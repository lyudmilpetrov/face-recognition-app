/*! For license information please see main.bc4848aa.js.LICENSE.txt */
(()=>{var e={353:e=>{e.exports=n;var t=null;try{t=new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0,97,115,109,1,0,0,0,1,13,2,96,0,1,127,96,4,127,127,127,127,1,127,3,7,6,0,1,1,1,1,1,6,6,1,127,1,65,0,11,7,50,6,3,109,117,108,0,1,5,100,105,118,95,115,0,2,5,100,105,118,95,117,0,3,5,114,101,109,95,115,0,4,5,114,101,109,95,117,0,5,8,103,101,116,95,104,105,103,104,0,0,10,191,1,6,4,0,35,0,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,126,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,127,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,128,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,129,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,130,34,4,66,32,135,167,36,0,32,4,167,11])),{}).exports}catch(N){}function n(e,t,n){this.low=0|e,this.high=0|t,this.unsigned=!!n}function a(e){return!0===(e&&e.__isLong__)}n.prototype.__isLong__,Object.defineProperty(n.prototype,"__isLong__",{value:!0}),n.isLong=a;var r={},o={};function s(e,t){var n,a,s;return t?(s=0<=(e>>>=0)&&e<256)&&(a=o[e])?a:(n=c(e,(0|e)<0?-1:0,!0),s&&(o[e]=n),n):(s=-128<=(e|=0)&&e<128)&&(a=r[e])?a:(n=c(e,e<0?-1:0,!1),s&&(r[e]=n),n)}function i(e,t){if(isNaN(e))return t?b:g;if(t){if(e<0)return b;if(e>=p)return k}else{if(e<=-f)return I;if(e+1>=f)return w}return e<0?i(-e,t).neg():c(e%h|0,e/h|0,t)}function c(e,t,a){return new n(e,t,a)}n.fromInt=s,n.fromNumber=i,n.fromBits=c;var l=Math.pow;function u(e,t,n){if(0===e.length)throw Error("empty string");if("NaN"===e||"Infinity"===e||"+Infinity"===e||"-Infinity"===e)return g;if("number"===typeof t?(n=t,t=!1):t=!!t,(n=n||10)<2||36<n)throw RangeError("radix");var a;if((a=e.indexOf("-"))>0)throw Error("interior hyphen");if(0===a)return u(e.substring(1),t,n).neg();for(var r=i(l(n,8)),o=g,s=0;s<e.length;s+=8){var c=Math.min(8,e.length-s),d=parseInt(e.substring(s,s+c),n);if(c<8){var h=i(l(n,c));o=o.mul(h).add(i(d))}else o=(o=o.mul(r)).add(i(d))}return o.unsigned=t,o}function d(e,t){return"number"===typeof e?i(e,t):"string"===typeof e?u(e,t):c(e.low,e.high,"boolean"===typeof t?t:e.unsigned)}n.fromString=u,n.fromValue=d;var h=4294967296,p=h*h,f=p/2,m=s(1<<24),g=s(0);n.ZERO=g;var b=s(0,!0);n.UZERO=b;var y=s(1);n.ONE=y;var x=s(1,!0);n.UONE=x;var v=s(-1);n.NEG_ONE=v;var w=c(-1,2147483647,!1);n.MAX_VALUE=w;var k=c(-1,-1,!0);n.MAX_UNSIGNED_VALUE=k;var I=c(0,-2147483648,!1);n.MIN_VALUE=I;var S=n.prototype;S.toInt=function(){return this.unsigned?this.low>>>0:this.low},S.toNumber=function(){return this.unsigned?(this.high>>>0)*h+(this.low>>>0):this.high*h+(this.low>>>0)},S.toString=function(e){if((e=e||10)<2||36<e)throw RangeError("radix");if(this.isZero())return"0";if(this.isNegative()){if(this.eq(I)){var t=i(e),n=this.div(t),a=n.mul(t).sub(this);return n.toString(e)+a.toInt().toString(e)}return"-"+this.neg().toString(e)}for(var r=i(l(e,6),this.unsigned),o=this,s="";;){var c=o.div(r),u=(o.sub(c.mul(r)).toInt()>>>0).toString(e);if((o=c).isZero())return u+s;for(;u.length<6;)u="0"+u;s=""+u+s}},S.getHighBits=function(){return this.high},S.getHighBitsUnsigned=function(){return this.high>>>0},S.getLowBits=function(){return this.low},S.getLowBitsUnsigned=function(){return this.low>>>0},S.getNumBitsAbs=function(){if(this.isNegative())return this.eq(I)?64:this.neg().getNumBitsAbs();for(var e=0!=this.high?this.high:this.low,t=31;t>0&&0==(e&1<<t);t--);return 0!=this.high?t+33:t+1},S.isZero=function(){return 0===this.high&&0===this.low},S.eqz=S.isZero,S.isNegative=function(){return!this.unsigned&&this.high<0},S.isPositive=function(){return this.unsigned||this.high>=0},S.isOdd=function(){return 1===(1&this.low)},S.isEven=function(){return 0===(1&this.low)},S.equals=function(e){return a(e)||(e=d(e)),(this.unsigned===e.unsigned||this.high>>>31!==1||e.high>>>31!==1)&&(this.high===e.high&&this.low===e.low)},S.eq=S.equals,S.notEquals=function(e){return!this.eq(e)},S.neq=S.notEquals,S.ne=S.notEquals,S.lessThan=function(e){return this.comp(e)<0},S.lt=S.lessThan,S.lessThanOrEqual=function(e){return this.comp(e)<=0},S.lte=S.lessThanOrEqual,S.le=S.lessThanOrEqual,S.greaterThan=function(e){return this.comp(e)>0},S.gt=S.greaterThan,S.greaterThanOrEqual=function(e){return this.comp(e)>=0},S.gte=S.greaterThanOrEqual,S.ge=S.greaterThanOrEqual,S.compare=function(e){if(a(e)||(e=d(e)),this.eq(e))return 0;var t=this.isNegative(),n=e.isNegative();return t&&!n?-1:!t&&n?1:this.unsigned?e.high>>>0>this.high>>>0||e.high===this.high&&e.low>>>0>this.low>>>0?-1:1:this.sub(e).isNegative()?-1:1},S.comp=S.compare,S.negate=function(){return!this.unsigned&&this.eq(I)?I:this.not().add(y)},S.neg=S.negate,S.add=function(e){a(e)||(e=d(e));var t=this.high>>>16,n=65535&this.high,r=this.low>>>16,o=65535&this.low,s=e.high>>>16,i=65535&e.high,l=e.low>>>16,u=0,h=0,p=0,f=0;return p+=(f+=o+(65535&e.low))>>>16,h+=(p+=r+l)>>>16,u+=(h+=n+i)>>>16,u+=t+s,c((p&=65535)<<16|(f&=65535),(u&=65535)<<16|(h&=65535),this.unsigned)},S.subtract=function(e){return a(e)||(e=d(e)),this.add(e.neg())},S.sub=S.subtract,S.multiply=function(e){if(this.isZero())return g;if(a(e)||(e=d(e)),t)return c(t.mul(this.low,this.high,e.low,e.high),t.get_high(),this.unsigned);if(e.isZero())return g;if(this.eq(I))return e.isOdd()?I:g;if(e.eq(I))return this.isOdd()?I:g;if(this.isNegative())return e.isNegative()?this.neg().mul(e.neg()):this.neg().mul(e).neg();if(e.isNegative())return this.mul(e.neg()).neg();if(this.lt(m)&&e.lt(m))return i(this.toNumber()*e.toNumber(),this.unsigned);var n=this.high>>>16,r=65535&this.high,o=this.low>>>16,s=65535&this.low,l=e.high>>>16,u=65535&e.high,h=e.low>>>16,p=65535&e.low,f=0,b=0,y=0,x=0;return y+=(x+=s*p)>>>16,b+=(y+=o*p)>>>16,y&=65535,b+=(y+=s*h)>>>16,f+=(b+=r*p)>>>16,b&=65535,f+=(b+=o*h)>>>16,b&=65535,f+=(b+=s*u)>>>16,f+=n*p+r*h+o*u+s*l,c((y&=65535)<<16|(x&=65535),(f&=65535)<<16|(b&=65535),this.unsigned)},S.mul=S.multiply,S.divide=function(e){if(a(e)||(e=d(e)),e.isZero())throw Error("division by zero");var n,r,o;if(t)return this.unsigned||-2147483648!==this.high||-1!==e.low||-1!==e.high?c((this.unsigned?t.div_u:t.div_s)(this.low,this.high,e.low,e.high),t.get_high(),this.unsigned):this;if(this.isZero())return this.unsigned?b:g;if(this.unsigned){if(e.unsigned||(e=e.toUnsigned()),e.gt(this))return b;if(e.gt(this.shru(1)))return x;o=b}else{if(this.eq(I))return e.eq(y)||e.eq(v)?I:e.eq(I)?y:(n=this.shr(1).div(e).shl(1)).eq(g)?e.isNegative()?y:v:(r=this.sub(e.mul(n)),o=n.add(r.div(e)));if(e.eq(I))return this.unsigned?b:g;if(this.isNegative())return e.isNegative()?this.neg().div(e.neg()):this.neg().div(e).neg();if(e.isNegative())return this.div(e.neg()).neg();o=g}for(r=this;r.gte(e);){n=Math.max(1,Math.floor(r.toNumber()/e.toNumber()));for(var s=Math.ceil(Math.log(n)/Math.LN2),u=s<=48?1:l(2,s-48),h=i(n),p=h.mul(e);p.isNegative()||p.gt(r);)p=(h=i(n-=u,this.unsigned)).mul(e);h.isZero()&&(h=y),o=o.add(h),r=r.sub(p)}return o},S.div=S.divide,S.modulo=function(e){return a(e)||(e=d(e)),t?c((this.unsigned?t.rem_u:t.rem_s)(this.low,this.high,e.low,e.high),t.get_high(),this.unsigned):this.sub(this.div(e).mul(e))},S.mod=S.modulo,S.rem=S.modulo,S.not=function(){return c(~this.low,~this.high,this.unsigned)},S.and=function(e){return a(e)||(e=d(e)),c(this.low&e.low,this.high&e.high,this.unsigned)},S.or=function(e){return a(e)||(e=d(e)),c(this.low|e.low,this.high|e.high,this.unsigned)},S.xor=function(e){return a(e)||(e=d(e)),c(this.low^e.low,this.high^e.high,this.unsigned)},S.shiftLeft=function(e){return a(e)&&(e=e.toInt()),0===(e&=63)?this:e<32?c(this.low<<e,this.high<<e|this.low>>>32-e,this.unsigned):c(0,this.low<<e-32,this.unsigned)},S.shl=S.shiftLeft,S.shiftRight=function(e){return a(e)&&(e=e.toInt()),0===(e&=63)?this:e<32?c(this.low>>>e|this.high<<32-e,this.high>>e,this.unsigned):c(this.high>>e-32,this.high>=0?0:-1,this.unsigned)},S.shr=S.shiftRight,S.shiftRightUnsigned=function(e){if(a(e)&&(e=e.toInt()),0===(e&=63))return this;var t=this.high;return e<32?c(this.low>>>e|t<<32-e,t>>>e,this.unsigned):c(32===e?t:t>>>e-32,0,this.unsigned)},S.shru=S.shiftRightUnsigned,S.shr_u=S.shiftRightUnsigned,S.toSigned=function(){return this.unsigned?c(this.low,this.high,!1):this},S.toUnsigned=function(){return this.unsigned?this:c(this.low,this.high,!0)},S.toBytes=function(e){return e?this.toBytesLE():this.toBytesBE()},S.toBytesLE=function(){var e=this.high,t=this.low;return[255&t,t>>>8&255,t>>>16&255,t>>>24,255&e,e>>>8&255,e>>>16&255,e>>>24]},S.toBytesBE=function(){var e=this.high,t=this.low;return[e>>>24,e>>>16&255,e>>>8&255,255&e,t>>>24,t>>>16&255,t>>>8&255,255&t]},n.fromBytes=function(e,t,a){return a?n.fromBytesLE(e,t):n.fromBytesBE(e,t)},n.fromBytesLE=function(e,t){return new n(e[0]|e[1]<<8|e[2]<<16|e[3]<<24,e[4]|e[5]<<8|e[6]<<16|e[7]<<24,t)},n.fromBytesBE=function(e,t){return new n(e[4]<<24|e[5]<<16|e[6]<<8|e[7],e[0]<<24|e[1]<<16|e[2]<<8|e[3],t)}},730:(e,t,n)=>{"use strict";var a=n(43),r=n(853);function o(e){for(var t="https://reactjs.org/docs/error-decoder.html?invariant="+e,n=1;n<arguments.length;n++)t+="&args[]="+encodeURIComponent(arguments[n]);return"Minified React error #"+e+"; visit "+t+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}var s=new Set,i={};function c(e,t){l(e,t),l(e+"Capture",t)}function l(e,t){for(i[e]=t,e=0;e<t.length;e++)s.add(t[e])}var u=!("undefined"===typeof window||"undefined"===typeof window.document||"undefined"===typeof window.document.createElement),d=Object.prototype.hasOwnProperty,h=/^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/,p={},f={};function m(e,t,n,a,r,o,s){this.acceptsBooleans=2===t||3===t||4===t,this.attributeName=a,this.attributeNamespace=r,this.mustUseProperty=n,this.propertyName=e,this.type=t,this.sanitizeURL=o,this.removeEmptyString=s}var g={};"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach((function(e){g[e]=new m(e,0,!1,e,null,!1,!1)})),[["acceptCharset","accept-charset"],["className","class"],["htmlFor","for"],["httpEquiv","http-equiv"]].forEach((function(e){var t=e[0];g[t]=new m(t,1,!1,e[1],null,!1,!1)})),["contentEditable","draggable","spellCheck","value"].forEach((function(e){g[e]=new m(e,2,!1,e.toLowerCase(),null,!1,!1)})),["autoReverse","externalResourcesRequired","focusable","preserveAlpha"].forEach((function(e){g[e]=new m(e,2,!1,e,null,!1,!1)})),"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach((function(e){g[e]=new m(e,3,!1,e.toLowerCase(),null,!1,!1)})),["checked","multiple","muted","selected"].forEach((function(e){g[e]=new m(e,3,!0,e,null,!1,!1)})),["capture","download"].forEach((function(e){g[e]=new m(e,4,!1,e,null,!1,!1)})),["cols","rows","size","span"].forEach((function(e){g[e]=new m(e,6,!1,e,null,!1,!1)})),["rowSpan","start"].forEach((function(e){g[e]=new m(e,5,!1,e.toLowerCase(),null,!1,!1)}));var b=/[\-:]([a-z])/g;function y(e){return e[1].toUpperCase()}function x(e,t,n,a){var r=g.hasOwnProperty(t)?g[t]:null;(null!==r?0!==r.type:a||!(2<t.length)||"o"!==t[0]&&"O"!==t[0]||"n"!==t[1]&&"N"!==t[1])&&(function(e,t,n,a){if(null===t||"undefined"===typeof t||function(e,t,n,a){if(null!==n&&0===n.type)return!1;switch(typeof t){case"function":case"symbol":return!0;case"boolean":return!a&&(null!==n?!n.acceptsBooleans:"data-"!==(e=e.toLowerCase().slice(0,5))&&"aria-"!==e);default:return!1}}(e,t,n,a))return!0;if(a)return!1;if(null!==n)switch(n.type){case 3:return!t;case 4:return!1===t;case 5:return isNaN(t);case 6:return isNaN(t)||1>t}return!1}(t,n,r,a)&&(n=null),a||null===r?function(e){return!!d.call(f,e)||!d.call(p,e)&&(h.test(e)?f[e]=!0:(p[e]=!0,!1))}(t)&&(null===n?e.removeAttribute(t):e.setAttribute(t,""+n)):r.mustUseProperty?e[r.propertyName]=null===n?3!==r.type&&"":n:(t=r.attributeName,a=r.attributeNamespace,null===n?e.removeAttribute(t):(n=3===(r=r.type)||4===r&&!0===n?"":""+n,a?e.setAttributeNS(a,t,n):e.setAttribute(t,n))))}"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach((function(e){var t=e.replace(b,y);g[t]=new m(t,1,!1,e,null,!1,!1)})),"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach((function(e){var t=e.replace(b,y);g[t]=new m(t,1,!1,e,"http://www.w3.org/1999/xlink",!1,!1)})),["xml:base","xml:lang","xml:space"].forEach((function(e){var t=e.replace(b,y);g[t]=new m(t,1,!1,e,"http://www.w3.org/XML/1998/namespace",!1,!1)})),["tabIndex","crossOrigin"].forEach((function(e){g[e]=new m(e,1,!1,e.toLowerCase(),null,!1,!1)})),g.xlinkHref=new m("xlinkHref",1,!1,"xlink:href","http://www.w3.org/1999/xlink",!0,!1),["src","href","action","formAction"].forEach((function(e){g[e]=new m(e,1,!1,e.toLowerCase(),null,!0,!0)}));var v=a.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED,w=Symbol.for("react.element"),k=Symbol.for("react.portal"),I=Symbol.for("react.fragment"),S=Symbol.for("react.strict_mode"),N=Symbol.for("react.profiler"),C=Symbol.for("react.provider"),T=Symbol.for("react.context"),E=Symbol.for("react.forward_ref"),R=Symbol.for("react.suspense"),_=Symbol.for("react.suspense_list"),A=Symbol.for("react.memo"),F=Symbol.for("react.lazy");Symbol.for("react.scope"),Symbol.for("react.debug_trace_mode");var O=Symbol.for("react.offscreen");Symbol.for("react.legacy_hidden"),Symbol.for("react.cache"),Symbol.for("react.tracing_marker");var D=Symbol.iterator;function M(e){return null===e||"object"!==typeof e?null:"function"===typeof(e=D&&e[D]||e["@@iterator"])?e:null}var L,P=Object.assign;function z(e){if(void 0===L)try{throw Error()}catch(n){var t=n.stack.trim().match(/\n( *(at )?)/);L=t&&t[1]||""}return"\n"+L+e}var B=!1;function W(e,t){if(!e||B)return"";B=!0;var n=Error.prepareStackTrace;Error.prepareStackTrace=void 0;try{if(t)if(t=function(){throw Error()},Object.defineProperty(t.prototype,"props",{set:function(){throw Error()}}),"object"===typeof Reflect&&Reflect.construct){try{Reflect.construct(t,[])}catch(l){var a=l}Reflect.construct(e,[],t)}else{try{t.call()}catch(l){a=l}e.call(t.prototype)}else{try{throw Error()}catch(l){a=l}e()}}catch(l){if(l&&a&&"string"===typeof l.stack){for(var r=l.stack.split("\n"),o=a.stack.split("\n"),s=r.length-1,i=o.length-1;1<=s&&0<=i&&r[s]!==o[i];)i--;for(;1<=s&&0<=i;s--,i--)if(r[s]!==o[i]){if(1!==s||1!==i)do{if(s--,0>--i||r[s]!==o[i]){var c="\n"+r[s].replace(" at new "," at ");return e.displayName&&c.includes("<anonymous>")&&(c=c.replace("<anonymous>",e.displayName)),c}}while(1<=s&&0<=i);break}}}finally{B=!1,Error.prepareStackTrace=n}return(e=e?e.displayName||e.name:"")?z(e):""}function V(e){switch(e.tag){case 5:return z(e.type);case 16:return z("Lazy");case 13:return z("Suspense");case 19:return z("SuspenseList");case 0:case 2:case 15:return e=W(e.type,!1);case 11:return e=W(e.type.render,!1);case 1:return e=W(e.type,!0);default:return""}}function U(e){if(null==e)return null;if("function"===typeof e)return e.displayName||e.name||null;if("string"===typeof e)return e;switch(e){case I:return"Fragment";case k:return"Portal";case N:return"Profiler";case S:return"StrictMode";case R:return"Suspense";case _:return"SuspenseList"}if("object"===typeof e)switch(e.$$typeof){case T:return(e.displayName||"Context")+".Consumer";case C:return(e._context.displayName||"Context")+".Provider";case E:var t=e.render;return(e=e.displayName)||(e=""!==(e=t.displayName||t.name||"")?"ForwardRef("+e+")":"ForwardRef"),e;case A:return null!==(t=e.displayName||null)?t:U(e.type)||"Memo";case F:t=e._payload,e=e._init;try{return U(e(t))}catch(n){}}return null}function G(e){var t=e.type;switch(e.tag){case 24:return"Cache";case 9:return(t.displayName||"Context")+".Consumer";case 10:return(t._context.displayName||"Context")+".Provider";case 18:return"DehydratedFragment";case 11:return e=(e=t.render).displayName||e.name||"",t.displayName||(""!==e?"ForwardRef("+e+")":"ForwardRef");case 7:return"Fragment";case 5:return t;case 4:return"Portal";case 3:return"Root";case 6:return"Text";case 16:return U(t);case 8:return t===S?"StrictMode":"Mode";case 22:return"Offscreen";case 12:return"Profiler";case 21:return"Scope";case 13:return"Suspense";case 19:return"SuspenseList";case 25:return"TracingMarker";case 1:case 0:case 17:case 2:case 14:case 15:if("function"===typeof t)return t.displayName||t.name||null;if("string"===typeof t)return t}return null}function H(e){switch(typeof e){case"boolean":case"number":case"string":case"undefined":case"object":return e;default:return""}}function j(e){var t=e.type;return(e=e.nodeName)&&"input"===e.toLowerCase()&&("checkbox"===t||"radio"===t)}function K(e){e._valueTracker||(e._valueTracker=function(e){var t=j(e)?"checked":"value",n=Object.getOwnPropertyDescriptor(e.constructor.prototype,t),a=""+e[t];if(!e.hasOwnProperty(t)&&"undefined"!==typeof n&&"function"===typeof n.get&&"function"===typeof n.set){var r=n.get,o=n.set;return Object.defineProperty(e,t,{configurable:!0,get:function(){return r.call(this)},set:function(e){a=""+e,o.call(this,e)}}),Object.defineProperty(e,t,{enumerable:n.enumerable}),{getValue:function(){return a},setValue:function(e){a=""+e},stopTracking:function(){e._valueTracker=null,delete e[t]}}}}(e))}function q(e){if(!e)return!1;var t=e._valueTracker;if(!t)return!0;var n=t.getValue(),a="";return e&&(a=j(e)?e.checked?"true":"false":e.value),(e=a)!==n&&(t.setValue(e),!0)}function X(e){if("undefined"===typeof(e=e||("undefined"!==typeof document?document:void 0)))return null;try{return e.activeElement||e.body}catch(t){return e.body}}function Y(e,t){var n=t.checked;return P({},t,{defaultChecked:void 0,defaultValue:void 0,value:void 0,checked:null!=n?n:e._wrapperState.initialChecked})}function Q(e,t){var n=null==t.defaultValue?"":t.defaultValue,a=null!=t.checked?t.checked:t.defaultChecked;n=H(null!=t.value?t.value:n),e._wrapperState={initialChecked:a,initialValue:n,controlled:"checkbox"===t.type||"radio"===t.type?null!=t.checked:null!=t.value}}function J(e,t){null!=(t=t.checked)&&x(e,"checked",t,!1)}function Z(e,t){J(e,t);var n=H(t.value),a=t.type;if(null!=n)"number"===a?(0===n&&""===e.value||e.value!=n)&&(e.value=""+n):e.value!==""+n&&(e.value=""+n);else if("submit"===a||"reset"===a)return void e.removeAttribute("value");t.hasOwnProperty("value")?ee(e,t.type,n):t.hasOwnProperty("defaultValue")&&ee(e,t.type,H(t.defaultValue)),null==t.checked&&null!=t.defaultChecked&&(e.defaultChecked=!!t.defaultChecked)}function $(e,t,n){if(t.hasOwnProperty("value")||t.hasOwnProperty("defaultValue")){var a=t.type;if(!("submit"!==a&&"reset"!==a||void 0!==t.value&&null!==t.value))return;t=""+e._wrapperState.initialValue,n||t===e.value||(e.value=t),e.defaultValue=t}""!==(n=e.name)&&(e.name=""),e.defaultChecked=!!e._wrapperState.initialChecked,""!==n&&(e.name=n)}function ee(e,t,n){"number"===t&&X(e.ownerDocument)===e||(null==n?e.defaultValue=""+e._wrapperState.initialValue:e.defaultValue!==""+n&&(e.defaultValue=""+n))}var te=Array.isArray;function ne(e,t,n,a){if(e=e.options,t){t={};for(var r=0;r<n.length;r++)t["$"+n[r]]=!0;for(n=0;n<e.length;n++)r=t.hasOwnProperty("$"+e[n].value),e[n].selected!==r&&(e[n].selected=r),r&&a&&(e[n].defaultSelected=!0)}else{for(n=""+H(n),t=null,r=0;r<e.length;r++){if(e[r].value===n)return e[r].selected=!0,void(a&&(e[r].defaultSelected=!0));null!==t||e[r].disabled||(t=e[r])}null!==t&&(t.selected=!0)}}function ae(e,t){if(null!=t.dangerouslySetInnerHTML)throw Error(o(91));return P({},t,{value:void 0,defaultValue:void 0,children:""+e._wrapperState.initialValue})}function re(e,t){var n=t.value;if(null==n){if(n=t.children,t=t.defaultValue,null!=n){if(null!=t)throw Error(o(92));if(te(n)){if(1<n.length)throw Error(o(93));n=n[0]}t=n}null==t&&(t=""),n=t}e._wrapperState={initialValue:H(n)}}function oe(e,t){var n=H(t.value),a=H(t.defaultValue);null!=n&&((n=""+n)!==e.value&&(e.value=n),null==t.defaultValue&&e.defaultValue!==n&&(e.defaultValue=n)),null!=a&&(e.defaultValue=""+a)}function se(e){var t=e.textContent;t===e._wrapperState.initialValue&&""!==t&&null!==t&&(e.value=t)}function ie(e){switch(e){case"svg":return"http://www.w3.org/2000/svg";case"math":return"http://www.w3.org/1998/Math/MathML";default:return"http://www.w3.org/1999/xhtml"}}function ce(e,t){return null==e||"http://www.w3.org/1999/xhtml"===e?ie(t):"http://www.w3.org/2000/svg"===e&&"foreignObject"===t?"http://www.w3.org/1999/xhtml":e}var le,ue,de=(ue=function(e,t){if("http://www.w3.org/2000/svg"!==e.namespaceURI||"innerHTML"in e)e.innerHTML=t;else{for((le=le||document.createElement("div")).innerHTML="<svg>"+t.valueOf().toString()+"</svg>",t=le.firstChild;e.firstChild;)e.removeChild(e.firstChild);for(;t.firstChild;)e.appendChild(t.firstChild)}},"undefined"!==typeof MSApp&&MSApp.execUnsafeLocalFunction?function(e,t,n,a){MSApp.execUnsafeLocalFunction((function(){return ue(e,t)}))}:ue);function he(e,t){if(t){var n=e.firstChild;if(n&&n===e.lastChild&&3===n.nodeType)return void(n.nodeValue=t)}e.textContent=t}var pe={animationIterationCount:!0,aspectRatio:!0,borderImageOutset:!0,borderImageSlice:!0,borderImageWidth:!0,boxFlex:!0,boxFlexGroup:!0,boxOrdinalGroup:!0,columnCount:!0,columns:!0,flex:!0,flexGrow:!0,flexPositive:!0,flexShrink:!0,flexNegative:!0,flexOrder:!0,gridArea:!0,gridRow:!0,gridRowEnd:!0,gridRowSpan:!0,gridRowStart:!0,gridColumn:!0,gridColumnEnd:!0,gridColumnSpan:!0,gridColumnStart:!0,fontWeight:!0,lineClamp:!0,lineHeight:!0,opacity:!0,order:!0,orphans:!0,tabSize:!0,widows:!0,zIndex:!0,zoom:!0,fillOpacity:!0,floodOpacity:!0,stopOpacity:!0,strokeDasharray:!0,strokeDashoffset:!0,strokeMiterlimit:!0,strokeOpacity:!0,strokeWidth:!0},fe=["Webkit","ms","Moz","O"];function me(e,t,n){return null==t||"boolean"===typeof t||""===t?"":n||"number"!==typeof t||0===t||pe.hasOwnProperty(e)&&pe[e]?(""+t).trim():t+"px"}function ge(e,t){for(var n in e=e.style,t)if(t.hasOwnProperty(n)){var a=0===n.indexOf("--"),r=me(n,t[n],a);"float"===n&&(n="cssFloat"),a?e.setProperty(n,r):e[n]=r}}Object.keys(pe).forEach((function(e){fe.forEach((function(t){t=t+e.charAt(0).toUpperCase()+e.substring(1),pe[t]=pe[e]}))}));var be=P({menuitem:!0},{area:!0,base:!0,br:!0,col:!0,embed:!0,hr:!0,img:!0,input:!0,keygen:!0,link:!0,meta:!0,param:!0,source:!0,track:!0,wbr:!0});function ye(e,t){if(t){if(be[e]&&(null!=t.children||null!=t.dangerouslySetInnerHTML))throw Error(o(137,e));if(null!=t.dangerouslySetInnerHTML){if(null!=t.children)throw Error(o(60));if("object"!==typeof t.dangerouslySetInnerHTML||!("__html"in t.dangerouslySetInnerHTML))throw Error(o(61))}if(null!=t.style&&"object"!==typeof t.style)throw Error(o(62))}}function xe(e,t){if(-1===e.indexOf("-"))return"string"===typeof t.is;switch(e){case"annotation-xml":case"color-profile":case"font-face":case"font-face-src":case"font-face-uri":case"font-face-format":case"font-face-name":case"missing-glyph":return!1;default:return!0}}var ve=null;function we(e){return(e=e.target||e.srcElement||window).correspondingUseElement&&(e=e.correspondingUseElement),3===e.nodeType?e.parentNode:e}var ke=null,Ie=null,Se=null;function Ne(e){if(e=xr(e)){if("function"!==typeof ke)throw Error(o(280));var t=e.stateNode;t&&(t=wr(t),ke(e.stateNode,e.type,t))}}function Ce(e){Ie?Se?Se.push(e):Se=[e]:Ie=e}function Te(){if(Ie){var e=Ie,t=Se;if(Se=Ie=null,Ne(e),t)for(e=0;e<t.length;e++)Ne(t[e])}}function Ee(e,t){return e(t)}function Re(){}var _e=!1;function Ae(e,t,n){if(_e)return e(t,n);_e=!0;try{return Ee(e,t,n)}finally{_e=!1,(null!==Ie||null!==Se)&&(Re(),Te())}}function Fe(e,t){var n=e.stateNode;if(null===n)return null;var a=wr(n);if(null===a)return null;n=a[t];e:switch(t){case"onClick":case"onClickCapture":case"onDoubleClick":case"onDoubleClickCapture":case"onMouseDown":case"onMouseDownCapture":case"onMouseMove":case"onMouseMoveCapture":case"onMouseUp":case"onMouseUpCapture":case"onMouseEnter":(a=!a.disabled)||(a=!("button"===(e=e.type)||"input"===e||"select"===e||"textarea"===e)),e=!a;break e;default:e=!1}if(e)return null;if(n&&"function"!==typeof n)throw Error(o(231,t,typeof n));return n}var Oe=!1;if(u)try{var De={};Object.defineProperty(De,"passive",{get:function(){Oe=!0}}),window.addEventListener("test",De,De),window.removeEventListener("test",De,De)}catch(ue){Oe=!1}function Me(e,t,n,a,r,o,s,i,c){var l=Array.prototype.slice.call(arguments,3);try{t.apply(n,l)}catch(u){this.onError(u)}}var Le=!1,Pe=null,ze=!1,Be=null,We={onError:function(e){Le=!0,Pe=e}};function Ve(e,t,n,a,r,o,s,i,c){Le=!1,Pe=null,Me.apply(We,arguments)}function Ue(e){var t=e,n=e;if(e.alternate)for(;t.return;)t=t.return;else{e=t;do{0!==(4098&(t=e).flags)&&(n=t.return),e=t.return}while(e)}return 3===t.tag?n:null}function Ge(e){if(13===e.tag){var t=e.memoizedState;if(null===t&&(null!==(e=e.alternate)&&(t=e.memoizedState)),null!==t)return t.dehydrated}return null}function He(e){if(Ue(e)!==e)throw Error(o(188))}function je(e){return null!==(e=function(e){var t=e.alternate;if(!t){if(null===(t=Ue(e)))throw Error(o(188));return t!==e?null:e}for(var n=e,a=t;;){var r=n.return;if(null===r)break;var s=r.alternate;if(null===s){if(null!==(a=r.return)){n=a;continue}break}if(r.child===s.child){for(s=r.child;s;){if(s===n)return He(r),e;if(s===a)return He(r),t;s=s.sibling}throw Error(o(188))}if(n.return!==a.return)n=r,a=s;else{for(var i=!1,c=r.child;c;){if(c===n){i=!0,n=r,a=s;break}if(c===a){i=!0,a=r,n=s;break}c=c.sibling}if(!i){for(c=s.child;c;){if(c===n){i=!0,n=s,a=r;break}if(c===a){i=!0,a=s,n=r;break}c=c.sibling}if(!i)throw Error(o(189))}}if(n.alternate!==a)throw Error(o(190))}if(3!==n.tag)throw Error(o(188));return n.stateNode.current===n?e:t}(e))?Ke(e):null}function Ke(e){if(5===e.tag||6===e.tag)return e;for(e=e.child;null!==e;){var t=Ke(e);if(null!==t)return t;e=e.sibling}return null}var qe=r.unstable_scheduleCallback,Xe=r.unstable_cancelCallback,Ye=r.unstable_shouldYield,Qe=r.unstable_requestPaint,Je=r.unstable_now,Ze=r.unstable_getCurrentPriorityLevel,$e=r.unstable_ImmediatePriority,et=r.unstable_UserBlockingPriority,tt=r.unstable_NormalPriority,nt=r.unstable_LowPriority,at=r.unstable_IdlePriority,rt=null,ot=null;var st=Math.clz32?Math.clz32:function(e){return e>>>=0,0===e?32:31-(it(e)/ct|0)|0},it=Math.log,ct=Math.LN2;var lt=64,ut=4194304;function dt(e){switch(e&-e){case 1:return 1;case 2:return 2;case 4:return 4;case 8:return 8;case 16:return 16;case 32:return 32;case 64:case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:return 4194240&e;case 4194304:case 8388608:case 16777216:case 33554432:case 67108864:return 130023424&e;case 134217728:return 134217728;case 268435456:return 268435456;case 536870912:return 536870912;case 1073741824:return 1073741824;default:return e}}function ht(e,t){var n=e.pendingLanes;if(0===n)return 0;var a=0,r=e.suspendedLanes,o=e.pingedLanes,s=268435455&n;if(0!==s){var i=s&~r;0!==i?a=dt(i):0!==(o&=s)&&(a=dt(o))}else 0!==(s=n&~r)?a=dt(s):0!==o&&(a=dt(o));if(0===a)return 0;if(0!==t&&t!==a&&0===(t&r)&&((r=a&-a)>=(o=t&-t)||16===r&&0!==(4194240&o)))return t;if(0!==(4&a)&&(a|=16&n),0!==(t=e.entangledLanes))for(e=e.entanglements,t&=a;0<t;)r=1<<(n=31-st(t)),a|=e[n],t&=~r;return a}function pt(e,t){switch(e){case 1:case 2:case 4:return t+250;case 8:case 16:case 32:case 64:case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:return t+5e3;default:return-1}}function ft(e){return 0!==(e=-1073741825&e.pendingLanes)?e:1073741824&e?1073741824:0}function mt(){var e=lt;return 0===(4194240&(lt<<=1))&&(lt=64),e}function gt(e){for(var t=[],n=0;31>n;n++)t.push(e);return t}function bt(e,t,n){e.pendingLanes|=t,536870912!==t&&(e.suspendedLanes=0,e.pingedLanes=0),(e=e.eventTimes)[t=31-st(t)]=n}function yt(e,t){var n=e.entangledLanes|=t;for(e=e.entanglements;n;){var a=31-st(n),r=1<<a;r&t|e[a]&t&&(e[a]|=t),n&=~r}}var xt=0;function vt(e){return 1<(e&=-e)?4<e?0!==(268435455&e)?16:536870912:4:1}var wt,kt,It,St,Nt,Ct=!1,Tt=[],Et=null,Rt=null,_t=null,At=new Map,Ft=new Map,Ot=[],Dt="mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" ");function Mt(e,t){switch(e){case"focusin":case"focusout":Et=null;break;case"dragenter":case"dragleave":Rt=null;break;case"mouseover":case"mouseout":_t=null;break;case"pointerover":case"pointerout":At.delete(t.pointerId);break;case"gotpointercapture":case"lostpointercapture":Ft.delete(t.pointerId)}}function Lt(e,t,n,a,r,o){return null===e||e.nativeEvent!==o?(e={blockedOn:t,domEventName:n,eventSystemFlags:a,nativeEvent:o,targetContainers:[r]},null!==t&&(null!==(t=xr(t))&&kt(t)),e):(e.eventSystemFlags|=a,t=e.targetContainers,null!==r&&-1===t.indexOf(r)&&t.push(r),e)}function Pt(e){var t=yr(e.target);if(null!==t){var n=Ue(t);if(null!==n)if(13===(t=n.tag)){if(null!==(t=Ge(n)))return e.blockedOn=t,void Nt(e.priority,(function(){It(n)}))}else if(3===t&&n.stateNode.current.memoizedState.isDehydrated)return void(e.blockedOn=3===n.tag?n.stateNode.containerInfo:null)}e.blockedOn=null}function zt(e){if(null!==e.blockedOn)return!1;for(var t=e.targetContainers;0<t.length;){var n=Yt(e.domEventName,e.eventSystemFlags,t[0],e.nativeEvent);if(null!==n)return null!==(t=xr(n))&&kt(t),e.blockedOn=n,!1;var a=new(n=e.nativeEvent).constructor(n.type,n);ve=a,n.target.dispatchEvent(a),ve=null,t.shift()}return!0}function Bt(e,t,n){zt(e)&&n.delete(t)}function Wt(){Ct=!1,null!==Et&&zt(Et)&&(Et=null),null!==Rt&&zt(Rt)&&(Rt=null),null!==_t&&zt(_t)&&(_t=null),At.forEach(Bt),Ft.forEach(Bt)}function Vt(e,t){e.blockedOn===t&&(e.blockedOn=null,Ct||(Ct=!0,r.unstable_scheduleCallback(r.unstable_NormalPriority,Wt)))}function Ut(e){function t(t){return Vt(t,e)}if(0<Tt.length){Vt(Tt[0],e);for(var n=1;n<Tt.length;n++){var a=Tt[n];a.blockedOn===e&&(a.blockedOn=null)}}for(null!==Et&&Vt(Et,e),null!==Rt&&Vt(Rt,e),null!==_t&&Vt(_t,e),At.forEach(t),Ft.forEach(t),n=0;n<Ot.length;n++)(a=Ot[n]).blockedOn===e&&(a.blockedOn=null);for(;0<Ot.length&&null===(n=Ot[0]).blockedOn;)Pt(n),null===n.blockedOn&&Ot.shift()}var Gt=v.ReactCurrentBatchConfig,Ht=!0;function jt(e,t,n,a){var r=xt,o=Gt.transition;Gt.transition=null;try{xt=1,qt(e,t,n,a)}finally{xt=r,Gt.transition=o}}function Kt(e,t,n,a){var r=xt,o=Gt.transition;Gt.transition=null;try{xt=4,qt(e,t,n,a)}finally{xt=r,Gt.transition=o}}function qt(e,t,n,a){if(Ht){var r=Yt(e,t,n,a);if(null===r)Ha(e,t,a,Xt,n),Mt(e,a);else if(function(e,t,n,a,r){switch(t){case"focusin":return Et=Lt(Et,e,t,n,a,r),!0;case"dragenter":return Rt=Lt(Rt,e,t,n,a,r),!0;case"mouseover":return _t=Lt(_t,e,t,n,a,r),!0;case"pointerover":var o=r.pointerId;return At.set(o,Lt(At.get(o)||null,e,t,n,a,r)),!0;case"gotpointercapture":return o=r.pointerId,Ft.set(o,Lt(Ft.get(o)||null,e,t,n,a,r)),!0}return!1}(r,e,t,n,a))a.stopPropagation();else if(Mt(e,a),4&t&&-1<Dt.indexOf(e)){for(;null!==r;){var o=xr(r);if(null!==o&&wt(o),null===(o=Yt(e,t,n,a))&&Ha(e,t,a,Xt,n),o===r)break;r=o}null!==r&&a.stopPropagation()}else Ha(e,t,a,null,n)}}var Xt=null;function Yt(e,t,n,a){if(Xt=null,null!==(e=yr(e=we(a))))if(null===(t=Ue(e)))e=null;else if(13===(n=t.tag)){if(null!==(e=Ge(t)))return e;e=null}else if(3===n){if(t.stateNode.current.memoizedState.isDehydrated)return 3===t.tag?t.stateNode.containerInfo:null;e=null}else t!==e&&(e=null);return Xt=e,null}function Qt(e){switch(e){case"cancel":case"click":case"close":case"contextmenu":case"copy":case"cut":case"auxclick":case"dblclick":case"dragend":case"dragstart":case"drop":case"focusin":case"focusout":case"input":case"invalid":case"keydown":case"keypress":case"keyup":case"mousedown":case"mouseup":case"paste":case"pause":case"play":case"pointercancel":case"pointerdown":case"pointerup":case"ratechange":case"reset":case"resize":case"seeked":case"submit":case"touchcancel":case"touchend":case"touchstart":case"volumechange":case"change":case"selectionchange":case"textInput":case"compositionstart":case"compositionend":case"compositionupdate":case"beforeblur":case"afterblur":case"beforeinput":case"blur":case"fullscreenchange":case"focus":case"hashchange":case"popstate":case"select":case"selectstart":return 1;case"drag":case"dragenter":case"dragexit":case"dragleave":case"dragover":case"mousemove":case"mouseout":case"mouseover":case"pointermove":case"pointerout":case"pointerover":case"scroll":case"toggle":case"touchmove":case"wheel":case"mouseenter":case"mouseleave":case"pointerenter":case"pointerleave":return 4;case"message":switch(Ze()){case $e:return 1;case et:return 4;case tt:case nt:return 16;case at:return 536870912;default:return 16}default:return 16}}var Jt=null,Zt=null,$t=null;function en(){if($t)return $t;var e,t,n=Zt,a=n.length,r="value"in Jt?Jt.value:Jt.textContent,o=r.length;for(e=0;e<a&&n[e]===r[e];e++);var s=a-e;for(t=1;t<=s&&n[a-t]===r[o-t];t++);return $t=r.slice(e,1<t?1-t:void 0)}function tn(e){var t=e.keyCode;return"charCode"in e?0===(e=e.charCode)&&13===t&&(e=13):e=t,10===e&&(e=13),32<=e||13===e?e:0}function nn(){return!0}function an(){return!1}function rn(e){function t(t,n,a,r,o){for(var s in this._reactName=t,this._targetInst=a,this.type=n,this.nativeEvent=r,this.target=o,this.currentTarget=null,e)e.hasOwnProperty(s)&&(t=e[s],this[s]=t?t(r):r[s]);return this.isDefaultPrevented=(null!=r.defaultPrevented?r.defaultPrevented:!1===r.returnValue)?nn:an,this.isPropagationStopped=an,this}return P(t.prototype,{preventDefault:function(){this.defaultPrevented=!0;var e=this.nativeEvent;e&&(e.preventDefault?e.preventDefault():"unknown"!==typeof e.returnValue&&(e.returnValue=!1),this.isDefaultPrevented=nn)},stopPropagation:function(){var e=this.nativeEvent;e&&(e.stopPropagation?e.stopPropagation():"unknown"!==typeof e.cancelBubble&&(e.cancelBubble=!0),this.isPropagationStopped=nn)},persist:function(){},isPersistent:nn}),t}var on,sn,cn,ln={eventPhase:0,bubbles:0,cancelable:0,timeStamp:function(e){return e.timeStamp||Date.now()},defaultPrevented:0,isTrusted:0},un=rn(ln),dn=P({},ln,{view:0,detail:0}),hn=rn(dn),pn=P({},dn,{screenX:0,screenY:0,clientX:0,clientY:0,pageX:0,pageY:0,ctrlKey:0,shiftKey:0,altKey:0,metaKey:0,getModifierState:Nn,button:0,buttons:0,relatedTarget:function(e){return void 0===e.relatedTarget?e.fromElement===e.srcElement?e.toElement:e.fromElement:e.relatedTarget},movementX:function(e){return"movementX"in e?e.movementX:(e!==cn&&(cn&&"mousemove"===e.type?(on=e.screenX-cn.screenX,sn=e.screenY-cn.screenY):sn=on=0,cn=e),on)},movementY:function(e){return"movementY"in e?e.movementY:sn}}),fn=rn(pn),mn=rn(P({},pn,{dataTransfer:0})),gn=rn(P({},dn,{relatedTarget:0})),bn=rn(P({},ln,{animationName:0,elapsedTime:0,pseudoElement:0})),yn=P({},ln,{clipboardData:function(e){return"clipboardData"in e?e.clipboardData:window.clipboardData}}),xn=rn(yn),vn=rn(P({},ln,{data:0})),wn={Esc:"Escape",Spacebar:" ",Left:"ArrowLeft",Up:"ArrowUp",Right:"ArrowRight",Down:"ArrowDown",Del:"Delete",Win:"OS",Menu:"ContextMenu",Apps:"ContextMenu",Scroll:"ScrollLock",MozPrintableKey:"Unidentified"},kn={8:"Backspace",9:"Tab",12:"Clear",13:"Enter",16:"Shift",17:"Control",18:"Alt",19:"Pause",20:"CapsLock",27:"Escape",32:" ",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"ArrowLeft",38:"ArrowUp",39:"ArrowRight",40:"ArrowDown",45:"Insert",46:"Delete",112:"F1",113:"F2",114:"F3",115:"F4",116:"F5",117:"F6",118:"F7",119:"F8",120:"F9",121:"F10",122:"F11",123:"F12",144:"NumLock",145:"ScrollLock",224:"Meta"},In={Alt:"altKey",Control:"ctrlKey",Meta:"metaKey",Shift:"shiftKey"};function Sn(e){var t=this.nativeEvent;return t.getModifierState?t.getModifierState(e):!!(e=In[e])&&!!t[e]}function Nn(){return Sn}var Cn=P({},dn,{key:function(e){if(e.key){var t=wn[e.key]||e.key;if("Unidentified"!==t)return t}return"keypress"===e.type?13===(e=tn(e))?"Enter":String.fromCharCode(e):"keydown"===e.type||"keyup"===e.type?kn[e.keyCode]||"Unidentified":""},code:0,location:0,ctrlKey:0,shiftKey:0,altKey:0,metaKey:0,repeat:0,locale:0,getModifierState:Nn,charCode:function(e){return"keypress"===e.type?tn(e):0},keyCode:function(e){return"keydown"===e.type||"keyup"===e.type?e.keyCode:0},which:function(e){return"keypress"===e.type?tn(e):"keydown"===e.type||"keyup"===e.type?e.keyCode:0}}),Tn=rn(Cn),En=rn(P({},pn,{pointerId:0,width:0,height:0,pressure:0,tangentialPressure:0,tiltX:0,tiltY:0,twist:0,pointerType:0,isPrimary:0})),Rn=rn(P({},dn,{touches:0,targetTouches:0,changedTouches:0,altKey:0,metaKey:0,ctrlKey:0,shiftKey:0,getModifierState:Nn})),_n=rn(P({},ln,{propertyName:0,elapsedTime:0,pseudoElement:0})),An=P({},pn,{deltaX:function(e){return"deltaX"in e?e.deltaX:"wheelDeltaX"in e?-e.wheelDeltaX:0},deltaY:function(e){return"deltaY"in e?e.deltaY:"wheelDeltaY"in e?-e.wheelDeltaY:"wheelDelta"in e?-e.wheelDelta:0},deltaZ:0,deltaMode:0}),Fn=rn(An),On=[9,13,27,32],Dn=u&&"CompositionEvent"in window,Mn=null;u&&"documentMode"in document&&(Mn=document.documentMode);var Ln=u&&"TextEvent"in window&&!Mn,Pn=u&&(!Dn||Mn&&8<Mn&&11>=Mn),zn=String.fromCharCode(32),Bn=!1;function Wn(e,t){switch(e){case"keyup":return-1!==On.indexOf(t.keyCode);case"keydown":return 229!==t.keyCode;case"keypress":case"mousedown":case"focusout":return!0;default:return!1}}function Vn(e){return"object"===typeof(e=e.detail)&&"data"in e?e.data:null}var Un=!1;var Gn={color:!0,date:!0,datetime:!0,"datetime-local":!0,email:!0,month:!0,number:!0,password:!0,range:!0,search:!0,tel:!0,text:!0,time:!0,url:!0,week:!0};function Hn(e){var t=e&&e.nodeName&&e.nodeName.toLowerCase();return"input"===t?!!Gn[e.type]:"textarea"===t}function jn(e,t,n,a){Ce(a),0<(t=Ka(t,"onChange")).length&&(n=new un("onChange","change",null,n,a),e.push({event:n,listeners:t}))}var Kn=null,qn=null;function Xn(e){za(e,0)}function Yn(e){if(q(vr(e)))return e}function Qn(e,t){if("change"===e)return t}var Jn=!1;if(u){var Zn;if(u){var $n="oninput"in document;if(!$n){var ea=document.createElement("div");ea.setAttribute("oninput","return;"),$n="function"===typeof ea.oninput}Zn=$n}else Zn=!1;Jn=Zn&&(!document.documentMode||9<document.documentMode)}function ta(){Kn&&(Kn.detachEvent("onpropertychange",na),qn=Kn=null)}function na(e){if("value"===e.propertyName&&Yn(qn)){var t=[];jn(t,qn,e,we(e)),Ae(Xn,t)}}function aa(e,t,n){"focusin"===e?(ta(),qn=n,(Kn=t).attachEvent("onpropertychange",na)):"focusout"===e&&ta()}function ra(e){if("selectionchange"===e||"keyup"===e||"keydown"===e)return Yn(qn)}function oa(e,t){if("click"===e)return Yn(t)}function sa(e,t){if("input"===e||"change"===e)return Yn(t)}var ia="function"===typeof Object.is?Object.is:function(e,t){return e===t&&(0!==e||1/e===1/t)||e!==e&&t!==t};function ca(e,t){if(ia(e,t))return!0;if("object"!==typeof e||null===e||"object"!==typeof t||null===t)return!1;var n=Object.keys(e),a=Object.keys(t);if(n.length!==a.length)return!1;for(a=0;a<n.length;a++){var r=n[a];if(!d.call(t,r)||!ia(e[r],t[r]))return!1}return!0}function la(e){for(;e&&e.firstChild;)e=e.firstChild;return e}function ua(e,t){var n,a=la(e);for(e=0;a;){if(3===a.nodeType){if(n=e+a.textContent.length,e<=t&&n>=t)return{node:a,offset:t-e};e=n}e:{for(;a;){if(a.nextSibling){a=a.nextSibling;break e}a=a.parentNode}a=void 0}a=la(a)}}function da(e,t){return!(!e||!t)&&(e===t||(!e||3!==e.nodeType)&&(t&&3===t.nodeType?da(e,t.parentNode):"contains"in e?e.contains(t):!!e.compareDocumentPosition&&!!(16&e.compareDocumentPosition(t))))}function ha(){for(var e=window,t=X();t instanceof e.HTMLIFrameElement;){try{var n="string"===typeof t.contentWindow.location.href}catch(a){n=!1}if(!n)break;t=X((e=t.contentWindow).document)}return t}function pa(e){var t=e&&e.nodeName&&e.nodeName.toLowerCase();return t&&("input"===t&&("text"===e.type||"search"===e.type||"tel"===e.type||"url"===e.type||"password"===e.type)||"textarea"===t||"true"===e.contentEditable)}function fa(e){var t=ha(),n=e.focusedElem,a=e.selectionRange;if(t!==n&&n&&n.ownerDocument&&da(n.ownerDocument.documentElement,n)){if(null!==a&&pa(n))if(t=a.start,void 0===(e=a.end)&&(e=t),"selectionStart"in n)n.selectionStart=t,n.selectionEnd=Math.min(e,n.value.length);else if((e=(t=n.ownerDocument||document)&&t.defaultView||window).getSelection){e=e.getSelection();var r=n.textContent.length,o=Math.min(a.start,r);a=void 0===a.end?o:Math.min(a.end,r),!e.extend&&o>a&&(r=a,a=o,o=r),r=ua(n,o);var s=ua(n,a);r&&s&&(1!==e.rangeCount||e.anchorNode!==r.node||e.anchorOffset!==r.offset||e.focusNode!==s.node||e.focusOffset!==s.offset)&&((t=t.createRange()).setStart(r.node,r.offset),e.removeAllRanges(),o>a?(e.addRange(t),e.extend(s.node,s.offset)):(t.setEnd(s.node,s.offset),e.addRange(t)))}for(t=[],e=n;e=e.parentNode;)1===e.nodeType&&t.push({element:e,left:e.scrollLeft,top:e.scrollTop});for("function"===typeof n.focus&&n.focus(),n=0;n<t.length;n++)(e=t[n]).element.scrollLeft=e.left,e.element.scrollTop=e.top}}var ma=u&&"documentMode"in document&&11>=document.documentMode,ga=null,ba=null,ya=null,xa=!1;function va(e,t,n){var a=n.window===n?n.document:9===n.nodeType?n:n.ownerDocument;xa||null==ga||ga!==X(a)||("selectionStart"in(a=ga)&&pa(a)?a={start:a.selectionStart,end:a.selectionEnd}:a={anchorNode:(a=(a.ownerDocument&&a.ownerDocument.defaultView||window).getSelection()).anchorNode,anchorOffset:a.anchorOffset,focusNode:a.focusNode,focusOffset:a.focusOffset},ya&&ca(ya,a)||(ya=a,0<(a=Ka(ba,"onSelect")).length&&(t=new un("onSelect","select",null,t,n),e.push({event:t,listeners:a}),t.target=ga)))}function wa(e,t){var n={};return n[e.toLowerCase()]=t.toLowerCase(),n["Webkit"+e]="webkit"+t,n["Moz"+e]="moz"+t,n}var ka={animationend:wa("Animation","AnimationEnd"),animationiteration:wa("Animation","AnimationIteration"),animationstart:wa("Animation","AnimationStart"),transitionend:wa("Transition","TransitionEnd")},Ia={},Sa={};function Na(e){if(Ia[e])return Ia[e];if(!ka[e])return e;var t,n=ka[e];for(t in n)if(n.hasOwnProperty(t)&&t in Sa)return Ia[e]=n[t];return e}u&&(Sa=document.createElement("div").style,"AnimationEvent"in window||(delete ka.animationend.animation,delete ka.animationiteration.animation,delete ka.animationstart.animation),"TransitionEvent"in window||delete ka.transitionend.transition);var Ca=Na("animationend"),Ta=Na("animationiteration"),Ea=Na("animationstart"),Ra=Na("transitionend"),_a=new Map,Aa="abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");function Fa(e,t){_a.set(e,t),c(t,[e])}for(var Oa=0;Oa<Aa.length;Oa++){var Da=Aa[Oa];Fa(Da.toLowerCase(),"on"+(Da[0].toUpperCase()+Da.slice(1)))}Fa(Ca,"onAnimationEnd"),Fa(Ta,"onAnimationIteration"),Fa(Ea,"onAnimationStart"),Fa("dblclick","onDoubleClick"),Fa("focusin","onFocus"),Fa("focusout","onBlur"),Fa(Ra,"onTransitionEnd"),l("onMouseEnter",["mouseout","mouseover"]),l("onMouseLeave",["mouseout","mouseover"]),l("onPointerEnter",["pointerout","pointerover"]),l("onPointerLeave",["pointerout","pointerover"]),c("onChange","change click focusin focusout input keydown keyup selectionchange".split(" ")),c("onSelect","focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" ")),c("onBeforeInput",["compositionend","keypress","textInput","paste"]),c("onCompositionEnd","compositionend focusout keydown keypress keyup mousedown".split(" ")),c("onCompositionStart","compositionstart focusout keydown keypress keyup mousedown".split(" ")),c("onCompositionUpdate","compositionupdate focusout keydown keypress keyup mousedown".split(" "));var Ma="abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "),La=new Set("cancel close invalid load scroll toggle".split(" ").concat(Ma));function Pa(e,t,n){var a=e.type||"unknown-event";e.currentTarget=n,function(e,t,n,a,r,s,i,c,l){if(Ve.apply(this,arguments),Le){if(!Le)throw Error(o(198));var u=Pe;Le=!1,Pe=null,ze||(ze=!0,Be=u)}}(a,t,void 0,e),e.currentTarget=null}function za(e,t){t=0!==(4&t);for(var n=0;n<e.length;n++){var a=e[n],r=a.event;a=a.listeners;e:{var o=void 0;if(t)for(var s=a.length-1;0<=s;s--){var i=a[s],c=i.instance,l=i.currentTarget;if(i=i.listener,c!==o&&r.isPropagationStopped())break e;Pa(r,i,l),o=c}else for(s=0;s<a.length;s++){if(c=(i=a[s]).instance,l=i.currentTarget,i=i.listener,c!==o&&r.isPropagationStopped())break e;Pa(r,i,l),o=c}}}if(ze)throw e=Be,ze=!1,Be=null,e}function Ba(e,t){var n=t[mr];void 0===n&&(n=t[mr]=new Set);var a=e+"__bubble";n.has(a)||(Ga(t,e,2,!1),n.add(a))}function Wa(e,t,n){var a=0;t&&(a|=4),Ga(n,e,a,t)}var Va="_reactListening"+Math.random().toString(36).slice(2);function Ua(e){if(!e[Va]){e[Va]=!0,s.forEach((function(t){"selectionchange"!==t&&(La.has(t)||Wa(t,!1,e),Wa(t,!0,e))}));var t=9===e.nodeType?e:e.ownerDocument;null===t||t[Va]||(t[Va]=!0,Wa("selectionchange",!1,t))}}function Ga(e,t,n,a){switch(Qt(t)){case 1:var r=jt;break;case 4:r=Kt;break;default:r=qt}n=r.bind(null,t,n,e),r=void 0,!Oe||"touchstart"!==t&&"touchmove"!==t&&"wheel"!==t||(r=!0),a?void 0!==r?e.addEventListener(t,n,{capture:!0,passive:r}):e.addEventListener(t,n,!0):void 0!==r?e.addEventListener(t,n,{passive:r}):e.addEventListener(t,n,!1)}function Ha(e,t,n,a,r){var o=a;if(0===(1&t)&&0===(2&t)&&null!==a)e:for(;;){if(null===a)return;var s=a.tag;if(3===s||4===s){var i=a.stateNode.containerInfo;if(i===r||8===i.nodeType&&i.parentNode===r)break;if(4===s)for(s=a.return;null!==s;){var c=s.tag;if((3===c||4===c)&&((c=s.stateNode.containerInfo)===r||8===c.nodeType&&c.parentNode===r))return;s=s.return}for(;null!==i;){if(null===(s=yr(i)))return;if(5===(c=s.tag)||6===c){a=o=s;continue e}i=i.parentNode}}a=a.return}Ae((function(){var a=o,r=we(n),s=[];e:{var i=_a.get(e);if(void 0!==i){var c=un,l=e;switch(e){case"keypress":if(0===tn(n))break e;case"keydown":case"keyup":c=Tn;break;case"focusin":l="focus",c=gn;break;case"focusout":l="blur",c=gn;break;case"beforeblur":case"afterblur":c=gn;break;case"click":if(2===n.button)break e;case"auxclick":case"dblclick":case"mousedown":case"mousemove":case"mouseup":case"mouseout":case"mouseover":case"contextmenu":c=fn;break;case"drag":case"dragend":case"dragenter":case"dragexit":case"dragleave":case"dragover":case"dragstart":case"drop":c=mn;break;case"touchcancel":case"touchend":case"touchmove":case"touchstart":c=Rn;break;case Ca:case Ta:case Ea:c=bn;break;case Ra:c=_n;break;case"scroll":c=hn;break;case"wheel":c=Fn;break;case"copy":case"cut":case"paste":c=xn;break;case"gotpointercapture":case"lostpointercapture":case"pointercancel":case"pointerdown":case"pointermove":case"pointerout":case"pointerover":case"pointerup":c=En}var u=0!==(4&t),d=!u&&"scroll"===e,h=u?null!==i?i+"Capture":null:i;u=[];for(var p,f=a;null!==f;){var m=(p=f).stateNode;if(5===p.tag&&null!==m&&(p=m,null!==h&&(null!=(m=Fe(f,h))&&u.push(ja(f,m,p)))),d)break;f=f.return}0<u.length&&(i=new c(i,l,null,n,r),s.push({event:i,listeners:u}))}}if(0===(7&t)){if(c="mouseout"===e||"pointerout"===e,(!(i="mouseover"===e||"pointerover"===e)||n===ve||!(l=n.relatedTarget||n.fromElement)||!yr(l)&&!l[fr])&&(c||i)&&(i=r.window===r?r:(i=r.ownerDocument)?i.defaultView||i.parentWindow:window,c?(c=a,null!==(l=(l=n.relatedTarget||n.toElement)?yr(l):null)&&(l!==(d=Ue(l))||5!==l.tag&&6!==l.tag)&&(l=null)):(c=null,l=a),c!==l)){if(u=fn,m="onMouseLeave",h="onMouseEnter",f="mouse","pointerout"!==e&&"pointerover"!==e||(u=En,m="onPointerLeave",h="onPointerEnter",f="pointer"),d=null==c?i:vr(c),p=null==l?i:vr(l),(i=new u(m,f+"leave",c,n,r)).target=d,i.relatedTarget=p,m=null,yr(r)===a&&((u=new u(h,f+"enter",l,n,r)).target=p,u.relatedTarget=d,m=u),d=m,c&&l)e:{for(h=l,f=0,p=u=c;p;p=qa(p))f++;for(p=0,m=h;m;m=qa(m))p++;for(;0<f-p;)u=qa(u),f--;for(;0<p-f;)h=qa(h),p--;for(;f--;){if(u===h||null!==h&&u===h.alternate)break e;u=qa(u),h=qa(h)}u=null}else u=null;null!==c&&Xa(s,i,c,u,!1),null!==l&&null!==d&&Xa(s,d,l,u,!0)}if("select"===(c=(i=a?vr(a):window).nodeName&&i.nodeName.toLowerCase())||"input"===c&&"file"===i.type)var g=Qn;else if(Hn(i))if(Jn)g=sa;else{g=ra;var b=aa}else(c=i.nodeName)&&"input"===c.toLowerCase()&&("checkbox"===i.type||"radio"===i.type)&&(g=oa);switch(g&&(g=g(e,a))?jn(s,g,n,r):(b&&b(e,i,a),"focusout"===e&&(b=i._wrapperState)&&b.controlled&&"number"===i.type&&ee(i,"number",i.value)),b=a?vr(a):window,e){case"focusin":(Hn(b)||"true"===b.contentEditable)&&(ga=b,ba=a,ya=null);break;case"focusout":ya=ba=ga=null;break;case"mousedown":xa=!0;break;case"contextmenu":case"mouseup":case"dragend":xa=!1,va(s,n,r);break;case"selectionchange":if(ma)break;case"keydown":case"keyup":va(s,n,r)}var y;if(Dn)e:{switch(e){case"compositionstart":var x="onCompositionStart";break e;case"compositionend":x="onCompositionEnd";break e;case"compositionupdate":x="onCompositionUpdate";break e}x=void 0}else Un?Wn(e,n)&&(x="onCompositionEnd"):"keydown"===e&&229===n.keyCode&&(x="onCompositionStart");x&&(Pn&&"ko"!==n.locale&&(Un||"onCompositionStart"!==x?"onCompositionEnd"===x&&Un&&(y=en()):(Zt="value"in(Jt=r)?Jt.value:Jt.textContent,Un=!0)),0<(b=Ka(a,x)).length&&(x=new vn(x,e,null,n,r),s.push({event:x,listeners:b}),y?x.data=y:null!==(y=Vn(n))&&(x.data=y))),(y=Ln?function(e,t){switch(e){case"compositionend":return Vn(t);case"keypress":return 32!==t.which?null:(Bn=!0,zn);case"textInput":return(e=t.data)===zn&&Bn?null:e;default:return null}}(e,n):function(e,t){if(Un)return"compositionend"===e||!Dn&&Wn(e,t)?(e=en(),$t=Zt=Jt=null,Un=!1,e):null;switch(e){case"paste":default:return null;case"keypress":if(!(t.ctrlKey||t.altKey||t.metaKey)||t.ctrlKey&&t.altKey){if(t.char&&1<t.char.length)return t.char;if(t.which)return String.fromCharCode(t.which)}return null;case"compositionend":return Pn&&"ko"!==t.locale?null:t.data}}(e,n))&&(0<(a=Ka(a,"onBeforeInput")).length&&(r=new vn("onBeforeInput","beforeinput",null,n,r),s.push({event:r,listeners:a}),r.data=y))}za(s,t)}))}function ja(e,t,n){return{instance:e,listener:t,currentTarget:n}}function Ka(e,t){for(var n=t+"Capture",a=[];null!==e;){var r=e,o=r.stateNode;5===r.tag&&null!==o&&(r=o,null!=(o=Fe(e,n))&&a.unshift(ja(e,o,r)),null!=(o=Fe(e,t))&&a.push(ja(e,o,r))),e=e.return}return a}function qa(e){if(null===e)return null;do{e=e.return}while(e&&5!==e.tag);return e||null}function Xa(e,t,n,a,r){for(var o=t._reactName,s=[];null!==n&&n!==a;){var i=n,c=i.alternate,l=i.stateNode;if(null!==c&&c===a)break;5===i.tag&&null!==l&&(i=l,r?null!=(c=Fe(n,o))&&s.unshift(ja(n,c,i)):r||null!=(c=Fe(n,o))&&s.push(ja(n,c,i))),n=n.return}0!==s.length&&e.push({event:t,listeners:s})}var Ya=/\r\n?/g,Qa=/\u0000|\uFFFD/g;function Ja(e){return("string"===typeof e?e:""+e).replace(Ya,"\n").replace(Qa,"")}function Za(e,t,n){if(t=Ja(t),Ja(e)!==t&&n)throw Error(o(425))}function $a(){}var er=null,tr=null;function nr(e,t){return"textarea"===e||"noscript"===e||"string"===typeof t.children||"number"===typeof t.children||"object"===typeof t.dangerouslySetInnerHTML&&null!==t.dangerouslySetInnerHTML&&null!=t.dangerouslySetInnerHTML.__html}var ar="function"===typeof setTimeout?setTimeout:void 0,rr="function"===typeof clearTimeout?clearTimeout:void 0,or="function"===typeof Promise?Promise:void 0,sr="function"===typeof queueMicrotask?queueMicrotask:"undefined"!==typeof or?function(e){return or.resolve(null).then(e).catch(ir)}:ar;function ir(e){setTimeout((function(){throw e}))}function cr(e,t){var n=t,a=0;do{var r=n.nextSibling;if(e.removeChild(n),r&&8===r.nodeType)if("/$"===(n=r.data)){if(0===a)return e.removeChild(r),void Ut(t);a--}else"$"!==n&&"$?"!==n&&"$!"!==n||a++;n=r}while(n);Ut(t)}function lr(e){for(;null!=e;e=e.nextSibling){var t=e.nodeType;if(1===t||3===t)break;if(8===t){if("$"===(t=e.data)||"$!"===t||"$?"===t)break;if("/$"===t)return null}}return e}function ur(e){e=e.previousSibling;for(var t=0;e;){if(8===e.nodeType){var n=e.data;if("$"===n||"$!"===n||"$?"===n){if(0===t)return e;t--}else"/$"===n&&t++}e=e.previousSibling}return null}var dr=Math.random().toString(36).slice(2),hr="__reactFiber$"+dr,pr="__reactProps$"+dr,fr="__reactContainer$"+dr,mr="__reactEvents$"+dr,gr="__reactListeners$"+dr,br="__reactHandles$"+dr;function yr(e){var t=e[hr];if(t)return t;for(var n=e.parentNode;n;){if(t=n[fr]||n[hr]){if(n=t.alternate,null!==t.child||null!==n&&null!==n.child)for(e=ur(e);null!==e;){if(n=e[hr])return n;e=ur(e)}return t}n=(e=n).parentNode}return null}function xr(e){return!(e=e[hr]||e[fr])||5!==e.tag&&6!==e.tag&&13!==e.tag&&3!==e.tag?null:e}function vr(e){if(5===e.tag||6===e.tag)return e.stateNode;throw Error(o(33))}function wr(e){return e[pr]||null}var kr=[],Ir=-1;function Sr(e){return{current:e}}function Nr(e){0>Ir||(e.current=kr[Ir],kr[Ir]=null,Ir--)}function Cr(e,t){Ir++,kr[Ir]=e.current,e.current=t}var Tr={},Er=Sr(Tr),Rr=Sr(!1),_r=Tr;function Ar(e,t){var n=e.type.contextTypes;if(!n)return Tr;var a=e.stateNode;if(a&&a.__reactInternalMemoizedUnmaskedChildContext===t)return a.__reactInternalMemoizedMaskedChildContext;var r,o={};for(r in n)o[r]=t[r];return a&&((e=e.stateNode).__reactInternalMemoizedUnmaskedChildContext=t,e.__reactInternalMemoizedMaskedChildContext=o),o}function Fr(e){return null!==(e=e.childContextTypes)&&void 0!==e}function Or(){Nr(Rr),Nr(Er)}function Dr(e,t,n){if(Er.current!==Tr)throw Error(o(168));Cr(Er,t),Cr(Rr,n)}function Mr(e,t,n){var a=e.stateNode;if(t=t.childContextTypes,"function"!==typeof a.getChildContext)return n;for(var r in a=a.getChildContext())if(!(r in t))throw Error(o(108,G(e)||"Unknown",r));return P({},n,a)}function Lr(e){return e=(e=e.stateNode)&&e.__reactInternalMemoizedMergedChildContext||Tr,_r=Er.current,Cr(Er,e),Cr(Rr,Rr.current),!0}function Pr(e,t,n){var a=e.stateNode;if(!a)throw Error(o(169));n?(e=Mr(e,t,_r),a.__reactInternalMemoizedMergedChildContext=e,Nr(Rr),Nr(Er),Cr(Er,e)):Nr(Rr),Cr(Rr,n)}var zr=null,Br=!1,Wr=!1;function Vr(e){null===zr?zr=[e]:zr.push(e)}function Ur(){if(!Wr&&null!==zr){Wr=!0;var e=0,t=xt;try{var n=zr;for(xt=1;e<n.length;e++){var a=n[e];do{a=a(!0)}while(null!==a)}zr=null,Br=!1}catch(r){throw null!==zr&&(zr=zr.slice(e+1)),qe($e,Ur),r}finally{xt=t,Wr=!1}}return null}var Gr=[],Hr=0,jr=null,Kr=0,qr=[],Xr=0,Yr=null,Qr=1,Jr="";function Zr(e,t){Gr[Hr++]=Kr,Gr[Hr++]=jr,jr=e,Kr=t}function $r(e,t,n){qr[Xr++]=Qr,qr[Xr++]=Jr,qr[Xr++]=Yr,Yr=e;var a=Qr;e=Jr;var r=32-st(a)-1;a&=~(1<<r),n+=1;var o=32-st(t)+r;if(30<o){var s=r-r%5;o=(a&(1<<s)-1).toString(32),a>>=s,r-=s,Qr=1<<32-st(t)+r|n<<r|a,Jr=o+e}else Qr=1<<o|n<<r|a,Jr=e}function eo(e){null!==e.return&&(Zr(e,1),$r(e,1,0))}function to(e){for(;e===jr;)jr=Gr[--Hr],Gr[Hr]=null,Kr=Gr[--Hr],Gr[Hr]=null;for(;e===Yr;)Yr=qr[--Xr],qr[Xr]=null,Jr=qr[--Xr],qr[Xr]=null,Qr=qr[--Xr],qr[Xr]=null}var no=null,ao=null,ro=!1,oo=null;function so(e,t){var n=Al(5,null,null,0);n.elementType="DELETED",n.stateNode=t,n.return=e,null===(t=e.deletions)?(e.deletions=[n],e.flags|=16):t.push(n)}function io(e,t){switch(e.tag){case 5:var n=e.type;return null!==(t=1!==t.nodeType||n.toLowerCase()!==t.nodeName.toLowerCase()?null:t)&&(e.stateNode=t,no=e,ao=lr(t.firstChild),!0);case 6:return null!==(t=""===e.pendingProps||3!==t.nodeType?null:t)&&(e.stateNode=t,no=e,ao=null,!0);case 13:return null!==(t=8!==t.nodeType?null:t)&&(n=null!==Yr?{id:Qr,overflow:Jr}:null,e.memoizedState={dehydrated:t,treeContext:n,retryLane:1073741824},(n=Al(18,null,null,0)).stateNode=t,n.return=e,e.child=n,no=e,ao=null,!0);default:return!1}}function co(e){return 0!==(1&e.mode)&&0===(128&e.flags)}function lo(e){if(ro){var t=ao;if(t){var n=t;if(!io(e,t)){if(co(e))throw Error(o(418));t=lr(n.nextSibling);var a=no;t&&io(e,t)?so(a,n):(e.flags=-4097&e.flags|2,ro=!1,no=e)}}else{if(co(e))throw Error(o(418));e.flags=-4097&e.flags|2,ro=!1,no=e}}}function uo(e){for(e=e.return;null!==e&&5!==e.tag&&3!==e.tag&&13!==e.tag;)e=e.return;no=e}function ho(e){if(e!==no)return!1;if(!ro)return uo(e),ro=!0,!1;var t;if((t=3!==e.tag)&&!(t=5!==e.tag)&&(t="head"!==(t=e.type)&&"body"!==t&&!nr(e.type,e.memoizedProps)),t&&(t=ao)){if(co(e))throw po(),Error(o(418));for(;t;)so(e,t),t=lr(t.nextSibling)}if(uo(e),13===e.tag){if(!(e=null!==(e=e.memoizedState)?e.dehydrated:null))throw Error(o(317));e:{for(e=e.nextSibling,t=0;e;){if(8===e.nodeType){var n=e.data;if("/$"===n){if(0===t){ao=lr(e.nextSibling);break e}t--}else"$"!==n&&"$!"!==n&&"$?"!==n||t++}e=e.nextSibling}ao=null}}else ao=no?lr(e.stateNode.nextSibling):null;return!0}function po(){for(var e=ao;e;)e=lr(e.nextSibling)}function fo(){ao=no=null,ro=!1}function mo(e){null===oo?oo=[e]:oo.push(e)}var go=v.ReactCurrentBatchConfig;function bo(e,t,n){if(null!==(e=n.ref)&&"function"!==typeof e&&"object"!==typeof e){if(n._owner){if(n=n._owner){if(1!==n.tag)throw Error(o(309));var a=n.stateNode}if(!a)throw Error(o(147,e));var r=a,s=""+e;return null!==t&&null!==t.ref&&"function"===typeof t.ref&&t.ref._stringRef===s?t.ref:(t=function(e){var t=r.refs;null===e?delete t[s]:t[s]=e},t._stringRef=s,t)}if("string"!==typeof e)throw Error(o(284));if(!n._owner)throw Error(o(290,e))}return e}function yo(e,t){throw e=Object.prototype.toString.call(t),Error(o(31,"[object Object]"===e?"object with keys {"+Object.keys(t).join(", ")+"}":e))}function xo(e){return(0,e._init)(e._payload)}function vo(e){function t(t,n){if(e){var a=t.deletions;null===a?(t.deletions=[n],t.flags|=16):a.push(n)}}function n(n,a){if(!e)return null;for(;null!==a;)t(n,a),a=a.sibling;return null}function a(e,t){for(e=new Map;null!==t;)null!==t.key?e.set(t.key,t):e.set(t.index,t),t=t.sibling;return e}function r(e,t){return(e=Ol(e,t)).index=0,e.sibling=null,e}function s(t,n,a){return t.index=a,e?null!==(a=t.alternate)?(a=a.index)<n?(t.flags|=2,n):a:(t.flags|=2,n):(t.flags|=1048576,n)}function i(t){return e&&null===t.alternate&&(t.flags|=2),t}function c(e,t,n,a){return null===t||6!==t.tag?((t=Pl(n,e.mode,a)).return=e,t):((t=r(t,n)).return=e,t)}function l(e,t,n,a){var o=n.type;return o===I?d(e,t,n.props.children,a,n.key):null!==t&&(t.elementType===o||"object"===typeof o&&null!==o&&o.$$typeof===F&&xo(o)===t.type)?((a=r(t,n.props)).ref=bo(e,t,n),a.return=e,a):((a=Dl(n.type,n.key,n.props,null,e.mode,a)).ref=bo(e,t,n),a.return=e,a)}function u(e,t,n,a){return null===t||4!==t.tag||t.stateNode.containerInfo!==n.containerInfo||t.stateNode.implementation!==n.implementation?((t=zl(n,e.mode,a)).return=e,t):((t=r(t,n.children||[])).return=e,t)}function d(e,t,n,a,o){return null===t||7!==t.tag?((t=Ml(n,e.mode,a,o)).return=e,t):((t=r(t,n)).return=e,t)}function h(e,t,n){if("string"===typeof t&&""!==t||"number"===typeof t)return(t=Pl(""+t,e.mode,n)).return=e,t;if("object"===typeof t&&null!==t){switch(t.$$typeof){case w:return(n=Dl(t.type,t.key,t.props,null,e.mode,n)).ref=bo(e,null,t),n.return=e,n;case k:return(t=zl(t,e.mode,n)).return=e,t;case F:return h(e,(0,t._init)(t._payload),n)}if(te(t)||M(t))return(t=Ml(t,e.mode,n,null)).return=e,t;yo(e,t)}return null}function p(e,t,n,a){var r=null!==t?t.key:null;if("string"===typeof n&&""!==n||"number"===typeof n)return null!==r?null:c(e,t,""+n,a);if("object"===typeof n&&null!==n){switch(n.$$typeof){case w:return n.key===r?l(e,t,n,a):null;case k:return n.key===r?u(e,t,n,a):null;case F:return p(e,t,(r=n._init)(n._payload),a)}if(te(n)||M(n))return null!==r?null:d(e,t,n,a,null);yo(e,n)}return null}function f(e,t,n,a,r){if("string"===typeof a&&""!==a||"number"===typeof a)return c(t,e=e.get(n)||null,""+a,r);if("object"===typeof a&&null!==a){switch(a.$$typeof){case w:return l(t,e=e.get(null===a.key?n:a.key)||null,a,r);case k:return u(t,e=e.get(null===a.key?n:a.key)||null,a,r);case F:return f(e,t,n,(0,a._init)(a._payload),r)}if(te(a)||M(a))return d(t,e=e.get(n)||null,a,r,null);yo(t,a)}return null}function m(r,o,i,c){for(var l=null,u=null,d=o,m=o=0,g=null;null!==d&&m<i.length;m++){d.index>m?(g=d,d=null):g=d.sibling;var b=p(r,d,i[m],c);if(null===b){null===d&&(d=g);break}e&&d&&null===b.alternate&&t(r,d),o=s(b,o,m),null===u?l=b:u.sibling=b,u=b,d=g}if(m===i.length)return n(r,d),ro&&Zr(r,m),l;if(null===d){for(;m<i.length;m++)null!==(d=h(r,i[m],c))&&(o=s(d,o,m),null===u?l=d:u.sibling=d,u=d);return ro&&Zr(r,m),l}for(d=a(r,d);m<i.length;m++)null!==(g=f(d,r,m,i[m],c))&&(e&&null!==g.alternate&&d.delete(null===g.key?m:g.key),o=s(g,o,m),null===u?l=g:u.sibling=g,u=g);return e&&d.forEach((function(e){return t(r,e)})),ro&&Zr(r,m),l}function g(r,i,c,l){var u=M(c);if("function"!==typeof u)throw Error(o(150));if(null==(c=u.call(c)))throw Error(o(151));for(var d=u=null,m=i,g=i=0,b=null,y=c.next();null!==m&&!y.done;g++,y=c.next()){m.index>g?(b=m,m=null):b=m.sibling;var x=p(r,m,y.value,l);if(null===x){null===m&&(m=b);break}e&&m&&null===x.alternate&&t(r,m),i=s(x,i,g),null===d?u=x:d.sibling=x,d=x,m=b}if(y.done)return n(r,m),ro&&Zr(r,g),u;if(null===m){for(;!y.done;g++,y=c.next())null!==(y=h(r,y.value,l))&&(i=s(y,i,g),null===d?u=y:d.sibling=y,d=y);return ro&&Zr(r,g),u}for(m=a(r,m);!y.done;g++,y=c.next())null!==(y=f(m,r,g,y.value,l))&&(e&&null!==y.alternate&&m.delete(null===y.key?g:y.key),i=s(y,i,g),null===d?u=y:d.sibling=y,d=y);return e&&m.forEach((function(e){return t(r,e)})),ro&&Zr(r,g),u}return function e(a,o,s,c){if("object"===typeof s&&null!==s&&s.type===I&&null===s.key&&(s=s.props.children),"object"===typeof s&&null!==s){switch(s.$$typeof){case w:e:{for(var l=s.key,u=o;null!==u;){if(u.key===l){if((l=s.type)===I){if(7===u.tag){n(a,u.sibling),(o=r(u,s.props.children)).return=a,a=o;break e}}else if(u.elementType===l||"object"===typeof l&&null!==l&&l.$$typeof===F&&xo(l)===u.type){n(a,u.sibling),(o=r(u,s.props)).ref=bo(a,u,s),o.return=a,a=o;break e}n(a,u);break}t(a,u),u=u.sibling}s.type===I?((o=Ml(s.props.children,a.mode,c,s.key)).return=a,a=o):((c=Dl(s.type,s.key,s.props,null,a.mode,c)).ref=bo(a,o,s),c.return=a,a=c)}return i(a);case k:e:{for(u=s.key;null!==o;){if(o.key===u){if(4===o.tag&&o.stateNode.containerInfo===s.containerInfo&&o.stateNode.implementation===s.implementation){n(a,o.sibling),(o=r(o,s.children||[])).return=a,a=o;break e}n(a,o);break}t(a,o),o=o.sibling}(o=zl(s,a.mode,c)).return=a,a=o}return i(a);case F:return e(a,o,(u=s._init)(s._payload),c)}if(te(s))return m(a,o,s,c);if(M(s))return g(a,o,s,c);yo(a,s)}return"string"===typeof s&&""!==s||"number"===typeof s?(s=""+s,null!==o&&6===o.tag?(n(a,o.sibling),(o=r(o,s)).return=a,a=o):(n(a,o),(o=Pl(s,a.mode,c)).return=a,a=o),i(a)):n(a,o)}}var wo=vo(!0),ko=vo(!1),Io=Sr(null),So=null,No=null,Co=null;function To(){Co=No=So=null}function Eo(e){var t=Io.current;Nr(Io),e._currentValue=t}function Ro(e,t,n){for(;null!==e;){var a=e.alternate;if((e.childLanes&t)!==t?(e.childLanes|=t,null!==a&&(a.childLanes|=t)):null!==a&&(a.childLanes&t)!==t&&(a.childLanes|=t),e===n)break;e=e.return}}function _o(e,t){So=e,Co=No=null,null!==(e=e.dependencies)&&null!==e.firstContext&&(0!==(e.lanes&t)&&(xi=!0),e.firstContext=null)}function Ao(e){var t=e._currentValue;if(Co!==e)if(e={context:e,memoizedValue:t,next:null},null===No){if(null===So)throw Error(o(308));No=e,So.dependencies={lanes:0,firstContext:e}}else No=No.next=e;return t}var Fo=null;function Oo(e){null===Fo?Fo=[e]:Fo.push(e)}function Do(e,t,n,a){var r=t.interleaved;return null===r?(n.next=n,Oo(t)):(n.next=r.next,r.next=n),t.interleaved=n,Mo(e,a)}function Mo(e,t){e.lanes|=t;var n=e.alternate;for(null!==n&&(n.lanes|=t),n=e,e=e.return;null!==e;)e.childLanes|=t,null!==(n=e.alternate)&&(n.childLanes|=t),n=e,e=e.return;return 3===n.tag?n.stateNode:null}var Lo=!1;function Po(e){e.updateQueue={baseState:e.memoizedState,firstBaseUpdate:null,lastBaseUpdate:null,shared:{pending:null,interleaved:null,lanes:0},effects:null}}function zo(e,t){e=e.updateQueue,t.updateQueue===e&&(t.updateQueue={baseState:e.baseState,firstBaseUpdate:e.firstBaseUpdate,lastBaseUpdate:e.lastBaseUpdate,shared:e.shared,effects:e.effects})}function Bo(e,t){return{eventTime:e,lane:t,tag:0,payload:null,callback:null,next:null}}function Wo(e,t,n){var a=e.updateQueue;if(null===a)return null;if(a=a.shared,0!==(2&Ec)){var r=a.pending;return null===r?t.next=t:(t.next=r.next,r.next=t),a.pending=t,Mo(e,n)}return null===(r=a.interleaved)?(t.next=t,Oo(a)):(t.next=r.next,r.next=t),a.interleaved=t,Mo(e,n)}function Vo(e,t,n){if(null!==(t=t.updateQueue)&&(t=t.shared,0!==(4194240&n))){var a=t.lanes;n|=a&=e.pendingLanes,t.lanes=n,yt(e,n)}}function Uo(e,t){var n=e.updateQueue,a=e.alternate;if(null!==a&&n===(a=a.updateQueue)){var r=null,o=null;if(null!==(n=n.firstBaseUpdate)){do{var s={eventTime:n.eventTime,lane:n.lane,tag:n.tag,payload:n.payload,callback:n.callback,next:null};null===o?r=o=s:o=o.next=s,n=n.next}while(null!==n);null===o?r=o=t:o=o.next=t}else r=o=t;return n={baseState:a.baseState,firstBaseUpdate:r,lastBaseUpdate:o,shared:a.shared,effects:a.effects},void(e.updateQueue=n)}null===(e=n.lastBaseUpdate)?n.firstBaseUpdate=t:e.next=t,n.lastBaseUpdate=t}function Go(e,t,n,a){var r=e.updateQueue;Lo=!1;var o=r.firstBaseUpdate,s=r.lastBaseUpdate,i=r.shared.pending;if(null!==i){r.shared.pending=null;var c=i,l=c.next;c.next=null,null===s?o=l:s.next=l,s=c;var u=e.alternate;null!==u&&((i=(u=u.updateQueue).lastBaseUpdate)!==s&&(null===i?u.firstBaseUpdate=l:i.next=l,u.lastBaseUpdate=c))}if(null!==o){var d=r.baseState;for(s=0,u=l=c=null,i=o;;){var h=i.lane,p=i.eventTime;if((a&h)===h){null!==u&&(u=u.next={eventTime:p,lane:0,tag:i.tag,payload:i.payload,callback:i.callback,next:null});e:{var f=e,m=i;switch(h=t,p=n,m.tag){case 1:if("function"===typeof(f=m.payload)){d=f.call(p,d,h);break e}d=f;break e;case 3:f.flags=-65537&f.flags|128;case 0:if(null===(h="function"===typeof(f=m.payload)?f.call(p,d,h):f)||void 0===h)break e;d=P({},d,h);break e;case 2:Lo=!0}}null!==i.callback&&0!==i.lane&&(e.flags|=64,null===(h=r.effects)?r.effects=[i]:h.push(i))}else p={eventTime:p,lane:h,tag:i.tag,payload:i.payload,callback:i.callback,next:null},null===u?(l=u=p,c=d):u=u.next=p,s|=h;if(null===(i=i.next)){if(null===(i=r.shared.pending))break;i=(h=i).next,h.next=null,r.lastBaseUpdate=h,r.shared.pending=null}}if(null===u&&(c=d),r.baseState=c,r.firstBaseUpdate=l,r.lastBaseUpdate=u,null!==(t=r.shared.interleaved)){r=t;do{s|=r.lane,r=r.next}while(r!==t)}else null===o&&(r.shared.lanes=0);Lc|=s,e.lanes=s,e.memoizedState=d}}function Ho(e,t,n){if(e=t.effects,t.effects=null,null!==e)for(t=0;t<e.length;t++){var a=e[t],r=a.callback;if(null!==r){if(a.callback=null,a=n,"function"!==typeof r)throw Error(o(191,r));r.call(a)}}}var jo={},Ko=Sr(jo),qo=Sr(jo),Xo=Sr(jo);function Yo(e){if(e===jo)throw Error(o(174));return e}function Qo(e,t){switch(Cr(Xo,t),Cr(qo,e),Cr(Ko,jo),e=t.nodeType){case 9:case 11:t=(t=t.documentElement)?t.namespaceURI:ce(null,"");break;default:t=ce(t=(e=8===e?t.parentNode:t).namespaceURI||null,e=e.tagName)}Nr(Ko),Cr(Ko,t)}function Jo(){Nr(Ko),Nr(qo),Nr(Xo)}function Zo(e){Yo(Xo.current);var t=Yo(Ko.current),n=ce(t,e.type);t!==n&&(Cr(qo,e),Cr(Ko,n))}function $o(e){qo.current===e&&(Nr(Ko),Nr(qo))}var es=Sr(0);function ts(e){for(var t=e;null!==t;){if(13===t.tag){var n=t.memoizedState;if(null!==n&&(null===(n=n.dehydrated)||"$?"===n.data||"$!"===n.data))return t}else if(19===t.tag&&void 0!==t.memoizedProps.revealOrder){if(0!==(128&t.flags))return t}else if(null!==t.child){t.child.return=t,t=t.child;continue}if(t===e)break;for(;null===t.sibling;){if(null===t.return||t.return===e)return null;t=t.return}t.sibling.return=t.return,t=t.sibling}return null}var ns=[];function as(){for(var e=0;e<ns.length;e++)ns[e]._workInProgressVersionPrimary=null;ns.length=0}var rs=v.ReactCurrentDispatcher,os=v.ReactCurrentBatchConfig,ss=0,is=null,cs=null,ls=null,us=!1,ds=!1,hs=0,ps=0;function fs(){throw Error(o(321))}function ms(e,t){if(null===t)return!1;for(var n=0;n<t.length&&n<e.length;n++)if(!ia(e[n],t[n]))return!1;return!0}function gs(e,t,n,a,r,s){if(ss=s,is=t,t.memoizedState=null,t.updateQueue=null,t.lanes=0,rs.current=null===e||null===e.memoizedState?$s:ei,e=n(a,r),ds){s=0;do{if(ds=!1,hs=0,25<=s)throw Error(o(301));s+=1,ls=cs=null,t.updateQueue=null,rs.current=ti,e=n(a,r)}while(ds)}if(rs.current=Zs,t=null!==cs&&null!==cs.next,ss=0,ls=cs=is=null,us=!1,t)throw Error(o(300));return e}function bs(){var e=0!==hs;return hs=0,e}function ys(){var e={memoizedState:null,baseState:null,baseQueue:null,queue:null,next:null};return null===ls?is.memoizedState=ls=e:ls=ls.next=e,ls}function xs(){if(null===cs){var e=is.alternate;e=null!==e?e.memoizedState:null}else e=cs.next;var t=null===ls?is.memoizedState:ls.next;if(null!==t)ls=t,cs=e;else{if(null===e)throw Error(o(310));e={memoizedState:(cs=e).memoizedState,baseState:cs.baseState,baseQueue:cs.baseQueue,queue:cs.queue,next:null},null===ls?is.memoizedState=ls=e:ls=ls.next=e}return ls}function vs(e,t){return"function"===typeof t?t(e):t}function ws(e){var t=xs(),n=t.queue;if(null===n)throw Error(o(311));n.lastRenderedReducer=e;var a=cs,r=a.baseQueue,s=n.pending;if(null!==s){if(null!==r){var i=r.next;r.next=s.next,s.next=i}a.baseQueue=r=s,n.pending=null}if(null!==r){s=r.next,a=a.baseState;var c=i=null,l=null,u=s;do{var d=u.lane;if((ss&d)===d)null!==l&&(l=l.next={lane:0,action:u.action,hasEagerState:u.hasEagerState,eagerState:u.eagerState,next:null}),a=u.hasEagerState?u.eagerState:e(a,u.action);else{var h={lane:d,action:u.action,hasEagerState:u.hasEagerState,eagerState:u.eagerState,next:null};null===l?(c=l=h,i=a):l=l.next=h,is.lanes|=d,Lc|=d}u=u.next}while(null!==u&&u!==s);null===l?i=a:l.next=c,ia(a,t.memoizedState)||(xi=!0),t.memoizedState=a,t.baseState=i,t.baseQueue=l,n.lastRenderedState=a}if(null!==(e=n.interleaved)){r=e;do{s=r.lane,is.lanes|=s,Lc|=s,r=r.next}while(r!==e)}else null===r&&(n.lanes=0);return[t.memoizedState,n.dispatch]}function ks(e){var t=xs(),n=t.queue;if(null===n)throw Error(o(311));n.lastRenderedReducer=e;var a=n.dispatch,r=n.pending,s=t.memoizedState;if(null!==r){n.pending=null;var i=r=r.next;do{s=e(s,i.action),i=i.next}while(i!==r);ia(s,t.memoizedState)||(xi=!0),t.memoizedState=s,null===t.baseQueue&&(t.baseState=s),n.lastRenderedState=s}return[s,a]}function Is(){}function Ss(e,t){var n=is,a=xs(),r=t(),s=!ia(a.memoizedState,r);if(s&&(a.memoizedState=r,xi=!0),a=a.queue,Ls(Ts.bind(null,n,a,e),[e]),a.getSnapshot!==t||s||null!==ls&&1&ls.memoizedState.tag){if(n.flags|=2048,As(9,Cs.bind(null,n,a,r,t),void 0,null),null===Rc)throw Error(o(349));0!==(30&ss)||Ns(n,t,r)}return r}function Ns(e,t,n){e.flags|=16384,e={getSnapshot:t,value:n},null===(t=is.updateQueue)?(t={lastEffect:null,stores:null},is.updateQueue=t,t.stores=[e]):null===(n=t.stores)?t.stores=[e]:n.push(e)}function Cs(e,t,n,a){t.value=n,t.getSnapshot=a,Es(t)&&Rs(e)}function Ts(e,t,n){return n((function(){Es(t)&&Rs(e)}))}function Es(e){var t=e.getSnapshot;e=e.value;try{var n=t();return!ia(e,n)}catch(a){return!0}}function Rs(e){var t=Mo(e,1);null!==t&&nl(t,e,1,-1)}function _s(e){var t=ys();return"function"===typeof e&&(e=e()),t.memoizedState=t.baseState=e,e={pending:null,interleaved:null,lanes:0,dispatch:null,lastRenderedReducer:vs,lastRenderedState:e},t.queue=e,e=e.dispatch=Xs.bind(null,is,e),[t.memoizedState,e]}function As(e,t,n,a){return e={tag:e,create:t,destroy:n,deps:a,next:null},null===(t=is.updateQueue)?(t={lastEffect:null,stores:null},is.updateQueue=t,t.lastEffect=e.next=e):null===(n=t.lastEffect)?t.lastEffect=e.next=e:(a=n.next,n.next=e,e.next=a,t.lastEffect=e),e}function Fs(){return xs().memoizedState}function Os(e,t,n,a){var r=ys();is.flags|=e,r.memoizedState=As(1|t,n,void 0,void 0===a?null:a)}function Ds(e,t,n,a){var r=xs();a=void 0===a?null:a;var o=void 0;if(null!==cs){var s=cs.memoizedState;if(o=s.destroy,null!==a&&ms(a,s.deps))return void(r.memoizedState=As(t,n,o,a))}is.flags|=e,r.memoizedState=As(1|t,n,o,a)}function Ms(e,t){return Os(8390656,8,e,t)}function Ls(e,t){return Ds(2048,8,e,t)}function Ps(e,t){return Ds(4,2,e,t)}function zs(e,t){return Ds(4,4,e,t)}function Bs(e,t){return"function"===typeof t?(e=e(),t(e),function(){t(null)}):null!==t&&void 0!==t?(e=e(),t.current=e,function(){t.current=null}):void 0}function Ws(e,t,n){return n=null!==n&&void 0!==n?n.concat([e]):null,Ds(4,4,Bs.bind(null,t,e),n)}function Vs(){}function Us(e,t){var n=xs();t=void 0===t?null:t;var a=n.memoizedState;return null!==a&&null!==t&&ms(t,a[1])?a[0]:(n.memoizedState=[e,t],e)}function Gs(e,t){var n=xs();t=void 0===t?null:t;var a=n.memoizedState;return null!==a&&null!==t&&ms(t,a[1])?a[0]:(e=e(),n.memoizedState=[e,t],e)}function Hs(e,t,n){return 0===(21&ss)?(e.baseState&&(e.baseState=!1,xi=!0),e.memoizedState=n):(ia(n,t)||(n=mt(),is.lanes|=n,Lc|=n,e.baseState=!0),t)}function js(e,t){var n=xt;xt=0!==n&&4>n?n:4,e(!0);var a=os.transition;os.transition={};try{e(!1),t()}finally{xt=n,os.transition=a}}function Ks(){return xs().memoizedState}function qs(e,t,n){var a=tl(e);if(n={lane:a,action:n,hasEagerState:!1,eagerState:null,next:null},Ys(e))Qs(t,n);else if(null!==(n=Do(e,t,n,a))){nl(n,e,a,el()),Js(n,t,a)}}function Xs(e,t,n){var a=tl(e),r={lane:a,action:n,hasEagerState:!1,eagerState:null,next:null};if(Ys(e))Qs(t,r);else{var o=e.alternate;if(0===e.lanes&&(null===o||0===o.lanes)&&null!==(o=t.lastRenderedReducer))try{var s=t.lastRenderedState,i=o(s,n);if(r.hasEagerState=!0,r.eagerState=i,ia(i,s)){var c=t.interleaved;return null===c?(r.next=r,Oo(t)):(r.next=c.next,c.next=r),void(t.interleaved=r)}}catch(l){}null!==(n=Do(e,t,r,a))&&(nl(n,e,a,r=el()),Js(n,t,a))}}function Ys(e){var t=e.alternate;return e===is||null!==t&&t===is}function Qs(e,t){ds=us=!0;var n=e.pending;null===n?t.next=t:(t.next=n.next,n.next=t),e.pending=t}function Js(e,t,n){if(0!==(4194240&n)){var a=t.lanes;n|=a&=e.pendingLanes,t.lanes=n,yt(e,n)}}var Zs={readContext:Ao,useCallback:fs,useContext:fs,useEffect:fs,useImperativeHandle:fs,useInsertionEffect:fs,useLayoutEffect:fs,useMemo:fs,useReducer:fs,useRef:fs,useState:fs,useDebugValue:fs,useDeferredValue:fs,useTransition:fs,useMutableSource:fs,useSyncExternalStore:fs,useId:fs,unstable_isNewReconciler:!1},$s={readContext:Ao,useCallback:function(e,t){return ys().memoizedState=[e,void 0===t?null:t],e},useContext:Ao,useEffect:Ms,useImperativeHandle:function(e,t,n){return n=null!==n&&void 0!==n?n.concat([e]):null,Os(4194308,4,Bs.bind(null,t,e),n)},useLayoutEffect:function(e,t){return Os(4194308,4,e,t)},useInsertionEffect:function(e,t){return Os(4,2,e,t)},useMemo:function(e,t){var n=ys();return t=void 0===t?null:t,e=e(),n.memoizedState=[e,t],e},useReducer:function(e,t,n){var a=ys();return t=void 0!==n?n(t):t,a.memoizedState=a.baseState=t,e={pending:null,interleaved:null,lanes:0,dispatch:null,lastRenderedReducer:e,lastRenderedState:t},a.queue=e,e=e.dispatch=qs.bind(null,is,e),[a.memoizedState,e]},useRef:function(e){return e={current:e},ys().memoizedState=e},useState:_s,useDebugValue:Vs,useDeferredValue:function(e){return ys().memoizedState=e},useTransition:function(){var e=_s(!1),t=e[0];return e=js.bind(null,e[1]),ys().memoizedState=e,[t,e]},useMutableSource:function(){},useSyncExternalStore:function(e,t,n){var a=is,r=ys();if(ro){if(void 0===n)throw Error(o(407));n=n()}else{if(n=t(),null===Rc)throw Error(o(349));0!==(30&ss)||Ns(a,t,n)}r.memoizedState=n;var s={value:n,getSnapshot:t};return r.queue=s,Ms(Ts.bind(null,a,s,e),[e]),a.flags|=2048,As(9,Cs.bind(null,a,s,n,t),void 0,null),n},useId:function(){var e=ys(),t=Rc.identifierPrefix;if(ro){var n=Jr;t=":"+t+"R"+(n=(Qr&~(1<<32-st(Qr)-1)).toString(32)+n),0<(n=hs++)&&(t+="H"+n.toString(32)),t+=":"}else t=":"+t+"r"+(n=ps++).toString(32)+":";return e.memoizedState=t},unstable_isNewReconciler:!1},ei={readContext:Ao,useCallback:Us,useContext:Ao,useEffect:Ls,useImperativeHandle:Ws,useInsertionEffect:Ps,useLayoutEffect:zs,useMemo:Gs,useReducer:ws,useRef:Fs,useState:function(){return ws(vs)},useDebugValue:Vs,useDeferredValue:function(e){return Hs(xs(),cs.memoizedState,e)},useTransition:function(){return[ws(vs)[0],xs().memoizedState]},useMutableSource:Is,useSyncExternalStore:Ss,useId:Ks,unstable_isNewReconciler:!1},ti={readContext:Ao,useCallback:Us,useContext:Ao,useEffect:Ls,useImperativeHandle:Ws,useInsertionEffect:Ps,useLayoutEffect:zs,useMemo:Gs,useReducer:ks,useRef:Fs,useState:function(){return ks(vs)},useDebugValue:Vs,useDeferredValue:function(e){var t=xs();return null===cs?t.memoizedState=e:Hs(t,cs.memoizedState,e)},useTransition:function(){return[ks(vs)[0],xs().memoizedState]},useMutableSource:Is,useSyncExternalStore:Ss,useId:Ks,unstable_isNewReconciler:!1};function ni(e,t){if(e&&e.defaultProps){for(var n in t=P({},t),e=e.defaultProps)void 0===t[n]&&(t[n]=e[n]);return t}return t}function ai(e,t,n,a){n=null===(n=n(a,t=e.memoizedState))||void 0===n?t:P({},t,n),e.memoizedState=n,0===e.lanes&&(e.updateQueue.baseState=n)}var ri={isMounted:function(e){return!!(e=e._reactInternals)&&Ue(e)===e},enqueueSetState:function(e,t,n){e=e._reactInternals;var a=el(),r=tl(e),o=Bo(a,r);o.payload=t,void 0!==n&&null!==n&&(o.callback=n),null!==(t=Wo(e,o,r))&&(nl(t,e,r,a),Vo(t,e,r))},enqueueReplaceState:function(e,t,n){e=e._reactInternals;var a=el(),r=tl(e),o=Bo(a,r);o.tag=1,o.payload=t,void 0!==n&&null!==n&&(o.callback=n),null!==(t=Wo(e,o,r))&&(nl(t,e,r,a),Vo(t,e,r))},enqueueForceUpdate:function(e,t){e=e._reactInternals;var n=el(),a=tl(e),r=Bo(n,a);r.tag=2,void 0!==t&&null!==t&&(r.callback=t),null!==(t=Wo(e,r,a))&&(nl(t,e,a,n),Vo(t,e,a))}};function oi(e,t,n,a,r,o,s){return"function"===typeof(e=e.stateNode).shouldComponentUpdate?e.shouldComponentUpdate(a,o,s):!t.prototype||!t.prototype.isPureReactComponent||(!ca(n,a)||!ca(r,o))}function si(e,t,n){var a=!1,r=Tr,o=t.contextType;return"object"===typeof o&&null!==o?o=Ao(o):(r=Fr(t)?_r:Er.current,o=(a=null!==(a=t.contextTypes)&&void 0!==a)?Ar(e,r):Tr),t=new t(n,o),e.memoizedState=null!==t.state&&void 0!==t.state?t.state:null,t.updater=ri,e.stateNode=t,t._reactInternals=e,a&&((e=e.stateNode).__reactInternalMemoizedUnmaskedChildContext=r,e.__reactInternalMemoizedMaskedChildContext=o),t}function ii(e,t,n,a){e=t.state,"function"===typeof t.componentWillReceiveProps&&t.componentWillReceiveProps(n,a),"function"===typeof t.UNSAFE_componentWillReceiveProps&&t.UNSAFE_componentWillReceiveProps(n,a),t.state!==e&&ri.enqueueReplaceState(t,t.state,null)}function ci(e,t,n,a){var r=e.stateNode;r.props=n,r.state=e.memoizedState,r.refs={},Po(e);var o=t.contextType;"object"===typeof o&&null!==o?r.context=Ao(o):(o=Fr(t)?_r:Er.current,r.context=Ar(e,o)),r.state=e.memoizedState,"function"===typeof(o=t.getDerivedStateFromProps)&&(ai(e,t,o,n),r.state=e.memoizedState),"function"===typeof t.getDerivedStateFromProps||"function"===typeof r.getSnapshotBeforeUpdate||"function"!==typeof r.UNSAFE_componentWillMount&&"function"!==typeof r.componentWillMount||(t=r.state,"function"===typeof r.componentWillMount&&r.componentWillMount(),"function"===typeof r.UNSAFE_componentWillMount&&r.UNSAFE_componentWillMount(),t!==r.state&&ri.enqueueReplaceState(r,r.state,null),Go(e,n,r,a),r.state=e.memoizedState),"function"===typeof r.componentDidMount&&(e.flags|=4194308)}function li(e,t){try{var n="",a=t;do{n+=V(a),a=a.return}while(a);var r=n}catch(o){r="\nError generating stack: "+o.message+"\n"+o.stack}return{value:e,source:t,stack:r,digest:null}}function ui(e,t,n){return{value:e,source:null,stack:null!=n?n:null,digest:null!=t?t:null}}function di(e,t){try{console.error(t.value)}catch(n){setTimeout((function(){throw n}))}}var hi="function"===typeof WeakMap?WeakMap:Map;function pi(e,t,n){(n=Bo(-1,n)).tag=3,n.payload={element:null};var a=t.value;return n.callback=function(){Hc||(Hc=!0,jc=a),di(0,t)},n}function fi(e,t,n){(n=Bo(-1,n)).tag=3;var a=e.type.getDerivedStateFromError;if("function"===typeof a){var r=t.value;n.payload=function(){return a(r)},n.callback=function(){di(0,t)}}var o=e.stateNode;return null!==o&&"function"===typeof o.componentDidCatch&&(n.callback=function(){di(0,t),"function"!==typeof a&&(null===Kc?Kc=new Set([this]):Kc.add(this));var e=t.stack;this.componentDidCatch(t.value,{componentStack:null!==e?e:""})}),n}function mi(e,t,n){var a=e.pingCache;if(null===a){a=e.pingCache=new hi;var r=new Set;a.set(t,r)}else void 0===(r=a.get(t))&&(r=new Set,a.set(t,r));r.has(n)||(r.add(n),e=Nl.bind(null,e,t,n),t.then(e,e))}function gi(e){do{var t;if((t=13===e.tag)&&(t=null===(t=e.memoizedState)||null!==t.dehydrated),t)return e;e=e.return}while(null!==e);return null}function bi(e,t,n,a,r){return 0===(1&e.mode)?(e===t?e.flags|=65536:(e.flags|=128,n.flags|=131072,n.flags&=-52805,1===n.tag&&(null===n.alternate?n.tag=17:((t=Bo(-1,1)).tag=2,Wo(n,t,1))),n.lanes|=1),e):(e.flags|=65536,e.lanes=r,e)}var yi=v.ReactCurrentOwner,xi=!1;function vi(e,t,n,a){t.child=null===e?ko(t,null,n,a):wo(t,e.child,n,a)}function wi(e,t,n,a,r){n=n.render;var o=t.ref;return _o(t,r),a=gs(e,t,n,a,o,r),n=bs(),null===e||xi?(ro&&n&&eo(t),t.flags|=1,vi(e,t,a,r),t.child):(t.updateQueue=e.updateQueue,t.flags&=-2053,e.lanes&=~r,Hi(e,t,r))}function ki(e,t,n,a,r){if(null===e){var o=n.type;return"function"!==typeof o||Fl(o)||void 0!==o.defaultProps||null!==n.compare||void 0!==n.defaultProps?((e=Dl(n.type,null,a,t,t.mode,r)).ref=t.ref,e.return=t,t.child=e):(t.tag=15,t.type=o,Ii(e,t,o,a,r))}if(o=e.child,0===(e.lanes&r)){var s=o.memoizedProps;if((n=null!==(n=n.compare)?n:ca)(s,a)&&e.ref===t.ref)return Hi(e,t,r)}return t.flags|=1,(e=Ol(o,a)).ref=t.ref,e.return=t,t.child=e}function Ii(e,t,n,a,r){if(null!==e){var o=e.memoizedProps;if(ca(o,a)&&e.ref===t.ref){if(xi=!1,t.pendingProps=a=o,0===(e.lanes&r))return t.lanes=e.lanes,Hi(e,t,r);0!==(131072&e.flags)&&(xi=!0)}}return Ci(e,t,n,a,r)}function Si(e,t,n){var a=t.pendingProps,r=a.children,o=null!==e?e.memoizedState:null;if("hidden"===a.mode)if(0===(1&t.mode))t.memoizedState={baseLanes:0,cachePool:null,transitions:null},Cr(Oc,Fc),Fc|=n;else{if(0===(1073741824&n))return e=null!==o?o.baseLanes|n:n,t.lanes=t.childLanes=1073741824,t.memoizedState={baseLanes:e,cachePool:null,transitions:null},t.updateQueue=null,Cr(Oc,Fc),Fc|=e,null;t.memoizedState={baseLanes:0,cachePool:null,transitions:null},a=null!==o?o.baseLanes:n,Cr(Oc,Fc),Fc|=a}else null!==o?(a=o.baseLanes|n,t.memoizedState=null):a=n,Cr(Oc,Fc),Fc|=a;return vi(e,t,r,n),t.child}function Ni(e,t){var n=t.ref;(null===e&&null!==n||null!==e&&e.ref!==n)&&(t.flags|=512,t.flags|=2097152)}function Ci(e,t,n,a,r){var o=Fr(n)?_r:Er.current;return o=Ar(t,o),_o(t,r),n=gs(e,t,n,a,o,r),a=bs(),null===e||xi?(ro&&a&&eo(t),t.flags|=1,vi(e,t,n,r),t.child):(t.updateQueue=e.updateQueue,t.flags&=-2053,e.lanes&=~r,Hi(e,t,r))}function Ti(e,t,n,a,r){if(Fr(n)){var o=!0;Lr(t)}else o=!1;if(_o(t,r),null===t.stateNode)Gi(e,t),si(t,n,a),ci(t,n,a,r),a=!0;else if(null===e){var s=t.stateNode,i=t.memoizedProps;s.props=i;var c=s.context,l=n.contextType;"object"===typeof l&&null!==l?l=Ao(l):l=Ar(t,l=Fr(n)?_r:Er.current);var u=n.getDerivedStateFromProps,d="function"===typeof u||"function"===typeof s.getSnapshotBeforeUpdate;d||"function"!==typeof s.UNSAFE_componentWillReceiveProps&&"function"!==typeof s.componentWillReceiveProps||(i!==a||c!==l)&&ii(t,s,a,l),Lo=!1;var h=t.memoizedState;s.state=h,Go(t,a,s,r),c=t.memoizedState,i!==a||h!==c||Rr.current||Lo?("function"===typeof u&&(ai(t,n,u,a),c=t.memoizedState),(i=Lo||oi(t,n,i,a,h,c,l))?(d||"function"!==typeof s.UNSAFE_componentWillMount&&"function"!==typeof s.componentWillMount||("function"===typeof s.componentWillMount&&s.componentWillMount(),"function"===typeof s.UNSAFE_componentWillMount&&s.UNSAFE_componentWillMount()),"function"===typeof s.componentDidMount&&(t.flags|=4194308)):("function"===typeof s.componentDidMount&&(t.flags|=4194308),t.memoizedProps=a,t.memoizedState=c),s.props=a,s.state=c,s.context=l,a=i):("function"===typeof s.componentDidMount&&(t.flags|=4194308),a=!1)}else{s=t.stateNode,zo(e,t),i=t.memoizedProps,l=t.type===t.elementType?i:ni(t.type,i),s.props=l,d=t.pendingProps,h=s.context,"object"===typeof(c=n.contextType)&&null!==c?c=Ao(c):c=Ar(t,c=Fr(n)?_r:Er.current);var p=n.getDerivedStateFromProps;(u="function"===typeof p||"function"===typeof s.getSnapshotBeforeUpdate)||"function"!==typeof s.UNSAFE_componentWillReceiveProps&&"function"!==typeof s.componentWillReceiveProps||(i!==d||h!==c)&&ii(t,s,a,c),Lo=!1,h=t.memoizedState,s.state=h,Go(t,a,s,r);var f=t.memoizedState;i!==d||h!==f||Rr.current||Lo?("function"===typeof p&&(ai(t,n,p,a),f=t.memoizedState),(l=Lo||oi(t,n,l,a,h,f,c)||!1)?(u||"function"!==typeof s.UNSAFE_componentWillUpdate&&"function"!==typeof s.componentWillUpdate||("function"===typeof s.componentWillUpdate&&s.componentWillUpdate(a,f,c),"function"===typeof s.UNSAFE_componentWillUpdate&&s.UNSAFE_componentWillUpdate(a,f,c)),"function"===typeof s.componentDidUpdate&&(t.flags|=4),"function"===typeof s.getSnapshotBeforeUpdate&&(t.flags|=1024)):("function"!==typeof s.componentDidUpdate||i===e.memoizedProps&&h===e.memoizedState||(t.flags|=4),"function"!==typeof s.getSnapshotBeforeUpdate||i===e.memoizedProps&&h===e.memoizedState||(t.flags|=1024),t.memoizedProps=a,t.memoizedState=f),s.props=a,s.state=f,s.context=c,a=l):("function"!==typeof s.componentDidUpdate||i===e.memoizedProps&&h===e.memoizedState||(t.flags|=4),"function"!==typeof s.getSnapshotBeforeUpdate||i===e.memoizedProps&&h===e.memoizedState||(t.flags|=1024),a=!1)}return Ei(e,t,n,a,o,r)}function Ei(e,t,n,a,r,o){Ni(e,t);var s=0!==(128&t.flags);if(!a&&!s)return r&&Pr(t,n,!1),Hi(e,t,o);a=t.stateNode,yi.current=t;var i=s&&"function"!==typeof n.getDerivedStateFromError?null:a.render();return t.flags|=1,null!==e&&s?(t.child=wo(t,e.child,null,o),t.child=wo(t,null,i,o)):vi(e,t,i,o),t.memoizedState=a.state,r&&Pr(t,n,!0),t.child}function Ri(e){var t=e.stateNode;t.pendingContext?Dr(0,t.pendingContext,t.pendingContext!==t.context):t.context&&Dr(0,t.context,!1),Qo(e,t.containerInfo)}function _i(e,t,n,a,r){return fo(),mo(r),t.flags|=256,vi(e,t,n,a),t.child}var Ai,Fi,Oi,Di,Mi={dehydrated:null,treeContext:null,retryLane:0};function Li(e){return{baseLanes:e,cachePool:null,transitions:null}}function Pi(e,t,n){var a,r=t.pendingProps,s=es.current,i=!1,c=0!==(128&t.flags);if((a=c)||(a=(null===e||null!==e.memoizedState)&&0!==(2&s)),a?(i=!0,t.flags&=-129):null!==e&&null===e.memoizedState||(s|=1),Cr(es,1&s),null===e)return lo(t),null!==(e=t.memoizedState)&&null!==(e=e.dehydrated)?(0===(1&t.mode)?t.lanes=1:"$!"===e.data?t.lanes=8:t.lanes=1073741824,null):(c=r.children,e=r.fallback,i?(r=t.mode,i=t.child,c={mode:"hidden",children:c},0===(1&r)&&null!==i?(i.childLanes=0,i.pendingProps=c):i=Ll(c,r,0,null),e=Ml(e,r,n,null),i.return=t,e.return=t,i.sibling=e,t.child=i,t.child.memoizedState=Li(n),t.memoizedState=Mi,e):zi(t,c));if(null!==(s=e.memoizedState)&&null!==(a=s.dehydrated))return function(e,t,n,a,r,s,i){if(n)return 256&t.flags?(t.flags&=-257,Bi(e,t,i,a=ui(Error(o(422))))):null!==t.memoizedState?(t.child=e.child,t.flags|=128,null):(s=a.fallback,r=t.mode,a=Ll({mode:"visible",children:a.children},r,0,null),(s=Ml(s,r,i,null)).flags|=2,a.return=t,s.return=t,a.sibling=s,t.child=a,0!==(1&t.mode)&&wo(t,e.child,null,i),t.child.memoizedState=Li(i),t.memoizedState=Mi,s);if(0===(1&t.mode))return Bi(e,t,i,null);if("$!"===r.data){if(a=r.nextSibling&&r.nextSibling.dataset)var c=a.dgst;return a=c,Bi(e,t,i,a=ui(s=Error(o(419)),a,void 0))}if(c=0!==(i&e.childLanes),xi||c){if(null!==(a=Rc)){switch(i&-i){case 4:r=2;break;case 16:r=8;break;case 64:case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:case 4194304:case 8388608:case 16777216:case 33554432:case 67108864:r=32;break;case 536870912:r=268435456;break;default:r=0}0!==(r=0!==(r&(a.suspendedLanes|i))?0:r)&&r!==s.retryLane&&(s.retryLane=r,Mo(e,r),nl(a,e,r,-1))}return ml(),Bi(e,t,i,a=ui(Error(o(421))))}return"$?"===r.data?(t.flags|=128,t.child=e.child,t=Tl.bind(null,e),r._reactRetry=t,null):(e=s.treeContext,ao=lr(r.nextSibling),no=t,ro=!0,oo=null,null!==e&&(qr[Xr++]=Qr,qr[Xr++]=Jr,qr[Xr++]=Yr,Qr=e.id,Jr=e.overflow,Yr=t),t=zi(t,a.children),t.flags|=4096,t)}(e,t,c,r,a,s,n);if(i){i=r.fallback,c=t.mode,a=(s=e.child).sibling;var l={mode:"hidden",children:r.children};return 0===(1&c)&&t.child!==s?((r=t.child).childLanes=0,r.pendingProps=l,t.deletions=null):(r=Ol(s,l)).subtreeFlags=14680064&s.subtreeFlags,null!==a?i=Ol(a,i):(i=Ml(i,c,n,null)).flags|=2,i.return=t,r.return=t,r.sibling=i,t.child=r,r=i,i=t.child,c=null===(c=e.child.memoizedState)?Li(n):{baseLanes:c.baseLanes|n,cachePool:null,transitions:c.transitions},i.memoizedState=c,i.childLanes=e.childLanes&~n,t.memoizedState=Mi,r}return e=(i=e.child).sibling,r=Ol(i,{mode:"visible",children:r.children}),0===(1&t.mode)&&(r.lanes=n),r.return=t,r.sibling=null,null!==e&&(null===(n=t.deletions)?(t.deletions=[e],t.flags|=16):n.push(e)),t.child=r,t.memoizedState=null,r}function zi(e,t){return(t=Ll({mode:"visible",children:t},e.mode,0,null)).return=e,e.child=t}function Bi(e,t,n,a){return null!==a&&mo(a),wo(t,e.child,null,n),(e=zi(t,t.pendingProps.children)).flags|=2,t.memoizedState=null,e}function Wi(e,t,n){e.lanes|=t;var a=e.alternate;null!==a&&(a.lanes|=t),Ro(e.return,t,n)}function Vi(e,t,n,a,r){var o=e.memoizedState;null===o?e.memoizedState={isBackwards:t,rendering:null,renderingStartTime:0,last:a,tail:n,tailMode:r}:(o.isBackwards=t,o.rendering=null,o.renderingStartTime=0,o.last=a,o.tail=n,o.tailMode=r)}function Ui(e,t,n){var a=t.pendingProps,r=a.revealOrder,o=a.tail;if(vi(e,t,a.children,n),0!==(2&(a=es.current)))a=1&a|2,t.flags|=128;else{if(null!==e&&0!==(128&e.flags))e:for(e=t.child;null!==e;){if(13===e.tag)null!==e.memoizedState&&Wi(e,n,t);else if(19===e.tag)Wi(e,n,t);else if(null!==e.child){e.child.return=e,e=e.child;continue}if(e===t)break e;for(;null===e.sibling;){if(null===e.return||e.return===t)break e;e=e.return}e.sibling.return=e.return,e=e.sibling}a&=1}if(Cr(es,a),0===(1&t.mode))t.memoizedState=null;else switch(r){case"forwards":for(n=t.child,r=null;null!==n;)null!==(e=n.alternate)&&null===ts(e)&&(r=n),n=n.sibling;null===(n=r)?(r=t.child,t.child=null):(r=n.sibling,n.sibling=null),Vi(t,!1,r,n,o);break;case"backwards":for(n=null,r=t.child,t.child=null;null!==r;){if(null!==(e=r.alternate)&&null===ts(e)){t.child=r;break}e=r.sibling,r.sibling=n,n=r,r=e}Vi(t,!0,n,null,o);break;case"together":Vi(t,!1,null,null,void 0);break;default:t.memoizedState=null}return t.child}function Gi(e,t){0===(1&t.mode)&&null!==e&&(e.alternate=null,t.alternate=null,t.flags|=2)}function Hi(e,t,n){if(null!==e&&(t.dependencies=e.dependencies),Lc|=t.lanes,0===(n&t.childLanes))return null;if(null!==e&&t.child!==e.child)throw Error(o(153));if(null!==t.child){for(n=Ol(e=t.child,e.pendingProps),t.child=n,n.return=t;null!==e.sibling;)e=e.sibling,(n=n.sibling=Ol(e,e.pendingProps)).return=t;n.sibling=null}return t.child}function ji(e,t){if(!ro)switch(e.tailMode){case"hidden":t=e.tail;for(var n=null;null!==t;)null!==t.alternate&&(n=t),t=t.sibling;null===n?e.tail=null:n.sibling=null;break;case"collapsed":n=e.tail;for(var a=null;null!==n;)null!==n.alternate&&(a=n),n=n.sibling;null===a?t||null===e.tail?e.tail=null:e.tail.sibling=null:a.sibling=null}}function Ki(e){var t=null!==e.alternate&&e.alternate.child===e.child,n=0,a=0;if(t)for(var r=e.child;null!==r;)n|=r.lanes|r.childLanes,a|=14680064&r.subtreeFlags,a|=14680064&r.flags,r.return=e,r=r.sibling;else for(r=e.child;null!==r;)n|=r.lanes|r.childLanes,a|=r.subtreeFlags,a|=r.flags,r.return=e,r=r.sibling;return e.subtreeFlags|=a,e.childLanes=n,t}function qi(e,t,n){var a=t.pendingProps;switch(to(t),t.tag){case 2:case 16:case 15:case 0:case 11:case 7:case 8:case 12:case 9:case 14:return Ki(t),null;case 1:case 17:return Fr(t.type)&&Or(),Ki(t),null;case 3:return a=t.stateNode,Jo(),Nr(Rr),Nr(Er),as(),a.pendingContext&&(a.context=a.pendingContext,a.pendingContext=null),null!==e&&null!==e.child||(ho(t)?t.flags|=4:null===e||e.memoizedState.isDehydrated&&0===(256&t.flags)||(t.flags|=1024,null!==oo&&(sl(oo),oo=null))),Fi(e,t),Ki(t),null;case 5:$o(t);var r=Yo(Xo.current);if(n=t.type,null!==e&&null!=t.stateNode)Oi(e,t,n,a,r),e.ref!==t.ref&&(t.flags|=512,t.flags|=2097152);else{if(!a){if(null===t.stateNode)throw Error(o(166));return Ki(t),null}if(e=Yo(Ko.current),ho(t)){a=t.stateNode,n=t.type;var s=t.memoizedProps;switch(a[hr]=t,a[pr]=s,e=0!==(1&t.mode),n){case"dialog":Ba("cancel",a),Ba("close",a);break;case"iframe":case"object":case"embed":Ba("load",a);break;case"video":case"audio":for(r=0;r<Ma.length;r++)Ba(Ma[r],a);break;case"source":Ba("error",a);break;case"img":case"image":case"link":Ba("error",a),Ba("load",a);break;case"details":Ba("toggle",a);break;case"input":Q(a,s),Ba("invalid",a);break;case"select":a._wrapperState={wasMultiple:!!s.multiple},Ba("invalid",a);break;case"textarea":re(a,s),Ba("invalid",a)}for(var c in ye(n,s),r=null,s)if(s.hasOwnProperty(c)){var l=s[c];"children"===c?"string"===typeof l?a.textContent!==l&&(!0!==s.suppressHydrationWarning&&Za(a.textContent,l,e),r=["children",l]):"number"===typeof l&&a.textContent!==""+l&&(!0!==s.suppressHydrationWarning&&Za(a.textContent,l,e),r=["children",""+l]):i.hasOwnProperty(c)&&null!=l&&"onScroll"===c&&Ba("scroll",a)}switch(n){case"input":K(a),$(a,s,!0);break;case"textarea":K(a),se(a);break;case"select":case"option":break;default:"function"===typeof s.onClick&&(a.onclick=$a)}a=r,t.updateQueue=a,null!==a&&(t.flags|=4)}else{c=9===r.nodeType?r:r.ownerDocument,"http://www.w3.org/1999/xhtml"===e&&(e=ie(n)),"http://www.w3.org/1999/xhtml"===e?"script"===n?((e=c.createElement("div")).innerHTML="<script><\/script>",e=e.removeChild(e.firstChild)):"string"===typeof a.is?e=c.createElement(n,{is:a.is}):(e=c.createElement(n),"select"===n&&(c=e,a.multiple?c.multiple=!0:a.size&&(c.size=a.size))):e=c.createElementNS(e,n),e[hr]=t,e[pr]=a,Ai(e,t,!1,!1),t.stateNode=e;e:{switch(c=xe(n,a),n){case"dialog":Ba("cancel",e),Ba("close",e),r=a;break;case"iframe":case"object":case"embed":Ba("load",e),r=a;break;case"video":case"audio":for(r=0;r<Ma.length;r++)Ba(Ma[r],e);r=a;break;case"source":Ba("error",e),r=a;break;case"img":case"image":case"link":Ba("error",e),Ba("load",e),r=a;break;case"details":Ba("toggle",e),r=a;break;case"input":Q(e,a),r=Y(e,a),Ba("invalid",e);break;case"option":default:r=a;break;case"select":e._wrapperState={wasMultiple:!!a.multiple},r=P({},a,{value:void 0}),Ba("invalid",e);break;case"textarea":re(e,a),r=ae(e,a),Ba("invalid",e)}for(s in ye(n,r),l=r)if(l.hasOwnProperty(s)){var u=l[s];"style"===s?ge(e,u):"dangerouslySetInnerHTML"===s?null!=(u=u?u.__html:void 0)&&de(e,u):"children"===s?"string"===typeof u?("textarea"!==n||""!==u)&&he(e,u):"number"===typeof u&&he(e,""+u):"suppressContentEditableWarning"!==s&&"suppressHydrationWarning"!==s&&"autoFocus"!==s&&(i.hasOwnProperty(s)?null!=u&&"onScroll"===s&&Ba("scroll",e):null!=u&&x(e,s,u,c))}switch(n){case"input":K(e),$(e,a,!1);break;case"textarea":K(e),se(e);break;case"option":null!=a.value&&e.setAttribute("value",""+H(a.value));break;case"select":e.multiple=!!a.multiple,null!=(s=a.value)?ne(e,!!a.multiple,s,!1):null!=a.defaultValue&&ne(e,!!a.multiple,a.defaultValue,!0);break;default:"function"===typeof r.onClick&&(e.onclick=$a)}switch(n){case"button":case"input":case"select":case"textarea":a=!!a.autoFocus;break e;case"img":a=!0;break e;default:a=!1}}a&&(t.flags|=4)}null!==t.ref&&(t.flags|=512,t.flags|=2097152)}return Ki(t),null;case 6:if(e&&null!=t.stateNode)Di(e,t,e.memoizedProps,a);else{if("string"!==typeof a&&null===t.stateNode)throw Error(o(166));if(n=Yo(Xo.current),Yo(Ko.current),ho(t)){if(a=t.stateNode,n=t.memoizedProps,a[hr]=t,(s=a.nodeValue!==n)&&null!==(e=no))switch(e.tag){case 3:Za(a.nodeValue,n,0!==(1&e.mode));break;case 5:!0!==e.memoizedProps.suppressHydrationWarning&&Za(a.nodeValue,n,0!==(1&e.mode))}s&&(t.flags|=4)}else(a=(9===n.nodeType?n:n.ownerDocument).createTextNode(a))[hr]=t,t.stateNode=a}return Ki(t),null;case 13:if(Nr(es),a=t.memoizedState,null===e||null!==e.memoizedState&&null!==e.memoizedState.dehydrated){if(ro&&null!==ao&&0!==(1&t.mode)&&0===(128&t.flags))po(),fo(),t.flags|=98560,s=!1;else if(s=ho(t),null!==a&&null!==a.dehydrated){if(null===e){if(!s)throw Error(o(318));if(!(s=null!==(s=t.memoizedState)?s.dehydrated:null))throw Error(o(317));s[hr]=t}else fo(),0===(128&t.flags)&&(t.memoizedState=null),t.flags|=4;Ki(t),s=!1}else null!==oo&&(sl(oo),oo=null),s=!0;if(!s)return 65536&t.flags?t:null}return 0!==(128&t.flags)?(t.lanes=n,t):((a=null!==a)!==(null!==e&&null!==e.memoizedState)&&a&&(t.child.flags|=8192,0!==(1&t.mode)&&(null===e||0!==(1&es.current)?0===Dc&&(Dc=3):ml())),null!==t.updateQueue&&(t.flags|=4),Ki(t),null);case 4:return Jo(),Fi(e,t),null===e&&Ua(t.stateNode.containerInfo),Ki(t),null;case 10:return Eo(t.type._context),Ki(t),null;case 19:if(Nr(es),null===(s=t.memoizedState))return Ki(t),null;if(a=0!==(128&t.flags),null===(c=s.rendering))if(a)ji(s,!1);else{if(0!==Dc||null!==e&&0!==(128&e.flags))for(e=t.child;null!==e;){if(null!==(c=ts(e))){for(t.flags|=128,ji(s,!1),null!==(a=c.updateQueue)&&(t.updateQueue=a,t.flags|=4),t.subtreeFlags=0,a=n,n=t.child;null!==n;)e=a,(s=n).flags&=14680066,null===(c=s.alternate)?(s.childLanes=0,s.lanes=e,s.child=null,s.subtreeFlags=0,s.memoizedProps=null,s.memoizedState=null,s.updateQueue=null,s.dependencies=null,s.stateNode=null):(s.childLanes=c.childLanes,s.lanes=c.lanes,s.child=c.child,s.subtreeFlags=0,s.deletions=null,s.memoizedProps=c.memoizedProps,s.memoizedState=c.memoizedState,s.updateQueue=c.updateQueue,s.type=c.type,e=c.dependencies,s.dependencies=null===e?null:{lanes:e.lanes,firstContext:e.firstContext}),n=n.sibling;return Cr(es,1&es.current|2),t.child}e=e.sibling}null!==s.tail&&Je()>Uc&&(t.flags|=128,a=!0,ji(s,!1),t.lanes=4194304)}else{if(!a)if(null!==(e=ts(c))){if(t.flags|=128,a=!0,null!==(n=e.updateQueue)&&(t.updateQueue=n,t.flags|=4),ji(s,!0),null===s.tail&&"hidden"===s.tailMode&&!c.alternate&&!ro)return Ki(t),null}else 2*Je()-s.renderingStartTime>Uc&&1073741824!==n&&(t.flags|=128,a=!0,ji(s,!1),t.lanes=4194304);s.isBackwards?(c.sibling=t.child,t.child=c):(null!==(n=s.last)?n.sibling=c:t.child=c,s.last=c)}return null!==s.tail?(t=s.tail,s.rendering=t,s.tail=t.sibling,s.renderingStartTime=Je(),t.sibling=null,n=es.current,Cr(es,a?1&n|2:1&n),t):(Ki(t),null);case 22:case 23:return dl(),a=null!==t.memoizedState,null!==e&&null!==e.memoizedState!==a&&(t.flags|=8192),a&&0!==(1&t.mode)?0!==(1073741824&Fc)&&(Ki(t),6&t.subtreeFlags&&(t.flags|=8192)):Ki(t),null;case 24:case 25:return null}throw Error(o(156,t.tag))}function Xi(e,t){switch(to(t),t.tag){case 1:return Fr(t.type)&&Or(),65536&(e=t.flags)?(t.flags=-65537&e|128,t):null;case 3:return Jo(),Nr(Rr),Nr(Er),as(),0!==(65536&(e=t.flags))&&0===(128&e)?(t.flags=-65537&e|128,t):null;case 5:return $o(t),null;case 13:if(Nr(es),null!==(e=t.memoizedState)&&null!==e.dehydrated){if(null===t.alternate)throw Error(o(340));fo()}return 65536&(e=t.flags)?(t.flags=-65537&e|128,t):null;case 19:return Nr(es),null;case 4:return Jo(),null;case 10:return Eo(t.type._context),null;case 22:case 23:return dl(),null;default:return null}}Ai=function(e,t){for(var n=t.child;null!==n;){if(5===n.tag||6===n.tag)e.appendChild(n.stateNode);else if(4!==n.tag&&null!==n.child){n.child.return=n,n=n.child;continue}if(n===t)break;for(;null===n.sibling;){if(null===n.return||n.return===t)return;n=n.return}n.sibling.return=n.return,n=n.sibling}},Fi=function(){},Oi=function(e,t,n,a){var r=e.memoizedProps;if(r!==a){e=t.stateNode,Yo(Ko.current);var o,s=null;switch(n){case"input":r=Y(e,r),a=Y(e,a),s=[];break;case"select":r=P({},r,{value:void 0}),a=P({},a,{value:void 0}),s=[];break;case"textarea":r=ae(e,r),a=ae(e,a),s=[];break;default:"function"!==typeof r.onClick&&"function"===typeof a.onClick&&(e.onclick=$a)}for(u in ye(n,a),n=null,r)if(!a.hasOwnProperty(u)&&r.hasOwnProperty(u)&&null!=r[u])if("style"===u){var c=r[u];for(o in c)c.hasOwnProperty(o)&&(n||(n={}),n[o]="")}else"dangerouslySetInnerHTML"!==u&&"children"!==u&&"suppressContentEditableWarning"!==u&&"suppressHydrationWarning"!==u&&"autoFocus"!==u&&(i.hasOwnProperty(u)?s||(s=[]):(s=s||[]).push(u,null));for(u in a){var l=a[u];if(c=null!=r?r[u]:void 0,a.hasOwnProperty(u)&&l!==c&&(null!=l||null!=c))if("style"===u)if(c){for(o in c)!c.hasOwnProperty(o)||l&&l.hasOwnProperty(o)||(n||(n={}),n[o]="");for(o in l)l.hasOwnProperty(o)&&c[o]!==l[o]&&(n||(n={}),n[o]=l[o])}else n||(s||(s=[]),s.push(u,n)),n=l;else"dangerouslySetInnerHTML"===u?(l=l?l.__html:void 0,c=c?c.__html:void 0,null!=l&&c!==l&&(s=s||[]).push(u,l)):"children"===u?"string"!==typeof l&&"number"!==typeof l||(s=s||[]).push(u,""+l):"suppressContentEditableWarning"!==u&&"suppressHydrationWarning"!==u&&(i.hasOwnProperty(u)?(null!=l&&"onScroll"===u&&Ba("scroll",e),s||c===l||(s=[])):(s=s||[]).push(u,l))}n&&(s=s||[]).push("style",n);var u=s;(t.updateQueue=u)&&(t.flags|=4)}},Di=function(e,t,n,a){n!==a&&(t.flags|=4)};var Yi=!1,Qi=!1,Ji="function"===typeof WeakSet?WeakSet:Set,Zi=null;function $i(e,t){var n=e.ref;if(null!==n)if("function"===typeof n)try{n(null)}catch(a){Sl(e,t,a)}else n.current=null}function ec(e,t,n){try{n()}catch(a){Sl(e,t,a)}}var tc=!1;function nc(e,t,n){var a=t.updateQueue;if(null!==(a=null!==a?a.lastEffect:null)){var r=a=a.next;do{if((r.tag&e)===e){var o=r.destroy;r.destroy=void 0,void 0!==o&&ec(t,n,o)}r=r.next}while(r!==a)}}function ac(e,t){if(null!==(t=null!==(t=t.updateQueue)?t.lastEffect:null)){var n=t=t.next;do{if((n.tag&e)===e){var a=n.create;n.destroy=a()}n=n.next}while(n!==t)}}function rc(e){var t=e.ref;if(null!==t){var n=e.stateNode;e.tag,e=n,"function"===typeof t?t(e):t.current=e}}function oc(e){var t=e.alternate;null!==t&&(e.alternate=null,oc(t)),e.child=null,e.deletions=null,e.sibling=null,5===e.tag&&(null!==(t=e.stateNode)&&(delete t[hr],delete t[pr],delete t[mr],delete t[gr],delete t[br])),e.stateNode=null,e.return=null,e.dependencies=null,e.memoizedProps=null,e.memoizedState=null,e.pendingProps=null,e.stateNode=null,e.updateQueue=null}function sc(e){return 5===e.tag||3===e.tag||4===e.tag}function ic(e){e:for(;;){for(;null===e.sibling;){if(null===e.return||sc(e.return))return null;e=e.return}for(e.sibling.return=e.return,e=e.sibling;5!==e.tag&&6!==e.tag&&18!==e.tag;){if(2&e.flags)continue e;if(null===e.child||4===e.tag)continue e;e.child.return=e,e=e.child}if(!(2&e.flags))return e.stateNode}}function cc(e,t,n){var a=e.tag;if(5===a||6===a)e=e.stateNode,t?8===n.nodeType?n.parentNode.insertBefore(e,t):n.insertBefore(e,t):(8===n.nodeType?(t=n.parentNode).insertBefore(e,n):(t=n).appendChild(e),null!==(n=n._reactRootContainer)&&void 0!==n||null!==t.onclick||(t.onclick=$a));else if(4!==a&&null!==(e=e.child))for(cc(e,t,n),e=e.sibling;null!==e;)cc(e,t,n),e=e.sibling}function lc(e,t,n){var a=e.tag;if(5===a||6===a)e=e.stateNode,t?n.insertBefore(e,t):n.appendChild(e);else if(4!==a&&null!==(e=e.child))for(lc(e,t,n),e=e.sibling;null!==e;)lc(e,t,n),e=e.sibling}var uc=null,dc=!1;function hc(e,t,n){for(n=n.child;null!==n;)pc(e,t,n),n=n.sibling}function pc(e,t,n){if(ot&&"function"===typeof ot.onCommitFiberUnmount)try{ot.onCommitFiberUnmount(rt,n)}catch(i){}switch(n.tag){case 5:Qi||$i(n,t);case 6:var a=uc,r=dc;uc=null,hc(e,t,n),dc=r,null!==(uc=a)&&(dc?(e=uc,n=n.stateNode,8===e.nodeType?e.parentNode.removeChild(n):e.removeChild(n)):uc.removeChild(n.stateNode));break;case 18:null!==uc&&(dc?(e=uc,n=n.stateNode,8===e.nodeType?cr(e.parentNode,n):1===e.nodeType&&cr(e,n),Ut(e)):cr(uc,n.stateNode));break;case 4:a=uc,r=dc,uc=n.stateNode.containerInfo,dc=!0,hc(e,t,n),uc=a,dc=r;break;case 0:case 11:case 14:case 15:if(!Qi&&(null!==(a=n.updateQueue)&&null!==(a=a.lastEffect))){r=a=a.next;do{var o=r,s=o.destroy;o=o.tag,void 0!==s&&(0!==(2&o)||0!==(4&o))&&ec(n,t,s),r=r.next}while(r!==a)}hc(e,t,n);break;case 1:if(!Qi&&($i(n,t),"function"===typeof(a=n.stateNode).componentWillUnmount))try{a.props=n.memoizedProps,a.state=n.memoizedState,a.componentWillUnmount()}catch(i){Sl(n,t,i)}hc(e,t,n);break;case 21:hc(e,t,n);break;case 22:1&n.mode?(Qi=(a=Qi)||null!==n.memoizedState,hc(e,t,n),Qi=a):hc(e,t,n);break;default:hc(e,t,n)}}function fc(e){var t=e.updateQueue;if(null!==t){e.updateQueue=null;var n=e.stateNode;null===n&&(n=e.stateNode=new Ji),t.forEach((function(t){var a=El.bind(null,e,t);n.has(t)||(n.add(t),t.then(a,a))}))}}function mc(e,t){var n=t.deletions;if(null!==n)for(var a=0;a<n.length;a++){var r=n[a];try{var s=e,i=t,c=i;e:for(;null!==c;){switch(c.tag){case 5:uc=c.stateNode,dc=!1;break e;case 3:case 4:uc=c.stateNode.containerInfo,dc=!0;break e}c=c.return}if(null===uc)throw Error(o(160));pc(s,i,r),uc=null,dc=!1;var l=r.alternate;null!==l&&(l.return=null),r.return=null}catch(u){Sl(r,t,u)}}if(12854&t.subtreeFlags)for(t=t.child;null!==t;)gc(t,e),t=t.sibling}function gc(e,t){var n=e.alternate,a=e.flags;switch(e.tag){case 0:case 11:case 14:case 15:if(mc(t,e),bc(e),4&a){try{nc(3,e,e.return),ac(3,e)}catch(g){Sl(e,e.return,g)}try{nc(5,e,e.return)}catch(g){Sl(e,e.return,g)}}break;case 1:mc(t,e),bc(e),512&a&&null!==n&&$i(n,n.return);break;case 5:if(mc(t,e),bc(e),512&a&&null!==n&&$i(n,n.return),32&e.flags){var r=e.stateNode;try{he(r,"")}catch(g){Sl(e,e.return,g)}}if(4&a&&null!=(r=e.stateNode)){var s=e.memoizedProps,i=null!==n?n.memoizedProps:s,c=e.type,l=e.updateQueue;if(e.updateQueue=null,null!==l)try{"input"===c&&"radio"===s.type&&null!=s.name&&J(r,s),xe(c,i);var u=xe(c,s);for(i=0;i<l.length;i+=2){var d=l[i],h=l[i+1];"style"===d?ge(r,h):"dangerouslySetInnerHTML"===d?de(r,h):"children"===d?he(r,h):x(r,d,h,u)}switch(c){case"input":Z(r,s);break;case"textarea":oe(r,s);break;case"select":var p=r._wrapperState.wasMultiple;r._wrapperState.wasMultiple=!!s.multiple;var f=s.value;null!=f?ne(r,!!s.multiple,f,!1):p!==!!s.multiple&&(null!=s.defaultValue?ne(r,!!s.multiple,s.defaultValue,!0):ne(r,!!s.multiple,s.multiple?[]:"",!1))}r[pr]=s}catch(g){Sl(e,e.return,g)}}break;case 6:if(mc(t,e),bc(e),4&a){if(null===e.stateNode)throw Error(o(162));r=e.stateNode,s=e.memoizedProps;try{r.nodeValue=s}catch(g){Sl(e,e.return,g)}}break;case 3:if(mc(t,e),bc(e),4&a&&null!==n&&n.memoizedState.isDehydrated)try{Ut(t.containerInfo)}catch(g){Sl(e,e.return,g)}break;case 4:default:mc(t,e),bc(e);break;case 13:mc(t,e),bc(e),8192&(r=e.child).flags&&(s=null!==r.memoizedState,r.stateNode.isHidden=s,!s||null!==r.alternate&&null!==r.alternate.memoizedState||(Vc=Je())),4&a&&fc(e);break;case 22:if(d=null!==n&&null!==n.memoizedState,1&e.mode?(Qi=(u=Qi)||d,mc(t,e),Qi=u):mc(t,e),bc(e),8192&a){if(u=null!==e.memoizedState,(e.stateNode.isHidden=u)&&!d&&0!==(1&e.mode))for(Zi=e,d=e.child;null!==d;){for(h=Zi=d;null!==Zi;){switch(f=(p=Zi).child,p.tag){case 0:case 11:case 14:case 15:nc(4,p,p.return);break;case 1:$i(p,p.return);var m=p.stateNode;if("function"===typeof m.componentWillUnmount){a=p,n=p.return;try{t=a,m.props=t.memoizedProps,m.state=t.memoizedState,m.componentWillUnmount()}catch(g){Sl(a,n,g)}}break;case 5:$i(p,p.return);break;case 22:if(null!==p.memoizedState){wc(h);continue}}null!==f?(f.return=p,Zi=f):wc(h)}d=d.sibling}e:for(d=null,h=e;;){if(5===h.tag){if(null===d){d=h;try{r=h.stateNode,u?"function"===typeof(s=r.style).setProperty?s.setProperty("display","none","important"):s.display="none":(c=h.stateNode,i=void 0!==(l=h.memoizedProps.style)&&null!==l&&l.hasOwnProperty("display")?l.display:null,c.style.display=me("display",i))}catch(g){Sl(e,e.return,g)}}}else if(6===h.tag){if(null===d)try{h.stateNode.nodeValue=u?"":h.memoizedProps}catch(g){Sl(e,e.return,g)}}else if((22!==h.tag&&23!==h.tag||null===h.memoizedState||h===e)&&null!==h.child){h.child.return=h,h=h.child;continue}if(h===e)break e;for(;null===h.sibling;){if(null===h.return||h.return===e)break e;d===h&&(d=null),h=h.return}d===h&&(d=null),h.sibling.return=h.return,h=h.sibling}}break;case 19:mc(t,e),bc(e),4&a&&fc(e);case 21:}}function bc(e){var t=e.flags;if(2&t){try{e:{for(var n=e.return;null!==n;){if(sc(n)){var a=n;break e}n=n.return}throw Error(o(160))}switch(a.tag){case 5:var r=a.stateNode;32&a.flags&&(he(r,""),a.flags&=-33),lc(e,ic(e),r);break;case 3:case 4:var s=a.stateNode.containerInfo;cc(e,ic(e),s);break;default:throw Error(o(161))}}catch(i){Sl(e,e.return,i)}e.flags&=-3}4096&t&&(e.flags&=-4097)}function yc(e,t,n){Zi=e,xc(e,t,n)}function xc(e,t,n){for(var a=0!==(1&e.mode);null!==Zi;){var r=Zi,o=r.child;if(22===r.tag&&a){var s=null!==r.memoizedState||Yi;if(!s){var i=r.alternate,c=null!==i&&null!==i.memoizedState||Qi;i=Yi;var l=Qi;if(Yi=s,(Qi=c)&&!l)for(Zi=r;null!==Zi;)c=(s=Zi).child,22===s.tag&&null!==s.memoizedState?kc(r):null!==c?(c.return=s,Zi=c):kc(r);for(;null!==o;)Zi=o,xc(o,t,n),o=o.sibling;Zi=r,Yi=i,Qi=l}vc(e)}else 0!==(8772&r.subtreeFlags)&&null!==o?(o.return=r,Zi=o):vc(e)}}function vc(e){for(;null!==Zi;){var t=Zi;if(0!==(8772&t.flags)){var n=t.alternate;try{if(0!==(8772&t.flags))switch(t.tag){case 0:case 11:case 15:Qi||ac(5,t);break;case 1:var a=t.stateNode;if(4&t.flags&&!Qi)if(null===n)a.componentDidMount();else{var r=t.elementType===t.type?n.memoizedProps:ni(t.type,n.memoizedProps);a.componentDidUpdate(r,n.memoizedState,a.__reactInternalSnapshotBeforeUpdate)}var s=t.updateQueue;null!==s&&Ho(t,s,a);break;case 3:var i=t.updateQueue;if(null!==i){if(n=null,null!==t.child)switch(t.child.tag){case 5:case 1:n=t.child.stateNode}Ho(t,i,n)}break;case 5:var c=t.stateNode;if(null===n&&4&t.flags){n=c;var l=t.memoizedProps;switch(t.type){case"button":case"input":case"select":case"textarea":l.autoFocus&&n.focus();break;case"img":l.src&&(n.src=l.src)}}break;case 6:case 4:case 12:case 19:case 17:case 21:case 22:case 23:case 25:break;case 13:if(null===t.memoizedState){var u=t.alternate;if(null!==u){var d=u.memoizedState;if(null!==d){var h=d.dehydrated;null!==h&&Ut(h)}}}break;default:throw Error(o(163))}Qi||512&t.flags&&rc(t)}catch(p){Sl(t,t.return,p)}}if(t===e){Zi=null;break}if(null!==(n=t.sibling)){n.return=t.return,Zi=n;break}Zi=t.return}}function wc(e){for(;null!==Zi;){var t=Zi;if(t===e){Zi=null;break}var n=t.sibling;if(null!==n){n.return=t.return,Zi=n;break}Zi=t.return}}function kc(e){for(;null!==Zi;){var t=Zi;try{switch(t.tag){case 0:case 11:case 15:var n=t.return;try{ac(4,t)}catch(c){Sl(t,n,c)}break;case 1:var a=t.stateNode;if("function"===typeof a.componentDidMount){var r=t.return;try{a.componentDidMount()}catch(c){Sl(t,r,c)}}var o=t.return;try{rc(t)}catch(c){Sl(t,o,c)}break;case 5:var s=t.return;try{rc(t)}catch(c){Sl(t,s,c)}}}catch(c){Sl(t,t.return,c)}if(t===e){Zi=null;break}var i=t.sibling;if(null!==i){i.return=t.return,Zi=i;break}Zi=t.return}}var Ic,Sc=Math.ceil,Nc=v.ReactCurrentDispatcher,Cc=v.ReactCurrentOwner,Tc=v.ReactCurrentBatchConfig,Ec=0,Rc=null,_c=null,Ac=0,Fc=0,Oc=Sr(0),Dc=0,Mc=null,Lc=0,Pc=0,zc=0,Bc=null,Wc=null,Vc=0,Uc=1/0,Gc=null,Hc=!1,jc=null,Kc=null,qc=!1,Xc=null,Yc=0,Qc=0,Jc=null,Zc=-1,$c=0;function el(){return 0!==(6&Ec)?Je():-1!==Zc?Zc:Zc=Je()}function tl(e){return 0===(1&e.mode)?1:0!==(2&Ec)&&0!==Ac?Ac&-Ac:null!==go.transition?(0===$c&&($c=mt()),$c):0!==(e=xt)?e:e=void 0===(e=window.event)?16:Qt(e.type)}function nl(e,t,n,a){if(50<Qc)throw Qc=0,Jc=null,Error(o(185));bt(e,n,a),0!==(2&Ec)&&e===Rc||(e===Rc&&(0===(2&Ec)&&(Pc|=n),4===Dc&&il(e,Ac)),al(e,a),1===n&&0===Ec&&0===(1&t.mode)&&(Uc=Je()+500,Br&&Ur()))}function al(e,t){var n=e.callbackNode;!function(e,t){for(var n=e.suspendedLanes,a=e.pingedLanes,r=e.expirationTimes,o=e.pendingLanes;0<o;){var s=31-st(o),i=1<<s,c=r[s];-1===c?0!==(i&n)&&0===(i&a)||(r[s]=pt(i,t)):c<=t&&(e.expiredLanes|=i),o&=~i}}(e,t);var a=ht(e,e===Rc?Ac:0);if(0===a)null!==n&&Xe(n),e.callbackNode=null,e.callbackPriority=0;else if(t=a&-a,e.callbackPriority!==t){if(null!=n&&Xe(n),1===t)0===e.tag?function(e){Br=!0,Vr(e)}(cl.bind(null,e)):Vr(cl.bind(null,e)),sr((function(){0===(6&Ec)&&Ur()})),n=null;else{switch(vt(a)){case 1:n=$e;break;case 4:n=et;break;case 16:default:n=tt;break;case 536870912:n=at}n=Rl(n,rl.bind(null,e))}e.callbackPriority=t,e.callbackNode=n}}function rl(e,t){if(Zc=-1,$c=0,0!==(6&Ec))throw Error(o(327));var n=e.callbackNode;if(kl()&&e.callbackNode!==n)return null;var a=ht(e,e===Rc?Ac:0);if(0===a)return null;if(0!==(30&a)||0!==(a&e.expiredLanes)||t)t=gl(e,a);else{t=a;var r=Ec;Ec|=2;var s=fl();for(Rc===e&&Ac===t||(Gc=null,Uc=Je()+500,hl(e,t));;)try{yl();break}catch(c){pl(e,c)}To(),Nc.current=s,Ec=r,null!==_c?t=0:(Rc=null,Ac=0,t=Dc)}if(0!==t){if(2===t&&(0!==(r=ft(e))&&(a=r,t=ol(e,r))),1===t)throw n=Mc,hl(e,0),il(e,a),al(e,Je()),n;if(6===t)il(e,a);else{if(r=e.current.alternate,0===(30&a)&&!function(e){for(var t=e;;){if(16384&t.flags){var n=t.updateQueue;if(null!==n&&null!==(n=n.stores))for(var a=0;a<n.length;a++){var r=n[a],o=r.getSnapshot;r=r.value;try{if(!ia(o(),r))return!1}catch(i){return!1}}}if(n=t.child,16384&t.subtreeFlags&&null!==n)n.return=t,t=n;else{if(t===e)break;for(;null===t.sibling;){if(null===t.return||t.return===e)return!0;t=t.return}t.sibling.return=t.return,t=t.sibling}}return!0}(r)&&(2===(t=gl(e,a))&&(0!==(s=ft(e))&&(a=s,t=ol(e,s))),1===t))throw n=Mc,hl(e,0),il(e,a),al(e,Je()),n;switch(e.finishedWork=r,e.finishedLanes=a,t){case 0:case 1:throw Error(o(345));case 2:case 5:wl(e,Wc,Gc);break;case 3:if(il(e,a),(130023424&a)===a&&10<(t=Vc+500-Je())){if(0!==ht(e,0))break;if(((r=e.suspendedLanes)&a)!==a){el(),e.pingedLanes|=e.suspendedLanes&r;break}e.timeoutHandle=ar(wl.bind(null,e,Wc,Gc),t);break}wl(e,Wc,Gc);break;case 4:if(il(e,a),(4194240&a)===a)break;for(t=e.eventTimes,r=-1;0<a;){var i=31-st(a);s=1<<i,(i=t[i])>r&&(r=i),a&=~s}if(a=r,10<(a=(120>(a=Je()-a)?120:480>a?480:1080>a?1080:1920>a?1920:3e3>a?3e3:4320>a?4320:1960*Sc(a/1960))-a)){e.timeoutHandle=ar(wl.bind(null,e,Wc,Gc),a);break}wl(e,Wc,Gc);break;default:throw Error(o(329))}}}return al(e,Je()),e.callbackNode===n?rl.bind(null,e):null}function ol(e,t){var n=Bc;return e.current.memoizedState.isDehydrated&&(hl(e,t).flags|=256),2!==(e=gl(e,t))&&(t=Wc,Wc=n,null!==t&&sl(t)),e}function sl(e){null===Wc?Wc=e:Wc.push.apply(Wc,e)}function il(e,t){for(t&=~zc,t&=~Pc,e.suspendedLanes|=t,e.pingedLanes&=~t,e=e.expirationTimes;0<t;){var n=31-st(t),a=1<<n;e[n]=-1,t&=~a}}function cl(e){if(0!==(6&Ec))throw Error(o(327));kl();var t=ht(e,0);if(0===(1&t))return al(e,Je()),null;var n=gl(e,t);if(0!==e.tag&&2===n){var a=ft(e);0!==a&&(t=a,n=ol(e,a))}if(1===n)throw n=Mc,hl(e,0),il(e,t),al(e,Je()),n;if(6===n)throw Error(o(345));return e.finishedWork=e.current.alternate,e.finishedLanes=t,wl(e,Wc,Gc),al(e,Je()),null}function ll(e,t){var n=Ec;Ec|=1;try{return e(t)}finally{0===(Ec=n)&&(Uc=Je()+500,Br&&Ur())}}function ul(e){null!==Xc&&0===Xc.tag&&0===(6&Ec)&&kl();var t=Ec;Ec|=1;var n=Tc.transition,a=xt;try{if(Tc.transition=null,xt=1,e)return e()}finally{xt=a,Tc.transition=n,0===(6&(Ec=t))&&Ur()}}function dl(){Fc=Oc.current,Nr(Oc)}function hl(e,t){e.finishedWork=null,e.finishedLanes=0;var n=e.timeoutHandle;if(-1!==n&&(e.timeoutHandle=-1,rr(n)),null!==_c)for(n=_c.return;null!==n;){var a=n;switch(to(a),a.tag){case 1:null!==(a=a.type.childContextTypes)&&void 0!==a&&Or();break;case 3:Jo(),Nr(Rr),Nr(Er),as();break;case 5:$o(a);break;case 4:Jo();break;case 13:case 19:Nr(es);break;case 10:Eo(a.type._context);break;case 22:case 23:dl()}n=n.return}if(Rc=e,_c=e=Ol(e.current,null),Ac=Fc=t,Dc=0,Mc=null,zc=Pc=Lc=0,Wc=Bc=null,null!==Fo){for(t=0;t<Fo.length;t++)if(null!==(a=(n=Fo[t]).interleaved)){n.interleaved=null;var r=a.next,o=n.pending;if(null!==o){var s=o.next;o.next=r,a.next=s}n.pending=a}Fo=null}return e}function pl(e,t){for(;;){var n=_c;try{if(To(),rs.current=Zs,us){for(var a=is.memoizedState;null!==a;){var r=a.queue;null!==r&&(r.pending=null),a=a.next}us=!1}if(ss=0,ls=cs=is=null,ds=!1,hs=0,Cc.current=null,null===n||null===n.return){Dc=1,Mc=t,_c=null;break}e:{var s=e,i=n.return,c=n,l=t;if(t=Ac,c.flags|=32768,null!==l&&"object"===typeof l&&"function"===typeof l.then){var u=l,d=c,h=d.tag;if(0===(1&d.mode)&&(0===h||11===h||15===h)){var p=d.alternate;p?(d.updateQueue=p.updateQueue,d.memoizedState=p.memoizedState,d.lanes=p.lanes):(d.updateQueue=null,d.memoizedState=null)}var f=gi(i);if(null!==f){f.flags&=-257,bi(f,i,c,0,t),1&f.mode&&mi(s,u,t),l=u;var m=(t=f).updateQueue;if(null===m){var g=new Set;g.add(l),t.updateQueue=g}else m.add(l);break e}if(0===(1&t)){mi(s,u,t),ml();break e}l=Error(o(426))}else if(ro&&1&c.mode){var b=gi(i);if(null!==b){0===(65536&b.flags)&&(b.flags|=256),bi(b,i,c,0,t),mo(li(l,c));break e}}s=l=li(l,c),4!==Dc&&(Dc=2),null===Bc?Bc=[s]:Bc.push(s),s=i;do{switch(s.tag){case 3:s.flags|=65536,t&=-t,s.lanes|=t,Uo(s,pi(0,l,t));break e;case 1:c=l;var y=s.type,x=s.stateNode;if(0===(128&s.flags)&&("function"===typeof y.getDerivedStateFromError||null!==x&&"function"===typeof x.componentDidCatch&&(null===Kc||!Kc.has(x)))){s.flags|=65536,t&=-t,s.lanes|=t,Uo(s,fi(s,c,t));break e}}s=s.return}while(null!==s)}vl(n)}catch(v){t=v,_c===n&&null!==n&&(_c=n=n.return);continue}break}}function fl(){var e=Nc.current;return Nc.current=Zs,null===e?Zs:e}function ml(){0!==Dc&&3!==Dc&&2!==Dc||(Dc=4),null===Rc||0===(268435455&Lc)&&0===(268435455&Pc)||il(Rc,Ac)}function gl(e,t){var n=Ec;Ec|=2;var a=fl();for(Rc===e&&Ac===t||(Gc=null,hl(e,t));;)try{bl();break}catch(r){pl(e,r)}if(To(),Ec=n,Nc.current=a,null!==_c)throw Error(o(261));return Rc=null,Ac=0,Dc}function bl(){for(;null!==_c;)xl(_c)}function yl(){for(;null!==_c&&!Ye();)xl(_c)}function xl(e){var t=Ic(e.alternate,e,Fc);e.memoizedProps=e.pendingProps,null===t?vl(e):_c=t,Cc.current=null}function vl(e){var t=e;do{var n=t.alternate;if(e=t.return,0===(32768&t.flags)){if(null!==(n=qi(n,t,Fc)))return void(_c=n)}else{if(null!==(n=Xi(n,t)))return n.flags&=32767,void(_c=n);if(null===e)return Dc=6,void(_c=null);e.flags|=32768,e.subtreeFlags=0,e.deletions=null}if(null!==(t=t.sibling))return void(_c=t);_c=t=e}while(null!==t);0===Dc&&(Dc=5)}function wl(e,t,n){var a=xt,r=Tc.transition;try{Tc.transition=null,xt=1,function(e,t,n,a){do{kl()}while(null!==Xc);if(0!==(6&Ec))throw Error(o(327));n=e.finishedWork;var r=e.finishedLanes;if(null===n)return null;if(e.finishedWork=null,e.finishedLanes=0,n===e.current)throw Error(o(177));e.callbackNode=null,e.callbackPriority=0;var s=n.lanes|n.childLanes;if(function(e,t){var n=e.pendingLanes&~t;e.pendingLanes=t,e.suspendedLanes=0,e.pingedLanes=0,e.expiredLanes&=t,e.mutableReadLanes&=t,e.entangledLanes&=t,t=e.entanglements;var a=e.eventTimes;for(e=e.expirationTimes;0<n;){var r=31-st(n),o=1<<r;t[r]=0,a[r]=-1,e[r]=-1,n&=~o}}(e,s),e===Rc&&(_c=Rc=null,Ac=0),0===(2064&n.subtreeFlags)&&0===(2064&n.flags)||qc||(qc=!0,Rl(tt,(function(){return kl(),null}))),s=0!==(15990&n.flags),0!==(15990&n.subtreeFlags)||s){s=Tc.transition,Tc.transition=null;var i=xt;xt=1;var c=Ec;Ec|=4,Cc.current=null,function(e,t){if(er=Ht,pa(e=ha())){if("selectionStart"in e)var n={start:e.selectionStart,end:e.selectionEnd};else e:{var a=(n=(n=e.ownerDocument)&&n.defaultView||window).getSelection&&n.getSelection();if(a&&0!==a.rangeCount){n=a.anchorNode;var r=a.anchorOffset,s=a.focusNode;a=a.focusOffset;try{n.nodeType,s.nodeType}catch(w){n=null;break e}var i=0,c=-1,l=-1,u=0,d=0,h=e,p=null;t:for(;;){for(var f;h!==n||0!==r&&3!==h.nodeType||(c=i+r),h!==s||0!==a&&3!==h.nodeType||(l=i+a),3===h.nodeType&&(i+=h.nodeValue.length),null!==(f=h.firstChild);)p=h,h=f;for(;;){if(h===e)break t;if(p===n&&++u===r&&(c=i),p===s&&++d===a&&(l=i),null!==(f=h.nextSibling))break;p=(h=p).parentNode}h=f}n=-1===c||-1===l?null:{start:c,end:l}}else n=null}n=n||{start:0,end:0}}else n=null;for(tr={focusedElem:e,selectionRange:n},Ht=!1,Zi=t;null!==Zi;)if(e=(t=Zi).child,0!==(1028&t.subtreeFlags)&&null!==e)e.return=t,Zi=e;else for(;null!==Zi;){t=Zi;try{var m=t.alternate;if(0!==(1024&t.flags))switch(t.tag){case 0:case 11:case 15:case 5:case 6:case 4:case 17:break;case 1:if(null!==m){var g=m.memoizedProps,b=m.memoizedState,y=t.stateNode,x=y.getSnapshotBeforeUpdate(t.elementType===t.type?g:ni(t.type,g),b);y.__reactInternalSnapshotBeforeUpdate=x}break;case 3:var v=t.stateNode.containerInfo;1===v.nodeType?v.textContent="":9===v.nodeType&&v.documentElement&&v.removeChild(v.documentElement);break;default:throw Error(o(163))}}catch(w){Sl(t,t.return,w)}if(null!==(e=t.sibling)){e.return=t.return,Zi=e;break}Zi=t.return}m=tc,tc=!1}(e,n),gc(n,e),fa(tr),Ht=!!er,tr=er=null,e.current=n,yc(n,e,r),Qe(),Ec=c,xt=i,Tc.transition=s}else e.current=n;if(qc&&(qc=!1,Xc=e,Yc=r),s=e.pendingLanes,0===s&&(Kc=null),function(e){if(ot&&"function"===typeof ot.onCommitFiberRoot)try{ot.onCommitFiberRoot(rt,e,void 0,128===(128&e.current.flags))}catch(t){}}(n.stateNode),al(e,Je()),null!==t)for(a=e.onRecoverableError,n=0;n<t.length;n++)r=t[n],a(r.value,{componentStack:r.stack,digest:r.digest});if(Hc)throw Hc=!1,e=jc,jc=null,e;0!==(1&Yc)&&0!==e.tag&&kl(),s=e.pendingLanes,0!==(1&s)?e===Jc?Qc++:(Qc=0,Jc=e):Qc=0,Ur()}(e,t,n,a)}finally{Tc.transition=r,xt=a}return null}function kl(){if(null!==Xc){var e=vt(Yc),t=Tc.transition,n=xt;try{if(Tc.transition=null,xt=16>e?16:e,null===Xc)var a=!1;else{if(e=Xc,Xc=null,Yc=0,0!==(6&Ec))throw Error(o(331));var r=Ec;for(Ec|=4,Zi=e.current;null!==Zi;){var s=Zi,i=s.child;if(0!==(16&Zi.flags)){var c=s.deletions;if(null!==c){for(var l=0;l<c.length;l++){var u=c[l];for(Zi=u;null!==Zi;){var d=Zi;switch(d.tag){case 0:case 11:case 15:nc(8,d,s)}var h=d.child;if(null!==h)h.return=d,Zi=h;else for(;null!==Zi;){var p=(d=Zi).sibling,f=d.return;if(oc(d),d===u){Zi=null;break}if(null!==p){p.return=f,Zi=p;break}Zi=f}}}var m=s.alternate;if(null!==m){var g=m.child;if(null!==g){m.child=null;do{var b=g.sibling;g.sibling=null,g=b}while(null!==g)}}Zi=s}}if(0!==(2064&s.subtreeFlags)&&null!==i)i.return=s,Zi=i;else e:for(;null!==Zi;){if(0!==(2048&(s=Zi).flags))switch(s.tag){case 0:case 11:case 15:nc(9,s,s.return)}var y=s.sibling;if(null!==y){y.return=s.return,Zi=y;break e}Zi=s.return}}var x=e.current;for(Zi=x;null!==Zi;){var v=(i=Zi).child;if(0!==(2064&i.subtreeFlags)&&null!==v)v.return=i,Zi=v;else e:for(i=x;null!==Zi;){if(0!==(2048&(c=Zi).flags))try{switch(c.tag){case 0:case 11:case 15:ac(9,c)}}catch(k){Sl(c,c.return,k)}if(c===i){Zi=null;break e}var w=c.sibling;if(null!==w){w.return=c.return,Zi=w;break e}Zi=c.return}}if(Ec=r,Ur(),ot&&"function"===typeof ot.onPostCommitFiberRoot)try{ot.onPostCommitFiberRoot(rt,e)}catch(k){}a=!0}return a}finally{xt=n,Tc.transition=t}}return!1}function Il(e,t,n){e=Wo(e,t=pi(0,t=li(n,t),1),1),t=el(),null!==e&&(bt(e,1,t),al(e,t))}function Sl(e,t,n){if(3===e.tag)Il(e,e,n);else for(;null!==t;){if(3===t.tag){Il(t,e,n);break}if(1===t.tag){var a=t.stateNode;if("function"===typeof t.type.getDerivedStateFromError||"function"===typeof a.componentDidCatch&&(null===Kc||!Kc.has(a))){t=Wo(t,e=fi(t,e=li(n,e),1),1),e=el(),null!==t&&(bt(t,1,e),al(t,e));break}}t=t.return}}function Nl(e,t,n){var a=e.pingCache;null!==a&&a.delete(t),t=el(),e.pingedLanes|=e.suspendedLanes&n,Rc===e&&(Ac&n)===n&&(4===Dc||3===Dc&&(130023424&Ac)===Ac&&500>Je()-Vc?hl(e,0):zc|=n),al(e,t)}function Cl(e,t){0===t&&(0===(1&e.mode)?t=1:(t=ut,0===(130023424&(ut<<=1))&&(ut=4194304)));var n=el();null!==(e=Mo(e,t))&&(bt(e,t,n),al(e,n))}function Tl(e){var t=e.memoizedState,n=0;null!==t&&(n=t.retryLane),Cl(e,n)}function El(e,t){var n=0;switch(e.tag){case 13:var a=e.stateNode,r=e.memoizedState;null!==r&&(n=r.retryLane);break;case 19:a=e.stateNode;break;default:throw Error(o(314))}null!==a&&a.delete(t),Cl(e,n)}function Rl(e,t){return qe(e,t)}function _l(e,t,n,a){this.tag=e,this.key=n,this.sibling=this.child=this.return=this.stateNode=this.type=this.elementType=null,this.index=0,this.ref=null,this.pendingProps=t,this.dependencies=this.memoizedState=this.updateQueue=this.memoizedProps=null,this.mode=a,this.subtreeFlags=this.flags=0,this.deletions=null,this.childLanes=this.lanes=0,this.alternate=null}function Al(e,t,n,a){return new _l(e,t,n,a)}function Fl(e){return!(!(e=e.prototype)||!e.isReactComponent)}function Ol(e,t){var n=e.alternate;return null===n?((n=Al(e.tag,t,e.key,e.mode)).elementType=e.elementType,n.type=e.type,n.stateNode=e.stateNode,n.alternate=e,e.alternate=n):(n.pendingProps=t,n.type=e.type,n.flags=0,n.subtreeFlags=0,n.deletions=null),n.flags=14680064&e.flags,n.childLanes=e.childLanes,n.lanes=e.lanes,n.child=e.child,n.memoizedProps=e.memoizedProps,n.memoizedState=e.memoizedState,n.updateQueue=e.updateQueue,t=e.dependencies,n.dependencies=null===t?null:{lanes:t.lanes,firstContext:t.firstContext},n.sibling=e.sibling,n.index=e.index,n.ref=e.ref,n}function Dl(e,t,n,a,r,s){var i=2;if(a=e,"function"===typeof e)Fl(e)&&(i=1);else if("string"===typeof e)i=5;else e:switch(e){case I:return Ml(n.children,r,s,t);case S:i=8,r|=8;break;case N:return(e=Al(12,n,t,2|r)).elementType=N,e.lanes=s,e;case R:return(e=Al(13,n,t,r)).elementType=R,e.lanes=s,e;case _:return(e=Al(19,n,t,r)).elementType=_,e.lanes=s,e;case O:return Ll(n,r,s,t);default:if("object"===typeof e&&null!==e)switch(e.$$typeof){case C:i=10;break e;case T:i=9;break e;case E:i=11;break e;case A:i=14;break e;case F:i=16,a=null;break e}throw Error(o(130,null==e?e:typeof e,""))}return(t=Al(i,n,t,r)).elementType=e,t.type=a,t.lanes=s,t}function Ml(e,t,n,a){return(e=Al(7,e,a,t)).lanes=n,e}function Ll(e,t,n,a){return(e=Al(22,e,a,t)).elementType=O,e.lanes=n,e.stateNode={isHidden:!1},e}function Pl(e,t,n){return(e=Al(6,e,null,t)).lanes=n,e}function zl(e,t,n){return(t=Al(4,null!==e.children?e.children:[],e.key,t)).lanes=n,t.stateNode={containerInfo:e.containerInfo,pendingChildren:null,implementation:e.implementation},t}function Bl(e,t,n,a,r){this.tag=t,this.containerInfo=e,this.finishedWork=this.pingCache=this.current=this.pendingChildren=null,this.timeoutHandle=-1,this.callbackNode=this.pendingContext=this.context=null,this.callbackPriority=0,this.eventTimes=gt(0),this.expirationTimes=gt(-1),this.entangledLanes=this.finishedLanes=this.mutableReadLanes=this.expiredLanes=this.pingedLanes=this.suspendedLanes=this.pendingLanes=0,this.entanglements=gt(0),this.identifierPrefix=a,this.onRecoverableError=r,this.mutableSourceEagerHydrationData=null}function Wl(e,t,n,a,r,o,s,i,c){return e=new Bl(e,t,n,i,c),1===t?(t=1,!0===o&&(t|=8)):t=0,o=Al(3,null,null,t),e.current=o,o.stateNode=e,o.memoizedState={element:a,isDehydrated:n,cache:null,transitions:null,pendingSuspenseBoundaries:null},Po(o),e}function Vl(e){if(!e)return Tr;e:{if(Ue(e=e._reactInternals)!==e||1!==e.tag)throw Error(o(170));var t=e;do{switch(t.tag){case 3:t=t.stateNode.context;break e;case 1:if(Fr(t.type)){t=t.stateNode.__reactInternalMemoizedMergedChildContext;break e}}t=t.return}while(null!==t);throw Error(o(171))}if(1===e.tag){var n=e.type;if(Fr(n))return Mr(e,n,t)}return t}function Ul(e,t,n,a,r,o,s,i,c){return(e=Wl(n,a,!0,e,0,o,0,i,c)).context=Vl(null),n=e.current,(o=Bo(a=el(),r=tl(n))).callback=void 0!==t&&null!==t?t:null,Wo(n,o,r),e.current.lanes=r,bt(e,r,a),al(e,a),e}function Gl(e,t,n,a){var r=t.current,o=el(),s=tl(r);return n=Vl(n),null===t.context?t.context=n:t.pendingContext=n,(t=Bo(o,s)).payload={element:e},null!==(a=void 0===a?null:a)&&(t.callback=a),null!==(e=Wo(r,t,s))&&(nl(e,r,s,o),Vo(e,r,s)),s}function Hl(e){return(e=e.current).child?(e.child.tag,e.child.stateNode):null}function jl(e,t){if(null!==(e=e.memoizedState)&&null!==e.dehydrated){var n=e.retryLane;e.retryLane=0!==n&&n<t?n:t}}function Kl(e,t){jl(e,t),(e=e.alternate)&&jl(e,t)}Ic=function(e,t,n){if(null!==e)if(e.memoizedProps!==t.pendingProps||Rr.current)xi=!0;else{if(0===(e.lanes&n)&&0===(128&t.flags))return xi=!1,function(e,t,n){switch(t.tag){case 3:Ri(t),fo();break;case 5:Zo(t);break;case 1:Fr(t.type)&&Lr(t);break;case 4:Qo(t,t.stateNode.containerInfo);break;case 10:var a=t.type._context,r=t.memoizedProps.value;Cr(Io,a._currentValue),a._currentValue=r;break;case 13:if(null!==(a=t.memoizedState))return null!==a.dehydrated?(Cr(es,1&es.current),t.flags|=128,null):0!==(n&t.child.childLanes)?Pi(e,t,n):(Cr(es,1&es.current),null!==(e=Hi(e,t,n))?e.sibling:null);Cr(es,1&es.current);break;case 19:if(a=0!==(n&t.childLanes),0!==(128&e.flags)){if(a)return Ui(e,t,n);t.flags|=128}if(null!==(r=t.memoizedState)&&(r.rendering=null,r.tail=null,r.lastEffect=null),Cr(es,es.current),a)break;return null;case 22:case 23:return t.lanes=0,Si(e,t,n)}return Hi(e,t,n)}(e,t,n);xi=0!==(131072&e.flags)}else xi=!1,ro&&0!==(1048576&t.flags)&&$r(t,Kr,t.index);switch(t.lanes=0,t.tag){case 2:var a=t.type;Gi(e,t),e=t.pendingProps;var r=Ar(t,Er.current);_o(t,n),r=gs(null,t,a,e,r,n);var s=bs();return t.flags|=1,"object"===typeof r&&null!==r&&"function"===typeof r.render&&void 0===r.$$typeof?(t.tag=1,t.memoizedState=null,t.updateQueue=null,Fr(a)?(s=!0,Lr(t)):s=!1,t.memoizedState=null!==r.state&&void 0!==r.state?r.state:null,Po(t),r.updater=ri,t.stateNode=r,r._reactInternals=t,ci(t,a,e,n),t=Ei(null,t,a,!0,s,n)):(t.tag=0,ro&&s&&eo(t),vi(null,t,r,n),t=t.child),t;case 16:a=t.elementType;e:{switch(Gi(e,t),e=t.pendingProps,a=(r=a._init)(a._payload),t.type=a,r=t.tag=function(e){if("function"===typeof e)return Fl(e)?1:0;if(void 0!==e&&null!==e){if((e=e.$$typeof)===E)return 11;if(e===A)return 14}return 2}(a),e=ni(a,e),r){case 0:t=Ci(null,t,a,e,n);break e;case 1:t=Ti(null,t,a,e,n);break e;case 11:t=wi(null,t,a,e,n);break e;case 14:t=ki(null,t,a,ni(a.type,e),n);break e}throw Error(o(306,a,""))}return t;case 0:return a=t.type,r=t.pendingProps,Ci(e,t,a,r=t.elementType===a?r:ni(a,r),n);case 1:return a=t.type,r=t.pendingProps,Ti(e,t,a,r=t.elementType===a?r:ni(a,r),n);case 3:e:{if(Ri(t),null===e)throw Error(o(387));a=t.pendingProps,r=(s=t.memoizedState).element,zo(e,t),Go(t,a,null,n);var i=t.memoizedState;if(a=i.element,s.isDehydrated){if(s={element:a,isDehydrated:!1,cache:i.cache,pendingSuspenseBoundaries:i.pendingSuspenseBoundaries,transitions:i.transitions},t.updateQueue.baseState=s,t.memoizedState=s,256&t.flags){t=_i(e,t,a,n,r=li(Error(o(423)),t));break e}if(a!==r){t=_i(e,t,a,n,r=li(Error(o(424)),t));break e}for(ao=lr(t.stateNode.containerInfo.firstChild),no=t,ro=!0,oo=null,n=ko(t,null,a,n),t.child=n;n;)n.flags=-3&n.flags|4096,n=n.sibling}else{if(fo(),a===r){t=Hi(e,t,n);break e}vi(e,t,a,n)}t=t.child}return t;case 5:return Zo(t),null===e&&lo(t),a=t.type,r=t.pendingProps,s=null!==e?e.memoizedProps:null,i=r.children,nr(a,r)?i=null:null!==s&&nr(a,s)&&(t.flags|=32),Ni(e,t),vi(e,t,i,n),t.child;case 6:return null===e&&lo(t),null;case 13:return Pi(e,t,n);case 4:return Qo(t,t.stateNode.containerInfo),a=t.pendingProps,null===e?t.child=wo(t,null,a,n):vi(e,t,a,n),t.child;case 11:return a=t.type,r=t.pendingProps,wi(e,t,a,r=t.elementType===a?r:ni(a,r),n);case 7:return vi(e,t,t.pendingProps,n),t.child;case 8:case 12:return vi(e,t,t.pendingProps.children,n),t.child;case 10:e:{if(a=t.type._context,r=t.pendingProps,s=t.memoizedProps,i=r.value,Cr(Io,a._currentValue),a._currentValue=i,null!==s)if(ia(s.value,i)){if(s.children===r.children&&!Rr.current){t=Hi(e,t,n);break e}}else for(null!==(s=t.child)&&(s.return=t);null!==s;){var c=s.dependencies;if(null!==c){i=s.child;for(var l=c.firstContext;null!==l;){if(l.context===a){if(1===s.tag){(l=Bo(-1,n&-n)).tag=2;var u=s.updateQueue;if(null!==u){var d=(u=u.shared).pending;null===d?l.next=l:(l.next=d.next,d.next=l),u.pending=l}}s.lanes|=n,null!==(l=s.alternate)&&(l.lanes|=n),Ro(s.return,n,t),c.lanes|=n;break}l=l.next}}else if(10===s.tag)i=s.type===t.type?null:s.child;else if(18===s.tag){if(null===(i=s.return))throw Error(o(341));i.lanes|=n,null!==(c=i.alternate)&&(c.lanes|=n),Ro(i,n,t),i=s.sibling}else i=s.child;if(null!==i)i.return=s;else for(i=s;null!==i;){if(i===t){i=null;break}if(null!==(s=i.sibling)){s.return=i.return,i=s;break}i=i.return}s=i}vi(e,t,r.children,n),t=t.child}return t;case 9:return r=t.type,a=t.pendingProps.children,_o(t,n),a=a(r=Ao(r)),t.flags|=1,vi(e,t,a,n),t.child;case 14:return r=ni(a=t.type,t.pendingProps),ki(e,t,a,r=ni(a.type,r),n);case 15:return Ii(e,t,t.type,t.pendingProps,n);case 17:return a=t.type,r=t.pendingProps,r=t.elementType===a?r:ni(a,r),Gi(e,t),t.tag=1,Fr(a)?(e=!0,Lr(t)):e=!1,_o(t,n),si(t,a,r),ci(t,a,r,n),Ei(null,t,a,!0,e,n);case 19:return Ui(e,t,n);case 22:return Si(e,t,n)}throw Error(o(156,t.tag))};var ql="function"===typeof reportError?reportError:function(e){console.error(e)};function Xl(e){this._internalRoot=e}function Yl(e){this._internalRoot=e}function Ql(e){return!(!e||1!==e.nodeType&&9!==e.nodeType&&11!==e.nodeType)}function Jl(e){return!(!e||1!==e.nodeType&&9!==e.nodeType&&11!==e.nodeType&&(8!==e.nodeType||" react-mount-point-unstable "!==e.nodeValue))}function Zl(){}function $l(e,t,n,a,r){var o=n._reactRootContainer;if(o){var s=o;if("function"===typeof r){var i=r;r=function(){var e=Hl(s);i.call(e)}}Gl(t,s,e,r)}else s=function(e,t,n,a,r){if(r){if("function"===typeof a){var o=a;a=function(){var e=Hl(s);o.call(e)}}var s=Ul(t,a,e,0,null,!1,0,"",Zl);return e._reactRootContainer=s,e[fr]=s.current,Ua(8===e.nodeType?e.parentNode:e),ul(),s}for(;r=e.lastChild;)e.removeChild(r);if("function"===typeof a){var i=a;a=function(){var e=Hl(c);i.call(e)}}var c=Wl(e,0,!1,null,0,!1,0,"",Zl);return e._reactRootContainer=c,e[fr]=c.current,Ua(8===e.nodeType?e.parentNode:e),ul((function(){Gl(t,c,n,a)})),c}(n,t,e,r,a);return Hl(s)}Yl.prototype.render=Xl.prototype.render=function(e){var t=this._internalRoot;if(null===t)throw Error(o(409));Gl(e,t,null,null)},Yl.prototype.unmount=Xl.prototype.unmount=function(){var e=this._internalRoot;if(null!==e){this._internalRoot=null;var t=e.containerInfo;ul((function(){Gl(null,e,null,null)})),t[fr]=null}},Yl.prototype.unstable_scheduleHydration=function(e){if(e){var t=St();e={blockedOn:null,target:e,priority:t};for(var n=0;n<Ot.length&&0!==t&&t<Ot[n].priority;n++);Ot.splice(n,0,e),0===n&&Pt(e)}},wt=function(e){switch(e.tag){case 3:var t=e.stateNode;if(t.current.memoizedState.isDehydrated){var n=dt(t.pendingLanes);0!==n&&(yt(t,1|n),al(t,Je()),0===(6&Ec)&&(Uc=Je()+500,Ur()))}break;case 13:ul((function(){var t=Mo(e,1);if(null!==t){var n=el();nl(t,e,1,n)}})),Kl(e,1)}},kt=function(e){if(13===e.tag){var t=Mo(e,134217728);if(null!==t)nl(t,e,134217728,el());Kl(e,134217728)}},It=function(e){if(13===e.tag){var t=tl(e),n=Mo(e,t);if(null!==n)nl(n,e,t,el());Kl(e,t)}},St=function(){return xt},Nt=function(e,t){var n=xt;try{return xt=e,t()}finally{xt=n}},ke=function(e,t,n){switch(t){case"input":if(Z(e,n),t=n.name,"radio"===n.type&&null!=t){for(n=e;n.parentNode;)n=n.parentNode;for(n=n.querySelectorAll("input[name="+JSON.stringify(""+t)+'][type="radio"]'),t=0;t<n.length;t++){var a=n[t];if(a!==e&&a.form===e.form){var r=wr(a);if(!r)throw Error(o(90));q(a),Z(a,r)}}}break;case"textarea":oe(e,n);break;case"select":null!=(t=n.value)&&ne(e,!!n.multiple,t,!1)}},Ee=ll,Re=ul;var eu={usingClientEntryPoint:!1,Events:[xr,vr,wr,Ce,Te,ll]},tu={findFiberByHostInstance:yr,bundleType:0,version:"18.3.1",rendererPackageName:"react-dom"},nu={bundleType:tu.bundleType,version:tu.version,rendererPackageName:tu.rendererPackageName,rendererConfig:tu.rendererConfig,overrideHookState:null,overrideHookStateDeletePath:null,overrideHookStateRenamePath:null,overrideProps:null,overridePropsDeletePath:null,overridePropsRenamePath:null,setErrorHandler:null,setSuspenseHandler:null,scheduleUpdate:null,currentDispatcherRef:v.ReactCurrentDispatcher,findHostInstanceByFiber:function(e){return null===(e=je(e))?null:e.stateNode},findFiberByHostInstance:tu.findFiberByHostInstance||function(){return null},findHostInstancesForRefresh:null,scheduleRefresh:null,scheduleRoot:null,setRefreshHandler:null,getCurrentFiber:null,reconcilerVersion:"18.3.1-next-f1338f8080-20240426"};if("undefined"!==typeof __REACT_DEVTOOLS_GLOBAL_HOOK__){var au=__REACT_DEVTOOLS_GLOBAL_HOOK__;if(!au.isDisabled&&au.supportsFiber)try{rt=au.inject(nu),ot=au}catch(ue){}}t.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=eu,t.createPortal=function(e,t){var n=2<arguments.length&&void 0!==arguments[2]?arguments[2]:null;if(!Ql(t))throw Error(o(200));return function(e,t,n){var a=3<arguments.length&&void 0!==arguments[3]?arguments[3]:null;return{$$typeof:k,key:null==a?null:""+a,children:e,containerInfo:t,implementation:n}}(e,t,null,n)},t.createRoot=function(e,t){if(!Ql(e))throw Error(o(299));var n=!1,a="",r=ql;return null!==t&&void 0!==t&&(!0===t.unstable_strictMode&&(n=!0),void 0!==t.identifierPrefix&&(a=t.identifierPrefix),void 0!==t.onRecoverableError&&(r=t.onRecoverableError)),t=Wl(e,1,!1,null,0,n,0,a,r),e[fr]=t.current,Ua(8===e.nodeType?e.parentNode:e),new Xl(t)},t.findDOMNode=function(e){if(null==e)return null;if(1===e.nodeType)return e;var t=e._reactInternals;if(void 0===t){if("function"===typeof e.render)throw Error(o(188));throw e=Object.keys(e).join(","),Error(o(268,e))}return e=null===(e=je(t))?null:e.stateNode},t.flushSync=function(e){return ul(e)},t.hydrate=function(e,t,n){if(!Jl(t))throw Error(o(200));return $l(null,e,t,!0,n)},t.hydrateRoot=function(e,t,n){if(!Ql(e))throw Error(o(405));var a=null!=n&&n.hydratedSources||null,r=!1,s="",i=ql;if(null!==n&&void 0!==n&&(!0===n.unstable_strictMode&&(r=!0),void 0!==n.identifierPrefix&&(s=n.identifierPrefix),void 0!==n.onRecoverableError&&(i=n.onRecoverableError)),t=Ul(t,null,e,1,null!=n?n:null,r,0,s,i),e[fr]=t.current,Ua(e),a)for(e=0;e<a.length;e++)r=(r=(n=a[e])._getVersion)(n._source),null==t.mutableSourceEagerHydrationData?t.mutableSourceEagerHydrationData=[n,r]:t.mutableSourceEagerHydrationData.push(n,r);return new Yl(t)},t.render=function(e,t,n){if(!Jl(t))throw Error(o(200));return $l(null,e,t,!1,n)},t.unmountComponentAtNode=function(e){if(!Jl(e))throw Error(o(40));return!!e._reactRootContainer&&(ul((function(){$l(null,null,e,!1,(function(){e._reactRootContainer=null,e[fr]=null}))})),!0)},t.unstable_batchedUpdates=ll,t.unstable_renderSubtreeIntoContainer=function(e,t,n,a){if(!Jl(n))throw Error(o(200));if(null==e||void 0===e._reactInternals)throw Error(o(38));return $l(e,t,n,!1,a)},t.version="18.3.1-next-f1338f8080-20240426"},391:(e,t,n)=>{"use strict";var a=n(950);t.createRoot=a.createRoot,t.hydrateRoot=a.hydrateRoot},950:(e,t,n)=>{"use strict";!function e(){if("undefined"!==typeof __REACT_DEVTOOLS_GLOBAL_HOOK__&&"function"===typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE)try{__REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(e)}catch(t){console.error(t)}}(),e.exports=n(730)},153:(e,t,n)=>{"use strict";var a=n(43),r=Symbol.for("react.element"),o=Symbol.for("react.fragment"),s=Object.prototype.hasOwnProperty,i=a.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner,c={key:!0,ref:!0,__self:!0,__source:!0};function l(e,t,n){var a,o={},l=null,u=null;for(a in void 0!==n&&(l=""+n),void 0!==t.key&&(l=""+t.key),void 0!==t.ref&&(u=t.ref),t)s.call(t,a)&&!c.hasOwnProperty(a)&&(o[a]=t[a]);if(e&&e.defaultProps)for(a in t=e.defaultProps)void 0===o[a]&&(o[a]=t[a]);return{$$typeof:r,type:e,key:l,ref:u,props:o,_owner:i.current}}t.Fragment=o,t.jsx=l,t.jsxs=l},202:(e,t)=>{"use strict";var n=Symbol.for("react.element"),a=Symbol.for("react.portal"),r=Symbol.for("react.fragment"),o=Symbol.for("react.strict_mode"),s=Symbol.for("react.profiler"),i=Symbol.for("react.provider"),c=Symbol.for("react.context"),l=Symbol.for("react.forward_ref"),u=Symbol.for("react.suspense"),d=Symbol.for("react.memo"),h=Symbol.for("react.lazy"),p=Symbol.iterator;var f={isMounted:function(){return!1},enqueueForceUpdate:function(){},enqueueReplaceState:function(){},enqueueSetState:function(){}},m=Object.assign,g={};function b(e,t,n){this.props=e,this.context=t,this.refs=g,this.updater=n||f}function y(){}function x(e,t,n){this.props=e,this.context=t,this.refs=g,this.updater=n||f}b.prototype.isReactComponent={},b.prototype.setState=function(e,t){if("object"!==typeof e&&"function"!==typeof e&&null!=e)throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");this.updater.enqueueSetState(this,e,t,"setState")},b.prototype.forceUpdate=function(e){this.updater.enqueueForceUpdate(this,e,"forceUpdate")},y.prototype=b.prototype;var v=x.prototype=new y;v.constructor=x,m(v,b.prototype),v.isPureReactComponent=!0;var w=Array.isArray,k=Object.prototype.hasOwnProperty,I={current:null},S={key:!0,ref:!0,__self:!0,__source:!0};function N(e,t,a){var r,o={},s=null,i=null;if(null!=t)for(r in void 0!==t.ref&&(i=t.ref),void 0!==t.key&&(s=""+t.key),t)k.call(t,r)&&!S.hasOwnProperty(r)&&(o[r]=t[r]);var c=arguments.length-2;if(1===c)o.children=a;else if(1<c){for(var l=Array(c),u=0;u<c;u++)l[u]=arguments[u+2];o.children=l}if(e&&e.defaultProps)for(r in c=e.defaultProps)void 0===o[r]&&(o[r]=c[r]);return{$$typeof:n,type:e,key:s,ref:i,props:o,_owner:I.current}}function C(e){return"object"===typeof e&&null!==e&&e.$$typeof===n}var T=/\/+/g;function E(e,t){return"object"===typeof e&&null!==e&&null!=e.key?function(e){var t={"=":"=0",":":"=2"};return"$"+e.replace(/[=:]/g,(function(e){return t[e]}))}(""+e.key):t.toString(36)}function R(e,t,r,o,s){var i=typeof e;"undefined"!==i&&"boolean"!==i||(e=null);var c=!1;if(null===e)c=!0;else switch(i){case"string":case"number":c=!0;break;case"object":switch(e.$$typeof){case n:case a:c=!0}}if(c)return s=s(c=e),e=""===o?"."+E(c,0):o,w(s)?(r="",null!=e&&(r=e.replace(T,"$&/")+"/"),R(s,t,r,"",(function(e){return e}))):null!=s&&(C(s)&&(s=function(e,t){return{$$typeof:n,type:e.type,key:t,ref:e.ref,props:e.props,_owner:e._owner}}(s,r+(!s.key||c&&c.key===s.key?"":(""+s.key).replace(T,"$&/")+"/")+e)),t.push(s)),1;if(c=0,o=""===o?".":o+":",w(e))for(var l=0;l<e.length;l++){var u=o+E(i=e[l],l);c+=R(i,t,r,u,s)}else if(u=function(e){return null===e||"object"!==typeof e?null:"function"===typeof(e=p&&e[p]||e["@@iterator"])?e:null}(e),"function"===typeof u)for(e=u.call(e),l=0;!(i=e.next()).done;)c+=R(i=i.value,t,r,u=o+E(i,l++),s);else if("object"===i)throw t=String(e),Error("Objects are not valid as a React child (found: "+("[object Object]"===t?"object with keys {"+Object.keys(e).join(", ")+"}":t)+"). If you meant to render a collection of children, use an array instead.");return c}function _(e,t,n){if(null==e)return e;var a=[],r=0;return R(e,a,"","",(function(e){return t.call(n,e,r++)})),a}function A(e){if(-1===e._status){var t=e._result;(t=t()).then((function(t){0!==e._status&&-1!==e._status||(e._status=1,e._result=t)}),(function(t){0!==e._status&&-1!==e._status||(e._status=2,e._result=t)})),-1===e._status&&(e._status=0,e._result=t)}if(1===e._status)return e._result.default;throw e._result}var F={current:null},O={transition:null},D={ReactCurrentDispatcher:F,ReactCurrentBatchConfig:O,ReactCurrentOwner:I};function M(){throw Error("act(...) is not supported in production builds of React.")}t.Children={map:_,forEach:function(e,t,n){_(e,(function(){t.apply(this,arguments)}),n)},count:function(e){var t=0;return _(e,(function(){t++})),t},toArray:function(e){return _(e,(function(e){return e}))||[]},only:function(e){if(!C(e))throw Error("React.Children.only expected to receive a single React element child.");return e}},t.Component=b,t.Fragment=r,t.Profiler=s,t.PureComponent=x,t.StrictMode=o,t.Suspense=u,t.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=D,t.act=M,t.cloneElement=function(e,t,a){if(null===e||void 0===e)throw Error("React.cloneElement(...): The argument must be a React element, but you passed "+e+".");var r=m({},e.props),o=e.key,s=e.ref,i=e._owner;if(null!=t){if(void 0!==t.ref&&(s=t.ref,i=I.current),void 0!==t.key&&(o=""+t.key),e.type&&e.type.defaultProps)var c=e.type.defaultProps;for(l in t)k.call(t,l)&&!S.hasOwnProperty(l)&&(r[l]=void 0===t[l]&&void 0!==c?c[l]:t[l])}var l=arguments.length-2;if(1===l)r.children=a;else if(1<l){c=Array(l);for(var u=0;u<l;u++)c[u]=arguments[u+2];r.children=c}return{$$typeof:n,type:e.type,key:o,ref:s,props:r,_owner:i}},t.createContext=function(e){return(e={$$typeof:c,_currentValue:e,_currentValue2:e,_threadCount:0,Provider:null,Consumer:null,_defaultValue:null,_globalName:null}).Provider={$$typeof:i,_context:e},e.Consumer=e},t.createElement=N,t.createFactory=function(e){var t=N.bind(null,e);return t.type=e,t},t.createRef=function(){return{current:null}},t.forwardRef=function(e){return{$$typeof:l,render:e}},t.isValidElement=C,t.lazy=function(e){return{$$typeof:h,_payload:{_status:-1,_result:e},_init:A}},t.memo=function(e,t){return{$$typeof:d,type:e,compare:void 0===t?null:t}},t.startTransition=function(e){var t=O.transition;O.transition={};try{e()}finally{O.transition=t}},t.unstable_act=M,t.useCallback=function(e,t){return F.current.useCallback(e,t)},t.useContext=function(e){return F.current.useContext(e)},t.useDebugValue=function(){},t.useDeferredValue=function(e){return F.current.useDeferredValue(e)},t.useEffect=function(e,t){return F.current.useEffect(e,t)},t.useId=function(){return F.current.useId()},t.useImperativeHandle=function(e,t,n){return F.current.useImperativeHandle(e,t,n)},t.useInsertionEffect=function(e,t){return F.current.useInsertionEffect(e,t)},t.useLayoutEffect=function(e,t){return F.current.useLayoutEffect(e,t)},t.useMemo=function(e,t){return F.current.useMemo(e,t)},t.useReducer=function(e,t,n){return F.current.useReducer(e,t,n)},t.useRef=function(e){return F.current.useRef(e)},t.useState=function(e){return F.current.useState(e)},t.useSyncExternalStore=function(e,t,n){return F.current.useSyncExternalStore(e,t,n)},t.useTransition=function(){return F.current.useTransition()},t.version="18.3.1"},43:(e,t,n)=>{"use strict";e.exports=n(202)},579:(e,t,n)=>{"use strict";e.exports=n(153)},234:(e,t)=>{"use strict";function n(e,t){var n=e.length;e.push(t);e:for(;0<n;){var a=n-1>>>1,r=e[a];if(!(0<o(r,t)))break e;e[a]=t,e[n]=r,n=a}}function a(e){return 0===e.length?null:e[0]}function r(e){if(0===e.length)return null;var t=e[0],n=e.pop();if(n!==t){e[0]=n;e:for(var a=0,r=e.length,s=r>>>1;a<s;){var i=2*(a+1)-1,c=e[i],l=i+1,u=e[l];if(0>o(c,n))l<r&&0>o(u,c)?(e[a]=u,e[l]=n,a=l):(e[a]=c,e[i]=n,a=i);else{if(!(l<r&&0>o(u,n)))break e;e[a]=u,e[l]=n,a=l}}}return t}function o(e,t){var n=e.sortIndex-t.sortIndex;return 0!==n?n:e.id-t.id}if("object"===typeof performance&&"function"===typeof performance.now){var s=performance;t.unstable_now=function(){return s.now()}}else{var i=Date,c=i.now();t.unstable_now=function(){return i.now()-c}}var l=[],u=[],d=1,h=null,p=3,f=!1,m=!1,g=!1,b="function"===typeof setTimeout?setTimeout:null,y="function"===typeof clearTimeout?clearTimeout:null,x="undefined"!==typeof setImmediate?setImmediate:null;function v(e){for(var t=a(u);null!==t;){if(null===t.callback)r(u);else{if(!(t.startTime<=e))break;r(u),t.sortIndex=t.expirationTime,n(l,t)}t=a(u)}}function w(e){if(g=!1,v(e),!m)if(null!==a(l))m=!0,O(k);else{var t=a(u);null!==t&&D(w,t.startTime-e)}}function k(e,n){m=!1,g&&(g=!1,y(C),C=-1),f=!0;var o=p;try{for(v(n),h=a(l);null!==h&&(!(h.expirationTime>n)||e&&!R());){var s=h.callback;if("function"===typeof s){h.callback=null,p=h.priorityLevel;var i=s(h.expirationTime<=n);n=t.unstable_now(),"function"===typeof i?h.callback=i:h===a(l)&&r(l),v(n)}else r(l);h=a(l)}if(null!==h)var c=!0;else{var d=a(u);null!==d&&D(w,d.startTime-n),c=!1}return c}finally{h=null,p=o,f=!1}}"undefined"!==typeof navigator&&void 0!==navigator.scheduling&&void 0!==navigator.scheduling.isInputPending&&navigator.scheduling.isInputPending.bind(navigator.scheduling);var I,S=!1,N=null,C=-1,T=5,E=-1;function R(){return!(t.unstable_now()-E<T)}function _(){if(null!==N){var e=t.unstable_now();E=e;var n=!0;try{n=N(!0,e)}finally{n?I():(S=!1,N=null)}}else S=!1}if("function"===typeof x)I=function(){x(_)};else if("undefined"!==typeof MessageChannel){var A=new MessageChannel,F=A.port2;A.port1.onmessage=_,I=function(){F.postMessage(null)}}else I=function(){b(_,0)};function O(e){N=e,S||(S=!0,I())}function D(e,n){C=b((function(){e(t.unstable_now())}),n)}t.unstable_IdlePriority=5,t.unstable_ImmediatePriority=1,t.unstable_LowPriority=4,t.unstable_NormalPriority=3,t.unstable_Profiling=null,t.unstable_UserBlockingPriority=2,t.unstable_cancelCallback=function(e){e.callback=null},t.unstable_continueExecution=function(){m||f||(m=!0,O(k))},t.unstable_forceFrameRate=function(e){0>e||125<e?console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported"):T=0<e?Math.floor(1e3/e):5},t.unstable_getCurrentPriorityLevel=function(){return p},t.unstable_getFirstCallbackNode=function(){return a(l)},t.unstable_next=function(e){switch(p){case 1:case 2:case 3:var t=3;break;default:t=p}var n=p;p=t;try{return e()}finally{p=n}},t.unstable_pauseExecution=function(){},t.unstable_requestPaint=function(){},t.unstable_runWithPriority=function(e,t){switch(e){case 1:case 2:case 3:case 4:case 5:break;default:e=3}var n=p;p=e;try{return t()}finally{p=n}},t.unstable_scheduleCallback=function(e,r,o){var s=t.unstable_now();switch("object"===typeof o&&null!==o?o="number"===typeof(o=o.delay)&&0<o?s+o:s:o=s,e){case 1:var i=-1;break;case 2:i=250;break;case 5:i=1073741823;break;case 4:i=1e4;break;default:i=5e3}return e={id:d++,callback:r,priorityLevel:e,startTime:o,expirationTime:i=o+i,sortIndex:-1},o>s?(e.sortIndex=o,n(u,e),null===a(l)&&e===a(u)&&(g?(y(C),C=-1):g=!0,D(w,o-s))):(e.sortIndex=i,n(l,e),m||f||(m=!0,O(k))),e},t.unstable_shouldYield=R,t.unstable_wrapCallback=function(e){var t=p;return function(){var n=p;p=t;try{return e.apply(this,arguments)}finally{p=n}}}},853:(e,t,n)=>{"use strict";e.exports=n(234)},334:(e,t,n)=>{var a=n(359),r=n(66),o=n(16),s=n(538),i=n(288),c=n(262),l=n(430);l.alea=a,l.xor128=r,l.xorwow=o,l.xorshift7=s,l.xor4096=i,l.tychei=c,e.exports=l},359:function(e,t,n){var a;!function(e,r,o){function s(e){var t=this,n=function(){var e=4022871197,t=function(t){t=String(t);for(var n=0;n<t.length;n++){var a=.02519603282416938*(e+=t.charCodeAt(n));a-=e=a>>>0,e=(a*=e)>>>0,e+=4294967296*(a-=e)}return 2.3283064365386963e-10*(e>>>0)};return t}();t.next=function(){var e=2091639*t.s0+2.3283064365386963e-10*t.c;return t.s0=t.s1,t.s1=t.s2,t.s2=e-(t.c=0|e)},t.c=1,t.s0=n(" "),t.s1=n(" "),t.s2=n(" "),t.s0-=n(e),t.s0<0&&(t.s0+=1),t.s1-=n(e),t.s1<0&&(t.s1+=1),t.s2-=n(e),t.s2<0&&(t.s2+=1),n=null}function i(e,t){return t.c=e.c,t.s0=e.s0,t.s1=e.s1,t.s2=e.s2,t}function c(e,t){var n=new s(e),a=t&&t.state,r=n.next;return r.int32=function(){return 4294967296*n.next()|0},r.double=function(){return r()+11102230246251565e-32*(2097152*r()|0)},r.quick=r,a&&("object"==typeof a&&i(a,n),r.state=function(){return i(n,{})}),r}r&&r.exports?r.exports=c:n.amdD&&n.amdO?void 0===(a=function(){return c}.call(t,n,t,r))||(r.exports=a):this.alea=c}(0,e=n.nmd(e),n.amdD)},262:function(e,t,n){var a;!function(e,r,o){function s(e){var t=this,n="";t.next=function(){var e=t.b,n=t.c,a=t.d,r=t.a;return e=e<<25^e>>>7^n,n=n-a|0,a=a<<24^a>>>8^r,r=r-e|0,t.b=e=e<<20^e>>>12^n,t.c=n=n-a|0,t.d=a<<16^n>>>16^r,t.a=r-e|0},t.a=0,t.b=0,t.c=-1640531527,t.d=1367130551,e===Math.floor(e)?(t.a=e/4294967296|0,t.b=0|e):n+=e;for(var a=0;a<n.length+20;a++)t.b^=0|n.charCodeAt(a),t.next()}function i(e,t){return t.a=e.a,t.b=e.b,t.c=e.c,t.d=e.d,t}function c(e,t){var n=new s(e),a=t&&t.state,r=function(){return(n.next()>>>0)/4294967296};return r.double=function(){do{var e=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},r.int32=n.next,r.quick=r,a&&("object"==typeof a&&i(a,n),r.state=function(){return i(n,{})}),r}r&&r.exports?r.exports=c:n.amdD&&n.amdO?void 0===(a=function(){return c}.call(t,n,t,r))||(r.exports=a):this.tychei=c}(0,e=n.nmd(e),n.amdD)},66:function(e,t,n){var a;!function(e,r,o){function s(e){var t=this,n="";t.x=0,t.y=0,t.z=0,t.w=0,t.next=function(){var e=t.x^t.x<<11;return t.x=t.y,t.y=t.z,t.z=t.w,t.w^=t.w>>>19^e^e>>>8},e===(0|e)?t.x=e:n+=e;for(var a=0;a<n.length+64;a++)t.x^=0|n.charCodeAt(a),t.next()}function i(e,t){return t.x=e.x,t.y=e.y,t.z=e.z,t.w=e.w,t}function c(e,t){var n=new s(e),a=t&&t.state,r=function(){return(n.next()>>>0)/4294967296};return r.double=function(){do{var e=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},r.int32=n.next,r.quick=r,a&&("object"==typeof a&&i(a,n),r.state=function(){return i(n,{})}),r}r&&r.exports?r.exports=c:n.amdD&&n.amdO?void 0===(a=function(){return c}.call(t,n,t,r))||(r.exports=a):this.xor128=c}(0,e=n.nmd(e),n.amdD)},288:function(e,t,n){var a;!function(e,r,o){function s(e){var t=this;t.next=function(){var e,n,a=t.w,r=t.X,o=t.i;return t.w=a=a+1640531527|0,n=r[o+34&127],e=r[o=o+1&127],n^=n<<13,e^=e<<17,n^=n>>>15,e^=e>>>12,n=r[o]=n^e,t.i=o,n+(a^a>>>16)|0},function(e,t){var n,a,r,o,s,i=[],c=128;for(t===(0|t)?(a=t,t=null):(t+="\0",a=0,c=Math.max(c,t.length)),r=0,o=-32;o<c;++o)t&&(a^=t.charCodeAt((o+32)%t.length)),0===o&&(s=a),a^=a<<10,a^=a>>>15,a^=a<<4,a^=a>>>13,o>=0&&(s=s+1640531527|0,r=0==(n=i[127&o]^=a+s)?r+1:0);for(r>=128&&(i[127&(t&&t.length||0)]=-1),r=127,o=512;o>0;--o)a=i[r+34&127],n=i[r=r+1&127],a^=a<<13,n^=n<<17,a^=a>>>15,n^=n>>>12,i[r]=a^n;e.w=s,e.X=i,e.i=r}(t,e)}function i(e,t){return t.i=e.i,t.w=e.w,t.X=e.X.slice(),t}function c(e,t){null==e&&(e=+new Date);var n=new s(e),a=t&&t.state,r=function(){return(n.next()>>>0)/4294967296};return r.double=function(){do{var e=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},r.int32=n.next,r.quick=r,a&&(a.X&&i(a,n),r.state=function(){return i(n,{})}),r}r&&r.exports?r.exports=c:n.amdD&&n.amdO?void 0===(a=function(){return c}.call(t,n,t,r))||(r.exports=a):this.xor4096=c}(0,e=n.nmd(e),n.amdD)},538:function(e,t,n){var a;!function(e,r,o){function s(e){var t=this;t.next=function(){var e,n,a=t.x,r=t.i;return e=a[r],n=(e^=e>>>7)^e<<24,n^=(e=a[r+1&7])^e>>>10,n^=(e=a[r+3&7])^e>>>3,n^=(e=a[r+4&7])^e<<7,e=a[r+7&7],n^=(e^=e<<13)^e<<9,a[r]=n,t.i=r+1&7,n},function(e,t){var n,a=[];if(t===(0|t))a[0]=t;else for(t=""+t,n=0;n<t.length;++n)a[7&n]=a[7&n]<<15^t.charCodeAt(n)+a[n+1&7]<<13;for(;a.length<8;)a.push(0);for(n=0;n<8&&0===a[n];++n);for(8==n?a[7]=-1:a[n],e.x=a,e.i=0,n=256;n>0;--n)e.next()}(t,e)}function i(e,t){return t.x=e.x.slice(),t.i=e.i,t}function c(e,t){null==e&&(e=+new Date);var n=new s(e),a=t&&t.state,r=function(){return(n.next()>>>0)/4294967296};return r.double=function(){do{var e=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},r.int32=n.next,r.quick=r,a&&(a.x&&i(a,n),r.state=function(){return i(n,{})}),r}r&&r.exports?r.exports=c:n.amdD&&n.amdO?void 0===(a=function(){return c}.call(t,n,t,r))||(r.exports=a):this.xorshift7=c}(0,e=n.nmd(e),n.amdD)},16:function(e,t,n){var a;!function(e,r,o){function s(e){var t=this,n="";t.next=function(){var e=t.x^t.x>>>2;return t.x=t.y,t.y=t.z,t.z=t.w,t.w=t.v,(t.d=t.d+362437|0)+(t.v=t.v^t.v<<4^e^e<<1)|0},t.x=0,t.y=0,t.z=0,t.w=0,t.v=0,e===(0|e)?t.x=e:n+=e;for(var a=0;a<n.length+64;a++)t.x^=0|n.charCodeAt(a),a==n.length&&(t.d=t.x<<10^t.x>>>4),t.next()}function i(e,t){return t.x=e.x,t.y=e.y,t.z=e.z,t.w=e.w,t.v=e.v,t.d=e.d,t}function c(e,t){var n=new s(e),a=t&&t.state,r=function(){return(n.next()>>>0)/4294967296};return r.double=function(){do{var e=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},r.int32=n.next,r.quick=r,a&&("object"==typeof a&&i(a,n),r.state=function(){return i(n,{})}),r}r&&r.exports?r.exports=c:n.amdD&&n.amdO?void 0===(a=function(){return c}.call(t,n,t,r))||(r.exports=a):this.xorwow=c}(0,e=n.nmd(e),n.amdD)},430:function(e,t,n){var a;!function(r,o,s){var i,c=256,l=s.pow(c,6),u=s.pow(2,52),d=2*u,h=c-1;function p(e,t,n){var a=[],h=b(g((t=1==t?{entropy:!0}:t||{}).entropy?[e,y(o)]:null==e?function(){try{var e;return i&&(e=i.randomBytes)?e=e(c):(e=new Uint8Array(c),(r.crypto||r.msCrypto).getRandomValues(e)),y(e)}catch(a){var t=r.navigator,n=t&&t.plugins;return[+new Date,r,n,r.screen,y(o)]}}():e,3),a),p=new f(a),x=function(){for(var e=p.g(6),t=l,n=0;e<u;)e=(e+n)*c,t*=c,n=p.g(1);for(;e>=d;)e/=2,t/=2,n>>>=1;return(e+n)/t};return x.int32=function(){return 0|p.g(4)},x.quick=function(){return p.g(4)/4294967296},x.double=x,b(y(p.S),o),(t.pass||n||function(e,t,n,a){return a&&(a.S&&m(a,p),e.state=function(){return m(p,{})}),n?(s.random=e,t):e})(x,h,"global"in t?t.global:this==s,t.state)}function f(e){var t,n=e.length,a=this,r=0,o=a.i=a.j=0,s=a.S=[];for(n||(e=[n++]);r<c;)s[r]=r++;for(r=0;r<c;r++)s[r]=s[o=h&o+e[r%n]+(t=s[r])],s[o]=t;(a.g=function(e){for(var t,n=0,r=a.i,o=a.j,s=a.S;e--;)t=s[r=h&r+1],n=n*c+s[h&(s[r]=s[o=h&o+t])+(s[o]=t)];return a.i=r,a.j=o,n})(c)}function m(e,t){return t.i=e.i,t.j=e.j,t.S=e.S.slice(),t}function g(e,t){var n,a=[],r=typeof e;if(t&&"object"==r)for(n in e)try{a.push(g(e[n],t-1))}catch(o){}return a.length?a:"string"==r?e:e+"\0"}function b(e,t){for(var n,a=e+"",r=0;r<a.length;)t[h&r]=h&(n^=19*t[h&r])+a.charCodeAt(r++);return y(t)}function y(e){return String.fromCharCode.apply(0,e)}if(b(s.random(),o),e.exports){e.exports=p;try{i=n(996)}catch(x){}}else void 0===(a=function(){return p}.call(t,n,t,e))||(e.exports=a)}("undefined"!==typeof self?self:this,[],Math)},895:(e,t,n)=>{"use strict";var a=n(43);var r="function"===typeof Object.is?Object.is:function(e,t){return e===t&&(0!==e||1/e===1/t)||e!==e&&t!==t},o=a.useSyncExternalStore,s=a.useRef,i=a.useEffect,c=a.useMemo,l=a.useDebugValue;t.useSyncExternalStoreWithSelector=function(e,t,n,a,u){var d=s(null);if(null===d.current){var h={hasValue:!1,value:null};d.current=h}else h=d.current;d=c((function(){function e(e){if(!i){if(i=!0,o=e,e=a(e),void 0!==u&&h.hasValue){var t=h.value;if(u(t,e))return s=t}return s=e}if(t=s,r(o,e))return t;var n=a(e);return void 0!==u&&u(t,n)?t:(o=e,s=n)}var o,s,i=!1,c=void 0===n?null:n;return[function(){return e(t())},null===c?void 0:function(){return e(c())}]}),[t,n,a,u]);var p=o(e,d[0],d[1]);return i((function(){h.hasValue=!0,h.value=p}),[p]),l(p),p}},237:(e,t,n)=>{"use strict";e.exports=n(895)},817:()=>{},590:()=>{},78:()=>{},905:()=>{},637:()=>{},279:()=>{},222:()=>{},996:()=>{}},t={};function n(a){var r=t[a];if(void 0!==r)return r.exports;var o=t[a]={id:a,loaded:!1,exports:{}};return e[a].call(o.exports,o,o.exports,n),o.loaded=!0,o.exports}n.m=e,n.amdD=function(){throw new Error("define cannot be used indirect")},n.amdO={},n.n=e=>{var t=e&&e.__esModule?()=>e.default:()=>e;return n.d(t,{a:t}),t},(()=>{var e,t=Object.getPrototypeOf?e=>Object.getPrototypeOf(e):e=>e.__proto__;n.t=function(a,r){if(1&r&&(a=this(a)),8&r)return a;if("object"===typeof a&&a){if(4&r&&a.__esModule)return a;if(16&r&&"function"===typeof a.then)return a}var o=Object.create(null);n.r(o);var s={};e=e||[null,t({}),t([]),t(t)];for(var i=2&r&&a;"object"==typeof i&&!~e.indexOf(i);i=t(i))Object.getOwnPropertyNames(i).forEach((e=>s[e]=()=>a[e]));return s.default=()=>a,n.d(o,s),o}})(),n.d=(e,t)=>{for(var a in t)n.o(t,a)&&!n.o(e,a)&&Object.defineProperty(e,a,{enumerable:!0,get:t[a]})},n.f={},n.e=e=>Promise.all(Object.keys(n.f).reduce(((t,a)=>(n.f[a](e,t),t)),[])),n.u=e=>"static/js/"+e+".ffa2c32b.chunk.js",n.miniCssF=e=>{},n.g=function(){if("object"===typeof globalThis)return globalThis;try{return this||new Function("return this")()}catch(e){if("object"===typeof window)return window}}(),n.o=(e,t)=>Object.prototype.hasOwnProperty.call(e,t),(()=>{var e={},t="face-recognition-app:";n.l=(a,r,o,s)=>{if(e[a])e[a].push(r);else{var i,c;if(void 0!==o)for(var l=document.getElementsByTagName("script"),u=0;u<l.length;u++){var d=l[u];if(d.getAttribute("src")==a||d.getAttribute("data-webpack")==t+o){i=d;break}}i||(c=!0,(i=document.createElement("script")).charset="utf-8",i.timeout=120,n.nc&&i.setAttribute("nonce",n.nc),i.setAttribute("data-webpack",t+o),i.src=a),e[a]=[r];var h=(t,n)=>{i.onerror=i.onload=null,clearTimeout(p);var r=e[a];if(delete e[a],i.parentNode&&i.parentNode.removeChild(i),r&&r.forEach((e=>e(n))),t)return t(n)},p=setTimeout(h.bind(null,void 0,{type:"timeout",target:i}),12e4);i.onerror=h.bind(null,i.onerror),i.onload=h.bind(null,i.onload),c&&document.head.appendChild(i)}}})(),n.r=e=>{"undefined"!==typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},n.nmd=e=>(e.paths=[],e.children||(e.children=[]),e),n.p="/face-recognition-app/",(()=>{var e={792:0};n.f.j=(t,a)=>{var r=n.o(e,t)?e[t]:void 0;if(0!==r)if(r)a.push(r[2]);else{var o=new Promise(((n,a)=>r=e[t]=[n,a]));a.push(r[2]=o);var s=n.p+n.u(t),i=new Error;n.l(s,(a=>{if(n.o(e,t)&&(0!==(r=e[t])&&(e[t]=void 0),r)){var o=a&&("load"===a.type?"missing":a.type),s=a&&a.target&&a.target.src;i.message="Loading chunk "+t+" failed.\n("+o+": "+s+")",i.name="ChunkLoadError",i.type=o,i.request=s,r[1](i)}}),"chunk-"+t,t)}};var t=(t,a)=>{var r,o,s=a[0],i=a[1],c=a[2],l=0;if(s.some((t=>0!==e[t]))){for(r in i)n.o(i,r)&&(n.m[r]=i[r]);if(c)c(n)}for(t&&t(a);l<s.length;l++)o=s[l],n.o(e,o)&&e[o]&&e[o][0](),e[o]=0},a=self.webpackChunkface_recognition_app=self.webpackChunkface_recognition_app||[];a.forEach(t.bind(null,0)),a.push=t.bind(null,a.push.bind(a))})(),(()=>{"use strict";var e={};n.r(e),n.d(e,{assertParamsValid:()=>Ih,computeFlatOffset:()=>Lh,computeOutShape:()=>Nh,getNormalizedAxes:()=>Rh,isSliceContinous:()=>Mh,maskToAxes:()=>Sh,parseSliceParams:()=>Ph,sliceInfo:()=>zh,startForAxis:()=>Oh,startIndicesWithElidedDims:()=>_h,stopForAxis:()=>Dh,stopIndicesWithElidedDims:()=>Ah,stridesForAxis:()=>Fh,stridesWithElidedDims:()=>Ch});var t={};n.r(t),n.d(t,{collectGatherOpShapeInfo:()=>nb,computeOutShape:()=>tb,segOpComputeOptimalWindowSize:()=>eb});var a={};n.r(a),n.d(a,{ERF_A1:()=>yg,ERF_A2:()=>xg,ERF_A3:()=>vg,ERF_A4:()=>wg,ERF_A5:()=>kg,ERF_P:()=>bg,PARALLELIZE_THRESHOLD:()=>ag,RowPartitionType:()=>Zm,SELU_SCALE:()=>gg,SELU_SCALEALPHA:()=>mg,applyActivation:()=>tm,assertAndGetBroadcastShape:()=>sh,assertAxesAreInnerMostDims:()=>qp,assertParamsConsistent:()=>Qm,assignToTypedArray:()=>Eg,axesAreInnerMostDims:()=>Gp,calculateShapes:()=>fg,checkEinsumDimSizes:()=>Pg,checkPadOnDimRoundingMode:()=>ap,combineLocations:()=>Hp,combineRaggedTensorToTensorShapes:()=>$m,complexWithEvenIndex:()=>Ng,complexWithOddIndex:()=>Cg,computeConv2DInfo:()=>Kh,computeConv3DInfo:()=>qh,computeDefaultPad:()=>Xh,computeDilation2DInfo:()=>Gh,computeOptimalWindowSize:()=>rg,computeOutAndReduceShapes:()=>jp,computeOutShape:()=>Jm,computePool2DInfo:()=>Hh,computePool3DInfo:()=>jh,convertConv2DDataFormat:()=>np,decodeEinsumEquation:()=>Mg,eitherStridesOrDilationsAreOne:()=>ep,expandShapeToKeepDim:()=>Kp,exponent:()=>_g,exponents:()=>Rg,fromStringArrayToUint8:()=>rb,fromUint8ToStringArray:()=>ab,getAxesPermutation:()=>Xp,getBroadcastDims:()=>rh,getComplexWithIndex:()=>Tg,getEinsumComputePath:()=>zg,getEinsumPermutation:()=>Lg,getFusedBiasGradient:()=>em,getFusedDyActivation:()=>$f,getImageCenter:()=>og,getInnerMostAxes:()=>Qp,getPermuted:()=>ig,getRaggedRank:()=>tg,getReductionAxes:()=>oh,getReshaped:()=>sg,getReshapedPermuted:()=>cg,getRowPartitionTypesHelper:()=>eg,getSliceBeginCoords:()=>lg,getSliceSize:()=>ug,getSparseFillEmptyRowsIndicesDenseShapeMismatch:()=>Ug,getSparseFillEmptyRowsNegativeIndexErrorMessage:()=>Gg,getSparseFillEmptyRowsOutOfRangeIndexErrorMessage:()=>Hg,getSparseReshapeEmptyTensorZeroOutputDimErrorMessage:()=>qg,getSparseReshapeInputOutputMismatchErrorMessage:()=>Yg,getSparseReshapeInputOutputMultipleErrorMessage:()=>Xg,getSparseReshapeMultipleNegativeOneOutputDimErrorMessage:()=>jg,getSparseReshapeNegativeOutputDimErrorMessage:()=>Kg,getSparseSegmentReductionIndicesOutOfRangeErrorMessage:()=>$g,getSparseSegmentReductionNegativeSegmentIdsErrorMessage:()=>Qg,getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage:()=>Jg,getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage:()=>Zg,getUndoAxesPermutation:()=>Yp,isIdentityPermutation:()=>Bg,log:()=>hl,mergeRealAndImagArrays:()=>Ig,prepareAndValidate:()=>dg,prepareSplitSize:()=>Vg,segment_util:()=>t,shouldFuse:()=>nm,slice_util:()=>e,splitRealAndImagArrays:()=>Sg,stridesOrDilationsArePositive:()=>tp,tupleValuesAreOne:()=>$h,upcastType:()=>fu,validateDefaultValueShape:()=>ng,validateInput:()=>pg,validateUpdateShape:()=>hg,warn:()=>dl});var r={};n.r(r),n.d(r,{addImpl:()=>YC,bincountImpl:()=>VT,bincountReduceImpl:()=>UT,bitwiseAndImpl:()=>HT,castImpl:()=>HC,ceilImpl:()=>qT,concatImpl:()=>$T,equalImpl:()=>PE,expImpl:()=>XE,expm1Impl:()=>$E,floorImpl:()=>gR,gatherNdImpl:()=>SR,gatherV2Impl:()=>CR,greaterEqualImpl:()=>AR,greaterImpl:()=>ER,lessEqualImpl:()=>HR,lessImpl:()=>VR,linSpaceImpl:()=>qR,logImpl:()=>YR,maxImpl:()=>u_,maximumImpl:()=>p_,minimumImpl:()=>I_,multiplyImpl:()=>RE,negImpl:()=>O_,notEqualImpl:()=>V_,prodImpl:()=>eA,raggedGatherImpl:()=>oA,raggedRangeImpl:()=>cA,raggedTensorToTensorImpl:()=>fA,rangeImpl:()=>gA,rsqrtImpl:()=>EA,scatterImpl:()=>AA,sigmoidImpl:()=>MC,simpleAbsImpl:()=>rT,sliceImpl:()=>PT,sparseFillEmptyRowsImpl:()=>JA,sparseReshapeImpl:()=>$A,sparseSegmentReductionImpl:()=>tF,sqrtImpl:()=>sF,staticRegexReplaceImpl:()=>pF,stridedSliceImpl:()=>yF,stringNGramsImpl:()=>wF,stringSplitImpl:()=>SF,stringToHashBucketFastImpl:()=>CF,subImpl:()=>oR,tileImpl:()=>FF,topKImpl:()=>LF,transposeImpl:()=>dT,uniqueImpl:()=>GF});var o={};n.r(o),n.d(o,{CompositeArrayBuffer:()=>cX,browserFiles:()=>XY,browserHTTPRequest:()=>aQ,concatenateArrayBuffers:()=>NX,copyModel:()=>uY,decodeWeights:()=>gX,decodeWeightsStream:()=>wX,encodeWeights:()=>mX,fromMemory:()=>iQ,fromMemorySync:()=>cQ,getLoadHandlers:()=>LX,getModelArtifactsForJSON:()=>RX,getModelArtifactsForJSONSync:()=>EX,getModelArtifactsInfoForJSON:()=>_X,getSaveHandlers:()=>MX,getWeightSpecs:()=>AX,http:()=>nQ,isHTTPScheme:()=>eQ,listModels:()=>cY,loadWeights:()=>JY,moveModel:()=>dY,registerLoadRouter:()=>DX,registerSaveRouter:()=>OX,removeModel:()=>lY,weightsLoaderFactory:()=>ZY,withSaveHandler:()=>lQ,withSaveHandlerSync:()=>uQ});var s={};n.r(s),n.d(s,{assertParamsValid:()=>bQ,computeFlatOffset:()=>_Q,computeOutShape:()=>xQ,getNormalizedAxes:()=>IQ,isSliceContinous:()=>RQ,maskToAxes:()=>yQ,parseSliceParams:()=>AQ,sliceInfo:()=>FQ,startForAxis:()=>TQ,startIndicesWithElidedDims:()=>SQ,stopForAxis:()=>EQ,stopIndicesWithElidedDims:()=>NQ,stridesForAxis:()=>CQ,stridesWithElidedDims:()=>vQ});var i={};n.r(i),n.d(i,{conv2d:()=>H0,depthwiseConv2d:()=>q0,matMul:()=>X0});var c={};n.r(c),n.d(c,{collectGatherOpShapeInfo:()=>a3,computeOutShape:()=>n3,segOpComputeOptimalWindowSize:()=>t3});var l={};n.r(l),n.d(l,{ERF_A1:()=>x2,ERF_A2:()=>v2,ERF_A3:()=>w2,ERF_A4:()=>k2,ERF_A5:()=>I2,ERF_P:()=>y2,PARALLELIZE_THRESHOLD:()=>i2,RowPartitionType:()=>n2,SELU_SCALE:()=>b2,SELU_SCALEALPHA:()=>g2,applyActivation:()=>U0,assertAndGetBroadcastShape:()=>VY,assertAxesAreInnerMostDims:()=>oZ,assertParamsConsistent:()=>e2,assignToTypedArray:()=>R2,axesAreInnerMostDims:()=>tZ,calculateShapes:()=>y0,checkEinsumDimSizes:()=>z2,checkPadOnDimRoundingMode:()=>sJ,combineLocations:()=>nZ,combineRaggedTensorToTensorShapes:()=>a2,complexWithEvenIndex:()=>C2,complexWithOddIndex:()=>T2,computeConv2DInfo:()=>YQ,computeConv3DInfo:()=>QQ,computeDefaultPad:()=>JQ,computeDilation2DInfo:()=>KQ,computeOptimalWindowSize:()=>c2,computeOutAndReduceShapes:()=>aZ,computeOutShape:()=>t2,computePool2DInfo:()=>qQ,computePool3DInfo:()=>XQ,convertConv2DDataFormat:()=>oJ,decodeEinsumEquation:()=>L2,eitherStridesOrDilationsAreOne:()=>aJ,expandShapeToKeepDim:()=>rZ,exponent:()=>A2,exponents:()=>_2,fromStringArrayToUint8:()=>o3,fromUint8ToStringArray:()=>r3,getAxesPermutation:()=>sZ,getBroadcastDims:()=>BY,getComplexWithIndex:()=>E2,getEinsumComputePath:()=>B2,getEinsumPermutation:()=>P2,getFusedBiasGradient:()=>V0,getFusedDyActivation:()=>W0,getImageCenter:()=>l2,getInnerMostAxes:()=>cZ,getPermuted:()=>d2,getRaggedRank:()=>o2,getReductionAxes:()=>WY,getReshaped:()=>u2,getReshapedPermuted:()=>h2,getRowPartitionTypesHelper:()=>r2,getSliceBeginCoords:()=>p2,getSliceSize:()=>f2,getSparseFillEmptyRowsIndicesDenseShapeMismatch:()=>G2,getSparseFillEmptyRowsNegativeIndexErrorMessage:()=>H2,getSparseFillEmptyRowsOutOfRangeIndexErrorMessage:()=>j2,getSparseReshapeEmptyTensorZeroOutputDimErrorMessage:()=>X2,getSparseReshapeInputOutputMismatchErrorMessage:()=>Q2,getSparseReshapeInputOutputMultipleErrorMessage:()=>Y2,getSparseReshapeMultipleNegativeOneOutputDimErrorMessage:()=>K2,getSparseReshapeNegativeOutputDimErrorMessage:()=>q2,getSparseSegmentReductionIndicesOutOfRangeErrorMessage:()=>e3,getSparseSegmentReductionNegativeSegmentIdsErrorMessage:()=>J2,getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage:()=>Z2,getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage:()=>$2,getUndoAxesPermutation:()=>iZ,isIdentityPermutation:()=>W2,log:()=>MK,mergeRealAndImagArrays:()=>S2,prepareAndValidate:()=>m2,prepareSplitSize:()=>U2,segment_util:()=>c,shouldFuse:()=>G0,slice_util:()=>s,splitRealAndImagArrays:()=>N2,stridesOrDilationsArePositive:()=>rJ,tupleValuesAreOne:()=>nJ,upcastType:()=>Dq,validateDefaultValueShape:()=>s2,validateInput:()=>b0,validateUpdateShape:()=>g0,warn:()=>DK});var u={};n.r(u),n.d(u,{addImpl:()=>W3,bincountImpl:()=>F4,bincountReduceImpl:()=>O4,bitwiseAndImpl:()=>M4,castImpl:()=>M3,ceilImpl:()=>B4,concatImpl:()=>j4,equalImpl:()=>R5,expImpl:()=>W5,expm1Impl:()=>j5,floorImpl:()=>c6,gatherNdImpl:()=>g6,gatherV2Impl:()=>y6,greaterEqualImpl:()=>I6,greaterImpl:()=>v6,lessEqualImpl:()=>L6,lessImpl:()=>O6,linSpaceImpl:()=>B6,logImpl:()=>V6,maxImpl:()=>n8,maximumImpl:()=>o8,minimumImpl:()=>m8,multiplyImpl:()=>w5,negImpl:()=>N8,notEqualImpl:()=>O8,prodImpl:()=>K8,raggedGatherImpl:()=>J8,raggedRangeImpl:()=>e7,raggedTensorToTensorImpl:()=>s7,rangeImpl:()=>c7,rsqrtImpl:()=>v7,scatterImpl:()=>I7,sigmoidImpl:()=>C3,simpleAbsImpl:()=>Y3,sliceImpl:()=>E4,sparseFillEmptyRowsImpl:()=>G7,sparseReshapeImpl:()=>j7,sparseSegmentReductionImpl:()=>q7,sqrtImpl:()=>Z7,staticRegexReplaceImpl:()=>o9,stridedSliceImpl:()=>u9,stringNGramsImpl:()=>p9,stringSplitImpl:()=>g9,stringToHashBucketFastImpl:()=>y9,subImpl:()=>J5,tileImpl:()=>S9,topKImpl:()=>E9,transposeImpl:()=>n4,uniqueImpl:()=>M9});var d={};n.r(d),n.d(d,{json:()=>Ple});var h={};n.r(h),n.d(h,{json:()=>zle});var p={};n.r(p),n.d(p,{json:()=>Ble});var f={};n.r(f),n.d(f,{json:()=>Wle});var m={};n.r(m),n.d(m,{json:()=>Vle});var g={};n.r(g),n.d(g,{json:()=>Ule});var b={};n.r(b),n.d(b,{json:()=>Gle});var y={};n.r(y),n.d(y,{json:()=>Hle});var x={};n.r(x),n.d(x,{json:()=>jle});var v={};n.r(v),n.d(v,{json:()=>Kle});var w={};n.r(w),n.d(w,{json:()=>qle});var k={};n.r(k),n.d(k,{json:()=>Xle});var I={};n.r(I),n.d(I,{json:()=>Yle});var S={};n.r(S),n.d(S,{json:()=>Qle});var N={};n.r(N),n.d(N,{json:()=>Jle});var C={};n.r(C),n.d(C,{json:()=>Zle});var T={};n.r(T),n.d(T,{json:()=>$le});var E={};n.r(E),n.d(E,{json:()=>eue});var R={};n.r(R),n.d(R,{json:()=>tue});var _={};n.r(_),n.d(_,{OP_SCOPE_SUFFIX:()=>nX,abs:()=>zY,acos:()=>DQ,acosh:()=>MQ,add:()=>vY,addN:()=>LQ,all:()=>PQ,any:()=>zQ,argMax:()=>BQ,argMin:()=>WQ,asin:()=>VQ,asinh:()=>UQ,atan:()=>GQ,atan2:()=>HQ,atanh:()=>jQ,avgPool:()=>cJ,avgPool3d:()=>lJ,basicLSTMCell:()=>mJ,batchNorm:()=>bJ,batchNorm2d:()=>yJ,batchNorm3d:()=>xJ,batchNorm4d:()=>vJ,batchToSpaceND:()=>gJ,bincount:()=>wJ,bitwiseAnd:()=>kJ,booleanMaskAsync:()=>R0,broadcastArgs:()=>IJ,broadcastTo:()=>SJ,buffer:()=>gY,cast:()=>bY,ceil:()=>NJ,clipByValue:()=>CJ,clone:()=>yY,complex:()=>rX,concat:()=>uJ,concat1d:()=>TJ,concat2d:()=>EJ,concat3d:()=>RJ,concat4d:()=>_J,conv1d:()=>FJ,conv2d:()=>AJ,conv2dTranspose:()=>DJ,conv3d:()=>MJ,conv3dTranspose:()=>PJ,cos:()=>zJ,cosh:()=>BJ,cosineWindow:()=>P0,cumprod:()=>WJ,cumsum:()=>VJ,denseBincount:()=>UJ,depthToSpace:()=>GJ,depthwiseConv2d:()=>HJ,diag:()=>jJ,dilation2d:()=>KJ,div:()=>kY,divNoNan:()=>YJ,dot:()=>QJ,dropout:()=>M0,einsum:()=>JJ,elu:()=>ZJ,enclosingPowerOfTwo:()=>L0,ensureShape:()=>$J,equal:()=>qJ,erf:()=>eZ,euclideanNorm:()=>fZ,exp:()=>mZ,expandDims:()=>gZ,expm1:()=>bZ,eye:()=>xZ,fft:()=>e0,fill:()=>MY,floor:()=>vZ,floorDiv:()=>wY,fused:()=>i,gather:()=>wZ,gatherND:()=>D0,greater:()=>kZ,greaterEqual:()=>IZ,ifft:()=>t0,imag:()=>SZ,image:()=>X1,inTopKAsync:()=>z0,irfft:()=>n0,isFinite:()=>NZ,isInf:()=>CZ,isNaN:()=>TZ,leakyRelu:()=>EZ,less:()=>RZ,lessEqual:()=>_Z,linalg:()=>Y1,linspace:()=>AZ,localResponseNormalization:()=>FZ,log:()=>OZ,log1p:()=>DZ,logSigmoid:()=>PZ,logSoftmax:()=>zZ,logSumExp:()=>BZ,logicalAnd:()=>WZ,logicalNot:()=>VZ,logicalOr:()=>UZ,logicalXor:()=>GZ,losses:()=>Q1,lowerBound:()=>KZ,matMul:()=>dJ,max:()=>lZ,maxPool:()=>qZ,maxPool3d:()=>XZ,maxPoolWithArgmax:()=>YZ,maximum:()=>UY,mean:()=>QZ,meshgrid:()=>$Z,min:()=>uZ,minimum:()=>e$,mirrorPad:()=>t$,mod:()=>n$,moments:()=>a$,movingAverage:()=>A0,mul:()=>IY,multiRNNCell:()=>r$,multinomial:()=>o$,neg:()=>MZ,norm:()=>pZ,notEqual:()=>s$,oneHot:()=>i$,ones:()=>ZZ,onesLike:()=>c$,op:()=>aX,outerProduct:()=>l$,pad:()=>u$,pad1d:()=>d$,pad2d:()=>h$,pad3d:()=>p$,pad4d:()=>f$,pool:()=>g$,pow:()=>LY,prelu:()=>b$,print:()=>xY,prod:()=>y$,raggedGather:()=>x$,raggedRange:()=>v$,raggedTensorToTensor:()=>w$,rand:()=>k$,randomGamma:()=>C$,randomNormal:()=>T$,randomStandardNormal:()=>E$,randomUniform:()=>R$,randomUniformInt:()=>_$,range:()=>A$,real:()=>F$,reciprocal:()=>O$,relu:()=>D$,relu6:()=>M$,reshape:()=>iJ,reverse:()=>L$,reverse1d:()=>P$,reverse2d:()=>z$,reverse3d:()=>B$,reverse4d:()=>W$,rfft:()=>r0,round:()=>V$,rsqrt:()=>U$,scalar:()=>EY,scatterND:()=>F0,searchSorted:()=>jZ,selu:()=>G$,separableConv2d:()=>H$,setdiff1dAsync:()=>j$,sigmoid:()=>hJ,sign:()=>K$,signal:()=>q1,sin:()=>q$,sinh:()=>X$,slice:()=>pJ,slice1d:()=>Y$,slice2d:()=>Q$,slice3d:()=>J$,slice4d:()=>Z$,softmax:()=>$$,softplus:()=>LZ,spaceToBatchND:()=>m$,sparse:()=>J1,sparseToDense:()=>O0,spectral:()=>K1,split:()=>a0,sqrt:()=>SY,square:()=>NY,squaredDifference:()=>o0,squeeze:()=>s0,stack:()=>i0,step:()=>c0,stridedSlice:()=>l0,string:()=>Z1,sub:()=>PY,sum:()=>dZ,tan:()=>u0,tanh:()=>fJ,tensor:()=>sX,tensor1d:()=>d0,tensor2d:()=>h0,tensor3d:()=>dQ,tensor4d:()=>p0,tensor5d:()=>f0,tensor6d:()=>m0,tensorScatterUpdate:()=>x0,tile:()=>yZ,topk:()=>v0,transpose:()=>_0,truncatedNormal:()=>w0,unique:()=>k0,unsortedSegmentSum:()=>I0,unstack:()=>S0,upperBound:()=>N0,variable:()=>C0,where:()=>XJ,whereAsync:()=>E0,zeros:()=>JZ,zerosLike:()=>CY});var A=n(43),F=n(391);function O(e,t){return t||(t=e.slice(0)),Object.freeze(Object.defineProperties(e,{raw:{value:Object.freeze(t)}}))}function D(e){return D="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e},D(e)}function M(e){var t=function(e,t){if("object"!=D(e)||!e)return e;var n=e[Symbol.toPrimitive];if(void 0!==n){var a=n.call(e,t||"default");if("object"!=D(a))return a;throw new TypeError("@@toPrimitive must return a primitive value.")}return("string"===t?String:Number)(e)}(e,"string");return"symbol"==D(t)?t:t+""}function L(e,t,n){return(t=M(t))in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function P(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function z(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?P(Object(n),!0).forEach((function(t){L(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):P(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}let B={data:""},W=e=>{if("object"==typeof window){let t=(e?e.querySelector("#_goober"):window._goober)||Object.assign(document.createElement("style"),{innerHTML:" ",id:"_goober"});return t.nonce=window.__nonce__,t.parentNode||(e||document.head).appendChild(t),t.firstChild}return e||B},V=/(?:([\u0080-\uFFFF\w-%@]+) *:? *([^{;]+?);|([^;}{]*?) *{)|(}\s*)/g,U=/\/\*[^]*?\*\/|  +/g,G=/\n+/g,H=(e,t)=>{let n="",a="",r="";for(let o in e){let s=e[o];"@"==o[0]?"i"==o[1]?n=o+" "+s+";":a+="f"==o[1]?H(s,o):o+"{"+H(s,"k"==o[1]?"":t)+"}":"object"==typeof s?a+=H(s,t?t.replace(/([^,])+/g,(e=>o.replace(/([^,]*:\S+\([^)]*\))|([^,])+/g,(t=>/&/.test(t)?t.replace(/&/g,e):e?e+" "+t:t)))):o):null!=s&&(o=/^--/.test(o)?o:o.replace(/[A-Z]/g,"-$&").toLowerCase(),r+=H.p?H.p(o,s):o+":"+s+";")}return n+(t&&r?t+"{"+r+"}":r)+a},j={},K=e=>{if("object"==typeof e){let t="";for(let n in e)t+=n+K(e[n]);return t}return e},q=(e,t,n,a,r)=>{let o=K(e),s=j[o]||(j[o]=(e=>{let t=0,n=11;for(;t<e.length;)n=101*n+e.charCodeAt(t++)>>>0;return"go"+n})(o));if(!j[s]){let t=o!==e?e:(e=>{let t,n,a=[{}];for(;t=V.exec(e.replace(U,""));)t[4]?a.shift():t[3]?(n=t[3].replace(G," ").trim(),a.unshift(a[0][n]=a[0][n]||{})):a[0][t[1]]=t[2].replace(G," ").trim();return a[0]})(e);j[s]=H(r?{["@keyframes "+s]:t}:t,n?"":"."+s)}let i=n&&j.g?j.g:null;return n&&(j.g=j[s]),((e,t,n,a)=>{a?t.data=t.data.replace(a,e):-1===t.data.indexOf(e)&&(t.data=n?e+t.data:t.data+e)})(j[s],t,a,i),s},X=(e,t,n)=>e.reduce(((e,a,r)=>{let o=t[r];if(o&&o.call){let e=o(n),t=e&&e.props&&e.props.className||/^go/.test(e)&&e;o=t?"."+t:e&&"object"==typeof e?e.props?"":H(e,""):!1===e?"":e}return e+a+(null==o?"":o)}),"");function Y(e){let t=this||{},n=e.call?e(t.p):e;return q(n.unshift?n.raw?X(n,[].slice.call(arguments,1),t.p):n.reduce(((e,n)=>Object.assign(e,n&&n.call?n(t.p):n)),{}):n,W(t.target),t.g,t.o,t.k)}Y.bind({g:1});let Q,J,Z,$=Y.bind({k:1});function ee(e,t){let n=this||{};return function(){let a=arguments;function r(o,s){let i=Object.assign({},o),c=i.className||r.className;n.p=Object.assign({theme:J&&J()},i),n.o=/ *go\d+/.test(c),i.className=Y.apply(n,a)+(c?" "+c:""),t&&(i.ref=s);let l=e;return e[0]&&(l=i.as||e,delete i.as),Z&&l[0]&&Z(i),Q(l,i)}return t?t(r):r}}var te,ne,ae,re,oe,se,ie,ce,le,ue,de,he,pe,fe,me,ge,be=(e,t)=>(e=>"function"==typeof e)(e)?e(t):e,ye=(()=>{let e=0;return()=>(++e).toString()})(),xe=(()=>{let e;return()=>{if(void 0===e&&typeof window<"u"){let t=matchMedia("(prefers-reduced-motion: reduce)");e=!t||t.matches}return e}})(),ve="default",we=(e,t)=>{let{toastLimit:n}=e.settings;switch(t.type){case 0:return z(z({},e),{},{toasts:[t.toast,...e.toasts].slice(0,n)});case 1:return z(z({},e),{},{toasts:e.toasts.map((e=>e.id===t.toast.id?z(z({},e),t.toast):e))});case 2:let{toast:a}=t;return we(e,{type:e.toasts.find((e=>e.id===a.id))?1:0,toast:a});case 3:let{toastId:r}=t;return z(z({},e),{},{toasts:e.toasts.map((e=>e.id===r||void 0===r?z(z({},e),{},{dismissed:!0,visible:!1}):e))});case 4:return void 0===t.toastId?z(z({},e),{},{toasts:[]}):z(z({},e),{},{toasts:e.toasts.filter((e=>e.id!==t.toastId))});case 5:return z(z({},e),{},{pausedAt:t.time});case 6:let o=t.time-(e.pausedAt||0);return z(z({},e),{},{pausedAt:void 0,toasts:e.toasts.map((e=>z(z({},e),{},{pauseDuration:e.pauseDuration+o})))})}},ke=[],Ie={toasts:[],pausedAt:void 0,settings:{toastLimit:20}},Se={},Ne=function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:ve;Se[t]=we(Se[t]||Ie,e),ke.forEach((e=>{let[n,a]=e;n===t&&a(Se[t])}))},Ce=e=>Object.keys(Se).forEach((t=>Ne(e,t))),Te=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:ve;return t=>{Ne(t,e)}},Ee={blank:4e3,error:4e3,success:2e3,loading:1/0,custom:4e3},Re=e=>(t,n)=>{let a=function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"blank",n=arguments.length>2?arguments[2]:void 0;return z(z({createdAt:Date.now(),visible:!0,dismissed:!1,type:t,ariaProps:{role:"status","aria-live":"polite"},message:e,pauseDuration:0},n),{},{id:(null==n?void 0:n.id)||ye()})}(t,e,n);return Te(a.toasterId||(e=>Object.keys(Se).find((t=>Se[t].toasts.some((t=>t.id===e)))))(a.id))({type:2,toast:a}),a.id},_e=(e,t)=>Re("blank")(e,t);_e.error=Re("error"),_e.success=Re("success"),_e.loading=Re("loading"),_e.custom=Re("custom"),_e.dismiss=(e,t)=>{let n={type:3,toastId:e};t?Te(t)(n):Ce(n)},_e.dismissAll=e=>_e.dismiss(void 0,e),_e.remove=(e,t)=>{let n={type:4,toastId:e};t?Te(t)(n):Ce(n)},_e.removeAll=e=>_e.remove(void 0,e),_e.promise=(e,t,n)=>{let a=_e.loading(t.loading,z(z({},n),null==n?void 0:n.loading));return"function"==typeof e&&(e=e()),e.then((e=>{let r=t.success?be(t.success,e):void 0;return r?_e.success(r,z(z({id:a},n),null==n?void 0:n.success)):_e.dismiss(a),e})).catch((e=>{let r=t.error?be(t.error,e):void 0;r?_e.error(r,z(z({id:a},n),null==n?void 0:n.error)):_e.dismiss(a)})),e};var Ae=function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"default",{toasts:n,pausedAt:a}=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:ve,[n,a]=(0,A.useState)(Se[t]||Ie),r=(0,A.useRef)(Se[t]);(0,A.useEffect)((()=>(r.current!==Se[t]&&a(Se[t]),ke.push([t,a]),()=>{let e=ke.findIndex((e=>{let[n]=e;return n===t}));e>-1&&ke.splice(e,1)})),[t]);let o=n.toasts.map((t=>{var n,a,r;return z(z(z(z({},e),e[t.type]),t),{},{removeDelay:t.removeDelay||(null==(n=e[t.type])?void 0:n.removeDelay)||(null==e?void 0:e.removeDelay),duration:t.duration||(null==(a=e[t.type])?void 0:a.duration)||(null==e?void 0:e.duration)||Ee[t.type],style:z(z(z({},e.style),null==(r=e[t.type])?void 0:r.style),t.style)})}));return z(z({},n),{},{toasts:o})}(e,t),r=(0,A.useRef)(new Map).current,o=(0,A.useCallback)((function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1e3;if(r.has(e))return;let n=setTimeout((()=>{r.delete(e),s({type:4,toastId:e})}),t);r.set(e,n)}),[]);(0,A.useEffect)((()=>{if(a)return;let e=Date.now(),r=n.map((n=>{if(n.duration===1/0)return;let a=(n.duration||0)+n.pauseDuration-(e-n.createdAt);if(!(a<0))return setTimeout((()=>_e.dismiss(n.id,t)),a);n.visible&&_e.dismiss(n.id)}));return()=>{r.forEach((e=>e&&clearTimeout(e)))}}),[n,a,t]);let s=(0,A.useCallback)(Te(t),[t]),i=(0,A.useCallback)((()=>{s({type:5,time:Date.now()})}),[s]),c=(0,A.useCallback)(((e,t)=>{s({type:1,toast:{id:e,height:t}})}),[s]),l=(0,A.useCallback)((()=>{a&&s({type:6,time:Date.now()})}),[a,s]),u=(0,A.useCallback)(((e,t)=>{let{reverseOrder:a=!1,gutter:r=8,defaultPosition:o}=t||{},s=n.filter((t=>(t.position||o)===(e.position||o)&&t.height)),i=s.findIndex((t=>t.id===e.id)),c=s.filter(((e,t)=>t<i&&e.visible)).length;return s.filter((e=>e.visible)).slice(...a?[c+1]:[0,c]).reduce(((e,t)=>e+(t.height||0)+r),0)}),[n]);return(0,A.useEffect)((()=>{n.forEach((e=>{if(e.dismissed)o(e.id,e.removeDelay);else{let t=r.get(e.id);t&&(clearTimeout(t),r.delete(e.id))}}))}),[n,o]),{toasts:n,handlers:{updateHeight:c,startPause:i,endPause:l,calculateOffset:u}}},Fe=$(te||(te=O(["\nfrom {\n  transform: scale(0) rotate(45deg);\n\topacity: 0;\n}\nto {\n transform: scale(1) rotate(45deg);\n  opacity: 1;\n}"]))),Oe=$(ne||(ne=O(["\nfrom {\n  transform: scale(0);\n  opacity: 0;\n}\nto {\n  transform: scale(1);\n  opacity: 1;\n}"]))),De=$(ae||(ae=O(["\nfrom {\n  transform: scale(0) rotate(90deg);\n\topacity: 0;\n}\nto {\n  transform: scale(1) rotate(90deg);\n\topacity: 1;\n}"]))),Me=ee("div")(re||(re=O(["\n  width: 20px;\n  opacity: 0;\n  height: 20px;\n  border-radius: 10px;\n  background: ",";\n  position: relative;\n  transform: rotate(45deg);\n\n  animation: "," 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275)\n    forwards;\n  animation-delay: 100ms;\n\n  &:after,\n  &:before {\n    content: '';\n    animation: "," 0.15s ease-out forwards;\n    animation-delay: 150ms;\n    position: absolute;\n    border-radius: 3px;\n    opacity: 0;\n    background: ",";\n    bottom: 9px;\n    left: 4px;\n    height: 2px;\n    width: 12px;\n  }\n\n  &:before {\n    animation: "," 0.15s ease-out forwards;\n    animation-delay: 180ms;\n    transform: rotate(90deg);\n  }\n"])),(e=>e.primary||"#ff4b4b"),Fe,Oe,(e=>e.secondary||"#fff"),De),Le=$(oe||(oe=O(["\n  from {\n    transform: rotate(0deg);\n  }\n  to {\n    transform: rotate(360deg);\n  }\n"]))),Pe=ee("div")(se||(se=O(["\n  width: 12px;\n  height: 12px;\n  box-sizing: border-box;\n  border: 2px solid;\n  border-radius: 100%;\n  border-color: ",";\n  border-right-color: ",";\n  animation: "," 1s linear infinite;\n"])),(e=>e.secondary||"#e0e0e0"),(e=>e.primary||"#616161"),Le),ze=$(ie||(ie=O(["\nfrom {\n  transform: scale(0) rotate(45deg);\n\topacity: 0;\n}\nto {\n  transform: scale(1) rotate(45deg);\n\topacity: 1;\n}"]))),Be=$(ce||(ce=O(["\n0% {\n\theight: 0;\n\twidth: 0;\n\topacity: 0;\n}\n40% {\n  height: 0;\n\twidth: 6px;\n\topacity: 1;\n}\n100% {\n  opacity: 1;\n  height: 10px;\n}"]))),We=ee("div")(le||(le=O(["\n  width: 20px;\n  opacity: 0;\n  height: 20px;\n  border-radius: 10px;\n  background: ",";\n  position: relative;\n  transform: rotate(45deg);\n\n  animation: "," 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275)\n    forwards;\n  animation-delay: 100ms;\n  &:after {\n    content: '';\n    box-sizing: border-box;\n    animation: "," 0.2s ease-out forwards;\n    opacity: 0;\n    animation-delay: 200ms;\n    position: absolute;\n    border-right: 2px solid;\n    border-bottom: 2px solid;\n    border-color: ",";\n    bottom: 6px;\n    left: 6px;\n    height: 10px;\n    width: 6px;\n  }\n"])),(e=>e.primary||"#61d345"),ze,Be,(e=>e.secondary||"#fff")),Ve=ee("div")(ue||(ue=O(["\n  position: absolute;\n"]))),Ue=ee("div")(de||(de=O(["\n  position: relative;\n  display: flex;\n  justify-content: center;\n  align-items: center;\n  min-width: 20px;\n  min-height: 20px;\n"]))),Ge=$(he||(he=O(["\nfrom {\n  transform: scale(0.6);\n  opacity: 0.4;\n}\nto {\n  transform: scale(1);\n  opacity: 1;\n}"]))),He=ee("div")(pe||(pe=O(["\n  position: relative;\n  transform: scale(0.6);\n  opacity: 0.4;\n  min-width: 20px;\n  animation: "," 0.3s 0.12s cubic-bezier(0.175, 0.885, 0.32, 1.275)\n    forwards;\n"])),Ge),je=e=>{let{toast:t}=e,{icon:n,type:a,iconTheme:r}=t;return void 0!==n?"string"==typeof n?A.createElement(He,null,n):n:"blank"===a?null:A.createElement(Ue,null,A.createElement(Pe,z({},r)),"loading"!==a&&A.createElement(Ve,null,"error"===a?A.createElement(Me,z({},r)):A.createElement(We,z({},r))))},Ke=e=>"\n0% {transform: translate3d(0,".concat(-200*e,"%,0) scale(.6); opacity:.5;}\n100% {transform: translate3d(0,0,0) scale(1); opacity:1;}\n"),qe=e=>"\n0% {transform: translate3d(0,0,-1px) scale(1); opacity:1;}\n100% {transform: translate3d(0,".concat(-150*e,"%,-1px) scale(.6); opacity:0;}\n"),Xe=ee("div")(fe||(fe=O(["\n  display: flex;\n  align-items: center;\n  background: #fff;\n  color: #363636;\n  line-height: 1.3;\n  will-change: transform;\n  box-shadow: 0 3px 10px rgba(0, 0, 0, 0.1), 0 3px 3px rgba(0, 0, 0, 0.05);\n  max-width: 350px;\n  pointer-events: auto;\n  padding: 8px 10px;\n  border-radius: 8px;\n"]))),Ye=ee("div")(me||(me=O(["\n  display: flex;\n  justify-content: center;\n  margin: 4px 10px;\n  color: inherit;\n  flex: 1 1 auto;\n  white-space: pre-line;\n"]))),Qe=A.memo((e=>{let{toast:t,position:n,style:a,children:r}=e,o=t.height?((e,t)=>{let n=e.includes("top")?1:-1,[a,r]=xe()?["0%{opacity:0;} 100%{opacity:1;}","0%{opacity:1;} 100%{opacity:0;}"]:[Ke(n),qe(n)];return{animation:t?"".concat($(a)," 0.35s cubic-bezier(.21,1.02,.73,1) forwards"):"".concat($(r)," 0.4s forwards cubic-bezier(.06,.71,.55,1)")}})(t.position||n||"top-center",t.visible):{opacity:0},s=A.createElement(je,{toast:t}),i=A.createElement(Ye,z({},t.ariaProps),be(t.message,t));return A.createElement(Xe,{className:t.className,style:z(z(z({},o),a),t.style)},"function"==typeof r?r({icon:s,message:i}):A.createElement(A.Fragment,null,s,i))}));!function(e,t,n,a){H.p=t,Q=e,J=n,Z=a}(A.createElement);var Je=e=>{let{id:t,className:n,style:a,onHeightUpdate:r,children:o}=e,s=A.useCallback((e=>{if(e){let n=()=>{let n=e.getBoundingClientRect().height;r(t,n)};n(),new MutationObserver(n).observe(e,{subtree:!0,childList:!0,characterData:!0})}}),[t,r]);return A.createElement("div",{ref:s,className:n,style:a},o)},Ze=Y(ge||(ge=O(["\n  z-index: 9999;\n  > * {\n    pointer-events: auto;\n  }\n"]))),$e=e=>{let{reverseOrder:t,position:n="top-center",toastOptions:a,gutter:r,children:o,toasterId:s,containerStyle:i,containerClassName:c}=e,{toasts:l,handlers:u}=Ae(a,s);return A.createElement("div",{"data-rht-toaster":s||"",style:z({position:"fixed",zIndex:9999,top:16,left:16,right:16,bottom:16,pointerEvents:"none"},i),className:c,onMouseEnter:u.startPause,onMouseLeave:u.endPause},l.map((e=>{let a=e.position||n,s=((e,t)=>{let n=e.includes("top"),a=n?{top:0}:{bottom:0},r=e.includes("center")?{justifyContent:"center"}:e.includes("right")?{justifyContent:"flex-end"}:{};return z(z({left:0,right:0,display:"flex",position:"absolute",transition:xe()?void 0:"all 230ms cubic-bezier(.21,1.02,.73,1)",transform:"translateY(".concat(t*(n?1:-1),"px)")},a),r)})(a,u.calculateOffset(e,{reverseOrder:t,gutter:r,defaultPosition:n}));return A.createElement(Je,{id:e.id,key:e.id,onHeightUpdate:u.updateHeight,className:e.visible?Ze:"",style:s},"custom"===e.type?be(e.message,e):o?o(e):A.createElement(Qe,{toast:e,position:a}))})))};function et(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}const tt=/^[a-z0-9]+(-[a-z0-9]+)*$/,nt=function(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"";const r=e.split(":");if("@"===e.slice(0,1)){if(r.length<2||r.length>3)return null;a=r.shift().slice(1)}if(r.length>3||!r.length)return null;if(r.length>1){const e=r.pop(),n=r.pop(),o={provider:r.length>0?r[0]:a,prefix:n,name:e};return t&&!at(o)?null:o}const o=r[0],s=o.split("-");if(s.length>1){const e={provider:a,prefix:s.shift(),name:s.join("-")};return t&&!at(e)?null:e}if(n&&""===a){const e={provider:a,prefix:"",name:o};return t&&!at(e,n)?null:e}return null},at=(e,t)=>!!e&&!(""!==e.provider&&!e.provider.match(tt)||!(t&&""===e.prefix||e.prefix.match(tt))||!e.name.match(tt)),rt=Object.freeze({left:0,top:0,width:16,height:16}),ot=Object.freeze({rotate:0,vFlip:!1,hFlip:!1}),st=Object.freeze(z(z({},rt),ot)),it=Object.freeze(z(z({},st),{},{body:"",hidden:!1}));function ct(e,t){const n=function(e,t){const n={};!e.hFlip!==!t.hFlip&&(n.hFlip=!0),!e.vFlip!==!t.vFlip&&(n.vFlip=!0);const a=((e.rotate||0)+(t.rotate||0))%4;return a&&(n.rotate=a),n}(e,t);for(const a in it)a in ot?a in e&&!(a in n)&&(n[a]=ot[a]):a in t?n[a]=t[a]:a in e&&(n[a]=e[a]);return n}function lt(e,t,n){const a=e.icons,r=e.aliases||Object.create(null);let o={};function s(e){o=ct(a[e]||r[e],o)}return s(t),n.forEach(s),ct(e,o)}function ut(e,t){const n=[];if("object"!==typeof e||"object"!==typeof e.icons)return n;e.not_found instanceof Array&&e.not_found.forEach((e=>{t(e,null),n.push(e)}));const a=function(e,t){const n=e.icons,a=e.aliases||Object.create(null),r=Object.create(null);return(t||Object.keys(n).concat(Object.keys(a))).forEach((function e(t){if(n[t])return r[t]=[];if(!(t in r)){r[t]=null;const n=a[t]&&a[t].parent,o=n&&e(n);o&&(r[t]=[n].concat(o))}return r[t]})),r}(e);for(const r in a){const o=a[r];o&&(t(r,lt(e,r,o)),n.push(r))}return n}const dt=z({provider:"",aliases:{},not_found:{}},rt);function ht(e,t){for(const n in t)if(n in e&&typeof e[n]!==typeof t[n])return!1;return!0}function pt(e){if("object"!==typeof e||null===e)return null;const t=e;if("string"!==typeof t.prefix||!e.icons||"object"!==typeof e.icons)return null;if(!ht(e,dt))return null;const n=t.icons;for(const r in n){const e=n[r];if(!r.match(tt)||"string"!==typeof e.body||!ht(e,it))return null}const a=t.aliases||Object.create(null);for(const r in a){const e=a[r],t=e.parent;if(!r.match(tt)||"string"!==typeof t||!n[t]&&!a[t]||!ht(e,it))return null}return t}const ft=Object.create(null);function mt(e,t){const n=ft[e]||(ft[e]=Object.create(null));return n[t]||(n[t]=function(e,t){return{provider:e,prefix:t,icons:Object.create(null),missing:new Set}}(e,t))}function gt(e,t){return pt(t)?ut(t,((t,n)=>{n?e.icons[t]=n:e.missing.add(t)})):[]}let bt=!1;function yt(e){return"boolean"===typeof e&&(bt=e),bt}function xt(e){const t="string"===typeof e?nt(e,!0,bt):e;if(t){const e=mt(t.provider,t.prefix),n=t.name;return e.icons[n]||(e.missing.has(n)?null:void 0)}}function vt(e,t){const n=nt(e,!0,bt);if(!n)return!1;return function(e,t,n){try{if("string"===typeof n.body)return e.icons[t]=z({},n),!0}catch(a){}return!1}(mt(n.provider,n.prefix),n.name,t)}const wt=Object.freeze({width:null,height:null}),kt=Object.freeze(z(z({},wt),ot)),It=/(-?[0-9.]*[0-9]+[0-9.]*)/g,St=/^-?[0-9.]*[0-9]+[0-9.]*$/g;function Nt(e,t,n){if(1===t)return e;if(n=n||100,"number"===typeof e)return Math.ceil(e*t*n)/n;if("string"!==typeof e)return e;const a=e.split(It);if(null===a||!a.length)return e;const r=[];let o=a.shift(),s=St.test(o);for(;;){if(s){const e=parseFloat(o);isNaN(e)?r.push(o):r.push(Math.ceil(e*t*n)/n)}else r.push(o);if(o=a.shift(),void 0===o)return r.join("");s=!s}}const Ct=/\sid="(\S+)"/g,Tt="IconifyId"+Date.now().toString(16)+(16777216*Math.random()|0).toString(16);let Et=0;function Rt(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:Tt;const n=[];let a;for(;a=Ct.exec(e);)n.push(a[1]);if(!n.length)return e;const r="suffix"+(16777216*Math.random()|Date.now()).toString(16);return n.forEach((n=>{const a="function"===typeof t?t(n):t+(Et++).toString(),o=n.replace(/[.*+?^${}()|[\]\\]/g,"\\$&");e=e.replace(new RegExp('([#;"])('+o+')([")]|\\.[a-z])',"g"),"$1"+a+r+"$3")})),e=e.replace(new RegExp(r,"g"),"")}const _t=Object.create(null);function At(e,t){_t[e]=t}function Ft(e){return _t[e]||_t[""]}function Ot(e){let t;if("string"===typeof e.resources)t=[e.resources];else if(t=e.resources,!(t instanceof Array)||!t.length)return null;return{resources:t,path:e.path||"/",maxURL:e.maxURL||500,rotate:e.rotate||750,timeout:e.timeout||5e3,random:!0===e.random,index:e.index||0,dataAfterTimeout:!1!==e.dataAfterTimeout}}const Dt=Object.create(null),Mt=["https://api.simplesvg.com","https://api.unisvg.com"],Lt=[];for(;Mt.length>0;)1===Mt.length||Math.random()>.5?Lt.push(Mt.shift()):Lt.push(Mt.pop());function Pt(e,t){const n=Ot(t);return null!==n&&(Dt[e]=n,!0)}function zt(e){return Dt[e]}Dt[""]=Ot({resources:["https://api.iconify.design"].concat(Lt)});let Bt=(()=>{let e;try{if(e=fetch,"function"===typeof e)return e}catch(t){}})();const Wt={prepare:(e,t,n)=>{const a=[],r=function(e,t){const n=zt(e);if(!n)return 0;let a;if(n.maxURL){let e=0;n.resources.forEach((t=>{const n=t;e=Math.max(e,n.length)}));const r=t+".json?icons=";a=n.maxURL-e-n.path.length-r.length}else a=0;return a}(e,t),o="icons";let s={type:o,provider:e,prefix:t,icons:[]},i=0;return n.forEach(((n,c)=>{i+=n.length+1,i>=r&&c>0&&(a.push(s),s={type:o,provider:e,prefix:t,icons:[]},i=n.length),s.icons.push(n)})),a.push(s),a},send:(e,t,n)=>{if(!Bt)return void n("abort",424);let a=function(e){if("string"===typeof e){const t=zt(e);if(t)return t.path}return"/"}(t.provider);switch(t.type){case"icons":{const e=t.prefix,n=t.icons.join(",");a+=e+".json?"+new URLSearchParams({icons:n}).toString();break}case"custom":{const e=t.uri;a+="/"===e.slice(0,1)?e.slice(1):e;break}default:return void n("abort",400)}let r=503;Bt(e+a).then((e=>{const t=e.status;if(200===t)return r=501,e.json();setTimeout((()=>{n(function(e){return 404===e}(t)?"abort":"next",t)}))})).then((e=>{"object"===typeof e&&null!==e?setTimeout((()=>{n("success",e)})):setTimeout((()=>{404===e?n("abort",e):n("next",r)}))})).catch((()=>{n("next",r)}))}};function Vt(e,t){e.forEach((e=>{const n=e.loaderCallbacks;n&&(e.loaderCallbacks=n.filter((e=>e.id!==t)))}))}let Ut=0;var Gt={resources:[],index:0,timeout:2e3,rotate:750,random:!1,dataAfterTimeout:!1};function Ht(e,t,n,a){const r=e.resources.length,o=e.random?Math.floor(Math.random()*r):e.index;let s;if(e.random){let t=e.resources.slice(0);for(s=[];t.length>1;){const e=Math.floor(Math.random()*t.length);s.push(t[e]),t=t.slice(0,e).concat(t.slice(e+1))}s=s.concat(t)}else s=e.resources.slice(o).concat(e.resources.slice(0,o));const i=Date.now();let c,l="pending",u=0,d=null,h=[],p=[];function f(){d&&(clearTimeout(d),d=null)}function m(){"pending"===l&&(l="aborted"),f(),h.forEach((e=>{"pending"===e.status&&(e.status="aborted")})),h=[]}function g(e,t){t&&(p=[]),"function"===typeof e&&p.push(e)}function b(){l="failed",p.forEach((e=>{e(void 0,c)}))}function y(){h.forEach((e=>{"pending"===e.status&&(e.status="aborted")})),h=[]}function x(){if("pending"!==l)return;f();const a=s.shift();if(void 0===a)return h.length?void(d=setTimeout((()=>{f(),"pending"===l&&(y(),b())}),e.timeout)):void b();const r={status:"pending",resource:a,callback:(t,n)=>{!function(t,n,a){const r="success"!==n;switch(h=h.filter((e=>e!==t)),l){case"pending":break;case"failed":if(r||!e.dataAfterTimeout)return;break;default:return}if("abort"===n)return c=a,void b();if(r)return c=a,void(h.length||(s.length?x():b()));if(f(),y(),!e.random){const n=e.resources.indexOf(t.resource);-1!==n&&n!==e.index&&(e.index=n)}l="completed",p.forEach((e=>{e(a)}))}(r,t,n)}};h.push(r),u++,d=setTimeout(x,e.rotate),n(a,t,r.callback)}return"function"===typeof a&&p.push(a),setTimeout(x),function(){return{startTime:i,payload:t,status:l,queriesSent:u,queriesPending:h.length,subscribe:g,abort:m}}}function jt(e){const t=z(z({},Gt),e);let n=[];function a(){n=n.filter((e=>"pending"===e().status))}return{query:function(e,r,o){const s=Ht(t,e,r,((e,t)=>{a(),o&&o(e,t)}));return n.push(s),s},find:function(e){return n.find((t=>e(t)))||null},setIndex:e=>{t.index=e},getIndex:()=>t.index,cleanup:a}}function Kt(){}const qt=Object.create(null);function Xt(e,t,n){let a,r;if("string"===typeof e){const t=Ft(e);if(!t)return n(void 0,424),Kt;r=t.send;const o=function(e){if(!qt[e]){const t=zt(e);if(!t)return;const n={config:t,redundancy:jt(t)};qt[e]=n}return qt[e]}(e);o&&(a=o.redundancy)}else{const t=Ot(e);if(t){a=jt(t);const n=Ft(e.resources?e.resources[0]:"");n&&(r=n.send)}}return a&&r?a.query(t,r,n)().abort:(n(void 0,424),Kt)}const Yt="iconify2",Qt="iconify",Jt=Qt+"-count",Zt=Qt+"-version",$t=36e5,en=168;function tn(e,t){try{return e.getItem(t)}catch(n){}}function nn(e,t,n){try{return e.setItem(t,n),!0}catch(a){}}function an(e,t){try{e.removeItem(t)}catch(n){}}function rn(e,t){return nn(e,Jt,t.toString())}function on(e){return parseInt(tn(e,Jt))||0}const sn={local:!0,session:!0},cn={local:new Set,session:new Set};let ln=!1;let un="undefined"===typeof window?{}:window;function dn(e){const t=e+"Storage";try{if(un&&un[t]&&"number"===typeof un[t].length)return un[t]}catch(n){}sn[e]=!1}function hn(e,t){const n=dn(e);if(!n)return;const a=tn(n,Zt);if(a!==Yt){if(a){const e=on(n);for(let t=0;t<e;t++)an(n,Qt+t.toString())}return nn(n,Zt,Yt),void rn(n,0)}const r=Math.floor(Date.now()/$t)-en,o=e=>{const a=Qt+e.toString(),o=tn(n,a);if("string"===typeof o){try{const n=JSON.parse(o);if("object"===typeof n&&"number"===typeof n.cached&&n.cached>r&&"string"===typeof n.provider&&"object"===typeof n.data&&"string"===typeof n.data.prefix&&t(n,e))return!0}catch(s){}an(n,a)}};let s=on(n);for(let i=s-1;i>=0;i--)o(i)||(i===s-1?(s--,rn(n,s)):cn[e].add(i))}function pn(){if(!ln){ln=!0;for(const e in sn)hn(e,(e=>{const t=e.data,n=mt(e.provider,t.prefix);if(!gt(n,t).length)return!1;const a=t.lastModified||-1;return n.lastModifiedCached=n.lastModifiedCached?Math.min(n.lastModifiedCached,a):a,!0}))}}function fn(e,t){function n(n){let a;if(!sn[n]||!(a=dn(n)))return;const r=cn[n];let o;if(r.size)r.delete(o=Array.from(r).shift());else if(o=on(a),!rn(a,o+1))return;const s={cached:Math.floor(Date.now()/$t),provider:e.provider,data:t};return nn(a,Qt+o.toString(),JSON.stringify(s))}ln||pn(),t.lastModified&&!function(e,t){const n=e.lastModifiedCached;if(n&&n>=t)return n===t;if(e.lastModifiedCached=t,n)for(const a in sn)hn(a,(n=>{const a=n.data;return n.provider!==e.provider||a.prefix!==e.prefix||a.lastModified===t}));return!0}(e,t.lastModified)||Object.keys(t.icons).length&&(t.not_found&&delete(t=Object.assign({},t)).not_found,n("local")||n("session"))}function mn(){}function gn(e){e.iconsLoaderFlag||(e.iconsLoaderFlag=!0,setTimeout((()=>{e.iconsLoaderFlag=!1,function(e){e.pendingCallbacksFlag||(e.pendingCallbacksFlag=!0,setTimeout((()=>{e.pendingCallbacksFlag=!1;const t=e.loaderCallbacks?e.loaderCallbacks.slice(0):[];if(!t.length)return;let n=!1;const a=e.provider,r=e.prefix;t.forEach((t=>{const o=t.icons,s=o.pending.length;o.pending=o.pending.filter((t=>{if(t.prefix!==r)return!0;const s=t.name;if(e.icons[s])o.loaded.push({provider:a,prefix:r,name:s});else{if(!e.missing.has(s))return n=!0,!0;o.missing.push({provider:a,prefix:r,name:s})}return!1})),o.pending.length!==s&&(n||Vt([e],t.id),t.callback(o.loaded.slice(0),o.missing.slice(0),o.pending.slice(0),t.abort))}))})))}(e)})))}const bn=(e,t)=>{const n=function(e){let t=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const a=[];return e.forEach((e=>{const r="string"===typeof e?nt(e,t,n):e;r&&a.push(r)})),a}(e,!0,yt()),a=function(e){const t={loaded:[],missing:[],pending:[]},n=Object.create(null);e.sort(((e,t)=>e.provider!==t.provider?e.provider.localeCompare(t.provider):e.prefix!==t.prefix?e.prefix.localeCompare(t.prefix):e.name.localeCompare(t.name)));let a={provider:"",prefix:"",name:""};return e.forEach((e=>{if(a.name===e.name&&a.prefix===e.prefix&&a.provider===e.provider)return;a=e;const r=e.provider,o=e.prefix,s=e.name,i=n[r]||(n[r]=Object.create(null)),c=i[o]||(i[o]=mt(r,o));let l;l=s in c.icons?t.loaded:""===o||c.missing.has(s)?t.missing:t.pending;const u={provider:r,prefix:o,name:s};l.push(u)})),t}(n);if(!a.pending.length){let e=!0;return t&&setTimeout((()=>{e&&t(a.loaded,a.missing,a.pending,mn)})),()=>{e=!1}}const r=Object.create(null),o=[];let s,i;return a.pending.forEach((e=>{const{provider:t,prefix:n}=e;if(n===i&&t===s)return;s=t,i=n,o.push(mt(t,n));const a=r[t]||(r[t]=Object.create(null));a[n]||(a[n]=[])})),a.pending.forEach((e=>{const{provider:t,prefix:n,name:a}=e,o=mt(t,n),s=o.pendingIcons||(o.pendingIcons=new Set);s.has(a)||(s.add(a),r[t][n].push(a))})),o.forEach((e=>{const{provider:t,prefix:n}=e;r[t][n].length&&function(e,t){e.iconsToLoad?e.iconsToLoad=e.iconsToLoad.concat(t).sort():e.iconsToLoad=t,e.iconsQueueFlag||(e.iconsQueueFlag=!0,setTimeout((()=>{e.iconsQueueFlag=!1;const{provider:t,prefix:n}=e,a=e.iconsToLoad;let r;delete e.iconsToLoad,a&&(r=Ft(t))&&r.prepare(t,n,a).forEach((n=>{Xt(t,n,(t=>{if("object"!==typeof t)n.icons.forEach((t=>{e.missing.add(t)}));else try{const n=gt(e,t);if(!n.length)return;const a=e.pendingIcons;a&&n.forEach((e=>{a.delete(e)})),fn(e,t)}catch(a){console.error(a)}gn(e)}))}))})))}(e,r[t][n])})),t?function(e,t,n){const a=Ut++,r=Vt.bind(null,n,a);if(!t.pending.length)return r;const o={id:a,icons:t,callback:e,abort:r};return n.forEach((e=>{(e.loaderCallbacks||(e.loaderCallbacks=[])).push(o)})),r}(t,a,o):mn};const yn=/[\s,]+/;function xn(e,t){t.split(yn).forEach((t=>{switch(t.trim()){case"horizontal":e.hFlip=!0;break;case"vertical":e.vFlip=!0}}))}function vn(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const n=e.replace(/^-?[0-9.]*/,"");function a(e){for(;e<0;)e+=4;return e%4}if(""===n){const t=parseInt(e);return isNaN(t)?0:a(t)}if(n!==e){let t=0;switch(n){case"%":t=25;break;case"deg":t=90}if(t){let r=parseFloat(e.slice(0,e.length-n.length));return isNaN(r)?0:(r/=t,r%1===0?a(r):0)}}return t}let wn;function kn(e){return void 0===wn&&function(){try{wn=window.trustedTypes.createPolicy("iconify",{createHTML:e=>e})}catch(e){wn=null}}(),wn?wn.createHTML(e):e}const In=z(z({},kt),{},{inline:!1}),Sn={xmlns:"http://www.w3.org/2000/svg",xmlnsXlink:"http://www.w3.org/1999/xlink","aria-hidden":!0,role:"img"},Nn={display:"inline-block"},Cn={backgroundColor:"currentColor"},Tn={backgroundColor:"transparent"},En={Image:"var(--svg)",Repeat:"no-repeat",Size:"100% 100%"},Rn={WebkitMask:Cn,mask:Cn,background:Tn};for(const n in Rn){const e=Rn[n];for(const t in En)e[n+t]=En[t]}const _n=z(z({},In),{},{inline:!0});function An(e){return e+(e.match(/^[-0-9.]+$/)?"px":"")}const Fn=(e,t,n,a)=>{const r=n?_n:In,o=function(e,t){const n=z({},e);for(const a in t){const e=t[a],r=typeof e;a in wt?(null===e||e&&("string"===r||"number"===r))&&(n[a]=e):r===typeof n[a]&&(n[a]="rotate"===a?e%4:e)}return n}(r,t),s=t.mode||"svg",i={},c=t.style||{},l=z(z({},"svg"===s?Sn:{}),{},{ref:a});for(let y in t){const e=t[y];if(void 0!==e)switch(y){case"icon":case"style":case"children":case"onLoad":case"mode":case"_ref":case"_inline":break;case"inline":case"hFlip":case"vFlip":o[y]=!0===e||"true"===e||1===e;break;case"flip":"string"===typeof e&&xn(o,e);break;case"color":i.color=e;break;case"rotate":"string"===typeof e?o[y]=vn(e):"number"===typeof e&&(o[y]=e);break;case"ariaHidden":case"aria-hidden":!0!==e&&"true"!==e&&delete l["aria-hidden"];break;default:void 0===r[y]&&(l[y]=e)}}const u=function(e,t){const n=z(z({},st),e),a=z(z({},kt),t),r={left:n.left,top:n.top,width:n.width,height:n.height};let o=n.body;[n,a].forEach((e=>{const t=[],n=e.hFlip,a=e.vFlip;let s,i=e.rotate;switch(n?a?i+=2:(t.push("translate("+(r.width+r.left).toString()+" "+(0-r.top).toString()+")"),t.push("scale(-1 1)"),r.top=r.left=0):a&&(t.push("translate("+(0-r.left).toString()+" "+(r.height+r.top).toString()+")"),t.push("scale(1 -1)"),r.top=r.left=0),i<0&&(i-=4*Math.floor(i/4)),i%=4,i){case 1:s=r.height/2+r.top,t.unshift("rotate(90 "+s.toString()+" "+s.toString()+")");break;case 2:t.unshift("rotate(180 "+(r.width/2+r.left).toString()+" "+(r.height/2+r.top).toString()+")");break;case 3:s=r.width/2+r.left,t.unshift("rotate(-90 "+s.toString()+" "+s.toString()+")")}i%2===1&&(r.left!==r.top&&(s=r.left,r.left=r.top,r.top=s),r.width!==r.height&&(s=r.width,r.width=r.height,r.height=s)),t.length&&(o='<g transform="'+t.join(" ")+'">'+o+"</g>")}));const s=a.width,i=a.height,c=r.width,l=r.height;let u,d;null===s?(d=null===i?"1em":"auto"===i?l:i,u=Nt(d,c/l)):(u="auto"===s?c:s,d=null===i?Nt(u,l/c):"auto"===i?l:i);const h={},p=(e,t)=>{(e=>"unset"===e||"undefined"===e||"none"===e)(t)||(h[e]=t.toString())};return p("width",u),p("height",d),h.viewBox=r.left.toString()+" "+r.top.toString()+" "+c.toString()+" "+l.toString(),{attributes:h,body:o}}(e,o),d=u.attributes;if(o.inline&&(i.verticalAlign="-0.125em"),"svg"===s){l.style=z(z({},i),c),Object.assign(l,d);let e=0,n=t.id;return"string"===typeof n&&(n=n.replace(/-/g,"_")),l.dangerouslySetInnerHTML={__html:kn(Rt(u.body,n?()=>n+"ID"+e++:"iconifyReact"))},A.createElement("svg",l)}const{body:h,width:p,height:f}=e,m="mask"===s||"bg"!==s&&-1!==h.indexOf("currentColor"),g=function(e,t){let n=-1===e.indexOf("xlink:")?"":' xmlns:xlink="http://www.w3.org/1999/xlink"';for(const a in t)n+=" "+a+'="'+t[a]+'"';return'<svg xmlns="http://www.w3.org/2000/svg"'+n+">"+e+"</svg>"}(h,z(z({},d),{},{width:p+"",height:f+""}));var b;return l.style=z(z(z(z({},i),{},{"--svg":(b=g,'url("'+function(e){return"data:image/svg+xml,"+function(e){return e.replace(/"/g,"'").replace(/%/g,"%25").replace(/#/g,"%23").replace(/</g,"%3C").replace(/>/g,"%3E").replace(/\s+/g," ")}(e)}(b)+'")'),width:An(d.width),height:An(d.height)},Nn),m?Cn:Tn),c),A.createElement("span",l)};if(yt(!0),At("",Wt),"undefined"!==typeof document&&"undefined"!==typeof window){pn();const e=window;if(void 0!==e.IconifyPreload){const t=e.IconifyPreload,n="Invalid IconifyPreload syntax.";"object"===typeof t&&null!==t&&(t instanceof Array?t:[t]).forEach((e=>{try{("object"!==typeof e||null===e||e instanceof Array||"object"!==typeof e.icons||"string"!==typeof e.prefix||!function(e,t){if("object"!==typeof e)return!1;if("string"!==typeof t&&(t=e.provider||""),bt&&!t&&!e.prefix){let t=!1;return pt(e)&&(e.prefix="",ut(e,((e,n)=>{n&&vt(e,n)&&(t=!0)}))),t}const n=e.prefix;return!!at({provider:t,prefix:n,name:"a"})&&!!gt(mt(t,n),e)}(e))&&console.error(n)}catch(B){console.error(n)}}))}if(void 0!==e.IconifyProviders){const t=e.IconifyProviders;if("object"===typeof t&&null!==t)for(let e in t){const n="IconifyProviders["+e+"] is invalid.";try{const a=t[e];if("object"!==typeof a||!a||void 0===a.resources)continue;Pt(e,a)||console.error(n)}catch(B){console.error(n)}}}}class On extends A.Component{constructor(e){super(e),this.state={icon:null}}_abortLoading(){this._loading&&(this._loading.abort(),this._loading=null)}_setData(e){this.state.icon!==e&&this.setState({icon:e})}_checkIcon(e){const t=this.state,n=this.props.icon;if("object"===typeof n&&null!==n&&"string"===typeof n.body)return this._icon="",this._abortLoading(),void((e||null===t.icon)&&this._setData({data:n}));let a;if("string"!==typeof n||null===(a=nt(n,!1,!0)))return this._abortLoading(),void this._setData(null);const r=xt(a);if(r){if(this._icon!==n||null===t.icon){this._abortLoading(),this._icon=n;const e=["iconify"];""!==a.prefix&&e.push("iconify--"+a.prefix),""!==a.provider&&e.push("iconify--"+a.provider),this._setData({data:r,classes:e}),this.props.onLoad&&this.props.onLoad(n)}}else this._loading&&this._loading.name===n||(this._abortLoading(),this._icon="",this._setData(null),null!==r&&(this._loading={name:n,abort:bn([a],this._checkIcon.bind(this,!1))}))}componentDidMount(){this._checkIcon(!1)}componentDidUpdate(e){e.icon!==this.props.icon&&this._checkIcon(!0)}componentWillUnmount(){this._abortLoading()}render(){const e=this.props,t=this.state.icon;if(null===t)return e.children?e.children:A.createElement("span",{});let n=e;return t.classes&&(n=z(z({},e),{},{className:("string"===typeof e.className?e.className+" ":"")+t.classes.join(" ")})),Fn(z(z({},st),t.data),n,e._inline,e._ref)}}const Dn=A.forwardRef((function(e,t){const n=z(z({},e),{},{_ref:t,_inline:!1});return A.createElement(On,n)}));A.forwardRef((function(e,t){const n=z(z({},e),{},{_ref:t,_inline:!0});return A.createElement(On,n)}));var Mn=n(579);const Ln=["className","size","icon","iconClasses"],Pn=e=>{let{className:t,size:n,icon:a,iconClasses:r}=e,o=et(e,Ln);return(0,Mn.jsx)("span",{className:"\n\t\t\t\tinline-block align-middle\n\t\t\t\t".concat(null!==t&&void 0!==t?t:"","\n\t\t\t\t").concat(null!==n&&void 0!==n?n:"","\n\t\t\t"),children:(0,Mn.jsx)(Dn,z({icon:a,className:"\n\t\t\t\t\t".concat(null!==r&&void 0!==r?r:"","\n\t\t\t\t\t").concat(null!==n&&void 0!==n?n:"","\n\t\t\t\t")},o))})},zn=e=>{let{title:t,handleThemeChange:n,theme:a}=e;const[r,o]=(0,A.useState)(!1),s="bg-white text-slate-900 shadow-sm dark:bg-slate-900 dark:text-slate-100",i="transform top-0 left-0 w-64 ".concat(s," h-full fixed overflow-auto ease-in-out transition-all duration-300 z-30 ").concat(r?"translate-x-0":"-translate-x-full"),c="text-slate-900 dark:text-slate-100";return(0,Mn.jsx)(Mn.Fragment,{children:(0,Mn.jsxs)("div",{className:"".concat(s),children:[(0,Mn.jsxs)("nav",{className:"".concat(s," px-4 py-3 flex justify-between items-center"),children:[(0,Mn.jsx)("div",{className:"text-base font-semibold sm:text-lg",children:t}),(0,Mn.jsx)("button",{className:"md:hidden ".concat(c),onClick:()=>o(!r),"aria-label":"Toggle navigation menu",children:(0,Mn.jsx)("svg",{className:"w-6 h-6",fill:"none",strokeLinecap:"round",strokeLinejoin:"round",strokeWidth:"2",viewBox:"0 0 24 24",stroke:"currentColor",children:(0,Mn.jsx)("path",{d:"M4 6h16M4 12h16M4 18h7"})})}),(0,Mn.jsxs)("div",{className:"hidden items-center gap-3 md:flex",children:[(0,Mn.jsx)("a",{href:"#",className:"rounded px-2 py-1 text-sm font-medium text-slate-600 transition hover:text-slate-900 dark:text-slate-300 dark:hover:text-white",children:"In progress"}),(0,Mn.jsx)("button",{type:"button",className:"inline-flex items-center justify-center rounded-md p-2 transition hover:bg-slate-100 dark:hover:bg-slate-800",onClick:n,"aria-label":"Toggle color theme",children:"light"!==a?(0,Mn.jsx)(Pn,{icon:"heroicons:sun",size:"h-6 w-6",className:c}):(0,Mn.jsx)(Pn,{icon:"heroicons:moon",size:"h-6 w-6",className:c})})]})]}),(0,Mn.jsxs)("div",{className:i,children:[(0,Mn.jsx)("button",{className:"p-2 text-slate-600 hover:text-slate-900 dark:text-slate-300 dark:hover:text-white",onClick:()=>o(!1),"aria-label":"Close navigation menu",children:"\u2715"}),(0,Mn.jsx)("a",{href:"#",className:"block p-2 text-sm font-medium text-slate-700 dark:text-slate-200",children:"Home"}),(0,Mn.jsx)("a",{href:"#",className:"block p-2 text-sm font-medium text-slate-700 dark:text-slate-200",children:"About"}),(0,Mn.jsx)("a",{href:"#",className:"block p-2 text-sm font-medium text-slate-700 dark:text-slate-200",children:"Services"}),(0,Mn.jsx)("a",{href:"#",className:"block p-2 text-sm font-medium text-slate-700 dark:text-slate-200",children:"Contact"}),(0,Mn.jsx)("button",{type:"button",className:"mt-4 flex items-center gap-2 rounded-md px-2 py-2 text-sm font-medium text-slate-700 transition hover:bg-slate-100 dark:text-slate-200 dark:hover:bg-slate-800",onClick:n,children:"light"!==a?(0,Mn.jsxs)(Mn.Fragment,{children:[(0,Mn.jsx)(Pn,{icon:"heroicons:sun",size:"h-5 w-5",className:c}),"Switch to light mode"]}):(0,Mn.jsxs)(Mn.Fragment,{children:[(0,Mn.jsx)(Pn,{icon:"heroicons:moon",size:"h-5 w-5",className:c}),"Switch to dark mode"]})})]})]})})};var Bn=Symbol.for("immer-nothing"),Wn=Symbol.for("immer-draftable"),Vn=Symbol.for("immer-state");function Un(e){throw new Error("[Immer] minified error nr: ".concat(e,". Full error at: https://bit.ly/3cXEKWf"))}var Gn=Object.getPrototypeOf;function Hn(e){return!!e&&!!e[Vn]}function jn(e){var t;return!!e&&(qn(e)||Array.isArray(e)||!!e[Wn]||!(null===(t=e.constructor)||void 0===t||!t[Wn])||Zn(e)||$n(e))}var Kn=Object.prototype.constructor.toString();function qn(e){if(!e||"object"!==typeof e)return!1;const t=Gn(e);if(null===t)return!0;const n=Object.hasOwnProperty.call(t,"constructor")&&t.constructor;return n===Object||"function"==typeof n&&Function.toString.call(n)===Kn}function Xn(e,t){0===Yn(e)?Reflect.ownKeys(e).forEach((n=>{t(n,e[n],e)})):e.forEach(((n,a)=>t(a,n,e)))}function Yn(e){const t=e[Vn];return t?t.type_:Array.isArray(e)?1:Zn(e)?2:$n(e)?3:0}function Qn(e,t){return 2===Yn(e)?e.has(t):Object.prototype.hasOwnProperty.call(e,t)}function Jn(e,t,n){const a=Yn(e);2===a?e.set(t,n):3===a?e.add(n):e[t]=n}function Zn(e){return e instanceof Map}function $n(e){return e instanceof Set}function ea(e){return e.copy_||e.base_}function ta(e,t){if(Zn(e))return new Map(e);if($n(e))return new Set(e);if(Array.isArray(e))return Array.prototype.slice.call(e);const n=qn(e);if(!0===t||"class_only"===t&&!n){const t=Object.getOwnPropertyDescriptors(e);delete t[Vn];let n=Reflect.ownKeys(t);for(let a=0;a<n.length;a++){const r=n[a],o=t[r];!1===o.writable&&(o.writable=!0,o.configurable=!0),(o.get||o.set)&&(t[r]={configurable:!0,writable:!0,enumerable:o.enumerable,value:e[r]})}return Object.create(Gn(e),t)}{const t=Gn(e);if(null!==t&&n)return z({},e);const a=Object.create(t);return Object.assign(a,e)}}function na(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];return ra(e)||Hn(e)||!jn(e)||(Yn(e)>1&&(e.set=e.add=e.clear=e.delete=aa),Object.freeze(e),t&&Object.entries(e).forEach((e=>{let[t,n]=e;return na(n,!0)}))),e}function aa(){Un(2)}function ra(e){return Object.isFrozen(e)}var oa,sa={};function ia(e){const t=sa[e];return t||Un(0),t}function ca(){return oa}function la(e,t){t&&(ia("Patches"),e.patches_=[],e.inversePatches_=[],e.patchListener_=t)}function ua(e){da(e),e.drafts_.forEach(pa),e.drafts_=null}function da(e){e===oa&&(oa=e.parent_)}function ha(e){return oa={drafts_:[],parent_:oa,immer_:e,canAutoFreeze_:!0,unfinalizedDrafts_:0}}function pa(e){const t=e[Vn];0===t.type_||1===t.type_?t.revoke_():t.revoked_=!0}function fa(e,t){t.unfinalizedDrafts_=t.drafts_.length;const n=t.drafts_[0];return void 0!==e&&e!==n?(n[Vn].modified_&&(ua(t),Un(4)),jn(e)&&(e=ma(t,e),t.parent_||ba(t,e)),t.patches_&&ia("Patches").generateReplacementPatches_(n[Vn].base_,e,t.patches_,t.inversePatches_)):e=ma(t,n,[]),ua(t),t.patches_&&t.patchListener_(t.patches_,t.inversePatches_),e!==Bn?e:void 0}function ma(e,t,n){if(ra(t))return t;const a=t[Vn];if(!a)return Xn(t,((r,o)=>ga(e,a,t,r,o,n))),t;if(a.scope_!==e)return t;if(!a.modified_)return ba(e,a.base_,!0),a.base_;if(!a.finalized_){a.finalized_=!0,a.scope_.unfinalizedDrafts_--;const t=a.copy_;let r=t,o=!1;3===a.type_&&(r=new Set(t),t.clear(),o=!0),Xn(r,((r,s)=>ga(e,a,t,r,s,n,o))),ba(e,t,!1),n&&e.patches_&&ia("Patches").generatePatches_(a,n,e.patches_,e.inversePatches_)}return a.copy_}function ga(e,t,n,a,r,o,s){if(Hn(r)){const s=ma(e,r,o&&t&&3!==t.type_&&!Qn(t.assigned_,a)?o.concat(a):void 0);if(Jn(n,a,s),!Hn(s))return;e.canAutoFreeze_=!1}else s&&n.add(r);if(jn(r)&&!ra(r)){if(!e.immer_.autoFreeze_&&e.unfinalizedDrafts_<1)return;ma(e,r),t&&t.scope_.parent_||"symbol"===typeof a||!Object.prototype.propertyIsEnumerable.call(n,a)||ba(e,r)}}function ba(e,t){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];!e.parent_&&e.immer_.autoFreeze_&&e.canAutoFreeze_&&na(t,n)}var ya={get(e,t){if(t===Vn)return e;const n=ea(e);if(!Qn(n,t))return function(e,t,n){var a;const r=wa(t,n);return r?"value"in r?r.value:null===(a=r.get)||void 0===a?void 0:a.call(e.draft_):void 0}(e,n,t);const a=n[t];return e.finalized_||!jn(a)?a:a===va(e.base_,t)?(Ia(e),e.copy_[t]=Sa(a,e)):a},has:(e,t)=>t in ea(e),ownKeys:e=>Reflect.ownKeys(ea(e)),set(e,t,n){const a=wa(ea(e),t);if(null!==a&&void 0!==a&&a.set)return a.set.call(e.draft_,n),!0;if(!e.modified_){const a=va(ea(e),t),s=null===a||void 0===a?void 0:a[Vn];if(s&&s.base_===n)return e.copy_[t]=n,e.assigned_[t]=!1,!0;if(((r=n)===(o=a)?0!==r||1/r===1/o:r!==r&&o!==o)&&(void 0!==n||Qn(e.base_,t)))return!0;Ia(e),ka(e)}var r,o;return e.copy_[t]===n&&(void 0!==n||t in e.copy_)||Number.isNaN(n)&&Number.isNaN(e.copy_[t])||(e.copy_[t]=n,e.assigned_[t]=!0),!0},deleteProperty:(e,t)=>(void 0!==va(e.base_,t)||t in e.base_?(e.assigned_[t]=!1,Ia(e),ka(e)):delete e.assigned_[t],e.copy_&&delete e.copy_[t],!0),getOwnPropertyDescriptor(e,t){const n=ea(e),a=Reflect.getOwnPropertyDescriptor(n,t);return a?{writable:!0,configurable:1!==e.type_||"length"!==t,enumerable:a.enumerable,value:n[t]}:a},defineProperty(){Un(11)},getPrototypeOf:e=>Gn(e.base_),setPrototypeOf(){Un(12)}},xa={};function va(e,t){const n=e[Vn];return(n?ea(n):e)[t]}function wa(e,t){if(!(t in e))return;let n=Gn(e);for(;n;){const e=Object.getOwnPropertyDescriptor(n,t);if(e)return e;n=Gn(n)}}function ka(e){e.modified_||(e.modified_=!0,e.parent_&&ka(e.parent_))}function Ia(e){e.copy_||(e.copy_=ta(e.base_,e.scope_.immer_.useStrictShallowCopy_))}Xn(ya,((e,t)=>{xa[e]=function(){return arguments[0]=arguments[0][0],t.apply(this,arguments)}})),xa.deleteProperty=function(e,t){return xa.set.call(this,e,t,void 0)},xa.set=function(e,t,n){return ya.set.call(this,e[0],t,n,e[0])};function Sa(e,t){const n=Zn(e)?ia("MapSet").proxyMap_(e,t):$n(e)?ia("MapSet").proxySet_(e,t):function(e,t){const n=Array.isArray(e),a={type_:n?1:0,scope_:t?t.scope_:ca(),modified_:!1,finalized_:!1,assigned_:{},parent_:t,base_:e,draft_:null,copy_:null,revoke_:null,isManual_:!1};let r=a,o=ya;n&&(r=[a],o=xa);const{revoke:s,proxy:i}=Proxy.revocable(r,o);return a.draft_=i,a.revoke_=s,i}(e,t);return(t?t.scope_:ca()).drafts_.push(n),n}function Na(e){return Hn(e)||Un(10),Ca(e)}function Ca(e){if(!jn(e)||ra(e))return e;const t=e[Vn];let n;if(t){if(!t.modified_)return t.base_;t.finalized_=!0,n=ta(e,t.scope_.immer_.useStrictShallowCopy_)}else n=ta(e,!0);return Xn(n,((e,t)=>{Jn(n,e,Ca(t))})),t&&(t.finalized_=!1),n}var Ta=new class{constructor(e){var t=this;this.autoFreeze_=!0,this.useStrictShallowCopy_=!1,this.produce=(e,t,n)=>{if("function"===typeof e&&"function"!==typeof t){const n=t;t=e;const a=this;return function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:n;for(var r=arguments.length,o=new Array(r>1?r-1:0),s=1;s<r;s++)o[s-1]=arguments[s];return a.produce(e,(e=>t.call(this,e,...o)))}}let a;if("function"!==typeof t&&Un(6),void 0!==n&&"function"!==typeof n&&Un(7),jn(e)){const r=ha(this),o=Sa(e,void 0);let s=!0;try{a=t(o),s=!1}finally{s?ua(r):da(r)}return la(r,n),fa(a,r)}if(!e||"object"!==typeof e){if(a=t(e),void 0===a&&(a=e),a===Bn&&(a=void 0),this.autoFreeze_&&na(a,!0),n){const t=[],r=[];ia("Patches").generateReplacementPatches_(e,a,t,r),n(t,r)}return a}Un(1)},this.produceWithPatches=(e,n)=>{if("function"===typeof e)return function(n){for(var a=arguments.length,r=new Array(a>1?a-1:0),o=1;o<a;o++)r[o-1]=arguments[o];return t.produceWithPatches(n,(t=>e(t,...r)))};let a,r;const o=this.produce(e,n,((e,t)=>{a=e,r=t}));return[o,a,r]},"boolean"===typeof(null===e||void 0===e?void 0:e.autoFreeze)&&this.setAutoFreeze(e.autoFreeze),"boolean"===typeof(null===e||void 0===e?void 0:e.useStrictShallowCopy)&&this.setUseStrictShallowCopy(e.useStrictShallowCopy)}createDraft(e){jn(e)||Un(8),Hn(e)&&(e=Na(e));const t=ha(this),n=Sa(e,void 0);return n[Vn].isManual_=!0,da(t),n}finishDraft(e,t){const n=e&&e[Vn];n&&n.isManual_||Un(9);const{scope_:a}=n;return la(a,t),fa(void 0,a)}setAutoFreeze(e){this.autoFreeze_=e}setUseStrictShallowCopy(e){this.useStrictShallowCopy_=e}applyPatches(e,t){let n;for(n=t.length-1;n>=0;n--){const a=t[n];if(0===a.path.length&&"replace"===a.op){e=a.value;break}}n>-1&&(t=t.slice(n+1));const a=ia("Patches").applyPatches_;return Hn(e)?a(e,t):this.produce(e,(e=>a(e,t)))}},Ea=Ta.produce;Ta.produceWithPatches.bind(Ta),Ta.setAutoFreeze.bind(Ta),Ta.setUseStrictShallowCopy.bind(Ta),Ta.applyPatches.bind(Ta),Ta.createDraft.bind(Ta),Ta.finishDraft.bind(Ta);function Ra(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"expected a function, instead received ".concat(typeof e);if("function"!==typeof e)throw new TypeError(t)}var _a=e=>Array.isArray(e)?e:[e];function Aa(e){const t=Array.isArray(e[0])?e[0]:e;return function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"expected all items to be functions, instead received the following types: ";if(!e.every((e=>"function"===typeof e))){const n=e.map((e=>"function"===typeof e?"function ".concat(e.name||"unnamed","()"):typeof e)).join(", ");throw new TypeError("".concat(t,"[").concat(n,"]"))}}(t,"createSelector expects all input-selectors to be functions, but received the following types: "),t}Symbol(),Object.getPrototypeOf({});var Fa="undefined"!==typeof WeakRef?WeakRef:class{constructor(e){this.value=e}deref(){return this.value}},Oa=0,Da=1;function Ma(){return{s:Oa,v:void 0,o:null,p:null}}function La(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},n=Ma();const{resultEqualityCheck:a}=t;let r,o=0;function s(){let t=n;const{length:s}=arguments;for(let e=0,n=s;e<n;e++){const n=arguments[e];if("function"===typeof n||"object"===typeof n&&null!==n){let e=t.o;null===e&&(t.o=e=new WeakMap);const a=e.get(n);void 0===a?(t=Ma(),e.set(n,t)):t=a}else{let e=t.p;null===e&&(t.p=e=new Map);const a=e.get(n);void 0===a?(t=Ma(),e.set(n,t)):t=a}}const i=t;let c;if(t.s===Da?c=t.v:(c=e.apply(null,arguments),o++),i.s=Da,a){var l,u,d;const e=null!==(l=null===(u=r)||void 0===u||null===(d=u.deref)||void 0===d?void 0:d.call(u))&&void 0!==l?l:r;null!=e&&a(e,c)&&(c=e,0!==o&&o--);r="object"===typeof c&&null!==c||"function"===typeof c?new Fa(c):c}return i.v=c,c}return s.clearCache=()=>{n=Ma(),s.resetResultsCount()},s.resultsCount=()=>o,s.resetResultsCount=()=>{o=0},s}function Pa(e){for(var t=arguments.length,n=new Array(t>1?t-1:0),a=1;a<t;a++)n[a-1]=arguments[a];const r="function"===typeof e?{memoize:e,memoizeOptions:n}:e,o=function(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];let a,o=0,s=0,i={},c=t.pop();"object"===typeof c&&(i=c,c=t.pop()),Ra(c,"createSelector expects an output function after the inputs, but received: [".concat(typeof c,"]"));const l=z(z({},r),i),{memoize:u,memoizeOptions:d=[],argsMemoize:h=La,argsMemoizeOptions:p=[],devModeChecks:f={}}=l,m=_a(d),g=_a(p),b=Aa(t),y=u((function(){return o++,c.apply(null,arguments)}),...m);const x=h((function(){s++;const e=function(e,t){const n=[],{length:a}=e;for(let r=0;r<a;r++)n.push(e[r].apply(null,t));return n}(b,arguments);return a=y.apply(null,e),a}),...g);return Object.assign(x,{resultFunc:c,memoizedResultFunc:y,dependencies:b,dependencyRecomputations:()=>s,resetDependencyRecomputations:()=>{s=0},lastResult:()=>a,recomputations:()=>o,resetRecomputations:()=>{o=0},memoize:u,argsMemoize:h})};return Object.assign(o,{withTypes:()=>o}),o}var za=Pa(La),Ba=Object.assign((function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:za;!function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"expected an object, instead received ".concat(typeof e);if("object"!==typeof e)throw new TypeError(t)}(e,"createStructuredSelector expects first argument to be an object where each property is a selector, instead received a ".concat(typeof e));const n=Object.keys(e),a=t(n.map((t=>e[t])),(function(){for(var e=arguments.length,t=new Array(e),a=0;a<e;a++)t[a]=arguments[a];return t.reduce(((e,t,a)=>(e[n[a]]=t,e)),{})}));return a}),{withTypes:()=>Ba});function Wa(e){return"Minified Redux error #".concat(e,"; visit https://redux.js.org/Errors?code=").concat(e," for the full message or use the non-minified dev environment for full errors. ")}var Va=(()=>"function"===typeof Symbol&&Symbol.observable||"@@observable")(),Ua=()=>Math.random().toString(36).substring(7).split("").join("."),Ga={INIT:"@@redux/INIT".concat(Ua()),REPLACE:"@@redux/REPLACE".concat(Ua()),PROBE_UNKNOWN_ACTION:()=>"@@redux/PROBE_UNKNOWN_ACTION".concat(Ua())};function Ha(e){if("object"!==typeof e||null===e)return!1;let t=e;for(;null!==Object.getPrototypeOf(t);)t=Object.getPrototypeOf(t);return Object.getPrototypeOf(e)===t||null===Object.getPrototypeOf(e)}function ja(e,t,n){if("function"!==typeof e)throw new Error(Wa(2));if("function"===typeof t&&"function"===typeof n||"function"===typeof n&&"function"===typeof arguments[3])throw new Error(Wa(0));if("function"===typeof t&&"undefined"===typeof n&&(n=t,t=void 0),"undefined"!==typeof n){if("function"!==typeof n)throw new Error(Wa(1));return n(ja)(e,t)}let a=e,r=t,o=new Map,s=o,i=0,c=!1;function l(){s===o&&(s=new Map,o.forEach(((e,t)=>{s.set(t,e)})))}function u(){if(c)throw new Error(Wa(3));return r}function d(e){if("function"!==typeof e)throw new Error(Wa(4));if(c)throw new Error(Wa(5));let t=!0;l();const n=i++;return s.set(n,e),function(){if(t){if(c)throw new Error(Wa(6));t=!1,l(),s.delete(n),o=null}}}function h(e){if(!Ha(e))throw new Error(Wa(7));if("undefined"===typeof e.type)throw new Error(Wa(8));if("string"!==typeof e.type)throw new Error(Wa(17));if(c)throw new Error(Wa(9));try{c=!0,r=a(r,e)}finally{c=!1}return(o=s).forEach((e=>{e()})),e}h({type:Ga.INIT});return{dispatch:h,subscribe:d,getState:u,replaceReducer:function(e){if("function"!==typeof e)throw new Error(Wa(10));a=e,h({type:Ga.REPLACE})},[Va]:function(){const e=d;return{subscribe(t){if("object"!==typeof t||null===t)throw new Error(Wa(11));function n(){const e=t;e.next&&e.next(u())}n();return{unsubscribe:e(n)}},[Va](){return this}}}}}function Ka(e){const t=Object.keys(e),n={};for(let o=0;o<t.length;o++){const a=t[o];0,"function"===typeof e[a]&&(n[a]=e[a])}const a=Object.keys(n);let r;try{!function(e){Object.keys(e).forEach((t=>{const n=e[t];if("undefined"===typeof n(void 0,{type:Ga.INIT}))throw new Error(Wa(12));if("undefined"===typeof n(void 0,{type:Ga.PROBE_UNKNOWN_ACTION()}))throw new Error(Wa(13))}))}(n)}catch(B){r=B}return function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},t=arguments.length>1?arguments[1]:void 0;if(r)throw r;let o=!1;const s={};for(let r=0;r<a.length;r++){const i=a[r],c=n[i],l=e[i],u=c(l,t);if("undefined"===typeof u){t&&t.type;throw new Error(Wa(14))}s[i]=u,o=o||u!==l}return o=o||a.length!==Object.keys(e).length,o?s:e}}function qa(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];return 0===t.length?e=>e:1===t.length?t[0]:t.reduce(((e,t)=>function(){return e(t(...arguments))}))}function Xa(e){return t=>{let{dispatch:n,getState:a}=t;return t=>r=>"function"===typeof r?r(n,a,e):t(r)}}var Ya=Xa(),Qa=Xa;const Ja=["reducerPath"];!function(){const e=Pa(...arguments),t=Object.assign((function(){const t=e(...arguments),n=function(e){for(var n=arguments.length,a=new Array(n>1?n-1:0),r=1;r<n;r++)a[r-1]=arguments[r];return t(Hn(e)?Na(e):e,...a)};return Object.assign(n,t),n}),{withTypes:()=>t})}(La);var Za="undefined"!==typeof window&&window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__?window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__:function(){if(0!==arguments.length)return"object"===typeof arguments[0]?qa:qa.apply(null,arguments)};"undefined"!==typeof window&&window.__REDUX_DEVTOOLS_EXTENSION__&&window.__REDUX_DEVTOOLS_EXTENSION__;function $a(e,t){function n(){if(t){let n=t(...arguments);if(!n)throw new Error(Nr(0));return z(z({type:e,payload:n.payload},"meta"in n&&{meta:n.meta}),"error"in n&&{error:n.error})}return{type:e,payload:arguments.length<=0?void 0:arguments[0]}}return n.toString=()=>"".concat(e),n.type=e,n.match=t=>function(e){return Ha(e)&&"type"in e&&"string"===typeof e.type}(t)&&t.type===e,n}var er=class e extends Array{constructor(){super(...arguments),Object.setPrototypeOf(this,e.prototype)}static get[Symbol.species](){return e}concat(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];return super.concat.apply(this,t)}prepend(){for(var t=arguments.length,n=new Array(t),a=0;a<t;a++)n[a]=arguments[a];return 1===n.length&&Array.isArray(n[0])?new e(...n[0].concat(this)):new e(...n.concat(this))}};function tr(e){return jn(e)?Ea(e,(()=>{})):e}function nr(e,t,n){if(e.has(t)){let a=e.get(t);return n.update&&(a=n.update(a,t,e),e.set(t,a)),a}if(!n.insert)throw new Error(Nr(10));const a=n.insert(t,e);return e.set(t,a),a}var ar="RTK_autoBatch",rr=e=>t=>{setTimeout(t,e)},or="undefined"!==typeof window&&window.requestAnimationFrame?window.requestAnimationFrame:rr(10),sr=e=>function(t){const{autoBatch:n=!0}=null!==t&&void 0!==t?t:{};let a=new er(e);return n&&a.push(function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{type:"raf"};return t=>function(){const n=t(...arguments);let a=!0,r=!1,o=!1;const s=new Set,i="tick"===e.type?queueMicrotask:"raf"===e.type?or:"callback"===e.type?e.queueNotification:rr(e.timeout),c=()=>{o=!1,r&&(r=!1,s.forEach((e=>e())))};return Object.assign({},n,{subscribe(e){const t=n.subscribe((()=>a&&e()));return s.add(e),()=>{t(),s.delete(e)}},dispatch(e){try{var t;return a=!(null!==e&&void 0!==e&&null!==(t=e.meta)&&void 0!==t&&t[ar]),r=!a,r&&(o||(o=!0,i(c))),n.dispatch(e)}finally{a=!0}}})}}("object"===typeof n?n:void 0)),a};function ir(e){const t={},n=[];let a;const r={addCase(e,n){const a="string"===typeof e?e:e.type;if(!a)throw new Error(Nr(28));if(a in t)throw new Error(Nr(29));return t[a]=n,r},addMatcher:(e,t)=>(n.push({matcher:e,reducer:t}),r),addDefaultCase:e=>(a=e,r)};return e(r),[t,n,a]}var cr=function(){let e="",t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:21;for(;t--;)e+="ModuleSymbhasOwnPr-0123456789ABCDEFGHNRVfgctiUvz_KqYTJkLxpZXIjQW"[64*Math.random()|0];return e};var lr=Symbol.for("rtk-slice-createasyncthunk");function ur(e,t){return"".concat(e,"/").concat(t)}function dr(){var e;let{creators:t}=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};const n=null===t||void 0===t||null===(e=t.asyncThunk)||void 0===e?void 0:e[lr];return function(e){const{name:t,reducerPath:a=t}=e;if(!t)throw new Error(Nr(11));const r=("function"===typeof e.reducers?e.reducers(function(){function e(e,t){return z({_reducerDefinitionType:"asyncThunk",payloadCreator:e},t)}return e.withTypes=()=>e,{reducer:e=>Object.assign({[e.name](){return e(...arguments)}}[e.name],{_reducerDefinitionType:"reducer"}),preparedReducer:(e,t)=>({_reducerDefinitionType:"reducerWithPrepare",prepare:e,reducer:t}),asyncThunk:e}}()):e.reducers)||{},o=Object.keys(r),s={sliceCaseReducersByName:{},sliceCaseReducersByType:{},actionCreators:{},sliceMatchers:[]},i={addCase(e,t){const n="string"===typeof e?e:e.type;if(!n)throw new Error(Nr(12));if(n in s.sliceCaseReducersByType)throw new Error(Nr(13));return s.sliceCaseReducersByType[n]=t,i},addMatcher:(e,t)=>(s.sliceMatchers.push({matcher:e,reducer:t}),i),exposeAction:(e,t)=>(s.actionCreators[e]=t,i),exposeCaseReducer:(e,t)=>(s.sliceCaseReducersByName[e]=t,i)};function c(){const[t={},n=[],a]="function"===typeof e.extraReducers?ir(e.extraReducers):[e.extraReducers],r=z(z({},t),s.sliceCaseReducersByType);return function(e,t){let n,[a,r,o]=ir(t);if("function"===typeof e)n=()=>tr(e());else{const t=tr(e);n=()=>t}function s(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:n(),t=arguments.length>1?arguments[1]:void 0,s=[a[t.type],...r.filter((e=>{let{matcher:n}=e;return n(t)})).map((e=>{let{reducer:t}=e;return t}))];return 0===s.filter((e=>!!e)).length&&(s=[o]),s.reduce(((e,n)=>{if(n){if(Hn(e)){const a=n(e,t);return void 0===a?e:a}if(jn(e))return Ea(e,(e=>n(e,t)));{const a=n(e,t);if(void 0===a){if(null===e)return e;throw new Error(Nr(9))}return a}}return e}),e)}return s.getInitialState=n,s}(e.initialState,(e=>{for(let t in r)e.addCase(t,r[t]);for(let t of s.sliceMatchers)e.addMatcher(t.matcher,t.reducer);for(let t of n)e.addMatcher(t.matcher,t.reducer);a&&e.addDefaultCase(a)}))}o.forEach((a=>{const o=r[a],s={reducerName:a,type:ur(t,a),createNotation:"function"===typeof e.reducers};!function(e){return"asyncThunk"===e._reducerDefinitionType}(o)?function(e,t,n){let a,r,{type:o,reducerName:s,createNotation:i}=e;if("reducer"in t){if(i&&!function(e){return"reducerWithPrepare"===e._reducerDefinitionType}(t))throw new Error(Nr(17));a=t.reducer,r=t.prepare}else a=t;n.addCase(o,a).exposeCaseReducer(s,a).exposeAction(s,r?$a(o,r):$a(o))}(s,o,i):function(e,t,n,a){let{type:r,reducerName:o}=e;if(!a)throw new Error(Nr(18));const{payloadCreator:s,fulfilled:i,pending:c,rejected:l,settled:u,options:d}=t,h=a(r,s,d);n.exposeAction(o,h),i&&n.addCase(h.fulfilled,i);c&&n.addCase(h.pending,c);l&&n.addCase(h.rejected,l);u&&n.addMatcher(h.settled,u);n.exposeCaseReducer(o,{fulfilled:i||fr,pending:c||fr,rejected:l||fr,settled:u||fr})}(s,o,i,n)}));const l=e=>e,u=new Map;let d;function h(e,t){return d||(d=c()),d(e,t)}function p(){return d||(d=c()),d.getInitialState()}function f(t){let n=arguments.length>1&&void 0!==arguments[1]&&arguments[1];function a(e){let a=e[t];return"undefined"===typeof a&&n&&(a=p()),a}function r(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:l;const a=nr(u,n,{insert:()=>new WeakMap});return nr(a,t,{insert:()=>{const a={};for(const[o,s]of Object.entries(null!==(r=e.selectors)&&void 0!==r?r:{})){var r;a[o]=hr(s,t,p,n)}return a}})}return{reducerPath:t,getSelectors:r,get selectors(){return r(a)},selectSlice:a}}const m=z(z({name:t,reducer:h,actions:s.actionCreators,caseReducers:s.sliceCaseReducersByName,getInitialState:p},f(a)),{},{injectInto(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},{reducerPath:n}=t,r=et(t,Ja);const o=null!==n&&void 0!==n?n:a;return e.inject({reducerPath:o,reducer:h},r),z(z({},m),f(o,!0))}});return m}}function hr(e,t,n,a){function r(r){let o=t(r);"undefined"===typeof o&&a&&(o=n());for(var s=arguments.length,i=new Array(s>1?s-1:0),c=1;c<s;c++)i[c-1]=arguments[c];return e(o,...i)}return r.unwrapped=e,r}var pr=dr();function fr(){}var mr="listener",gr="completed",br="cancelled",yr=("task-".concat(br),"task-".concat(gr),"".concat(mr,"-").concat(br),"".concat(mr,"-").concat(gr),(e,t)=>{if("function"!==typeof e)throw new Error(Nr(32))});var{assign:xr}=Object,vr="listenerMiddleware",wr=e=>{let{type:t,actionCreator:n,matcher:a,predicate:r,effect:o}=e;if(t)r=$a(t).match;else if(n)t=n.type,r=n.match;else if(a)r=a;else if(!r)throw new Error(Nr(21));return yr(o),{predicate:r,type:t,effect:o}},kr=Object.assign((e=>{const{type:t,predicate:n,effect:a}=wr(e);return{id:cr(),effect:a,type:t,predicate:n,pending:new Set,unsubscribe:()=>{throw new Error(Nr(22))}}}),{withTypes:()=>kr}),Ir=Object.assign($a("".concat(vr,"/add")),{withTypes:()=>Ir}),Sr=($a("".concat(vr,"/removeAll")),Object.assign($a("".concat(vr,"/remove")),{withTypes:()=>Sr}));Symbol.for("rtk-state-proxy-original");function Nr(e){return"Minified Redux Toolkit error #".concat(e,"; visit https://redux-toolkit.js.org/Errors?code=").concat(e," for the full message or use the non-minified dev environment for full errors. ")}const Cr=pr({name:"main",initialState:{path:"",error:"",message:"",signalr:{},theme:(()=>{if("undefined"===typeof window)return"light";const e=window.localStorage.getItem("theme");if("light"===e||"dark"===e)return e;return window.matchMedia&&window.matchMedia("(prefers-color-scheme: dark)").matches?"dark":"light"})(),prefersLightMode:!("undefined"===typeof window||!window.matchMedia||!window.matchMedia("(prefers-color-scheme: light)").matches),GlobalCallErrors:[],constants:{drawerWidth:240}},reducers:{set:(e,t)=>{e[t.target]=t.payload},setTheme:(e,t)=>{e.theme=t.payload},setPath:(e,t)=>{e.path=t.payload},setError:(e,t)=>{e.error=t.payload},setMessage:(e,t)=>{e.message=t.payload},setSignalr:(e,t)=>{e.signalr=t.payload},setPrefersLightMode:(e,t)=>{e.prefersLightMode=t.payload},setGlobalCallErrors:(e,t)=>{e.GlobalCallErrors=t.payload}}}),{set:Tr,setTheme:Er,setPath:Rr,setError:_r,setMessage:Ar,setSignalr:Fr,setPrefersLightMode:Or,setGlobalCallErrors:Dr}=Cr.actions,Mr=Cr.reducer;var Lr=n(237);var Pr=A,zr=Symbol.for("react-redux-context"),Br="undefined"!==typeof globalThis?globalThis:{};function Wr(){var e;if(!Pr.createContext)return{};const t=null!==(e=Br[zr])&&void 0!==e?e:Br[zr]=new Map;let n=t.get(Pr.createContext);return n||(n=Pr.createContext(null),t.set(Pr.createContext,n)),n}var Vr=Wr(),Ur=()=>{throw new Error("uSES not initialized!")};function Gr(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:Vr;return function(){return Pr.useContext(e)}}var Hr=Gr(),jr=Ur,Kr=(e,t)=>e===t;function qr(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:Vr;const t=e===Vr?Hr:Gr(e),n=function(e){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const{equalityFn:a=Kr,devModeChecks:r={}}="function"===typeof n?{equalityFn:n}:n;const{store:o,subscription:s,getServerState:i,stabilityCheck:c,identityFunctionCheck:l}=t(),u=(Pr.useRef(!0),Pr.useCallback({[e.name]:t=>e(t)}[e.name],[e,c,r.stabilityCheck])),d=jr(s.addNestedSub,o.getState,i||o.getState,u,a);return Pr.useDebugValue(d),d};return Object.assign(n,{withTypes:()=>n}),n}var Xr=qr();Symbol.for("react.element"),Symbol.for("react.portal"),Symbol.for("react.fragment"),Symbol.for("react.strict_mode"),Symbol.for("react.profiler"),Symbol.for("react.provider"),Symbol.for("react.context"),Symbol.for("react.server_context"),Symbol.for("react.forward_ref"),Symbol.for("react.suspense"),Symbol.for("react.suspense_list"),Symbol.for("react.memo"),Symbol.for("react.lazy"),Symbol.for("react.offscreen"),Symbol.for("react.client.reference");function Yr(e){e()}var Qr={notify(){},get:()=>[]};function Jr(e,t){let n,a=Qr,r=0,o=!1;function s(){l.onStateChange&&l.onStateChange()}function i(){r++,n||(n=t?t.addNestedSub(s):e.subscribe(s),a=function(){let e=null,t=null;return{clear(){e=null,t=null},notify(){Yr((()=>{let t=e;for(;t;)t.callback(),t=t.next}))},get(){const t=[];let n=e;for(;n;)t.push(n),n=n.next;return t},subscribe(n){let a=!0;const r=t={callback:n,next:null,prev:t};return r.prev?r.prev.next=r:e=r,function(){a&&null!==e&&(a=!1,r.next?r.next.prev=r.prev:t=r.prev,r.prev?r.prev.next=r.next:e=r.next)}}}}())}function c(){r--,n&&0===r&&(n(),n=void 0,a.clear(),a=Qr)}const l={addNestedSub:function(e){i();const t=a.subscribe(e);let n=!1;return()=>{n||(n=!0,t(),c())}},notifyNestedSubs:function(){a.notify()},handleChangeWrapper:s,isSubscribed:function(){return o},trySubscribe:function(){o||(o=!0,i())},tryUnsubscribe:function(){o&&(o=!1,c())},getListeners:()=>a};return l}var Zr=!("undefined"===typeof window||"undefined"===typeof window.document||"undefined"===typeof window.document.createElement),$r="undefined"!==typeof navigator&&"ReactNative"===navigator.product,eo=Zr||$r?Pr.useLayoutEffect:Pr.useEffect;Object.defineProperty,Object.getOwnPropertyNames,Object.getOwnPropertySymbols,Object.getOwnPropertyDescriptor,Object.getPrototypeOf,Object.prototype;var to=function(e){let{store:t,context:n,children:a,serverState:r,stabilityCheck:o="once",identityFunctionCheck:s="once"}=e;const i=Pr.useMemo((()=>{const e=Jr(t);return{store:t,subscription:e,getServerState:r?()=>r:void 0,stabilityCheck:o,identityFunctionCheck:s}}),[t,r,o,s]),c=Pr.useMemo((()=>t.getState()),[t]);eo((()=>{const{subscription:e}=i;return e.onStateChange=e.notifyNestedSubs,e.trySubscribe(),c!==t.getState()&&e.notifyNestedSubs(),()=>{e.tryUnsubscribe(),e.onStateChange=void 0}}),[i,c]);const l=n||Vr;return Pr.createElement(l.Provider,{value:i},a)};function no(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:Vr;const t=e===Vr?Hr:Gr(e),n=()=>{const{store:e}=t();return e};return Object.assign(n,{withTypes:()=>n}),n}var ao=no();function ro(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:Vr;const t=e===Vr?ao:no(e),n=()=>t().dispatch;return Object.assign(n,{withTypes:()=>n}),n}var oo,so=ro();oo=Lr.useSyncExternalStoreWithSelector,jr=oo,(e=>{e})(A.useSyncExternalStore);class io{constructor(e,t){this.backend=e,this.dataMover=t,this.data=new WeakMap,this.dataIdsCount=0}get(e){return this.data.has(e)||this.dataMover.moveData(this.backend,e),this.data.get(e)}set(e,t){this.dataIdsCount++,this.data.set(e,t)}has(e){return this.data.has(e)}delete(e){return this.dataIdsCount--,this.data.delete(e)}numDataIds(){return this.dataIdsCount}}class co{refCount(e){return lo("refCount")}incRef(e){return lo("incRef")}timerAvailable(){return!0}time(e){return lo("time")}read(e){return lo("read")}readSync(e){return lo("readSync")}readToGPU(e,t){return lo("readToGPU")}numDataIds(){return lo("numDataIds")}disposeData(e,t){return lo("disposeData")}write(e,t,n){return lo("write")}move(e,t,n,a,r){return lo("move")}createTensorFromGPUData(e,t,n){return lo("createTensorFromGPUData")}memory(){return lo("memory")}floatPrecision(){return lo("floatPrecision")}epsilon(){return 32===this.floatPrecision()?1e-7:1e-4}dispose(){return lo("dispose")}}function lo(e){throw new Error("'".concat(e,"' not yet implemented or not found in the registry. ")+"This kernel may not be supported by the tfjs backend you have chosen")}function uo(e){let t=e.length,n=0;for(;t>0;)n=Math.random()*t|0,t--,fo(e,t,n)}function ho(e,t,n){return Math.max(e,Math.min(t,n))}function po(e){return e%2===0?e:e+1}function fo(e,t,n){const a=e[t];e[t]=e[n],e[n]=a}function mo(e,t){if(!e)throw new Error("string"===typeof t?t:t())}function go(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"";mo(xo(e,t),(()=>n+" Shapes ".concat(e," and ").concat(t," must match")))}function bo(e){mo(null!=e,(()=>"The input to the tensor constructor must be a non-null value."))}function yo(e){if(0===e.length)return 1;let t=e[0];for(let n=1;n<e.length;n++)t*=e[n];return t}function xo(e,t){if(e===t)return!0;if(null==e||null==t)return!1;if(e.length!==t.length)return!1;for(let n=0;n<e.length;n++)if(e[n]!==t[n])return!1;return!0}function vo(e){return e%1===0}function wo(e){const t=Math.ceil(Math.sqrt(e));return[t,Math.ceil(e/t)]}function ko(e,t){return t<=e.length?e:e+" ".repeat(t-e.length)}function Io(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:e=>0,n=arguments.length>2?arguments[2]:void 0,a=arguments.length>3?arguments[3]:void 0;return new Promise(((r,o)=>{let s=0;const i=()=>{if(e())return void r();s++;const c=t(s);null!=n&&s>=n?o():null!=a?a(i,c):setTimeout(i,c)};i()}))}function So(e,t){let n=1,a=-1;for(let o=0;o<e.length;++o)if(e[o]>=0)n*=e[o];else if(-1===e[o]){if(-1!==a)throw Error("Shapes can only have 1 implicit size. "+"Found -1 at dim ".concat(a," and dim ").concat(o));a=o}else if(e[o]<0)throw Error("Shapes can not be < 0. Found ".concat(e[o]," at dim ").concat(o));if(-1===a){if(t>0&&t!==n)throw Error("Size(".concat(t,") must match the product of shape ").concat(e));return e}if(0===n)throw Error("Cannot infer the missing size in [".concat(e,"] when ")+"there are 0 elements");if(t%n!==0)throw Error("The implicit shape can't be a fractional number. "+"Got ".concat(t," / ").concat(n));const r=e.slice();return r[a]=t/n,r}function No(e,t){const n=t.length;return e=null==e?t.map(((e,t)=>t)):[].concat(e),mo(e.every((e=>e>=-n&&e<n)),(()=>"All values in axis param must be in range [-".concat(n,", ").concat(n,") but ")+"got axis ".concat(e))),mo(e.every((e=>vo(e))),(()=>"All values in axis param must be integers but "+"got axis ".concat(e))),e.map((e=>e<0?n+e:e))}function Co(e,t){const n=[],a=[],r=null!=t&&Array.isArray(t)&&0===t.length,o=null==t||r?null:No(t,e).sort();let s=0;for(let i=0;i<e.length;++i){if(null!=o){if(o[s]===i&&1!==e[i])throw new Error("Can't squeeze axis ".concat(i," since its dim '").concat(e[i],"' is not 1"));(null==o[s]||o[s]>i)&&1===e[i]&&(n.push(e[i]),a.push(i)),o[s]<=i&&s++}1!==e[i]&&(n.push(e[i]),a.push(i))}return{newShape:n,keptDims:a}}function To(e,t){return Eo(e,t)}function Eo(e,t){let n=null;if(null==e||"float32"===e)n=new Float32Array(t);else if("int32"===e)n=new Int32Array(t);else if("bool"===e)n=new Uint8Array(t);else{if("string"!==e)throw new Error("Unknown data type ".concat(e));n=new Array(t)}return n}function Ro(e,t){return"complex64"!==t&&(("float32"!==t||"complex64"===e)&&(("int32"!==t||"float32"===e||"complex64"===e)&&("bool"!==t||"bool"!==e)))}function _o(e){if("float32"===e||"int32"===e)return 4;if("complex64"===e)return 8;if("bool"===e)return 1;throw new Error("Unknown dtype ".concat(e))}function Ao(e){return"string"===typeof e||e instanceof String}function Fo(e){return"number"===typeof e}function Oo(e){return Array.isArray(e)?Oo(e[0]):e instanceof Float32Array?"float32":e instanceof Int32Array||e instanceof Uint8Array||e instanceof Uint8ClampedArray?"int32":Fo(e)?"float32":Ao(e)?"string":"boolean"===typeof e?"bool":"float32"}function Do(e){return!!(e&&e.constructor&&e.call&&e.apply)}function Mo(e,t){for(let n=t;n<e;++n)if(e%n===0)return n;return e}function Lo(e){const t=e.length;if(t<2)return[];const n=new Array(t-1);n[t-2]=e[t-1];for(let a=t-3;a>=0;--a)n[a]=n[a+1]*e[a+1];return n}function Po(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const r=new Array;if(1===t.length){const o=t[0]*(a?2:1);for(let t=0;t<o;t++)r[t]=n[e+t]}else{const o=t[0],s=t.slice(1),i=s.reduce(((e,t)=>e*t))*(a?2:1);for(let t=0;t<o;t++)r[t]=Po(e+t*i,s,n,a)}return r}function zo(e,t){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];if(0===e.length)return t[0];const a=e.reduce(((e,t)=>e*t))*(n?2:1);if(0===a)return[];if(a!==t.length)throw new Error("[".concat(e,"] does not match the input size ").concat(t.length).concat(n?" for a complex tensor":"","."));return Po(0,e,t,n)}function Bo(e,t){const n=Wo(e,t);for(let a=0;a<n.length;a++)n[a]=1;return n}function Wo(e,t){if(null==t||"float32"===t||"complex64"===t)return new Float32Array(e);if("int32"===t)return new Int32Array(e);if("bool"===t)return new Uint8Array(e);throw new Error("Unknown data type ".concat(t))}function Vo(e,t){const n=e.reduce(((e,t)=>e*t),1);if(null==t||"float32"===t)return zo(e,new Float32Array(n));if("int32"===t)return zo(e,new Int32Array(n));if("bool"===t)return zo(e,new Uint8Array(n));throw new Error("Unknown data type ".concat(t))}function Uo(e){e.forEach((t=>{mo(Number.isInteger(t)&&t>=0,(()=>"Tensor must have a shape comprised of positive integers but got "+"shape [".concat(e,"].")))}))}function Go(e,t,n){if(0===t)return 0;if(1===t)return e[0];let a=e[e.length-1];for(let r=0;r<e.length-1;++r)a+=n[r]*e[r];return a}function Ho(e,t,n){if(0===t)return[];if(1===t)return[e];const a=new Array(t);for(let r=0;r<a.length-1;++r)a[r]=Math.floor(e/n[r]),e-=a[r]*n[r];return a[a.length-1]=e,a}function jo(e){return e&&e.then&&"function"===typeof e.then}const Ko="tfjsflags";class qo{constructor(e){this.global=e,this.flags={},this.flagRegistry={},this.urlFlags={},this.getQueryParams=Xo,this.populateURLFlags()}setPlatform(e,t){null!=this.platform&&(Yo().getBool("IS_TEST")||Yo().getBool("PROD")||console.warn("Platform ".concat(this.platformName," has already been set. ")+"Overwriting the platform with ".concat(e,"."))),this.platformName=e,this.platform=t}registerFlag(e,t,n){if(this.flagRegistry[e]={evaluationFn:t,setHook:n},null!=this.urlFlags[e]){const t=this.urlFlags[e];Yo().getBool("IS_TEST")||Yo().getBool("PROD")||console.warn("Setting feature override from URL ".concat(e,": ").concat(t,".")),this.set(e,t)}}async getAsync(e){return e in this.flags||(this.flags[e]=await this.evaluateFlag(e)),this.flags[e]}get(e){if(e in this.flags)return this.flags[e];const t=this.evaluateFlag(e);if(jo(t))throw new Error("Flag ".concat(e," cannot be synchronously evaluated. ")+"Please use getAsync() instead.");return this.flags[e]=t,this.flags[e]}getNumber(e){return this.get(e)}getBool(e){return this.get(e)}getString(e){return this.get(e)}getFlags(){return this.flags}get features(){return this.flags}set(e,t){if(null==this.flagRegistry[e])throw new Error("Cannot set flag ".concat(e," as it has not been registered."));this.flags[e]=t,null!=this.flagRegistry[e].setHook&&this.flagRegistry[e].setHook(t)}evaluateFlag(e){if(null==this.flagRegistry[e])throw new Error("Cannot evaluate flag '".concat(e,"': no evaluation function found."));return this.flagRegistry[e].evaluationFn()}setFlags(e){this.flags=Object.assign({},e)}reset(){this.flags={},this.urlFlags={},this.populateURLFlags()}populateURLFlags(){if("undefined"===typeof this.global||"undefined"===typeof this.global.location||"undefined"===typeof this.global.location.search)return;const e=this.getQueryParams(this.global.location.search);if(Ko in e){e[Ko].split(",").forEach((e=>{const[t,n]=e.split(":");this.urlFlags[t]=function(e,t){const n=t.toLowerCase();return"true"===n||"false"===n?"true"===n:"".concat(+n)===n?+n:t}(0,n)}))}}}function Xo(e){const t={};return e.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g,(function(e){for(var n=arguments.length,a=new Array(n>1?n-1:0),r=1;r<n;r++)a[r-1]=arguments[r];return function(e,t,n){e[decodeURIComponent(t)]=decodeURIComponent(n||"")}(t,a[0],a[1]),a.join("=")})),t}function Yo(){return Jo}let Qo,Jo=null;function Zo(){if(null==Qo){let e;if("undefined"!==typeof window)e=window;else if("undefined"!==typeof n.g)e=n.g;else if("undefined"!==typeof process)e=process;else{if("undefined"===typeof self)throw new Error("Could not find a global object");e=self}Qo=e}return Qo}function $o(e,t){const n=function(){const e=Zo();return null==e._tfGlobals&&(e._tfGlobals=new Map),e._tfGlobals}();if(n.has(e))return n.get(e);{const a=t();return n.set(e,a),n.get(e)}}const es="Abs",ts="Acos",ns="Acosh",as="Add",rs="AddN",os="All",ss="Any",is="ArgMax",cs="ArgMin",ls="Asin",us="Asinh",ds="Atan",hs="Atanh",ps="Atan2",fs="AvgPool",ms="AvgPoolGrad",gs="AvgPool3D",bs="AvgPool3DGrad",ys="BatchMatMul",xs="BatchToSpaceND",vs="Bincount",ws="BitwiseAnd",ks="BroadcastArgs",Is="Cast",Ss="Ceil",Ns="ClipByValue",Cs="Complex",Ts="ComplexAbs",Es="Concat",Rs="Conv2D",_s="Conv2DBackpropFilter",As="Conv2DBackpropInput",Fs="Conv3D",Os="Conv3DBackpropFilterV2",Ds="Conv3DBackpropInputV2",Ms="Cos",Ls="Cosh",Ps="Cumprod",zs="Cumsum",Bs="CropAndResize",Ws="DenseBincount",Vs="DepthToSpace",Us="DepthwiseConv2dNative",Gs="DepthwiseConv2dNativeBackpropFilter",Hs="DepthwiseConv2dNativeBackpropInput",js="Diag",Ks="Dilation2D",qs="Dilation2DBackpropInput",Xs="Dilation2DBackpropFilter",Ys="Draw",Qs="RealDiv",Js="Einsum",Zs="Elu",$s="EluGrad",ei="Erf",ti="Equal",ni="Exp",ai="ExpandDims",ri="Expm1",oi="FFT",si="Fill",ii="FlipLeftRight",ci="Floor",li="FloorDiv",ui="FusedBatchNorm",di="GatherV2",hi="GatherNd",pi="Greater",fi="GreaterEqual",mi="Identity",gi="IFFT",bi="Imag",yi="IsFinite",xi="IsInf",vi="IsNan",wi="LeakyRelu",ki="Less",Ii="LessEqual",Si="LinSpace",Ni="Log",Ci="Log1p",Ti="LogicalAnd",Ei="LogicalNot",Ri="LogicalOr",_i="LRN",Ai="LRNGrad",Fi="Max",Oi="Maximum",Di="MaxPool",Mi="MaxPoolGrad",Li="MaxPool3D",Pi="MaxPool3DGrad",zi="MaxPoolWithArgmax",Bi="Mean",Wi="Min",Vi="Minimum",Ui="MirrorPad",Gi="Mod",Hi="Multinomial",ji="Multiply",Ki="Neg",qi="NotEqual",Xi="NonMaxSuppressionV3",Yi="NonMaxSuppressionV4",Qi="NonMaxSuppressionV5",Ji="OnesLike",Zi="OneHot",$i="Pack",ec="PadV2",tc="Pow",nc="Prelu",ac="Prod",rc="RaggedGather",oc="RaggedRange",sc="RaggedTensorToTensor",ic="Range",cc="Real",lc="Reciprocal",uc="Relu",dc="Reshape",hc="ResizeNearestNeighbor",pc="ResizeNearestNeighborGrad",fc="ResizeBilinear",mc="ResizeBilinearGrad",gc="Relu6",bc="Reverse",yc="Round",xc="Rsqrt",vc="ScatterNd",wc="TensorScatterUpdate",kc="SearchSorted",Ic="Select",Sc="Selu",Nc="Slice",Cc="Sin",Tc="Sinh",Ec="Sign",Rc="Sigmoid",_c="Softplus",Ac="Sqrt",Fc="Sum",Oc="SpaceToBatchND",Dc="SplitV",Mc="Softmax",Lc="SparseFillEmptyRows",Pc="SparseReshape",zc="SparseSegmentMean",Bc="SparseSegmentSum",Wc="SparseToDense",Vc="SquaredDifference",Uc="Square",Gc="StaticRegexReplace",Hc="StridedSlice",jc="StringNGrams",Kc="StringSplit",qc="StringToHashBucketFast",Xc="Sub",Yc="Tan",Qc="Tanh",Jc="Tile",Zc="TopK",$c="Transform",el="Transpose",tl="Unique",nl="Unpack",al="UnsortedSegmentSum",rl="ZerosLike",ol="Step",sl="FromPixels",il="RotateWithOffset",cl="_FusedMatMul",ll="FusedConv2D",ul="FusedDepthwiseConv2D";function dl(){Yo().getBool("IS_TEST")||Yo().getBool("PROD")||console.warn(...arguments)}function hl(){Yo().getBool("IS_TEST")||Yo().getBool("PROD")||console.log(...arguments)}const pl=$o("kernelRegistry",(()=>new Map)),fl=$o("gradRegistry",(()=>new Map));function ml(e,t){const n=vl(e,t);return pl.get(n)}function gl(e){return fl.get(e)}function bl(e){const t=pl.entries(),n=[];for(;;){const{done:a,value:r}=t.next();if(a)break;const[o,s]=r,[i]=o.split("_");i===e&&n.push(s)}return n}function yl(e){const{kernelName:t,backendName:n}=e,a=vl(t,n);pl.has(a)&&dl("The kernel '".concat(t,"' for backend ")+"'".concat(n,"' is already registered")),pl.set(a,e)}function xl(e){const{kernelName:t}=e;fl.has(t)&&Yo().getBool("DEBUG")&&dl("Overriding the gradient for '".concat(t,"'")),fl.set(t,e)}function vl(e,t){return"".concat(t,"_").concat(e)}function wl(e){return e instanceof Float32Array||e instanceof Int32Array||e instanceof Uint8Array||e instanceof Uint8ClampedArray}var kl=n(353),Il=n.n(kl);const Sl=Il()||kl;function Nl(e){return Sl.fromString(e,!0,16)}const Cl=Nl("c3a5c85c97cb3127"),Tl=Nl("b492b66fbe98f273"),El=Nl("9ae16a3b2f90404f");function Rl(e){return e.xor(e.shru(47))}function _l(e,t,n){const a=e.slice(t,t+n);return Sl.fromBytes(Array.from(a),!0,!0)}function Al(e,t){return _l(e,t,8)}function Fl(e,t){return _l(e,t,4)}function Ol(e,t){return 0===t?e:e.shru(t).or(e.shl(64-t))}function Dl(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:Nl("9ddfea08eb382d69"),a=e.xor(t).mul(n);a=a.xor(a.shru(47));let r=t.xor(a).mul(n);return r=r.xor(r.shru(47)),r=r.mul(n),r}function Ml(e,t,n,a){return function(e,t,n,a,r,o){r=r.add(e),o=Ol(o.add(r).add(a),21);const s=r;return r=(r=r.add(t)).add(n),o=o.add(Ol(r,44)),[r.add(a),o.add(s)]}(Al(e,t),Al(e,t+8),Al(e,t+16),Al(e,t+24),n,a)}function Ll(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:e.length;const n=Sl.fromNumber(81,!0);if(t<=32)return t<=16?function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:e.length;if(t>=8){const n=El.add(2*t),a=Al(e,0).add(El),r=Al(e,t-8);return Dl(Ol(r,37).mul(n).add(a),Ol(a,25).add(r).mul(n),n)}if(t>=4){const n=El.add(2*t);return Dl(Fl(e,0).shl(3).add(t),Fl(e,t-4),n)}if(t>0){const n=e[0]+(e[t>>1]<<8),a=t+(e[t-1]<<2);return Rl(El.mul(n).xor(Cl.mul(a))).mul(El)}return El}(e,t):function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:e.length;const n=El.add(2*t),a=Al(e,0).mul(Tl),r=Al(e,8),o=Al(e,t-8).mul(n),s=Al(e,t-16).mul(El);return Dl(Ol(a.add(r),43).add(Ol(o,30)).add(s),a.add(Ol(r.add(El),18)).add(o),n)}(e,t);if(t<=64)return function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:e.length;const n=El.add(2*t),a=Al(e,0).mul(El),r=Al(e,8),o=Al(e,t-8).mul(n),s=Al(e,t-16).mul(El),i=Ol(a.add(r),43).add(Ol(o,30)).add(s),c=Dl(i,a.add(Ol(r.add(El),18)).add(o),n),l=Al(e,16).mul(n),u=Al(e,24),d=i.add(Al(e,t-32)).mul(n),h=c.add(Al(e,t-24)).mul(n);return Dl(Ol(l.add(u),43).add(Ol(d,30)).add(h),l.add(Ol(u.add(a),18)).add(d),n)}(e,t);let a=n,r=n.mul(Tl).add(113),o=Rl(r.mul(El).add(113)).mul(El),s=[Sl.UZERO,Sl.UZERO],i=[Sl.UZERO,Sl.UZERO];a=a.mul(El).add(Al(e,0));let c=0;const l=64*(t-1>>6),u=l+(t-1&63)-63;do{a=Ol(a.add(r).add(s[0]).add(Al(e,c+8)),37).mul(Tl),r=Ol(r.add(s[1]).add(Al(e,c+48)),42).mul(Tl),a=a.xor(i[1]),r=r.add(s[0]).add(Al(e,c+40)),o=Ol(o.add(i[0]),33).mul(Tl),s=Ml(e,c,s[1].mul(Tl),a.add(i[0])),i=Ml(e,c+32,o.add(i[1]),r.add(Al(e,c+16))),[o,a]=[a,o],c+=64}while(c!==l);const d=Tl.add(o.and(255).shl(1));return c=u,i[0]=i[0].add(t-1&63),s[0]=s[0].add(i[0]),i[0]=i[0].add(s[0]),a=Ol(a.add(r).add(s[0]).add(Al(e,c+8)),37).mul(d),r=Ol(r.add(s[1]).add(Al(e,c+48)),42).mul(d),a=a.xor(i[1].mul(9)),r=r.add(s[0].mul(9).add(Al(e,c+40))),o=Ol(o.add(i[0]),33).mul(d),s=Ml(e,c,s[1].mul(d),a.add(i[0])),i=Ml(e,c+32,o.add(i[1]),r.add(Al(e,c+16))),[o,a]=[a,o],Dl(Dl(s[0],i[0],d).add(Rl(r).mul(Cl)).add(o),Dl(s[1],i[1],d).add(a),d)}function Pl(e,t){return"string"===t?Wl(e):zl([e],t)}function zl(e,t){if("string"===t)throw new Error("Cannot convert a string[] to a TypedArray");if(Array.isArray(e)&&(e=Gl(e)),Yo().getBool("DEBUG")&&function(e,t){for(let n=0;n<e.length;n++){const a=e[n];if(isNaN(a)||!isFinite(a))throw Error("A tensor of type ".concat(t," being uploaded contains ").concat(a,"."))}}(e,t),function(e,t){return e instanceof Float32Array&&"float32"===t||e instanceof Int32Array&&"int32"===t||e instanceof Uint8Array&&"bool"===t}(e,t))return e;if(null==t||"float32"===t||"complex64"===t)return new Float32Array(e);if("int32"===t)return new Int32Array(e);if("bool"===t){const t=new Uint8Array(e.length);for(let n=0;n<t.length;++n)0!==Math.round(e[n])&&(t[n]=1);return t}throw new Error("Unknown data type ".concat(t))}function Bl(){return Yo().platform.now()}function Wl(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"utf-8";return t=t||"utf-8",Yo().platform.encode(e,t)}function Vl(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"utf-8";return t=t||"utf-8",Yo().platform.decode(e,t)}function Ul(e){return null!=Yo().platform.isTypedArray?Yo().platform.isTypedArray(e):wl(e)}function Gl(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[],n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];if(null==t&&(t=[]),"boolean"===typeof e||"number"===typeof e||"string"===typeof e||jo(e)||null==e||Ul(e)&&n)t.push(e);else if(Array.isArray(e)||Ul(e))for(let a=0;a<e.length;++a)Gl(e[a],t,n);else{let a=-1;for(const t of Object.keys(e))/^([1-9]+[0-9]*|0)$/.test(t)&&(a=Math.max(a,Number(t)));for(let r=0;r<=a;r++)Gl(e[r],t,n)}return t}class Hl{constructor(e,t){this.backendTimer=e,this.logger=t,null==t&&(this.logger=new Kl)}profileKernel(e,t,n){let a;const r=()=>{a=n()};let o;const s=Bl();if(this.backendTimer.timerAvailable())o=this.backendTimer.time(r);else{r();for(const e of a)e.dataSync();o=Promise.resolve({kernelMs:Bl()-s})}if(Yo().getBool("CHECK_COMPUTATION_FOR_ERRORS"))for(let i=0;i<a.length;i++){const t=a[i];t.data().then((n=>{jl(n,t.dtype,e)}))}return{kernelName:e,outputs:a,inputs:t,timeMs:o.then((e=>e.kernelMs)),extraInfo:o.then((e=>null!=e.getExtraProfileInfo?e.getExtraProfileInfo():""))}}logKernelProfile(e){const{kernelName:t,outputs:n,timeMs:a,inputs:r,extraInfo:o}=e;n.forEach((e=>{Promise.all([e.data(),a,o]).then((n=>{this.logger.logKernelProfile(t,e,n[0],n[1],r,n[2])}))}))}}function jl(e,t,n){if("float32"!==t)return!1;for(let a=0;a<e.length;a++){const t=e[a];if(isNaN(t)||!isFinite(t))return console.warn("Found ".concat(t," in the result of '").concat(n,"'")),!0}return!1}class Kl{logKernelProfile(e,t,n,a,r,o){const s="number"===typeof a?ko("".concat(a,"ms"),9):a.error,i=ko(e,25),c=t.rank,l=t.size,u=ko(t.shape.toString(),14);let d="";for(const h in r){const e=r[h];if(null!=e){const n=e.shape||t.shape,a=n.length;d+="".concat(h,": ").concat(a,"D ").concat(a>0?n:""," ")}}console.log("%c".concat(i,"\t%c").concat(s,"\t%c").concat(c,"D ").concat(u,"\t%c").concat(l,"\t%c").concat(d,"\t%c").concat(o),"font-weight:bold","color:red","color:blue","color: orange","color: green","color: steelblue")}}const ql=20,Xl=3,Yl=7;function Ql(e,t,n,a){const r=Lo(t),o=function(e,t,n,a){const r=yo(t),o=a[a.length-1],s=new Array(o).fill(0),i=t.length,c="complex64"===n?eu(e):e;if(i>1)for(let l=0;l<r/o;l++){const e=l*o;for(let t=0;t<o;t++)s[t]=Math.max(s[t],Jl(c[e+t],0,n).length)}return s}(e,t,n,r),s=t.length,i=$l(e,t,n,r,o),c=["Tensor"];return a&&(c.push("  dtype: ".concat(n)),c.push("  rank: ".concat(s)),c.push("  shape: [".concat(t,"]")),c.push("  values:")),c.push(i.map((e=>"    "+e)).join("\n")),c.join("\n")}function Jl(e,t,n){let a;return a=Array.isArray(e)?"".concat(parseFloat(e[0].toFixed(Yl))," + ")+"".concat(parseFloat(e[1].toFixed(Yl)),"j"):Ao(e)?"'".concat(e,"'"):"bool"===n?Zl(e):parseFloat(e.toFixed(Yl)).toString(),ko(a,t)}function Zl(e){return 0===e?"false":"true"}function $l(e,t,n,a,r){let o=!(arguments.length>5&&void 0!==arguments[5])||arguments[5];const s="complex64"===n?2:1,i=t[0],c=t.length;if(0===c){if("complex64"===n){return[Jl(eu(e)[0],0,n)]}return"bool"===n?[Zl(e[0])]:[e[0].toString()]}if(1===c){if(i>ql){const t=Xl*s;let a=Array.from(e.slice(0,t)),o=Array.from(e.slice((i-Xl)*s,i*s));return"complex64"===n&&(a=eu(a),o=eu(o)),["["+a.map(((e,t)=>Jl(e,r[t],n))).join(", ")+", ..., "+o.map(((e,t)=>Jl(e,r[i-Xl+t],n))).join(", ")+"]"]}return["["+("complex64"===n?eu(e):Array.from(e)).map(((e,t)=>Jl(e,r[t],n))).join(", ")+"]"]}const l=t.slice(1),u=a.slice(1),d=a[0]*s,h=[];if(i>ql){for(let t=0;t<Xl;t++){const a=t*d,o=a+d;h.push(...$l(e.slice(a,o),l,n,u,r,!1))}h.push("...");for(let t=i-Xl;t<i;t++){const a=t*d,o=a+d;h.push(...$l(e.slice(a,o),l,n,u,r,t===i-1))}}else for(let m=0;m<i;m++){const t=m*d,a=t+d;h.push(...$l(e.slice(t,a),l,n,u,r,m===i-1))}const p=2===c?",":"";h[0]="["+(i>0?h[0]+p:"");for(let m=1;m<h.length-1;m++)h[m]=" "+h[m]+p;let f=",\n";for(let m=2;m<c;m++)f+="\n";return h[h.length-1]=" "+h[h.length-1]+"]"+(o?"":f),h}function eu(e){const t=[];for(let n=0;n<e.length;n+=2)t.push([e[n],e[n+1]]);return t}class tu{constructor(e,t,n){if(this.dtype=t,this.shape=e.slice(),this.size=yo(e),null!=n){const e=n.length;mo(e===this.size,(()=>"Length of values '".concat(e,"' does not match the size ")+"inferred by the shape '".concat(this.size,"'.")))}if("complex64"===t)throw new Error("complex64 dtype TensorBuffers are not supported. Please create a TensorBuffer for the real and imaginary parts separately and call tf.complex(real, imag).");this.values=n||Eo(t,this.size),this.strides=Lo(e)}set(e){for(var t=arguments.length,n=new Array(t>1?t-1:0),a=1;a<t;a++)n[a-1]=arguments[a];0===n.length&&(n=[0]),mo(n.length===this.rank,(()=>"The number of provided coordinates (".concat(n.length,") must ")+"match the rank (".concat(this.rank,")")));const r=this.locToIndex(n);this.values[r]=e}get(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];0===t.length&&(t=[0]);let a=0;for(const o of t){if(o<0||o>=this.shape[a]){const e="Requested out of range element at ".concat(t,". ")+"  Buffer shape=".concat(this.shape);throw new Error(e)}a++}let r=t[t.length-1];for(let o=0;o<t.length-1;++o)r+=this.strides[o]*t[o];return this.values[r]}locToIndex(e){if(0===this.rank)return 0;if(1===this.rank)return e[0];let t=e[e.length-1];for(let n=0;n<e.length-1;++n)t+=this.strides[n]*e[n];return t}indexToLoc(e){if(0===this.rank)return[];if(1===this.rank)return[e];const t=new Array(this.shape.length);for(let n=0;n<t.length-1;++n)t[n]=Math.floor(e/this.strides[n]),e-=t[n]*this.strides[n];return t[t.length-1]=e,t}get rank(){return this.shape.length}toTensor(){return nu().makeTensor(this.values,this.shape,this.dtype)}}let nu=null,au=null,ru=null;class ou{constructor(e,t,n,a){this.kept=!1,this.isDisposedInternal=!1,this.shape=e.slice(),this.dtype=t||"float32",this.size=yo(e),this.strides=Lo(e),this.dataId=n,this.id=a,this.rankType=this.rank<5?this.rank.toString():"higher"}get rank(){return this.shape.length}async buffer(){const e=await this.data();return au.buffer(this.shape,this.dtype,e)}bufferSync(){return au.buffer(this.shape,this.dtype,this.dataSync())}async array(){const e=await this.data();return zo(this.shape,e,"complex64"===this.dtype)}arraySync(){return zo(this.shape,this.dataSync(),"complex64"===this.dtype)}async data(){this.throwIfDisposed();const e=nu().read(this.dataId);if("string"===this.dtype){const n=await e;try{return n.map((e=>Vl(e)))}catch(t){throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}}return e}dataToGPU(e){return this.throwIfDisposed(),nu().readToGPU(this.dataId,e)}dataSync(){this.throwIfDisposed();const e=nu().readSync(this.dataId);if("string"===this.dtype)try{return e.map((e=>Vl(e)))}catch(t){throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}return e}async bytes(){this.throwIfDisposed();const e=await nu().read(this.dataId);return"string"===this.dtype?e:new Uint8Array(e.buffer)}dispose(){this.isDisposed||(this.kerasMask&&this.kerasMask.dispose(),nu().disposeTensor(this),this.isDisposedInternal=!0)}get isDisposed(){return this.isDisposedInternal}throwIfDisposed(){if(this.isDisposed)throw new Error("Tensor is disposed.")}print(){let e=arguments.length>0&&void 0!==arguments[0]&&arguments[0];return au.print(this,e)}clone(){return this.throwIfDisposed(),au.clone(this)}toString(){let e=arguments.length>0&&void 0!==arguments[0]&&arguments[0];return Ql(this.dataSync(),this.shape,this.dtype,e)}cast(e){return this.throwIfDisposed(),au.cast(this,e)}variable(){let e=!(arguments.length>0&&void 0!==arguments[0])||arguments[0],t=arguments.length>1?arguments[1]:void 0,n=arguments.length>2?arguments[2]:void 0;return this.throwIfDisposed(),nu().makeVariable(this,e,t,n)}}function su(){return $o("Tensor",(()=>ou))}Object.defineProperty(ou,Symbol.hasInstance,{value:e=>!!e&&null!=e.data&&null!=e.dataSync&&null!=e.throwIfDisposed}),su();class iu extends ou{constructor(e,t,n,a){super(e.shape,e.dtype,e.dataId,a),this.trainable=t,this.name=n}assign(e){if(e.dtype!==this.dtype)throw new Error("dtype of the new value (".concat(e.dtype,") and ")+"previous value (".concat(this.dtype,") must match"));if(!xo(e.shape,this.shape))throw new Error("shape of the new value (".concat(e.shape,") and ")+"previous value (".concat(this.shape,") must match"));nu().disposeTensor(this),this.dataId=e.dataId,nu().incRef(this,null)}dispose(){nu().disposeVariable(this),this.isDisposedInternal=!0}}var cu,lu,uu,du,hu;Object.defineProperty(iu,Symbol.hasInstance,{value:e=>e instanceof ou&&null!=e.assign&&e.assign instanceof Function}),function(e){e.R0="R0",e.R1="R1",e.R2="R2",e.R3="R3",e.R4="R4",e.R5="R5",e.R6="R6"}(cu||(cu={})),function(e){e.float32="float32",e.int32="int32",e.bool="int32",e.complex64="complex64"}(lu||(lu={})),function(e){e.float32="float32",e.int32="int32",e.bool="bool",e.complex64="complex64"}(uu||(uu={})),function(e){e.float32="float32",e.int32="float32",e.bool="float32",e.complex64="complex64"}(du||(du={})),function(e){e.float32="complex64",e.int32="complex64",e.bool="complex64",e.complex64="complex64"}(hu||(hu={}));const pu={float32:du,int32:lu,bool:uu,complex64:hu};function fu(e,t){if("string"===e||"string"===t){if("string"===e&&"string"===t)return"string";throw new Error("Can not upcast ".concat(e," with ").concat(t))}return pu[e][t]}function mu(e){return fu(e,"int32")}function gu(e){return null!=e&&"object"===typeof e&&"texture"in e&&e.texture instanceof WebGLTexture}function bu(e){return"undefined"!==typeof GPUBuffer&&null!=e&&"object"===typeof e&&"buffer"in e&&e.buffer instanceof GPUBuffer}function yu(e,t){if(e.dtype===t.dtype)return[e,t];const n=fu(e.dtype,t.dtype);return[e.cast(n),t.cast(n)]}function xu(e,t){return t.some((t=>t.id===e.id))}function vu(e){const t=[];return wu(e,t,new Set),t}function wu(e,t,n){if(null==e)return;if(e instanceof ou)return void t.push(e);if(a=e,!Array.isArray(a)&&"object"!==typeof a)return;var a;const r=e;for(const o in r){const e=r[o];n.has(e)||(n.add(e),wu(e,t,n))}}function ku(e){return null!=e.kernelName}class Iu{constructor(){this.registeredVariables={},this.nextTapeNodeId=0,this.numBytes=0,this.numTensors=0,this.numStringTensors=0,this.numDataBuffers=0,this.gradientDepth=0,this.kernelDepth=0,this.scopeStack=[],this.numDataMovesStack=[],this.nextScopeId=0,this.tensorInfo=new WeakMap,this.profiling=!1,this.activeProfile={newBytes:0,newTensors:0,peakBytes:0,kernels:[],result:null,get kernelNames(){return Array.from(new Set(this.kernels.map((e=>e.name))))}}}dispose(){for(const e in this.registeredVariables)this.registeredVariables[e].dispose()}}class Su{constructor(e){this.ENV=e,this.registry={},this.registryFactory={},this.pendingBackendInitId=0,this.state=new Iu}async ready(){if(null!=this.pendingBackendInit)return this.pendingBackendInit.then((()=>{}));if(null!=this.backendInstance)return;const e=this.getSortedBackends();for(let t=0;t<e.length;t++){const n=e[t];if(await this.initializeBackend(n).success)return void await this.setBackend(n)}throw new Error("Could not initialize any backends, all backend initializations failed.")}get backend(){if(null!=this.pendingBackendInit)throw new Error("Backend '".concat(this.backendName,"' has not yet been initialized. Make ")+"sure to await tf.ready() or await tf.setBackend() before calling other methods");if(null==this.backendInstance){const{name:e,asyncInit:t}=this.initializeBackendsAndReturnBest();if(t)throw new Error("The highest priority backend '".concat(e,"' has not yet been ")+"initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods");this.setBackend(e)}return this.backendInstance}backendNames(){return Object.keys(this.registryFactory)}findBackend(e){if(!(e in this.registry)){if(!(e in this.registryFactory))return null;{const{asyncInit:t}=this.initializeBackend(e);if(t)return null}}return this.registry[e]}findBackendFactory(e){return e in this.registryFactory?this.registryFactory[e].factory:null}registerBackend(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1;return e in this.registryFactory?(dl("".concat(e," backend was already registered. ")+"Reusing existing backend factory."),!1):(this.registryFactory[e]={factory:t,priority:n},!0)}async setBackend(e){if(null==this.registryFactory[e])throw new Error("Backend name '".concat(e,"' not found in registry"));if(this.backendName=e,null==this.registry[e]){this.backendInstance=null;const{success:t,asyncInit:n}=this.initializeBackend(e);if(!(n?await t:t))return!1}return this.backendInstance=this.registry[e],this.setupRegisteredKernels(),this.profiler=new Hl(this.backendInstance),!0}setupRegisteredKernels(){bl(this.backendName).forEach((e=>{null!=e.setupFunc&&e.setupFunc(this.backendInstance)}))}disposeRegisteredKernels(e){bl(e).forEach((t=>{null!=t.disposeFunc&&t.disposeFunc(this.registry[e])}))}initializeBackend(e){const t=this.registryFactory[e];if(null==t)throw new Error("Cannot initialize backend ".concat(e,", no registration found."));try{const n=t.factory();if(!n||n instanceof co||"function"!==typeof n.then)return this.registry[e]=n,{success:!0,asyncInit:!1};{const t=++this.pendingBackendInitId,a=n.then((n=>!(t<this.pendingBackendInitId)&&(this.registry[e]=n,this.pendingBackendInit=null,!0))).catch((n=>(t<this.pendingBackendInitId||(this.pendingBackendInit=null,dl("Initialization of backend ".concat(e," failed")),dl(n.stack||n.message)),!1)));return this.pendingBackendInit=a,{success:a,asyncInit:!0}}}catch(n){return dl("Initialization of backend ".concat(e," failed")),dl(n.stack||n.message),{success:!1,asyncInit:!1}}}removeBackend(e){if(!(e in this.registryFactory))throw new Error("".concat(e," backend not found in registry"));this.backendName===e&&null!=this.pendingBackendInit&&this.pendingBackendInitId++,e in this.registry&&(this.disposeRegisteredKernels(e),this.registry[e].dispose(),delete this.registry[e]),delete this.registryFactory[e],this.backendName===e&&(this.pendingBackendInit=null,this.backendName=null,this.backendInstance=null)}getSortedBackends(){if(0===Object.keys(this.registryFactory).length)throw new Error("No backend found in registry.");return Object.keys(this.registryFactory).sort(((e,t)=>this.registryFactory[t].priority-this.registryFactory[e].priority))}initializeBackendsAndReturnBest(){const e=this.getSortedBackends();for(let t=0;t<e.length;t++){const n=e[t],{success:a,asyncInit:r}=this.initializeBackend(n);if(r||a)return{name:n,asyncInit:r}}throw new Error("Could not initialize any backends, all backend initializations failed.")}moveData(e,t){const n=this.state.tensorInfo.get(t),a=n.backend,r=this.readSync(t),o=a.refCount(t);a.disposeData(t,!0),n.backend=e,e.move(t,r,n.shape,n.dtype,o),this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack[this.state.numDataMovesStack.length-1]++}tidy(e,t){let n,a=null;if(null==t){if("function"!==typeof e)throw new Error("Please provide a function to tidy()");t=e}else{if("string"!==typeof e&&!(e instanceof String))throw new Error("When calling with two arguments, the first argument to tidy() must be a string");if("function"!==typeof t)throw new Error("When calling with two arguments, the 2nd argument to tidy() must be a function");a=e}return this.scopedRun((()=>this.startScope(a)),(()=>this.endScope(n)),(()=>(n=t(),n instanceof Promise&&console.error("Cannot return a Promise inside of tidy."),n)))}scopedRun(e,t,n){e();try{const e=n();return t(),e}catch(a){throw t(),a}}nextTensorId(){return Su.nextTensorId++}nextVariableId(){return Su.nextVariableId++}clone(e){const t=Cu.runKernel(mi,{x:e}),n={x:e};return this.addTapeNode(this.state.activeScope.name,n,[t],(e=>({x:()=>{const t={x:e},n={dtype:"float32"};return Cu.runKernel(Is,t,n)}})),[],{}),t}runKernel(e,t,n){null==this.backendName&&this.backend;if(!(null!=ml(e,this.backendName)))throw new Error("Kernel '".concat(e,"' not registered for backend '").concat(this.backendName,"'"));return this.runKernelFunc({kernelName:e,inputs:t,attrs:n})}shouldCheckForMemLeaks(){return this.ENV.getBool("IS_TEST")}checkKernelForMemLeak(e,t,n){const a=this.backend.numDataIds();let r=0;n.forEach((e=>{r+="complex64"===e.dtype?3:1}));const o=this.state.numDataMovesStack[this.state.numDataMovesStack.length-1],s=a-t-r-o;if(s>0)throw new Error("Backend '".concat(this.backendName,"' has an internal memory leak ")+"(".concat(s," data ids) after running '").concat(e,"'"))}runKernelFunc(e){let t,n=[];const a=this.isTapeOn(),r=this.state.numBytes,o=this.state.numTensors;let s,i;this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack.push(0),null==this.backendName&&this.backend;const c=ku(e)?e.kernelName:null!=this.state.activeScope?this.state.activeScope.name:"";if(ku(e)){const{kernelName:t,inputs:r,attrs:o}=e;null==this.backendName&&this.backend;const c=ml(t,this.backendName);mo(null!=c,(()=>"Cannot find registered kernel '".concat(t,"' for backend '").concat(this.backendName,"'"))),s=()=>{const e=this.backend.numDataIds();i=c.kernelFunc({inputs:r,attrs:o,backend:this.backend});const s=Array.isArray(i)?i:[i];this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(t,e,s);const l=s.map((e=>null!=e.rank?e:this.makeTensorFromTensorInfo(e)));if(a){const e=this.getTensorsForGradient(t,r,l);n=this.saveTensorsForBackwardMode(e)}return l}}else{const{forwardFunc:t}=e,r=e=>{a&&(n=e.map((e=>this.keep(this.clone(e)))))};s=()=>{const e=this.backend.numDataIds();i=this.tidy((()=>t(this.backend,r)));const n=Array.isArray(i)?i:[i];return this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(c,e,n),n}}const{inputs:l,attrs:u}=e,d=ku(e)?null:e.backwardsFunc;let h;return this.scopedRun((()=>this.state.kernelDepth++),(()=>this.state.kernelDepth--),(()=>{this.ENV.getBool("DEBUG")||this.state.profiling?(h=this.profiler.profileKernel(c,l,(()=>s())),this.ENV.getBool("DEBUG")&&this.profiler.logKernelProfile(h),t=h.outputs):t=s()})),a&&this.addTapeNode(c,l,t,d,n,u),this.state.profiling&&this.state.activeProfile.kernels.push({name:c,bytesAdded:this.state.numBytes-r,totalBytesSnapshot:this.state.numBytes,tensorsAdded:this.state.numTensors-o,totalTensorsSnapshot:this.state.numTensors,inputShapes:Object.keys(l).map((e=>null!=l[e]?l[e].shape:null)),outputShapes:t.map((e=>e.shape)),kernelTimeMs:h.timeMs,extraInfo:h.extraInfo}),Array.isArray(i)?t:t[0]}saveTensorsForBackwardMode(e){return e.map((e=>this.keep(this.clone(e))))}getTensorsForGradient(e,t,n){const a=gl(e);if(null!=a){const e=a.inputsToSave||[],r=a.outputsToSave||[];let o;a.saveAllInputs?(mo(Array.isArray(t),(()=>"saveAllInputs is true, expected inputs to be an array.")),o=Object.keys(t).map((e=>t[e]))):o=e.map((e=>t[e]));const s=n.filter(((e,t)=>r[t]));return o.concat(s)}return[]}makeTensor(e,t,n,a){if(null==e)throw new Error("Values passed to engine.makeTensor() are null");n=n||"float32",a=a||this.backend;let r=e;"string"===n&&Ao(e[0])&&(r=e.map((e=>Wl(e))));const o=a.write(r,t,n),s=new ou(t,n,o,this.nextTensorId());if(this.trackTensor(s,a),"string"===n){const e=this.state.tensorInfo.get(o),t=function(e){if(null==e)return 0;let t=0;return e.forEach((e=>t+=e.length)),t}(r);this.state.numBytes+=t-e.bytes,e.bytes=t}return s}makeTensorFromDataId(e,t,n,a){const r={dataId:e,shape:t,dtype:n=n||"float32"};return this.makeTensorFromTensorInfo(r,a)}makeTensorFromTensorInfo(e,t){const{dataId:n,shape:a,dtype:r}=e,o=new ou(a,r,n,this.nextTensorId());return this.trackTensor(o,t),o}makeVariable(e){let t=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],n=arguments.length>2?arguments[2]:void 0,a=arguments.length>3?arguments[3]:void 0;n=n||this.nextVariableId().toString(),null!=a&&a!==e.dtype&&(e=e.cast(a));const r=new iu(e,t,n,this.nextTensorId());if(null!=this.state.registeredVariables[r.name])throw new Error("Variable with name ".concat(r.name," was already registered"));return this.state.registeredVariables[r.name]=r,this.incRef(r,this.backend),r}trackTensor(e,t){this.state.numTensors++,"string"===e.dtype&&this.state.numStringTensors++;let n=0;"complex64"!==e.dtype&&"string"!==e.dtype&&(n=e.size*_o(e.dtype)),this.state.numBytes+=n,this.state.tensorInfo.has(e.dataId)||(this.state.numDataBuffers++,this.state.tensorInfo.set(e.dataId,{backend:t||this.backend,dtype:e.dtype,shape:e.shape,bytes:n})),e instanceof iu||this.track(e)}incRef(e,t){this.trackTensor(e,t),this.backend.incRef(e.dataId)}removeDataId(e,t){this.state.tensorInfo.has(e)&&this.state.tensorInfo.get(e).backend===t&&(this.state.tensorInfo.delete(e),this.state.numDataBuffers--)}disposeTensor(e){if(!this.state.tensorInfo.has(e.dataId))return;const t=this.state.tensorInfo.get(e.dataId);if(this.state.numTensors--,"string"===e.dtype&&(this.state.numStringTensors--,this.state.numBytes-=t.bytes),"complex64"!==e.dtype&&"string"!==e.dtype){const t=e.size*_o(e.dtype);this.state.numBytes-=t}t.backend.disposeData(e.dataId)&&this.removeDataId(e.dataId,t.backend)}disposeVariables(){for(const e in this.state.registeredVariables){const t=this.state.registeredVariables[e];this.disposeVariable(t)}}disposeVariable(e){this.disposeTensor(e),null!=this.state.registeredVariables[e.name]&&delete this.state.registeredVariables[e.name]}memory(){const e=this.backend.memory();return e.numTensors=this.state.numTensors,e.numDataBuffers=this.state.numDataBuffers,e.numBytes=this.state.numBytes,this.state.numStringTensors>0&&(e.unreliable=!0,null==e.reasons&&(e.reasons=[]),e.reasons.push("Memory usage by string tensors is approximate (2 bytes per character)")),e}async profile(e){this.state.profiling=!0;const t=this.state.numBytes,n=this.state.numTensors;this.state.activeProfile.kernels=[],this.state.activeProfile.result=await e(),this.state.profiling=!1,this.state.activeProfile.peakBytes=Math.max(...this.state.activeProfile.kernels.map((e=>e.totalBytesSnapshot))),this.state.activeProfile.newBytes=this.state.numBytes-t,this.state.activeProfile.newTensors=this.state.numTensors-n;for(const a of this.state.activeProfile.kernels)a.kernelTimeMs=await a.kernelTimeMs,a.extraInfo=await a.extraInfo;return this.state.activeProfile}isTapeOn(){return this.state.gradientDepth>0&&0===this.state.kernelDepth}addTapeNode(e,t,n,a,r,o){const s={id:this.state.nextTapeNodeId++,kernelName:e,inputs:t,outputs:n,saved:r},i=gl(e);null!=i&&(a=i.gradFunc),null!=a&&(s.gradient=e=>(e=e.map(((e,t)=>{if(null==e){const e=n[t],a=Wo(e.size,e.dtype);return this.makeTensor(a,e.shape,e.dtype)}return e})),a(e.length>1?e:e[0],r,o))),this.state.activeTape.push(s)}keep(e){return e.kept=!0,e}startTape(){0===this.state.gradientDepth&&(this.state.activeTape=[]),this.state.gradientDepth++}endTape(){this.state.gradientDepth--}startScope(e){const t={track:[],name:"unnamed scope",id:this.state.nextScopeId++};e&&(t.name=e),this.state.scopeStack.push(t),this.state.activeScope=t}endScope(e){const t=vu(e),n=new Set(t.map((e=>e.id)));for(let r=0;r<this.state.activeScope.track.length;r++){const e=this.state.activeScope.track[r];e.kept||n.has(e.id)||e.dispose()}const a=this.state.scopeStack.pop();this.state.activeScope=0===this.state.scopeStack.length?null:this.state.scopeStack[this.state.scopeStack.length-1],t.forEach((e=>{e.kept||e.scopeId!==a.id||this.track(e)}))}gradients(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]&&arguments[3];if(mo(t.length>0,(()=>"gradients() received an empty list of xs.")),null!=n&&"float32"!==n.dtype)throw new Error("dy must have 'float32' dtype, but has '".concat(n.dtype,"'"));const r=this.scopedRun((()=>this.startTape()),(()=>this.endTape()),(()=>this.tidy("forward",e)));mo(r instanceof ou,(()=>"The result y returned by f() must be a tensor."));const o=function(e,t,n){const a={},r={};for(let c=0;c<t.length;c++)a[t[c].id]=!0;for(let c=0;c<e.length;c++){const n=e[c],o=n.inputs;for(const e in o){const s=o[e];let i=!1;for(let e=0;e<t.length;e++)if(a[s.id]){n.outputs.forEach((e=>a[e.id]=!0)),i=!0,r[n.id]=!0;break}if(i)break}}const o={};o[n.id]=!0;const s={};for(let c=e.length-1;c>=0;c--){const t=e[c],n=t.inputs;for(let e=0;e<t.outputs.length;e++)if(o[t.outputs[e].id]){for(const e in n)o[n[e].id]=!0,s[t.id]=!0;break}}const i=[];for(let c=0;c<e.length;c++){const t=e[c];if(r[t.id]&&s[t.id]){const e={};for(const r in t.inputs){const n=t.inputs[r];a[n.id]&&(e[r]=n)}const n=Object.assign({},t);n.inputs=e,n.outputs=t.outputs,i.push(n)}}return i}(this.state.activeTape,t,r);if(!a&&0===o.length&&t.length>0)throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that the f you passed encloses all operations that lead from x to y.");return this.tidy("backward",(()=>{const e={};e[r.id]=null==n?function(e){const t=Bo(yo(e),"float32");return Cu.makeTensor(t,e,"float32")}(r.shape):n,function(e,t,n,a){for(let r=t.length-1;r>=0;r--){const o=t[r],s=[];if(o.outputs.forEach((t=>{const n=e[t.id];null!=n?s.push(n):s.push(null)})),null==o.gradient)throw new Error("Cannot compute gradient: gradient function not found "+"for ".concat(o.kernelName,"."));const i=o.gradient(s);for(const t in o.inputs){if(!(t in i))throw new Error("Cannot backprop through input ".concat(t,". ")+"Available gradients found: ".concat(Object.keys(i),"."));const r=n((()=>i[t]()));if("float32"!==r.dtype)throw new Error("Error in gradient for op ".concat(o.kernelName,". The gradient of input ")+"".concat(t," must have 'float32' dtype, but has '").concat(r.dtype,"'"));const s=o.inputs[t];if(!xo(r.shape,s.shape))throw new Error("Error in gradient for op ".concat(o.kernelName,". The gradient of input ")+"'".concat(t,"' has shape '").concat(r.shape,"', which does not match ")+"the shape of the input '".concat(s.shape,"'"));if(null==e[s.id])e[s.id]=r;else{const t=e[s.id];e[s.id]=a(t,r),t.dispose()}}}}(e,o,(e=>this.tidy(e)),Tu);const a=t.map((t=>e[t.id]));return 0===this.state.gradientDepth&&(this.state.activeTape.forEach((e=>{for(const t of e.saved)t.dispose()})),this.state.activeTape=null),{value:r,grads:a}}))}customGrad(e){var t=this;return mo(Do(e),(()=>"The f passed in customGrad(f) must be a function.")),function(){for(var n=arguments.length,a=new Array(n),r=0;r<n;r++)a[r]=arguments[r];let o;mo(a.every((e=>e instanceof ou)),(()=>"The args passed in customGrad(f)(x1, x2,...) must all be tensors"));const s={};a.forEach(((e,t)=>{s[t]=e}));return t.runKernelFunc({forwardFunc:(t,n)=>(o=e(...a,n),mo(o.value instanceof ou,(()=>"The function f passed in customGrad(f) must return an object where `obj.value` is a tensor")),mo(Do(o.gradFunc),(()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function.")),o.value),backwardsFunc:(e,t)=>{const n=o.gradFunc(e,t),r=Array.isArray(n)?n:[n];mo(r.length===a.length,(()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns the same number of tensors as inputs passed to f(...).")),mo(r.every((e=>e instanceof ou)),(()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns a list of only tensors."));const s={};return r.forEach(((e,t)=>{s[t]=()=>e})),s},inputs:s})}}readSync(e){return this.state.tensorInfo.get(e).backend.readSync(e)}read(e){return this.state.tensorInfo.get(e).backend.read(e)}readToGPU(e,t){return this.state.tensorInfo.get(e).backend.readToGPU(e,t)}async time(e){const t=Bl(),n=await this.backend.time(e);return n.wallMs=Bl()-t,n}track(e){return null!=this.state.activeScope&&(e.scopeId=this.state.activeScope.id,this.state.activeScope.track.push(e)),e}get registeredVariables(){return this.state.registeredVariables}reset(){this.pendingBackendInitId++,this.state.dispose(),this.ENV.reset(),this.state=new Iu;for(const e in this.registry)this.disposeRegisteredKernels(e),this.registry[e].dispose(),delete this.registry[e];this.backendName=null,this.backendInstance=null,this.pendingBackendInit=null}}function Nu(){const e=Zo();if(null==e._tfengine){const t=new qo(e);e._tfengine=new Su(t)}var t;return t=e._tfengine.ENV,Jo=t,function(e){nu=e}((()=>e._tfengine)),e._tfengine}Su.nextTensorId=0,Su.nextVariableId=0;const Cu=Nu();function Tu(e,t){const n={a:e,b:t};return Cu.runKernel(as,n)}let Eu;function Ru(e){if(void 0!==Eu)return Eu;if(e||"undefined"!==typeof navigator&&null!=navigator){if(e||(e=navigator),"ReactNative"===e.product)return!0;const t=e.userAgent||e.vendor||("undefined"!==typeof window?window.opera:"");if(!t){const t=e;return t.userAgentData&&t.userAgentData.mobile}return/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(t)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(t.substr(0,4))}return!1}function _u(){return"undefined"!==typeof window&&null!=window.document||"undefined"!==typeof WorkerGlobalScope}const Au=Yo();function Fu(e,t){let n=e;if(Ul(e))return"string"===t?[]:[e.length];if(gu(e)){const t=e.channels||"RGBA";return[e.height,e.width*t.length]}if(bu(e))return[e.buffer.size/(null==t?4:_o(t))];if(!Array.isArray(e))return[];const a=[];for(;Array.isArray(n)||Ul(n)&&"string"!==t;)a.push(n.length),n=n[0];return Array.isArray(e)&&Yo().getBool("TENSORLIKE_CHECK_SHAPE_CONSISTENCY")&&Ou(e,a,[]),a}function Ou(e,t,n){if(n=n||[],!Array.isArray(e)&&!Ul(e))return void mo(0===t.length,(()=>"Element arr[".concat(n.join("]["),"] is a primitive, ")+"but should be an array/TypedArray of ".concat(t[0]," elements")));mo(t.length>0,(()=>"Element arr[".concat(n.join("]["),"] should be a primitive, ")+"but is an array of ".concat(e.length," elements"))),mo(e.length===t[0],(()=>"Element arr[".concat(n.join("]["),"] should have ").concat(t[0]," ")+"elements, but has ".concat(e.length," elements")));const a=t.slice(1);for(let r=0;r<e.length;++r)Ou(e[r],a,n.concat(r))}function Du(e,t,n,a){if("string_or_numeric"!==e){if(null==e)throw new Error("Expected dtype cannot be null.");if("numeric"!==e&&e!==t||"numeric"===e&&"string"===t)throw new Error("Argument '".concat(n,"' passed to '").concat(a,"' must ")+"be ".concat(e," tensor, but got ").concat(t," tensor"))}}function Mu(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"numeric";if(e instanceof su())return Du(a,e.dtype,t,n),e;let r=Oo(e);if("string"!==r&&["bool","int32","float32"].indexOf(a)>=0&&(r=a),Du(a,r,t,n),null==e||!Ul(e)&&!Array.isArray(e)&&"number"!==typeof e&&"boolean"!==typeof e&&"string"!==typeof e){const a=null==e?"null":e.constructor.name;throw new Error("Argument '".concat(t,"' passed to '").concat(n,"' must be a ")+"Tensor or TensorLike, but got '".concat(a,"'"))}const o=Fu(e,r);Ul(e)||Array.isArray(e)||(e=[e]);const s="string"!==r?zl(e,r):Gl(e,[],!0);return Cu.makeTensor(s,o,r)}function Lu(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"numeric";if(!Array.isArray(e))throw new Error("Argument ".concat(t," passed to ").concat(n," must be a ")+"`Tensor[]` or `TensorLike[]`");return e.map(((e,r)=>Mu(e,"".concat(t,"[").concat(r,"]"),n,a)))}Au.registerFlag("DEBUG",(()=>!1),(e=>{e&&console.warn("Debugging mode is ON. The output of every math call will be downloaded to CPU and checked for NaNs. This significantly impacts performance.")})),Au.registerFlag("IS_BROWSER",(()=>_u())),Au.registerFlag("IS_NODE",(()=>"undefined"!==typeof process&&"undefined"!==typeof process.versions&&"undefined"!==typeof process.versions.node)),Au.registerFlag("IS_CHROME",(()=>"undefined"!==typeof navigator&&null!=navigator&&null!=navigator.userAgent&&/Chrome/.test(navigator.userAgent)&&/Google Inc/.test(navigator.vendor))),Au.registerFlag("IS_SAFARI",(()=>"undefined"!==typeof navigator&&null!=navigator&&null!=navigator.userAgent&&/Safari/.test(navigator.userAgent)&&/Apple/.test(navigator.vendor))),Au.registerFlag("PROD",(()=>!1)),Au.registerFlag("TENSORLIKE_CHECK_SHAPE_CONSISTENCY",(()=>Au.getBool("DEBUG"))),Au.registerFlag("DEPRECATION_WARNINGS_ENABLED",(()=>!0)),Au.registerFlag("IS_TEST",(()=>!1)),Au.registerFlag("CHECK_COMPUTATION_FOR_ERRORS",(()=>Au.getBool("DEBUG"))),Au.registerFlag("WRAP_TO_IMAGEBITMAP",(()=>!1)),Au.registerFlag("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU",(()=>!1)),Au.registerFlag("USE_SETTIMEOUTCUSTOM",(()=>!1));function Pu(e){const t=Object.keys(e);if(1!==t.length)throw new Error("Please provide an object with a single key (operation name) mapping to a function. Got an object with "+"".concat(t.length," keys."));let n=t[0];const a=e[n];n.endsWith("_")&&(n=n.substring(0,n.length-1)),n+="__op";const r=function(){Cu.startScope(n);try{const e=a(...arguments);return jo(e)&&console.error("Cannot return a Promise inside of tidy."),Cu.endScope(e),e}catch(e){throw Cu.endScope(null),e}};return Object.defineProperty(r,"name",{value:n,configurable:!0}),r}const zu=Pu({complex_:function(e,t){const n=Mu(e,"real","complex"),a=Mu(t,"imag","complex");go(n.shape,a.shape,"real and imag shapes, ".concat(n.shape," and ").concat(a.shape,", ")+"must match in call to tf.complex().");const r={real:n,imag:a};return Cu.runKernel(Cs,r)}});function Bu(e,t,n,a){if(null==a)a=Oo(e);else if("complex64"===a)throw new Error("Cannot construct a complex64 tensor directly. Please use tf.complex(real, imag).");if(bu(e)||gu(e)){if("float32"!==a&&"int32"!==a)throw new Error("Creating tensor from GPU data only supports "+"'float32'|'int32' dtype, while the dtype is ".concat(a,"."));return Cu.backend.createTensorFromGPUData(e,t||n,a)}if(!Ul(e)&&!Array.isArray(e)&&"number"!==typeof e&&"boolean"!==typeof e&&"string"!==typeof e)throw new Error("values passed to tensor(values) must be a number/boolean/string or an array of numbers/booleans/strings, or a TypedArray");if(null!=t){Uo(t);const e=yo(t),a=yo(n);mo(e===a,(()=>"Based on the provided shape, [".concat(t,"], the tensor should have ")+"".concat(e," values but has ").concat(a)));for(let r=0;r<n.length;++r){const e=n[r],a=r!==n.length-1||e!==yo(t.slice(r));mo(n[r]===t[r]||!a,(()=>"Error creating a new Tensor. Inferred shape "+"(".concat(n,") does not match the provided ")+"shape (".concat(t,"). ")))}}return Ul(e)||Array.isArray(e)||(e=[e]),t=t||n,e="string"!==a?zl(e,a):Gl(e,[],!0),Cu.makeTensor(e,t,a)}function Wu(e,t,n){return Bu(e,t,Fu(e,n),n)}class Vu{static join(e){return new Vu(e).slice()}constructor(e){if(this.shards=[],this.previousShardIndex=0,null==e)return;if(e instanceof Array||(e=[e]),0===(e=e.map((e=>Ul(e)?e.buffer:e))).length)return;this.bufferUniformSize=e[0].byteLength;let t=0;for(let n=0;n<e.length;n++){const a=e[n];n!==e.length-1&&a.byteLength!==this.bufferUniformSize&&(this.bufferUniformSize=void 0);const r=t+a.byteLength;this.shards.push({buffer:a,start:t,end:r}),t=r}0===this.shards.length&&(this.byteLength=0),this.byteLength=this.shards[this.shards.length-1].end}slice(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:this.byteLength;if(0===this.shards.length)return new ArrayBuffer(0);if(e=isNaN(Number(e))?0:e,t=isNaN(Number(t))?0:t,e=Math.max(0,e),t=Math.min(this.byteLength,t),t<=e)return new ArrayBuffer(0);const n=this.findShardForByte(e);if(-1===n)throw new Error("Could not find start shard for byte ".concat(e));const a=new ArrayBuffer(t-e),r=new Uint8Array(a);let o=0;for(let s=n;s<this.shards.length;s++){const n=this.shards[s],a=e+o-n.start,i=o,c=Math.min(t,n.end)-n.start,l=new Uint8Array(n.buffer,a,c-a);if(r.set(l,i),o+=l.length,t<n.end)break}return a}findShardForByte(e){if(0===this.shards.length||e<0||e>=this.byteLength)return-1;if(null!=this.bufferUniformSize)return this.previousShardIndex=Math.floor(e/this.bufferUniformSize),this.previousShardIndex;function t(t){return e<t.start?-1:e>=t.end?1:0}if(0===t(this.shards[this.previousShardIndex]))return this.previousShardIndex;const n=function(e,t){let n=0,a=e.length;for(;n<=a;){const r=Math.floor((a-n)/2)+n,o=t(e[r]);if(0===o)return r;o<0?a=r:n=r+1}return-1}(this.shards,t);return-1===n?-1:(this.previousShardIndex=n,this.previousShardIndex)}}function Uu(){return Cu}function Gu(){return Cu.memory()}function Hu(e,t){return Cu.tidy(e,t)}function ju(e){vu(e).forEach((e=>e.dispose()))}function Ku(e){return Cu.keep(e)}function qu(e){return Cu.setBackend(e)}function Xu(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1;return Cu.registerBackend(e,t,n)}function Yu(){return Cu.backend}!function(e){ru=e}((function(e){Yo().getBool("DEPRECATION_WARNINGS_ENABLED")&&console.warn(e+" You can disable deprecation warnings with tf.disableDeprecationWarnings().")}));const Qu=4;async function Ju(e,t){const n=[],a=[],r=Array.isArray(e)?e.map((e=>e.name)):Object.keys(e);for(let o=0;o<r.length;++o){const s=r[o],i=Array.isArray(e)?e[o].tensor:e[s];if("float32"!==i.dtype&&"int32"!==i.dtype&&"bool"!==i.dtype&&"string"!==i.dtype&&"complex64"!==i.dtype)throw new Error("Unsupported dtype in weight '".concat(s,"': ").concat(i.dtype));const c={name:s,shape:i.shape,dtype:i.dtype};if("string"===i.dtype){const e=new Promise((async e=>{const t=await i.bytes(),n=t.reduce(((e,t)=>e+t.length),0)+Qu*t.length,a=new Uint8Array(n);let r=0;for(let o=0;o<t.length;o++){const e=t[o],n=new Uint8Array(new Uint32Array([e.length]).buffer);a.set(n,r),r+=Qu,a.set(e,r),r+=e.length}e(a)}));a.push(e)}else a.push(i.data());null!=t&&(c.group=t),n.push(c)}return{data:Zu(await Promise.all(a)),specs:n}}function Zu(e){if(null===e)throw new Error("Invalid input value: ".concat(JSON.stringify(e)));let t=0;const n=[];e.forEach((e=>{if(t+=e.byteLength,n.push(e.byteLength===e.buffer.byteLength?e:new e.constructor(e)),!(e instanceof Float32Array||e instanceof Int32Array||e instanceof Uint8Array))throw new Error("Unsupported TypedArray subtype: ".concat(e.constructor.name))}));const a=new Uint8Array(t);let r=0;return n.forEach((e=>{a.set(new Uint8Array(e.buffer),r),r+=e.byteLength})),a.buffer}const $u="undefined"!==typeof Buffer&&("undefined"===typeof Blob||"undefined"===typeof atob||"undefined"===typeof btoa);function ed(e){return $u?Buffer.byteLength(e,"utf8"):new Blob([e]).size}function td(e,t){const n={modelTopology:e.modelTopology,format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy,weightsManifest:t};return null!=e.signature&&(n.signature=e.signature),null!=e.userDefinedMetadata&&(n.userDefinedMetadata=e.userDefinedMetadata),null!=e.modelInitializer&&(n.modelInitializer=e.modelInitializer),null!=e.initializerSignature&&(n.initializerSignature=e.initializerSignature),null!=e.trainingConfig&&(n.trainingConfig=e.trainingConfig),n}async function nd(e,t){let n,a;return null!=e.weightsManifest&&([n,a]=await t(e.weightsManifest)),function(e,t,n){const a={modelTopology:e.modelTopology,format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy};if(null!=e.trainingConfig&&(a.trainingConfig=e.trainingConfig),null!=e.weightsManifest){if(!t)throw new Error("modelJSON has weightsManifest but weightSpecs is null");if(!n)throw new Error("modelJSON has weightsManifest but weightData is null");a.weightSpecs=t,a.weightData=n}return null!=e.signature&&(a.signature=e.signature),null!=e.userDefinedMetadata&&(a.userDefinedMetadata=e.userDefinedMetadata),null!=e.modelInitializer&&(a.modelInitializer=e.modelInitializer),null!=e.initializerSignature&&(a.initializerSignature=e.initializerSignature),a}(e,n,a)}function ad(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("Expected JSON model topology, received ArrayBuffer.");return{dateSaved:new Date,modelTopologyType:"JSON",modelTopologyBytes:null==e.modelTopology?0:ed(JSON.stringify(e.modelTopology)),weightSpecsBytes:null==e.weightSpecs?0:ed(JSON.stringify(e.weightSpecs)),weightDataBytes:null==e.weightData?0:new Vu(e.weightData).byteLength}}function rd(e){const t=[];for(const n of e)t.push(...n.weights);return t}class od{constructor(){this.saveRouters=[],this.loadRouters=[]}static getInstance(){return null==od.instance&&(od.instance=new od),od.instance}static registerSaveRouter(e){od.getInstance().saveRouters.push(e)}static registerLoadRouter(e){od.getInstance().loadRouters.push(e)}static getSaveHandlers(e){return od.getHandlers(e,"save")}static getLoadHandlers(e,t){return od.getHandlers(e,"load",t)}static getHandlers(e,t,n){const a=[];return("load"===t?od.getInstance().loadRouters:od.getInstance().saveRouters).forEach((t=>{const r=t(e,n);null!==r&&a.push(r)})),a}}const sd="tensorflowjs",id="models_store",cd="model_info_store";function ld(){if(!Yo().getBool("IS_BROWSER"))throw new Error("Failed to obtain IndexedDB factory because the current environmentis not a web browser.");const e="undefined"===typeof window?self:window,t=e.indexedDB||e.mozIndexedDB||e.webkitIndexedDB||e.msIndexedDB||e.shimIndexedDB;if(null==t)throw new Error("The current browser does not appear to support IndexedDB.");return t}function ud(e){const t=e.result;t.createObjectStore(id,{keyPath:"modelPath"}),t.createObjectStore(cd,{keyPath:"modelPath"})}class dd{constructor(e){if(this.indexedDB=ld(),null==e||!e)throw new Error("For IndexedDB, modelPath must not be null, undefined or empty.");this.modelPath=e}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");return this.databaseAction(this.modelPath,e)}async load(){return this.databaseAction(this.modelPath)}databaseAction(e,t){return new Promise(((e,n)=>{const a=this.indexedDB.open(sd,1);a.onupgradeneeded=()=>ud(a),a.onsuccess=()=>{const r=a.result;if(null==t){const t=r.transaction(id,"readonly"),a=t.objectStore(id).get(this.modelPath);a.onsuccess=()=>{if(null==a.result)return r.close(),n(new Error("Cannot find model with path '".concat(this.modelPath,"' ")+"in IndexedDB."));e(a.result.modelArtifacts)},a.onerror=e=>(r.close(),n(a.error)),t.oncomplete=()=>r.close()}else{t.weightData=Vu.join(t.weightData);const a=ad(t),s=r.transaction(cd,"readwrite");let i,c,l=s.objectStore(cd);try{i=l.put({modelPath:this.modelPath,modelArtifactsInfo:a})}catch(o){return n(o)}i.onsuccess=()=>{c=r.transaction(id,"readwrite");const i=c.objectStore(id);let u;try{u=i.put({modelPath:this.modelPath,modelArtifacts:t,modelArtifactsInfo:a})}catch(o){return n(o)}u.onsuccess=()=>e({modelArtifactsInfo:a}),u.onerror=e=>{l=s.objectStore(cd);const t=l.delete(this.modelPath);t.onsuccess=()=>(r.close(),n(u.error)),t.onerror=e=>(r.close(),n(u.error))}},i.onerror=e=>(r.close(),n(i.error)),s.oncomplete=()=>{null==c?r.close():c.oncomplete=()=>r.close()}}},a.onerror=e=>n(a.error)}))}}dd.URL_SCHEME="indexeddb://";const hd=e=>{return Yo().getBool("IS_BROWSER")&&!Array.isArray(e)&&e.startsWith(dd.URL_SCHEME)?(t=e.slice(dd.URL_SCHEME.length),new dd(t)):null;var t};od.registerSaveRouter(hd),od.registerLoadRouter(hd);class pd{constructor(){this.indexedDB=ld()}async listModels(){return new Promise(((e,t)=>{const n=this.indexedDB.open(sd,1);n.onupgradeneeded=()=>ud(n),n.onsuccess=()=>{const a=n.result,r=a.transaction(cd,"readonly"),o=r.objectStore(cd).getAll();o.onsuccess=()=>{const t={};for(const e of o.result)t[e.modelPath]=e.modelArtifactsInfo;e(t)},o.onerror=e=>(a.close(),t(o.error)),r.oncomplete=()=>a.close()},n.onerror=e=>t(n.error)}))}async removeModel(e){var t;return e=(t=e).startsWith(dd.URL_SCHEME)?t.slice(dd.URL_SCHEME.length):t,new Promise(((t,n)=>{const a=this.indexedDB.open(sd,1);a.onupgradeneeded=()=>ud(a),a.onsuccess=()=>{const r=a.result,o=r.transaction(cd,"readwrite"),s=o.objectStore(cd),i=s.get(e);let c;i.onsuccess=()=>{if(null==i.result)return r.close(),n(new Error("Cannot find model with path '".concat(e,"' ")+"in IndexedDB."));{const a=s.delete(e),o=()=>{c=r.transaction(id,"readwrite");const a=c.objectStore(id).delete(e);a.onsuccess=()=>t(i.result.modelArtifactsInfo),a.onerror=e=>n(i.error)};a.onsuccess=o,a.onerror=e=>(o(),r.close(),n(i.error))}},i.onerror=e=>(r.close(),n(i.error)),o.oncomplete=()=>{null==c?r.close():c.oncomplete=()=>r.close()}},a.onerror=e=>n(a.error)}))}}const fd="/",md="tensorflowjs_models",gd="info",bd="model_topology",yd="weight_specs",xd="weight_data",vd="model_metadata";function wd(e){return{info:[md,e,gd].join(fd),topology:[md,e,bd].join(fd),weightSpecs:[md,e,yd].join(fd),weightData:[md,e,xd].join(fd),modelMetadata:[md,e,vd].join(fd)}}function kd(e){for(const t of Object.values(e))window.localStorage.removeItem(t)}function Id(e){const t=e.split(fd);if(t.length<3)throw new Error("Invalid key format: ".concat(e));return t.slice(1,t.length-1).join(fd)}class Sd{constructor(e){if(!Yo().getBool("IS_BROWSER")||"undefined"===typeof window||"undefined"===typeof window.localStorage)throw new Error("The current environment does not support local storage.");if(this.LS=window.localStorage,null==e||!e)throw new Error("For local storage, modelPath must not be null, undefined or empty.");this.modelPath=e,this.keys=wd(this.modelPath)}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");{const n=JSON.stringify(e.modelTopology),a=JSON.stringify(e.weightSpecs),r=ad(e),o=Vu.join(e.weightData);try{this.LS.setItem(this.keys.info,JSON.stringify(r)),this.LS.setItem(this.keys.topology,n),this.LS.setItem(this.keys.weightSpecs,a),this.LS.setItem(this.keys.weightData,function(e){if($u)return Buffer.from(e).toString("base64");const t=new Uint8Array(e);let n="";for(let a=0,r=t.length;a<r;a++)n+=String.fromCharCode(t[a]);return btoa(n)}(o));const t={format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy,signature:null!=e.signature?e.signature:void 0,userDefinedMetadata:null!=e.userDefinedMetadata?e.userDefinedMetadata:void 0,modelInitializer:null!=e.modelInitializer?e.modelInitializer:void 0,initializerSignature:null!=e.initializerSignature?e.initializerSignature:void 0,trainingConfig:null!=e.trainingConfig?e.trainingConfig:void 0};return this.LS.setItem(this.keys.modelMetadata,JSON.stringify(t)),{modelArtifactsInfo:r}}catch(t){throw kd(this.keys),new Error("Failed to save model '".concat(this.modelPath,"' to local storage: ")+"size quota being exceeded is a possible cause of this failure: "+"modelTopologyBytes=".concat(r.modelTopologyBytes,", ")+"weightSpecsBytes=".concat(r.weightSpecsBytes,", ")+"weightDataBytes=".concat(r.weightDataBytes,"."))}}}async load(){const e=JSON.parse(this.LS.getItem(this.keys.info));if(null==e)throw new Error("In local storage, there is no model with name '".concat(this.modelPath,"'"));if("JSON"!==e.modelTopologyType)throw new Error("BrowserLocalStorage does not support loading non-JSON model topology yet.");const t={},n=JSON.parse(this.LS.getItem(this.keys.topology));if(null==n)throw new Error("In local storage, the topology of model '".concat(this.modelPath,"' ")+"is missing.");t.modelTopology=n;const a=JSON.parse(this.LS.getItem(this.keys.weightSpecs));if(null==a)throw new Error("In local storage, the weight specs of model '".concat(this.modelPath,"' ")+"are missing.");t.weightSpecs=a;const r=this.LS.getItem(this.keys.modelMetadata);if(null!=r){const e=JSON.parse(r);t.format=e.format,t.generatedBy=e.generatedBy,t.convertedBy=e.convertedBy,null!=e.signature&&(t.signature=e.signature),null!=e.userDefinedMetadata&&(t.userDefinedMetadata=e.userDefinedMetadata),null!=e.modelInitializer&&(t.modelInitializer=e.modelInitializer),null!=e.initializerSignature&&(t.initializerSignature=e.initializerSignature),null!=e.trainingConfig&&(t.trainingConfig=e.trainingConfig)}const o=this.LS.getItem(this.keys.weightData);if(null==o)throw new Error("In local storage, the binary weight values of model "+"'".concat(this.modelPath,"' are missing."));return t.weightData=function(e){if($u){const t=Buffer.from(e,"base64");return t.buffer.slice(t.byteOffset,t.byteOffset+t.byteLength)}const t=atob(e),n=new Uint8Array(t.length);for(let a=0;a<t.length;++a)n.set([t.charCodeAt(a)],a);return n.buffer}(o),t}}Sd.URL_SCHEME="localstorage://";const Nd=e=>{return Yo().getBool("IS_BROWSER")&&!Array.isArray(e)&&e.startsWith(Sd.URL_SCHEME)?(t=e.slice(Sd.URL_SCHEME.length),new Sd(t)):null;var t};od.registerSaveRouter(Nd),od.registerLoadRouter(Nd);class Cd{constructor(){mo(Yo().getBool("IS_BROWSER"),(()=>"Current environment is not a web browser")),mo("undefined"===typeof window||"undefined"!==typeof window.localStorage,(()=>"Current browser does not appear to support localStorage")),this.LS=window.localStorage}async listModels(){const e={},t=md+fd,n=fd+gd;for(let a=0;a<this.LS.length;++a){const r=this.LS.key(a);if(r.startsWith(t)&&r.endsWith(n)){e[Id(r)]=JSON.parse(this.LS.getItem(r))}}return e}async removeModel(e){var t;const n=wd(e=(t=e).startsWith(Sd.URL_SCHEME)?t.slice(Sd.URL_SCHEME.length):t);if(null==this.LS.getItem(n.info))throw new Error("Cannot find model at path '".concat(e,"'"));const a=JSON.parse(this.LS.getItem(n.info));return kd(n),a}}const Td="://";class Ed{constructor(){this.managers={}}static getInstance(){return null==Ed.instance&&(Ed.instance=new Ed),Ed.instance}static registerManager(e,t){mo(null!=e,(()=>"scheme must not be undefined or null.")),e.endsWith(Td)&&(e=e.slice(0,e.indexOf(Td))),mo(e.length>0,(()=>"scheme must not be an empty string."));const n=Ed.getInstance();mo(null==n.managers[e],(()=>"A model store manager is already registered for scheme '".concat(e,"'."))),n.managers[e]=t}static getManager(e){const t=Ed.getInstance().managers[e];if(null==t)throw new Error("Cannot find model manager for scheme '".concat(e,"'"));return t}static getSchemes(){return Object.keys(Ed.getInstance().managers)}}class Rd{constructor(){this.messageName="setTimeoutCustom",this.functionRefs=[],this.handledMessageCount=0,this.hasEventListener=!1}fetch(e,t){return fetch(e,t)}now(){return performance.now()}encode(e,t){if("utf-8"!==t&&"utf8"!==t)throw new Error("Browser's encoder only supports utf-8, but got ".concat(t));return null==this.textEncoder&&(this.textEncoder=new TextEncoder),this.textEncoder.encode(e)}decode(e,t){return new TextDecoder(t).decode(e)}setTimeoutCustom(e,t){"undefined"!==typeof window&&Yo().getBool("USE_SETTIMEOUTCUSTOM")?(this.functionRefs.push(e),setTimeout((()=>{window.postMessage({name:this.messageName,index:this.functionRefs.length-1},"*")}),t),this.hasEventListener||(this.hasEventListener=!0,window.addEventListener("message",(e=>{if(e.source===window&&e.data.name===this.messageName){e.stopPropagation();(0,this.functionRefs[e.data.index])(),this.handledMessageCount++,this.handledMessageCount===this.functionRefs.length&&(this.functionRefs=[],this.handledMessageCount=0)}}),!0))):setTimeout(e,t)}isTypedArray(e){return wl(e)}}if(Yo().get("IS_BROWSER")){Yo().setPlatform("browser",new Rd);try{Ed.registerManager(Sd.URL_SCHEME,new Cd)}catch(ade){}try{Ed.registerManager(dd.URL_SCHEME,new pd)}catch(ade){}}const _d=()=>n(78);let Ad;class Fd{constructor(){this.util=n(905),this.textEncoder=new this.util.TextEncoder}fetch(e,t){return null!=Yo().global.fetch?Yo().global.fetch(e,t):(null==Ad&&(Ad=_d()),Ad(e,t))}now(){const e=process.hrtime();return 1e3*e[0]+e[1]/1e6}encode(e,t){if("utf-8"!==t&&"utf8"!==t)throw new Error("Node built-in encoder only supports utf-8, but got ".concat(t));return this.textEncoder.encode(e)}decode(e,t){return 0===e.length?"":new this.util.TextDecoder(t).decode(e)}isTypedArray(e){return this.util.types.isFloat32Array(e)||this.util.types.isInt32Array(e)||this.util.types.isUint8Array(e)||this.util.types.isUint8ClampedArray(e)}}function Od(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"float32",n=arguments.length>2?arguments[2]:void 0;return t=t||"float32",Uo(e),new tu(e,t,n)}Yo().get("IS_NODE")&&!Yo().get("IS_BROWSER")&&Yo().setPlatform("node",new Fd);const Dd=Pu({cast_:function(e,t){const n=Mu(e,"x","cast");if(!function(e){return"bool"===e||"complex64"===e||"float32"===e||"int32"===e||"string"===e}(t))throw new Error("Failed to cast to unknown dtype ".concat(t));if("string"===t&&"string"!==n.dtype||"string"!==t&&"string"===n.dtype)throw new Error("Only strings can be casted to strings");const a={x:n},r={dtype:t};return Cu.runKernel(Is,a,r)}});const Md=Pu({clone_:function(e){const t={x:Mu(e,"x","clone","string_or_numeric")};return Cu.runKernel(mi,t)}});Nu();au={buffer:Od,cast:Dd,clone:Md,print:function(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];console.log(e.toString(t))}};const Ld=Pu({add_:function(e,t){let n=Mu(e,"a","add"),a=Mu(t,"b","add");[n,a]=yu(n,a);const r={a:n,b:a};return Cu.runKernel(as,r)}});const Pd=Pu({floorDiv_:function(e,t){let n=Mu(e,"a","floorDiv"),a=Mu(t,"b","floorDiv");[n,a]=yu(n,a);const r={a:n,b:a};return Cu.runKernel(li,r)}});const zd=Pu({div_:function(e,t){let n=Mu(e,"a","div"),a=Mu(t,"b","div");if([n,a]=yu(n,a),"int32"===n.dtype&&"int32"===a.dtype)return Pd(n,a);const r={a:n,b:a};return Cu.runKernel(Qs,r,{})}});const Bd=Pu({mul_:function(e,t){let n=Mu(e,"a","mul"),a=Mu(t,"b","mul");[n,a]=yu(n,a);const r={a:n,b:a};return Cu.runKernel(ji,r)}});const Wd=Pu({sqrt_:function(e){const t={x:Mu(e,"x","sqrt","float32")};return Cu.runKernel(Ac,t)}});const Vd=Pu({square_:function(e){const t=Mu(e,"x","square");return Cu.runKernel("Square",{x:t},{})}});const Ud=Pu({zerosLike_:function(e){const t={x:Mu(e,"x","zerosLike")};return Cu.runKernel(rl,t)}});function Gd(e){return Cu.customGrad(e)}function Hd(e,t){if((Ul(e)&&"string"!==t||Array.isArray(e))&&"complex64"!==t)throw new Error("Error creating a new Scalar: value must be a primitive (number|boolean|string)");if("string"===t&&Ul(e)&&!(e instanceof Uint8Array))throw new Error("When making a scalar from encoded string, the value must be `Uint8Array`.");return Bu(e,[],[],t)}const jd=new Map,Kd=new Map;class qd{getClassName(){return this.constructor.className}static fromConfig(e,t){return new e(t)}}class Xd{constructor(){this.classNameMap={}}static getMap(){return null==Xd.instance&&(Xd.instance=new Xd),Xd.instance}static register(e){Xd.getMap().classNameMap[e.className]=[e,e.fromConfig]}}function Yd(e,t,n){mo(null!=e.className,(()=>"Class being registered does not have the static className property defined.")),mo("string"===typeof e.className,(()=>"className is required to be a string, but got type "+typeof e.className)),mo(e.className.length>0,(()=>"Class being registered has an empty-string as its className, which is disallowed.")),"undefined"===typeof t&&(t="Custom"),"undefined"===typeof n&&(n=e.className);const a=t+">"+n;return Xd.register(e),jd.set(a,e),Kd.set(e,a),e}class Qd extends qd{minimize(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1],n=arguments.length>2?arguments[2]:void 0;const{value:a,grads:r}=this.computeGradients(e,n);if(null!=n){const e=n.map((e=>({name:e.name,tensor:r[e.name]})));this.applyGradients(e)}else this.applyGradients(r);return ju(r),t?a:(a.dispose(),null)}get iterations(){return null==this.iterations_&&(this.iterations_=0),this.iterations_}incrementIterations(){this.iterations_=this.iterations+1}computeGradients(e,t){return function(e,t){mo(Do(e),(()=>"The f passed in variableGrads(f) must be a function")),mo(null==t||Array.isArray(t)&&t.every((e=>e instanceof iu)),(()=>"The varList passed in variableGrads(f, varList) must be an array of variables"));const n=null!=t;if(!n){t=[];for(const e in Cu.registeredVariables)t.push(Cu.registeredVariables[e])}const a=n?t.filter((e=>!e.trainable)):null,r=t.length;t=t.filter((e=>e.trainable)),mo(t.length>0,(()=>"variableGrads() expects at least one of the input variables to "+"be trainable, but none of the ".concat(r," variables is ")+"trainable."));const{value:o,grads:s}=Cu.gradients(e,t,null,!0);mo(s.some((e=>null!=e)),(()=>"Cannot find a connection between any variable and the result of the loss function y=f(x). Please make sure the operations that use variables are inside the function f passed to minimize().")),mo(0===o.rank,(()=>"The f passed in variableGrads(f) must return a scalar, but it "+"returned a rank-".concat(o.rank," tensor")));const i={};return t.forEach(((e,t)=>{null!=s[t]&&(i[e.name]=s[t])})),null!=a&&a.forEach((e=>i[e.name]=null)),{value:o,grads:i}}(e,t)}dispose(){null!=this.iterations_&&ju(this.iterations_)}async saveIterations(){return null==this.iterations_&&(this.iterations_=0),{name:"iter",tensor:Hd(this.iterations_,"int32")}}async getWeights(){throw new Error("getWeights() is not implemented for this optimizer yet.")}async setWeights(e){throw new Error("setWeights() is not implemented for this optimizer class "+"".concat(this.getClassName()))}async extractIterations(e){return this.iterations_=(await e[0].tensor.data())[0],e.slice(1)}}Object.defineProperty(Qd,Symbol.hasInstance,{value:e=>null!=e.minimize&&null!=e.computeGradients&&null!=e.applyGradients});class Jd extends Qd{static get className(){return"Adadelta"}constructor(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null;super(),this.learningRate=e,this.rho=t,this.epsilon=n,this.accumulatedGrads=[],this.accumulatedUpdates=[],null==n&&(this.epsilon=Cu.backend.epsilon())}applyGradients(e){(Array.isArray(e)?e.map((e=>e.name)):Object.keys(e)).forEach(((t,n)=>{const a=Cu.registeredVariables[t],r=!1;null==this.accumulatedGrads[n]&&(this.accumulatedGrads[n]={originalName:"".concat(t,"/accum_grad"),variable:Hu((()=>Ud(a).variable(r)))}),null==this.accumulatedUpdates[n]&&(this.accumulatedUpdates[n]={originalName:"".concat(t,"/accum_var"),variable:Hu((()=>Ud(a).variable(r)))});const o=Array.isArray(e)?e[n].tensor:e[t];if(null==o)return;const s=this.accumulatedGrads[n].variable,i=this.accumulatedUpdates[n].variable;Hu((()=>{const e=Ld(Bd(s,this.rho),Bd(Vd(o),1-this.rho)),t=Bd(zd(Wd(Ld(i,this.epsilon)),Wd(Ld(s,this.epsilon))),o),n=Ld(Bd(i,this.rho),Bd(Vd(t),1-this.rho));s.assign(e),i.assign(n);const r=Ld(Bd(t,-this.learningRate),a);a.assign(r)}))})),this.incrementIterations()}dispose(){null!=this.accumulatedUpdates&&(ju(this.accumulatedGrads.map((e=>e.variable))),ju(this.accumulatedUpdates.map((e=>e.variable))))}async getWeights(){const e=[...this.accumulatedGrads,...this.accumulatedUpdates];return[await this.saveIterations()].concat(e.map((e=>({name:e.originalName,tensor:e.variable}))))}async setWeights(e){const t=(e=await this.extractIterations(e)).length/2,n=!1;this.accumulatedGrads=e.slice(0,t).map((e=>({originalName:e.name,variable:e.tensor.variable(n)}))),this.accumulatedUpdates=e.slice(t,2*t).map((e=>({originalName:e.name,variable:e.tensor.variable(n)})))}getConfig(){return{learningRate:this.learningRate,rho:this.rho,epsilon:this.epsilon}}static fromConfig(e,t){return new e(t.learningRate,t.rho,t.epsilon)}}function Zd(e,t,n){Uo(e);const a={shape:e,value:t,dtype:n=n||Oo(t)};return Cu.runKernel(si,{},a)}class $d extends Qd{static get className(){return"Adagrad"}constructor(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:.1;super(),this.learningRate=e,this.initialAccumulatorValue=t,this.accumulatedGrads=[]}applyGradients(e){(Array.isArray(e)?e.map((e=>e.name)):Object.keys(e)).forEach(((t,n)=>{const a=Cu.registeredVariables[t];if(null==this.accumulatedGrads[n]){const e=!1;this.accumulatedGrads[n]={originalName:"".concat(t,"/accumulator"),variable:Hu((()=>Zd(a.shape,this.initialAccumulatorValue).variable(e)))}}const r=Array.isArray(e)?e[n].tensor:e[t];if(null==r)return;const o=this.accumulatedGrads[n].variable;Hu((()=>{const e=Ld(o,Vd(r));o.assign(e);const t=Ld(Bd(zd(r,Wd(Ld(e,Cu.backend.epsilon()))),-this.learningRate),a);a.assign(t)}))})),this.incrementIterations()}dispose(){null!=this.accumulatedGrads&&ju(this.accumulatedGrads.map((e=>e.variable)))}async getWeights(){return[await this.saveIterations()].concat(this.accumulatedGrads.map((e=>({name:e.originalName,tensor:e.variable}))))}async setWeights(e){e=await this.extractIterations(e);this.accumulatedGrads=e.map((e=>({originalName:e.name,variable:e.tensor.variable(false)})))}getConfig(){return{learningRate:this.learningRate,initialAccumulatorValue:this.initialAccumulatorValue}}static fromConfig(e,t){return new e(t.learningRate,t.initialAccumulatorValue)}}const eh=Pu({pow_:function(e,t){let n=Mu(e,"base","pow"),a=Mu(t,"exp","pow");[n,a]=yu(n,a);const r={a:n,b:a};return Cu.runKernel(tc,r)}});const th=Pu({sub_:function(e,t){let n=Mu(e,"a","sub"),a=Mu(t,"b","sub");[n,a]=yu(n,a);const r={a:n,b:a};return Cu.runKernel(Xc,r)}});class nh extends Qd{static get className(){return"Adam"}constructor(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:null;super(),this.learningRate=e,this.beta1=t,this.beta2=n,this.epsilon=a,this.accumulatedFirstMoment=[],this.accumulatedSecondMoment=[],Hu((()=>{this.accBeta1=Hd(t).variable(),this.accBeta2=Hd(n).variable()})),null==a&&(this.epsilon=Cu.backend.epsilon())}applyGradients(e){const t=Array.isArray(e)?e.map((e=>e.name)):Object.keys(e);Hu((()=>{const n=th(1,this.accBeta1),a=th(1,this.accBeta2);t.forEach(((t,r)=>{const o=Cu.registeredVariables[t],s=!1;null==this.accumulatedFirstMoment[r]&&(this.accumulatedFirstMoment[r]={originalName:"".concat(t,"/m"),variable:Hu((()=>Ud(o).variable(s)))}),null==this.accumulatedSecondMoment[r]&&(this.accumulatedSecondMoment[r]={originalName:"".concat(t,"/v"),variable:Hu((()=>Ud(o).variable(s)))});const i=Array.isArray(e)?e[r].tensor:e[t];if(null==i)return;const c=this.accumulatedFirstMoment[r].variable,l=this.accumulatedSecondMoment[r].variable,u=Ld(Bd(c,this.beta1),Bd(i,1-this.beta1)),d=Ld(Bd(l,this.beta2),Bd(Vd(i),1-this.beta2)),h=zd(u,n),p=zd(d,a);c.assign(u),l.assign(d);const f=Ld(Bd(zd(h,Ld(Wd(p),this.epsilon)),-this.learningRate),o);o.assign(f)})),this.accBeta1.assign(Bd(this.accBeta1,this.beta1)),this.accBeta2.assign(Bd(this.accBeta2,this.beta2))})),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.accBeta2.dispose(),null!=this.accumulatedFirstMoment&&ju(this.accumulatedFirstMoment.map((e=>e.variable))),null!=this.accumulatedSecondMoment&&ju(this.accumulatedSecondMoment.map((e=>e.variable)))}async getWeights(){const e=[...this.accumulatedFirstMoment,...this.accumulatedSecondMoment];return[await this.saveIterations()].concat(e.map((e=>({name:e.originalName,tensor:e.variable}))))}async setWeights(e){e=await this.extractIterations(e),Hu((()=>{this.accBeta1.assign(eh(this.beta1,this.iterations_+1)),this.accBeta2.assign(eh(this.beta2,this.iterations_+1))}));const t=e.length/2,n=!1;this.accumulatedFirstMoment=e.slice(0,t).map((e=>({originalName:e.name,variable:e.tensor.variable(n)}))),this.accumulatedSecondMoment=e.slice(t,2*t).map((e=>({originalName:e.name,variable:e.tensor.variable(n)})))}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon}}static fromConfig(e,t){return new e(t.learningRate,t.beta1,t.beta2,t.epsilon)}}const ah=Pu({abs_:function(e){const t=Mu(e,"x","abs");if("complex64"===t.dtype){const e={x:t};return Cu.runKernel(Ts,e)}{const e={x:t};return Cu.runKernel(es,e)}}});function rh(e,t){const n=e.length,a=[];for(let r=0;r<n;r++){const o=n-1-r,s=e[o]||1;(t[t.length-1-r]||1)>1&&1===s&&a.unshift(o)}return a}function oh(e,t){const n=[];for(let a=0;a<t.length;a++){const r=e[e.length-a-1],o=t.length-a-1,s=t[o];(null==r||1===r&&s>1)&&n.unshift(o)}return n}function sh(e,t){const n=Math.max(e.length,t.length),a=new Array(n);for(let r=0;r<n;r++){let o=e[e.length-r-1];null==o&&(o=1);let s=t[t.length-r-1];if(null==s&&(s=1),1===o)a[n-r-1]=s;else if(1===s)a[n-r-1]=o;else{if(o!==s){const n="Operands could not be broadcast together with shapes "+"".concat(e," and ").concat(t,".");throw Error(n)}a[n-r-1]=o}}return a}const ih=Pu({maximum_:function(e,t){let n=Mu(e,"a","maximum"),a=Mu(t,"b","maximum");[n,a]=yu(n,a),"bool"===n.dtype&&(n=Dd(n,"int32"),a=Dd(a,"int32")),sh(n.shape,a.shape);const r={a:n,b:a};return Cu.runKernel(Oi,r)}});class ch extends Qd{static get className(){return"Adamax"}constructor(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:null,r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:0;super(),this.learningRate=e,this.beta1=t,this.beta2=n,this.epsilon=a,this.decay=r,this.accumulatedFirstMoment=[],this.accumulatedWeightedInfNorm=[],Hu((()=>{this.iteration=Hd(0).variable(),this.accBeta1=Hd(t).variable()})),null==a&&(this.epsilon=Cu.backend.epsilon())}applyGradients(e){const t=Array.isArray(e)?e.map((e=>e.name)):Object.keys(e);Hu((()=>{const n=th(1,this.accBeta1),a=zd(-this.learningRate,Ld(Bd(this.iteration,this.decay),1));t.forEach(((t,r)=>{const o=Cu.registeredVariables[t],s=!1;null==this.accumulatedFirstMoment[r]&&(this.accumulatedFirstMoment[r]={originalName:"".concat(t,"/m"),variable:Ud(o).variable(s)}),null==this.accumulatedWeightedInfNorm[r]&&(this.accumulatedWeightedInfNorm[r]={originalName:"".concat(t,"/v"),variable:Ud(o).variable(s)});const i=Array.isArray(e)?e[r].tensor:e[t];if(null==i)return;const c=this.accumulatedFirstMoment[r].variable,l=this.accumulatedWeightedInfNorm[r].variable,u=Ld(Bd(c,this.beta1),Bd(i,1-this.beta1)),d=Bd(l,this.beta2),h=ah(i),p=ih(d,h);c.assign(u),l.assign(p);const f=Ld(Bd(zd(a,n),zd(u,Ld(p,this.epsilon))),o);o.assign(f)})),this.iteration.assign(Ld(this.iteration,1)),this.accBeta1.assign(Bd(this.accBeta1,this.beta1))})),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.iteration.dispose(),null!=this.accumulatedFirstMoment&&ju(this.accumulatedFirstMoment.map((e=>e.variable))),null!=this.accumulatedWeightedInfNorm&&ju(this.accumulatedWeightedInfNorm.map((e=>e.variable)))}async getWeights(){throw new Error("getWeights() is not implemented for Adamax yet.")}async setWeights(e){throw new Error("setWeights() is not implemented for Adamax yet.")}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon,decay:this.decay}}static fromConfig(e,t){return new e(t.learningRate,t.beta1,t.beta2,t.epsilon,t.decay)}}class lh extends Qd{static get className(){return"SGD"}constructor(e){super(),this.learningRate=e,this.setLearningRate(e)}applyGradients(e){const t=Array.isArray(e)?e.map((e=>e.name)):Object.keys(e);t.forEach(((t,n)=>{const a=Array.isArray(e)?e[n].tensor:e[t];if(null==a)return;const r=Cu.registeredVariables[t];Hu((()=>{const e=Ld(Bd(this.c,a),r);r.assign(e)}))})),this.incrementIterations()}setLearningRate(e){this.learningRate=e,null!=this.c&&this.c.dispose(),this.c=Ku(Hd(-e))}dispose(){this.c.dispose()}async getWeights(){return[await this.saveIterations()]}async setWeights(e){if(0!==(e=await this.extractIterations(e)).length)throw new Error("SGD optimizer does not have settable weights.")}getConfig(){return{learningRate:this.learningRate}}static fromConfig(e,t){return new e(t.learningRate)}}class uh extends lh{static get className(){return"Momentum"}constructor(e,t){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];super(e),this.learningRate=e,this.momentum=t,this.useNesterov=n,this.accumulations=[],this.m=Hd(this.momentum)}applyGradients(e){(Array.isArray(e)?e.map((e=>e.name)):Object.keys(e)).forEach(((t,n)=>{const a=Cu.registeredVariables[t];if(null==this.accumulations[n]){const e=!1;this.accumulations[n]={originalName:"".concat(t,"/momentum"),variable:Hu((()=>Ud(a).variable(e)))}}const r=this.accumulations[n].variable,o=Array.isArray(e)?e[n].tensor:e[t];null!=o&&Hu((()=>{let e;const t=Ld(Bd(this.m,r),o);e=this.useNesterov?Ld(Bd(this.c,Ld(o,Bd(t,this.m))),a):Ld(Bd(this.c,t),a),r.assign(t),a.assign(e)}))})),this.incrementIterations()}dispose(){this.m.dispose(),null!=this.accumulations&&ju(this.accumulations.map((e=>e.variable)))}setMomentum(e){this.momentum=e}async getWeights(){return[await this.saveIterations()].concat(this.accumulations.map((e=>({name:e.originalName,tensor:e.variable}))))}async setWeights(e){e=await this.extractIterations(e);this.accumulations=e.map((e=>({originalName:e.name,variable:e.tensor.variable(false)})))}getConfig(){return{learningRate:this.learningRate,momentum:this.momentum,useNesterov:this.useNesterov}}static fromConfig(e,t){return new e(t.learningRate,t.momentum,t.useNesterov)}}class dh extends Qd{static get className(){return"RMSProp"}constructor(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:.9,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:null,r=arguments.length>4&&void 0!==arguments[4]&&arguments[4];if(super(),this.learningRate=e,this.decay=t,this.momentum=n,this.epsilon=a,this.accumulatedMeanSquares=[],this.accumulatedMoments=[],this.accumulatedMeanGrads=[],this.centered=r,null==a&&(this.epsilon=Cu.backend.epsilon()),null==e)throw new Error("learningRate for RMSPropOptimizer must be defined.")}applyGradients(e){(Array.isArray(e)?e.map((e=>e.name)):Object.keys(e)).forEach(((t,n)=>{const a=Cu.registeredVariables[t],r=!1;null==this.accumulatedMeanSquares[n]&&(this.accumulatedMeanSquares[n]={originalName:"".concat(t,"/rms"),variable:Hu((()=>Ud(a).variable(r)))}),null==this.accumulatedMoments[n]&&(this.accumulatedMoments[n]={originalName:"".concat(t,"/momentum"),variable:Hu((()=>Ud(a).variable(r)))}),null==this.accumulatedMeanGrads[n]&&this.centered&&(this.accumulatedMeanGrads[n]={originalName:"".concat(t,"/mg"),variable:Hu((()=>Ud(a).variable(r)))});const o=Array.isArray(e)?e[n].tensor:e[t];if(null==o)return;const s=this.accumulatedMeanSquares[n].variable,i=this.accumulatedMoments[n].variable;Hu((()=>{const e=Ld(Bd(s,this.decay),Bd(Vd(o),1-this.decay));if(this.centered){const t=this.accumulatedMeanGrads[n].variable,r=Ld(Bd(t,this.decay),Bd(o,1-this.decay)),c=zd(Bd(o,this.learningRate),Wd(th(e,Ld(Vd(r),this.epsilon)))),l=Ld(Bd(i,this.momentum),c);s.assign(e),t.assign(r),i.assign(l);const u=th(a,l);a.assign(u)}else{const e=Ld(Bd(s,this.decay),Bd(Vd(o),1-this.decay)),t=Ld(Bd(i,this.momentum),zd(Bd(o,this.learningRate),Wd(Ld(e,this.epsilon))));s.assign(e),i.assign(t);const n=th(a,t);a.assign(n)}}))})),this.incrementIterations()}dispose(){null!=this.accumulatedMeanSquares&&ju(this.accumulatedMeanSquares.map((e=>e.variable))),null!=this.accumulatedMeanGrads&&this.centered&&ju(this.accumulatedMeanGrads.map((e=>e.variable))),null!=this.accumulatedMoments&&ju(this.accumulatedMoments.map((e=>e.variable)))}async getWeights(){const e=[...this.accumulatedMeanSquares,...this.accumulatedMoments];return this.centered&&e.push(...this.accumulatedMeanGrads),[await this.saveIterations()].concat(e.map((e=>({name:e.originalName,tensor:e.variable}))))}async setWeights(e){e=await this.extractIterations(e);const t=this.centered?e.length/3:e.length/2,n=!1;this.accumulatedMeanSquares=e.slice(0,t).map((e=>({originalName:e.name,variable:e.tensor.variable(n)}))),this.accumulatedMoments=e.slice(t,2*t).map((e=>({originalName:e.name,variable:e.tensor.variable(n)}))),this.centered&&(this.accumulatedMeanGrads=e.slice(2*t,3*t).map((e=>({originalName:e.name,variable:e.tensor.variable(n)}))))}getConfig(){return{learningRate:this.learningRate,decay:this.decay,momentum:this.momentum,epsilon:this.epsilon,centered:this.centered}}static fromConfig(e,t){return new e(t.learningRate,t.decay,t.momentum,t.epsilon,t.centered)}}const hh=[Jd,$d,nh,ch,uh,dh,lh];function ph(e){return new Promise((e=>setTimeout(e))).then(e)}class fh{constructor(e){if(!Yo().getBool("IS_BROWSER"))throw new Error("browserDownloads() cannot proceed because the current environment is not a browser.");e.startsWith(fh.URL_SCHEME)&&(e=e.slice(fh.URL_SCHEME.length)),null!=e&&0!==e.length||(e="model"),this.modelJsonFileName=e+".json",this.weightDataFileName=e+".weights.bin"}async save(e){if("undefined"===typeof document)throw new Error("Browser downloads are not supported in this environment since `document` is not present");const t=Vu.join(e.weightData),n=window.URL.createObjectURL(new Blob([t],{type:"application/octet-stream"}));if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserDownloads.save() does not support saving model topology in binary formats yet.");{const t=td(e,[{paths:["./"+this.weightDataFileName],weights:e.weightSpecs}]),a=window.URL.createObjectURL(new Blob([JSON.stringify(t)],{type:"application/json"})),r=null==this.modelJsonAnchor?document.createElement("a"):this.modelJsonAnchor;if(r.download=this.modelJsonFileName,r.href=a,await ph((()=>r.dispatchEvent(new MouseEvent("click")))),null!=e.weightData){const e=null==this.weightDataAnchor?document.createElement("a"):this.weightDataAnchor;e.download=this.weightDataFileName,e.href=n,await ph((()=>e.dispatchEvent(new MouseEvent("click"))))}return{modelArtifactsInfo:ad(e)}}}}fh.URL_SCHEME="downloads://";function mh(e,t,n,a){!function(e){mo(null!=e&&Array.isArray(e)&&e.length>0,(()=>"promises must be a none empty array"))}(e),function(e,t){mo(e>=0&&e<=1,(()=>"Progress fraction must be in range [0, 1], but "+"got startFraction ".concat(e))),mo(t>=0&&t<=1,(()=>"Progress fraction must be in range [0, 1], but "+"got endFraction ".concat(t))),mo(t>=e,(()=>"startFraction must be no more than endFraction, but "+"got startFraction ".concat(e," and endFraction ")+"".concat(t)))}(n=null==n?0:n,a=null==a?1:a);let r=0;return Promise.all(e.map((o=>(o.then((o=>{const s=n+ ++r/e.length*(a-n);return t(s),o})),o))))}async function gh(e,t){null==t&&(t={});const n=null==t.fetchFunc?Yo().platform.fetch:t.fetchFunc,a=e.map((e=>n(e,t.requestInit,{isBinary:!0}))),r=(null==t.onProgress?await Promise.all(a):await mh(a,t.onProgress,0,.5)).map((e=>e.arrayBuffer()));return null==t.onProgress?await Promise.all(r):await mh(r,t.onProgress,.5,1)}od.registerSaveRouter((e=>Yo().getBool("IS_BROWSER")&&!Array.isArray(e)&&e.startsWith(fh.URL_SCHEME)?function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:"model";return new fh(e)}(e.slice(fh.URL_SCHEME.length)):null));class bh{constructor(e,t){if(this.DEFAULT_METHOD="POST",null==t&&(t={}),this.weightPathPrefix=t.weightPathPrefix,this.weightUrlConverter=t.weightUrlConverter,null!=t.fetchFunc?(mo("function"===typeof t.fetchFunc,(()=>"Must pass a function that matches the signature of `fetch` (see https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)")),this.fetch=t.fetchFunc):this.fetch=Yo().platform.fetch,mo(null!=e&&e.length>0,(()=>"URL path for http must not be null, undefined or empty.")),Array.isArray(e)&&mo(2===e.length,(()=>"URL paths for http must have a length of 2, "+"(actual length is ".concat(e.length,")."))),this.path=e,null!=t.requestInit&&null!=t.requestInit.body)throw new Error("requestInit is expected to have no pre-existing body, but has one.");this.requestInit=t.requestInit||{},this.loadOptions=t}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserHTTPRequest.save() does not support saving model topology in binary formats yet.");const t=Object.assign({method:this.DEFAULT_METHOD},this.requestInit);t.body=new FormData;const n=td(e,[{paths:["./model.weights.bin"],weights:e.weightSpecs}]);if(t.body.append("model.json",new Blob([JSON.stringify(n)],{type:"application/json"}),"model.json"),null!=e.weightData){const n=Vu.join(e.weightData);t.body.append("model.weights.bin",new Blob([n],{type:"application/octet-stream"}),"model.weights.bin")}const a=await this.fetch(this.path,t);if(a.ok)return{modelArtifactsInfo:ad(e),responses:[a]};throw new Error("BrowserHTTPRequest.save() failed due to HTTP response status "+"".concat(a.status,"."))}async loadModelJSON(){const e=await this.fetch(this.path,this.requestInit);if(!e.ok)throw new Error("Request to ".concat(this.path," failed with status code ")+"".concat(e.status,". Please verify this URL points to ")+"the model JSON of the model to load.");let t;try{t=await e.json()}catch(B){let t="Failed to parse model JSON of response from ".concat(this.path,".");throw this.path.endsWith(".pb")?t+=" Your path contains a .pb file extension. Support for .pb models have been removed in TensorFlow.js 1.0 in favor of .json models. You can re-convert your Python TensorFlow model using the TensorFlow.js 1.0 conversion scripts or you can convert your.pb models with the 'pb2json'NPM script in the tensorflow/tfjs-converter repository.":t+=" Please make sure the server is serving valid JSON for this request.",new Error(t)}const n=t.modelTopology,a=t.weightsManifest;if(null==n&&null==a)throw new Error("The JSON from HTTP path ".concat(this.path," contains neither model ")+"topology or manifest for weights.");return t}async load(){if(this.loadOptions.streamWeights)return this.loadStream();return nd(await this.loadModelJSON(),(e=>this.loadWeights(e)))}async loadStream(){const e=await this.loadModelJSON(),t=await this.getWeightUrls(e.weightsManifest),n=rd(e.weightsManifest);return Object.assign(Object.assign({},e),{weightSpecs:n,getWeightStream:()=>function(e,t){var n;const a=null==t.fetchFunc?Yo().platform.fetch:t.fetchFunc;let r,o=0;return null===(n=t.onProgress)||void 0===n||n.call(t,0),new ReadableStream({pull:async n=>{for(var s;o<e.length;){if(!r){const n=(await a(e[o],t.requestInit,{isBinary:!0})).body;r=n.getReader()}const{done:i,value:c}=await r.read();if(!i)return void n.enqueue(c);o++,r=void 0,null===(s=t.onProgress)||void 0===s||s.call(t,o/e.length)}n.close()}})}(t,this.loadOptions)})}async getWeightUrls(e){const t=Array.isArray(this.path)?this.path[1]:this.path,[n,a]=function(e){const t=e.lastIndexOf("/"),n=e.lastIndexOf("?"),a=e.substring(0,t),r=n>t?e.substring(n):"";return[a+"/",r]}(t),r=this.weightPathPrefix||n,o=[],s=[];for(const i of e)for(const e of i.paths)null!=this.weightUrlConverter?s.push(this.weightUrlConverter(e)):o.push(r+e+a);return this.weightUrlConverter&&o.push(...await Promise.all(s)),o}async loadWeights(e){const t=await this.getWeightUrls(e);return[rd(e),await gh(t,this.loadOptions)]}}function yh(e){return null!=e.match(bh.URL_SCHEME_REGEX)}bh.URL_SCHEME_REGEX=/^https?:\/\//;const xh=(e,t)=>{if("undefined"===typeof fetch&&(null==t||null==t.fetchFunc))return null;{let n=!0;if(n=Array.isArray(e)?e.every((e=>yh(e))):yh(e),n)return vh(e,t)}return null};function vh(e,t){return new bh(e,t)}od.registerSaveRouter(xh),od.registerLoadRouter(xh);const wh=-2,kh=-1;function Ih(e,t,n){const a=e.shape.length;mo(a===t.length,(()=>"Error in slice".concat(a,"D: Length of begin ").concat(t," must ")+"match the rank of the array (".concat(a,")."))),mo(a===n.length,(()=>"Error in slice".concat(a,"D: Length of size ").concat(n," must ")+"match the rank of the array (".concat(a,").")));for(let r=0;r<a;++r)mo(t[r]+n[r]<=e.shape[r],(()=>"Error in slice".concat(a,"D: begin[").concat(r,"] + size[").concat(r,"] ")+"(".concat(t[r]+n[r],") would overflow input.shape[").concat(r,"] (").concat(e.shape[r],")")))}function Sh(e){const t=[];let n=0;for(;e>0;)1&e&&t.push(n),e/=2,n++;return t}function Nh(e,t,n){const a=[];for(let r=0;r<e.length;r++)a[r]=Math.ceil((t[r]-e[r])/n[r]);return a}function Ch(e,t,n,a){const r=[...e];for(let o=r.length;o<a.length;o++)r.push(1);for(let o=0;o<n;o++)0===o?r[t]=1:(r.splice(t,0,1),r.pop());return r}function Th(e,t,n){return n<=e?n:n-(t-1)}function Eh(e,t){const n=[];for(let a=0;a<e;a++)n.push(t+a);return n}function Rh(e,t,n,a,r,o,s,i,c){const l=e.length;let u=new Array(l),d=new Array(l),h=new Array(l);if(t.length&&n>0){const c=t[0],l=n+1;u=_h(s,c,l,a,e),d=Ah(i,c,l,r,e),h=Ch(o,c,l,e)}else for(let p=0;p<l;p++)u[p]=Oh(s,a,o,e,p,c),d[p]=Dh(i,r,o,e,p,c),h[p]=Fh(o,p,c);return{begin:u,end:d,strides:h}}function _h(e,t,n,a,r){const o=[...r],s=Eh(n,t);for(let i=0;i<o.length;i++)if(s.indexOf(i)>-1)o[i]=0;else{const r=Th(t,n,i);let s=a[r];e&1<<r&&(s=0),o[i]=s}return o}function Ah(e,t,n,a,r){const o=[...r],s=Eh(n,t);for(let i=0;i<o.length;i++)if(s.indexOf(i)>-1)o[i]=Number.MAX_SAFE_INTEGER;else{const r=Th(t,n,i);let s=a[r];e&1<<r&&(s=Number.MAX_SAFE_INTEGER),o[i]=s}for(let i=0;i<o.length;i++){const e=r[i];o[i]<0&&(o[i]+=e),o[i]=ho(0,o[i],r[i])}return o}function Fh(e,t,n){let a=e[t];return(n&1<<t||null==a)&&(a=1),a}function Oh(e,t,n,a,r,o){let s=t[r];const i=n[r]||1;(e&1<<r||o&1<<r||null==s)&&(s=i>0?Number.MIN_SAFE_INTEGER:Number.MAX_SAFE_INTEGER);const c=a[r];return s<0&&(s+=c),s=ho(0,s,c-1),s}function Dh(e,t,n,a,r,o){let s=t[r];const i=n[r]||1;(e&1<<r||o&1<<r||null==s)&&(s=i>0?Number.MAX_SAFE_INTEGER:Number.MIN_SAFE_INTEGER);const c=a[r];return s<0&&(s+=c),s=i>0?ho(0,s,c):ho(-1,s,c-1),s}function Mh(e,t,n){let a=n.length;for(let r=0;r<n.length;r++)if(n[r]>1){a=r;break}for(let r=a+1;r<n.length;r++)if(t[r]>0||n[r]!==e[r])return!1;return!0}function Lh(e,t){let n=e.length>0?e[e.length-1]:1;for(let a=0;a<e.length-1;a++)n+=e[a]*t[a];return n}function Ph(e,t,n){let a;const r=e.shape.length;let o;return a="number"===typeof t?[t,...new Array(r-1).fill(0)]:t.length<r?t.concat(new Array(r-t.length).fill(0)):t.slice(),a.forEach((e=>{mo(-1!==e,(()=>"slice() does not support negative begin indexing."))})),o=null==n?new Array(r).fill(-1):"number"===typeof n?[n,...new Array(r-1).fill(-1)]:n.length<r?n.concat(new Array(r-n.length).fill(-1)):n,o=o.map(((t,n)=>t>=0?t:(mo(-1===t,(()=>"Negative size values should be exactly -1 but got "+"".concat(t," for the slice() size at index ").concat(n,"."))),e.shape[n]-a[n]))),[a,o]}function zh(e,t,n,a,r,o,s,i,c){let l;if(null==a?(l=new Array(t.length),l.fill(1)):l=a,null!=s&&0!==(s&s-1))throw new Error("Multiple ellipses in slice is not allowed.");let u=!1;const d={dims:l.length,numAddAxisAfterEllipsis:0,begin:t.slice(),end:n.slice(),strides:l.slice(),beginMask:r,endMask:o,ellipsisMask:s,newAxisMask:i,shrinkAxisMask:c};for(let x=0;x<d.dims;x++)u&&0!==(1<<x&i)&&d.numAddAxisAfterEllipsis++,1<<x&s&&(u=!0);u||(d.ellipsisMask|=1<<d.dims,d.dims++);const h={dims:e.length,beginMask:0,endMask:0,beginValid:!1,endValid:!1};!function(e,t){t.beginMask=0,t.endMask=0,t.shrinkAxisMask=0;let n=0;t.beginValid=null!=e.begin,t.endValid=null!=e.end,t.begin=new Array(t.dims),t.end=new Array(t.dims),t.strides=new Array(t.dims),t.finalShapeGatherIndices=[],t.finalShapeGatherIndicesSparse=[],t.inputShapeGatherIndicesSparse=new Array(t.dims);for(let a=0;a<e.dims;a++)if(1<<a&e.ellipsisMask){const r=Math.min(t.dims-(e.dims-a)+1+e.numAddAxisAfterEllipsis,t.dims);for(;n<r;n++)t.begin[n]=0,t.end[n]=0,t.strides[n]=1,t.beginMask|=1<<n,t.endMask|=1<<n,t.finalShapeGatherIndices.push(n),t.finalShapeGatherIndicesSparse.push(-1),t.inputShapeGatherIndicesSparse[n]=a}else if(1<<a&e.newAxisMask)t.finalShapeGatherIndices.push(wh),t.finalShapeGatherIndicesSparse.push(-1);else{if(n===t.begin.length)throw Error("Index out of range using input dim ".concat(n,"; input ")+"has only ".concat(t.dims," dims, ").concat(t.begin.length,"."));null!=e.begin&&(t.begin[n]=e.begin[a]),null!=e.end&&(t.end[n]=e.end[a]),t.strides[n]=e.strides[a],e.beginMask&1<<a&&(t.beginMask|=1<<n),e.endMask&1<<a&&(t.endMask|=1<<n),e.shrinkAxisMask&1<<a?(t.finalShapeGatherIndices.push(kh),t.finalShapeGatherIndicesSparse.push(-1),t.shrinkAxisMask|=1<<n):(t.finalShapeGatherIndices.push(n),t.finalShapeGatherIndicesSparse.push(a)),t.inputShapeGatherIndicesSparse[n]=a,n++}}(d,h);let p=!0,f=!0,m=!0;const g=[],b=[];for(let x=0;x<e.length;++x){if(0===h.strides[x])throw Error("strides[".concat(x,"] must be non-zero"));const t=!!(h.shrinkAxisMask&1<<x),n=e[x];if(-1===n){g.push(t?1:-1);continue}const a=[h.beginMask&1<<x,h.endMask&1<<x],r=[h.strides[x]>0?0:-1,h.strides[x]>0?n:n-1];if(t&&h.strides[x]<=0)throw Error("only stride 1 allowed on non-range indexing.");m=m&&1===h.strides[x];const o=!!(h.beginMask&1<<x&&h.endMask&1<<x);if(h.beginValid&&h.endValid){if(t){const e=h.begin[x]<0?n+h.begin[x]:h.begin[x];if(h.begin[x]=e,h.end[x]=h.begin[x]+1,e<0||e>=n)throw Error("slice index ".concat(h.begin[x]," of dimension ").concat(x," out of bounds."))}else h.begin[x]=Bh(h.begin[x],0,h.strides[x],n,a,r),h.end[x]=Bh(h.end[x],1,h.strides[x],n,a,r);const e=1===h.strides[x]&&0===h.begin[x]&&h.end[x]===n;p=p&&e,f=f&&(0===x&&1===h.strides[x]||e)}else p=p&&1===h.strides[x]&&o,f=f&&(0===x&&1===h.strides[x]||o);let s,i=!1;if(h.beginValid&&h.endValid?(s=h.end[x]-h.begin[x],i=!0):t?(s=1,i=!0):o&&n>=0&&(s=h.strides[x]<0?-n:n,i=!0),i){let e;e=0===s||s<0!==h.strides[x]<0?0:Math.trunc(s/h.strides[x])+(s%h.strides[x]!==0?1:0),g.push(e)}else g.push(-1)}for(let x=0;x<h.finalShapeGatherIndices.length;++x){const e=h.finalShapeGatherIndices[x];e>=0?b.push(g[e]):e===wh&&b.push(1)}const y=b.filter(((e,t)=>h.finalShapeGatherIndices[t]!==wh));return{finalShapeSparse:y,finalShape:b,isIdentity:p,sliceDim0:f,isSimpleSlice:m,begin:h.begin,end:h.end,strides:h.strides}}function Bh(e,t,n,a,r,o){if(r[t])return n>0?o[t]:o[t+1&1];{const t=e<0?a+e:e;return t<o[0]?o[0]:t>o[1]?o[1]:t}}const Wh=Pu({all_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const a={x:Mu(e,"x","all","bool")},r={axis:t,keepDims:n};return Cu.runKernel(os,a,r)}});const Vh=Pu({any_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const a={x:Mu(e,"x","any","bool")},r={axis:t,keepDims:n};return Cu.runKernel(ss,a,r)}});const Uh=Pu({argMax_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const n={x:Mu(e,"x","argMax")},a={axis:t};return Cu.runKernel(is,n,a)}});function Gh(e,t,n,a){let r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"NHWC",o=arguments.length>5?arguments[5]:void 0;return Kh(e,[...t,e[3]],n,o,a,null,null,np(r))}function Hh(e,t,n,a,r,o){let s=arguments.length>6&&void 0!==arguments[6]?arguments[6]:"channelsLast";const[i,c]=Yh(t);let l;if("channelsLast"===s)l=[i,c,e[3],e[3]];else{if("channelsFirst"!==s)throw new Error("Unknown dataFormat ".concat(s));l=[i,c,e[1],e[1]]}return Kh(e,l,n,a,r,o,!1,s)}function jh(e,t,n,a,r,o){let s=arguments.length>6&&void 0!==arguments[6]?arguments[6]:"NDHWC";const[i,c,l]=Qh(t);let u,d;if("NDHWC"===s)d="channelsLast",u=[i,c,l,e[4],e[4]];else{if("NCDHW"!==s)throw new Error("Unknown dataFormat ".concat(s));d="channelsFirst",u=[i,c,l,e[1],e[1]]}return qh(e,u,n,a,r,!1,d,o)}function Kh(e,t,n,a,r,o){let s=arguments.length>6&&void 0!==arguments[6]&&arguments[6],i=arguments.length>7&&void 0!==arguments[7]?arguments[7]:"channelsLast",[c,l,u,d]=[-1,-1,-1,-1];if("channelsLast"===i)[c,l,u,d]=e;else{if("channelsFirst"!==i)throw new Error("Unknown dataFormat ".concat(i));[c,d,l,u]=e}const[h,p,,f]=t,[m,g]=Yh(n),[b,y]=Yh(a),x=Jh(h,b),v=Jh(p,y),{padInfo:w,outHeight:k,outWidth:I}=function(e,t,n,a,r,o,s,i,c){let l,u,d;if("number"===typeof e){l={top:e,bottom:e,left:e,right:e,type:0===e?"VALID":"NUMBER"};const r=function(e,t,n,a,r){null==a&&(a=Xh(e,t,n));const o=e[0],s=e[1],i=Zh((o-t+2*a)/n+1,r),c=Zh((s-t+2*a)/n+1,r);return[i,c]}([t,n],o,a,e,i);u=r[0],d=r[1]}else if("same"===e){u=Math.ceil(t/a),d=Math.ceil(n/r);const e=Math.max(0,(u-1)*a+o-t),i=Math.max(0,(d-1)*r+s-n),c=Math.floor(e/2),h=e-c,p=Math.floor(i/2);l={top:c,bottom:h,left:p,right:i-p,type:"SAME"}}else if("valid"===e)l={top:0,bottom:0,left:0,right:0,type:"VALID"},u=Math.ceil((t-o+1)/a),d=Math.ceil((n-s+1)/r);else{if("object"!==typeof e)throw Error("Unknown padding parameter: ".concat(e));{const h="channelsLast"===c?e[1][0]:e[2][0],p="channelsLast"===c?e[1][1]:e[2][1],f="channelsLast"===c?e[2][0]:e[3][0],m="channelsLast"===c?e[2][1]:e[3][1];l={top:h,bottom:p,left:f,right:m,type:0===h&&0===p&&0===f&&0===m?"VALID":"EXPLICIT"},u=Zh((t-o+h+p)/a+1,i),d=Zh((n-s+f+m)/r+1,i)}}return{padInfo:l,outHeight:u,outWidth:d}}(r,l,u,m,g,x,v,o,i),S=s?f*d:f;let N;return"channelsFirst"===i?N=[c,S,k,I]:"channelsLast"===i&&(N=[c,k,I,S]),{batchSize:c,dataFormat:i,inHeight:l,inWidth:u,inChannels:d,outHeight:k,outWidth:I,outChannels:S,padInfo:w,strideHeight:m,strideWidth:g,filterHeight:h,filterWidth:p,effectiveFilterHeight:x,effectiveFilterWidth:v,dilationHeight:b,dilationWidth:y,inShape:e,outShape:N,filterShape:t}}function qh(e,t,n,a,r){let o=arguments.length>5&&void 0!==arguments[5]&&arguments[5],s=arguments.length>6&&void 0!==arguments[6]?arguments[6]:"channelsLast",i=arguments.length>7?arguments[7]:void 0,[c,l,u,d,h]=[-1,-1,-1,-1,-1];if("channelsLast"===s)[c,l,u,d,h]=e;else{if("channelsFirst"!==s)throw new Error("Unknown dataFormat ".concat(s));[c,h,l,u,d]=e}const[p,f,m,,g]=t,[b,y,x]=Qh(n),[v,w,k]=Qh(a),I=Jh(p,v),S=Jh(f,w),N=Jh(m,k),{padInfo:C,outDepth:T,outHeight:E,outWidth:R}=function(e,t,n,a,r,o,s,i,c,l,u){let d,h,p,f;"valid"===e&&(e=0);if("number"===typeof e){d={top:e,bottom:e,left:e,right:e,front:e,back:e,type:0===e?"VALID":"NUMBER"};const m=function(e,t,n,a,r,o){null==r&&(r=Xh(e,t[0],a[0]));const s=[0,0,0,n];for(let i=0;i<3;i++)e[i]+2*r>=t[i]&&(s[i]=Zh((e[i]-t[i]+2*r)/a[i]+1,o));return s}([t,n,a,1],[i,c,l],1,[r,o,s],e,u);h=m[0],p=m[1],f=m[2]}else{if("same"!==e)throw Error("Unknown padding parameter: ".concat(e));{h=Math.ceil(t/r),p=Math.ceil(n/o),f=Math.ceil(a/s);const e=(h-1)*r+i-t,u=(p-1)*o+c-n,m=(f-1)*s+l-a,g=Math.floor(e/2),b=e-g,y=Math.floor(u/2),x=u-y,v=Math.floor(m/2);d={top:y,bottom:x,left:v,right:m-v,front:g,back:b,type:"SAME"}}}return{padInfo:d,outDepth:h,outHeight:p,outWidth:f}}(r,l,u,d,b,y,x,I,S,N,i),_=o?g*h:g;let A;return"channelsFirst"===s?A=[c,_,T,E,R]:"channelsLast"===s&&(A=[c,T,E,R,_]),{batchSize:c,dataFormat:s,inDepth:l,inHeight:u,inWidth:d,inChannels:h,outDepth:T,outHeight:E,outWidth:R,outChannels:_,padInfo:C,strideDepth:b,strideHeight:y,strideWidth:x,filterDepth:p,filterHeight:f,filterWidth:m,effectiveFilterDepth:I,effectiveFilterHeight:S,effectiveFilterWidth:N,dilationDepth:v,dilationHeight:w,dilationWidth:k,inShape:e,outShape:A,filterShape:t}}function Xh(e,t,n){const a=Jh(t,arguments.length>3&&void 0!==arguments[3]?arguments[3]:1);return Math.floor((e[0]*(n-1)-n+a)/2)}function Yh(e){return"number"===typeof e?[e,e,e]:2===e.length?[e[0],e[1],1]:e}function Qh(e){return"number"===typeof e?[e,e,e]:e}function Jh(e,t){return t<=1?e:e+(e-1)*(t-1)}function Zh(e,t){if(!t)return Math.trunc(e);switch(t){case"round":return Math.round(e);case"ceil":return Math.ceil(e);case"floor":return Math.floor(e);default:throw new Error("Unknown roundingMode ".concat(t))}}function $h(e){const[t,n,a]=Yh(e);return 1===t&&1===n&&1===a}function ep(e,t){return $h(e)||$h(t)}function tp(e){return Yh(e).every((e=>e>0))}function np(e){if("NHWC"===e)return"channelsLast";if("NCHW"===e)return"channelsFirst";throw new Error("Unknown dataFormat ".concat(e))}function ap(e,t,n){if(null!=n){if("string"===typeof t)throw Error("Error in ".concat(e,": pad must be an integer when using ")+"dimRoundingMode ".concat(n," but got pad ").concat(t,"."));if("number"===typeof t)mo(vo(t),(()=>"Error in ".concat(e,": pad must be an integer when using ")+"dimRoundingMode ".concat(n," but got pad ").concat(t,".")));else{if("object"!==typeof t)throw Error("Error in ".concat(e,": Unknown padding parameter: ").concat(t));t.forEach((t=>{t.forEach((t=>{mo(vo(t),(()=>"Error in ".concat(e,": pad must be an integer when using ")+"dimRoundingMode ".concat(n," but got pad ").concat(t,".")))}))}))}}}const rp=Pu({reshape_:function(e,t){const n={x:Mu(e,"x","reshape","string_or_numeric")},a={shape:t};return Cu.runKernel(dc,n,a)}});const op=Pu({avgPool_:function(e,t,n,a,r){const o=Mu(e,"x","avgPool","float32");mo(ep(n,1),(()=>"Error in avgPool: Either strides or dilations must be 1. "+"Got strides ".concat(n," and dilations '").concat(1,"'")));let s=o,i=!1;3===o.rank&&(i=!0,s=rp(o,[1,o.shape[0],o.shape[1],o.shape[2]])),mo(4===s.rank,(()=>"Error in avgPool: x must be rank 4 but got rank ".concat(s.rank,"."))),ap("avgPool",a,r);const c={x:s},l={filterSize:t,strides:n,pad:a,dimRoundingMode:r};let u=Cu.runKernel(fs,c,l);return u=Dd(u,o.dtype),i?rp(u,[u.shape[1],u.shape[2],u.shape[3]]):u}});const sp=Pu({avgPool3d_:function(e,t,n,a,r){let o=arguments.length>5&&void 0!==arguments[5]?arguments[5]:"NDHWC";const s=Mu(e,"x","avgPool3d","float32");let i=s,c=!1;4===s.rank&&(c=!0,i=rp(s,[1,s.shape[0],s.shape[1],s.shape[2],s.shape[3]])),mo(5===i.rank,(()=>"Error in avgPool3d: x must be rank 5 but got rank ".concat(i.rank,"."))),mo("NDHWC"===o,(()=>"Error in avgPool3d: Only NDHWC is currently supported, "+"but got dataFormat of ".concat(o))),mo("number"===typeof n&&n>0||Array.isArray(n)&&n[0]>0&&n[1]>0&&n[2]>0,(()=>"Error in avgPool3d: Stride must be > 0, but got '".concat(n,"'"))),ap("avgPool3d",a,r);const l={x:i},u={filterSize:t,strides:n,pad:a,dimRoundingMode:r,dataFormat:o};let d=Cu.runKernel(gs,l,u);return d=Dd(d,i.dtype),c?rp(d,[d.shape[1],d.shape[2],d.shape[3],d.shape[4]]):d}});const ip=Pu({batchNorm_:function(e,t,n,a,r,o){null==o&&(o=.001);const s=Mu(e,"x","batchNorm"),i=Mu(t,"mean","batchNorm"),c=Mu(n,"variance","batchNorm");let l,u;null!=r&&(l=Mu(r,"scale","batchNorm")),null!=a&&(u=Mu(a,"offset","batchNorm")),mo(i.rank===c.rank,(()=>"Batch normalization gradient requires mean and variance to have equal ranks.")),mo(null==u||i.rank===u.rank,(()=>"Batch normalization gradient requires mean and offset to have equal ranks.")),mo(null==l||i.rank===l.rank,(()=>"Batch normalization gradient requires mean and scale to have equal ranks."));const d={x:function(e){let t;return t=0===e.rank||1===e.rank?rp(e,[1,1,1,e.size]):2===e.rank?rp(e,[1,1,e.shape[0],e.shape[1]]):3===e.rank?rp(e,[1,e.shape[0],e.shape[1],e.shape[2]]):e,t}(s),scale:l,offset:u,mean:i,variance:c},h={varianceEpsilon:o},p=Cu.runKernel(ui,d,h);return rp(p,s.shape)}});const cp=Pu({batchNorm2d_:function(e,t,n,a,r,o){const s=Mu(e,"x","batchNorm"),i=Mu(t,"mean","batchNorm"),c=Mu(n,"variance","batchNorm");let l,u;return null!=r&&(l=Mu(r,"scale","batchNorm")),null!=a&&(u=Mu(a,"offset","batchNorm")),mo(2===s.rank,(()=>"Error in batchNorm2D: x must be rank 2 but got rank "+"".concat(s.rank,"."))),mo(2===i.rank||1===i.rank,(()=>"Error in batchNorm2D: mean must be rank 2 or rank 1 but "+"got rank ".concat(i.rank,"."))),mo(2===c.rank||1===c.rank,(()=>"Error in batchNorm2D: variance must be rank 2 or rank 1 "+"but got rank ".concat(c.rank,"."))),null!=l&&mo(2===l.rank||1===l.rank,(()=>"Error in batchNorm2D: scale must be rank 2 or rank 1 "+"but got rank ".concat(l.rank,"."))),null!=u&&mo(2===u.rank||1===u.rank,(()=>"Error in batchNorm2D: offset must be rank 2 or rank 1 "+"but got rank ".concat(u.rank,"."))),ip(s,i,c,u,l,o)}});const lp=Pu({batchNorm3d_:function(e,t,n,a,r,o){const s=Mu(e,"x","batchNorm"),i=Mu(t,"mean","batchNorm"),c=Mu(n,"variance","batchNorm");let l,u;return null!=r&&(l=Mu(r,"scale","batchNorm")),null!=a&&(u=Mu(a,"offset","batchNorm")),mo(3===s.rank,(()=>"Error in batchNorm3D: x must be rank 3 but got rank "+"".concat(s.rank,"."))),mo(3===i.rank||1===i.rank,(()=>"Error in batchNorm3D: mean must be rank 3 or rank 1 but "+"got rank ".concat(i.rank,"."))),mo(3===c.rank||1===c.rank,(()=>"Error in batchNorm3D: variance must be rank 3 or rank 1 "+"but got rank ".concat(c.rank,"."))),null!=l&&mo(3===l.rank||1===l.rank,(()=>"Error in batchNorm3D: scale must be rank 3 or rank 1 "+"but got rank ".concat(l.rank,"."))),null!=u&&mo(3===u.rank||1===u.rank,(()=>"Error in batchNorm3D: offset must be rank 3 or rank 1 "+"but got rank ".concat(u.rank,"."))),ip(s,i,c,u,l,o)}});const up=Pu({batchNorm4d_:function(e,t,n,a,r,o){const s=Mu(e,"x","batchNorm"),i=Mu(t,"mean","batchNorm"),c=Mu(n,"variance","batchNorm");let l,u;return null!=r&&(l=Mu(r,"scale","batchNorm")),null!=a&&(u=Mu(a,"offset","batchNorm")),mo(4===s.rank,(()=>"Error in batchNorm4D: x must be rank 4 but got rank "+"".concat(s.rank,"."))),mo(4===i.rank||1===i.rank,(()=>"Error in batchNorm4D: mean must be rank 4 or rank 1 but "+"got rank ".concat(i.rank,"."))),mo(4===c.rank||1===c.rank,(()=>"Error in batchNorm4D: variance must be rank 4 or rank 1 "+"but got rank ".concat(c.rank,"."))),null!=l&&mo(4===l.rank||1===l.rank,(()=>"Error in batchNorm4D: scale must be rank 4 or rank 1 "+"but got rank ".concat(l.rank,"."))),null!=u&&mo(4===u.rank||1===u.rank,(()=>"Error in batchNorm4D: offset must be rank 4 or rank 1 "+"but got rank ".concat(u.rank,"."))),ip(s,i,c,u,l,o)}});const dp=Pu({broadcastTo_:function(e,t){let n=Mu(e,"broadcastTo","x");const a=n.shape;if(Uo(t),t.length<n.rank)throw new Error("broadcastTo(): shape.length=".concat(t.length," < input.rank=").concat(n.rank,"."));if(t.length>n.rank){const e=n.shape.slice();for(;e.length<t.length;)e.unshift(1);n=rp(n,e)}const r=n.shape,o=Array.from(t);for(let l=t.length-1;l>=0;l--)if(r[l]===t[l])o[l]=1;else if(1!==n.shape[l])throw new Error("broadcastTo(): [".concat(a,"] cannot be broadcast to [").concat(t,"]."));const s=o.map(((e,t)=>e>1?t:-1)).filter((e=>e>=0));if(0===s.length)return Md(n);const i={x:n},c={reps:o};return Cu.runKernel(Jc,i,c)}});const hp=Pu({clipByValue_:function(e,t,n){const a=Mu(e,"x","clipByValue");if(mo(t<=n,(()=>"Error in clip: min (".concat(t,") must be ")+"less than or equal to max (".concat(n,")."))),t===n)return Zd(a.shape,t,a.dtype);const r={x:a},o={clipValueMin:t,clipValueMax:n};return Cu.runKernel(Ns,r,o)}});const pp=Pu({concat_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;mo(e.length>=1,(()=>"Pass at least one tensor to concat"));const n=Lu(e,"tensors","concat","string_or_numeric");if("complex64"===n[0].dtype&&n.forEach((e=>{if("complex64"!==e.dtype)throw new Error("Cannot concatenate complex64 tensors with a tensor\n          with dtype ".concat(e.dtype,". "))})),1===n.length)return Md(n[0]);const a=n,r={axis:t};return Cu.runKernel(Es,a,r)}});const fp=Pu({concat1d_:function(e){return pp(e,0)}});const mp=Pu({concat2d_:function(e,t){return pp(e,t)}});const gp=Pu({concat3d_:function(e,t){return pp(e,t)}});const bp=Pu({concat4d_:function(e,t){return pp(e,t)}});const yp=Pu({conv2d_:function(e,t,n,a){let r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"NHWC",o=arguments.length>5&&void 0!==arguments[5]?arguments[5]:[1,1],s=arguments.length>6?arguments[6]:void 0;const i=Mu(e,"x","conv2d","float32"),c=Mu(t,"filter","conv2d","float32");let l=i,u=!1;3===i.rank&&(u=!0,l=rp(i,[1,i.shape[0],i.shape[1],i.shape[2]])),mo(4===l.rank,(()=>"Error in conv2d: input must be rank 4, but got rank ".concat(l.rank,"."))),mo(4===c.rank,(()=>"Error in conv2d: filter must be rank 4, but got rank "+"".concat(c.rank,"."))),ap("conv2d",a,s);const d="NHWC"===r?l.shape[3]:l.shape[1];mo(d===c.shape[2],(()=>"Error in conv2d: depth of input (".concat(d,") must match ")+"input depth for filter ".concat(c.shape[2],"."))),mo(ep(n,o),(()=>"Error in conv2D: Either strides or dilations must be 1. "+"Got strides ".concat(n," and dilations '").concat(o,"'"))),mo(tp(o),(()=>"Error in conv2D: Dilated rates should be larger than 0.")),mo(tp(n),(()=>"Error in conv2D: Strides should be larger than 0."));const h={x:l,filter:c},p={strides:n,pad:a,dataFormat:r,dilations:o,dimRoundingMode:s},f=Cu.runKernel(Rs,h,p);return u?rp(f,[f.shape[1],f.shape[2],f.shape[3]]):f}});const xp=Pu({conv1d_:function(e,t,n,a){let r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"NWC",o=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,s=arguments.length>6?arguments[6]:void 0;const i=Mu(e,"x","conv1d"),c=Mu(t,"filter","conv1d");let l=i,u=!1;2===i.rank&&(u=!0,l=rp(i,[1,i.shape[0],i.shape[1]])),mo(3===l.rank,(()=>"Error in conv1d: input must be rank 3, but got rank ".concat(l.rank,"."))),mo(3===c.rank,(()=>"Error in conv1d: filter must be rank 3, but got rank "+"".concat(c.rank,"."))),ap("conv1d",a,s),mo(l.shape[2]===c.shape[1],(()=>"Error in conv1d: depth of input (".concat(l.shape[2],") must match ")+"input depth for filter ".concat(c.shape[1],"."))),mo(ep(n,o),(()=>"Error in conv1D: Either stride or dilation must be 1. "+"Got stride ".concat(n," and dilation '").concat(o,"'"))),mo(tp(o),(()=>"Error in conv1D: Dilated rates should be larger than 0.")),mo(tp(n),(()=>"Error in conv1D: Stride should be larger than 0.")),mo("NWC"===r,(()=>"Error in conv1d: got dataFormat of ".concat(r," but only NWC is currently supported.")));const d=rp(c,[1,c.shape[0],c.shape[1],c.shape[2]]),h=rp(l,[l.shape[0],1,l.shape[1],l.shape[2]]),p=yp(h,d,[1,n],a,"NHWC",[1,o],s);return rp(p,u?[p.shape[2],p.shape[3]]:[p.shape[0],p.shape[2],p.shape[3]])}});const vp=Pu({conv2DBackpropInput_:function(e,t,n,a,r){let o=arguments.length>5&&void 0!==arguments[5]?arguments[5]:"NHWC",s=arguments.length>6?arguments[6]:void 0;mo(e.length===t.rank,(()=>"Length of inShape "+"(".concat(e.length,") and rank of dy (").concat(t.rank,") must match")));let i=e,c=t,l=!1;3===t.rank&&(l=!0,c=rp(t,[1,t.shape[0],t.shape[1],t.shape[2]]),i=[1,e[0],e[1],e[2]]),mo(4===i.length,(()=>"Error in conv2dDerInput: inShape must be length 4, but got length "+"".concat(i.length,"."))),mo(4===c.rank,(()=>"Error in conv2dDerInput: dy must be rank 4, but got "+"rank ".concat(c.rank))),mo(4===n.rank,(()=>"Error in conv2dDerInput: filter must be rank 4, but got "+"rank ".concat(n.rank)));const u="NHWC"===o?i[3]:i[1],d="NHWC"===o?c.shape[3]:c.shape[1];mo(u===n.shape[2],(()=>"Error in conv2dDerInput: depth of input (".concat(u,") must ")+"match input depth for filter ".concat(n.shape[2],"."))),mo(d===n.shape[3],(()=>"Error in conv2dDerInput: depth of output (".concat(d,") must ")+"match output depth for filter ".concat(n.shape[3],"."))),ap("conv2dDerInput",r,s);const h={dy:c,filter:n},p={strides:a,pad:r,dataFormat:o,dimRoundingMode:s,inputShape:i},f=Cu.runKernel(As,h,p);return l?rp(f,[f.shape[1],f.shape[2],f.shape[3]]):f}});const wp=Pu({conv2dTranspose_:function(e,t,n,a,r,o){const s=Mu(e,"x","conv2dTranspose"),i=Mu(t,"filter","conv2dTranspose");return vp(n,s,i,a,r,"NHWC",o)}});const kp=Pu({conv3d_:function(e,t,n,a){let r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"NDHWC",o=arguments.length>5&&void 0!==arguments[5]?arguments[5]:[1,1,1];const s=Mu(e,"x","conv3d"),i=Mu(t,"filter","conv3d");let c=s,l=!1;4===s.rank&&(l=!0,c=rp(s,[1,s.shape[0],s.shape[1],s.shape[2],s.shape[3]])),mo(5===c.rank,(()=>"Error in conv3d: input must be rank 5, but got rank ".concat(c.rank,"."))),mo(5===i.rank,(()=>"Error in conv3d: filter must be rank 5, but got rank "+"".concat(i.rank,"."))),mo(c.shape[4]===i.shape[3],(()=>"Error in conv3d: depth of input (".concat(c.shape[4],") must match ")+"input depth for filter ".concat(i.shape[3],"."))),mo(ep(n,o),(()=>"Error in conv3D: Either strides or dilations must be 1. "+"Got strides ".concat(n," and dilations '").concat(o,"'"))),mo("NDHWC"===r,(()=>"Error in conv3d: got dataFormat of ".concat(r," but only NDHWC is currently supported."))),mo(tp(o),(()=>"Error in conv3D: Dilated rates should be larger than 0.")),mo(tp(n),(()=>"Error in conv3D: Strides should be larger than 0."));const u={x:c,filter:i},d={strides:n,pad:a,dataFormat:r,dilations:o},h=Cu.runKernel(Fs,u,d);return l?rp(h,[h.shape[1],h.shape[2],h.shape[3],h.shape[4]]):h}});const Ip=Pu({conv3DBackpropInput_:function(e,t,n,a,r){mo(e.length===t.rank,(()=>"Length of inShape "+"(".concat(e.length,") and rank of dy (").concat(t.rank,") must match")));let o=e,s=t,i=!1;4===t.rank&&(i=!0,s=rp(t,[1,t.shape[0],t.shape[1],t.shape[2],t.shape[3]]),o=[1,e[0],e[1],e[2],e[3]]);const c=o[4],l=s.shape[4];mo(5===o.length,(()=>"Error in conv3dDerInput: inShape must be length 5, but got length "+"".concat(o.length,"."))),mo(5===s.rank,(()=>"Error in conv3dDerInput: dy must be rank 5, but got "+"rank ".concat(s.rank))),mo(5===n.rank,(()=>"Error in conv3dDerInput: filter must be rank 5, but got "+"rank ".concat(n.rank))),mo(c===n.shape[3],(()=>"Error in conv3dDerInput: depth of input (".concat(c,") must ")+"match input depth for filter ".concat(n.shape[3],"."))),mo(l===n.shape[4],(()=>"Error in conv3dDerInput: depth of output (".concat(l,") must ")+"match output depth for filter ".concat(n.shape[4],".")));const u={dy:s,filter:n},d={pad:r,strides:a,inputShape:o},h=Cu.runKernel(Ds,u,d);return i?rp(h,[h.shape[1],h.shape[2],h.shape[3],h.shape[4]]):h}});const Sp=Pu({conv3dTranspose_:function(e,t,n,a,r){const o=Mu(e,"x","conv3dTranspose"),s=Mu(t,"filter","conv3dTranspose");return Ip(n,o,s,a,r)}});const Np=Pu({denseBincount_:function(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const r=Mu(e,"x","denseBincount"),o=Mu(t,"weights","denseBincount");mo("int32"===r.dtype,(()=>"Error in denseBincount: input "+"dtype must be int32, but got ".concat(r.dtype))),mo(r.rank<=2,(()=>"Error in denseBincount: input must be at most rank 2, but got "+"rank ".concat(r.rank,"."))),mo(n>=0,(()=>"size must be non-negative, but got ".concat(n,"."))),mo(o.size===r.size||0===o.size,(()=>"Error in denseBincount: weights must have the same shape as x or "+"0-length, but got x shape: ".concat(r.shape,", weights shape: ")+"".concat(o.shape,".")));const s={x:r,weights:o},i={size:n,binaryOutput:a};return Cu.runKernel(Ws,s,i)}});const Cp=Pu({depthwiseConv2d_:function(e,t,n,a){let r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"NHWC",o=arguments.length>5&&void 0!==arguments[5]?arguments[5]:[1,1],s=arguments.length>6?arguments[6]:void 0;const i=Mu(e,"x","depthwiseConv2d","float32"),c=Mu(t,"filter","depthwiseConv2d","float32");let l=i,u=!1;3===i.rank&&(u=!0,l=rp(i,[1,i.shape[0],i.shape[1],i.shape[2]])),mo(4===l.rank,(()=>"Error in depthwiseConv2d: input must be rank 4, but got "+"rank ".concat(l.rank,"."))),mo(4===c.rank,(()=>"Error in depthwiseConv2d: filter must be rank 4, but got rank "+"".concat(c.rank,".")));const d="NHWC"===r?l.shape[3]:l.shape[1];mo(d===c.shape[2],(()=>"Error in depthwiseConv2d: number of input channels "+"(".concat(d,") must match the inChannels dimension in ")+"filter ".concat(c.shape[2],"."))),ap("depthwiseConv2d",a,s);const h={x:l,filter:c},p={strides:n,pad:a,dataFormat:r,dilations:o,dimRoundingMode:s},f=Cu.runKernel(Us,h,p);return u?rp(f,[f.shape[1],f.shape[2],f.shape[3]]):f}});const Tp=Pu({elu_:function(e){const t={x:Mu(e,"x","elu","float32")};return Cu.runKernel(Zs,t)}});const Ep=Pu({equal_:function(e,t){let n=Mu(e,"a","equal","string_or_numeric"),a=Mu(t,"b","equal","string_or_numeric");[n,a]=yu(n,a),sh(n.shape,a.shape);const r={a:n,b:a};return Cu.runKernel(ti,r)}});const Rp=Pu({exp_:function(e){const t={x:Mu(e,"x","exp")};return Cu.runKernel(ni,t)}});const _p=Pu({expandDims_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const n=Mu(e,"x","expandDims","string_or_numeric");mo(t<=n.rank,(()=>"Axis must be <= rank of the tensor"));const a={input:n},r={dim:t};return Cu.runKernel(ai,a,r)}});const Ap=Pu({tile_:function(e,t){const n=Mu(e,"x","tile","string_or_numeric");mo(n.rank===t.length,(()=>"Error in transpose: rank of input ".concat(n.rank," ")+"must match length of reps ".concat(t,".")));const a={x:n},r={reps:t};return Cu.runKernel(Jc,a,r)}});const Fp=Pu({eye_:function(e,t,n){null==t&&(t=e);const a=Od([e,t],arguments.length>3&&void 0!==arguments[3]?arguments[3]:"float32"),r=e<=t?e:t;for(let s=0;s<r;++s)a.set(1,s,s);const o=rp(a.toTensor(),[e,t]);if(null==n)return o;if(1===n.length)return Ap(_p(o,0),[n[0],1,1]);if(2===n.length)return Ap(_p(_p(o,0),0),[n[0],n[1],1,1]);if(3===n.length)return Ap(_p(_p(_p(o,0),0),0),[n[0],n[1],n[2],1,1]);throw new Error("eye() currently supports only 1D and 2D "+"batchShapes, but received ".concat(n.length,"D."))}});const Op=Pu({floor_:function(e){const t={x:Mu(e,"x","floor","float32")};return Cu.runKernel(ci,t)}});const Dp=Pu({gather_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;const r={x:Mu(e,"x","gather"),indices:Mu(t,"indices","gather","int32")},o={axis:n,batchDims:a};return Cu.runKernel(di,r,o)}});const Mp=Pu({greater_:function(e,t){let n=Mu(e,"a","greater","string_or_numeric"),a=Mu(t,"b","greater","string_or_numeric");[n,a]=yu(n,a),sh(n.shape,a.shape);const r={a:n,b:a};return Cu.runKernel(pi,r)}});const Lp=Pu({greaterEqual_:function(e,t){let n=Mu(e,"a","greaterEqual","string_or_numeric"),a=Mu(t,"b","greaterEqual","string_or_numeric");[n,a]=yu(n,a),sh(n.shape,a.shape);const r={a:n,b:a};return Cu.runKernel(fi,r)}});const Pp=Pu({leakyRelu_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:.2;const n={x:Mu(e,"x","leakyRelu")},a={alpha:t};return Cu.runKernel(wi,n,a)}});const zp=Pu({log_:function(e){const t={x:Mu(e,"x","log","float32")};return Cu.runKernel(Ni,t)}});const Bp=Pu({log1p_:function(e){const t={x:Mu(e,"x","log1p")};return Cu.runKernel(Ci,t)}});const Wp=Pu({max_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const a={x:Mu(e,"x","max")},r={reductionIndices:t,keepDims:n};return Cu.runKernel(Fi,a,r)}});const Vp=Pu({sum_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],a=Mu(e,"x","sum");"bool"===a.dtype&&(a=Dd(a,"int32"));const r={x:a},o={axis:t,keepDims:n};return Cu.runKernel(Fc,r,o)}});const Up=Pu({logSoftmax_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:-1;const n=Mu(e,"logits","logSoftmax");if(-1===t&&(t=n.rank-1),t!==n.rank-1)throw Error("Log Softmax along a non-last dimension is not yet supported. "+"Logits was rank ".concat(n.rank," and axis was ").concat(t));const a=Gd(((e,n)=>{const a=Wp(e,t,!0),r=th(e,a),o=th(Dd(r,"float32"),zp(Vp(Rp(r),t,!0)));n([o]);return{value:o,gradFunc:(e,n)=>{const[a]=n,r=Rp(a);return th(e,Bd(Vp(e,t,!0),r))}}}));return a(n)}});function Gp(e,t){for(let n=0;n<e.length;++n)if(e[e.length-n-1]!==t-1-n)return!1;return!0}function Hp(e,t,n){const a=e.length+t.length,r=[];let o=0,s=0;for(let i=0;i<a;i++)-1===n.indexOf(i)?r.push(e[o++]):r.push(t[s++]);return r}function jp(e,t){const n=[],a=e.length;for(let r=0;r<a;r++)-1===t.indexOf(r)&&n.push(e[r]);return[n,t.map((t=>e[t]))]}function Kp(e,t){return Hp(e,t.map((e=>1)),t)}function qp(e,t,n){mo(Gp(t,n),(()=>"".concat(e," supports only inner-most axes for now. ")+"Got axes ".concat(t," and rank-").concat(n," input.")))}function Xp(e,t){if(Gp(e,t))return null;const n=[];for(let a=0;a<t;++a)-1===e.indexOf(a)&&n.push(a);return e.forEach((e=>n.push(e))),n}function Yp(e){return e.map(((e,t)=>[t,e])).sort(((e,t)=>e[1]-t[1])).map((e=>e[0]))}function Qp(e,t){const n=[];for(let a=t-e;a<t;++a)n.push(a);return n}const Jp=Pu({logSumExp_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const a=Mu(e,"x","logSumExp"),r=No(t,a.shape),o=Wp(a,r,!0),s=th(a,o),i=Rp(s),c=Vp(i,r),l=zp(c),u=Ld(rp(o,l.shape),l);if(n){const e=Kp(u.shape,r);return rp(u,e)}return u}});const Zp=Pu({logicalAnd_:function(e,t){const n=Mu(e,"a","logicalAnd","bool"),a=Mu(t,"b","logicalAnd","bool");sh(n.shape,a.shape);const r={a:n,b:a};return Cu.runKernel(Ti,r)}});const $p=Pu({matMul_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],a=arguments.length>3&&void 0!==arguments[3]&&arguments[3],r=Mu(e,"a","matMul"),o=Mu(t,"b","matMul");[r,o]=yu(r,o);const s={a:r,b:o},i={transposeA:n,transposeB:a};return Cu.runKernel(ys,s,i)}});const ef=Pu({maxPool_:function(e,t,n,a,r){const o=Mu(e,"x","maxPool");let s=o,i=!1;3===o.rank&&(i=!0,s=rp(o,[1,o.shape[0],o.shape[1],o.shape[2]])),mo(4===s.rank,(()=>"Error in maxPool: input must be rank 4 but got rank ".concat(s.rank,"."))),mo(ep(n,1),(()=>"Error in maxPool: Either strides or dilations must be 1. "+"Got strides ".concat(n," and dilations '").concat(1,"'"))),ap("maxPool",a,r);const c={x:s},l={filterSize:t,strides:n,pad:a,dimRoundingMode:r},u=Cu.runKernel(Di,c,l);return i?rp(u,[u.shape[1],u.shape[2],u.shape[3]]):u}});const tf=Pu({maxPool3d_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[1,1,1],n=arguments.length>2?arguments[2]:void 0,a=arguments.length>3?arguments[3]:void 0,r=arguments.length>4?arguments[4]:void 0,o=arguments.length>5&&void 0!==arguments[5]?arguments[5]:"NDHWC";const s=Mu(e,"x","maxPool3d");let i=s,c=!1;4===s.rank&&(c=!0,i=rp(s,[1,s.shape[0],s.shape[1],s.shape[2],s.shape[3]])),mo(5===i.rank,(()=>"Error in maxPool3d: x must be rank 5 but got rank ".concat(i.rank,"."))),mo("NDHWC"===o,(()=>"Error in maxPool3d: Only NDHWC is currently supported, "+"but got dataFormat of ".concat(o))),ap("maxPool3d",a,r);const l={x:i},u={filterSize:t,strides:n,pad:a,dimRoundingMode:r,dataFormat:o},d=Cu.runKernel(Li,l,u);return c?rp(d,[d.shape[1],d.shape[2],d.shape[3],d.shape[4]]):d}});const nf=Pu({mean_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const a={x:Mu(e,"x","mean")},r={axis:t,keepDims:n};return Cu.runKernel(Bi,a,r)}});const af=Pu({min_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const a={x:Mu(e,"x","min")},r={axis:t,keepDims:n};return Cu.runKernel(Wi,a,r)}});const rf=Pu({minimum_:function(e,t){let n=Mu(e,"a","minimum"),a=Mu(t,"b","minimum");[n,a]=yu(n,a),"bool"===n.dtype&&(n=Dd(n,"int32"),a=Dd(a,"int32")),sh(n.shape,a.shape);const r={a:n,b:a};return Cu.runKernel(Vi,r)}});const of=Pu({moments_:function(e){let t=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const n=No(arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,(e=Mu(e,"x","moments")).shape),a=nf(e,n,t);let r=a.shape;t||(r=Kp(a.shape,n));const o=Vd(th(Dd(e,"float32"),rp(a,r)));return{mean:a,variance:nf(o,n,t)}}});const sf=Pu({neg_:function(e){const t={x:Mu(e,"x","neg")};return Cu.runKernel(Ki,t)}});const cf=Pu({notEqual_:function(e,t){let n=Mu(e,"a","notEqual","string_or_numeric"),a=Mu(t,"b","notEqual","string_or_numeric");[n,a]=yu(n,a),sh(n.shape,a.shape);const r={a:n,b:a};return Cu.runKernel(qi,r)}});const lf=Pu({oneHot_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0,r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"int32";if(t<2)throw new Error("Error in oneHot: depth must be >=2, but it is ".concat(t));const o={indices:Mu(e,"indices","oneHot","int32")},s={dtype:r,depth:t,onValue:n,offValue:a};return Cu.runKernel(Zi,o,s)}});function uf(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"float32";if(Uo(e),"complex64"===t){const t=uf(e,"float32"),n=uf(e,"float32");return zu(t,n)}const n=Wo(yo(e),t);return Cu.makeTensor(n,e,t)}function df(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"float32";if(Uo(e),"complex64"===t){const t=df(e,"float32"),n=uf(e,"float32");return zu(t,n)}const n=Bo(yo(e),t);return Cu.makeTensor(n,e,t)}const hf=Pu({onesLike_:function(e){const t={x:Mu(e,"x","onesLike")};return Cu.runKernel(Ji,t)}});const pf=Pu({pad_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;const a=Mu(e,"x","pad");if(0===a.rank)throw new Error("pad(scalar) is not defined. Pass non-scalar to pad");const r={paddings:t,constantValue:n},o={x:a};return Cu.runKernel(ec,o,r)}});const ff=Pu({prelu_:function(e,t){const n={x:Mu(e,"x","prelu"),alpha:Mu(t,"alpha","prelu")};return Cu.runKernel(nc,n)}});var mf=n(334);class gf{constructor(e,t,n,a,r){this.mean=e,this.stdDev=t,this.dtype=n,this.nextVal=NaN,this.truncated=a,this.truncated&&(this.upper=this.mean+2*this.stdDev,this.lower=this.mean-2*this.stdDev);const o=r||Math.random();this.random=mf.alea(o.toString())}nextValue(){if(!isNaN(this.nextVal)){const e=this.nextVal;return this.nextVal=NaN,e}let e,t,n=!1;for(;!n;){let a,r,o;do{a=2*this.random()-1,r=2*this.random()-1,o=a*a+r*r}while(o>=1||0===o);const s=Math.sqrt(-2*Math.log(o)/o);e=this.mean+this.stdDev*a*s,t=this.mean+this.stdDev*r*s,this.truncated&&!this.isValidTruncated(e)||(n=!0)}return this.truncated&&!this.isValidTruncated(t)||(this.nextVal=this.convertValue(t)),this.convertValue(e)}convertValue(e){return null==this.dtype||"float32"===this.dtype?e:Math.round(e)}isValidTruncated(e){return e<=this.upper&&e>=this.lower}}class bf{constructor(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,n=arguments.length>2?arguments[2]:void 0,a=arguments.length>3?arguments[3]:void 0;if(this.canReturnFloat=()=>null==this.dtype||"float32"===this.dtype,this.min=e,this.range=t-e,this.dtype=n,null==a&&(a=Math.random()),"number"===typeof a&&(a=a.toString()),!this.canReturnFloat()&&this.range<=1)throw new Error("The difference between ".concat(e," - ").concat(t," <= 1 and dtype is not float"));this.random=mf.alea(a)}convertValue(e){return this.canReturnFloat()?e:Math.round(e)}nextValue(){return this.convertValue(this.min+this.range*this.random())}}const yf=Pu({randomNormal_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,a=arguments.length>3?arguments[3]:void 0,r=arguments.length>4?arguments[4]:void 0;if(Uo(e),null!=a&&"bool"===a)throw new Error("Unsupported data type ".concat(a));const o=new gf(t,n,a,!1,r),s=Od(e,a);for(let i=0;i<s.values.length;i++)s.values[i]=o.nextValue();return s.toTensor()}});const xf=Pu({randomUniform_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"float32",r=arguments.length>4?arguments[4]:void 0;Uo(e);const o=Od(e,a),s=new bf(t,n,null,r);for(let i=0;i<o.values.length;i++)o.values[i]=s.nextValue();return o.toTensor()}});function vf(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"float32";if(0===n)throw new Error("Cannot have a step of zero");const r={start:e,stop:t,step:n,dtype:a};return Cu.runKernel(ic,{},r)}const wf=Pu({relu_:function(e){const t={x:Mu(e,"x","relu")};return Cu.runKernel(uc,t)}});const kf=Pu({reverse_:function(e,t){const n={x:Mu(e,"x","reverse")},a={dims:t};return Cu.runKernel(bc,n,a)}});const If=Pu({selu_:function(e){const t={x:Mu(e,"x","selu")};return Cu.runKernel(Sc,t)}});const Sf=Pu({separableConv2d_:function(e,t,n,a,r){let o=arguments.length>5&&void 0!==arguments[5]?arguments[5]:[1,1],s=arguments.length>6&&void 0!==arguments[6]?arguments[6]:"NHWC";const i=Mu(e,"x","separableConv2d"),c=Mu(t,"depthwiseFilter","separableConv2d"),l=Mu(n,"pointwiseFilter","separableConv2d");let u=i,d=!1;if(3===i.rank&&(d=!0,u=rp(i,[1,i.shape[0],i.shape[1],i.shape[2]])),"NCHW"===s)throw new Error("separableConv2d currently does not support dataFormat NCHW; only NHWC is supported");mo(4===u.rank,(()=>"Error in separableConv2d: input must be rank 4, but got "+"rank ".concat(u.rank,"."))),mo(4===c.rank,(()=>"Error in separableConv2d: depthwise filter must be rank 4, but "+"got rank ".concat(c.rank,"."))),mo(4===l.rank,(()=>"Error in separableConv2d: pointwise filter must be rank 4, but "+"got rank ".concat(c.rank,"."))),mo(1===l.shape[0],(()=>"Error in separableConv2d: the first dimension of pointwise filter "+" must be 1, but got ".concat(l.shape[0],"."))),mo(1===l.shape[1],(()=>"Error in separableConv2d: the second dimension of pointwise "+"filter must be 1, but got ".concat(l.shape[1],".")));const h=c.shape[2],p=c.shape[3];mo(l.shape[2]===h*p,(()=>"Error in separableConv2d: the third dimension of pointwise filter "+"must be ".concat(h*p,", ")+"but got ".concat(l.shape[2],".")));const f=Cp(u,c,a,r,s,o),m=yp(f,l,1,"valid",s);return d?rp(m,[m.shape[1],m.shape[2],m.shape[3]]):m}});const Nf=Pu({sigmoid_:function(e){const t={x:Mu(e,"x","sigmoid","float32")};return Cu.runKernel(Rc,t)}});const Cf=Pu({slice_:function(e,t,n){const a=Mu(e,"x","slice","string_or_numeric");if(0===a.rank)throw new Error("Slicing scalar is not possible");const r={x:a},o={begin:t,size:n};return Cu.runKernel(Nc,r,o)}});const Tf=Pu({slice1d_:function(e,t,n){const a=Mu(e,"x","slice1d");return mo(1===a.rank,(()=>"slice1d expects a rank-1 tensor, but got a rank-".concat(a.rank," tensor"))),Cf(a,[t],[n])}});const Ef=Pu({slice2d_:function(e,t,n){const a=Mu(e,"x","slice2d");return mo(2===a.rank,(()=>"slice2d expects a rank-2 tensor, but got a rank-".concat(a.rank," tensor"))),Cf(a,t,n)}});const Rf=Pu({slice3d_:function(e,t,n){const a=Mu(e,"x","slice3d");return mo(3===a.rank,(()=>"slice3d expects a rank-3 tensor, but got a rank-".concat(a.rank," tensor"))),Cf(a,t,n)}});const _f=Pu({slice4d_:function(e,t,n){const a=Mu(e,"x","slice4d");return mo(4===a.rank,(()=>"slice4d expects a rank-4 tensor, but got a rank-".concat(a.rank," tensor"))),Cf(a,t,n)}});const Af=Pu({softmax_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:-1;const n=Mu(e,"logits","softmax","float32");if(-1===t&&(t=n.rank-1),t!==n.rank-1)throw Error("Softmax along a non-last dimension is not yet supported. "+"Logits was rank ".concat(n.rank," and dim was ").concat(t));const a={logits:n},r={dim:t};return Cu.runKernel(Mc,a,r)}});const Ff=Pu({softplus_:function(e){const t={x:Mu(e,"x","softplus")};return Cu.runKernel(_c,t)}});const Of=Pu({split_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;const a={x:Mu(e,"x","split")},r={numOrSizeSplits:t,axis:n};return Cu.runKernel(Dc,a,r)}});const Df=Pu({squeeze_:function(e,t){const n=Mu(e,"x","squeeze","string_or_numeric");return rp(n,Co(n.shape,t).newShape)}});const Mf=Pu({stack_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const n=Lu(e,"tensors","stack","string_or_numeric");mo(n.length>=1,(()=>"Pass at least one tensor to tf.stack")),n.length>0&&mo(t<=n[0].rank,(()=>"Axis must be <= rank of the tensor"));const a=n,r={axis:t};return Cu.runKernel($i,a,r)}});const Lf=Pu({tanh_:function(e){const t={x:Mu(e,"x","tanh","float32")};return Cu.runKernel(Qc,t)}});function Pf(e,t){bo(e);const n=Fu(e,t);if(1!==n.length)throw new Error("tensor1d() requires values to be a flat/TypedArray");return Bu(e,null,n,t)}function zf(e,t,n){if(bo(e),null!=t&&2!==t.length)throw new Error("tensor2d() requires shape to have two numbers");const a=Fu(e,n);if(2!==a.length&&1!==a.length)throw new Error("tensor2d() requires values to be number[][] or flat/TypedArray");if(1===a.length&&null==t)throw new Error("tensor2d() requires shape to be provided when `values` are a flat/TypedArray");return Bu(e,t,a,n)}const Bf=Pu({truncatedNormal_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,a=arguments.length>3?arguments[3]:void 0,r=arguments.length>4?arguments[4]:void 0;if(Uo(e),null!=a&&"bool"===a)throw new Error("Unsupported data type $ { dtype }");const o=new gf(t,n,a,!0,r),s=Od(e,a);for(let i=0;i<s.values.length;i++)s.values[i]=o.nextValue();return s.toTensor()}});const Wf=Pu({unstack_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const n=Mu(e,"x","unstack","string_or_numeric");mo(t>=-n.shape.length&&t<n.shape.length,(()=>"Axis = ".concat(t," is not in [-").concat(n.shape.length,", ").concat(n.shape.length,")")));const a={value:n},r={axis:t};return Cu.runKernel(nl,a,r)}});const Vf=Pu({where_:function(e,t,n){const a=Mu(t,"a","where"),r=Mu(n,"b","where"),o=Mu(e,"condition","where","bool"),s=sh(sh(o.shape,a.shape),r.shape),i={condition:dp(o,s),t:dp(a,s),e:dp(r,s)};return Cu.runKernel(Ic,i)}});const Uf=Pu({imag_:function(e){const t={input:Mu(e,"input","imag")};return Cu.runKernel(bi,t)}});const Gf=Pu({real_:function(e){const t={input:Mu(e,"input","real")};return Cu.runKernel(cc,t)}});const Hf=Pu({transpose_:function(e,t,n){const a=Mu(e,"x","transpose");if(null==t&&(t=a.shape.map(((e,t)=>t)).reverse()),mo(a.rank===t.length,(()=>"Error in transpose: rank of input ".concat(a.rank," ")+"must match length of perm ".concat(t,"."))),t.forEach((e=>{mo(e>=0&&e<a.rank,(()=>"All entries in 'perm' must be between 0 and ".concat(a.rank-1)+" but got ".concat(t)))})),a.rank<=1)return a.clone();const r={x:a},o={perm:t};return"complex64"===a.dtype?Hu((()=>{let e=Gf(a),t=Uf(a);return e=Cu.runKernel(el,{x:e},o),t=Cu.runKernel(el,{x:t},o),n&&(t=sf(t)),zu(e,t)})):Cu.runKernel(el,r,o)}});const jf=Pu({dropout_:function(e,t,n,a){const r=Mu(e,"x","dropout");if(mo("float32"===r.dtype,(()=>"x has to be a floating point tensor since it's going to be "+"scaled, but got a ".concat(r.dtype," tensor instead."))),mo(t>=0&&t<1,(()=>"rate must be a float in the range [0, 1), but got ".concat(t,"."))),0===t)return e instanceof ou?r.clone():r;const o=function(e,t){if(null==t)return e.shape.slice();if(xo(e.shape,t))return t;if(e.shape.length===t.length){const n=[];for(let a=0;a<e.shape.length;a++)null==t[a]&&null!=e.shape[a]?n.push(e.shape[a]):n.push(t[a]);return n}return t}(r,n),s=1-t,i=zd(Op(Ld(xf(o,0,1,"float32",a),s)),s);return Bd(r,i)}});const Kf=Pu({fft_:function(e){mo("complex64"===e.dtype,(()=>"The dtype for tf.spectral.fft() must be complex64 "+"but got ".concat(e.dtype,".")));const t={input:e};return Cu.runKernel(oi,t)}});const qf=Pu({rfft_:function(e,t){mo("float32"===e.dtype,(()=>"The dtype for rfft() must be real value but got ".concat(e.dtype)));let n=e.shape[e.shape.length-1];const a=e.size/n;let r;if(null!=t&&t<n){const a=e.shape.map((e=>0)),o=e.shape.map((e=>e));o[e.shape.length-1]=t,r=Cf(e,a,o),n=t}else if(null!=t&&t>n){const a=e.shape.map((e=>e));a[e.shape.length-1]=t-n,r=pp([e,uf(a)],e.shape.length-1),n=t}else r=e;const o=Ud(r),s=rp(zu(r,o),[a,n]),i=Kf(s),c=Math.floor(n/2)+1,l=Gf(i),u=Uf(i),d=Of(l,[c,n-c],l.shape.length-1),h=Of(u,[c,n-c],u.shape.length-1),p=r.shape.slice();return p[r.shape.length-1]=c,rp(zu(d[0],h[0]),p)}});const Xf=Pu({ifft_:function(e){mo("complex64"===e.dtype,(()=>"The dtype for tf.spectral.ifft() must be complex64 "+"but got ".concat(e.dtype,".")));const t={input:e};return Cu.runKernel(gi,t)}});const Yf=Pu({irfft_:function(e){const t=e.shape[e.shape.length-1],n=e.size/t;let a;if(t<=2){const r=rp(e,[n,t]);a=Xf(r)}else{const r=[n,2*(t-1)],o=rp(Gf(e),[n,t]),s=rp(Uf(e),[n,t]),i=kf(Cf(o,[0,1],[n,t-2]),1),c=Bd(kf(Cf(s,[0,1],[n,t-2]),1),Hd(-1)),l=pp([o,i],1),u=pp([s,c],1),d=rp(zu(l,u),[r[0],r[1]]);a=Xf(d)}if(a=Gf(a),3===e.rank&&0!==e.shape[0]){const t=a,n=e.shape[0];a=rp(a,[n,a.shape[0]/n,a.shape[1]]),t.dispose()}return a}});const Qf=Pu({conv2DBackpropFilter_:function(e,t,n,a,r){let o=arguments.length>5&&void 0!==arguments[5]?arguments[5]:"NHWC",s=arguments.length>6?arguments[6]:void 0,i=e;3===e.rank&&(i=rp(e,[1,e.shape[0],e.shape[1],e.shape[2]]));let c=t;3===c.rank&&(c=rp(t,[1,t.shape[0],t.shape[1],t.shape[2]])),mo(4===i.rank,(()=>"Error in conv2dDerFilter: input must be rank 4, but got shape "+"".concat(i.shape,"."))),mo(4===c.rank,(()=>"Error in conv2dDerFilter: dy must be rank 4, but got shape "+"".concat(c.shape,"."))),mo(4===n.length,(()=>"Error in conv2dDerFilter: filterShape must be length 4, but got "+"".concat(n,".")));const l="NHWC"===o?i.shape[3]:i.shape[1],u="NHWC"===o?c.shape[3]:c.shape[1];mo(l===n[2],(()=>"Error in conv2dDerFilter: depth of input ".concat(l,") must ")+"match input depth in filter (".concat(n[2],"."))),mo(u===n[3],(()=>"Error in conv2dDerFilter: depth of dy (".concat(u,") must ")+"match output depth for filter (".concat(n[3],")."))),ap("conv2dDerFilter",r,s);const d={x:i,dy:c},h={strides:a,pad:r,dataFormat:o,dimRoundingMode:s,filterShape:n};return Cu.runKernel(_s,d,h)}});const Jf=Pu({relu6_:function(e){const t={x:Mu(e,"x","relu6")};return Cu.runKernel(gc,t)}});const Zf=Pu({step_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const n={x:Mu(e,"x","step")},a={alpha:t};return Cu.runKernel(ol,n,a)}});function $f(e,t,n){if(null==n||"linear"===n)return e;if("relu"===n)return Bd(e,Zf(t));throw new Error("Cannot compute gradient for fused activation ".concat(n,"."))}function em(e,t){let n=t;const a=oh(e.shape,t.shape);return a.length>0&&(n=Vp(n,a)),rp(n,e.shape)}function tm(e,t,n,a){if("linear"===t)return e;if("relu"===t)return wf(e);if("elu"===t)return Tp(e);if("relu6"===t)return Jf(e);if("prelu"===t)return ff(e,n);if("leakyrelu"===t)return Pp(e,a);if("sigmoid"===t)return Nf(e);throw new Error("Unknown fused activation ".concat(t,"."))}const nm=(e,t)=>!(e>0)||"linear"===t;const am=Pu({fusedConv2d_:function(e){let{x:t,filter:n,strides:a,pad:r,dataFormat:o="NHWC",dilations:s=[1,1],dimRoundingMode:i,bias:c,activation:l="linear",preluActivationWeights:u,leakyreluAlpha:d}=e;if(l=l||"linear",!1===nm(Cu.state.gradientDepth,l)){mo("NHWC"===o,(()=>"Error in fused conv2d: got dataFormat of ".concat(o," but ")+"only NHWC is currently supported for the case of gradient depth is 0 and the activation is not linear."));let e=yp(t,n,a,r,o,s,i);return null!=c&&(e=Ld(e,c)),tm(e,l,u,d)}const h=Mu(t,"x","conv2d","float32"),p=Mu(n,"filter","conv2d","float32");let f=h,m=!1;3===h.rank&&(m=!0,f=rp(h,[1,h.shape[0],h.shape[1],h.shape[2]])),mo(4===f.rank,(()=>"Error in fused conv2d: input must be rank 4, but got rank "+"".concat(f.rank,"."))),mo(4===p.rank,(()=>"Error in fused conv2d: filter must be rank 4, but got rank "+"".concat(p.rank,"."))),ap("fused conv2d",r,i);const g="NHWC"===o?f.shape[3]:f.shape[1];mo(p.shape[2]===g,(()=>"Error in conv2d: depth of input (".concat(g,") must match ")+"input depth for filter ".concat(p.shape[2],"."))),mo(ep(a,s),(()=>"Error in conv2D: Either strides or dilations must be 1. "+"Got strides ".concat(a," and dilations '").concat(s,"'")));const b=Kh(f.shape,p.shape,a,s,r,i);let y,x;if(null!=c&&(y=Mu(c,"bias","fused conv2d"),[y]=yu(y,h),"NHWC"===o?sh(b.outShape,y.shape):(mo(y.shape.length<=1,(()=>"Error in fused conv2d: only supports scalar or 1-D Tensor bias for NCHW format but got the bias of "+"rank-".concat(y.shape.length,"."))),mo(0===y.shape.length||y.shape[0]===b.outChannels||1===y.shape[0],(()=>"Error in fused conv2d: bias shape (".concat(y.shape,") is not ")+"compatible with the number of output channels "+"(".concat(b.outChannels,")"))))),null!=u){const e=u.shape;if(mo(e.length<=1||3===e.length,(()=>"Error in fused conv2d: only supports scalar, 1-D Tensor or 3-D Tensor PReLU activation weights but got a tensor of "+"rank-".concat(e.length,"."))),1===e.length)mo(1===e[0]||e[0]===b.outChannels,(()=>"Error in fused conv2d: PReLU activation weights "+"(".concat(e,") is not compatible with the number of output ")+"channels (".concat(b.outChannels,").")));else if(3===e.length)try{sh(e,b.outShape)}catch(B){const n="Error in fused conv2d: PReLU activation weights (".concat(e,") ")+"is not compatible with the output shape of the conv2d "+"(".concat(b.outShape,").");throw Error(n)}x=Mu(u,"prelu weights","fused conv2d")}const v=(e,t)=>{mo("NHWC"===o,(()=>"Error in gradient of fused conv2D: got dataFormat of ".concat(o," but only NHWC is currently supported.")));const[n,i,c,u]=t,d=$f(e,c,l);mo($h(s),(()=>"Error in gradient of fused conv2D: dilation rates greater than 1 "+"are not yet supported in gradients. Got dilations '".concat(s,"'")));const h=[vp(i.shape,d,n,a,r),Qf(i,d,n.shape,a,r)];if(null!=u){const e=em(u,d);h.push(e)}return h},w={x:f,filter:p,bias:y,preluActivationWeights:x},k={strides:a,pad:r,dataFormat:o,dilations:s,dimRoundingMode:i,activation:l,leakyreluAlpha:d};if(null==c){const e=Gd(((e,t,n)=>{let a=Cu.runKernel(ll,w,k);return n([t,e,a]),m&&(a=rp(a,[a.shape[1],a.shape[2],a.shape[3]])),{value:a,gradFunc:v}}));return e(f,p)}{const e=Gd(((e,t,n,a)=>{let r=Cu.runKernel(ll,w,k);return a([t,e,r,n]),m&&(r=rp(r,[r.shape[1],r.shape[2],r.shape[3]])),{value:r,gradFunc:v}}));return e(f,p,y)}}});const rm=Pu({depthwiseConv2dNativeBackpropFilter_:function(e,t,n,a,r){let o=arguments.length>5&&void 0!==arguments[5]?arguments[5]:[1,1],s=arguments.length>6?arguments[6]:void 0,i=e;3===e.rank&&(i=rp(e,[1,e.shape[0],e.shape[1],e.shape[2]]));let c=t;3===c.rank&&(c=rp(t,[1,t.shape[0],t.shape[1],t.shape[2]]));const l={x:i,dy:c},u={strides:a,pad:r,dimRoundingMode:s,dilations:o,filterShape:n};return Cu.runKernel(Gs,l,u)}});const om=Pu({depthwiseConv2dNativeBackpropInput_:function(e,t,n,a,r){let o=arguments.length>5&&void 0!==arguments[5]?arguments[5]:[1,1],s=arguments.length>6?arguments[6]:void 0,i=t,c=!1;3===t.rank&&(c=!0,i=rp(t,[1,t.shape[0],t.shape[1],t.shape[2]]));const l={dy:i,filter:n},u={strides:a,pad:r,dimRoundingMode:s,dilations:o,inputShape:e},d=Cu.runKernel(Hs,l,u);return c?rp(d,[d.shape[1],d.shape[2],d.shape[3]]):d}});const sm=Pu({fusedMatMul_:function(e){let{a:t,b:n,transposeA:a=!1,transposeB:r=!1,bias:o,activation:s="linear",preluActivationWeights:i,leakyreluAlpha:c=.2}=e;if(!1===nm(Cu.state.gradientDepth,s)){let e=$p(t,n,a,r);return null!=o&&(e=Ld(e,o)),tm(e,s,i,c)}let l=Mu(t,"a","fused matMul"),u=Mu(n,"b","fused matMul");[l,u]=yu(l,u);const d=a?l.shape[l.rank-2]:l.shape[l.rank-1],h=r?u.shape[u.rank-1]:u.shape[u.rank-2],p=a?l.shape[l.rank-1]:l.shape[l.rank-2],f=r?u.shape[u.rank-2]:u.shape[u.rank-1],m=l.shape.slice(0,-2),g=u.shape.slice(0,-2),b=yo(m),y=yo(g);mo(d===h,(()=>"Error in fused matMul: inner shapes (".concat(d,") and (")+"".concat(h,") of Tensors with shapes ").concat(l.shape," and ")+"".concat(u.shape," and transposeA=").concat(a)+" and transposeB=".concat(r," must match.")));const x=sh(l.shape.slice(0,-2),u.shape.slice(0,-2)).concat([p,f]),v=rp(l,a?[b,d,p]:[b,p,d]),w=rp(u,r?[y,f,h]:[y,h,f]);let k,I;null!=o&&(k=Mu(o,"bias","fused matMul"),[k]=yu(k,l),sh(x,k.shape)),null!=i&&(I=Mu(i,"prelu weights","fused matMul"));const S=(e,t)=>{const[n,i,c,l]=t,u=$f(rp(e,c.shape),c,s);let d,h;if(a||r?!a&&r?(d=$p(u,i,!1,!1),h=$p(u,n,!0,!1)):a&&!r?(d=$p(i,u,!1,!0),h=$p(n,u,!1,!1)):(d=$p(i,u,!0,!0),h=$p(u,n,!0,!0)):(d=$p(u,i,!1,!0),h=$p(n,u,!0,!1)),null!=o){return[d,h,em(l,u)]}return[d,h]},N={a:v,b:w,bias:k,preluActivationWeights:I},C={transposeA:a,transposeB:r,activation:s,leakyreluAlpha:c};if(null==o){const e=Gd(((e,t,n)=>{const a=Cu.runKernel(cl,N,C);return n([e,t,a]),{value:rp(a,x),gradFunc:S}}));return e(v,w)}{const e=Gd(((e,t,n,a)=>{const r=Cu.runKernel(cl,N,C);return a([e,t,r,n]),{value:rp(r,x),gradFunc:S}}));return e(v,w,k)}}});const im=Pu({cropAndResize_:function(e,t,n,a){let r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"bilinear",o=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0;const s=Mu(e,"image","cropAndResize"),i=Mu(t,"boxes","cropAndResize","float32"),c=Mu(n,"boxInd","cropAndResize","int32"),l=i.shape[0];mo(4===s.rank,(()=>"Error in cropAndResize: image must be rank 4,"+"but got rank ".concat(s.rank,"."))),mo(2===i.rank&&4===i.shape[1],(()=>"Error in cropAndResize: boxes must be have size [".concat(l,",4] ")+"but had shape ".concat(i.shape,"."))),mo(1===c.rank&&c.shape[0]===l,(()=>"Error in cropAndResize: boxInd must be have size [".concat(l,"] ")+"but had shape ".concat(i.shape,"."))),mo(2===a.length,(()=>"Error in cropAndResize: cropSize must be of length 2, but got "+"length ".concat(a.length,"."))),mo(a[0]>=1&&a[1]>=1,(()=>"cropSize must be atleast [1,1], but was ".concat(a))),mo("bilinear"===r||"nearest"===r,(()=>"method must be bilinear or nearest, but was ".concat(r)));const u={image:s,boxes:i,boxInd:c},d={method:r,extrapolationValue:o,cropSize:a};return Cu.runKernel(Bs,u,d)}});const cm=Pu({flipLeftRight_:function(e){const t=Mu(e,"image","flipLeftRight","float32");mo(4===t.rank,(()=>"Error in flipLeftRight: image must be rank 4,"+"but got rank ".concat(t.rank,".")));const n={image:t};return Cu.runKernel(ii,n,{})}});const lm=Pu({grayscaleToRGB_:function(e){const t=Mu(e,"image","grayscaleToRGB"),n=t.rank-1,a=t.shape[n];mo(t.rank>=2,(()=>"Error in grayscaleToRGB: images must be at least rank 2, "+"but got rank ".concat(t.rank,"."))),mo(1===a,(()=>"Error in grayscaleToRGB: last dimension of a grayscale image "+"should be size 1, but got size ".concat(a,".")));const r=new Array(t.rank);return r.fill(1,0,n),r[n]=3,Ap(t,r)}});const um=Pu({einsum_:function(e){for(var t=arguments.length,n=new Array(t>1?t-1:0),a=1;a<t;a++)n[a-1]=arguments[a];const r=n.map(((e,t)=>Mu(e,"tensors".concat(t),"einsum"))),o={equation:e};return Cu.runKernel(Js,r,o)}});const dm=Pu({rgbToGrayscale_:function(e){const t=Mu(e,"image","RGBToGrayscale"),n=t.rank-1,a=t.shape[n];mo(t.rank>=2,(()=>"Error in RGBToGrayscale: images must be at least rank 2, "+"but got rank ".concat(t.rank,"."))),mo(3===a,(()=>"Error in RGBToGrayscale: last dimension of an RGB image "+"should be size 3, but got size ".concat(a,".")));const r=t.dtype,o=Dd(t,"float32"),s=Pf([.2989,.587,.114]);let i;switch(t.rank){case 2:i=um("ij,j->i",o,s);break;case 3:i=um("ijk,k->ij",o,s);break;case 4:i=um("ijkl,l->ijk",o,s);break;case 5:i=um("ijklm,m->ijkl",o,s);break;case 6:i=um("ijklmn,n->ijklm",o,s);break;default:throw new Error("Not a valid tensor rank.")}return i=_p(i,-1),Dd(i,r)}});const hm=Pu({rotateWithOffset_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:.5;const r=Mu(e,"image","rotateWithOffset","float32");mo(4===r.rank,(()=>"Error in rotateWithOffset: image must be rank 4,"+"but got rank ".concat(r.rank,".")));const o={image:r},s={radians:t,fillValue:n,center:a};return Cu.runKernel(il,o,s)}});function pm(e,t,n,a,r,o){null==a&&(a=.5),null==r&&(r=Number.NEGATIVE_INFINITY),null==o&&(o=0);const s=e.shape[0];return n=Math.min(n,s),mo(0<=a&&a<=1,(()=>"iouThreshold must be in [0, 1], but was '".concat(a,"'"))),mo(2===e.rank,(()=>"boxes must be a 2D tensor, but was of rank '".concat(e.rank,"'"))),mo(4===e.shape[1],(()=>"boxes must have 4 columns, but 2nd dimension was ".concat(e.shape[1]))),mo(1===t.rank,(()=>"scores must be a 1D tensor")),mo(t.shape[0]===s,(()=>"scores has incompatible shape with boxes. Expected ".concat(s,", ")+"but was ".concat(t.shape[0]))),mo(0<=o&&o<=1,(()=>"softNmsSigma must be in [0, 1], but was '".concat(o,"'"))),{maxOutputSize:n,iouThreshold:a,scoreThreshold:r,softNmsSigma:o}}const fm=Pu({nonMaxSuppression_:function(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:.5,r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:Number.NEGATIVE_INFINITY;const o=Mu(e,"boxes","nonMaxSuppression","float32"),s=Mu(t,"scores","nonMaxSuppression","float32"),i=pm(o,s,n,a,r);n=i.maxOutputSize,a=i.iouThreshold,r=i.scoreThreshold;const c={maxOutputSize:n,iouThreshold:a,scoreThreshold:r};return Cu.runKernel(Xi,{boxes:o,scores:s},c)}});function mm(e,t,n){const a=function(e,t,n){return function(e,t,n){let a=0,r=e.length,o=0,s=!1;for(;a<r;){o=a+(r-a>>>1);const i=n(t,e[o]);i>0?a=o+1:(r=o,s=!i)}return s?a:-a-1}(e,t,n||gm)}(e,t,n),r=a<0?-(a+1):a;e.splice(r,0,t)}function gm(e,t){return e>t?1:e<t?-1:0}function bm(e,t,n,a,r){return vm(e,t,n,a,r,0)}function ym(e,t,n,a,r,o){return vm(e,t,n,a,r,0,!1,o,!0)}function xm(e,t,n,a,r,o){return vm(e,t,n,a,r,o,!0)}function vm(e,t,n,a,r,o){let s=arguments.length>6&&void 0!==arguments[6]&&arguments[6],i=arguments.length>7&&void 0!==arguments[7]&&arguments[7],c=arguments.length>8&&void 0!==arguments[8]&&arguments[8];const l=[];for(let g=0;g<t.length;g++)t[g]>r&&l.push({score:t[g],boxIndex:g,suppressBeginIndex:0});l.sort(Im);const u=o>0?-.5/o:0,d=[],h=[];for(;d.length<n&&l.length>0;){const t=l.pop(),{score:n,boxIndex:o,suppressBeginIndex:s}=t;if(n<r)break;let i=!1;for(let c=d.length-1;c>=s;--c){const n=wm(e,o,d[c]);if(n>=a){i=!0;break}if(t.score=t.score*km(a,u,n),t.score<=r)break}t.suppressBeginIndex=d.length,i||(t.score===n?(d.push(o),h.push(t.score)):t.score>r&&mm(l,t,Im))}const p=d.length,f=n-p;i&&f>0&&(d.push(...new Array(f).fill(0)),h.push(...new Array(f).fill(0)));const m={selectedIndices:d};return s&&(m.selectedScores=h),c&&(m.validOutputs=p),m}function wm(e,t,n){const a=e.subarray(4*t,4*t+4),r=e.subarray(4*n,4*n+4),o=Math.min(a[0],a[2]),s=Math.min(a[1],a[3]),i=Math.max(a[0],a[2]),c=Math.max(a[1],a[3]),l=Math.min(r[0],r[2]),u=Math.min(r[1],r[3]),d=Math.max(r[0],r[2]),h=Math.max(r[1],r[3]),p=(i-o)*(c-s),f=(d-l)*(h-u);if(p<=0||f<=0)return 0;const m=Math.max(o,l),g=Math.max(s,u),b=Math.min(i,d),y=Math.min(c,h),x=Math.max(b-m,0)*Math.max(y-g,0);return x/(p+f-x)}function km(e,t,n){const a=Math.exp(t*n*n);return n<=e?a:0}function Im(e,t){return e.score-t.score||e.score===t.score&&t.boxIndex-e.boxIndex}const Sm=async function(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:.5,r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:Number.NEGATIVE_INFINITY;const o=Mu(e,"boxes","nonMaxSuppressionAsync"),s=Mu(t,"scores","nonMaxSuppressionAsync"),i=pm(o,s,n,a,r);n=i.maxOutputSize,a=i.iouThreshold,r=i.scoreThreshold;const c=await Promise.all([o.data(),s.data()]),l=c[0],u=c[1],{selectedIndices:d}=bm(l,u,n,a,r);return o!==e&&o.dispose(),s!==t&&s.dispose(),Pf(d,"int32")};const Nm=Pu({nonMaxSuppressionWithScore_:function(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:.5,r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:Number.NEGATIVE_INFINITY,o=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0;const s=Mu(e,"boxes","nonMaxSuppression"),i=Mu(t,"scores","nonMaxSuppression"),c=pm(s,i,n,a,r,o);n=c.maxOutputSize,a=c.iouThreshold,r=c.scoreThreshold,o=c.softNmsSigma;const l={boxes:s,scores:i},u={maxOutputSize:n,iouThreshold:a,scoreThreshold:r,softNmsSigma:o},d=Cu.runKernel(Qi,l,u);return{selectedIndices:d[0],selectedScores:d[1]}}});const Cm=async function(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:.5,r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:Number.NEGATIVE_INFINITY,o=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0;const s=Mu(e,"boxes","nonMaxSuppressionAsync"),i=Mu(t,"scores","nonMaxSuppressionAsync"),c=pm(s,i,n,a,r,o);n=c.maxOutputSize,a=c.iouThreshold,r=c.scoreThreshold,o=c.softNmsSigma;const l=await Promise.all([s.data(),i.data()]),u=l[0],d=l[1],{selectedIndices:h,selectedScores:p}=xm(u,d,n,a,r,o);return s!==e&&s.dispose(),i!==t&&i.dispose(),{selectedIndices:Pf(h,"int32"),selectedScores:Pf(p)}};const Tm=Pu({nonMaxSuppressionPadded_:function(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:.5,r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:Number.NEGATIVE_INFINITY,o=arguments.length>5&&void 0!==arguments[5]&&arguments[5];const s=Mu(e,"boxes","nonMaxSuppression"),i=Mu(t,"scores","nonMaxSuppression"),c=pm(s,i,n,a,r,null),l={boxes:s,scores:i},u={maxOutputSize:c.maxOutputSize,iouThreshold:c.iouThreshold,scoreThreshold:c.scoreThreshold,padToMaxOutputSize:o},d=Cu.runKernel(Yi,l,u);return{selectedIndices:d[0],validOutputs:d[1]}}});const Em=async function(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:.5,r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:Number.NEGATIVE_INFINITY,o=arguments.length>5&&void 0!==arguments[5]&&arguments[5];const s=Mu(e,"boxes","nonMaxSuppressionAsync"),i=Mu(t,"scores","nonMaxSuppressionAsync"),c=pm(s,i,n,a,r,null),l=c.maxOutputSize,u=c.iouThreshold,d=c.scoreThreshold,[h,p]=await Promise.all([s.data(),i.data()]),{selectedIndices:f,validOutputs:m}=ym(h,p,l,u,d,o);return s!==e&&s.dispose(),i!==t&&i.dispose(),{selectedIndices:Pf(f,"int32"),validOutputs:Hd(m,"int32")}};const Rm=Pu({resizeBilinear_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],a=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const r=Mu(e,"images","resizeBilinear");mo(3===r.rank||4===r.rank,(()=>"Error in resizeBilinear: x must be rank 3 or 4, but got "+"rank ".concat(r.rank,"."))),mo(2===t.length,(()=>"Error in resizeBilinear: new shape must 2D, but got shape "+"".concat(t,"."))),mo(!1===a||!1===n,(()=>"Error in resizeBilinear: If halfPixelCenters is true, alignCorners must be false."));let o=r,s=!1;3===r.rank&&(s=!0,o=rp(r,[1,r.shape[0],r.shape[1],r.shape[2]]));const[]=t,i={images:o},c={alignCorners:n,halfPixelCenters:a,size:t},l=Cu.runKernel(fc,i,c);return s?rp(l,[l.shape[1],l.shape[2],l.shape[3]]):l}});const _m=Pu({resizeNearestNeighbor_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],a=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const r=Mu(e,"images","resizeNearestNeighbor");mo(3===r.rank||4===r.rank,(()=>"Error in resizeNearestNeighbor: x must be rank 3 or 4, but got "+"rank ".concat(r.rank,"."))),mo(2===t.length,(()=>"Error in resizeNearestNeighbor: new shape must 2D, but got shape "+"".concat(t,"."))),mo("float32"===r.dtype||"int32"===r.dtype,(()=>"`images` must have `int32` or `float32` as dtype")),mo(!1===a||!1===n,(()=>"Error in resizeNearestNeighbor: If halfPixelCenters is true, alignCorners must be false."));let o=r,s=!1;3===r.rank&&(s=!0,o=rp(r,[1,r.shape[0],r.shape[1],r.shape[2]]));const[]=t,i={images:o},c={alignCorners:n,halfPixelCenters:a,size:t},l=Cu.runKernel(hc,i,c);return s?rp(l,[l.shape[1],l.shape[2],l.shape[3]]):l}});const Am=Pu({bincount_:function(e,t,n){const a=Mu(e,"x","bincount"),r=Mu(t,"weights","bincount");mo("int32"===a.dtype,(()=>"Error in bincount: input "+"dtype must be int32, but got ".concat(a.dtype))),mo(n>=0,(()=>"size must be non-negative, but got ".concat(n,"."))),mo(r.size===a.size||0===r.size,(()=>"Error in bincount: weights must have the same size as input or"+"0-length, but got input shape: ".concat(a.shape,", weights shape: ")+"".concat(r.shape,".")));const o={x:a,weights:r},s={size:n};return Cu.runKernel(vs,o,s)}});const Fm=Pu({lessEqual_:function(e,t){let n=Mu(e,"a","lessEqual","string_or_numeric"),a=Mu(t,"b","lessEqual","string_or_numeric");[n,a]=yu(n,a),sh(n.shape,a.shape);const r={a:n,b:a};return Cu.runKernel(Ii,r)}});const Om=Pu({round_:function(e){const t={x:Mu(e,"x","round")};return Cu.runKernel(yc,t)}});const Dm=Pu({threshold_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"binary",n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:.5;const r=Mu(e,"image","threshold"),o=r.shape[0]*r.shape[1];let s,i,c,l,u=Bd(Pf([a]),255);if(mo(3===r.rank,(()=>"Error in threshold: image must be rank 3,"+"but got rank ".concat(r.rank,"."))),mo(3===r.shape[2]||1===r.shape[2],(()=>"Error in threshold: image color channel must be equal to 3 or 1"+"but got ".concat(r.shape[2],"."))),mo("int32"===r.dtype||"float32"===r.dtype,(()=>"Error in dtype: image dtype must be int32 or float32,"+"but got dtype ".concat(r.dtype,"."))),mo("otsu"===t||"binary"===t,(()=>"Method must be binary or otsu, but was ".concat(t))),3===r.shape[2]){[s,i,c]=Of(r,[1,1,1],-1);const e=Bd(s,.2989),t=Bd(i,.587),n=Bd(c,.114);l=Ld(Ld(e,t),n)}else l=e;if("otsu"===t){u=function(e,t){let n,a,r,o,s,i,c=Pf([-1]),l=Pf([0]),u=Pf([0]);for(let d=0;d<e.size-1;d++){n=Cf(e,0,d+1),a=Cf(e,d+1),s=zd(Vp(n),t),i=zd(Vp(a),t);const h=Vp(Bd(n,vf(0,n.size)));r=zd(h,Vp(n));const p=Zd(a.shape,n.size),f=Ld(vf(0,a.size),p),m=Bd(a,f);o=zd(Vp(m),Vp(a));const g=th(r,o),b=th(r,o),y=Bd(s,i);u=Bd(Bd(y,g),b);const x=Mp(u,l);l=Vf(x,u,l),c=Vf(x,Pf([d]),c)}return c}(Am(Dd(Om(l),"int32"),Wu([]),256),o)}const d=n?Fm(l,u):Mp(l,u);return Dd(Bd(d,255),"int32")}});const Mm=Pu({transform_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"nearest",a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"constant",r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:0,o=arguments.length>5?arguments[5]:void 0;const s=Mu(e,"image","transform","float32"),i=Mu(t,"transforms","transform","float32");mo(4===s.rank,(()=>"Error in transform: image must be rank 4,"+"but got rank ".concat(s.rank,"."))),mo(2===i.rank&&(i.shape[0]===s.shape[0]||1===i.shape[0])&&8===i.shape[1],(()=>"Error in transform: Input transform should be batch x 8 or 1 x 8")),mo(null==o||2===o.length,(()=>"Error in transform: outputShape must be [height, width] or null, "+"but got ".concat(o,".")));const c={image:s,transforms:i},l={interpolation:n,fillMode:a,fillValue:r,outputShape:o};return Cu.runKernel($c,c,l)}});const Lm=Pu({less_:function(e,t){let n=Mu(e,"a","less","string_or_numeric"),a=Mu(t,"b","less","string_or_numeric");[n,a]=yu(n,a),sh(n.shape,a.shape);const r={a:n,b:a};return Cu.runKernel(ki,r)}});const Pm=Pu({bandPart_:function(e,t,n){const a=Mu(e,"a","bandPart");mo(a.rank>=2,(()=>"bandPart(): Rank must be at least 2, got ".concat(a.rank,".")));const r=a.shape,[o,s]=a.shape.slice(-2);let i,c;"number"===typeof t?(mo(t%1===0,(()=>"bandPart(): numLower must be an integer, got ".concat(t,"."))),mo(t<=o,(()=>"bandPart(): numLower (".concat(t,")")+" must not be greater than the number of rows (".concat(o,")."))),i=Mu(t<0?o:t,"numLower","bandPart")):(mo("int32"===t.dtype,(()=>"bandPart(): numLower's dtype must be an int32.")),i=Vf(Lm(t,0),o,rf(t,o))),"number"===typeof n?(mo(n%1===0,(()=>"bandPart(): numUpper must be an integer, got ".concat(n,"."))),mo(n<=s,(()=>"bandPart(): numUpper (".concat(n,")")+" must not be greater than the number of columns (".concat(s,")."))),c=Mu(n<0?s:n,"numUpper","bandPart")):(mo("int32"===n.dtype,(()=>"bandPart(): numUpper's dtype must be an int32.")),c=Vf(Lm(n,0),s,rf(n,s)));const l=rp(vf(0,o,1,"int32"),[-1,1]),u=vf(0,s,1,"int32"),d=th(l,u),h=Zp(Fm(d,i),Lp(d,sf(c))),p=uf([o,s],a.dtype);return rp(Mf(Wf(rp(a,[-1,o,s])).map((e=>Vf(h,e,p)))),r)}});function zm(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null;if(0===e.rank)return ah(e);if(1!==e.rank&&null===n)return zm(rp(e,[-1]),t,n);if(1===e.rank||"number"===typeof n||Array.isArray(n)&&1===n.length){if(1===t)return Vp(ah(e),n);if(t===1/0)return Wp(ah(e),n);if(t===-1/0)return af(ah(e),n);if("euclidean"===t||2===t)return Wd(Vp(eh(ah(e),Hd(2,"int32")),n));throw new Error("Error in norm: invalid ord value: ".concat(t))}if(Array.isArray(n)&&2===n.length){if(1===t)return Wp(Vp(ah(e),n[0]),n[1]-1);if(t===1/0)return Wp(Vp(ah(e),n[1]),n[0]);if(t===-1/0)return af(Vp(ah(e),n[1]),n[0]);if("fro"===t||"euclidean"===t)return Wd(Vp(Vd(e),n));throw new Error("Error in norm: invalid ord value: ".concat(t))}throw new Error("Error in norm: invalid axis: ".concat(n))}const Bm=Pu({norm_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"euclidean",n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null,a=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const r=zm(e=Mu(e,"x","norm"),t,n);let o=r.shape;if(a){const t=No(n,e.shape);o=Kp(r.shape,t)}return rp(r,o)}});const Wm=Pu({gramSchmidt_:function(e){let t;if(Array.isArray(e)){t=!1,mo(null!=e&&e.length>0,(()=>"Gram-Schmidt process: input must not be null, undefined, or empty"));const n=e[0].shape[0];for(let t=1;t<e.length;++t)mo(e[t].shape[0]===n,(()=>"Gram-Schmidt: Non-unique lengths found in the input vectors: "+"(".concat(e[t].shape[0]," vs. ").concat(n,")")))}else t=!0,e=Of(e,e.shape[0],0).map((e=>Df(e,[0])));mo(e.length<=e[0].shape[0],(()=>"Gram-Schmidt: Number of vectors (".concat(e.length,") exceeds ")+"number of dimensions (".concat(e[0].shape[0],").")));const n=[],a=e;for(let r=0;r<e.length;++r)n.push(Cu.tidy((()=>{let e=a[r];if(r>0)for(let t=0;t<r;++t){const a=Bd(Vp(Bd(n[t],e)),n[t]);e=th(e,a)}return zd(e,Bm(e,"euclidean"))})));return t?Mf(n,0):n}});function Vm(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];return Cu.tidy((()=>{mo(2===e.shape.length,(()=>"qr2d() requires a 2D Tensor, but got a ".concat(e.shape.length,"D Tensor.")));const n=e.shape[0],a=e.shape[1];let r=Fp(n),o=Md(e);const s=zf([[1]],[1,1]);let i=Md(s);const c=n>=a?a:n;for(let e=0;e<c;++e){const t=o,c=i,l=r;[i,o,r]=Cu.tidy((()=>{const t=Cf(o,[e,e],[n-e,1]),c=Bm(t),l=Cf(o,[e,e],[1,1]),u=Vf(Mp(l,0),zf([[-1]]),zf([[1]])),d=th(l,Bd(u,c)),h=zd(t,d);i=1===h.shape[0]?Md(s):pp([s,Cf(h,[1,0],[h.shape[0]-1,h.shape[1]])],0);const p=sf(zd($p(u,d),c)),f=Cf(o,[e,0],[n-e,a]),m=Bd(p,i),g=Hf(i);if(0===e)o=th(f,$p(m,$p(g,f)));else{const t=th(f,$p(m,$p(g,f)));o=pp([Cf(o,[0,0],[e,a]),t],0)}const b=Hf(m),y=Cf(r,[0,e],[n,r.shape[1]-e]);if(0===e)r=th(y,$p($p(y,i),b));else{const t=th(y,$p($p(y,i),b));r=pp([Cf(r,[0,0],[n,e]),t],1)}return[i,o,r]})),ju([t,c,l])}return!t&&n>a&&(r=Cf(r,[0,0],[n,a]),o=Cf(o,[0,0],[a,a])),[r,o]}))}const Um=Pu({qr_:function(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];if(mo(e.rank>=2,(()=>"qr() requires input tensor to have a rank >= 2, but got rank ".concat(e.rank))),2===e.rank)return Vm(e,t);{const n=e.shape.slice(0,e.shape.length-2).reduce(((e,t)=>e*t)),a=Wf(rp(e,[n,e.shape[e.shape.length-2],e.shape[e.shape.length-1]]),0),r=[],o=[];a.forEach((e=>{const[n,a]=Vm(e,t);r.push(n),o.push(a)}));return[rp(Mf(r,0),e.shape),rp(Mf(o,0),e.shape)]}}});var Gm;!function(e){e[e.NONE=0]="NONE",e[e.MEAN=1]="MEAN",e[e.SUM=2]="SUM",e[e.SUM_BY_NONZERO_WEIGHTS=3]="SUM_BY_NONZERO_WEIGHTS"}(Gm||(Gm={}));const Hm=Pu({squaredDifference_:function(e,t){let n=Mu(e,"a","squaredDifference"),a=Mu(t,"b","squaredDifference");[n,a]=yu(n,a),sh(n.shape,a.shape);const r={a:n,b:a};return Cu.runKernel(Vc,r,{})}});const jm={flipLeftRight:cm,grayscaleToRGB:lm,resizeNearestNeighbor:_m,resizeBilinear:Rm,rgbToGrayscale:dm,rotateWithOffset:hm,cropAndResize:im,nonMaxSuppression:fm,nonMaxSuppressionAsync:Sm,nonMaxSuppressionWithScore:Nm,nonMaxSuppressionWithScoreAsync:Cm,nonMaxSuppressionPadded:Tm,nonMaxSuppressionPaddedAsync:Em,threshold:Dm,transform:Mm},Km={bandPart:Pm,gramSchmidt:Wm,qr:Um};const qm=class{static sgd(e){return new lh(e)}static momentum(e,t){return new uh(e,t,arguments.length>2&&void 0!==arguments[2]&&arguments[2])}static rmsprop(e){return new dh(e,arguments.length>1&&void 0!==arguments[1]?arguments[1]:.9,arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,arguments.length>3&&void 0!==arguments[3]?arguments[3]:null,arguments.length>4&&void 0!==arguments[4]&&arguments[4])}static adam(){return new nh(arguments.length>0&&void 0!==arguments[0]?arguments[0]:.001,arguments.length>1&&void 0!==arguments[1]?arguments[1]:.9,arguments.length>2&&void 0!==arguments[2]?arguments[2]:.999,arguments.length>3&&void 0!==arguments[3]?arguments[3]:null)}static adadelta(){return new Jd(arguments.length>0&&void 0!==arguments[0]?arguments[0]:.001,arguments.length>1&&void 0!==arguments[1]?arguments[1]:.95,arguments.length>2&&void 0!==arguments[2]?arguments[2]:null)}static adamax(){return new ch(arguments.length>0&&void 0!==arguments[0]?arguments[0]:.002,arguments.length>1&&void 0!==arguments[1]?arguments[1]:.9,arguments.length>2&&void 0!==arguments[2]?arguments[2]:.999,arguments.length>3&&void 0!==arguments[3]?arguments[3]:null,arguments.length>4&&void 0!==arguments[4]?arguments[4]:0)}static adagrad(e){return new $d(e,arguments.length>1&&void 0!==arguments[1]?arguments[1]:.1)}},Xm="undefined"!==typeof requestAnimationFrame?requestAnimationFrame:"undefined"!==typeof setImmediate?setImmediate:e=>e();function Ym(){return new Promise((e=>Xm((()=>e()))))}function Qm(e,t){const n=e[0].length;e.forEach(((e,t)=>{mo(e.length===n,(()=>"Error in concat".concat(n,"D: rank of tensors[").concat(t,"] must be the same ")+"as the rank of the rest (".concat(n,")")))})),mo(t>=0&&t<n,(()=>"Error in concat".concat(n,"D: axis must be between 0 and ").concat(n-1,".")));const a=e[0];e.forEach(((e,r)=>{for(let o=0;o<n;o++)mo(o===t||e[o]===a[o],(()=>"Error in concat".concat(n,"D: Shape of tensors[").concat(r,"] (").concat(e,") ")+"does not match the shape of the rest (".concat(a,") ")+"along the non-concatenated axis ".concat(r,".")))}))}function Jm(e,t){const n=e[0].slice();for(let a=1;a<e.length;a++)n[t]+=e[a][t];return n}var Zm;function $m(e,t,n){let a=new Array;if(null==n&&null==t)return a;if(null==t)for(;a.length<e+n.length;)a.push(-1);else a=t.slice();if(null==n)return a;if(e+n.length!==a.length)throw new Error("rt input.shape and shape=".concat(t," are incompatible: rt input.rank = ").concat(e+n.length,", but shape.rank = ").concat(a.length));for(let r=1;r<n.length;++r){const o=n[r],s=a[a.length-n.length+r],i=a[s];if(o>=0)if(i>=0){if(i!==o)throw new Error("rt input.shape and shape=".concat(t," are incompatible: rt input.shape[").concat(r+e,"] = ").concat(o," but shape[").concat(r+e,"] = ").concat(i))}else a[s]=o}return a}function eg(e){const t={FIRST_DIM_SIZE:Zm.FIRST_DIM_SIZE,VALUE_ROWIDS:Zm.VALUE_ROWIDS,ROW_LENGTHS:Zm.ROW_LENGTHS,ROW_SPLITS:Zm.ROW_SPLITS,ROW_LIMITS:Zm.ROW_LIMITS,ROW_STARTS:Zm.ROW_STARTS},n=[];for(const a of e){if(!(a in t))break;n.push(t[a])}return n}function tg(e){return 0===e.length?0:e[0]===Zm.FIRST_DIM_SIZE?e.length-1:e.length}function ng(e,t){if(null==e||null==t)return;const n=e.length,a=t.length;if(n>=a)throw new Error("defaultValue.shape=".concat(e," and ragged tensor flatValues.shape=").concat(t,", are incompatible: defaultValue.rank = ").concat(n," must be less than ragged tensor input flatValues.rank = ").concat(a,")"));for(let r=0;r<Math.min(n,a-1);++r){const n=e[r],a=t[r+1];if(n>=0&&a>=0&&1!==n&&n!==a)throw new Error("defaultValue.shape=".concat(e,", and ragged tensor input flatValues.shape=").concat(t," are incompatible: defaultValue.shape[").concat(r-e.length,"] = ").concat(n," but ragged tensor input.flatValues.shape[").concat(r-e.length,"] = ").concat(a))}}!function(e){e[e.FIRST_DIM_SIZE=0]="FIRST_DIM_SIZE",e[e.VALUE_ROWIDS=1]="VALUE_ROWIDS",e[e.ROW_LENGTHS=2]="ROW_LENGTHS",e[e.ROW_SPLITS=3]="ROW_SPLITS",e[e.ROW_LIMITS=4]="ROW_LIMITS",e[e.ROW_STARTS=5]="ROW_STARTS"}(Zm||(Zm={}));const ag=30;function rg(e){return e<=ag?e:Mo(e,Math.floor(Math.sqrt(e)))}function og(e,t,n){return[n*("number"===typeof e?e:e[0]),t*("number"===typeof e?e:e[1])]}function sg(e,t,n){let a=[];if(!(arguments.length>3&&void 0!==arguments[3])||arguments[3])a=a.concat(t.slice(0)),a.push(e[0]/n),a=a.concat(e.slice(1));else{a=a.concat(e[0]);const n=t.length;for(let r=0;r<n;++r)a=a.concat([e[r+1]/t[r],t[r]]);a=a.concat(e.slice(n+1))}return a}function ig(e,t){const n=[];if(!(arguments.length>2&&void 0!==arguments[2])||arguments[2]){n.push(t);for(let a=t+1;a<e;++a)a<=2*t?(n.push(a),n.push(a-(t+1))):n.push(a)}else{const a=[],r=[];for(let n=1;n<e;++n)n>=2*t+1||n%2===1?r.push(n):a.push(n);n.push(...a),n.push(0),n.push(...r)}return n}function cg(e,t,n){let a=!(arguments.length>3&&void 0!==arguments[3])||arguments[3];const r=[];a?r.push(e[0]/n):r.push(e[0]*n);for(let o=1;o<e.length;++o)o<=t.length?a?r.push(t[o-1]*e[o]):r.push(e[o]/t[o-1]):r.push(e[o]);return r}function lg(e,t){const n=[0];for(let a=0;a<t;++a)n.push(e[a][0]);return n}function ug(e,t,n){const a=e.slice(0,1);for(let r=0;r<n;++r)a.push(e[r+1]-t[r][0]-t[r][1]);return a}function dg(e,t){const n=e.shape.length,a=t.shape.length;if(n<1)throw new Error("tf.gatherND() expects the input to be rank 1 or higher,"+" but the rank was ".concat(n,"."));if(a<1)throw new Error("tf.gatherND() expects the indices to be rank 1 or higher,"+" but the rank was ".concat(a,"."));if("int32"!==t.dtype)throw new Error("tf.gatherND() expects the indices to be int32 type,"+" but the dtype was ".concat(t.dtype,"."));if(t.shape[a-1]>n)throw new Error("index innermost dimension length must be <= tensor rank; saw: "+"".concat(t.shape[a-1]," vs. ").concat(n));if(0===yo(e.shape))throw new Error("Requested more than 0 entries, but input is empty."+" Input shape: ".concat(e.shape,"."));const r=t.shape,o=r[r.length-1];let s=1;for(let d=0;d<r.length-1;++d)s*=r[d];const i=e.shape,c=r.slice();c.pop();let l=1;for(let d=o;d<n;++d)l*=i[d],c.push(i[d]);const u=[...Lo(e.shape).map((e=>e/l)),1].slice(0,o);return[c,s,l,u]}function hg(e,t,n){const a=t.rank>1?t.shape[t.rank-1]:1,r=t.rank>1?t.rank-1:1,o="Must have updates.shape = indices.shape[:batchDim] + "+"shape[sliceDim:], got updates.shape: ".concat(n.shape)+", indices.shape: ".concat(t.shape,", shape: ").concat(e)+", sliceDim: ".concat(a,", and batchDim: ").concat(r,".");if(n.rank<r)throw new Error(o+" update.rank < ".concat(r,". "));if(e.length<a+(n.rank-r))throw new Error(o+" Output shape length < ".concat(a+(n.rank-r)));if(n.rank!==r+e.length-a)throw new Error(o+" update.rank != ".concat(r+e.length-a));for(let s=0;s<r;++s)if(n.shape[s]!==t.shape[s])throw new Error(o+" updates.shape[".concat(s,"] (").concat(n.shape[s],") != indices.shape[").concat(s,"] (").concat(t.shape[s],")."));for(let s=0;s<n.rank-r;++s)if(n.shape[s+r]!==e[s+a])throw new Error(o+" updates.shape[".concat(s+r,"] (").concat(n.shape[s+r],") != shape[").concat(s+r,"] (").concat(e[s+r],")"))}function pg(e,t,n){if(t.rank<1)throw new Error("tf.scatterND() expects the indices to be rank 1 or higher,"+" but the rank was ".concat(t.rank,"."));if(e.rank<1)throw new Error("tf.scatterND() expects the updates to be rank 1 or higher,"+" but the rank was ".concat(e.rank,"."));if("int32"!==t.dtype)throw new Error("The dtype of 'indices' should be int32, but got dtype: ".concat(t.dtype));if(n.length<1)throw new Error("Output rank must be greater or equal to 1, but got shape: ".concat(n));if(0===n.length){if(0===t.size)throw new Error("Indices specified for empty output. indices shape: ".concat(t.shape));if(0===e.size)throw new Error("Updates specified for empty output. updates shape: ".concat(e.shape))}hg(n,t,e)}function fg(e,t,n){const a=t.shape.length,r=a>1?t.shape[a-1]:1,o=n.length;let s=1;for(let c=r;c<o;++c)s*=n[c];const i=r<1?1:r;return{sliceRank:r,numUpdates:yo(t.shape)/i,sliceSize:s,strides:[...Lo(n.slice(0,r)),1],outputSize:yo(n)}}const mg=1.7580993408473768,gg=1.0507009873554805,bg=.3275911,yg=.254829592,xg=-.284496736,vg=1.421413741,wg=-1.453152027,kg=1.061405429;function Ig(e,t){if(e.length!==t.length)throw new Error("Cannot merge real and imag arrays of different lengths. real:"+"".concat(e.length,", imag: ").concat(t.length,"."));const n=new Float32Array(2*e.length);for(let a=0;a<n.length;a+=2)n[a]=e[a/2],n[a+1]=t[a/2];return n}function Sg(e){const t=new Float32Array(e.length/2),n=new Float32Array(e.length/2);for(let a=0;a<e.length;a+=2)t[a/2]=e[a],n[a/2]=e[a+1];return{real:t,imag:n}}function Ng(e){const t=Math.ceil(e.length/4),n=new Float32Array(t),a=new Float32Array(t);for(let r=0;r<e.length;r+=4)n[Math.floor(r/4)]=e[r],a[Math.floor(r/4)]=e[r+1];return{real:n,imag:a}}function Cg(e){const t=Math.floor(e.length/4),n=new Float32Array(t),a=new Float32Array(t);for(let r=2;r<e.length;r+=4)n[Math.floor(r/4)]=e[r],a[Math.floor(r/4)]=e[r+1];return{real:n,imag:a}}function Tg(e,t){return{real:e[2*t],imag:e[2*t+1]}}function Eg(e,t,n,a){e[2*a]=t,e[2*a+1]=n}function Rg(e,t){const n=new Float32Array(e/2),a=new Float32Array(e/2);for(let r=0;r<Math.ceil(e/2);r++){const o=(t?2:-2)*Math.PI*(r/e);n[r]=Math.cos(o),a[r]=Math.sin(o)}return{real:n,imag:a}}function _g(e,t,n){const a=(n?2:-2)*Math.PI*(e/t);return{real:Math.cos(a),imag:Math.sin(a)}}const Ag="->",Fg=/->/g,Og=",",Dg="...";function Mg(e,t){const n=((e=e.replace(/\s/g,"")).length-e.replace(Fg,"").length)/Ag.length;if(n<1)throw new Error("Equations without an arrow are not supported.");if(n>1)throw new Error('Equation must contain exactly one arrow ("'.concat(Ag,'").'));const[a,r]=e.split(Ag);mo(-1===a.indexOf(Dg),(()=>'The ellipsis notation ("'.concat(Dg,'") is not supported yet.')));const o=a.split(Og),s=o.length;if(t!==s)throw new Error("Expected ".concat(s," input tensors, received ").concat(t));if(s>2)throw new Error("Support for more than 2 input tensors is not implemented yet.");const i=[];for(let d=0;d<r.length;++d){const e=r[d];if(!o.some((t=>-1!==t.indexOf(e))))throw new Error("Output subscripts contain the label ".concat(e," ")+"not present in the input subscripts.");-1===i.indexOf(e)&&i.push(e)}for(let d=0;d<a.length;++d){const e=a[d];-1===i.indexOf(e)&&e!==Og&&i.push(e)}const c=new Array(o.length);for(let d=0;d<s;++d){if(new Set(o[d].split("")).size!==o[d].length)throw new Error("Found duplicate axes in input component ".concat(o[d],". ")+"Support for duplicate axes in input is not implemented yet.");c[d]=[];for(let e=0;e<o[d].length;++e)c[d].push(i.indexOf(o[d][e]))}const l=i.length,u=[];for(let d=r.length;d<l;++d)u.push(d);return{allDims:i,summedDims:u,idDims:c}}function Lg(e,t){let n=new Array(e);n.fill(-1);for(let r=0;r<t.length;++r)n[t[r]]=r;const a=[];for(let r=0;r<e;++r)-1===n[r]&&a.push(r);return n=n.filter((e=>-1!==e)),{permutationIndices:n,expandDims:a}}function Pg(e,t,n){const a=new Array(e);for(let r=0;r<n.length;++r){const e=n[r].shape;for(let n=0;n<t[r].length;++n)void 0===a[t[r][n]]?a[t[r][n]]=e[n]:mo(a[t[r][n]]===e[n],(()=>"Expected dimension ".concat(a[t[r][n]]," at axis ").concat(n," ")+"of input shaped ".concat(JSON.stringify(e),", ")+"but got dimension ".concat(e[n])))}}function zg(e,t){const n=e,a=[];let r=0;0===e.length&&n.push(-1),r=e.length+1;for(let s=0;s<r;++s)a.push([]);const o=[];for(let s=0;s<n.length;++s){const e=Wg(t,n[s]);for(const t of e)-1===o.indexOf(t)&&(a[s].push(t),o.push(t))}return{path:n,steps:a}}function Bg(e){return e.every(((e,t)=>e===t))}function Wg(e,t){const n=[];for(let a=0;a<e.length;++a)0!==e[a].length&&-1===e[a].indexOf(t)&&-1!==t||n.push(a);return n}function Vg(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,a=[];if("number"===typeof t)mo(e.shape[n]%t===0,(()=>"Number of splits must evenly divide the axis.")),a=new Array(t).fill(e.shape[n]/t);else{const r=t.reduce(((e,t)=>(-1===t&&(e+=1),e)),0);mo(r<=1,(()=>"There should be only one negative value in split array."));const o=t.indexOf(-1);if(-1!==o){const a=t.reduce(((e,t)=>t>0?e+t:e));t[o]=e.shape[n]-a}mo(e.shape[n]===t.reduce(((e,t)=>e+t)),(()=>"The sum of sizes must match the size of the axis dimension.")),a=t}return a}function Ug(e){return"Received SparseTensor with denseShape[0] = 0 but\n  indices.shape[0] = ".concat(e)}function Gg(e,t){return"indices(".concat(e,", 0) is invalid: ").concat(t," < 0")}function Hg(e,t,n){return"indices(".concat(e,", 0) is invalid: ").concat(t," >= ").concat(n)}function jg(e,t){return"only one output dimension may be -1, not both ".concat(e," and ").concat(t)}function Kg(e,t){return"size ".concat(e," must be non-negative, not ").concat(t)}function qg(){return"reshape cannot infer the missing input size for an empty tensor unless all specified input sizes are non-zero"}function Xg(e,t){const n=yo(e),a=yo(t);return"Input to reshape is a SparseTensor with ".concat(n,"\n  dense values, but the requested shape requires a multiple of ").concat(a,". inputShape=").concat(e," outputShape= ").concat(t)}function Yg(e,t){const n=yo(e),a=yo(t);return"Input to reshape is a tensor with ".concat(n," dense values, but the requested shape has ").concat(a,". inputShape=").concat(e," outputShape=").concat(t)}function Qg(){return"segment ids must be >= 0"}function Jg(){return"segment ids are not increasing"}function Zg(e,t){return"Segment id ".concat(e," out of range [0, ").concat(t,"), possibly because segmentIds input is not sorted.")}function $g(e,t,n){return"Bad: indices[".concat(e,"] == ").concat(t," out of range [0, ").concat(n,")")}function eb(e,t){let n,a=!1;for(e<=ag?(n=e,a=!0):n=Mo(e,Math.floor(Math.sqrt(e)));!a;)n>t||n===e?a=!0:n=Mo(e,n+1);return n}function tb(e,t,n){const a=[],r=e.length;for(let o=0;o<r;o++)o!==t?a.push(e[o]):a.push(n);return a}function nb(e,t,n,a){const r=t.shape.length,o=e.shape.length;if(0!==a&&(a<-r||a>r))throw new Error("Expect batchDims in the range of [-".concat(r,", ").concat(r,"], but got ").concat(a));if(a<0&&(a+=r),a>o)throw new Error("batchDims (".concat(a,") must be less than rank(x) (\n    ").concat(o,")."));if(n<a)throw new Error("batchDims (".concat(a,") must be less than or equal to axis (").concat(n,")."));for(let d=0;d<a;++d)if(e.shape[d]!==t.shape[d])throw new Error("x.shape[".concat(d,"]: ").concat(e.shape[d]," should be equal to indices.shape[").concat(d,"]: ").concat(t.shape[d],"."));const s=e.shape[n],i=[];let c=1,l=1,u=1;for(let d=0;d<a;++d)i.push(e.shape[d]),c*=e.shape[d];for(let d=a;d<n;d++)i.push(e.shape[d]),l*=e.shape[d];for(let d=a;d<r;d++)i.push(t.shape[d]);for(let d=n+1;d<o;d++)i.push(e.shape[d]),u*=e.shape[d];return{batchSize:c,sliceSize:u,outerSize:l,dimSize:s,outputShape:i}}function ab(e){try{return e.map((e=>Vl(e)))}catch(ade){throw new Error("Failed to decode encoded string bytes into utf-8, error: ".concat(ade))}}function rb(e){return e.map((e=>Wl(e)))}function ob(e,t){const n=[];for(let o=0;o<t.length;o++)t[o]&&n.push(o);const a=Od(e,"int32"),r=Od([n.length,e.length],"int32");for(let o=0;o<n.length;o++){const t=a.indexToLoc(n[o]),s=o*e.length;r.values.set(t,s)}return r.toTensor()}!function(){for(const e of hh)Yd(e)}();const sb={kernelName:es,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>Bd(e,Zf(Dd(n,"float32"),-1))}}},ib={kernelName:ts,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>{const t=Vd(Dd(n,"float32")),a=Wd(th(Hd(1),t));return sf(zd(e,a))}}}},cb={kernelName:ns,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>{const t=Wd(th(Vd(Dd(n,"float32")),1));return zd(e,t)}}}},lb={kernelName:as,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,a]=t,r=sh(n.shape,a.shape);return{a:()=>{let t=e;const a=oh(n.shape,r);return a.length>0&&(t=Vp(t,a)),rp(t,n.shape)},b:()=>{let t=e;const n=oh(a.shape,r);return n.length>0&&(t=Vp(t,n)),rp(t,a.shape)}}}},ub={kernelName:rs,saveAllInputs:!0,gradFunc:(e,t)=>{const n={};return t.forEach(((t,a)=>{n[a]=()=>e.clone()})),n}},db={kernelName:is,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>Ud(n)}}},hb={kernelName:cs,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>Ud(n)}}},pb={kernelName:ls,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>zd(e,Wd(th(Hd(1),Vd(Dd(n,"float32")))))}}},fb={kernelName:us,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>{const t=Wd(Ld(Hd(1),Vd(Dd(n,"float32"))));return zd(e,t)}}}},mb={kernelName:ps,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,a]=t,r=sh(n.shape,a.shape);return{a:()=>{const t=Ld(Vd(n),Vd(a));let o=Bd(e,zd(a,t));const s=oh(n.shape,r);return s.length>0&&(o=Vp(o,s)),rp(o,n.shape)},b:()=>{const t=Ld(Vd(n),Vd(a));let o=sf(Bd(e,zd(n,t)));const s=oh(a.shape,r);return s.length>0&&(o=Vp(o,s)),rp(o,a.shape)}}}},gb={kernelName:ds,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>zd(e,Ld(Vd(Dd(n,"float32")),1))}}},bb={kernelName:hs,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>zd(e,th(Hd(1),Vd(Dd(n,"float32"))))}}};const yb=Pu({avgPool3dGrad_:function(e,t,n,a,r,o){const s=Mu(e,"dy","avgPool3dGrad"),i=Mu(t,"input","avgPool3dGrad");let c=s,l=i,u=!1;4===i.rank&&(u=!0,c=rp(s,[1,s.shape[0],s.shape[1],s.shape[2],s.shape[3]]),l=rp(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]])),mo(5===c.rank,(()=>"Error in avgPool3dGrad: dy must be rank 5 but got rank "+"".concat(c.rank,"."))),mo(5===l.rank,(()=>"Error in avgPool3dGrad: input must be rank 5 but got rank "+"".concat(l.rank,"."))),ap("avgPool3dGrad",r,o);const d={dy:c,input:l},h={filterSize:n,strides:a,pad:r,dimRoundingMode:o},p=Cu.runKernel(bs,d,h);return u?rp(p,[p.shape[1],p.shape[2],p.shape[3],p.shape[4]]):p}}),xb={kernelName:gs,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[a]=t,{filterSize:r,strides:o,pad:s,dimRoundingMode:i}=n;return{x:()=>yb(e,a,r,o,s,i)}}};const vb=Pu({avgPoolGrad_:function(e,t,n,a,r){const o=Mu(e,"dy","avgPoolGrad"),s=Mu(t,"input","avgPoolGrad");mo(s.rank===o.rank,(()=>"Rank of input (".concat(s.rank,") does not match rank of dy (").concat(o.rank,")")));let i=s,c=o,l=!1;3===s.rank&&(l=!0,i=rp(s,[1,s.shape[0],s.shape[1],s.shape[2]]),c=rp(o,[1,o.shape[0],o.shape[1],o.shape[2]])),mo(4===c.rank,(()=>"Error in avgPoolGrad: dy must be rank 4 but got rank "+"".concat(c.rank,"."))),mo(4===i.rank,(()=>"Error in avgPoolGrad: input must be rank 4 but got rank "+"".concat(i.rank,".")));const u={dy:c,input:i},d={filterSize:n,strides:a,pad:r},h=Cu.runKernel(ms,u,d);return l?rp(h,[h.shape[1],h.shape[2],h.shape[3]]):h}}),wb={kernelName:fs,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[a]=t,{filterSize:r,strides:o,pad:s}=n;return{x:()=>vb(e,a,r,o,s)}}},kb={kernelName:ys,inputsToSave:["a","b"],gradFunc:(e,t,n)=>{const[a,r]=t,{transposeA:o,transposeB:s}=n;return o||s?!o&&s?{a:()=>$p(e,r,!1,!1),b:()=>$p(e,a,!0,!1)}:o&&!s?{a:()=>$p(r,e,!1,!0),b:()=>$p(a,e,!1,!1)}:{a:()=>$p(r,e,!0,!0),b:()=>$p(e,a,!0,!0)}:{a:()=>$p(e,r,!1,!0),b:()=>$p(a,e,!0,!1)}}};const Ib=Pu({spaceToBatchND_:function(e,t,n){const a=Mu(e,"x","spaceToBatchND");mo(a.rank>=1+t.length,(()=>"input rank ".concat(a.rank," should be > than [blockShape] ").concat(t.length))),mo(n.length===t.length,(()=>"paddings.shape[0] ".concat(n.length," must be equal to [blockShape] ").concat(t.length))),mo(a.shape.reduce(((e,a,r)=>r>0&&r<=t.length?e&&(a+n[r-1][0]+n[r-1][1])%t[r-1]===0:e),!0),(()=>"input spatial dimensions ".concat(a.shape.slice(1)," with paddings ").concat(n.toString()," must be divisible by blockShapes ").concat(t.toString())));const r={x:a},o={blockShape:t,paddings:n};return Cu.runKernel(Oc,r,o)}}),Sb={kernelName:xs,gradFunc:(e,t,n)=>{const{blockShape:a,crops:r}=n;return{x:()=>Ib(e,a,r)}}},Nb={kernelName:"BroadcastTo",gradFunc:(e,t,n)=>{const a=n,r=a.inputShape,o=a.shape,s=Array.from(o);for(let c=r.length-1;c>=0;c--)if(r[c]===o[c])s[c]=1;else if(1!==r[c])throw new Error("broadcastTo(): [".concat(r,"] cannot be broadcast to [").concat(o,"]."));const i=[];for(let c=0;c<s.length;c++)s[c]>1&&i.push(c);return{x:()=>Vp(e,i,!0)}}},Cb={kernelName:Is,gradFunc:e=>({x:()=>e.clone()})},Tb={kernelName:Ss,gradFunc:e=>({x:()=>Ud(e)})},Eb={kernelName:Ns,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[a]=t,{clipValueMin:r,clipValueMax:o}=n;return{x:()=>Vf(Zp(Lp(a,r),Fm(a,o)),e,Ud(e))}}},Rb={kernelName:Ts,inputsToSave:["x"],gradFunc:sb.gradFunc},_b={kernelName:Es,saveAllInputs:!0,gradFunc:(e,t,n)=>{const a=t.map((e=>e.shape)),{axis:r}=n,o=No(r,t[0].shape)[0],s=a.map((e=>e[o]));return Of(e,s,o).map((e=>()=>e))}},Ab={kernelName:Rs,inputsToSave:["x","filter"],gradFunc:(e,t,n)=>{const[a,r]=t,{dilations:o,strides:s,pad:i,dataFormat:c}=n;return mo($h(o),(()=>"Error in gradient of conv2D: dilation rates greater than 1 "+"are not yet supported in gradients. Got dilations '".concat(o,"'"))),{x:()=>vp(a.shape,e,r,s,i,c),filter:()=>Qf(a,e,r.shape,s,i,c)}}},Fb={kernelName:As,inputsToSave:["dy","filter"],gradFunc:(e,t,n)=>{const[a,r]=t,{strides:o,pad:s,dataFormat:i,dimRoundingMode:c}=n;return{dy:()=>yp(e,r,o,s,i,1,c),filter:()=>Qf(e,a,r.shape,o,s,i,c)}}};const Ob=Pu({conv3DBackpropFilter_:function(e,t,n,a,r){let o=e;4===e.rank&&(o=rp(e,[1,e.shape[0],e.shape[1],e.shape[2],e.shape[3]]));let s=t;4===s.rank&&(s=rp(t,[1,t.shape[0],t.shape[1],t.shape[2],t.shape[3]])),mo(5===o.rank,(()=>"Error in conv3dDerFilter: input must be rank 5, but got shape "+"".concat(o.shape,"."))),mo(5===s.rank,(()=>"Error in conv3dDerFilter: dy must be rank 5, but got shape "+"".concat(s.shape,"."))),mo(5===n.length,(()=>"Error in conv3dDerFilter: filterShape must be length 5, but got "+"".concat(n,"."))),mo(o.shape[4]===n[3],(()=>"Error in conv3dDerFilter: depth of input ".concat(o.shape[4],") must ")+"match input depth in filter (".concat(n[3],"."))),mo(s.shape[4]===n[4],(()=>"Error in conv3dDerFilter: depth of dy (".concat(s.shape[4],") must ")+"match output depth for filter (".concat(n[4],").")));const i={x:o,dy:s},c={strides:a,pad:r,filterShape:n};return Cu.runKernel(Os,i,c)}}),Db={kernelName:Fs,inputsToSave:["x","filter"],gradFunc:(e,t,n)=>{const{dilations:a,strides:r,pad:o}=n;mo($h(a),(()=>"Error in gradient of conv3D: dilation rates greater than 1 are "+"not yet supported in gradients. Got dilations '".concat(a,"'")));const[s,i]=t;return{x:()=>Ip(s.shape,e,i,r,o),filter:()=>Ob(s,e,i.shape,r,o)}}};const Mb=Pu({sin_:function(e){const t={x:Mu(e,"x","sin","float32")};return Cu.runKernel(Cc,t)}}),Lb={kernelName:Ms,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>Bd(sf(Mb(Dd(n,"float32"))),e)}}};const Pb=Pu({sinh_:function(e){const t={x:Mu(e,"x","sinh")};return Cu.runKernel(Tc,t)}}),zb={kernelName:Ls,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>Bd(Pb(Dd(n,"float32")),e)}}};const Bb=Pu({cumsum_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],a=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const r={x:Mu(e,"x","cumsum")},o={axis:t,exclusive:n,reverse:a};return Cu.runKernel(zs,r,o)}}),Wb={kernelName:zs,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[a]=t,{axis:r,exclusive:o,reverse:s}=n;return{x:()=>{const t=Xp([r],a.rank);let n=Bb(e,r,o,!s);return null!=t&&(n=Hf(n,t)),n}}}},Vb={kernelName:Us,inputsToSave:["x","filter"],gradFunc:(e,t,n)=>{const{dilations:a,strides:r,pad:o,dimRoundingMode:s}=n,i=null==a?[1,1]:a;mo($h(i),(()=>"Error in gradient of depthwiseConv2dNative: dilation rates greater than 1 are not yet supported. Got dilations "+"'".concat(i,"'")));const[c,l]=t;return mo(4===c.rank,(()=>"Error in gradient of depthwiseConv2dNative: input must be "+"rank 4, but got rank ".concat(c.rank,"."))),mo(4===l.rank,(()=>"Error in gradient of depthwiseConv2dNative: filter must be "+"rank 4, but got rank ".concat(l.rank,"."))),mo(c.shape[3]===l.shape[2],(()=>"Error in gradient of depthwiseConv2d: number of input "+"channels (".concat(c.shape[3],") must match the inChannels dimension ")+"in filter ".concat(l.shape[2],"."))),mo(ep(r,i),(()=>"Error in gradient of depthwiseConv2d: Either strides or "+"dilations must be  1. Got strides ".concat(r," and dilations ")+"'".concat(i,"'."))),ap("depthwiseConv2d",o,s),{x:()=>om(c.shape,e,l,r,o,i,s),filter:()=>rm(c,e,l.shape,r,o,i,s)}}},Ub={kernelName:Ks,inputsToSave:["x","filter"],gradFunc:(e,t,n)=>{const[a,r]=t,o={x:a,filter:r,dy:e},s={x:a,filter:r,dy:e};return{x:()=>Cu.runKernel(qs,o,n),filter:()=>Cu.runKernel(Xs,s,n)}}},Gb={kernelName:Zs,outputsToSave:[!0],gradFunc:(e,t)=>{const[n]=t,a={dy:e,y:n};return{x:()=>Cu.runKernel($s,a)}}},Hb={kernelName:ei,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t,a=Bd(Rp(sf(Vd(n))),2/Math.sqrt(Math.PI));return{x:()=>Bd(e,a)}}},jb={kernelName:ni,outputsToSave:[!0],gradFunc:(e,t)=>{const[n]=t;return{x:()=>Bd(e,n)}}},Kb={kernelName:ai,inputsToSave:["input"],gradFunc:(e,t)=>{const[n]=t;return{input:()=>rp(e,n.shape)}}},qb={kernelName:ri,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>Bd(e,Rp(n))}}},Xb={kernelName:ci,gradFunc:e=>({x:()=>Ud(e)})},Yb={kernelName:li,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,a]=t,r=sh(n.shape,a.shape);return{a:()=>{const t=zd(e,Dd(a,"float32")),o=oh(n.shape,r);return o.length>0?rp(Vp(t,o),n.shape):t},b:()=>{let t=Bd(e,Dd(n,"float32"));const o=oh(a.shape,r);o.length>0&&(t=rp(Vp(t,o),a.shape));const s=Vd(a);return sf(zd(t,Dd(s,"float32")))}}}};const Qb=Pu({rsqrt_:function(e){const t={x:Mu(e,"x","rsqrt","float32")};return Cu.runKernel(xc,t)}}),Jb={kernelName:ui,inputsToSave:["x","mean","variance","scale"],gradFunc:(e,t,n)=>{const{varianceEpsilon:a}=n,[r,o,s,i]=t,c=null==i?Hd(1):i,l=oh(o.shape,r.shape),u=[];if(1===o.rank){for(let e=0;e<r.shape.length-1;++e)u.push(r.shape[e]);u.push(1)}const d=th(r,o),h=Bd(e,c),p=Qb(Ld(s,Hd(a))),f=Bd(Bd(Bd(p,p),p),Hd(-.5));return{x:()=>1===o.rank?rp(Bd(Bd(e,Ap(rp(p,[1,1,1,o.shape[0]]),u)),c),r.shape):rp(Bd(Bd(e,p),c),r.shape),mean:()=>{let e=Bd(Bd(p,Hd(-1)),h);return 1===o.rank&&(e=Vp(e,l)),rp(e,o.shape)},variance:()=>{let e=Bd(Bd(f,d),h);return 1===o.rank&&(e=Vp(e,l)),rp(e,o.shape)},scale:()=>{const t=Bd(d,p);let n=Bd(e,t);return 1===o.rank&&(n=Vp(n,l)),rp(n,o.shape)},offset:()=>{let t=e;return 1===o.rank&&(t=Vp(t,l)),rp(t,o.shape)}}}};const Zb=Pu({unsortedSegmentSum_:function(e,t,n){const a=Mu(e,"x","unsortedSegmentSum"),r=Mu(t,"segmentIds","unsortedSegmentSum","int32");mo(vo(n),(()=>"numSegments must be of dtype int"));const o={x:a,segmentIds:r},s={numSegments:n};return Cu.runKernel(al,o,s)}}),$b={kernelName:di,inputsToSave:["x","indices"],gradFunc:(e,t,n)=>{const[a,r]=t,{axis:o,batchDims:s}=n,i=No(o,a.shape)[0],c=(e,t,n)=>()=>{const a=e.shape,r=t.size,s=a.slice(0,i),c=s.length,l=a.slice(o,a.length).slice(1),u=l.length,d=ey(0,c),h=ey(c+1,c+1+u),p=ty([s,[r],l]),f=rp(n,p),m=rp(t,[r]),g=ty([[c],d,h]),b=Hf(f,g);let y=Zb(b,m,e.shape[i]);const x=Yp(g);return y=Hf(y,x),y};if(1===s){const t=a.shape[0],n=a.split(t,0),o=()=>{const t=Mf(n.map(((t,n)=>c(t,r.slice(n,1),e.slice(n,1))())));return t.reshape(a.shape)};return{x:o,indices:()=>r}}return{x:c(a,r,e),indices:()=>r}}};function ey(e,t){const n=[];for(let a=e;a<t;++a)n.push(a);return n}function ty(e){const t=[];for(let n=0;n<e.length;++n)for(let a=0;a<e[n].length;++a)t.push(e[n][a]);return t}const ny={kernelName:fi,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,a]=t;return{a:()=>Ud(n),b:()=>Ud(a)}}},ay={kernelName:mi,gradFunc:e=>({x:()=>Dd(e,"float32")})},ry={kernelName:yi,gradFunc:e=>({x:()=>Ud(e)})},oy={kernelName:xi,gradFunc:e=>({x:()=>Ud(e)})},sy={kernelName:vi,gradFunc:e=>({x:()=>Ud(e)})},iy={kernelName:wi,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[a]=t,{alpha:r}=n,o=Mp(a,0);return{x:()=>Vf(o,e,Bd(e,r))}}},cy={kernelName:Ci,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>zd(e,Ld(n,1))}}},ly={kernelName:Ni,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>zd(e,Dd(n,"float32"))}}},uy={kernelName:"LogSoftmax",inputsToSave:[],outputsToSave:[!0],gradFunc:(e,t,n)=>{const[a]=t,{axis:r}=n;return{logits:()=>{const t=Rp(a);return th(e,Bd(Vp(e,r,!0),t))}}}};const dy=Pu({localResponseNormalizationBackprop_:function(e,t,n){const a={x:e,y:t,dy:n},r={depthRadius:arguments.length>3&&void 0!==arguments[3]?arguments[3]:5,bias:arguments.length>4&&void 0!==arguments[4]?arguments[4]:1,alpha:arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,beta:arguments.length>6&&void 0!==arguments[6]?arguments[6]:.5};return Cu.runKernel(Ai,a,r)}}),hy={kernelName:_i,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,n)=>{const[a,r]=t,{depthRadius:o,bias:s,alpha:i,beta:c}=n;return{x:()=>dy(a,r,e,o,s,i,c)}}};function py(e,t,n,a){return t.rank<n.rank&&(t=rp(t,Kp(t.shape,a))),e.rank<n.rank&&(e=rp(e,Kp(e.shape,a))),{x:()=>Bd(e,Dd(Ep(n,t),e.dtype))}}const fy={kernelName:Fi,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,n)=>{const a=n,{reductionIndices:r}=a,o=t[0],s=py(e,t[1],o,No(r,o.shape));return{x:()=>s.x()}}},my={kernelName:Oi,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,a]=t;return{a:()=>Bd(e,Dd(Lp(n,a),"float32")),b:()=>Bd(e,Dd(Lm(n,a),"float32"))}}};const gy=Pu({maxPool3dGrad_:function(e,t,n,a,r,o,s){const i=Mu(e,"dy","maxPool3dGrad"),c=Mu(t,"input","maxPool3dGrad"),l=Mu(n,"output","maxPool3dGrad");let u=i,d=c,h=l,p=!1;4===c.rank&&(p=!0,u=rp(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]]),d=rp(c,[1,c.shape[0],c.shape[1],c.shape[2],c.shape[3]]),h=rp(l,[1,l.shape[0],l.shape[1],l.shape[2],l.shape[3]])),mo(5===u.rank,(()=>"Error in maxPool3dGrad: dy must be rank 5 but got rank "+"".concat(u.rank,"."))),mo(5===d.rank,(()=>"Error in maxPool3dGrad: input must be rank 5 but got rank "+"".concat(d.rank,"."))),mo(5===h.rank,(()=>"Error in maxPool3dGrad: output must be rank 5 but got rank "+"".concat(h.rank,"."))),ap("maxPool3dGrad",o,s);const f={dy:u,input:d,output:h},m={filterSize:a,strides:r,pad:o,dimRoundingMode:s},g=Cu.runKernel(Pi,f,m);return p?rp(g,[g.shape[1],g.shape[2],g.shape[3],g.shape[4]]):g}}),by={kernelName:Li,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,n)=>{const[a,r]=t,{filterSize:o,strides:s,pad:i,dimRoundingMode:c}=n;return{x:()=>gy(e,a,r,o,s,i,c)}}};const yy=Pu({maxPoolGrad_:function(e,t,n,a,r,o,s){const i=Mu(e,"dy","maxPoolGrad"),c=Mu(t,"input","maxPoolGrad"),l=Mu(n,"output","maxPoolGrad");mo(c.rank===i.rank,(()=>"Rank of input (".concat(c.rank,") does not match rank of dy ")+"(".concat(i.rank,")"))),mo(4===i.rank,(()=>"Error in maxPoolGrad: dy must be rank 4 but got rank "+"".concat(i.rank,"."))),mo(4===c.rank,(()=>"Error in maxPoolGrad: input must be rank 4 but got rank "+"".concat(c.rank,"."))),ap("maxPoolGrad",o,s);const u={dy:i,input:c,output:l},d={filterSize:a,strides:r,pad:o,dimRoundingMode:s};return Cu.runKernel(Mi,u,d)}}),xy={kernelName:Di,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,n)=>{const[a,r]=t,{filterSize:o,strides:s,pad:i}=n;return{x:()=>yy(e,a,r,o,s,i)}}},vy={kernelName:Bi,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[a]=t,{axis:r}=n,o=No(r,a.shape),s=yo(jp(a.shape,o)[1]);return{x:()=>{const t=a.shape.slice();o.forEach((e=>{t[e]=1}));const n=rp(e,t);return zd(Bd(n,df(a.shape,"float32")),s)}}}},wy={kernelName:Wi,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,n)=>{const a=n,{axis:r}=a,[o,s]=t,i=py(e,s,o,No(r,o.shape));return{x:()=>i.x()}}},ky={kernelName:Vi,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,a]=t;return{a:()=>Bd(e,Dd(Fm(n,a),"float32")),b:()=>Bd(e,Dd(Mp(n,a),"float32"))}}},Iy={kernelName:Ui,inputsToSave:["x"],gradFunc:(e,t,n)=>{const a=t[0],{paddings:r}=n,o=r.map((e=>e[0]));return{x:()=>Cf(e,o,a.shape)}}},Sy={kernelName:Gi,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,a]=t,r=sh(n.shape,a.shape);return{a:()=>{const t=oh(n.shape,r);return t.length>0?rp(Vp(e,t),n.shape):e},b:()=>{const t=Bd(e,sf(Op(zd(n,a)))),o=oh(a.shape,r);return o.length>0?rp(Vp(t,o),a.shape):t}}}},Ny={kernelName:ji,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,a]=t,r=sh(n.shape,a.shape);return{a:()=>{const t=Bd(e,Dd(a,"float32")),o=oh(n.shape,r);return o.length>0?rp(Vp(t,o),n.shape):t},b:()=>{const t=Bd(e,Dd(n,"float32")),o=oh(a.shape,r);return o.length>0?rp(Vp(t,o),a.shape):t}}}},Cy={kernelName:Ki,gradFunc:e=>({x:()=>sf(e)})},Ty={kernelName:Zi,inputsToSave:["indices"],gradFunc:(e,t)=>{const n=t[0];return{indices:()=>uf(n.shape,"float32")}}},Ey={kernelName:Ji,gradFunc:e=>({x:()=>Ud(e)})},Ry={kernelName:$i,saveAllInputs:!0,gradFunc:(e,t,n)=>{const{axis:a}=n;return Wf(e,a).map((e=>()=>e))}},_y={kernelName:ec,inputsToSave:["x"],gradFunc:(e,t,n)=>{const a=t[0],{paddings:r}=n,o=r.map((e=>e[0]));return{x:()=>Cf(e,o,a.shape)}}},Ay={kernelName:tc,inputsToSave:["a","b"],outputsToSave:[!0],gradFunc:(e,t)=>{const[n,a,r]=t,o=n,s=a,i=sh(o.shape,s.shape);return{a:()=>{const t=Dd(s,"float32");let n=Bd(e,Bd(t,eh(o,th(t,Hd(1)))));const a=oh(o.shape,i);return a.length>0&&(n=Vp(n,a)),rp(n,o.shape)},b:()=>{const t=Mp(o,0),n=Vf(t,zp(o),Ud(o));let a=Bd(e,Bd(r,n));const c=oh(s.shape,i);return c.length>0&&(a=Vp(a,c)),rp(a,s.shape)}}}},Fy={kernelName:nc,inputsToSave:["x","alpha"],gradFunc:(e,t)=>{const[n,a]=t,r=Mp(n,0);return{x:()=>Vf(r,e,Bd(e,a)),alpha:()=>{let t=Vf(r,Ud(e),Bd(e,n));const o=oh(a.shape,e.shape);return o.length>0&&(t=Vp(t,o)),rp(t,a.shape)}}}};const Oy=Pu({cumprod_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],a=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const r={x:Mu(e,"x","cumprod")},o={axis:t,exclusive:n,reverse:a};return Cu.runKernel(Ps,r,o)}});function Dy(e,t,n){const a=e.shape.length,r=a-n.length,o=Xp(n,a);let s=e;null!=o&&(s=Hf(e,o));const i=s.shape.slice(),c=i.splice(a-n.length,n.length).reduce(((e,t)=>e*t),1);i.push(c);let l=function(e,t,n){const a=e.shape.slice();a[n]=1;const r=rp(t,a),o=Oy(e,n,!0,!1),s=Oy(e,n,!0,!0),i=Bd(o,s);return Bd(r,i)}(s.reshape(i),t,r);if(l=l.reshape(s.shape),null!=o){const e=Yp(o);l=Hf(l,e)}return l}const My={kernelName:ac,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[a]=t,{axis:r}=n;let o=[];return o=void 0===r||null===r?a.shape.map(((e,t)=>t)):"number"===typeof r?[r]:r,{x:()=>Dy(a,e,o)}}},Ly={kernelName:Qs,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,a]=t,r=sh(n.shape,a.shape);return{a:()=>{const t=zd(e,Dd(a,"float32")),o=oh(n.shape,r);return o.length>0?rp(Vp(t,o),n.shape):t},b:()=>{let t=Bd(e,Dd(n,"float32"));const o=oh(a.shape,r);o.length>0&&(t=rp(Vp(t,o),a.shape));const s=Vd(a);return sf(zd(t,Dd(s,"float32")))}}}},Py={kernelName:lc,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>zd(e,sf(Vd(n)))}}},zy={kernelName:gc,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t,a=Bd(Fm(n,6),Zf(n));return{x:()=>Bd(e,Dd(a,"float32"))}}},By={kernelName:uc,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>Bd(e,Dd(Zf(n),"float32"))}}},Wy={kernelName:dc,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>rp(e,n.shape)}}},Vy={kernelName:fc,inputsToSave:["images"],gradFunc:(e,t,n)=>{const[a]=t,r={dy:e,images:a};return{images:()=>Cu.runKernel(mc,r,n)}}},Uy={kernelName:hc,inputsToSave:["images"],gradFunc:(e,t,n)=>{const[a]=t,r={dy:e,images:a};return{images:()=>Cu.runKernel(pc,r,n)}}},Gy={kernelName:bc,gradFunc:(e,t,n)=>{const{dims:a}=n,r=No(a,e.shape);return{x:()=>kf(e,r)}}},Hy={kernelName:yc,gradFunc:e=>({x:()=>Ud(e)})},jy={kernelName:xc,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>sf(zd(e,Bd(eh(n,1.5),2)))}}};const Ky=Pu({logicalNot_:function(e){const t={x:Mu(e,"x","logicalNot","bool")};return Cu.runKernel(Ei,t)}}),qy={kernelName:Ic,inputsToSave:["condition"],gradFunc:(e,t)=>{const[n]=t;return{condition:()=>Dd(Ud(n),"float32"),t:()=>Bd(e,Dd(n,e.dtype)),e:()=>Bd(e,Dd(Ky(n),e.dtype))}}},Xy={kernelName:Sc,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>{const t=Mp(n,Hd(0)),a=Hd(mg),r=Hd(gg),o=Bd(e,r),s=Bd(Bd(e,a),Rp(Dd(n,"float32")));return Vf(t,o,s)}}}},Yy={kernelName:Rc,outputsToSave:[!0],gradFunc:(e,t)=>{const[n]=t;return{x:()=>Bd(e,Bd(n,th(Hd(1),n)))}}},Qy={kernelName:Ec,gradFunc:e=>({x:()=>Ud(e)})};const Jy=Pu({cos_:function(e){const t={x:Mu(e,"x","cos","float32")};return Cu.runKernel(Ms,t)}}),Zy={kernelName:Cc,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>Bd(Jy(Dd(n,"float32")),e)}}};const $y=Pu({cosh_:function(e){const t={x:Mu(e,"x","cosh","float32")};return Cu.runKernel(Ls,t)}}),ex={kernelName:Tc,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>Bd($y(Dd(n,"float32")),e)}}},tx={kernelName:Nc,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[a]=t,{begin:r,size:o}=n,s=a.shape,[i,c]=Ph(a,r,o),l=[];for(let u=0;u<e.rank;u++)l.push([i[u],s[u]-i[u]-c[u]]);return{x:()=>pf(e,l)}}},nx={kernelName:Mc,outputsToSave:[!0],gradFunc:(e,t,n)=>{const[a]=t,{dim:r}=n,o=Bd(e,a);return{logits:()=>th(o,Bd(Vp(o,[r],true),a))}}},ax={kernelName:_c,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>Bd(e,Nf(n))}}};const rx=Pu({batchToSpaceND_:function(e,t,n){const a=Mu(e,"x","batchToSpaceND"),r=t.reduce(((e,t)=>e*t));mo(a.rank>=1+t.length,(()=>"input rank is ".concat(a.rank," but should be > than blockShape.length ").concat(t.length))),mo(n.length===t.length,(()=>"crops.length is ".concat(n.length," but should be equal to blockShape.length  ").concat(t.length))),mo(a.shape[0]%r===0,(()=>"input tensor batch is ".concat(a.shape[0]," but is not divisible by the product of ")+"the elements of blockShape ".concat(t.join(" * ")," === ").concat(r)));const o={x:a},s={blockShape:t,crops:n};return Cu.runKernel(xs,o,s)}}),ox={kernelName:Oc,gradFunc:(e,t,n)=>{const{blockShape:a,paddings:r}=n;return{x:()=>rx(e,a,r)}}},sx={kernelName:Dc,gradFunc:(e,t,n)=>{const{axis:a}=n;return{x:()=>pp(e,a)}}},ix={kernelName:Vc,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,a]=t,r=Hd(2);return{a:()=>Bd(e,Bd(r,th(n,a))),b:()=>Bd(e,Bd(r,th(a,n)))}}},cx={kernelName:Xc,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,a]=t,r=sh(n.shape,a.shape);return{a:()=>{let t=e;const a=oh(n.shape,r);return a.length>0&&(t=Vp(t,a)),rp(t,n.shape)},b:()=>{let t=e;const n=oh(a.shape,r);return n.length>0&&(t=Vp(t,n)),rp(sf(t),a.shape)}}}},lx={kernelName:Jc,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[a]=t,{reps:r}=n;return{x:()=>{let t=Ud(a);if(1===a.rank)for(let n=0;n<r[0];++n)t=Ld(t,Cf(e,[n*a.shape[0]],[a.shape[0]]));else if(2===a.rank)for(let n=0;n<r[0];++n)for(let o=0;o<r[1];++o)t=Ld(t,Cf(e,[n*a.shape[0],o*a.shape[1]],[a.shape[0],a.shape[1]]));else if(3===a.rank)for(let n=0;n<r[0];++n)for(let o=0;o<r[1];++o)for(let s=0;s<r[2];++s)t=Ld(t,Cf(e,[n*a.shape[0],o*a.shape[1],s*a.shape[2]],[a.shape[0],a.shape[1],a.shape[2]]));else{if(4!==a.rank)throw new Error("Gradient for tile operation is not implemented for rank-"+"".concat(a.rank," tensors yet."));for(let n=0;n<r[0];++n)for(let o=0;o<r[1];++o)for(let s=0;s<r[2];++s)for(let i=0;i<r[3];++i)t=Ld(t,Cf(e,[n*a.shape[0],o*a.shape[1],s*a.shape[2],i*a.shape[3]],[a.shape[0],a.shape[1],a.shape[2],a.shape[3]]))}return t}}}},ux={kernelName:al,inputsToSave:["segmentIds"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>function(e,t){const n=ih(t,Ud(t)),a=Dp(e,n);let r=Lp(t,Hd(0,"int32"));const o=a.rank-r.rank;for(let i=0;i<o;++i)r=_p(r,i+1);r=Zp(r,df(a.shape,"bool"));const s=Ud(a);return Vf(r,a,s)}(e,n)}}};const dx=[sb,ib,cb,lb,ub,db,hb,pb,fb,mb,gb,bb,xb,wb,kb,Sb,Nb,Cb,Tb,Eb,Rb,_b,Fb,Ab,Db,Lb,zb,Wb,Vb,Ub,Ly,Gb,Hb,jb,Kb,qb,Yb,Xb,Jb,$b,ny,ay,ry,oy,sy,iy,cy,ly,uy,hy,fy,fy,my,by,xy,vy,wy,ky,Iy,Sy,Ny,Cy,Ty,Ey,Ry,_y,_y,Ay,Fy,My,Py,zy,By,Wy,Vy,Uy,Gy,Hy,jy,qy,Xy,Yy,Qy,Zy,ex,tx,nx,ax,ox,ox,sx,sx,{kernelName:Ac,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>zd(e,Bd(Wd(Dd(n,"float32")),2))}}},ix,{kernelName:Uc,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>Bd(e,Bd(Dd(n,"float32"),2))}}},{kernelName:ol,gradFunc:e=>({x:()=>Ud(e)})},cx,{kernelName:Fc,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[a]=t,r=a.shape.slice(),{axis:o}=n;No(o,a.shape).forEach((e=>{r[e]=1}));const s=rp(e,r),i=Bd(s,df(a.shape,"float32"));return{x:()=>i}}},{kernelName:Yc,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>zd(e,Vd(Jy(n)))}}},{kernelName:Qc,outputsToSave:[!0],gradFunc:(e,t)=>{const[n]=t;return{x:()=>Bd(th(Hd(1),Vd(n)),e)}}},lx,{kernelName:el,gradFunc:(e,t,n)=>{const a=n,{perm:r}=a,o=Yp(r);return{x:()=>Hf(e,o)}}},{kernelName:nl,gradFunc:(e,t,n)=>{const a=n,{axis:r}=a;return{value:()=>Mf(e,r)}}},ux,{kernelName:rl,gradFunc:e=>({x:()=>Ud(e)})}];for(const n of dx)xl(n);su().prototype.abs=function(){return this.throwIfDisposed(),ah(this)};const hx=Pu({acos_:function(e){const t={x:Mu(e,"x","acos")};return Cu.runKernel(ts,t)}});su().prototype.acos=function(){return this.throwIfDisposed(),hx(this)};const px=Pu({acosh_:function(e){const t={x:Mu(e,"x","acosh")};return Cu.runKernel(ns,t)}});su().prototype.acosh=function(){return this.throwIfDisposed(),px(this)},su().prototype.add=function(e){return this.throwIfDisposed(),Ld(this,e)},su().prototype.all=function(e,t){return this.throwIfDisposed(),Wh(this,e,t)},su().prototype.any=function(e,t){return this.throwIfDisposed(),Vh(this,e,t)},su().prototype.argMax=function(e){return this.throwIfDisposed(),Uh(this,e)};const fx=Pu({argMin_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const n={x:Mu(e,"x","argMin")},a={axis:t};return Cu.runKernel(cs,n,a)}});su().prototype.argMin=function(e){return this.throwIfDisposed(),fx(this,e)},su().prototype.asScalar=function(){return this.throwIfDisposed(),mo(1===this.size,(()=>"The array must have only 1 element.")),rp(this,[])},su().prototype.asType=function(e){return this.throwIfDisposed(),Dd(this,e)},su().prototype.as1D=function(){return this.throwIfDisposed(),rp(this,[this.size])},su().prototype.as2D=function(e,t){return this.throwIfDisposed(),rp(this,[e,t])},su().prototype.as3D=function(e,t,n){return this.throwIfDisposed(),rp(this,[e,t,n])},su().prototype.as4D=function(e,t,n,a){return this.throwIfDisposed(),rp(this,[e,t,n,a])},su().prototype.as5D=function(e,t,n,a,r){return this.throwIfDisposed(),rp(this,[e,t,n,a,r])};const mx=Pu({asin_:function(e){const t={x:Mu(e,"x","asin")};return Cu.runKernel(ls,t)}});su().prototype.asin=function(){return this.throwIfDisposed(),mx(this)};const gx=Pu({asinh_:function(e){const t={x:Mu(e,"x","asinh")};return Cu.runKernel(us,t)}});su().prototype.asinh=function(){return this.throwIfDisposed(),gx(this)};const bx=Pu({atan_:function(e){const t={x:Mu(e,"x","atan")};return Cu.runKernel(ds,t)}});su().prototype.atan=function(){return this.throwIfDisposed(),bx(this)};const yx=Pu({atan2_:function(e,t){let n=Mu(e,"a","atan2"),a=Mu(t,"b","atan2");[n,a]=yu(n,a);const r={a:n,b:a};return Cu.runKernel(ps,r)}});su().prototype.atan2=function(e){return this.throwIfDisposed(),yx(this,e)};const xx=Pu({atanh_:function(e){const t={x:Mu(e,"x","atanh")};return Cu.runKernel(hs,t)}});su().prototype.atanh=function(){return this.throwIfDisposed(),xx(this)},su().prototype.avgPool=function(e,t,n,a){return this.throwIfDisposed(),op(this,e,t,n,a)},su().prototype.batchToSpaceND=function(e,t){return this.throwIfDisposed(),rx(this,e,t)},su().prototype.batchNorm=function(e,t,n,a,r){return this.throwIfDisposed(),ip(this,e,t,n,a,r)},su().prototype.broadcastTo=function(e){return this.throwIfDisposed(),dp(this,e)},su().prototype.cast=function(e){return this.throwIfDisposed(),Dd(this,e)};const vx=Pu({ceil_:function(e){const t={x:Mu(e,"x","ceil","float32")};return Cu.runKernel(Ss,t)}});su().prototype.ceil=function(){return this.throwIfDisposed(),vx(this)},su().prototype.clipByValue=function(e,t){return this.throwIfDisposed(),hp(this,e,t)},su().prototype.concat=function(e,t){return this.throwIfDisposed(),e instanceof ou&&(e=[e]),pp([this,...e],t)},su().prototype.conv1d=function(e,t,n,a,r,o){return this.throwIfDisposed(),xp(this,e,t,n,a,r,o)},su().prototype.conv2dTranspose=function(e,t,n,a,r){return this.throwIfDisposed(),wp(this,e,t,n,a,r)},su().prototype.conv2d=function(e,t,n,a,r,o){return this.throwIfDisposed(),yp(this,e,t,n,a,r,o)},su().prototype.cos=function(){return this.throwIfDisposed(),Jy(this)},su().prototype.cosh=function(){return this.throwIfDisposed(),$y(this)},su().prototype.cumprod=function(e,t,n){return this.throwIfDisposed(),Oy(this,e,t,n)},su().prototype.cumsum=function(e,t,n){return this.throwIfDisposed(),Bb(this,e,t,n)};const wx=Pu({depthToSpace_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"NHWC";const a=Mu(e,"x","depthToSpace","float32"),r="NHWC"===n?a.shape[1]:a.shape[2],o="NHWC"===n?a.shape[2]:a.shape[3],s="NHWC"===n?a.shape[3]:a.shape[1];mo(t>1,(()=>"blockSize should be > 1 for depthToSpace, but was: ".concat(t))),mo(r*t>=0,(()=>"Negative dimension size caused by overflow when multiplying\n    ".concat(r," and ").concat(t,"  for depthToSpace with input shape\n    ").concat(a.shape))),mo(o*t>=0,(()=>"Negative dimension size caused by overflow when multiplying\n    ".concat(o," and ").concat(t," for depthToSpace with input shape\n        ").concat(a.shape))),mo(s%(t*t)===0,(()=>"Dimension size must be evenly divisible by ".concat(t*t," but is ").concat(s," for depthToSpace with input shape ").concat(a.shape)));const i={x:a},c={blockSize:t,dataFormat:n};return Cu.runKernel(Vs,i,c)}});su().prototype.depthToSpace=function(e,t){return this.throwIfDisposed(),wx(this,e,t)},su().prototype.depthwiseConv2d=function(e,t,n,a,r,o){return this.throwIfDisposed(),Cp(this,e,t,n,a,r,o)};const kx=Pu({dilation2d_:function(e,t,n,a){let r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:[1,1],o=arguments.length>5&&void 0!==arguments[5]?arguments[5]:"NHWC";const s=Mu(e,"x","dilation2d"),i=Mu(t,"filter","dilation2d");mo(3===s.rank||4===s.rank,(()=>"Error in dilation2d: input must be rank 3 or 4, but got rank "+"".concat(s.rank,"."))),mo(3===i.rank,(()=>"Error in dilation2d: filter must be rank 3, but got rank "+"".concat(i.rank,"."))),mo("NHWC"===o,(()=>"Error in dilation2d: Only NHWC is currently supported, "+"but got dataFormat of ".concat(o)));let c=s,l=!1;3===s.rank&&(c=rp(s,[1,s.shape[0],s.shape[1],s.shape[2]]),l=!0),mo(c.shape[3]===i.shape[2],(()=>"Error in dilation2d:  input and filter must have the same depth: ".concat(c.shape[3]," vs ").concat(i.shape[2])));const u={x:c,filter:i},d={strides:n,pad:a,dilations:r},h=Cu.runKernel(Ks,u,d);return l?rp(h,[h.shape[1],h.shape[2],h.shape[3]]):h}});su().prototype.dilation2d=function(e,t,n,a,r){return this.throwIfDisposed(),kx(this,e,t,n,a,r)};const Ix=Pu({divNoNan_:function(e,t){let n=Mu(e,"a","div"),a=Mu(t,"b","div");[n,a]=yu(n,a);const r=zd(n,a),o=Ud(r),s=Ep(a,o);return Vf(s,o,r)}});su().prototype.divNoNan=function(e){return this.throwIfDisposed(),Ix(this,e)},su().prototype.div=function(e){return this.throwIfDisposed(),zd(this,e)};const Sx=Pu({dot_:function(e,t){const n=Mu(e,"t1","dot"),a=Mu(t,"t2","dot");mo((1===n.rank||2===n.rank)&&(1===a.rank||2===a.rank),(()=>"Error in dot: inputs must all be rank 1 or 2, but got ranks "+"".concat(n.rank," and ").concat(a.rank,".")));const r=1===n.rank?n.size:n.shape[1],o=1===a.rank?a.size:a.shape[0];if(mo(r===o,(()=>"Error in dot: inner dimensions of inputs must match, but got "+"".concat(r," and ").concat(o,"."))),1===n.rank&&1===a.rank){const e=rp(n,[1,-1]),t=rp(a,[-1,1]),r=$p(e,t);return rp(r,[])}if(1===n.rank&&2===a.rank){const e=rp(n,[1,-1]),t=rp(a,[a.shape[0],a.shape[1]]),r=$p(e,t);return rp(r,[r.size])}if(2===n.rank&&1===a.rank){const e=rp(a,[-1,1]),t=$p(n,e);return rp(t,[t.size])}{const e=rp(a,[a.shape[0],a.shape[1]]);return $p(n,e)}}});su().prototype.dot=function(e){return this.throwIfDisposed(),Sx(this,e)},su().prototype.elu=function(){return this.throwIfDisposed(),Tp(this)},su().prototype.equal=function(e){return this.throwIfDisposed(),Ep(this,e)};const Nx=Pu({erf_:function(e){let t=Mu(e,"x","erf");mo("int32"===t.dtype||"float32"===t.dtype,(()=>"Input dtype must be `int32` or `float32`.")),"int32"===t.dtype&&(t=Dd(t,"float32"));const n={x:t};return Cu.runKernel(ei,n)}});su().prototype.erf=function(){return this.throwIfDisposed(),Nx(this)};const Cx=Pu({euclideanNorm_:function(e){return Bm(e,"euclidean",arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,arguments.length>2&&void 0!==arguments[2]&&arguments[2])}});su().prototype.euclideanNorm=function(e,t){return this.throwIfDisposed(),Cx(this,e,t)},su().prototype.exp=function(){return this.throwIfDisposed(),Rp(this)},su().prototype.expandDims=function(e){return this.throwIfDisposed(),_p(this,e)};const Tx=Pu({expm1_:function(e){const t={x:Mu(e,"x","expm1")};return Cu.runKernel(ri,t)}});su().prototype.expm1=function(){return this.throwIfDisposed(),Tx(this)},su().prototype.fft=function(){return this.throwIfDisposed(),Kf(this)},su().prototype.flatten=function(){return this.throwIfDisposed(),rp(this,[this.size])},su().prototype.floor=function(){return this.throwIfDisposed(),Op(this)},su().prototype.floorDiv=function(e){return this.throwIfDisposed(),Pd(this,e)},su().prototype.gather=function(e,t,n){return this.throwIfDisposed(),Dp(this,e,t,n)},su().prototype.greaterEqual=function(e){return this.throwIfDisposed(),Lp(this,e)},su().prototype.greater=function(e){return this.throwIfDisposed(),Mp(this,e)},su().prototype.ifft=function(){return this.throwIfDisposed(),Xf(this)},su().prototype.irfft=function(){return this.throwIfDisposed(),Yf(this)};const Ex=Pu({isFinite_:function(e){const t={x:Mu(e,"x","isFinite")};return Cu.runKernel(yi,t)}});su().prototype.isFinite=function(){return this.throwIfDisposed(),Ex(this)};const Rx=Pu({isInf_:function(e){const t={x:Mu(e,"x","isInf")};return Cu.runKernel(xi,t)}});su().prototype.isInf=function(){return this.throwIfDisposed(),Rx(this)};const _x=Pu({isNaN_:function(e){const t={x:Mu(e,"x","isNaN")};return Cu.runKernel(vi,t)}});su().prototype.isNaN=function(){return this.throwIfDisposed(),_x(this)},su().prototype.leakyRelu=function(e){return this.throwIfDisposed(),Pp(this,e)},su().prototype.lessEqual=function(e){return this.throwIfDisposed(),Fm(this,e)},su().prototype.less=function(e){return this.throwIfDisposed(),Lm(this,e)};const Ax=Pu({localResponseNormalization_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:5,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1,r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:.5;const o=Mu(e,"x","localResponseNormalization");mo(4===o.rank||3===o.rank,(()=>"Error in localResponseNormalization: x must be rank 3 or 4 but got\n               rank ".concat(o.rank,"."))),mo(vo(t),(()=>"Error in localResponseNormalization: depthRadius must be an "+"integer but got depthRadius ".concat(t,".")));let s=o,i=!1;3===o.rank&&(i=!0,s=rp(o,[1,o.shape[0],o.shape[1],o.shape[2]]));const c={x:s},l={depthRadius:t,bias:n,alpha:a,beta:r},u=Cu.runKernel(_i,c,l);return i?rp(u,[u.shape[1],u.shape[2],u.shape[3]]):u}});su().prototype.localResponseNormalization=function(e,t,n,a){return this.throwIfDisposed(),Ax(this,e,t,n,a)};const Fx=Pu({logSigmoid_:function(e){const t=Mu(e,"x","logSigmoid");return Gd((e=>({value:sf(Ff(sf(e))),gradFunc:t=>Bd(t,Nf(sf(e)))})))(t)}});su().prototype.logSigmoid=function(){return this.throwIfDisposed(),Fx(this)},su().prototype.logSoftmax=function(e){return this.throwIfDisposed(),Up(this,e)},su().prototype.logSumExp=function(e,t){return this.throwIfDisposed(),Jp(this,e,t)},su().prototype.log=function(){return this.throwIfDisposed(),zp(this)},su().prototype.log1p=function(){return this.throwIfDisposed(),Bp(this)},su().prototype.logicalAnd=function(e){return this.throwIfDisposed(),Zp(this,e)},su().prototype.logicalNot=function(){return this.throwIfDisposed(),Ky(this)};const Ox=Pu({logicalOr_:function(e,t){const n=Mu(e,"a","logicalOr","bool"),a=Mu(t,"b","logicalOr","bool");sh(n.shape,a.shape);const r={a:n,b:a};return Cu.runKernel(Ri,r)}});su().prototype.logicalOr=function(e){return this.throwIfDisposed(),Ox(this,e)};const Dx=Pu({logicalXor_:function(e,t){const n=Mu(e,"a","logicalXor","bool"),a=Mu(t,"b","logicalXor","bool");return sh(n.shape,a.shape),Zp(Ox(e,t),Ky(Zp(e,t)))}});su().prototype.logicalXor=function(e){return this.throwIfDisposed(),Dx(this,e)},su().prototype.matMul=function(e,t,n){return this.throwIfDisposed(),$p(this,e,t,n)},su().prototype.maxPool=function(e,t,n,a){return this.throwIfDisposed(),ef(this,e,t,n,a)},su().prototype.max=function(e,t){return this.throwIfDisposed(),Wp(this,e,t)},su().prototype.maximum=function(e){return this.throwIfDisposed(),ih(this,e)},su().prototype.mean=function(e,t){return this.throwIfDisposed(),nf(this,e,t)},su().prototype.min=function(e,t){return this.throwIfDisposed(),af(this,e,t)},su().prototype.minimum=function(e){return this.throwIfDisposed(),rf(this,e)};const Mx=Pu({mirrorPad_:function(e,t,n){mo("reflect"===n||"symmetric"===n,(()=>"Invalid mode. Mode must be either reflect or symmetric. "+"Got ".concat(n,".")));const a=Mu(e,"x","mirrorPad");if(0===a.rank)throw new Error("mirrorPad(scalar) is not defined. Pass non-scalar to mirrorPad");mo(t.length===a.rank,(()=>"Padding doesn't match input. Must be ".concat(a.rank,". ")+"Got ".concat(t.length,".")));const r="reflect"===n?1:0;for(let i=0;i<a.rank;i++)mo(2===t[i].length,(()=>"Invalid number of paddings. Must be length of 2 each.")),mo(t[i][0]>=0&&t[i][0]<=a.shape[i]-r&&t[i][1]>=0&&t[i][1]<=a.shape[i]-r,(()=>"Padding in dimension ".concat(i," cannot be greater than or equal ")+"to ".concat(a.shape[i]-r," or less than 0 for input of ")+"shape ".concat(a.shape)));const o={paddings:t,mode:n},s={x:a};return Cu.runKernel(Ui,s,o)}});su().prototype.mirrorPad=function(e,t){return this.throwIfDisposed(),Mx(this,e,t)};const Lx=Pu({mod_:function(e,t){let n=Mu(e,"a","mod"),a=Mu(t,"b","mod");[n,a]=yu(n,a);const r={a:n,b:a};return Cu.runKernel(Gi,r)}});su().prototype.mod=function(e){return this.throwIfDisposed(),Lx(this,e)},su().prototype.mul=function(e){return this.throwIfDisposed(),Bd(this,e)},su().prototype.neg=function(){return this.throwIfDisposed(),sf(this)},su().prototype.norm=function(e,t,n){return this.throwIfDisposed(),Bm(this,e,t,n)},su().prototype.notEqual=function(e){return this.throwIfDisposed(),cf(this,e)},su().prototype.oneHot=function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;return this.throwIfDisposed(),lf(this,e,t,n)},su().prototype.onesLike=function(){return this.throwIfDisposed(),hf(this)},su().prototype.pad=function(e,t){return this.throwIfDisposed(),pf(this,e,t)};const Px=Pu({pool_:function(e,t,n,a,r,o,s){null==r&&(r=[1,1]),null==o&&(o=1),0===a&&(a="valid");const i=Mu(e,"x","maxPool");let c=i,l=!1;3===i.rank&&(l=!0,c=rp(i,[1,i.shape[0],i.shape[1],i.shape[2]])),mo(ep(o,r),(()=>"Error in pool: Either strides or dilations must be 1. "+"Got strides ".concat(o," and dilations '").concat(r,"'")));const u=Hh(c.shape,t,o,r,a),d=[u.dilationHeight,u.dilationWidth];let h;h="same"===a?function(e,t){const n=e.map(((e,n)=>e+(e-1)*(t[n]-1))),a=n.map((e=>e-1)),r=a.map((e=>Math.floor(e/2))),o=a.map(((e,t)=>e-r[t]));return a.map(((e,t)=>[r[t],o[t]]))}([u.filterHeight,u.filterWidth],d):[[0,0],[0,0]];const p=1===d[0]&&1===d[1],[f,m]=function(e,t,n){const a=n.map((e=>e[0])),r=n.map((e=>e[1])),o=e.concat(a,r),s=t.map(((e,t)=>(e-o[t]%e)%e)),i=r.map(((e,t)=>e+s[t])),c=t.map(((e,t)=>[a[t],i[t]])),l=t.map(((e,t)=>[0,s[t]]));return[c,l]}([u.inHeight,u.inWidth],d,h),g=p?a:"valid",b=p?c:Ib(c,d,f),y=("avg"===n?()=>op(b,t,o,g,s):()=>ef(b,t,o,g,s))(),x=p?y:rx(y,d,m);return l?rp(x,[x.shape[1],x.shape[2],x.shape[3]]):x}});su().prototype.pool=function(e,t,n,a,r,o){return this.throwIfDisposed(),Px(this,e,t,n,a,r,o)},su().prototype.pow=function(e){return this.throwIfDisposed(),eh(this,e)},su().prototype.prelu=function(e){return this.throwIfDisposed(),ff(this,e)};const zx=Pu({prod_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],a=Mu(e,"x","prod");"bool"===a.dtype&&(a=Dd(a,"int32"));const r={x:a},o={axis:t,keepDims:n};return Cu.runKernel(ac,r,o)}});su().prototype.prod=function(e,t){return this.throwIfDisposed(),zx(this,e,t)};const Bx=Pu({reciprocal_:function(e){const t={x:Mu(e,"x","reciprocal")};return Cu.runKernel(lc,t)}});su().prototype.reciprocal=function(){return this.throwIfDisposed(),Bx(this)},su().prototype.relu=function(){return this.throwIfDisposed(),wf(this)},su().prototype.relu6=function(){return this.throwIfDisposed(),Jf(this)},su().prototype.reshapeAs=function(e){return this.throwIfDisposed(),rp(this,e.shape)},su().prototype.reshape=function(e){return this.throwIfDisposed(),rp(this,e)},su().prototype.resizeBilinear=function(e,t,n){return this.throwIfDisposed(),Rm(this,e,t,n)},su().prototype.resizeNearestNeighbor=function(e,t,n){return this.throwIfDisposed(),_m(this,e,t,n)},su().prototype.reverse=function(e){return this.throwIfDisposed(),kf(this,e)},su().prototype.rfft=function(){return this.throwIfDisposed(),qf(this)},su().prototype.round=function(){return this.throwIfDisposed(),Om(this)},su().prototype.rsqrt=function(){return this.throwIfDisposed(),Qb(this)},su().prototype.selu=function(){return this.throwIfDisposed(),If(this)},su().prototype.separableConv2d=function(e,t,n,a,r,o){return this.throwIfDisposed(),Sf(this,e,t,n,a,r,o)},su().prototype.sigmoid=function(){return this.throwIfDisposed(),Nf(this)};const Wx=Pu({sign_:function(e){const t={x:Mu(e,"x","sign")};return Cu.runKernel(Ec,t)}});su().prototype.sign=function(){return this.throwIfDisposed(),Wx(this)},su().prototype.sin=function(){return this.throwIfDisposed(),Mb(this)},su().prototype.sinh=function(){return this.throwIfDisposed(),Pb(this)},su().prototype.slice=function(e,t){return this.throwIfDisposed(),Cf(this,e,t)},su().prototype.softmax=function(e){return this.throwIfDisposed(),Af(this,e)},su().prototype.softplus=function(){return this.throwIfDisposed(),Ff(this)},su().prototype.spaceToBatchND=function(e,t){return this.throwIfDisposed(),Ib(this,e,t)},su().prototype.split=function(e,t){return this.throwIfDisposed(),Of(this,e,t)},su().prototype.sqrt=function(){return this.throwIfDisposed(),Wd(this)},su().prototype.square=function(){return this.throwIfDisposed(),Vd(this)},su().prototype.squaredDifference=function(e){return this.throwIfDisposed(),Hm(this,e)},su().prototype.squeeze=function(e){return this.throwIfDisposed(),Df(this,e)},su().prototype.stack=function(e,t){this.throwIfDisposed();const n=e instanceof ou?[this,e]:[this,...e];return Mf(n,t)},su().prototype.step=function(e){return this.throwIfDisposed(),Zf(this,e)};const Vx=Pu({stridedSlice_:function(e,t,n,a){let r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:0,o=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0,s=arguments.length>6&&void 0!==arguments[6]?arguments[6]:0,i=arguments.length>7&&void 0!==arguments[7]?arguments[7]:0,c=arguments.length>8&&void 0!==arguments[8]?arguments[8]:0;const l={x:Mu(e,"x","stridedSlice","string_or_numeric")},u={begin:t,end:n,strides:a,beginMask:r,endMask:o,ellipsisMask:s,newAxisMask:i,shrinkAxisMask:c};return Cu.runKernel(Hc,l,u)}});su().prototype.stridedSlice=function(e,t,n,a,r,o,s,i){return this.throwIfDisposed(),Vx(this,e,t,n,a,r,o,s,i)},su().prototype.sub=function(e){return this.throwIfDisposed(),th(this,e)},su().prototype.sum=function(e,t){return this.throwIfDisposed(),Vp(this,e,t)};const Ux=Pu({tan_:function(e){const t={x:Mu(e,"x","tan","float32")};return Cu.runKernel(Yc,t)}});su().prototype.tan=function(){return this.throwIfDisposed(),Ux(this)},su().prototype.tanh=function(){return this.throwIfDisposed(),Lf(this)},su().prototype.tile=function(e){return this.throwIfDisposed(),Ap(this,e)},su().prototype.toBool=function(){return this.throwIfDisposed(),Dd(this,"bool")},su().prototype.toFloat=function(){return this.throwIfDisposed(),Dd(this,"float32")},su().prototype.toInt=function(){return this.throwIfDisposed(),Dd(this,"int32")};const Gx=Pu({topk_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,n=!(arguments.length>2&&void 0!==arguments[2])||arguments[2];const a=Mu(e,"x","topk");if(0===a.rank)throw new Error("topk() expects the input to be of rank 1 or higher");const r=a.shape[a.shape.length-1];if(t<0)throw new Error("'k' passed to topk() must be >= 0 but got ".concat(t));if(t>r)throw new Error("'k' passed to topk() must be <= the last dimension (".concat(r,") ")+"but got ".concat(t));const o={x:a},s={k:t,sorted:n},[i,c]=Cu.runKernel(Zc,o,s);return{values:i,indices:c}}});su().prototype.topk=function(e,t){return this.throwIfDisposed(),Gx(this,e,t)},su().prototype.transpose=function(e){return this.throwIfDisposed(),Hf(this,e)};const Hx=Pu({unique_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const n=Mu(e,"x","unique","string_or_numeric");mo(n.rank>0,(()=>"The input tensor must be at least 1D"));const a={x:n},r={axis:t},[o,s]=Cu.runKernel(tl,a,r);return{values:o,indices:s}}});su().prototype.unique=function(e){return this.throwIfDisposed(),Hx(this,e)},su().prototype.unsortedSegmentSum=function(e,t){return this.throwIfDisposed(),Zb(this,e,t)},su().prototype.unstack=function(e){return this.throwIfDisposed(),Wf(this,e)},su().prototype.where=function(e,t){return this.throwIfDisposed(),Vf(e,this,t)},su().prototype.zerosLike=function(){return this.throwIfDisposed(),Ud(this)};class jx extends Error{constructor(e){super(e),Object.setPrototypeOf(this,jx.prototype)}}class Kx extends Error{constructor(e){super(e),Object.setPrototypeOf(this,Kx.prototype)}}class qx extends Error{constructor(e){super(e),Object.setPrototypeOf(this,qx.prototype)}}class Xx extends Error{constructor(e){super(e),Object.setPrototypeOf(this,Xx.prototype)}}class Yx extends Error{constructor(e){super(e),Object.setPrototypeOf(this,Yx.prototype)}}Error;class Qx{constructor(e){this.maxEntries=e||100,this.cache=new Map}get(e){let t;return this.cache.has(e)&&(t=this.cache.get(e),this.cache.delete(e),this.cache.set(e,t)),t}put(e,t){if(this.cache.has(e))this.cache.delete(e);else if(this.cache.size>=this.maxEntries){const e=this.cache.keys().next().value;this.cache.delete(e)}this.cache.set(e,t)}getMaxEntries(){return this.maxEntries}setMaxEntries(e){if(e<0)throw new Error("The maxEntries of LRU caches must be at least 0, but got ".concat(e,"."));if(this.maxEntries>e)for(let t=0;t<this.maxEntries-e;t++){const e=this.cache.keys().next().value;this.cache.delete(e)}this.maxEntries=e}}function Jx(e,t){if(Array.isArray(e)){let n=[];for(let a=0;a<t;a++)n=n.concat(e);return n}{const n=new Array(t);return n.fill(e),n}}function Zx(e,t){if(!e)throw new Yx(t)}function $x(e,t){let n=0;for(const a of e)a===t&&n++;return n}function ev(e){return 1===e.length?e[0]:e}function tv(e){return Array.isArray(e)?e:[e]}function nv(e){const t=e.replace(/(.)([A-Z][a-z0-9]+)/g,"$1_$2").replace(/([a-z])([A-Z])/g,"$1_$2").toLowerCase();return"_"!==t[0]?t:"private"+t}function av(e){return e.length<=1||-1===e.indexOf("_")?e:e.replace(/[_]+(\w|$)/g,((e,t)=>t.toUpperCase()))}let rv={};function ov(e){if(null===e||void 0===e)return null;const t={};return t.className=e.getClassName(),t.config=e.getConfig(),t}function sv(e){if(null!=e&&"object"===typeof e)if(Array.isArray(e))e.forEach((e=>sv(e)));else{const t=Object.keys(e);for(const n of t){const t=e[n];null!=t&&"object"===typeof t&&(Array.isArray(t)||"ndarray"!==t.type||"number"!==typeof t.value?sv(t):e[n]=t.value)}}}function iv(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{},a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"object",r=arguments.length>4&&void 0!==arguments[4]&&arguments[4];if("string"===typeof e){const r=e;let o;if(r in n)o=n[r];else if(r in rv)o=rv[r];else if(o=t[r],null==o)throw new qx("Unknown ".concat(a,": ").concat(e,". ")+"This may be due to one of the following reasons:\n"+"1. The ".concat(a," is defined in Python, in which ")+"case it needs to be ported to TensorFlow.js or your JavaScript code.\n"+"2. The custom ".concat(a," is defined in JavaScript, ")+"but is not registered properly with tf.serialization.registerClass().");return o}{const o=e;if(null==o.className||null==o.config)throw new qx("".concat(a,": Improper config format: ")+"".concat(JSON.stringify(o),".\n")+"'className' and 'config' must set.");const s=o.className;let i,c;if(s in n?[i,c]=n[s]:s in rv?[i,c]=rv.className:s in t&&([i,c]=t[s]),null==i)throw new qx("Unknown ".concat(a,": ").concat(s,". ")+"This may be due to one of the following reasons:\n"+"1. The ".concat(a," is defined in Python, in which ")+"case it needs to be ported to TensorFlow.js or your JavaScript code.\n"+"2. The custom ".concat(a," is defined in JavaScript, ")+"but is not registered properly with tf.serialization.registerClass().");if(null!=c){const e={};for(const n of Object.keys(rv))e[n]=rv[n];for(const r of Object.keys(n))e[r]=n[r];o.config.customObjects=e;const t=Object.assign({},rv);for(const r of Object.keys(n))rv[r]=n[r];sv(o.config);const a=c(i,o.config,n,r);return rv=Object.assign({},t),a}{const e=Object.assign({},rv);for(const a of Object.keys(n))rv[a]=n[a];const t=new i(o.config);return rv=Object.assign({},e),t}}}function cv(e,t){return-1*function(e,t){return e<t?-1:e>t?1:0}(e,t)}function lv(e){if(null==e)return e;const t=[];for(const n of e)-1===t.indexOf(n)&&t.push(n);return t}function uv(e){if(null==e)throw new qx("Invalid value in obj: ".concat(JSON.stringify(e)));for(const t in e)if(e.hasOwnProperty(t))return!1;return!0}function dv(e,t,n){if(null!=n&&e.indexOf(n)<0)throw new qx("".concat(n," is not a valid ").concat(t,".  Valid values are ").concat(e," or null/undefined."))}function hv(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1/0;return Zx(n>=0),Zx(a>=n),Array.isArray(e)&&e.length>=n&&e.length<=a&&e.every((e=>typeof e===t))}function pv(e,t){Array.isArray(e)?(mo(e.length>0,(()=>"".concat(t," is unexpectedly an empty array."))),e.forEach(((e,n)=>pv(e,"element ".concat(n+1," of ").concat(t))))):mo(Number.isInteger(e)&&e>0,(()=>"Expected ".concat(t," to be a positive integer, but got ")+"".concat(fv(e),".")))}function fv(e){return null===e?"null":Array.isArray(e)?"["+e.map((e=>fv(e))).join(",")+"]":"string"===typeof e?'"'.concat(e,'"'):"".concat(e)}function mv(e){return"relu"===e?"relu":"linear"===e?"linear":"elu"===e?"elu":null}let gv=0;function bv(){return gv++}const yv={};function xv(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:"";return e in yv||(yv[e]=0),yv[e]+=1,e+yv[e].toString()}const vv=["channelsFirst","channelsLast"],wv=["nearest","bilinear"],kv=["valid","same","causal"],Iv=["max","avg"],Sv=["sum","mul","concat","ave"],Nv=new Map;function Cv(e){dv(vv,"DataFormat",e)}function Tv(e){dv(kv,"PaddingMode",e)}function Ev(e){dv(Iv,"PoolMode",e)}const Rv=[],_v="/";function Av(e,t){Rv.push(e);try{const e=t();return Rv.pop(),e}catch(B){throw Rv.pop(),B}}function Fv(e){if(!Mv(e))throw new Error("Not a valid tensor name: '"+e+"'");return(0===Rv.length?"":Rv.join(_v)+_v)+e}function Ov(e){if(!Mv(e))throw new Error("Not a valid tensor name: '"+e+"'");Nv.has(e)||Nv.set(e,0);const t=Nv.get(e);if(Nv.set(e,Nv.get(e)+1),t>0){const n="".concat(e,"_").concat(t);return Nv.set(n,1),n}return e}const Dv=new RegExp(/^[A-Za-z0-9][-A-Za-z0-9\._\/]*$/);function Mv(e){return!!e.match(Dv)}function Lv(e,t,n){null==t&&(t=0),null==n&&(n=e.length);let a=1;for(let r=t;r<n;++r)a*=e[r];return a}function Pv(e){if(0===e.length)return Number.NaN;let t=Number.POSITIVE_INFINITY;for(let n=0;n<e.length;n++){const a=e[n];a<t&&(t=a)}return t}function zv(e){if(0===e.length)return Number.NaN;let t=Number.NEGATIVE_INFINITY;for(let n=0;n<e.length;n++){const a=e[n];a>t&&(t=a)}return t}function Bv(e,t){if(t<e)throw new qx("end (".concat(t,") < begin (").concat(e,") is forbidden."));const n=[];for(let a=e;a<t;++a)n.push(a);return n}let Wv;function Vv(){return null==Wv&&(Wv=Yu().epsilon()),Wv}function Uv(e,t){return Dd(e,t)}function Gv(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:-1;const n=e.shape.slice();return t<0&&(t=n.length+t+1),n.splice(t,0,1),rp(e,n)}function Hv(e,t,n){return Hu((()=>{switch(e.rank){case 1:return Tf(e,t,n);case 2:return Ef(e,[t,0],[n,e.shape[1]]);case 3:return Rf(e,[t,0,0],[n,e.shape[1],e.shape[2]]);case 4:return _f(e,[t,0,0,0],[n,e.shape[1],e.shape[2],e.shape[3]]);case 5:return Cf(e,[t,0,0,0,0],[n,e.shape[1],e.shape[2],e.shape[3],e.shape[4]]);case 6:return Cf(e,[t,0,0,0,0,0],[n,e.shape[1],e.shape[2],e.shape[3],e.shape[4],e.shape[5]]);default:throw new qx("sliceAlongFirstAxis() received an unsupported tensor rank: "+"".concat(e.rank))}}))}function jv(e,t,n){return Hu((()=>{switch(e.rank){case 1:return Tf(e,t,n);case 2:return Ef(e,[0,t],[e.shape[0],n]);case 3:return Rf(e,[0,0,t],[e.shape[0],e.shape[1],n]);case 4:return _f(e,[0,0,0,t],[e.shape[0],e.shape[1],e.shape[2],n]);default:throw new qx("sliceAlongLastAxis() received an unsupported tensor rank: "+"".concat(e.rank))}}))}function Kv(e,t,n,a){return Hu((()=>{switch(e.rank){case 1:return Tf(e,t,n);case 2:switch(a){case 1:return Hv(e,t,n);case 2:return jv(e,t,n);default:throw new qx("The axis is not within the rank of the tensor "+"".concat(a))}case 3:switch(a){case 1:return Hv(e,t,n);case 2:return Rf(e,[0,t,0],[e.shape[0],n,e.shape[2]]);case 3:return jv(e,t,n);default:throw new qx("The axis is not within the rank of the tensor "+"".concat(a))}case 4:switch(a){case 1:return Hv(e,t,n);case 2:return _f(e,[0,t,0,0],[e.shape[0],n,e.shape[2],e.shape[3]]);case 3:return _f(e,[0,0,t,0],[e.shape[0],e.shape[1],n,e.shape[3]]);case 4:return jv(e,t,n);default:throw new qx("The axis is not within the rank of the tensor "+"".concat(a))}default:throw new qx("sliceAlongLastAxis() received an unsupported tensor rank: "+"".concat(e.rank))}}))}function qv(e){let t,n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:-1;return n<0&&(t=e[0].rank,n=0!==t?t:0),n===e[0].rank&&(n=-1),pp(e,n)}function Xv(e,t){switch(e.rank){case 1:return fp([e,t]);case 2:return mp([e,t],0);case 3:return gp([e,t],0);case 4:return bp([e,t],0);default:throw new qx("concatAlongFirstAxis() received an unsupported "+"tensor rank: ".concat(e.rank))}}function Yv(e,t){if(Array.isArray(t)||(t=[t]),e.rank!==t.length)throw new qx("The length of input n (".concat(t.length,") does not match ")+"the number of dimensions in input x (".concat(e.rank,")"));return Ap(e,t)}function Qv(e){return yf(e,arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,arguments.length>3?arguments[3]:void 0,arguments.length>4?arguments[4]:void 0)}function Jv(e,t,n,a){if(e.rank<2||t.rank<2)throw new Xx("dot requires both inputs to be rank >= 2"+" but got x shape = ".concat(e.shape," and y shape = ").concat(t.shape));if(t.rank>=3){if(e.shape.slice(-1)[0]!==t.shape.slice(-2)[0])throw new Xx("If rank y >= 3, then the second last dim"+" of y must equal the last dim of x but got x shape = ".concat(e.shape," and ")+" y shape = ".concat(t.shape))}if(2===e.rank&&2===t.rank){return sm({a:e,b:t,transposeA:!1,transposeB:!1,bias:a?ew(e.rank,a,"channelsLast"):null,activation:n})}{const r=e.shape.slice(),o=r.pop();e=rp(e,[-1,o]);const s=t.shape.slice(),i=s.pop(),c=s.pop(),l=[...s,i],u=Array.from({length:t.rank},((e,n)=>0===n?t.rank-2:n<=t.rank-2?n-1:n));t=rp(Hf(t,u),[c,-1]);const d=[...r,...l];return rp(sm({a:e,b:t,transposeA:!1,transposeB:!1,bias:a?ew(e.rank,a,"channelsLast"):null,activation:n}),d)}}function Zv(e,t,n){return Hu((()=>(t=Array.isArray(t)?Pf(t,"int32"):Dd(t,"int32"),Dp(e,t,n))))}function $v(e){return Bd(e,e)}function ew(e,t,n){const a=t.shape;if(1!==t.rank&&t.rank!==e)throw new qx("Unexpected bias dimensions: ".concat(t.rank)+"; expected it to be 1 or ".concat(e));if(5===e){if("channelsFirst"===n)return 1===a.length?rp(t,[1,a[0],1,1,1]):rp(t,[1,a[3],a[0],a[1],a[2]]);if("channelsLast"===n)return 1===a.length?rp(t,[1,1,1,1,a[0]]):rp(t,[1].concat(a))}else if(4===e){if("channelsFirst"===n)return 1===a.length?rp(t,[1,a[0],1,1]):rp(t,[1,a[2],a[0],a[1]]);if("channelsLast"===n)return 1===a.length?rp(t,[1,1,1,a[0]]):rp(t,[1].concat(a))}else if(3===e){if("channelsFirst"===n)return 1===a.length?rp(t,[1,a[0],1]):rp(t,[1,a[1],a[0]]);if("channelsLast"===n)return 1===a.length?rp(t,[1,1,a[0]]):rp(t,[1].concat(a))}else if(e<3)return t;throw new qx("Unsupported input rank by biasAdd: ".concat(t.rank))}function tw(e,t,n){return Hu((()=>(null==n&&(n="channelsLast"),Cv(n),Ld(e,ew(e.rank,t,n)))))}function nw(e,t,n,a){return Hu((()=>jf(e,t,n,a)))}function aw(e,t){return arguments.length>2&&void 0!==arguments[2]&&arguments[2]?e():t()}const rw=["fanIn","fanOut","fanAvg"],ow=["normal","uniform","truncatedNormal"];class sw extends qd{fromConfigUsesCustomObjects(){return!1}getConfig(){return{}}}class iw extends sw{apply(e,t){return uf(e,t)}}iw.className="Zeros",Yd(iw);class cw extends sw{apply(e,t){return df(e,t)}}cw.className="Ones",Yd(cw);class lw extends sw{constructor(e){if(super(),"object"!==typeof e)throw new qx("Expected argument of type ConstantConfig but got ".concat(e));if(void 0===e.value)throw new qx("config must have value set but got ".concat(e));this.value=e.value}apply(e,t){return Hu((()=>Bd(Hd(this.value),df(e,t))))}getConfig(){return{value:this.value}}}lw.className="Constant",Yd(lw);class uw extends sw{constructor(e){super(),this.DEFAULT_MINVAL=-.05,this.DEFAULT_MAXVAL=.05,this.minval=e.minval||this.DEFAULT_MINVAL,this.maxval=e.maxval||this.DEFAULT_MAXVAL,this.seed=e.seed}apply(e,t){return xf(e,this.minval,this.maxval,t,this.seed)}getConfig(){return{minval:this.minval,maxval:this.maxval,seed:this.seed}}}uw.className="RandomUniform",Yd(uw);class dw extends sw{constructor(e){super(),this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=e.mean||this.DEFAULT_MEAN,this.stddev=e.stddev||this.DEFAULT_STDDEV,this.seed=e.seed}apply(e,t){if("float32"!==(t=t||"float32")&&"int32"!==t)throw new Xx("randomNormal does not support dType ".concat(t,"."));return Qv(e,this.mean,this.stddev,t,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}}dw.className="RandomNormal",Yd(dw);class hw extends sw{constructor(e){super(),this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=e.mean||this.DEFAULT_MEAN,this.stddev=e.stddev||this.DEFAULT_STDDEV,this.seed=e.seed}apply(e,t){if("float32"!==(t=t||"float32")&&"int32"!==t)throw new Xx("truncatedNormal does not support dType ".concat(t,"."));return Bf(e,this.mean,this.stddev,t,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}}hw.className="TruncatedNormal",Yd(hw);class pw extends sw{constructor(e){super(),this.gain=null!=e.gain?e.gain:1}apply(e,t){return Hu((()=>{if(2!==e.length||e[0]!==e[1])throw new qx("Identity matrix initializer can only be used for 2D square matrices.");return Bd(this.gain,Fp(e[0]))}))}getConfig(){return{gain:this.gain}}}pw.className="Identity",Yd(pw);class fw extends sw{constructor(e){if(super(),e.scale<0)throw new qx("scale must be a positive float. Got: ".concat(e.scale));var t;this.scale=null==e.scale?1:e.scale,this.mode=null==e.mode?"fanIn":e.mode,t=this.mode,dv(rw,"FanMode",t),this.distribution=null==e.distribution?"normal":e.distribution,function(e){dv(ow,"Distribution",e)}(this.distribution),this.seed=e.seed}apply(e,t){const n=function(e){let t,n,a=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"channelsLast";if(Cv(a),2===e.length)t=e[0],n=e[1];else if(-1!==[3,4,5].indexOf(e.length)){if("channelsFirst"===a){const a=Lv(e,2);t=e[1]*a,n=e[0]*a}else if("channelsLast"===a){const a=Lv(e,0,e.length-2);t=e[e.length-2]*a,n=e[e.length-1]*a}}else{const a=Lv(e);t=Math.sqrt(a),n=Math.sqrt(a)}return[t,n]}(e),a=n[0],r=n[1];let o=this.scale;if("fanIn"===this.mode?o/=Math.max(1,a):"fanOut"===this.mode?o/=Math.max(1,r):o/=Math.max(1,(a+r)/2),"normal"===this.distribution){const n=Math.sqrt(o);if("float32"!==(t=t||"float32")&&"int32"!==t)throw new Xx("".concat(this.getClassName()," does not support dType ").concat(t,"."));return Bf(e,0,n,t,this.seed)}{const n=Math.sqrt(3*o);return xf(e,-n,n,t,this.seed)}}getConfig(){return{scale:this.scale,mode:this.mode,distribution:this.distribution,seed:this.seed}}}fw.className="VarianceScaling",Yd(fw);class mw extends fw{constructor(e){super({scale:1,mode:"fanAvg",distribution:"uniform",seed:null==e?null:e.seed})}getClassName(){return fw.className}}mw.className="GlorotUniform",Yd(mw);class gw extends fw{constructor(e){super({scale:1,mode:"fanAvg",distribution:"normal",seed:null==e?null:e.seed})}getClassName(){return fw.className}}gw.className="GlorotNormal",Yd(gw);class bw extends fw{constructor(e){super({scale:2,mode:"fanIn",distribution:"normal",seed:null==e?null:e.seed})}getClassName(){return fw.className}}bw.className="HeNormal",Yd(bw);class yw extends fw{constructor(e){super({scale:2,mode:"fanIn",distribution:"uniform",seed:null==e?null:e.seed})}getClassName(){return fw.className}}yw.className="HeUniform",Yd(yw);class xw extends fw{constructor(e){super({scale:1,mode:"fanIn",distribution:"normal",seed:null==e?null:e.seed})}getClassName(){return fw.className}}xw.className="LeCunNormal",Yd(xw);class vw extends fw{constructor(e){super({scale:1,mode:"fanIn",distribution:"uniform",seed:null==e?null:e.seed})}getClassName(){return fw.className}}vw.className="LeCunUniform",Yd(vw);class ww extends sw{constructor(e){super(),this.DEFAULT_GAIN=1,this.ELEMENTS_WARN_SLOW=2e3,this.gain=null==e.gain?this.DEFAULT_GAIN:e.gain,this.seed=e.seed}apply(e,t){return Hu((()=>{if(e.length<2)throw new Xx("Shape must be at least 2D.");if("int32"!==t&&"float32"!==t&&void 0!==t)throw new TypeError("Unsupported data type ".concat(t,"."));const n=yo(e.slice(0,-1)),a=e[e.length-1],r=n*a;r>this.ELEMENTS_WARN_SLOW&&console.warn("Orthogonal initializer is being called on a matrix with more "+"than ".concat(this.ELEMENTS_WARN_SLOW," (").concat(r,") elements: ")+"Slowness may result.");const o=Qv([Math.max(a,n),Math.min(a,n)],0,1,t,this.seed),s=Km.qr(o,!1);let i=s[0];const c=s[1].flatten().stridedSlice([0],[Math.min(a,n)*Math.min(a,n)],[Math.min(a,n)+1]);return i=Bd(i,c.sign()),n<a&&(i=i.transpose()),Bd(Hd(this.gain),i.reshape(e))}))}getConfig(){return{gain:this.gain,seed:this.seed}}}ww.className="Orthogonal",Yd(ww);const kw={constant:"Constant",glorotNormal:"GlorotNormal",glorotUniform:"GlorotUniform",heNormal:"HeNormal",heUniform:"HeUniform",identity:"Identity",leCunNormal:"LeCunNormal",leCunUniform:"LeCunUniform",ones:"Ones",orthogonal:"Orthogonal",randomNormal:"RandomNormal",randomUniform:"RandomUniform",truncatedNormal:"TruncatedNormal",varianceScaling:"VarianceScaling",zeros:"Zeros"};function Iw(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return iv(e,Xd.getMap().classNameMap,t,"initializer")}function Sw(e){return ov(e)}function Nw(e){if("string"===typeof e){const t=e in kw?kw[e]:e;if("GlorotNormal"===t)return new gw;if("GlorotUniform"===t)return new mw;if("HeNormal"===t)return new bw;if("HeUniform"===t)return new yw;if("LeCunNormal"===t)return new xw;if("LeCunUniform"===t)return new vw;{const e={};return e.className=t,e.config={},Iw(e)}}return e instanceof sw?e:Iw(e)}function Cw(e){return Array.isArray(e)&&Array.isArray(e[0])}function Tw(e){return 0===e.length?[]:Array.isArray(e[0])?e:[e]}function Ew(e){let t;if(Array.isArray(e)){if(1!==e.length)throw new qx("Expected Tensor length to be 1; got ".concat(e.length));t=e[0]}else t=e;return t}function Rw(e){if(Array.isArray(e)&&Array.isArray(e[0])){if(1===e.length)return e[0];throw new qx("Expected exactly 1 Shape; got ".concat(e.length))}return e}function _w(e){let t=0;for(const n of e)0===n.shape.length?t+=1:t+=n.shape.reduce(((e,t)=>e*t));return t}const Aw="Variable";class Fw{constructor(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"float32",n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:Aw,a=!(arguments.length>3&&void 0!==arguments[3])||arguments[3],r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null;this.dtype=null==t?"float32":t,this.shape=e.shape,this.id=bv(),n=null==n?Aw:n,this.originalName=Fv(n),this.name=Ov(this.originalName),this.trainable_=a,this.constraint=r,this.val=function(e){let t=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],n=arguments.length>2?arguments[2]:void 0,a=arguments.length>3?arguments[3]:void 0;return Cu.makeVariable(e,t,n,a)}(e,this.trainable_,this.name,this.dtype)}read(){return this.assertNotDisposed(),this.val}write(e){return this.assertNotDisposed(),function(e,t){if(e.shape.toString()!==t.shape.toString())throw new Error("Shape mismatch: "+JSON.stringify(e.shape)+" vs. "+JSON.stringify(t.shape))}(this.val,e),this.val.id!==e.id&&(this.val.assign(e),null!=this.constraint&&this.val.assign(this.constraint.apply(this.val))),this}dispose(){this.assertNotDisposed(),this.val.dispose()}assertNotDisposed(){if(this.val.isDisposed)throw new Error("LayersVariable ".concat(this.name," is already disposed."))}get trainable(){return this.trainable_}set trainable(e){this.trainable_=e,this.val.trainable=e}}function Ow(e){return e.map((e=>e.read()))}function Dw(e){e.forEach((e=>{e[0].write(e[1])}))}class Mw{constructor(e){this.dtype=e.dtype,this.shape=e.shape,null!=e.shape?this.ndim=e.shape.length:this.ndim=e.ndim,this.maxNDim=e.maxNDim,this.minNDim=e.minNDim,this.axes=e.axes||{}}}class Lw{constructor(e,t,n,a,r,o,s){this.dtype=e,this.shape=t,this.sourceLayer=n,this.inputs=a,this.callArgs=r,this.outputTensorIndex=s,this.id=bv(),null!=o&&(this.originalName=Fv(o),this.name=Ov(this.originalName)),this.rank=t.length}}let Pw=0;class zw{constructor(e,t){this.callArgs=t,this.id=Pw++,this.outboundLayer=e.outboundLayer,this.inboundLayers=e.inboundLayers,this.nodeIndices=e.nodeIndices,this.tensorIndices=e.tensorIndices,this.inputTensors=e.inputTensors,this.outputTensors=e.outputTensors,this.inputMasks=e.inputMasks,this.outputMasks=e.outputMasks,this.inputShapes=e.inputShapes,this.outputShapes=e.outputShapes;for(const n of e.inboundLayers)null!=n&&n.outboundNodes.push(this);e.outboundLayer.inboundNodes.push(this)}getConfig(){const e=[];for(const t of this.inboundLayers)null!=t?e.push(t.name):e.push(null);return{outboundLayer:this.outboundLayer?this.outboundLayer.name:null,inboundLayers:e,nodeIndices:this.nodeIndices,tensorIndices:this.tensorIndices}}}let Bw=0;class Ww extends qd{constructor(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};super(),this._callHook=null,this._addedWeightNames=[],this._stateful=!1,this.id=Bw++,this.activityRegularizer=null,this.inputSpec=null,this.supportsMasking=!1,this._trainableWeights=[],this._nonTrainableWeights=[],this._losses=[],this._updates=[],this._built=!1,this.inboundNodes=[],this.outboundNodes=[];let t=e.name;if(!t){const e=this.getClassName();t=nv(e)+"_"+xv(e)}if(this.name=t,this.trainable_=null==e.trainable||e.trainable,null!=e.inputShape||null!=e.batchInputShape){let t;if(null!=e.batchInputShape)t=e.batchInputShape;else if(null!=e.inputShape){let n=null;null!=e.batchSize&&(n=e.batchSize),t=[n].concat(e.inputShape)}this.batchInputShape=t;let n=e.dtype;null==n&&(n=e.inputDType),null==n&&(n="float32"),this.dtype=n}null!=e.weights?this.initialWeights=e.weights:this.initialWeights=null,this._refCount=null,this.fastWeightInitDuringBuild=!1}static nodeKey(e,t){return e.name+"_ib-"+t.toString()}getNodeAtIndex(e,t){if(0===this.inboundNodes.length)throw new Kx("The layer has never been called "+"and thus has no defined ".concat(t,"."));if(this.inboundNodes.length<=e)throw new qx("Asked to get ".concat(t," at node ").concat(e,", ")+"but the layer has only ".concat(this.inboundNodes.length," inbound nodes."));return this.inboundNodes[e]}getInputAt(e){return ev(this.getNodeAtIndex(e,"input").inputTensors)}getOutputAt(e){return ev(this.getNodeAtIndex(e,"output").outputTensors)}get input(){if(this.inboundNodes.length>1)throw new jx("Layer ".concat(this.name)+' has multiple inbound nodes, hence the notion of "layer input" is ill-defined. Use `getInputAt(nodeIndex)` instead.');if(0===this.inboundNodes.length)throw new jx("Layer ".concat(this.name)+" is not connected, no input to return.");return ev(this.getNodeAtIndex(0,"input").inputTensors)}get output(){if(0===this.inboundNodes.length)throw new jx("Layer ".concat(this.name)+" has no inbound nodes.");if(this.inboundNodes.length>1)throw new jx("Layer ".concat(this.name)+' has multiple inbound nodes, hence the notion of "layer output" is ill-defined. Use `getOutputAt(nodeIndex)` instead.');return ev(this.getNodeAtIndex(0,"output").outputTensors)}get losses(){return this._losses}calculateLosses(){return this.losses.map((e=>e()))}get updates(){return this._updates}get built(){return this._built}set built(e){this._built=e}get trainable(){return this.trainable_}set trainable(e){this._trainableWeights.forEach((t=>t.trainable=e)),this.trainable_=e}get trainableWeights(){return this.trainable_?this._trainableWeights.filter((e=>e.trainable)):[]}set trainableWeights(e){this._trainableWeights=e}get nonTrainableWeights(){return this.trainable?this._trainableWeights.filter((e=>!e.trainable)).concat(this._nonTrainableWeights):this._trainableWeights.concat(this._nonTrainableWeights)}set nonTrainableWeights(e){this._nonTrainableWeights=e}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}get stateful(){return this._stateful}resetStates(){if(!this.stateful)throw new Error("Cannot call the resetStates() method of a non-stateful Layer object.")}assertInputCompatibility(e){const t=tv(e);if(null==this.inputSpec||0===this.inputSpec.length)return;const n=tv(this.inputSpec);if(t.length!==n.length)throw new qx("Layer ".concat(this.name," expects ").concat(n.length," inputs, ")+"but it received ".concat(t.length," input tensors. ")+"Input received: ".concat(e));for(let a=0;a<t.length;a++){const e=t[a],r=n[a];if(null==r)continue;const o=e.rank;if(null!=r.ndim&&o!==r.ndim)throw new qx("Input ".concat(a," is incompatible with layer ").concat(this.name,": ")+"expected ndim=".concat(r.ndim,", found ndim=").concat(o));if(null!=r.maxNDim&&o>r.maxNDim)throw new qx("Input ".concat(a," is incompatible with layer ").concat(this.name)+": expected max_ndim=".concat(r.maxNDim,", found ndim=").concat(o));if(null!=r.minNDim&&o<r.minNDim)throw new qx("Input ".concat(a," is incompatible with layer ").concat(this.name)+": expected min_ndim=".concat(r.minNDim,", found ndim=").concat(o,"."));if(null!=r.dtype&&e.dtype!==r.dtype)throw new qx("Input ".concat(a," is incompatible with layer ").concat(this.name," ")+": expected dtype=".concat(r.dtype,", found dtype=").concat(e.dtype,"."));if(r.axes){const t=e.shape;for(const e in r.axes){const n=Number(e),o=r.axes[e],s=n>=0?t[n]:t[t.length+n];if(null!=o&&-1===[o,null].indexOf(s))throw new qx("Input ".concat(a," is incompatible with layer ")+"".concat(this.name,": expected axis ").concat(n," of input shape to ")+"have value ".concat(o," but got shape ").concat(t,"."))}}if(null!=r.shape)for(let t=0;t<r.shape.length;++t){const n=r.shape[t],o=e.shape[t];if(null!=n&&null!=o&&n!==o)throw new qx("Input ".concat(a," is incompatible with layer ")+"".concat(this.name,": expected shape=").concat(r.shape,", ")+"found shape=".concat(e.shape,"."))}}}call(e,t){return e}invokeCallHook(e,t){null!=this._callHook&&this._callHook(e,t)}setCallHook(e){this._callHook=e}clearCallHook(){this._callHook=null}apply(e,t){t=t||{},this.assertNotDisposed();const n=tv(e),a=function(e){let t=!0;for(const n of tv(e))if(!(n instanceof Lw)){t=!1;break}return t}(e),r=function(e){let t=!0;for(const n of tv(e))if(n instanceof Lw){t=!1;break}return t}(e);if(a===r)throw new qx("Arguments to apply() must be all SymbolicTensors or all Tensors");return Av(this.name,(()=>{if(!this.built){this.assertInputCompatibility(e);const t=[];for(const n of tv(e))t.push(n.shape);this.build(ev(t)),this.built=!0,this.initialWeights&&this.setWeights(this.initialWeights),null===this._refCount&&r&&(this._refCount=1)}if(this.assertInputCompatibility(e),r){let a=this.call(e,t);this.supportsMasking&&this.setMaskMetadata(e,a);const r=tv(a),o=[];for(let e of r)-1!==n.indexOf(e)&&(e=e.clone()),o.push(e);if(a=ev(o),null!=this.activityRegularizer)throw new Xx("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return a}{const n=function(e){e=tv(e);const t=[];for(const n of e)t.push(n.shape);return ev(t)}(e),a=this.computeOutputShape(n);let r;const o="float32";if(this.warnOnIncompatibleInputShape(Array.isArray(e)?n[0]:n),r=null!=a&&a.length>0&&Array.isArray(a[0])?a.map(((n,a)=>new Lw(o,n,this,tv(e),t,this.name,a))):new Lw(o,a,this,tv(e),t,this.name),this.addInboundNode(e,r,null,null,n,a,t),this._refCount++,null!=this.activityRegularizer)throw new Xx("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return r}}))}warnOnIncompatibleInputShape(e){if(null!=this.batchInputShape)if(e.length!==this.batchInputShape.length)console.warn("The rank of the input tensor provided (shape: "+"".concat(JSON.stringify(e),") does not match that of the ")+"batchInputShape (".concat(JSON.stringify(this.batchInputShape),") ")+"of the layer ".concat(this.name));else{let t=!1;this.batchInputShape.forEach(((n,a)=>{null!=n&&null!=e[a]&&e[a]!==n&&(t=!0)})),t&&console.warn("The shape of the input tensor "+"(".concat(JSON.stringify(e),") does not ")+"match the expectation of layer ".concat(this.name,": ")+"".concat(JSON.stringify(this.batchInputShape)))}}get outputShape(){if(null==this.inboundNodes||0===this.inboundNodes.length)throw new jx("The layer ".concat(this.name," has never been called and thus has no ")+"defined output shape.");const e=[];for(const t of this.inboundNodes){const n=JSON.stringify(t.outputShapes);-1===e.indexOf(n)&&e.push(n)}if(1===e.length){const e=this.inboundNodes[0].outputShapes;return Array.isArray(e)&&Array.isArray(e[0])&&1===e.length?e[0]:e}throw new jx("The layer ".concat(this.name," has multiple inbound nodes with different ")+'output shapes. Hence the notion of "output shape" is ill-defined for the layer.')}countParams(){if(!this.built)throw new Kx("You tried to call countParams() on ".concat(this.name,", ")+"but the layer is not built yet. Build it first by calling build(batchInputShape).");return _w(this.weights)}build(e){this.built=!0}getWeights(){return Ow(arguments.length>0&&void 0!==arguments[0]&&arguments[0]?this.trainableWeights:this.weights)}setWeights(e){Hu((()=>{const t=this.weights;if(t.length!==e.length)throw new qx('You called setWeights(weights) on layer "'.concat(this.name,'" ')+"with a weight list of length ".concat(e.length,", ")+"but the layer was expecting ".concat(t.length," weights. ")+"Provided weights: ".concat(e,"..."));if(0===t.length)return;const n=[],a=Ow(t);for(let r=0;r<a.length;++r){const o=a[r],s=t[r],i=e[r];if(!xo(o.shape,i.shape))throw new qx("Layer weight shape ".concat(o.shape," ")+"not compatible with provided weight shape ".concat(i.shape));n.push([s,i])}Dw(n)}))}addWeight(e,t,n,a,r,o,s,i){if(-1!==this._addedWeightNames.indexOf(e))throw new qx("Duplicate weight name ".concat(e," for layer ").concat(this.name));this._addedWeightNames.push(e),null==n&&(n="float32"),this.fastWeightInitDuringBuild&&(a=null!=i?i():Nw("zeros"));const c=a.apply(t,n),l=new Fw(c,n,e,o,s);return c.dispose(),null!=r&&this.addLoss((()=>r.apply(l.read()))),null==o&&(o=!0),o?this._trainableWeights.push(l):this._nonTrainableWeights.push(l),l}setFastWeightInitDuringBuild(e){this.fastWeightInitDuringBuild=e}addLoss(e){null==e||Array.isArray(e)&&0===e.length||(e=tv(e),void 0!==this._losses&&null!==this._losses&&this.losses.push(...e))}computeOutputShape(e){return e}computeMask(e,t){if(!this.supportsMasking){if(null!=t){if(!Array.isArray(t))throw new TypeError("Layer ".concat(this.name," does not support masking, ")+"but was passed an inputMask.");t.forEach((e=>{if(null!=e)throw new TypeError("Layer ".concat(this.name," does not support masking, ")+"but was passed an inputMask.")}))}return null}return t}setMaskMetadata(e,t,n){if(!this.supportsMasking)return;const a=this.computeMask(e,n),r=tv(t),o=tv(a);if(r.length!==o.length)throw new Error("".concat(this.name," outputs ").concat(r.length," tensors ")+"but ".concat(r.length," masks for those tensors"));for(let s=0;s<r.length;s++)r[s].kerasMask=o[s]}addInboundNode(e,t,n,a,r,o){let s=arguments.length>6&&void 0!==arguments[6]?arguments[6]:null;const i=tv(e);t=tv(t),n=tv(n),a=tv(a),r=Tw(r),o=Tw(o);const c=[],l=[],u=[];for(const d of i)c.push(d.sourceLayer),l.push(d.nodeIndex),u.push(d.tensorIndex);new zw({outboundLayer:this,inboundLayers:c,nodeIndices:l,tensorIndices:u,inputTensors:i,outputTensors:t,inputMasks:n,outputMasks:a,inputShapes:r,outputShapes:o},s);for(let d=0;d<t.length;d++)t[d].sourceLayer=this,t[d].nodeIndex=this.inboundNodes.length-1,t[d].tensorIndex=d}getConfig(){const e={name:this.name,trainable:this.trainable};return null!=this.batchInputShape&&(e.batchInputShape=this.batchInputShape),null!=this.dtype&&(e.dtype=this.dtype),e}disposeWeights(){return this.weights.forEach((e=>e.dispose())),this.weights.length}assertNotDisposed(){if(0===this._refCount)throw new Error("Layer '".concat(this.name,"' is already disposed."))}dispose(){if(!this.built)throw new Error("Cannot dispose Layer ".concat(this.name," because it has not been ")+"built yet.");if(null===this._refCount)throw new Error("Cannot dispose Layer ".concat(this.name," because it has not been used ")+"yet.");this.assertNotDisposed();let e=0;return 0===--this._refCount&&(e=this.disposeWeights()),{refCountAfterDispose:this._refCount,numDisposedVariables:e}}}function Vw(e,t,n){if((null==t||null!=n&&n>0)&&(t=e.sourceLayer,n=e.nodeIndex),0===t.inboundNodes.length)return[e];{const e=t.inboundNodes[n];if(0===e.inboundLayers.length)return e.inputTensors;{const t=[];for(let n=0;n<e.inboundLayers.length;n++){const a=Vw(e.inputTensors[n],e.inboundLayers[n],e.nodeIndices[n]);for(const e of a)-1===t.indexOf(e)&&t.push(e)}return t}}}class Uw extends Ww{constructor(e){if(super({dtype:e.dtype,name:null!=e.name?e.name:xv("input").toString()}),null==e.batchSize&&(e.batchSize=null),null==e.sparse&&(e.sparse=!1),this.trainable=!1,this.built=!0,this.sparse=e.sparse,null!=e.inputShape&&null!=e.batchInputShape)throw new qx("Only provide the inputShape OR batchInputShape argument to inputLayer, not both at the same time.");let t=e.batchInputShape;if(null==t){if(null==e.inputShape)throw new qx("An InputLayer should be passed either a `batchInputShape` or an `inputShape`.");t=[e.batchSize].concat(e.inputShape)}else if(null!=e.batchSize)throw new qx("Cannot specify batchSize if batchInputShape is specified when creating an InputLayer.");const n=e.dtype||"float32";this.batchInputShape=t,this.dtype=n,this.inputSpec=[{shape:t}];const a=new Lw(this.dtype,this.batchInputShape,this,[],{},this.name);a.nodeIndex=0,a.tensorIndex=0,new zw({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:[a],outputTensors:[a],inputMasks:[null],outputMasks:[null],inputShapes:[t],outputShapes:[t]})}apply(e,t){throw new qx("Cannot pass any input to an "+"InputLayer's apply() method. InputLayer name: ".concat(this.name))}dispose(){return{refCountAfterDispose:this._refCount,numDisposedVariables:0}}getConfig(){return{batchInputShape:this.batchInputShape,dtype:this.dtype,sparse:this.sparse,name:this.name}}}Uw.className="InputLayer",Yd(Uw);class Gw{constructor(e){if(this.id2Value={},this.id2Mask={},this.name2Id={},e instanceof Gw)for(const t in e.id2Value)this.id2Value[t]=e.id2Value[t],t in e.id2Mask&&(this.id2Mask[t]=e.id2Mask[t]);else{if(null==e)return;for(const t of e)this.add(t.key,t.value)}}add(e,t,n){if(null!=this.id2Value[e.id])throw new qx("Duplicate key: name=".concat(e.name,", id=").concat(e.id));return this.id2Value[e.id]=function(e,t){if(null==e.dtype||e.dtype===t.dtype)return t;try{return Dd(t,e.dtype)}catch(ade){throw new qx("The dtype of the feed (".concat(t.dtype,") can not be cast to the dtype ")+"of the key '".concat(e.name,"' (").concat(e.dtype,")."))}}(e,t),this.name2Id[e.name]=e.id,null!=n&&(this.id2Mask[e.id]=n),this}addFeed(e){this.add(e.key,e.value)}hasKey(e){return null!=this.id2Value[e.id]}names(){return Object.keys(this.name2Id)}getValue(e){if(e instanceof Lw){if(null==this.id2Value[e.id])throw new qx("Nonexistent key: ".concat(e.name));return this.id2Value[e.id]}{const t=this.name2Id[e];if(null==t)throw new qx("Feed dict has no SymbolicTensor name: ".concat(e));return this.id2Value[t]}}getMask(e){if(e instanceof Lw){if(null==this.id2Value[e.id])throw new qx("Nonexistent key: ".concat(e.name));return this.id2Mask[e.id]}{const t=this.name2Id[e];if(null==t)throw new qx("Feed dict has no SymbolicTensor name: ".concat(e));return this.id2Mask[t]}}disposeMasks(){null!=this.id2Mask&&ju(this.id2Mask)}}const Hw=new Qx,jw=new Qx;function Kw(e,t,n,a){const r=null!=n&&n.training,o=Array.isArray(e),s=o?e:[e],i=s.map((e=>e.name)),c=[],l=t.names();for(const f of i)-1!==l.indexOf(f)?c.push(t.getValue(f)):c.push(null);null!=a&&(a.maxNumTensors=-1/0,a.minNumTensors=1/0);const u=i.join(",")+"|"+t.names().sort().join(",");let d,h=Hw.get(u);if(null==h){const e=function(e,t){mo(null!=e&&e.length>0,(()=>"Expected at least one fetch, got none"));let n=[],a={};if(1===e.length){const r=Xw(e[0],t);n=r.sorted,a=r.recipientMap}else{const r=new Set;for(const o of e){const{sorted:e,recipientMap:s}=Xw(o,t);for(const t of e)r.has(t.name)||(n.push(t),r.add(t.name));for(const t in s)null==a[t]&&(a[t]=new Set),s[t].forEach((e=>a[t].add(e)))}}return{sorted:n,recipientCounts:qw(a)}}(s,t);h=e.sorted,d=e.recipientCounts,Hw.put(u,h),jw.put(u,d)}d={},r||Object.assign(d,jw.get(u));const p=new Gw(t);for(let f=0;f<h.length;++f){if(null!=a){const e=Gu().numTensors;e>a.maxNumTensors&&(a.maxNumTensors=e),e<a.minNumTensors&&(a.minNumTensors=e)}const e=h[f],o=e.sourceLayer;if(o instanceof Uw)continue;const s=[],l=[],u=[];let m=!1;for(const n of e.inputs){const e=p.getValue(n),a=p.getMask(n);s.push(e),l.push(a),null!=a&&(m=!0),r||(d[n.name]--,0!==d[n.name]||t.hasKey(n)||-1!==i.indexOf(n.name)||e.isDisposed||!0===n.sourceLayer.stateful||u.push(e))}m&&((n=n||{}).mask=l[0]);const g=tv(o.apply(s,n));let b=null;o.supportsMasking&&(b=o.computeMask(s,l));const y=Yw(e),x=Array.isArray(y)?y:[y];for(let t=0;t<x.length;++t){p.hasKey(x[t])||p.add(x[t],g[t],Array.isArray(b)?b[0]:b);const e=i.indexOf(x[t].name);-1!==e&&(c[e]=g[t])}r||ju(u)}return p.disposeMasks(),o?c:c[0]}function qw(e){const t={};for(const n in e)t[n]=e[n].size;return t}function Xw(e,t){const n=new Set,a=[],r={};for(const i of t.names())n.add(i);const o=[],s=[];for(o.push(e);o.length>0;){const e=o[o.length-1];if(n.has(e.name)){o.pop();continue}const t=s[s.length-1]===o.length-1;if(0===e.inputs.length||t)o.pop(),a.push(e),n.add(e.name),t&&s.pop();else{s.push(o.length-1);for(const t of e.inputs)null==r[t.name]&&(r[t.name]=new Set),r[t.name].add(e.name),n.has(t.name)||o.push(t)}}return{sorted:a,recipientMap:r}}function Yw(e){let t;if(1===e.sourceLayer.inboundNodes.length)t=e.sourceLayer.output;else{let n=null;for(let t=0;t<e.sourceLayer.inboundNodes.length;++t)for(const a of e.sourceLayer.inboundNodes[t].outputTensors)if(a.id===e.id){n=t;break}t=e.sourceLayer.getOutputAt(n)}return t}function Qw(e,t){return Hu((()=>Wd(Vp(Bd(e,e),t,!0))))}Yo().registerFlag("TOPOLOGICAL_SORT_CACHE_MAX_ENTRIES",(()=>100),(function(e){null!=Hw&&Hw.setMaxEntries(e),null!=jw&&jw.setMaxEntries(e)}));class Jw extends qd{getConfig(){return{}}}class Zw extends Jw{constructor(e){super(),this.defaultMaxValue=2,this.defaultAxis=0,this.maxValue=null!=e.maxValue?e.maxValue:this.defaultMaxValue,this.axis=null!=e.axis?e.axis:this.defaultAxis}apply(e){return Hu((()=>{const t=Qw(e,this.axis),n=hp(t,0,this.maxValue);return Bd(e,zd(n,Ld(Vv(),t)))}))}getConfig(){return{maxValue:this.maxValue,axis:this.axis}}}Zw.className="MaxNorm",Yd(Zw);class $w extends Jw{constructor(e){super(),this.defaultAxis=0,this.axis=null!=e.axis?e.axis:this.defaultAxis}apply(e){return Hu((()=>zd(e,Ld(Vv(),Qw(e,this.axis)))))}getConfig(){return{axis:this.axis}}}$w.className="UnitNorm",Yd($w);class ek extends Jw{apply(e){return wf(e)}}ek.className="NonNeg",Yd(ek);class tk extends Jw{constructor(e){super(),this.defaultMinValue=0,this.defaultMaxValue=1,this.defaultRate=1,this.defaultAxis=0,this.minValue=null!=e.minValue?e.minValue:this.defaultMinValue,this.maxValue=null!=e.maxValue?e.maxValue:this.defaultMaxValue,this.rate=null!=e.rate?e.rate:this.defaultRate,this.axis=null!=e.axis?e.axis:this.defaultAxis}apply(e){return Hu((()=>{const t=Qw(e,this.axis),n=Ld(Bd(this.rate,hp(t,this.minValue,this.maxValue)),Bd(1-this.rate,t));return Bd(e,zd(n,Ld(Vv(),t)))}))}getConfig(){return{minValue:this.minValue,maxValue:this.maxValue,rate:this.rate,axis:this.axis}}}tk.className="MinMaxNorm",Yd(tk);const nk={maxNorm:"MaxNorm",minMaxNorm:"MinMaxNorm",nonNeg:"NonNeg",unitNorm:"UnitNorm"};function ak(e){return ov(e)}function rk(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return iv(e,Xd.getMap().classNameMap,t,"constraint")}function ok(e){if(null==e)return null;if("string"===typeof e){return rk({className:e in nk?nk[e]:e,config:{}})}return e instanceof Jw?e:rk(e)}async function sk(e){if(null==e)return;const t=[],n=[],a=[];for(const r in e){const o=e[r];if("number"!==typeof o){const e=o;t.push(e.data()),n.push(r),a.push(e)}}if(t.length>0){const r=await Promise.all(t);for(let t=0;t<r.length;++t)e[n[t]]=r[t][0];ju(a)}}function ik(e){if(null!=e)for(const t in e){const n=e[t];"number"!==typeof n&&n.dispose()}}var ck;!function(e){e[e.SILENT=0]="SILENT",e[e.VERBOSE=1]="VERBOSE"}(ck||(ck={}));class lk{constructor(){this.validationData=null}setParams(e){this.params=e}async onEpochBegin(e,t){}async onEpochEnd(e,t){}async onBatchBegin(e,t){}async onBatchEnd(e,t){}async onTrainBegin(e){}async onTrainEnd(e){}setModel(e){}}class uk{constructor(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:10;null==e&&(e=[]),this.callbacks=e,this.queueLength=t}append(e){this.callbacks.push(e)}setParams(e){for(const t of this.callbacks)t.setParams(e)}setModel(e){for(const t of this.callbacks)t.setModel(e)}async onEpochBegin(e,t){null==t&&(t={});for(const n of this.callbacks)await n.onEpochBegin(e,t)}async onEpochEnd(e,t){null==t&&(t={});for(const n of this.callbacks)await n.onEpochEnd(e,t)}async onBatchBegin(e,t){null==t&&(t={});for(const n of this.callbacks)await n.onBatchBegin(e,t)}async onBatchEnd(e,t){null==t&&(t={});for(const n of this.callbacks)await n.onBatchEnd(e,t)}async onTrainBegin(e){null==e&&(e={});for(const t of this.callbacks)await t.onTrainBegin(e)}async onTrainEnd(e){null==e&&(e={});for(const t of this.callbacks)await t.onTrainEnd(e)}}class dk extends lk{constructor(){super()}async onEpochBegin(e){this.seen=0,this.totals={}}async onBatchEnd(e,t){null==t&&(t={});const n=null==t.size?0:t.size;this.seen+=n;for(const a in t){const e=t[a];if("number"===typeof e)this.totals.hasOwnProperty(a)||(this.totals[a]=0),this.totals[a]=this.totals[a]+e*n;else{let t;a in this.totals?t=this.totals[a]:this.totals[a]=0;const r=Hu((()=>Ld(this.totals[a],Bd(e,n))));this.totals[a]=r,null!=t&&t.dispose()}}}async onEpochEnd(e,t){if(null!=t)for(const n of this.params.metrics)null!=this.totals[n]&&("number"===typeof this.totals[n]?t[n]=this.totals[n]/this.seen:Hu((()=>{const e=Bd(zd(1,this.seen),this.totals[n]);t[n]=e,this.totals[n].dispose(),Ku(t[n])})))}}class hk extends lk{async onTrainBegin(e){this.epoch=[],this.history={}}async onEpochEnd(e,t){null==t&&(t={}),this.epoch.push(e);for(const n in t)null==this.history[n]&&(this.history[n]=[]),this.history[n].push(t[n])}async syncData(){const e=[],t=[],n=[];for(const r in this.history){const a=this.history[r];for(let o=0;o<a.length;++o)if("number"!==typeof a[o]){const s=a[o];e.push(s.data()),t.push(r),n.push(o)}}const a=await Promise.all(e);for(let r=0;r<a.length;++r){this.history[t[r]][n[r]].dispose(),this.history[t[r]][n[r]]=a[r][0]}}}class pk extends lk{constructor(e,t){if(super(),this.currentEpoch=0,this.nowFunc=e.nowFunc,this.nextFrameFunc=e.nextFrameFunc||Ym,this.yieldEvery=t||"auto","auto"===this.yieldEvery&&(this.yieldEvery=125),"never"===this.yieldEvery&&null!=e.onYield)throw new Error("yieldEvery is `never` but you provided an `onYield` callback. Either change `yieldEvery` or remove the callback");Fo(this.yieldEvery)&&(this.maybeWait=function(e,t,n){let a,r=null!=n?n():Bl();return function(){const o=null!=n?n():Bl();return o-r<t||(r=o,a=e(...arguments)),a}}(this.maybeWait.bind(this),this.yieldEvery,this.nowFunc)),this.trainBegin=e.onTrainBegin,this.trainEnd=e.onTrainEnd,this.epochBegin=e.onEpochBegin,this.epochEnd=e.onEpochEnd,this.batchBegin=e.onBatchBegin,this.batchEnd=e.onBatchEnd,this.yield=e.onYield}async maybeWait(e,t,n){const a=[];null!=this.yield&&(await sk(n),a.push(this.yield(e,t,n))),a.push(this.nextFrameFunc()),await Promise.all(a)}async onEpochBegin(e,t){this.currentEpoch=e,null!=this.epochBegin&&(await sk(t),await this.epochBegin(e,t))}async onEpochEnd(e,t){const n=[];null!=this.epochEnd&&(await sk(t),n.push(this.epochEnd(e,t))),"epoch"===this.yieldEvery&&n.push(this.nextFrameFunc()),await Promise.all(n)}async onBatchBegin(e,t){null!=this.batchBegin&&(await sk(t),await this.batchBegin(e,t))}async onBatchEnd(e,t){const n=[];null!=this.batchEnd&&(await sk(t),n.push(this.batchEnd(e,t))),"batch"===this.yieldEvery?n.push(this.nextFrameFunc()):Fo(this.yieldEvery)&&n.push(this.maybeWait(this.currentEpoch,e,t)),await Promise.all(n)}async onTrainBegin(e){null!=this.trainBegin&&(await sk(e),await this.trainBegin(e))}async onTrainEnd(e){null!=this.trainEnd&&(await sk(e),await this.trainEnd(e))}}function fk(e,t){if(null==e&&(e={}),e instanceof lk)return[e];if(Array.isArray(e)&&e[0]instanceof lk)return e;return tv(e).map((e=>new pk(e,t)))}class mk{constructor(){}static registerCallbackConstructor(e,t){mo(e>=0&&Number.isInteger(e),(()=>"Verbosity level is expected to be an integer >= 0, "+"but got ".concat(e))),mk.checkForDuplicate(t),null==mk.constructors[e]&&(mk.constructors[e]=[]),mk.constructors[e].push(t)}static checkForDuplicate(e){for(const t in mk.constructors){mk.constructors[+t].forEach((t=>{if(t===e)throw new qx("Duplicate callback constructor.")}))}}static clear(){mk.constructors={}}static createCallbacks(e){const t=[];for(const n in mk.constructors){const a=+n;e>=a&&t.push(...mk.constructors[a])}return t.map((e=>new e))}}function gk(e,t,n,a,r,o,s,i,c){const l=new hk,u=[new dk,...mk.createCallbacks(t)];null!=e&&u.push(...e),u.push(l);const d=new uk(u);return d.setParams({epochs:n,initialEpoch:a,samples:r,steps:o,batchSize:s,verbose:t,doValidation:i,metrics:c}),{callbackList:d,history:l}}function bk(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];return iv(e,Xd.getMap().classNameMap,t,"layer",n)}function yk(e,t){return Hu((()=>{"float32"!==e.dtype&&(e=Dd(e,"float32"));const n=Vp($v(e),t,!0),a=Zd(n.shape,Vv()),r=Wd(ih(n,a));return zd(e,r)}))}function xk(e,t){return Hu((()=>nf($v(th(t,e)),-1)))}function vk(e,t){return Hu((()=>nf(ah(th(t,e)),-1)))}function wk(e,t){return Hu((()=>{const n=th(e,t),a=hp(ah(e),Vv(),Number.MAX_VALUE),r=ah(zd(n,a));return Bd(100,nf(r,-1))}))}function kk(e,t){return Hu((()=>{const n=hp(t,Vv(),Number.MAX_VALUE),a=zp(Ld(1,n)),r=hp(e,Vv(),Number.MAX_VALUE),o=zp(Ld(1,r));return nf($v(th(a,o)),-1)}))}function Ik(e,t){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];return Hu((()=>{if(n)t=Af(t);else{const e=Vp(t,t.shape.length-1,!0);t=zd(t,e)}return t=hp(t,Vv(),1-Vv()),sf(Vp(Bd(Dd(e,"float32"),zp(t)),t.shape.length-1))}))}function Sk(e,t){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];return Hu((()=>{const a=Dd(Op(function(e){const t=[Lv(e.shape)];return rp(e,t)}(e)),"int32"),r=(t=hp(t,Vv(),1-Vv())).shape;return Ik(rp(lf(a,r[r.length-1]),r),t,n)}))}function Nk(e,t){return Hu((()=>{let n;return n=hp(t,Vv(),1-Vv()),n=zp(zd(n,th(1,n))),nf(function(e,t){if(!xo(e.shape,t.shape))throw new qx("logits and labels must have the same shape, but got shapes "+"".concat(JSON.stringify(e.shape)," and ").concat(JSON.stringify(t.shape)));return Hu((()=>{const n=wf(t),a=sf(ah(t));return Ld(th(n,Bd(t,e)),Bp(Rp(a)))}))}(e,n),-1)}))}function Ck(e,t){return Hu((()=>{const n=hp(e,Vv(),1),a=hp(t,Vv(),1);return Vp(Bd(e,zp(zd(n,a))),-1)}))}function Tk(e,t){return Hu((()=>{const n=yk(e,-1),a=yk(t,-1),r=Bd(n,a);return sf(Vp(r,-1))}))}mk.constructors={};const Ek={meanSquaredError:xk,meanAbsoluteError:vk,meanAbsolutePercentageError:wk,meanSquaredLogarithmicError:kk,squaredHinge:function(e,t){return Hu((()=>{const n=ih(0,th(1,Bd(e,t)));return nf($v(n),-1)}))},hinge:function(e,t){return Hu((()=>{const n=ih(0,th(1,Bd(e,t)));return nf(n,-1)}))},categoricalHinge:function(e,t){return Hu((()=>{const n=Vp(Bd(e,t),-1),a=Wp(Bd(th(1,e),t),-1);return ih(0,Ld(1,th(a,n)))}))},logcosh:function(e,t){return Hu((()=>{const n=Math.log(2),a=th(t,e),r=th(Ld(a,Ff(Bd(-2,a))),n);return nf(r,-1)}))},categoricalCrossentropy:Ik,sparseCategoricalCrossentropy:Sk,binaryCrossentropy:Nk,kullbackLeiblerDivergence:Ck,poisson:function(e,t){return Hu((()=>{const n=zp(Ld(Vv(),t));return nf(th(t,Bd(e,n)),-1)}))},cosineProximity:Tk};function Rk(e){if("string"===typeof e){if(e in Ek)return Ek[e];let t="Unknown loss ".concat(e);throw e.toLowerCase().includes("softmaxcrossentropy")&&(t="Unknown loss ".concat(e,". ")+'Use "categoricalCrossentropy" as the string name for tf.losses.softmaxCrossEntropy'),new qx(t)}return e}function _k(e,t){return Hu((()=>{const n=Bd(.5,hf(t)),a=Uv(Mp(t,n),e.dtype);return nf(Ep(e,a),-1)}))}function Ak(e,t){return Hu((()=>Uv(Ep(Uh(e,-1),Uh(t,-1)),"float32")))}function Fk(e,t){return Hu((()=>Dd(Vp(Zp(Ep(e,1),Ep(t,1))),"float32")))}function Ok(e,t){return Nk(e,t)}function Dk(e,t){return e.rank===t.rank&&(e=Df(e,[e.rank-1])),(t=Uh(t,-1)).dtype!==e.dtype&&(t=Dd(t,e.dtype)),Dd(Ep(e,t),"float32")}const Mk=Ik,Lk=Sk,Pk={binaryAccuracy:_k,categoricalAccuracy:Ak,precision:function(e,t){return Hu((()=>{const n=Fk(e,t),a=function(e,t){return Hu((()=>Dd(Vp(Zp(Ep(e,0),Ep(t,1))),"float32")))}(e,t),r=Ld(n,a);return Dd(Vf(Mp(r,0),zd(n,r),0),"float32")}))},categoricalCrossentropy:Mk,sparseCategoricalCrossentropy:Lk,mse:xk,MSE:xk,mae:vk,MAE:vk,mape:wk,MAPE:wk,cosine:Tk};function zk(e){if("string"===typeof e&&e in Pk)return Pk[e];if("string"!==typeof e&&null!=e)return e;throw new qx("Unknown metric ".concat(e))}function Bk(e){if(Zx(null!==e,"Unknown LossOrMetricFn ".concat(e)),"string"===typeof e)return e;{let t;for(const n of Object.keys(Ek))if(Ek[n]===e){t=n;break}if(void 0!==t)return t;for(const n of Object.keys(Pk))if(Pk[n]===e){t=n;break}return void 0!==t?t:e.name}}const Wk=1048576;function Vk(e,t){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];if(null==e||"object"!==typeof e||Object.getPrototypeOf(e)!==Object.prototype||!Uk(e))throw new Error("User-defined metadata is expected to be a JSON object, but is not.");if(n){const n=JSON.stringify(e);n.length>Wk&&console.warn('User-defined metadata of model "'.concat(t,'" is too large in ')+"size (length=".concat(n.length," when serialized). It is not ")+"recommended to store such large objects in user-defined metadata. Please make sure its serialized length is <= "+"".concat(Wk,"."))}}function Uk(e){if(null===e)return!0;if("object"===typeof e){if(Object.getPrototypeOf(e)===Object.prototype){const t=Object.keys(e);for(const n of t){if("string"!==typeof n)return!1;if(!Uk(e[n]))return!1}return!0}if(Array.isArray(e)){for(const t of e)if(!Uk(t))return!1;return!0}return!1}{const t=typeof e;return"string"===t||"number"===t||"boolean"===t}}function Gk(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:console.log;const r=function(e){let t=!0;const n=[],a=[];for(const r in e.nodesByDepth)n.push(e.nodesByDepth[r]);for(const r of n){if(r.length>1||1===r.length&&r[0].inboundLayers.length>1){t=!1;break}a.push(...r)}if(t)for(const r of e.layers){let e=!1;for(const n of r.inboundNodes)if(-1!==a.indexOf(n)){if(e){t=!1;break}e=!0}if(!t)break}return t}(e),o=["Layer (type)","Input Shape","Output shape","Param #"];let s;if(r?(t=t||90,n=n||[.32,.61,.89,1]):(t=t||115,n=n||[.24,.48,.7,.8,1]),n[n.length-1]<=1&&(n=n.map((e=>Math.floor(t*e)))),!r){o.push("Receives inputs"),s=[];for(const t in e.nodesByDepth)s.push(...e.nodesByDepth[t])}a("_".repeat(t)),Hk(o,n,a),a("=".repeat(t));const i=e.layers;for(let u=0;u<i.length;++u)r?jk(i[u],n,a):Kk(i[u],n,s,a),a((u===i.length-1?"=":"_").repeat(t));e.checkTrainableWeightsConsistency();const c=function(e){let t;t=null!=e.collectedTrainableWeights?_w(e.collectedTrainableWeights):_w(e.trainableWeights);return t}(e),l=_w(e.nonTrainableWeights);a("Total params: ".concat(c+l)),a("Trainable params: ".concat(c)),a("Non-trainable params: ".concat(l)),a("_".repeat(t))}function Hk(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:console.log,a="";for(let r=0;r<e.length;++r)r>0&&(a=a.slice(0,a.length-1)+" "),a+=e[r],a=a.slice(0,t[r]),a+=" ".repeat(t[r]-a.length);n(a)}function jk(e,t,n){let a,r;try{r=e.inboundNodes.map((e=>JSON.stringify(e.inputShapes))).join(",")}catch(ade){r="multiple"}try{a=JSON.stringify(e.outputShape)}catch(ade){a="multiple"}const o=e.name,s=e.getClassName();Hk(["".concat(o," (").concat(s,")"),r,a,e.countParams().toString()],t,n)}function Kk(e,t,n,a){let r,o;try{o=e.inboundNodes.map((e=>JSON.stringify(e.inputShapes))).join(",")}catch(ade){o="multiple"}try{r=JSON.stringify(e.outputShape)}catch(ade){r="multiple"}const s=[];for(const u of e.inboundNodes)if(!(null!=n&&n.length>0&&-1===n.indexOf(u)))for(let e=0;e<u.inboundLayers.length;++e){const t=u.inboundLayers[e].name,n=u.nodeIndices[e],a=u.tensorIndices[e];s.push("".concat(t,"[").concat(n,"][").concat(a,"]"))}const i=e.name,c=e.getClassName(),l=0===s.length?"":s[0];Hk(["".concat(i," (").concat(c,")"),o,r,e.countParams().toString(),l],t,a);for(let u=1;u<s.length;++u)Hk(["","","","",s[u]],t,a)}function qk(e,t,n){return("inboundNodes"===e||"outputLayers"===e||"inputLayers"===e)&&0===t&&"string"===typeof n}function Xk(e,t){if(null===e)return null;if("string"===typeof e)return av(e);if("number"===typeof e||"boolean"===typeof e)return e;if(e instanceof Array){const n=[],a=e.length;for(let r=0;r<a;++r){const a=e[r];qk(t,r,a)?n.push(a):n.push(Xk(a,t))}return n}{const t={};for(const n of Object.keys(e)){const a=e[n];if("name"===n&&"string"===typeof a)t[n]=a;else{const e=av(n);t[e]=Xk(a,e)}}return t}}function Yk(e,t){if(null===e||void 0===e)return null;if("string"===typeof e)return nv(e);if("number"===typeof e||"boolean"===typeof e)return e;if(e instanceof Array){const n=[],a=e.length;for(let r=0;r<a;++r){const a=e[r];qk(t,r,a)?n.push(a):n.push(Yk(a,t))}return n}{const t={};for(const n of Object.keys(e)){const a=e[n],r=nv(n);t[r]="name"!==n&&"className"!==n||"string"!==typeof a?Yk(a,n):a}return t}}const Qk="4.18.0";class Jk extends Ww{constructor(e){if(super({}),this.containerNodes=new Set,this.name=e.name,null==this.name){const e=this.getClassName().toLowerCase();this.name=xv(e)}if(this.supportsMasking=!1,this.trainable_=!0,Array.isArray(e.inputs)?this.inputs=e.inputs.slice():this.inputs=[e.inputs],Array.isArray(e.outputs)?this.outputs=e.outputs.slice():this.outputs=[e.outputs],lv(this.inputs).length!==this.inputs.length)throw new qx("The list of inputs passed to the model is redundant. All inputs should only appear once. Found: "+"".concat(this.inputs.map((e=>e.name))));lv(this.outputs).length!==this.outputs.length&&console.warn("The list of outputs passed to the model is redundant. All outputs should only appear once. Found: "+"".concat(this.outputs.map((e=>e.name)))),this.inputLayers=[],this.inputLayersNodeIndices=[],this.inputLayersTensorIndices=[],this.outputLayers=[],this.outputLayersNodeIndices=[],this.outputLayersTensorIndices=[],this.layers=[],this.internalContainerRefs=[];for(const b of this.outputs){const e=b.sourceLayer,t=b.nodeIndex,n=b.tensorIndex;this.outputLayers.push(e),this.outputLayersNodeIndices.push(t),this.outputLayersTensorIndices.push(n)}for(const b of this.inputs){const e=b.sourceLayer,t=b.nodeIndex,n=b.tensorIndex;Zx(0===t,"input layer has >1 nodes"),Zx(0===n,"input layer has >1 tensors"),this.inputLayers.push(e),this.inputLayersNodeIndices.push(t),this.inputLayersTensorIndices.push(n)}this.inputNames=[],this.outputNames=[],this.feedInputShapes=[],this.feedInputNames=[],this.feedOutputNames=[];for(let b=0;b<this.inputLayers.length;b++){const t=this.inputLayers[b];if(!(t instanceof Uw))throw new TypeError("Input layers to a LayersModel must be InputLayer objects. "+"Received inputs: ".concat(e.inputs,". ")+"Input ".concat(b," (0-based) originates ")+"from layer type ".concat(t.getClassName(),"."));this.inputNames.push(t.name),this.feedInputShapes.push(t.batchInputShape),this.feedInputNames.push(t.name)}for(const b of this.outputLayers)this.outputNames.push(b.name);this.internalInputShapes=this.inputs.map((e=>e.shape)),this.internalOutputShapes=this.outputs.map((e=>e.shape));const t={},n={},a={},r={},o={},s=[],i=(e,t,n,a,r,c)=>{null!=a&&null!=r&&null!=c||(a=e.sourceLayer,r=e.nodeIndex,c=e.tensorIndex);const l=a.inboundNodes[r];if(-1!==n.indexOf(l))throw new Kx("The tensor ".concat(e.name,' at layer "').concat(a.name,'" ')+"is part of a cycle.");if(-1!==t.indexOf(l))return;this.containerNodes.add(Jk.nodeKey(a,r)),a.id in o||(o[a.id]=Object.keys(o).length),-1===n.indexOf(l)&&n.push(l);const u=l.inboundLayers.length;for(let o=0;o<u;o++){const e=l.inputTensors[o],a=l.inboundLayers[o],r=l.nodeIndices[o],s=l.tensorIndices[o];i(e,t,n,a,r,s)}for(t.push(l);n.indexOf(l)>=0;)n.splice(n.indexOf(l),1);s.push(l)},c=[],l=[];for(const b of this.outputs)i(b,c,l);const u=s.slice().reverse();for(const b of u){n[b.id]=b,b.id in t||(t[b.id]=0);let e=t[b.id];const o=null==a[b.outboundLayer.id]?0:a[b.outboundLayer.id];e=Math.max(e,o),a[b.outboundLayer.id]=e,r[b.outboundLayer.id]=b.outboundLayer,t[b.id]=e;for(let a=0;a<b.inboundLayers.length;a++){const r=b.inboundLayers[a],o=b.nodeIndices[a],s=r.inboundNodes[o],i=null==t[s.id]?0:t[s.id];t[s.id]=Math.max(e+1,i),n[s.id]=s}}const d={};for(const b in t){const e=t[b];e in d||(d[e]=[]),d[e].push(n[b])}const h={};for(const b in a){const e=a[b];e in h||(h[e]=[]),h[e].push(r[b])}let p=Object.keys(h).map((e=>parseInt(e,10))).sort(cv);this.layers=[];for(const b of p){const e=h[b];e.sort(((e,t)=>{const n=o[e.id],a=o[t.id];return n<a?-1:n>a?1:0}));for(const t of e)t instanceof Jk&&this.internalContainerRefs.push(t),this.layers.push(t)}this.layersByDepth=h,p=Object.keys(d).map((e=>parseInt(e,10))).sort(cv);const f=this.inputs.slice(),m=[];for(const b of p)for(const e of d[b]){const t=e.outboundLayer;if(null!=t){for(const n of e.inputTensors)if(-1===f.indexOf(n))throw new Kx("Graph disconnected: cannot obtain value for tensor ".concat(n)+' at layer "'.concat(t.name,'". ')+"The following previous layers were accessed without "+"issue: ".concat(m));for(const t of e.outputTensors)f.push(t);m.push(t.name)}}this.nodesByDepth=d;const g=this.layers.map((e=>e.name));for(const b of g){const e=g.filter((e=>e===b)).length;if(1!==e)throw new Kx('The name "'.concat(b,'" is used ').concat(e," times ")+"in the model. All layer names should be unique. Layer names: "+JSON.stringify(g))}this.outboundNodes=[],this.inboundNodes=[],new zw({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:this.inputs.map((e=>null)),outputMasks:this.outputs.map((e=>null)),inputShapes:this.inputs.map((e=>e.shape)),outputShapes:this.outputs.map((e=>e.shape))}),this.built=!0,this._refCount=1}assertNotDisposed(){if(0===this._refCount)throw new Error("Container '".concat(this.name,"' is already disposed."))}dispose(){this.assertNotDisposed();const e={refCountAfterDispose:null,numDisposedVariables:0};if(0===--this._refCount){for(const t of this.layers)e.numDisposedVariables+=t.dispose().numDisposedVariables;for(const t of this.internalContainerRefs)e.numDisposedVariables+=t.dispose().numDisposedVariables}return e.refCountAfterDispose=this._refCount,e}get trainable(){return this.trainable_}set trainable(e){this.layers.forEach((t=>{t._trainableWeights.forEach((t=>t.trainable=e))})),this.trainable_=e}get trainableWeights(){if(this._trainableWeights.length>0)throw new qx("Container instance unexpectedly contains _trainableWeights.The trainable weights of a Container are a union of the trainable weights of its consituent Layers. Its own _trainableWeights must remain an empty Array.");if(!this.trainable)return[];let e=[];for(const t of this.layers)e=e.concat(t.trainableWeights);return e}get nonTrainableWeights(){const e=[];for(const t of this.layers)e.push(...t.nonTrainableWeights);if(!this.trainable){const t=[];for(const e of this.layers)t.push(...e.trainableWeights);return t.concat(e)}return e}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}loadWeights(e){let t=!(arguments.length>1&&void 0!==arguments[1])||arguments[1];const n={};let a=0;const r=(e=>{const t=Object.keys(e);if(0===t.length)return!1;const n=t[0].split("/");return!isNaN(parseInt(n[n.length-1],10))})(e);r&&this.parseWeights(e);for(const s of this.layers)for(const[e,t]of s.weights.entries()){const o=r?"".concat(t.name.split("/").slice(0,-1).join("/")+"/").concat(e):t.originalName;if(null!=n[o])throw new qx("Duplicate weight name: ".concat(o));n[o]=t,a++}const o=[];for(const s in e){let a=s;if(null==n[s]){const e=s.split("/");a=e.slice(0,-2).concat([e[e.length-1]]).join("/")}if(null!=n[a])o.push([n[a],e[s]]);else if(t)throw new qx("Provided weight data has no target variable: ".concat(s));delete n[a]}if(t){const e=[];for(const t in n)e.push(t);if(e.length>0)throw new qx("".concat(e.length," of ").concat(a," weights are not set: ")+"".concat(e))}Dw(o)}parseWeights(e){for(const t in Object.keys(e)){const n=t.split("/"),a=["vars","layer_checkpoint_dependencies"],r=n.map((e=>e.startsWith("_")?e.slice(1):e)).filter((e=>!a.includes(e))).join("/");r!==t&&(e[r]=e[t],delete e[t])}}updatedConfig(){const e=this.getConfig(),t={};return t.className=this.getClassName(),t.config=e,t.kerasVersion="tfjs-layers ".concat(Qk),t.backend="TensorFlow.js",t}toJSON(e){let t=!(arguments.length>1&&void 0!==arguments[1])||arguments[1];const n=Yk(this.updatedConfig());return t?JSON.stringify(n):n}call(e,t){return Hu((()=>{e=tv(e);const n=new Gw;for(let t=0;t<this.inputs.length;++t)n.add(this.inputs[t],e[t]);return Kw(this.outputs,n,t)}))}computeMask(e,t){return Hu((()=>{let n;return e=tv(e),n=null==t?Jx(null,e.length):tv(t),this.runInternalGraph(e,n)[1]}))}computeOutputShape(e){const t=Tw(e);if(t.length!==this.inputLayers.length)throw new qx("Invalid inputShape argument ".concat(e,": ")+"model has ".concat(this.inputLayers.length," tensor inputs."));const n={};for(let s=0;s<t.length;s++){const e=this.inputLayers[s],a=t[s];n[e.name+"_0_0"]=a}const a=Object.keys(this.nodesByDepth).map((e=>parseInt(e,10))).sort(cv);if(a.length>1)for(const s of a){const e=this.nodesByDepth[s];for(const t of e){const e=t.outboundLayer;if(-1!==this.inputLayers.map((e=>e.id)).indexOf(e.id))continue;const a=[];for(let s=0;s<t.inboundLayers.length;s++){const e=t.inboundLayers[s],r=t.nodeIndices[s],o=t.tensorIndices[s],i=n["".concat(e.name,"_").concat(r,"_").concat(o)];a.push(i)}const r=Tw(e.computeOutputShape(ev(a))),o=e.inboundNodes.indexOf(t);for(let t=0;t<r.length;t++){n["".concat(e.name,"_").concat(o,"_").concat(t)]=r[t]}}}const r=[],o=[];for(let s=0;s<this.outputLayers.length;s++){const e=this.outputLayers[s],t=this.outputLayersNodeIndices[s],n=this.outputLayersTensorIndices[s],a="".concat(e.name,"_").concat(t,"_").concat(n);o.push(a)}for(let s=0;s<o.length;s++){const e=o[s];Zx(e in n),r.push(n[e])}return ev(r)}runInternalGraph(e,t){null==t&&(t=Jx(null,e.length));const n={};for(let i=0;i<this.inputs.length;++i){const a=this.inputs[i],r=e[i],o=t[i];n[a.id]=[r,o]}const a=Object.keys(this.nodesByDepth).map((e=>parseInt(e,10))).sort(cv);for(const i of a){const e=this.nodesByDepth[i];for(const t of e){const e=t.outboundLayer,a=t.inputTensors,r=t.outputTensors,o=new Array;for(const t of a)t.id in n&&o.push(n[t.id]);if(o.length===a.length){let a,s,i,c,l={};if(null!=t.callArgs&&(l=t.callArgs),1===o.length){const[t,n]=o[0];null==l.mask&&(l.mask=n),i=tv(e.call(t,l)),c=tv(e.computeMask(t,n)),a=[t],s=[n]}else a=o.map((e=>e[0])),s=o.map((e=>e[1])),null==l.mask&&(l.mask=s),i=tv(e.call(a,l)),c=tv(e.computeMask(a,s));if(e.activityRegularizer)throw new Xx("LayersModel invocation with concrete Tensor value(s) in the presence of activity regularizer(s) is not supported yet.");for(let e=0;e<r.length;++e){const t=r[e],a=i[e],o=c[e];n[t.id]=[a,o]}}}}const r=[],o=[],s=[];for(const i of this.outputs){Zx(i.id in n,"Could not compute output ".concat(i.name," : ").concat(i.id));const[e,t]=n[i.id];s.push(e.shape),r.push(e),o.push(t)}return[r,o,s]}buildNodeConversionMap(e){const t={};let n;for(const a of this.layers){n=a instanceof Jk?1:0;for(let e=0;e<a.inboundNodes.length;e++){const r=Jk.nodeKey(a,e);this.containerNodes.has(r)&&(t[r]=n,n+=1)}}return t}getLayer(e,t){if(null!=t)return this.findLayer(t);if(null==e)throw new qx("Provide either a layer name or layer index");if("number"===typeof e)return this.findLayer(e);for(const n of this.layers)if(n.name===e)return n;throw new qx("No such layer: ".concat(e))}findLayer(e){if(this.layers.length<=e)throw new qx("Was asked to retrieve layer at index ".concat(e,", but model only ")+"has ".concat(this.layers.length," layer(s)."));return this.layers[e]}calculateLosses(){return Hu((()=>{const e=[];for(const t of this.layers)for(let n=0;n<t.inboundNodes.length;++n){const a=Jk.nodeKey(t,n);this.containerNodes.has(a)&&e.push(...t.calculateLosses())}return e}))}getConfig(){const e={name:this.name},t=this.buildNodeConversionMap(this.layers),n=[];for(const o of this.layers){const e=o.getClassName(),a=o.getConfig(),r=[];for(let n=0;n<o.inboundNodes.length;n++){const e=o.inboundNodes[n],a=Jk.nodeKey(o,n);let s={};if(this.containerNodes.has(a)){if(e.callArgs)try{JSON.stringify(e.callArgs),s=e.callArgs}catch(ade){console.warn("Layer ".concat(o.name," was passed ")+"non-serializable keyword arguments: "+"".concat(e.callArgs,". They will not be included ")+"in the serialized model (and thus will be missing at deserialization time)."),s={}}if(e.inboundLayers.length>0){const n=[];for(let a=0;a<e.inboundLayers.length;a++){const r=e.inboundLayers[a],o=e.nodeIndices[a],i=e.tensorIndices[a];let c=t[Jk.nodeKey(r,o)];null==c&&(c=0),n.push([r.name,c,i,s])}r.push(n)}}}const s={};s.name=o.name,s.className=e,s.config=a,s.inboundNodes=r,n.push(s)}e.layers=n;const a=[];for(let o=0;o<this.inputLayers.length;o++){const e=this.inputLayers[o],n=this.inputLayersNodeIndices[o],r=Jk.nodeKey(e,n);if(!this.containerNodes.has(r))continue;let s=t[r];null!==s&&void 0!==s||(s=0);const i=this.inputLayersTensorIndices[o];a.push([e.name,s,i])}e.inputLayers=a;const r=[];for(let o=0;o<this.outputLayers.length;o++){const e=this.outputLayers[o],n=this.outputLayersNodeIndices[o],a=Jk.nodeKey(e,n);if(!this.containerNodes.has(a))continue;let s=t[a];null!==s&&void 0!==s||(s=0);const i=this.outputLayersTensorIndices[o];r.push([e.name,s,i])}return e.outputLayers=r,e}static fromConfig(e,t){let n=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const a={},r={};function o(e,t){e.name in r?r[e.name].push(t):r[e.name]=[t]}function s(e,t){const n=[];let r;for(const s of t){const i=s[0],c=s[1],l=s[2];if(r=null==s[3]?{}:s[3],!(i in a))return void o(e,t);const u=a[i];if(u.inboundNodes.length<=c)return void o(e,t);const d=u.inboundNodes[c];n.push(d.outputTensors[l])}n.length>0&&e.apply(ev(n),r)}function i(e){const r=e.name,s=bk(e,null!=t.customObjects?t.customObjects:{});s.setFastWeightInitDuringBuild(n),a[r]=s;e.inboundNodes.forEach((e=>{if(!(e instanceof Array))throw new qx("Corrupted configuration, expected array for nodeData: ".concat(e));o(s,e)}))}const c=t.name,l=t.layers;for(const f of l)i(f);for(;!uv(r);)for(const e of l){const t=a[e.name];if(t.name in r){const e=r[t.name];delete r[t.name];for(const n of e)s(t,n)}}const u=[],d=[],h=t.inputLayers;for(const f of h){const e=f[0],t=f[1],n=f[2];Zx(e in a);const r=a[e].inboundNodes[t].outputTensors;u.push(r[n])}const p=t.outputLayers;for(const f of p){const e=f[0],t=f[1],n=f[2];Zx(e in a);const r=a[e].inboundNodes[t].outputTensors;d.push(r[n])}return new e({inputs:u,outputs:d,name:c})}get stateful(){if(this._stateful)throw new qx("Container instance unexpectedly has _stateful = true. The statefulness of a Container is determined by the Layers it contains. Its _stateful property must remain the default false.");for(const e of this.layers)if(e.stateful)return!0;return!1}resetStates(){Hu((()=>{this.layers.forEach((e=>{e.stateful&&e.resetStates()}))}))}}function Zk(e,t,n){const a=t.length;if(null==e||Array.isArray(e)&&0===e.length)return t.map((e=>null));if(1===a)return Array.isArray(e)&&1===e.length?e:"object"===typeof e&&t[0]in e?[e[t[0]]]:[e];if(Array.isArray(e)){if(e.length!==a)throw new Error("Provided ".concat(n," is an array of ").concat(e.length," ")+"element(s), but the model has ".concat(a," outputs. ")+"Make sure a set of weights is provided for each model output.");return e}if("object"===typeof e&&Object.keys(e).length>0&&"object"===typeof e[Object.keys(e)[0]]){const n=[];return t.forEach((t=>{t in e?n.push(e[t]):n.push(null)})),n}throw new Error("The model has multiple (".concat(a,") outputs, ")+"so ".concat(n," must be either an array with ")+"".concat(a," elements or an object with ").concat(t," keys. ")+"Provided ".concat(n," not understood: ").concat(JSON.stringify(e)))}function $k(e,t){return Zk(e,t,"classWeight")}async function eI(e,t,n,a){if(null!=t||null!=a)throw new Error("Support sampleWeight is not implemented yet");if(null!=n){const t=Hu((()=>{if(1===e.shape.length)return Md(e);if(2===e.shape.length){if(e.shape[1]>1){return Uh(e,1)}if(1===e.shape[1])return rp(e,[e.shape[0]]);throw new Error("Encountered unexpected last-dimension size (".concat(e.shape[1],") ")+"during handling of class weights. The size is expected to be >= 1.")}throw new Error("Unexpected rank of target (y) tensor (".concat(e.rank,") during ")+"handling of class weights. The rank is expected to be 1 or 2.")})),a=Array.from(await t.data());ju(t);const r=[];return a.forEach((e=>{if(null==n[e])throw new Error("classWeight must contain all classes in the training data. "+"The class ".concat(e," exists in the data but not in ")+"classWeight");r.push(n[e])})),Pf(r,"float32")}return null}function tI(e,t){return Bd(e,t)}function nI(e,t){let n,a;const r=t;n=r.xs,a=r.ys,mo(null!=n&&null!=a,(()=>"A Dataset iterator for fitDataset() is expected to generate objects of the form `{xs: xVal, ys: yVal}`, where the two values may be `tf.Tensor`, an array of Tensors, or a map of string to Tensor.  The provided Dataset instead generates "+"".concat(t)));const o=aI("input",e.inputNames,n),s=aI("output",e.outputNames,a),i=o[0].shape[0];mo(o.length===e.inputs.length,(()=>"LayersModel has ".concat(e.inputs.length," inputs, but the dataset ")+"provides ".concat(o.length," inputs.  (Expected input keys: ")+"".concat(JSON.stringify(e.inputNames),")"))),mo(s.length===e.outputs.length,(()=>"LayersModel has ".concat(e.outputs.length," outputs, but the dataset ")+"provides ".concat(s.length," outputs.  (Expected output keys: ")+"".concat(JSON.stringify(e.outputNames),")")));for(let c=0;c<o.length;c++)mo(o[c].shape[0]===i,(()=>"Batch size mismatch: input "+"".concat(e.inputNames[c]," has ").concat(o[c].shape[0],"; ")+"expected  ".concat(i," based on input ").concat(e.inputNames[0],".")));for(let c=0;c<s.length;c++)mo(s[c].shape[0]===i,(()=>"Batch size mismatch: output "+"".concat(e.outputNames[c]," has ").concat(s[c].shape[0],"; ")+"expected  ".concat(i," based on input ").concat(e.inputNames[0],".")));return{xs:o,ys:s}}function aI(e,t,n){if(n instanceof ou)return[n];if(Array.isArray(n))return mo(n.length===t.length,(()=>"Received an array of ".concat(n.length," Tensors, but expected ").concat(t.length," to match the ").concat(e," keys ").concat(t,"."))),n;{const a=[];for(const r of t){if(null==n[r])throw new qx("The feature data generated by the dataset lacks the required "+"".concat(e," key '").concat(r,"'."));a.push(n[r])}return a}}async function rI(e,t,n){const a=null!=n.batchesPerEpoch;if(mo(null!=e.optimizer,(()=>"You must compile a model before training/testing. Use LayersModel.compile(modelCompileConfig).")),mo(null!=n,(()=>"For fitDataset(), the 2nd argument (config) is required, but it is not provided in this call.")),mo(null!=n.epochs&&n.epochs>0&&Number.isInteger(n.epochs),(()=>"For fitDataset(), config.epochs is expected to be a positive "+"integer, but got ".concat(n.epochs))),mo(!a||n.batchesPerEpoch>0&&Number.isInteger(n.batchesPerEpoch),(()=>"For fitDataset(), config.batchesPerEpoch is expected to be a "+"positive integer if specified, but got ".concat(n.batchesPerEpoch))),mo(null==n.validationSplit,(()=>"`validationSplit` is not supported by `fitDataset()`. Use validationData instead.")),e.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");e.isTraining=!0;try{const r=null!=n.validationData;let o,s;if(r)if(oI(n.validationData))mo(null==n.validationBatches||n.validationBatches>0&&Number.isInteger(n.validationBatches),(()=>"For fitDataset() with dataset-based validation, config.validationBatches is expected not to be provided, or to be a positive integer, "+"but got ".concat(n.validationBatches)));else{const e=function(e){if(3===e.length)throw new Xx("Validation with sample weights is not implemented yet.");return{xs:e[0],ys:e[1]}}(n.validationData);o=e.xs,s=e.ys}const i=e.makeTrainFunction(),c=e.getDedupedMetricsNames();let l;l=r?c.slice().concat(c.map((e=>"val_"+e))):c.slice();const u=fk(n.callbacks,n.yieldEvery),d=null==n.verbose?1:n.verbose,{callbackList:h,history:p}=gk(u,d,n.epochs,null,null,function(e,t){let n=null;null!=t.batchesPerEpoch?n=t.batchesPerEpoch:Number.isFinite(e.size)&&(n=e.size);return n}(t,n),null,r,l);h.setModel(e),e.history=p,await h.onTrainBegin(),e.stopTraining_=!1;let f=null==n.initialEpoch?0:n.initialEpoch,m=await t.iterator();for(;f<n.epochs;){const l={};await h.onEpochBegin(f);let u=0,d=0;for(a||(m=await t.iterator());!a||u<n.batchesPerEpoch;){const t=await m.next();if(a&&t.done){console.warn("You provided `batchesPerEpoch` as "+"".concat(n.batchesPerEpoch,", ")+"but your dataset iterator ran out of data after "+"".concat(u," batches; ")+"interrupting training. Make sure that your dataset can generate at least `batchesPerEpoch * epochs` batches (in this case, "+"".concat(n.batchesPerEpoch*n.epochs," batches). ")+"You may need to use the repeat() function when building your dataset.");break}if(null!=t.value){const{xs:a,ys:r}=nI(e,t.value),o={};o.batch=d,o.size=a[0].shape[0],await h.onBatchBegin(d,o);const s=[];if(null!=n.classWeight){const t=$k(n.classWeight,e.outputNames);for(let e=0;e<t.length;++e)s.push(await eI(r[e],null,t[e]))}const l=a.concat(r).concat(s),p=i(l);ju(l);for(let e=0;e<c.length;++e){const t=c[e],n=p[e];o[t]=n,Ku(n)}await h.onBatchEnd(d,o),ik(o),d++,u++}if(a?u>=n.batchesPerEpoch:t.done){if(r){let t;t=oI(n.validationData)?tv(await e.evaluateDataset(n.validationData,{batches:n.validationBatches})):tv(e.evaluate(o,s,{batchSize:null==n.validationBatchSize?32:n.validationBatchSize,verbose:0}));for(let n=0;n<e.metricsNames.length;++n)l["val_".concat(e.metricsNames[n])]=t[n]}break}if(e.stopTraining_)break}if(await h.onEpochEnd(f,l),f++,e.stopTraining_)break}return await h.onTrainEnd(),await e.history.syncData(),e.history}finally{e.isTraining=!1}}function oI(e){return"function"===typeof e.iterator}function sI(e){mo(e>0&&Number.isInteger(e),(()=>"batchSize is required to be a positive integer, but got ".concat(e)))}function iI(e,t,n){return null==e?[null]:Array.isArray(e)?e.map((e=>Hv(e,t,n-t))):Hv(e,t,n-t)}function cI(e,t){return Hu((()=>null==e?null:Array.isArray(e)?e.map((e=>cI(e,t))):Zv(e,"int32"===t.dtype?t:Dd(t,"int32"))))}function lI(e,t){const n=[];let a=0,r=null;for(;a<e;)r=a+t,r>=e&&(r=e),n.push([a,r]),a=r;return n}function uI(e){const t=[];e instanceof ou&&(e=[e]);for(let n=0;n<e.length;++n){const a=e[n];if(1===a.rank)t.push(Gv(a,1));else{if(0===a.rank)throw new Error("Expected tensor to be at least 1D, but received a 0D tensor (scalar).");t.push(a)}}return t}function dI(e,t){if(null==e)return;const n=[];if(t instanceof ou)n.push(t.id);else if(Array.isArray(t))t.forEach((e=>n.push(e.id)));else if(null!=t)for(const r in t){const e=t[r];n.push(e.id)}const a=[];if(e instanceof ou)-1===n.indexOf(e.id)&&a.push(e);else if(Array.isArray(e))e.forEach((e=>{-1===n.indexOf(e.id)&&a.push(e)}));else if(null!=e)for(const r in e){const t=e[r];-1===n.indexOf(t.id)&&a.push(t)}a.forEach((e=>{e.isDisposed||e.dispose()}))}function hI(e){return Array.isArray(e)}function pI(e){return!function(e){return e instanceof ou}(e)&&!hI(e)}function fI(e,t,n){let a,r=!(arguments.length>3&&void 0!==arguments[3])||arguments[3],o=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"";if(null==t||0===t.length){if(null!=e){let t=!1;if(hI(e)&&e.length>0)t=!0;else if(pI(e)){for(const n in e)if(e.hasOwnProperty(n)){t=!0;break}}else t=!0;if(t)throw new qx("Error when checking model ".concat(o," expected no data, ")+"but got ".concat(e))}return[]}if(null==e)return t.map((e=>null));if(pI(e)){a=[];for(const n of t){if(null==e[n])throw new qx('No data provided for "'.concat(n,'". Need data for each key in: ')+"".concat(t));a.push(e[n])}}else if(hI(e)){if(e.length!==t.length)throw new qx("Error when checking model ".concat(o,": the Array of ")+"Tensors that you are passing to your model is not the size the "+"model expected. Expected to see ".concat(t.length," Tensor(s), but ")+"instead got the following list of Tensor(s): ".concat(e));a=e}else{if(t.length>1)throw new qx("The model ".concat(o," expects ").concat(t.length," Tensor(s), ")+"but only received one Tensor. Found: Tensor with shape ".concat(e.shape));a=[e]}if(a=uI(a),null!=n)for(let s=0;s<t.length;++s){if(null==n[s])continue;const e=a[s];if(e.shape.length!==n[s].length)throw new qx("Error when checking ".concat(o,": expected ").concat(t[s]," ")+"to have ".concat(n[s].length," dimension(s). but got array with ")+"shape ".concat(e.shape));for(let t=0;t<n[s].length;++t){if(0===t&&!r)continue;const a=e.shape[t],i=n[s][t];if(null!=i&&i>=0&&a!==i)throw new qx("".concat(o," expected a batch of elements where each ")+"example has shape [".concat(n[s].slice(1,n[s].length),"] ")+"(i.e.,tensor shape [*,".concat(n[s].slice(1,n[s].length),"])")+" but the ".concat(o," received an input with ").concat(e.shape[0])+" examples, each with shape [".concat(e.shape.slice(1,e.shape.length),"]")+" (tensor shape [".concat(e.shape,"])"))}}return a}function mI(e,t,n){let a,r=!(arguments.length>3&&void 0!==arguments[3])||arguments[3],o=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"";if(Array.isArray(e)){if(e.length!==t.length)throw new qx("Error when checking model ".concat(o,": the Array of ")+"Tensors that you are passing to your model is not the size the "+"the model expected. Expected to see ".concat(t.length," Tensor(s),")+" but instead got ".concat(e.length," Tensors(s)."));a=e}else{if(t.length>1)throw new qx("The model expects ".concat(t.length," ").concat(o," Tensors, ")+"but only received one Tensor. Found: array with shape "+"".concat(JSON.stringify(e.shape),"."));a=[e]}if(null!=n)for(let s=0;s<t.length;++s){if(null==n[s])continue;const e=a[s];if(e.shape.length!==n[s].length)throw new qx("Error when checking ".concat(o,": expected ").concat(t[s]," ")+"to have ".concat(n[s].length," dimension(s), but got array with ")+"shape ".concat(JSON.stringify(e.shape)));for(let a=0;a<n[s].length;++a){if(0===a&&!r)continue;const i=e.shape[a],c=n[s][a];if(null!=c&&c!==i)throw new qx("Error when checking ".concat(o,": expected ")+"".concat(t[s]," to have shape ").concat(JSON.stringify(n[s])," but ")+"got array with shape ".concat(JSON.stringify(e.shape),"."))}}}class gI extends Jk{constructor(e){super(e),this.isTraining=!1}summary(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:console.log;if(!this.built)throw new qx("This model has never been called, thus its weights have not been created yet. So no summary can be displayed. Build the model first (e.g., by calling it on some test data).");Gk(this,e,t,n)}compile(e){if(null==e.loss&&(e.loss=[]),this.loss=e.loss,"string"===typeof e.optimizer)this.optimizer_=function(e){const t={Adagrad:()=>qm.adagrad(.01),Adadelta:()=>qm.adadelta(1,.95,Vv()),Adam:()=>qm.adam(.001,.9,.999,Vv()),Adamax:()=>qm.adamax(.002,.9,.999,Vv(),0),RMSProp:()=>qm.rmsprop(.001,.9,0,Vv()),SGD:()=>qm.sgd(.01)};if(t.adagrad=t.Adagrad,t.adadelta=t.Adadelta,t.adam=t.Adam,t.adamax=t.Adamax,t.rmsprop=t.RMSProp,t.sgd=t.SGD,e in t)return t[e]();throw new qx("Unknown Optimizer ".concat(e))}(e.optimizer),this.isOptimizerOwned=!0;else{if(!(e.optimizer instanceof Qd))throw new qx("User-defined optimizer must be an instance of tf.Optimizer.");this.optimizer_=e.optimizer,this.isOptimizerOwned=!1}let t=[];if(Array.isArray(e.loss)||"string"===typeof e.loss||"function"===typeof e.loss)if(Array.isArray(e.loss)){if(e.loss.length!==this.outputs.length)throw new qx("When passing an Array as loss, it should have one entry per "+"model output. The model has ".concat(this.outputs.length," output(s), ")+"but you passed loss=".concat(e.loss,"."));const n=e.loss;t=n.map((e=>Rk(e)))}else{const n=Rk(e.loss);this.outputs.forEach((e=>{t.push(n)}))}else{e.loss=e.loss;for(const t in e.loss)if(-1===this.outputNames.indexOf(t))throw new qx('Unknown entry in loss dictionary: "'.concat(t,'". ')+"Only expected the following keys: ".concat(this.outputNames));for(const n of this.outputNames)null==e.loss[n]&&console.warn('Output "'.concat(n,'" is missing from loss dictionary. We assume ')+"this was done on purpose, and we will not be expecting data "+"to be passed to ".concat(n," during training")),t.push(Rk(e.loss[n]))}this.lossFunctions=t,this.feedOutputNames=[],this.feedOutputShapes=[],this.feedLossFns=[];for(let o=0;o<this.outputs.length;++o){const e=this.internalOutputShapes[o],t=this.outputNames[o];this.feedOutputNames.push(t),this.feedOutputShapes.push(e),this.feedLossFns.push(this.lossFunctions[o])}const n=[];this.metrics=e.metrics,this.metricsNames=["loss"],this.metricsTensors=[],Av("loss",(()=>{for(let e=0;e<this.outputs.length;++e){if(-1!==n.indexOf(e))continue;const t=this.lossFunctions[e];this.outputs.length>1&&(this.metricsTensors.push([t,e]),this.metricsNames.push(this.outputNames[e]+"_loss"))}}));const a=function(e,t){if(null==e||Array.isArray(e)&&0===e.length)return t.map((e=>[]));let n;if("string"===typeof e||"function"===typeof e)n=[e];else{if(!Array.isArray(e)&&"object"!==typeof e)throw new TypeError("Type of metrics argument not understood. Expected an string,"+"function, Array, or Object, found: ".concat(e));n=e}if(Array.isArray(n))return t.map((e=>n));{const e=[];for(const a of t){let t=n.hasOwnProperty(a)?n[a]:[];Array.isArray(t)||(t=[t]),e.push(t)}return e}}(e.metrics,this.outputNames),r=(e,t,n)=>{this.outputNames.length>1&&(t=this.outputNames[e]+"_"+t),this.metricsNames.push(t),this.metricsTensors.push([n,e])};Av("metric",(()=>{for(let e=0;e<this.outputs.length;++e){if(-1!==n.indexOf(e))continue;(t=>{let n,a,o;for(const s of t){if("string"===typeof s&&-1!==["accuracy","acc","crossentropy","ce"].indexOf(s)){const t=this.internalOutputShapes[e];let r;1===t[t.length-1]||this.lossFunctions[e]===Nk?-1!==["accuracy","acc"].indexOf(s)?a=_k:-1!==["crossentropy","ce"].indexOf(s)&&(a=Ok):this.lossFunctions[e]===Sk?-1!==["accuracy","acc"].indexOf(s)?a=Dk:-1!==["crossentropy","ce"].indexOf(s)&&(a=Lk):-1!==["accuracy","acc"].indexOf(s)?a=Ak:-1!==["crossentropy","ce"].indexOf(s)&&(a=Mk),-1!==["accuracy","acc"].indexOf(s)?r="acc":-1!==["crossentropy","ce"].indexOf(s)&&(r="ce"),o=a,n=""+r}else{const e=zk(s);o=e,n=""+Bk(s)}let t;Av(n,(()=>{t=o})),r(e,n,t)}})(a[e])}})),this.collectedTrainableWeights=this.trainableWeights}checkTrainableWeightsConsistency(){null!=this.collectedTrainableWeights&&this.trainableWeights.length!==this.collectedTrainableWeights.length&&console.warn("Discrepancy between trainableweights and collected trainable weights. Did you set `model.trainable` without calling `model.compile()` afterwards?")}evaluate(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};const a=null==n.batchSize?32:n.batchSize;sI(a);const r=this.standardizeUserDataXY(e,t,!0,a);try{const e=r[0].concat(r[1]);this.makeTestFunction();const t=this.testFunction;return ev(this.testLoop(t,e,a,n.verbose,n.steps))}finally{dI(r[0],e),dI(r[1],t)}}async evaluateDataset(e,t){return this.makeTestFunction(),async function(e,t,n){const a=null!=(n=n||{}).batches,r=e.testFunction;let o=[];if(n.verbose>0)throw new Xx("Verbose mode is not implemented yet.");mo(!a||n.batches>0&&Number.isInteger(n.batches),(()=>"Test loop expects `batches` to be a positive integer, but "+"received ".concat(JSON.stringify(n.batches))));const s="function"===typeof t.next?t:await t.iterator();let i=0,c=0;for(;!a||c<n.batches;){const t=await s.next();if(o=Hu((()=>{if(t.value){const{xs:n,ys:a}=nI(e,t.value),s=n.concat(a),l=Hu((()=>r(s)));if(ju(s),0===c)for(let e=0;e<l.length;++e)o.push(Hd(0));const u=s[0].shape[0];for(let e=0;e<l.length;++e){const t=l[e],n=o[e];o[e]=Hu((()=>Ld(o[e],Bd(u,t)))),c>0&&ju(n)}ju(l),i+=u,++c}return o})),t.done){a&&console.warn("Your dataset iterator ran out of data during evaluateDataset(). Interrupting evalution. Make sure that your dataset can generate at least `batches` "+"batches (in this case, ".concat(n.batches," batches). ")+"You may need to use the repeat() function when building your dataset.");break}}for(let l=0;l<o.length;++l){const e=o[l];o[l]=zd(o[l],i),ju(e)}return ev(o)}(this,e,t)}checkNumSamples(e,t,n){let a,r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"steps";if(null!=n){if(a=null,null!=t)throw new qx("If ".concat(r," is set, batchSize must be null or undefined.")+"Got batchSize = ".concat(t))}else{if(null==e)throw new qx("Either the input data should have a defined shape, or "+"".concat(r," shoud be specified."));a=Array.isArray(e)?e[0].shape[0]:e.shape[0]}return a}execute(e,t){if(Array.isArray(t)&&0===t.length)throw new qx("`outputs` is an empty Array, which is not allowed.");const n=Array.isArray(t),a=n?t:[t],r=this.retrieveSymbolicTensors(a),o=new Gw;if(e instanceof ou&&(e=[e]),Array.isArray(e)){if(e.length!==this.inputs.length)throw new qx("The number of inputs provided (".concat(e.length,") ")+"does not match the number of inputs of this model "+"(".concat(this.inputs.length,")."));for(let t=0;t<this.inputs.length;++t)o.add(this.inputs[t],e[t])}else for(const i of this.inputs){const t=e[i.name];if(null==t)throw new qx("No value is provided for the model's input ".concat(i.name));o.add(i,t)}const s=Kw(r,o);return n?s:s[0]}retrieveSymbolicTensors(e){const t=Jx(null,e.length);let n=e.length;for(const a of this.layers){const r=Array.isArray(a.output)?a.output:[a.output],o=r.map((e=>e.name));for(let a=0;a<e.length;++a){const s=o.indexOf(e[a]);if(-1!==s&&(t[a]=r[s],n--),0===n)break}if(0===n)break}if(n>0){const n=[];throw t.forEach(((t,a)=>{null==t&&n.push(e[a])})),new qx("Cannot find SymbolicTensors for output name(s): "+"".concat(JSON.stringify(n)))}return t}predictLoop(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:32,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];return Hu((()=>{const a=this.checkNumSamples(e);if(n)throw new Xx("Verbose predictLoop() is not implemented yet.");const r=lI(a,t),o=this.outputs.map((e=>[]));for(let t=0;t<r.length;++t){const n=Hu((()=>{const n=r[t][0],a=r[t][1],o=iI(e,n,a),s=[];if(Array.isArray(o))for(let e=0;e<o.length;++e)s.push({key:this.inputs[e],value:o[e]});else s.push({key:this.inputs[0],value:o});const i=new Gw(s);return Kw(this.outputs,i)}));n.forEach(((e,t)=>o[t].push(e)))}return ev(o.map((e=>pp(e,0))))}))}predict(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const n=uI(e);mI(n,this.inputNames,this.feedInputShapes,!1);try{const e=null==t.batchSize?32:t.batchSize;return sI(e),this.predictLoop(n,e)}finally{dI(n,e)}}predictOnBatch(e){mI(e,this.inputNames,this.feedInputShapes,!0);const t=(Array.isArray(e)?e[0]:e).shape[0];return this.predictLoop(e,t)}standardizeUserDataXY(e,t){let n=arguments.length>3?arguments[3]:void 0;if(null==this.optimizer_)throw new Kx("You must compile a model before training/testing. Use LayersModel.compile(modelCompileArgs).");const a=[];for(let r=0;r<this.feedOutputShapes.length;++r){const e=this.feedOutputShapes[r];this.feedLossFns[r]===Sk?a.push(e.slice(0,e.length-1).concat([1])):a.push(e)}if(function(e,t,n){const a=lv(e.map((e=>e.shape[0])));a.sort();const r=lv(t.map((e=>e.shape[0])));if(r.sort(),a.length>1)throw new qx("All input Tensors (x) should have the same number of samples. Got array shapes: "+"".concat(JSON.stringify(e.map((e=>e.shape)))));if(r.length>1)throw new qx("All target Tensors (y) should have the same number of samples. Got array shapes: "+"".concat(JSON.stringify(t.map((e=>e.shape)))));if(a.length>0&&r.length>0&&!xo(a,r))throw new qx("Input Tensors should have the same number of samples as target "+"Tensors. Found ".concat(a[0]," input sample(s) and ").concat(r[0]," target ")+"sample(s).")}(e=fI(e,this.feedInputNames,this.feedInputShapes,!1,"input"),t=fI(t,this.feedOutputNames,a,!1,"target")),function(e,t,n){const a=[xk,Nk,Ik];for(let r=0;r<e.length;++r){const o=e[r],s=t[r],i=n[r];if(null!=s){if(s===Ik&&1===o.shape[o.shape.length-1])throw new qx("You are passing a target array of shape ".concat(o.shape," while using ")+"a loss 'categorical_crossentropy'. 'categorical_crossentropy'expects targets to be binary matrices (1s and 0s) of shape [samples, classes].");if(-1!==a.indexOf(s)){const e=o.shape.slice(1),t=i.slice(1);for(let n=0;n<e.length;++n){const a=e[n],r=t[n];if(null!=r&&a!==r)throw new qx("A target Tensor with shape ".concat(o.shape," was passed for an ")+"output of shape ".concat(i,", while using a loss function that ")+"expects targets to have the same shape as the output.")}}}}}(t,this.feedLossFns,this.feedOutputShapes),this.stateful&&null!=n&&n>0&&e[0].shape[0]%n!==0)throw new qx("In a stateful network, you should only pass inputs with a number of samples that is divisible by the batch size "+"".concat(n,". Found: ").concat(e[0].shape[0]," sample(s)."));return[e,t]}async standardizeUserData(e,t,n,a){let r=!(arguments.length>4&&void 0!==arguments[4])||arguments[4],o=arguments.length>5?arguments[5]:void 0;const[s,i]=this.standardizeUserDataXY(e,t,r,o);if(null!=n)throw new Error("sample weight is not supported yet.");let c=null;if(null!=a){const e=$k(a,this.outputNames);c=[];for(let t=0;t<e.length;++t)c.push(await eI(i[t],null,e[t]))}return[s,i,c]}testLoop(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0,r=arguments.length>4?arguments[4]:void 0;return Hu((()=>{const o=this.checkNumSamples(t,n,r,"steps"),s=[];if(a>0)throw new Xx("Verbose mode is not implemented yet.");if(null!=r)throw new Xx("steps mode in testLoop() is not implemented yet");{const a=lI(o,n),r=Pf(Bv(0,o));for(let n=0;n<a.length;++n){const o=a[n][0],i=a[n][1],c=Hv(r,o,i-o),l=cI(t,c),u=e(l);if(0===n)for(let e=0;e<u.length;++e)s.push(Hd(0));for(let e=0;e<u.length;++e){const t=u[e];s[e]=Ld(s[e],Bd(i-o,t))}}for(let e=0;e<s.length;++e)s[e]=zd(s[e],o)}return s}))}getDedupedMetricsNames(){const e=this.metricsNames,t=[];for(let n=0;n<e.length;++n){const a=e[n];let r=a;if($x(e,a)>1){const t=$x(e.slice(0,n),a);r+="_".concat(t)}t.push(r)}return t}makeTrainFunction(){return e=>{const t=[],n=e.slice(0,this.inputs.length),a=e.slice(this.inputs.length,this.inputs.length+this.outputs.length),r=e.slice(this.inputs.length+this.outputs.length,this.inputs.length+2*this.outputs.length),o=[],s=this.collectedTrainableWeights.map((e=>e.read())),i=this.optimizer_.minimize((()=>{const e=[];for(let t=0;t<this.inputs.length;++t)e.push({key:this.inputs[t],value:n[t]});const s=new Gw(e),i=Kw(this.outputs,s,{training:!0});let c;for(let n=0;n<this.lossFunctions.length;++n){let e=(0,this.lossFunctions[n])(a[n],i[n]);null!=r[n]&&(e=tI(e,r[n]));const o=nf(e);t.push(o),c=0===n?e:Ld(c,e)}for(let n=0;n<this.metricsTensors.length;++n){let e;if(this.outputs.length>1&&n<this.outputs.length)e=t[n];else{const t=this.metricsTensors[n][0],r=this.metricsTensors[n][1];e=nf(t(a[r],i[r]))}Ku(e),o.push(e)}return c=nf(c),this.calculateLosses().forEach((e=>{c=Ld(c,e)})),c}),!0,s);return[i].concat(o)}}makeTestFunction(){this.testFunction=e=>Hu((()=>{const t=[];let n;const a=e.slice(0,this.inputs.length),r=e.slice(this.inputs.length,this.inputs.length+this.outputs.length),o=[];for(let e=0;e<this.inputs.length;++e)o.push({key:this.inputs[e],value:a[e]});const s=new Gw(o),i=Kw(this.outputs,s);for(let e=0;e<this.lossFunctions.length;++e){const a=this.lossFunctions[e],o=nf(a(r[e],i[e]));n=0===e?o:Ld(n,o),t.push(n)}for(let e=0;e<this.metricsTensors.length;++e){const n=this.metricsTensors[e][0],a=this.metricsTensors[e][1],o=nf(n(r[a],i[a]));t.push(o)}return t}))}async fit(e,t){let n,a,r,o,s,i,c,l,u,d=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};if(this.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");this.isTraining=!0;try{const h=null==d.batchSize?32:d.batchSize;sI(h);const p=!1,f=await this.standardizeUserData(e,t,d.sampleWeight,d.classWeight,p,h);n=f[0],a=f[1],u=f[2];let m,g=!1;if(null!=d.validationData&&d.validationData.length>0){if(g=!0,2!==d.validationData.length)throw 3===d.validationData.length?new Xx("validationData including sample weights is not supported yet."):new qx("When passing validation data, it must contain 2 (valX, valY) or 3 (valX, valY, valSampleWeight) items; "+"".concat(d.validationData," is invalid."));s=d.validationData[0],i=d.validationData[1];const e=!0,t=await this.standardizeUserData(s,i,null,null,e,h);c=t[0],l=t[1],m=c.concat(l)}else if(null!=d.validationSplit&&d.validationSplit>0&&d.validationSplit<1){g=!0;const e=Math.floor(n[0].shape[0]*(1-d.validationSplit)),t=n[0].shape[0];c=iI(n,e,t),r=n,n=iI(n,0,e),l=iI(a,e,t),o=a,a=iI(a,0,e),m=c.concat(l)}else null!=d.validationSteps&&(g=!0);const b=n.concat(a).concat(u);this.checkTrainableWeightsConsistency();const y=this.makeTrainFunction(),x=this.getDedupedMetricsNames();let v,w;g?(this.makeTestFunction(),v=this.testFunction,w=x.slice().concat(x.map((e=>"val_"+e)))):(v=null,m=[],w=x.slice());const k=fk(d.callbacks,d.yieldEvery);return await this.fitLoop(y,b,x,h,d.epochs,d.verbose,k,v,m,d.shuffle,w,d.initialEpoch,null,null)}finally{this.isTraining=!1,dI(n,e),dI(a,t),dI(r,e),dI(o,t),dI(c,s),dI(l,i),null!=u&&ju(u)}}async fitLoop(e,t,n,a,r,o,s,i,c,l,u,d,h,p){null==a&&(a=32),null==r&&(r=1),null==l&&(l=!0),null==d&&(d=0);let f=!1;if(null!=i&&null!=c&&(f=!0),null!=p&&(f=!0,null==h))throw new qx("Can only use `validationSteps` when doing step-wise training, i.e., `stepsPerEpoch` must be set.");const m=this.checkNumSamples(t,a,h,"steps_per_epoch");let g;null!=m&&(g=Bv(0,m)),null==o&&(o=1);const{callbackList:b,history:y}=gk(s,o,r,d,m,h,a,f,u);b.setModel(this),this.history=y,await b.onTrainBegin(),this.stopTraining_=!1;for(let x=d;x<r;++x){await b.onEpochBegin(x);const r={};if(null!=h)throw new Xx("stepsPerEpoch mode is not implemented yet.");{if("batch"===l)throw new Xx("batch shuffling is not implemneted yet");l&&uo(g);const o=Pf(g),s=lI(m,a);for(let l=0;l<s.length;++l){const u={};if(await b.onBatchBegin(l,u),Hu((()=>{const d=s[l][0],h=s[l][1],p=Hv(o,d,h-d);u.batch=l,u.size=h-d;const m=cI(t,p),g=e(m);for(let e=0;e<n.length;++e){const t=n[e],a=g[e];u[t]=a,Ku(a)}if(l===s.length-1&&f){const e=this.testLoop(i,c,a);for(let t=0;t<n.length;++t){const a=n[t],o=e[t];Ku(o),r["val_"+a]=o}}})),await b.onBatchEnd(l,u),ik(u),this.stopTraining_)break}o.dispose()}if(await b.onEpochEnd(x,r),this.stopTraining_)break}return await b.onTrainEnd(),await this.history.syncData(),this.history}async fitDataset(e,t){return rI(this,e,t)}async trainOnBatch(e,t){const n=await this.standardizeUserData(e,t),a=n[0],r=n[1],o=this.makeTrainFunction()(a.concat(r)),s=[];for(const i of o){const e=await i.data();s.push(e[0])}return ju(o),dI(n[0],e),dI(n[1],t),ev(s)}getNamedWeights(e){const t=[],n=null!=e&&e.trainableOnly,a=n?this.trainableWeights:this.weights,r=this.getWeights(n);for(let o=0;o<a.length;++o)n&&!a[o].trainable||t.push({name:a[o].originalName,tensor:r[o]});return t}set stopTraining(e){this.stopTraining_=e}get stopTraining(){return this.stopTraining_}get optimizer(){return this.optimizer_}set optimizer(e){this.optimizer_!==e&&(this.optimizer_=e,this.isOptimizerOwned=!1)}dispose(){const e=super.dispose();if(0===e.refCountAfterDispose&&null!=this.optimizer&&this.isOptimizerOwned){const t=Gu().numTensors;this.optimizer_.dispose(),e.numDisposedVariables+=t-Gu().numTensors}return e}getLossIdentifiers(){let e;if("string"===typeof this.loss)e=nv(this.loss);else if(Array.isArray(this.loss)){for(const e of this.loss)if("string"!==typeof e)throw new Error("Serialization of non-string loss is not supported.");e=this.loss.map((e=>nv(e)))}else{const t=Object.keys(this.loss);e={};const n=this.loss;for(const a of t){if("string"!==typeof n[a])throw new Error("Serialization of non-string loss is not supported.");e[a]=nv(n[a])}}return e}getMetricIdentifiers(){if("string"===typeof this.metrics||"function"===typeof this.metrics)return[nv(Bk(this.metrics))];if(Array.isArray(this.metrics))return this.metrics.map((e=>nv(Bk(e))));{const e={};for(const t in this.metrics)e[t]=nv(Bk(this.metrics[t]));return e}}getTrainingConfig(){return{loss:this.getLossIdentifiers(),metrics:this.getMetricIdentifiers(),optimizer_config:{class_name:this.optimizer.getClassName(),config:this.optimizer.getConfig()}}}loadTrainingConfig(e){if(null!=e.weighted_metrics)throw new Error("Loading weight_metrics is not supported yet.");if(null!=e.loss_weights)throw new Error("Loading loss_weights is not supported yet.");if(null!=e.sample_weight_mode)throw new Error("Loading sample_weight_mode is not supported yet.");const t=bk(Xk(e.optimizer_config));let n,a;if("string"===typeof e.loss)n=av(e.loss);else if(Array.isArray(e.loss))n=e.loss.map((e=>av(e)));else if(null!=e.loss){n={};for(const t in e.loss)n[t]=av(e.loss[t])}if(Array.isArray(e.metrics))a=e.metrics.map((e=>av(e)));else if(null!=e.metrics){a={};for(const t in e.metrics)a[t]=av(e.metrics[t])}this.compile({loss:n,metrics:a,optimizer:t})}async save(e,t){if("string"===typeof e){const t=(n=e,od.getSaveHandlers(n));if(0===t.length)throw new qx("Cannot find any save handlers for URL '".concat(e,"'"));if(t.length>1)throw new qx("Found more than one (".concat(t.length,") save handlers for ")+"URL '".concat(e,"'"));e=t[0]}var n;if(null==e.save)throw new qx("LayersModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");const a=await Ju(this.getNamedWeights(t)),r={modelTopology:this.toJSON(null,!1),format:"layers-model",generatedBy:"TensorFlow.js tfjs-layers v".concat(Qk),convertedBy:null};if(null!=t&&t.includeOptimizer&&null!=this.optimizer){r.trainingConfig=this.getTrainingConfig();const e="optimizer",{data:t,specs:n}=await Ju(await this.optimizer.getWeights(),e);a.specs.push(...n),a.data=(o=[a.data,t],Vu.join(o))}var o;if(null!=this.userDefinedMetadata){const e=!0;Vk(this.userDefinedMetadata,this.name,e),r.userDefinedMetadata=this.userDefinedMetadata}return r.weightData=a.data,r.weightSpecs=a.specs,e.save(r)}setUserDefinedMetadata(e){Vk(e,this.name),this.userDefinedMetadata=e}getUserDefinedMetadata(){return this.userDefinedMetadata}}gI.className="Model",Yd(gI);class bI extends gI{}bI.className="Functional",Yd(bI);class yI extends gI{constructor(e){if(super({inputs:[],outputs:[]}),e=e||{},this.trainable=!0,this.built=!1,this.name=null!=e.name?e.name:xv("sequential_"),null!=e.layers)for(const t of e.layers)this.add(t)}checkShape(e){if(e.inboundNodes[0].outputTensors[0].shape.some((e=>e<0)))throw new qx("Negative dimension size caused by adding layer "+"".concat(e.name," with input shape [")+"".concat(e.inboundNodes[0].inputTensors[0].shape,"]"))}add(e){const t=e instanceof yI||e instanceof gI;let n;if(t){if(n=e,1!==n.outputs.length)throw new qx("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");if(1!==n.inputs.length)throw new qx("All layers in a Sequential model should have a single input tensor. For multi-input layers, use the functional API.")}if(0===this.outputs.length){if(0===e.inboundNodes.length){if(null==e.batchInputShape)throw new qx("The first layer in a Sequential model must get an `inputShape` or `batchInputShape` argument.");const t=function(e){if(null==e.batchShape&&null==e.shape)throw new Error("Please provide to Input either a `shape` or a `batchShape` argument. Note that `shape` does not include the batch dimension.");if(null!=e.batchShape&&null!=e.shape)throw new qx("Please provide either a `shape` or `batchShape` argument to Input, but not both.");let t=e.batchShape;null!=e.shape&&null==t&&(t=[null].concat(e.shape));let n=e.dtype;return null==n&&(n="float32"),new Uw({batchInputShape:t,name:e.name,dtype:n,sparse:e.sparse}).inboundNodes[0].outputTensors[0]}({batchShape:e.batchInputShape,dtype:e.dtype,name:e.name+"_input"});e.apply(t)}if(t)this.outputs=n.outputs,this.inputs=n.inputs;else{if(1!==e.inboundNodes.length)throw new qx("A layer added to a Sequential model must not already be "+"connected somewhere else. LayersModel received layer ".concat(e.name," ")+"which has ".concat(e.inboundNodes.length," pre-existing inbound ")+"connections.");if(1!==e.inboundNodes[0].outputTensors.length)throw new qx("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(e),this.outputs=[e.inboundNodes[0].outputTensors[0]],this.inputs=Vw(this.outputs[0])}this.inboundNodes=[],new zw({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:Jx(null,this.inputs.length),outputMasks:[null],inputShapes:this.inputs.map((e=>e.shape)),outputShapes:this.outputs[0].shape})}else{const t=e.apply(this.outputs[0]);if(Array.isArray(t))throw new TypeError("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(e),this.outputs=[t],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}this.layers.push(e),this.built=!1}pop(){if(0===this.layers.length)throw new TypeError("There are no layers in the model.");if(this.layers.pop(),0===this.layers.length)this.outputs=[],this.inboundNodes=[],this.outboundNodes=[];else{const e=this.layers.length-1;this.layers[e].outboundNodes=[],this.outputs=[this.layers[e].output],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}}call(e,t){return null==this.model&&this.build(),this.model.call(e,t)}build(e){if(Rw(e),0===this.inputs.length||0===this.outputs.length)throw new TypeError("Sequential model cannot be built: model is empty. Add some layers first.");this.model=new gI({inputs:this.inputs,outputs:this.outputs[0],name:this.name+"_model"}),this.model.trainable=this.trainable,this.supportsMasking=this.model.supportsMasking,this.inputLayers=this.model.inputLayers,this.inputLayersNodeIndices=this.model.inputLayersNodeIndices,this.inputLayersTensorIndices=this.model.inputLayersTensorIndices,this.outputLayers=this.model.outputLayers,this.outputLayersNodeIndices=this.model.outputLayersNodeIndices,this.outputLayersTensorIndices=this.model.outputLayersTensorIndices,this.nodesByDepth=this.model.nodesByDepth,this.containerNodes=this.model.containerNodes,this.outputNames=this.model.outputNames,this.inputNames=this.model.inputNames,this.built=!0}countParams(){return this.built||this.build(),super.countParams()}summary(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:console.log;this.built||this.build(),super.summary(e,t,n)}setWeights(e){null==this.model&&this.build(),this.model.setWeights(e)}evaluate(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};if(!this.built)throw new Kx("The model needs to be compiled before being used.");return this.model.evaluate(e,t,n)}async evaluateDataset(e,t){if(!this.built)throw new Kx("The model needs to be compiled before being used.");return this.model.evaluateDataset(e,t)}predict(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return null==this.model&&this.build(),this.model.predict(e,t)}predictOnBatch(e){return null==this.model&&this.build(),this.model.predictOnBatch(e)}compile(e){this.build(),this.model.compile(e),this.optimizer_=this.model.optimizer,this.isOptimizerOwned=this.model.isOptimizerOwned,this.loss=this.model.loss,this.metrics=this.model.metrics,this.metricsTensors=this.model.metricsTensors,this.metricsNames=this.model.metricsNames}get optimizer(){return null==this.model?void 0:this.model.optimizer}set optimizer(e){this.model.optimizer=e}async fit(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};if(!this.built)throw new Kx("The model needs to be compiled before being used.");return this.model.fit(e,t,n)}async fitDataset(e,t){if(!this.built)throw new Kx("The model needs to be compiled before being used.");return this.model.fitDataset(e,t)}async trainOnBatch(e,t){return this.model.trainOnBatch(e,t)}static fromConfig(e,t){let n,a=arguments.length>3&&void 0!==arguments[3]&&arguments[3],r={};if(t instanceof Array){if(null==t[0].className||"Merge"===t[0].className)throw new qx("Legacy serialization format not supported yet.");n=t}else mo(null!=t.layers,(()=>"When the config data for a Sequential model is not an Array, it must be an Object that contains the 'layers' field.")),n=t.layers,delete t.layers,r=t;const o=new e(r);if(!(o instanceof yI))throw new Xx("Sequential.fromConfig called on non-Sequential input: ".concat(o));for(const s of n){const e=bk(s,void 0,a);a&&e.setFastWeightInitDuringBuild(!0),o.add(e)}return o}set stopTraining(e){if(null==this.model)throw new qx("Cannot set the stopTraining property of a sequential model before it is compiled.");this.model.stopTraining=e}get stopTraining(){if(null==this.model)throw new qx("Cannot get the stopTraining property of a sequential model before it is compiled.");return this.model.stopTraining}getConfig(){const e=[];for(const t of this.layers){const n={};n.className=t.getClassName(),n.config=t.getConfig(),e.push(n)}return{name:this.name,layers:e}}}yI.className="Sequential",Yd(yI);class xI extends qd{getConfig(){return{}}}class vI extends xI{apply(e){return function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;if(1!==t)throw new Xx("Support for alpha values other than 1 (".concat(t,") is not implemented ")+"yet.");return Tp(e)}(e,arguments.length>1&&void 0!==arguments[1]?arguments[1]:1)}}vI.className="elu",Yd(vI);class wI extends xI{apply(e){return If(e)}}wI.className="selu",Yd(wI);class kI extends xI{apply(e){return wf(e)}}kI.className="relu",Yd(kI);class II extends xI{apply(e){return Hu((()=>rf(6,wf(e))))}}II.className="relu6",Yd(II);class SI extends xI{apply(e){return e}}SI.className="linear",Yd(SI);class NI extends xI{apply(e){return Nf(e)}}NI.className="sigmoid",Yd(NI);class CI extends xI{apply(e){return function(e){return Hu((()=>{const t=Ld(.5,Bd(.2,e));return hp(t,0,1)}))}(e)}}CI.className="hardSigmoid",Yd(CI);class TI extends xI{apply(e){return Ff(e)}}TI.className="softplus",Yd(TI);class EI extends xI{apply(e){return function(e){return Hu((()=>zd(e,Ld(ah(e),1))))}(e)}}EI.className="softsign",Yd(EI);class RI extends xI{apply(e){return Lf(e)}}RI.className="tanh",Yd(RI);class _I extends xI{apply(e){return Af(e,arguments.length>1&&void 0!==arguments[1]?arguments[1]:-1)}}_I.className="softmax",Yd(_I);class AI extends xI{apply(e){return Up(e,arguments.length>1&&void 0!==arguments[1]?arguments[1]:-1)}}AI.className="logSoftmax",Yd(AI);class FI extends xI{apply(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return Hu((()=>Bd(Nf(Bd(e,t)),e)))}}FI.className="swish",Yd(FI);class OI extends xI{apply(e){return Hu((()=>Bd(e,Lf(Ff(e)))))}}function DI(e){return e.getClassName()}function MI(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return iv(e,Xd.getMap().classNameMap,t,"activation")}function LI(e){if(null==e){const e={className:"linear",config:{}};return MI(e)}if("string"===typeof e){const t={};return t.className=e,t.config={},MI(t)}return e instanceof xI?e:MI(e)}function PI(e){if(null!=e&&"object"!==typeof e)throw new Error("Argument to L1L2 regularizer's constructor is expected to be an "+"object, but received: ".concat(e))}OI.className="mish",Yd(OI);class zI extends qd{}class BI extends zI{constructor(e){super(),PI(e),this.l1=null==e||null==e.l1?.01:e.l1,this.l2=null==e||null==e.l2?.01:e.l2,this.hasL1=0!==this.l1,this.hasL2=0!==this.l2}apply(e){return Hu((()=>{let t=uf([1]);return this.hasL1&&(t=Ld(t,Vp(Bd(this.l1,ah(e))))),this.hasL2&&(t=Ld(t,Vp(Bd(this.l2,$v(e))))),rp(t,[])}))}getConfig(){return{l1:this.l1,l2:this.l2}}static fromConfig(e,t){return new e({l1:t.l1,l2:t.l2})}}BI.className="L1L2",Yd(BI);const WI={l1l2:"L1L2"};function VI(e){return ov(e)}function UI(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return iv(e,Xd.getMap().classNameMap,t,"regularizer")}function GI(e){if(null==e)return null;if("string"===typeof e){return UI({className:e in WI?WI[e]:e,config:{}})}return e instanceof zI?e:UI(e)}class HI extends Ww{constructor(e){super(null==e?{}:e),this.supportsMasking=!0,null!=e&&(this.maxValue=e.maxValue)}call(e,t){e=Ew(e);let n=wf(e);return null!=this.maxValue&&(n=hp(n,0,this.maxValue)),n}computeOutputShape(e){return e}getConfig(){const e={maxValue:this.maxValue},t=super.getConfig();return Object.assign(e,t),e}}HI.className="ReLU",Yd(HI);class jI extends Ww{constructor(e){super(null==e?{}:e),this.DEFAULT_ALPHA=.3,null==e&&(e={}),this.alpha=null==e.alpha?this.DEFAULT_ALPHA:e.alpha}call(e,t){const n=Ew(e);return Pp(n,this.alpha)}computeOutputShape(e){return e}getConfig(){const e={alpha:this.alpha},t=super.getConfig();return Object.assign(e,t),e}}jI.className="LeakyReLU",Yd(jI);class KI extends Ww{constructor(e){if(super(null==e?{}:e),this.DEFAULT_ALPHA_INITIALIZER="zeros",null==e&&(e={}),this.supportsMasking=!0,this.alphaInitializer=Nw(e.alphaInitializer||this.DEFAULT_ALPHA_INITIALIZER),this.alphaRegularizer=GI(e.alphaRegularizer),this.alphaConstraint=ok(e.alphaConstraint),null==e.sharedAxes)this.sharedAxes=null;else if(Array.isArray(e.sharedAxes))this.sharedAxes=e.sharedAxes;else{if("number"!==typeof e.sharedAxes)throw new qx("Expected sharedAxes to be a number or an array of numbers, "+"but got ".concat(e.sharedAxes));this.sharedAxes=[e.sharedAxes]}}build(e){const t=(e=Rw(e)).slice(1);if(null!=this.sharedAxes)for(const a of this.sharedAxes)t[a-1]=1;this.alpha=this.addWeight("alpha",t,"float32",this.alphaInitializer,this.alphaRegularizer,!0,this.alphaConstraint);const n={};if(null!=this.sharedAxes)for(let a=1;a<e.length;++a)n[a]=e[a];this.inputSpec=[new Mw({ndim:e.length,axes:n})],this.built=!0}call(e,t){return e=Ew(e),ff(e,this.alpha.read())}getConfig(){const e={alphaInitializer:Sw(this.alphaInitializer),alphaRegularizer:VI(this.alphaRegularizer),alphaConstraint:ak(this.alphaConstraint),sharedAxes:this.sharedAxes},t=super.getConfig();return Object.assign(e,t),e}}KI.className="PReLU",Yd(KI);class qI extends Ww{constructor(e){if(super(null==e?{}:e),this.DEFAULT_ALPHA=1,null==e&&(e={}),null!=e.alpha&&e.alpha!==this.DEFAULT_ALPHA)throw new Xx("Non-default alpha value (".concat(e.alpha,") is not supported by the ")+"ELU layer yet.");this.alpha=null==e.alpha?this.DEFAULT_ALPHA:e.alpha}call(e,t){const n=Ew(e);return Tp(n)}computeOutputShape(e){return e}getConfig(){const e={alpha:this.alpha},t=super.getConfig();return Object.assign(e,t),e}}qI.className="ELU",Yd(qI);class XI extends Ww{constructor(e){super(null==e?{}:e),this.DEFAULT_THETA=1,null==e&&(e={}),this.theta=null==e.theta?this.DEFAULT_THETA:e.theta}call(e,t){const n=Ew(e);return Bd(n,Dd(Mp(n,this.theta),"float32"))}computeOutputShape(e){return e}getConfig(){const e={theta:this.theta},t=super.getConfig();return Object.assign(e,t),e}}XI.className="ThresholdedReLU",Yd(XI);class YI extends Ww{constructor(e){super(null==e?{}:e),this.DEFAULT_AXIS=1,null==e&&(e={}),this.softmax=(new _I).apply,this.axis=null==e.axis?this.DEFAULT_AXIS:e.axis}call(e,t){return Hu((()=>{let n=Ew(e);const a=t.mask;if(null!=a){const e=Bd(th(df(n.shape),Dd(a,n.dtype)),Hd(-1e9));n=Ld(n,e)}return this.axis instanceof Array?this.axis.length>1?Rp(th(n,Jp(n,this.axis,!0))):this.softmax(n,this.axis[0]):this.softmax(n,this.axis)}))}computeOutputShape(e){return e}getConfig(){const e={axis:this.axis},t=super.getConfig();return Object.assign(e,t),e}}function QI(e,t,n){if("number"===typeof e)return Jx(e,t);if(e.length!==t)throw new qx("The ".concat(n," argument must be an integer or tuple of ").concat(t," integers.")+" Received: ".concat(e.length," elements."));for(let r=0;r<t;++r){const o=e[r];if((a=o)!==parseInt(a.toString(),10))throw new qx("The ".concat(n," argument must be an integer or tuple of ").concat(t)+" integers. Received: ".concat(JSON.stringify(e)," including a")+" non-integer number ".concat(o))}return e;var a}function JI(e,t,n,a){if(null==e)return e;let r;return r="same"===n?e:e-(t+(t-1)*((arguments.length>4&&void 0!==arguments[4]?arguments[4]:1)-1))+1,Math.floor((r+a-1)/a)}function ZI(e,t,n,a){if(null==e)return null;if("valid"===a)e=e*t+zv([n-t,0]);else{if("same"!==a)throw new qx("Unsupport padding mode: ".concat(a,"."));e*=t}return e}function $I(e,t){return Hu((()=>(Cv(t),"channelsFirst"===t?Hf(e,[0,2,3,1]):e)))}function eS(e,t){return Hu((()=>(Cv(t),"channelsFirst"===t?Hf(e,[0,2,3,4,1]):e)))}function tS(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1,r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"valid",o=arguments.length>5?arguments[5]:void 0,s=arguments.length>6&&void 0!==arguments[6]?arguments[6]:1;return Hu((()=>{if(null==o&&(o="channelsLast"),Cv(o),3!==e.shape.length)throw new qx("The input of a conv1dWithBias operation should be 3, but is "+"".concat(e.shape.length," instead."));if(3!==t.shape.length)throw new qx("The kernel for a conv1dWithBias operation should be 3, but is "+"".concat(t.shape.length," instead"));if(null!=n&&1!==n.shape.length)throw new qx("The bias for a conv1dWithBias operation should be 1, but is "+"".concat(t.shape.length," instead"));if("channelsFirst"===o&&(e=Hf(e,[0,2,1])),"causal"===r)throw new Xx("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");let i=xp(e,t,a,"same"===r?"same":"valid","NWC",s);return null!=n&&(i=tw(i,n)),i}))}function nS(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:[1,1],r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"valid",o=arguments.length>5?arguments[5]:void 0,s=arguments.length>6?arguments[6]:void 0,i=arguments.length>7&&void 0!==arguments[7]?arguments[7]:null;return Hu((()=>{if(null==o&&(o="channelsLast"),Cv(o),3!==e.rank&&4!==e.rank)throw new qx("conv2dWithBiasActivation expects input to be of rank 3 or 4, "+"but received ".concat(e.rank,"."));if(3!==t.rank&&4!==t.rank)throw new qx("conv2dWithBiasActivation expects kernel to be of rank 3 or 4, "+"but received ".concat(e.rank,"."));let c=$I(e,o);if("causal"===r)throw new Xx("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");return c=am({x:c,filter:t,strides:a,pad:"same"===r?"same":"valid",dilations:s,dataFormat:"NHWC",bias:n,activation:i}),"channelsFirst"===o&&(c=Hf(c,[0,3,1,2])),c}))}function aS(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:[1,1,1],r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"valid",o=arguments.length>5?arguments[5]:void 0,s=arguments.length>6?arguments[6]:void 0;return Hu((()=>{if(null==o&&(o="channelsLast"),Cv(o),4!==e.rank&&5!==e.rank)throw new qx("conv3dWithBias expects input to be of rank 4 or 5, but received "+"".concat(e.rank,"."));if(4!==t.rank&&5!==t.rank)throw new qx("conv3dWithBias expects kernel to be of rank 4 or 5, but received "+"".concat(e.rank,"."));let i=eS(e,o);if("causal"===r)throw new Xx("The support for CAUSAL padding mode in conv3dWithBias is not implemented yet.");return i=kp(i,t,a,"same"===r?"same":"valid","NDHWC",s),null!=n&&(i=tw(i,n)),"channelsFirst"===o&&(i=Hf(i,[0,4,1,2,3])),i}))}YI.className="Softmax",Yd(YI);class rS extends Ww{constructor(e,t){if(super(t),this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",rS.verifyArgs(t),this.rank=e,pv(this.rank,"rank"),1!==this.rank&&2!==this.rank&&3!==this.rank)throw new Xx("Convolution layer for rank other than 1, 2, or 3 (".concat(this.rank,") is ")+"not implemented yet.");if(this.kernelSize=QI(t.kernelSize,e,"kernelSize"),this.strides=QI(null==t.strides?1:t.strides,e,"strides"),this.padding=null==t.padding?"valid":t.padding,Tv(this.padding),this.dataFormat=null==t.dataFormat?"channelsLast":t.dataFormat,Cv(this.dataFormat),this.activation=LI(t.activation),this.useBias=null==t.useBias||t.useBias,this.biasInitializer=Nw(t.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.biasConstraint=ok(t.biasConstraint),this.biasRegularizer=GI(t.biasRegularizer),this.activityRegularizer=GI(t.activityRegularizer),this.dilationRate=QI(null==t.dilationRate?1:t.dilationRate,e,"dilationRate"),1===this.rank&&Array.isArray(this.dilationRate)&&1!==this.dilationRate.length)throw new qx("dilationRate must be a number or an array of a single number for 1D convolution, but received "+"".concat(JSON.stringify(this.dilationRate)));if(2===this.rank){if("number"===typeof this.dilationRate)this.dilationRate=[this.dilationRate,this.dilationRate];else if(2!==this.dilationRate.length)throw new qx("dilationRate must be a number or array of two numbers for 2D "+"convolution, but received ".concat(JSON.stringify(this.dilationRate)))}else if(3===this.rank)if("number"===typeof this.dilationRate)this.dilationRate=[this.dilationRate,this.dilationRate,this.dilationRate];else if(3!==this.dilationRate.length)throw new qx("dilationRate must be a number or array of three numbers for 3D "+"convolution, but received ".concat(JSON.stringify(this.dilationRate)))}static verifyArgs(e){if(Zx("kernelSize"in e,"required key 'kernelSize' not in config"),"number"!==typeof e.kernelSize&&!hv(e.kernelSize,"number",1,3))throw new qx("BaseConv expects config.kernelSize to be number or number[] with "+"length 1, 2, or 3, but received ".concat(JSON.stringify(e.kernelSize),"."))}getConfig(){const e={kernelSize:this.kernelSize,strides:this.strides,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,activation:DI(this.activation),useBias:this.useBias,biasInitializer:Sw(this.biasInitializer),biasRegularizer:VI(this.biasRegularizer),activityRegularizer:VI(this.activityRegularizer),biasConstraint:ak(this.biasConstraint)},t=super.getConfig();return Object.assign(e,t),e}}class oS extends rS{constructor(e,t){super(e,t),this.kernel=null,oS.verifyArgs(t),this.filters=t.filters,pv(this.filters,"filters"),this.kernelInitializer=Nw(t.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.kernelConstraint=ok(t.kernelConstraint),this.kernelRegularizer=GI(t.kernelRegularizer)}build(e){e=Rw(e);const t="channelsFirst"===this.dataFormat?1:e.length-1;if(null==e[t])throw new qx("The channel dimension of the input should be defined. "+"Found ".concat(e[t]));const n=e[t],a=this.kernelSize.concat([n,this.filters]);this.kernel=this.addWeight("kernel",a,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[{ndim:this.rank+2,axes:{[t]:n}}],this.built=!0}call(e,t){return Hu((()=>{let t;e=Ew(e);const n=null==this.bias?null:this.bias.read(),a=mv(this.activation.getClassName());if(null!=a&&2===this.rank)t=nS(e,this.kernel.read(),n,this.strides,this.padding,this.dataFormat,this.dilationRate,a);else{if(1===this.rank)t=tS(e,this.kernel.read(),n,this.strides[0],this.padding,this.dataFormat,this.dilationRate[0]);else if(2===this.rank)t=nS(e,this.kernel.read(),n,this.strides,this.padding,this.dataFormat,this.dilationRate);else{if(3!==this.rank)throw new Xx("convolutions greater than 3D are not implemented yet.");t=aS(e,this.kernel.read(),n,this.strides,this.padding,this.dataFormat,this.dilationRate)}null!=this.activation&&(t=this.activation.apply(t))}return t}))}computeOutputShape(e){e=Rw(e);const t=[],n="channelsLast"===this.dataFormat?e.slice(1,e.length-1):e.slice(2);for(let r=0;r<n.length;++r){const e=JI(n[r],this.kernelSize[r],this.padding,this.strides[r],"number"===typeof this.dilationRate?this.dilationRate:this.dilationRate[r]);t.push(e)}let a=[e[0]];return"channelsLast"===this.dataFormat?(a=a.concat(t),a.push(this.filters)):(a.push(this.filters),a=a.concat(t)),a}getConfig(){const e={filters:this.filters,kernelInitializer:Sw(this.kernelInitializer),kernelRegularizer:VI(this.kernelRegularizer),kernelConstraint:ak(this.kernelConstraint)},t=super.getConfig();return Object.assign(e,t),e}static verifyArgs(e){if(!("filters"in e)||"number"!==typeof e.filters||e.filters<1)throw new qx("Convolution layer expected config.filters to be a 'number' > 0 "+"but got ".concat(JSON.stringify(e.filters)))}}class sS extends oS{constructor(e){super(2,e),sS.verifyArgs(e)}getConfig(){const e=super.getConfig();return delete e.rank,e}static verifyArgs(e){if("number"!==typeof e.kernelSize&&!hv(e.kernelSize,"number",1,2))throw new qx("Conv2D expects config.kernelSize to be number or number[] with "+"length 1 or 2, but received ".concat(JSON.stringify(e.kernelSize),"."))}}sS.className="Conv2D",Yd(sS);class iS extends oS{constructor(e){super(3,e),iS.verifyArgs(e)}getConfig(){const e=super.getConfig();return delete e.rank,e}static verifyArgs(e){if("number"!==typeof e.kernelSize&&(!Array.isArray(e.kernelSize)||1!==e.kernelSize.length&&3!==e.kernelSize.length))throw new qx("Conv3D expects config.kernelSize to be number or"+" [number, number, number], but received ".concat(JSON.stringify(e.kernelSize),"."))}}iS.className="Conv3D",Yd(iS);class cS extends sS{constructor(e){if(super(e),this.inputSpec=[new Mw({ndim:4})],"same"!==this.padding&&"valid"!==this.padding)throw new qx("Conv2DTranspose currently supports only padding modes 'same' "+"and 'valid', but received padding mode ".concat(this.padding))}build(e){if(4!==(e=Rw(e)).length)throw new qx("Input should have rank 4; Received input shape: "+JSON.stringify(e));const t="channelsFirst"===this.dataFormat?1:e.length-1;if(null==e[t])throw new qx("The channel dimension of the inputs should be defined. Found `None`.");const n=e[t],a=this.kernelSize.concat([this.filters,n]);this.kernel=this.addWeight("kernel",a,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new Mw({ndim:4,axes:{[t]:n}})],this.built=!0}call(e,t){return Hu((()=>{let t=Ew(e);if(4!==t.shape.length)throw new qx("Conv2DTranspose.call() expects input tensor to be rank-4, but "+"received a tensor of rank-".concat(t.shape.length));const n=t.shape,a=n[0];let r,o;"channelsFirst"===this.dataFormat?(r=2,o=3):(r=1,o=2);const s=n[r],i=n[o],c=this.kernelSize[0],l=this.kernelSize[1],u=this.strides[0],d=this.strides[1],h=[a,ZI(s,u,c,this.padding),ZI(i,d,l,this.padding),this.filters];"channelsLast"!==this.dataFormat&&(t=Hf(t,[0,2,3,1]));let p=wp(t,this.kernel.read(),h,this.strides,this.padding);return"channelsLast"!==this.dataFormat&&(p=Hf(p,[0,3,1,2])),null!=this.bias&&(p=tw(p,this.bias.read(),this.dataFormat)),null!=this.activation&&(p=this.activation.apply(p)),p}))}computeOutputShape(e){const t=(e=Rw(e)).slice();let n,a,r;"channelsFirst"===this.dataFormat?(n=1,a=2,r=3):(n=3,a=1,r=2);const o=this.kernelSize[0],s=this.kernelSize[1],i=this.strides[0],c=this.strides[1];return t[n]=this.filters,t[a]=ZI(t[a],i,o,this.padding),t[r]=ZI(t[r],c,s,this.padding),t}getConfig(){const e=super.getConfig();return delete e.dilationRate,e}}cS.className="Conv2DTranspose",Yd(cS);class lS extends iS{constructor(e){if(super(e),this.inputSpec=[new Mw({ndim:5})],"same"!==this.padding&&"valid"!==this.padding)throw new qx("Conv3DTranspose currently supports only padding modes 'same' "+"and 'valid', but received padding mode ".concat(this.padding))}build(e){if(5!==(e=Rw(e)).length)throw new qx("Input should have rank 5; Received input shape: "+JSON.stringify(e));const t="channelsFirst"===this.dataFormat?1:e.length-1;if(null==e[t])throw new qx("The channel dimension of the inputs should be defined. Found `None`.");const n=e[t],a=this.kernelSize.concat([this.filters,n]);this.kernel=this.addWeight("kernel",a,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new Mw({ndim:5,axes:{[t]:n}})],this.built=!0}call(e,t){return Hu((()=>{let t=Ew(e);if(5!==t.shape.length)throw new qx("Conv3DTranspose.call() expects input tensor to be rank-4, but "+"received a tensor of rank-".concat(t.shape.length));const n=t.shape,a=n[0];let r,o,s;"channelsFirst"===this.dataFormat?(s=2,r=3,o=4):(s=1,r=2,o=3);const i=n[s],c=n[r],l=n[o],u=this.kernelSize[0],d=this.kernelSize[1],h=this.kernelSize[2],p=this.strides[0],f=this.strides[1],m=this.strides[2],g=[a,ZI(i,p,u,this.padding),ZI(c,f,d,this.padding),ZI(l,m,h,this.padding),this.filters];"channelsLast"!==this.dataFormat&&(t=Hf(t,[0,2,3,4,1]));let b=Sp(t,this.kernel.read(),g,this.strides,this.padding);return"channelsLast"!==this.dataFormat&&(b=Hf(b,[0,4,1,2,3])),null!==this.bias&&(b=tw(b,this.bias.read(),this.dataFormat)),null!==this.activation&&(b=this.activation.apply(b)),b}))}computeOutputShape(e){const t=(e=Rw(e)).slice();let n,a,r,o;"channelsFirst"===this.dataFormat?(n=1,a=2,r=3,o=4):(n=4,a=1,r=2,o=3);const s=this.kernelSize[0],i=this.kernelSize[1],c=this.kernelSize[2],l=this.strides[0],u=this.strides[1],d=this.strides[2];return t[n]=this.filters,t[a]=ZI(t[a],l,s,this.padding),t[r]=ZI(t[r],u,i,this.padding),t[o]=ZI(t[o],d,c,this.padding),t}getConfig(){const e=super.getConfig();return delete e.dilationRate,e}}lS.className="Conv3DTranspose",Yd(lS);class uS extends oS{constructor(e,t){if(super(e,t),this.DEFAULT_DEPTHWISE_INITIALIZER="glorotUniform",this.DEFAULT_POINTWISE_INITIALIZER="glorotUniform",this.depthwiseKernel=null,this.pointwiseKernel=null,null==t.filters)throw new qx("The `filters` configuration field is required by SeparableConv, but is unspecified.");if(null!=t.kernelInitializer||null!=t.kernelRegularizer||null!=t.kernelConstraint)throw new qx("Fields kernelInitializer, kernelRegularizer and kernelConstraint are invalid for SeparableConv2D. Use depthwiseInitializer, depthwiseRegularizer, depthwiseConstraint, pointwiseInitializer, pointwiseRegularizer and pointwiseConstraint instead.");if(null!=t.padding&&"same"!==t.padding&&"valid"!==t.padding)throw new qx("SeparableConv".concat(this.rank,"D supports only padding modes: ")+"'same' and 'valid', but received ".concat(JSON.stringify(t.padding)));this.depthMultiplier=null==t.depthMultiplier?1:t.depthMultiplier,this.depthwiseInitializer=Nw(t.depthwiseInitializer||this.DEFAULT_DEPTHWISE_INITIALIZER),this.depthwiseRegularizer=GI(t.depthwiseRegularizer),this.depthwiseConstraint=ok(t.depthwiseConstraint),this.pointwiseInitializer=Nw(t.depthwiseInitializer||this.DEFAULT_POINTWISE_INITIALIZER),this.pointwiseRegularizer=GI(t.pointwiseRegularizer),this.pointwiseConstraint=ok(t.pointwiseConstraint)}build(e){if((e=Rw(e)).length<this.rank+2)throw new qx("Inputs to SeparableConv".concat(this.rank,"D should have rank ")+"".concat(this.rank+2,", but received input shape: ")+"".concat(JSON.stringify(e)));const t="channelsFirst"===this.dataFormat?1:e.length-1;if(null==e[t]||e[t]<0)throw new qx("The channel dimension of the inputs should be defined, "+"but found ".concat(JSON.stringify(e[t])));const n=e[t],a=this.kernelSize.concat([n,this.depthMultiplier]),r=[];for(let s=0;s<this.rank;++s)r.push(1);r.push(n*this.depthMultiplier,this.filters);const o=!0;this.depthwiseKernel=this.addWeight("depthwise_kernel",a,"float32",this.depthwiseInitializer,this.depthwiseRegularizer,o,this.depthwiseConstraint),this.pointwiseKernel=this.addWeight("pointwise_kernel",r,"float32",this.pointwiseInitializer,this.pointwiseRegularizer,o,this.pointwiseConstraint),this.useBias?this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,o,this.biasConstraint):this.bias=null,this.inputSpec=[new Mw({ndim:this.rank+2,axes:{[t]:n}})],this.built=!0}call(e,t){return Hu((()=>{let t;if(e=Ew(e),1===this.rank)throw new Xx("1D separable convolution is not implemented yet.");return 2===this.rank&&("channelsFirst"===this.dataFormat&&(e=Hf(e,[0,2,3,1])),t=Sf(e,this.depthwiseKernel.read(),this.pointwiseKernel.read(),this.strides,this.padding,this.dilationRate,"NHWC")),this.useBias&&(t=tw(t,this.bias.read(),this.dataFormat)),null!=this.activation&&(t=this.activation.apply(t)),"channelsFirst"===this.dataFormat&&(t=Hf(t,[0,3,1,2])),t}))}getConfig(){const e=super.getConfig();return delete e.rank,delete e.kernelInitializer,delete e.kernelRegularizer,delete e.kernelConstraint,e.depthwiseInitializer=Sw(this.depthwiseInitializer),e.pointwiseInitializer=Sw(this.pointwiseInitializer),e.depthwiseRegularizer=VI(this.depthwiseRegularizer),e.pointwiseRegularizer=VI(this.pointwiseRegularizer),e.depthwiseConstraint=ak(this.depthwiseConstraint),e.pointwiseConstraint=ak(this.pointwiseConstraint),e}}uS.className="SeparableConv";class dS extends uS{constructor(e){super(2,e)}}dS.className="SeparableConv2D",Yd(dS);class hS extends oS{constructor(e){super(1,e),hS.verifyArgs(e),this.inputSpec=[{ndim:3}]}getConfig(){const e=super.getConfig();return delete e.rank,delete e.dataFormat,e}static verifyArgs(e){if("number"!==typeof e.kernelSize&&!hv(e.kernelSize,"number",1,1))throw new qx("Conv1D expects config.kernelSize to be number or number[] with "+"length 1, but received ".concat(JSON.stringify(e.kernelSize),"."))}}hS.className="Conv1D",Yd(hS);class pS extends Ww{constructor(e){super(e),"number"===typeof e.cropping?this.cropping=[[e.cropping,e.cropping],[e.cropping,e.cropping]]:"number"===typeof e.cropping[0]?this.cropping=[[e.cropping[0],e.cropping[0]],[e.cropping[1],e.cropping[1]]]:this.cropping=e.cropping,this.dataFormat=void 0===e.dataFormat?"channelsLast":e.dataFormat,this.inputSpec=[{ndim:4}]}computeOutputShape(e){return"channelsFirst"===this.dataFormat?[e[0],e[1],e[2]-this.cropping[0][0]-this.cropping[0][1],e[3]-this.cropping[1][0]-this.cropping[1][1]]:[e[0],e[1]-this.cropping[0][0]-this.cropping[0][1],e[2]-this.cropping[1][0]-this.cropping[1][1],e[3]]}call(e,t){return Hu((()=>{if(e=Ew(e),"channelsLast"===this.dataFormat){const t=Kv(e,this.cropping[0][0],e.shape[1]-this.cropping[0][0]-this.cropping[0][1],2);return Kv(t,this.cropping[1][0],e.shape[2]-this.cropping[1][1]-this.cropping[1][0],3)}{const t=Kv(e,this.cropping[0][0],e.shape[2]-this.cropping[0][0]-this.cropping[0][1],3);return Kv(t,this.cropping[1][0],e.shape[3]-this.cropping[1][1]-this.cropping[1][0],4)}}))}getConfig(){const e={cropping:this.cropping,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}}pS.className="Cropping2D",Yd(pS);class fS extends Ww{constructor(e){var t;super(e),this.DEFAULT_SIZE=[2,2],this.inputSpec=[{ndim:4}],this.size=null==e.size?this.DEFAULT_SIZE:e.size,this.dataFormat=null==e.dataFormat?"channelsLast":e.dataFormat,Cv(this.dataFormat),this.interpolation=null==e.interpolation?"nearest":e.interpolation,t=this.interpolation,dv(wv,"InterpolationFormat",t)}computeOutputShape(e){if("channelsFirst"===this.dataFormat){const t=null==e[2]?null:this.size[0]*e[2],n=null==e[3]?null:this.size[1]*e[3];return[e[0],e[1],t,n]}{const t=null==e[1]?null:this.size[0]*e[1],n=null==e[2]?null:this.size[1]*e[2];return[e[0],t,n,e[3]]}}call(e,t){return Hu((()=>{let t=Ew(e);const n=t.shape;if("channelsFirst"===this.dataFormat){t=Hf(t,[0,2,3,1]);const e=this.size[0]*n[2],a=this.size[1]*n[3],r="nearest"===this.interpolation?jm.resizeNearestNeighbor(t,[e,a]):jm.resizeBilinear(t,[e,a]);return Hf(r,[0,3,1,2])}{const e=this.size[0]*n[1],a=this.size[1]*n[2];return"nearest"===this.interpolation?jm.resizeNearestNeighbor(t,[e,a]):jm.resizeBilinear(t,[e,a])}}))}getConfig(){const e={size:this.size,dataFormat:this.dataFormat,interpolation:this.interpolation},t=super.getConfig();return Object.assign(e,t),e}}fS.className="UpSampling2D",Yd(fS);class mS extends rS{constructor(e){super(2,e),this.depthwiseKernel=null,this.depthMultiplier=null==e.depthMultiplier?1:e.depthMultiplier,this.depthwiseInitializer=Nw(e.depthwiseInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.depthwiseConstraint=ok(e.depthwiseConstraint),this.depthwiseRegularizer=GI(e.depthwiseRegularizer)}build(e){if((e=Rw(e)).length<4)throw new qx("Inputs to DepthwiseConv2D should have rank 4. "+"Received input shape: ".concat(JSON.stringify(e),"."));const t="channelsFirst"===this.dataFormat?1:3;if(null==e[t]||e[t]<0)throw new qx("The channel dimension of the inputs to DepthwiseConv2D should "+"be defined, but is not (".concat(e[t],")."));const n=e[t],a=[this.kernelSize[0],this.kernelSize[1],n,this.depthMultiplier];this.depthwiseKernel=this.addWeight("depthwise_kernel",a,null,this.depthwiseInitializer,this.depthwiseRegularizer,!0,this.depthwiseConstraint),this.useBias?this.bias=this.addWeight("bias",[n*this.depthMultiplier],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(e,t){return Hu((()=>{let t=function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:[1,1],a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"valid",r=arguments.length>4?arguments[4]:void 0,o=arguments.length>5?arguments[5]:void 0;return Hu((()=>{null==r&&(r="channelsLast"),Cv(r);let s=$I(e,r);if(4!==e.rank)throw new qx("Input for depthwiseConv2d is required to be 4-D, but is instead "+"".concat(e.rank,"-D"));if(4!==t.rank)throw new qx("depthwiseKernel is required to be 4-D, but is instead "+"".concat(t.rank,"-D"));return s=Cp(s,t,n,"same"===a?"same":"valid","NHWC",o),"channelsFirst"===r&&(s=Hf(s,[0,3,1,2])),s}))}(e=Ew(e),this.depthwiseKernel.read(),this.strides,this.padding,this.dataFormat,null);return this.useBias&&(t=tw(t,this.bias.read(),this.dataFormat)),null!=this.activation&&(t=this.activation.apply(t)),t}))}computeOutputShape(e){e=Rw(e);const t="channelsFirst"===this.dataFormat?e[2]:e[1],n="channelsFirst"===this.dataFormat?e[3]:e[2],a="channelsFirst"===this.dataFormat?e[1]*this.depthMultiplier:e[3]*this.depthMultiplier,r=JI(t,this.kernelSize[0],this.padding,this.strides[0]),o=JI(n,this.kernelSize[1],this.padding,this.strides[1]);return"channelsFirst"===this.dataFormat?[e[0],a,r,o]:[e[0],r,o,a]}getConfig(){const e=super.getConfig();return e.depthMultiplier=this.depthMultiplier,e.depthwiseInitializer=Sw(this.depthwiseInitializer),e.depthwiseRegularizer=VI(this.depthwiseRegularizer),e.depthwiseConstraint=ak(this.depthwiseRegularizer),e}}function gS(e,t,n,a){if(Array.isArray(e)){if(null!=t||null!=n)throw new qx("When inputs is an array, neither initialState or constants should be provided");null!=a&&(n=e.slice(e.length-a,e.length),e=e.slice(0,e.length-a)),e.length>1&&(t=e.slice(1,e.length)),e=e[0]}function r(e){return null==e||Array.isArray(e)?e:[e]}return{inputs:e,initialState:t=r(t),constants:n=r(n)}}function bS(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]&&arguments[3],r=arguments.length>4?arguments[4]:void 0,o=arguments.length>5?arguments[5]:void 0,s=arguments.length>6&&void 0!==arguments[6]&&arguments[6],i=arguments.length>7&&void 0!==arguments[7]&&arguments[7];return Hu((()=>{const c=t.shape.length;if(c<3)throw new qx("Input should be at least 3D, but is ".concat(c,"D."));const l=[1,0].concat(Bv(2,c));if(t=Hf(t,l),null!=o)throw new Xx("The rnn() functoin of the deeplearn.js backend does not support constants yet.");s&&console.warn("Backend rnn(): the unroll = true option is not applicable to the imperative deeplearn.js backend."),null!=r&&(r=Dd(Dd(r,"bool"),"float32"),r.rank===c-1&&(r=_p(r,-1)),r=Hf(r,l)),a&&(t=kf(t,0),null!=r&&(r=kf(r,0)));const u=[];let d,h=n;const p=t.shape[0],f=Wf(t);let m,g;null!=r&&(m=Wf(r));for(let t=0;t<p;++t){const n=f[t],a=Hu((()=>e(n,h)));if(null==r)d=a[0],h=a[1];else{const e=Hu((()=>{const e=m[t],n=th(hf(e),e),r=Ld(Bd(a[0],e),Bd(h[0],n)),o=h.map(((t,r)=>Ld(Bd(a[1][r],e),Bd(t,n))));return{output:r,newStates:o}}));d=e.output,h=e.newStates}i&&u.push(d)}if(i){g=Mf(u,1)}return[d,g,h]}))}mS.className="DepthwiseConv2D",Yd(mS);class yS extends Ww{constructor(e){let t;if(super(e),null==e.cell)throw new qx("cell property is missing for the constructor of RNN.");if(t=Array.isArray(e.cell)?new CS({cells:e.cell}):e.cell,null==t.stateSize)throw new qx("The RNN cell should have an attribute `stateSize` (tuple of integers, one integer per RNN state).");this.cell=t,this.returnSequences=null!=e.returnSequences&&e.returnSequences,this.returnState=null!=e.returnState&&e.returnState,this.goBackwards=null!=e.goBackwards&&e.goBackwards,this._stateful=null!=e.stateful&&e.stateful,this.unroll=null!=e.unroll&&e.unroll,this.supportsMasking=!0,this.inputSpec=[new Mw({ndim:3})],this.stateSpec=null,this.states_=null,this.numConstants=null,this.keptStates=[]}getStates(){if(null==this.states_){return Bv(0,Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1).map((e=>null))}return this.states_}setStates(e){this.states_=e}computeOutputShape(e){Cw(e)&&(e=e[0]);let t=this.cell.stateSize;Array.isArray(t)||(t=[t]);const n=t[0];let a;if(a=this.returnSequences?[e[0],e[1],n]:[e[0],n],this.returnState){const n=[];for(const a of t)n.push([e[0],a]);return[a].concat(n)}return a}computeMask(e,t){return Hu((()=>{Array.isArray(t)&&(t=t[0]);const e=this.returnSequences?t:null;if(this.returnState){const t=this.states.map((e=>null));return[e].concat(t)}return e}))}get states(){if(null==this.states_){const e=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1,t=[];for(let n=0;n<e;++n)t.push(null);return t}return this.states_}set states(e){this.states_=e}build(e){if(null!=this.numConstants)throw new Xx("Constants support is not implemented in RNN yet.");Cw(e)&&(e=e[0]);const t=this.stateful?e[0]:null,n=e.slice(2);this.inputSpec[0]=new Mw({shape:[t,null,...n]});const a=[e[0]].concat(e.slice(2));let r;if(this.cell.build(a),r=Array.isArray(this.cell.stateSize)?this.cell.stateSize:[this.cell.stateSize],null!=this.stateSpec){if(!xo(this.stateSpec.map((e=>e.shape[e.shape.length-1])),r))throw new qx("An initialState was passed that is not compatible with "+"cell.stateSize. Received stateSpec=".concat(this.stateSpec,"; ")+"However cell.stateSize is ".concat(this.cell.stateSize))}else this.stateSpec=r.map((e=>new Mw({shape:[null,e]})));this.stateful&&this.resetStates()}resetStates(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];Hu((()=>{if(!this.stateful)throw new jx("Cannot call resetStates() on an RNN Layer that is not stateful.");const n=this.inputSpec[0].shape[0];if(null==n)throw new qx("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(null==this.states_)Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map((e=>uf([n,e]))):this.states_=[uf([n,this.cell.stateSize])];else if(null==e)ju(this.states_),null!=this.keptStates&&(ju(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map((e=>uf([n,e]))):this.states_[0]=uf([n,this.cell.stateSize]);else{if(Array.isArray(e)||(e=[e]),e.length!==this.states_.length)throw new qx("Layer ".concat(this.name," expects ").concat(this.states_.length," state(s), ")+"but it received ".concat(e.length," state value(s). Input ")+"received: ".concat(e));!0===t?this.keptStates.push(this.states_.slice()):ju(this.states_);for(let t=0;t<this.states_.length;++t){const a=e[t],r=Array.isArray(this.cell.stateSize)?this.cell.stateSize[t]:this.cell.stateSize,o=[n,r];if(!xo(a.shape,o))throw new qx("State ".concat(t," is incompatible with layer ").concat(this.name,": ")+"expected shape=".concat(o,", received shape=").concat(a.shape));this.states_[t]=a}}this.states_=this.states_.map((e=>Ku(e.clone())))}))}apply(e,t){let n=null==t?null:t.initialState,a=null==t?null:t.constants;null==t&&(t={});const r=gS(e,n,a,this.numConstants);e=r.inputs,n=r.initialState,a=r.constants;let o=[],s=[];if(null!=n){t.initialState=n,o=o.concat(n),this.stateSpec=[];for(const e of n)this.stateSpec.push(new Mw({shape:e.shape}));s=s.concat(this.stateSpec)}null!=a&&(t.constants=a,o=o.concat(a),this.numConstants=a.length);if(o[0]instanceof Lw){const n=[e].concat(o),a=this.inputSpec.concat(s),r=this.inputSpec;this.inputSpec=a;const i=super.apply(n,t);return this.inputSpec=r,i}return super.apply(e,t)}call(e,t){return Hu((()=>{const n=null==t?null:t.mask,a=null==t?null:t.training;let r=null==t?null:t.initialState;e=Ew(e),null==r&&(r=this.stateful?this.states_:this.getInitialState(e));const o=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1;if(r.length!==o)throw new qx("RNN Layer has ".concat(o," state(s) but was passed ")+"".concat(r.length," initial state(s)."));this.unroll&&console.warn("Ignoring unroll = true for RNN layer, due to imperative backend.");const s={training:a},i=bS(((e,t)=>{const n=this.cell.call([e].concat(t),s);return[n[0],n.slice(1)]}),e,r,this.goBackwards,n,null,this.unroll,this.returnSequences),c=i[0],l=i[1],u=i[2];this.stateful&&this.resetStates(u,a);const d=this.returnSequences?l:c;return this.returnState?[d].concat(u):d}))}getInitialState(e){return Hu((()=>{let t=uf(e.shape);return t=Vp(t,[1,2]),t=Gv(t),Array.isArray(this.cell.stateSize)?this.cell.stateSize.map((e=>e>1?Yv(t,[1,e]):t)):this.cell.stateSize>1?[Yv(t,[1,this.cell.stateSize])]:[t]}))}get trainableWeights(){return this.trainable?this.cell.trainableWeights:[]}get nonTrainableWeights(){return this.trainable?this.cell.nonTrainableWeights:this.cell.weights}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),null!=this.cell&&this.cell.setFastWeightInitDuringBuild(e)}getConfig(){const e=super.getConfig(),t={returnSequences:this.returnSequences,returnState:this.returnState,goBackwards:this.goBackwards,stateful:this.stateful,unroll:this.unroll};null!=this.numConstants&&(t.numConstants=this.numConstants);const n=this.cell.getConfig();return this.getClassName()===yS.className&&(t.cell={className:this.cell.getClassName(),config:n}),Object.assign(Object.assign(Object.assign({},n),e),t)}static fromConfig(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};const a=bk(t.cell,n);return new e(Object.assign(t,{cell:a}))}}yS.className="RNN",Yd(yS);class xS extends Ww{}class vS extends xS{constructor(e){super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=e.units,pv(this.units,"units"),this.activation=LI(null==e.activation?this.DEFAULT_ACTIVATION:e.activation),this.useBias=null==e.useBias||e.useBias,this.kernelInitializer=Nw(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=Nw(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=Nw(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=GI(e.kernelRegularizer),this.recurrentRegularizer=GI(e.recurrentRegularizer),this.biasRegularizer=GI(e.biasRegularizer),this.kernelConstraint=ok(e.kernelConstraint),this.recurrentConstraint=ok(e.recurrentConstraint),this.biasConstraint=ok(e.biasConstraint),this.dropout=Pv([1,zv([0,null==e.dropout?0:e.dropout])]),this.recurrentDropout=Pv([1,zv([0,null==e.recurrentDropout?0:e.recurrentDropout])]),this.dropoutFunc=e.dropoutFunc,this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){e=Rw(e),this.kernel=this.addWeight("kernel",[e[e.length-1],this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias?this.bias=this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(e,t){return Hu((()=>{if(2!==e.length)throw new qx("SimpleRNNCell expects 2 input Tensors, got ".concat(e.length,"."));let n=e[1];e=e[0];const a=null!=t.training&&t.training;let r;0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=TS({ones:()=>hf(e),rate:this.dropout,training:a,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=TS({ones:()=>hf(n),rate:this.recurrentDropout,training:a,dropoutFunc:this.dropoutFunc}));const o=this.dropoutMask,s=this.recurrentDropoutMask;r=Jv(null!=o?Bd(e,o):e,this.kernel.read()),null!=this.bias&&(r=tw(r,this.bias.read())),null!=s&&(n=Bd(n,s));let i=Ld(r,Jv(n,this.recurrentKernel.read()));return null!=this.activation&&(i=this.activation.apply(i)),[i,i]}))}getConfig(){const e=super.getConfig(),t={units:this.units,activation:DI(this.activation),useBias:this.useBias,kernelInitializer:Sw(this.kernelInitializer),recurrentInitializer:Sw(this.recurrentInitializer),biasInitializer:Sw(this.biasInitializer),kernelRegularizer:VI(this.kernelRegularizer),recurrentRegularizer:VI(this.recurrentRegularizer),biasRegularizer:VI(this.biasRegularizer),activityRegularizer:VI(this.activityRegularizer),kernelConstraint:ak(this.kernelConstraint),recurrentConstraint:ak(this.recurrentConstraint),biasConstraint:ak(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout};return Object.assign(Object.assign({},e),t)}}vS.className="SimpleRNNCell",Yd(vS);class wS extends yS{constructor(e){e.cell=new vS(e),super(e)}call(e,t){return Hu((()=>{null!=this.cell.dropoutMask&&(ju(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(ju(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);const n=null==t?null:t.mask,a=null==t?null:t.training,r=null==t?null:t.initialState;return super.call(e,{mask:n,training:a,initialState:r})}))}static fromConfig(e,t){return new e(t)}}wS.className="SimpleRNN",Yd(wS);class kS extends xS{constructor(e){if(super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",e.resetAfter)throw new qx("GRUCell does not support reset_after parameter set to true.");this.units=e.units,pv(this.units,"units"),this.activation=LI(void 0===e.activation?this.DEFAULT_ACTIVATION:e.activation),this.recurrentActivation=LI(void 0===e.recurrentActivation?this.DEFAULT_RECURRENT_ACTIVATION:e.recurrentActivation),this.useBias=null==e.useBias||e.useBias,this.kernelInitializer=Nw(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=Nw(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=Nw(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=GI(e.kernelRegularizer),this.recurrentRegularizer=GI(e.recurrentRegularizer),this.biasRegularizer=GI(e.biasRegularizer),this.kernelConstraint=ok(e.kernelConstraint),this.recurrentConstraint=ok(e.recurrentConstraint),this.biasConstraint=ok(e.biasConstraint),this.dropout=Pv([1,zv([0,null==e.dropout?0:e.dropout])]),this.recurrentDropout=Pv([1,zv([0,null==e.recurrentDropout?0:e.recurrentDropout])]),this.dropoutFunc=e.dropoutFunc,this.implementation=e.implementation,this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){const t=(e=Rw(e))[e.length-1];this.kernel=this.addWeight("kernel",[t,3*this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,3*this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias?this.bias=this.addWeight("bias",[3*this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(e,t){return Hu((()=>{if(2!==e.length)throw new qx("GRUCell expects 2 input Tensors (inputs, h, c), got "+"".concat(e.length,"."));const n=null!=t.training&&t.training;let a=e[1];e=e[0],0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=TS({ones:()=>hf(e),rate:this.dropout,training:n,count:3,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=TS({ones:()=>hf(a),rate:this.recurrentDropout,training:n,count:3,dropoutFunc:this.dropoutFunc}));const r=this.dropoutMask,o=this.recurrentDropoutMask;let s,i,c;0<this.dropout&&this.dropout<1&&(e=Bd(e,r[0]));let l=Jv(e,this.kernel.read());this.useBias&&(l=tw(l,this.bias.read())),0<this.recurrentDropout&&this.recurrentDropout<1&&(a=Bd(a,o[0]));const u=this.recurrentKernel.read(),[d,h]=Of(u,[2*this.units,this.units],u.rank-1),p=Jv(a,d),[f,m,g]=Of(l,3,l.rank-1),[b,y]=Of(p,2,p.rank-1);s=this.recurrentActivation.apply(Ld(f,b)),i=this.recurrentActivation.apply(Ld(m,y));const x=Jv(Bd(i,a),h);c=this.activation.apply(Ld(g,x));const v=Ld(Bd(s,a),Bd(Ld(1,sf(s)),c));return[v,v]}))}getConfig(){const e=super.getConfig(),t={units:this.units,activation:DI(this.activation),recurrentActivation:DI(this.recurrentActivation),useBias:this.useBias,kernelInitializer:Sw(this.kernelInitializer),recurrentInitializer:Sw(this.recurrentInitializer),biasInitializer:Sw(this.biasInitializer),kernelRegularizer:VI(this.kernelRegularizer),recurrentRegularizer:VI(this.recurrentRegularizer),biasRegularizer:VI(this.biasRegularizer),activityRegularizer:VI(this.activityRegularizer),kernelConstraint:ak(this.kernelConstraint),recurrentConstraint:ak(this.recurrentConstraint),biasConstraint:ak(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation,resetAfter:!1};return Object.assign(Object.assign({},e),t)}}kS.className="GRUCell",Yd(kS);class IS extends yS{constructor(e){0===e.implementation&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),e.cell=new kS(e),super(e)}call(e,t){return Hu((()=>{null!=this.cell.dropoutMask&&(ju(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(ju(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);const n=null==t?null:t.mask,a=null==t?null:t.training,r=null==t?null:t.initialState;return super.call(e,{mask:n,training:a,initialState:r})}))}static fromConfig(e,t){return 0===t.implmentation&&(t.implementation=1),new e(t)}}IS.className="GRU",Yd(IS);class SS extends xS{constructor(e){super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=e.units,pv(this.units,"units"),this.activation=LI(void 0===e.activation?this.DEFAULT_ACTIVATION:e.activation),this.recurrentActivation=LI(void 0===e.recurrentActivation?this.DEFAULT_RECURRENT_ACTIVATION:e.recurrentActivation),this.useBias=null==e.useBias||e.useBias,this.kernelInitializer=Nw(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=Nw(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=Nw(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.unitForgetBias=e.unitForgetBias,this.kernelRegularizer=GI(e.kernelRegularizer),this.recurrentRegularizer=GI(e.recurrentRegularizer),this.biasRegularizer=GI(e.biasRegularizer),this.kernelConstraint=ok(e.kernelConstraint),this.recurrentConstraint=ok(e.recurrentConstraint),this.biasConstraint=ok(e.biasConstraint),this.dropout=Pv([1,zv([0,null==e.dropout?0:e.dropout])]),this.recurrentDropout=Pv([1,zv([0,null==e.recurrentDropout?0:e.recurrentDropout])]),this.dropoutFunc=e.dropoutFunc,this.implementation=e.implementation,this.stateSize=[this.units,this.units],this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){var t;const n=(e=Rw(e))[e.length-1];let a;if(this.kernel=this.addWeight("kernel",[n,4*this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,4*this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias){if(this.unitForgetBias){const e=this.biasInitializer,n=this.units;a=new((t=class extends sw{apply(t,a){const r=e.apply([n]),o=(new cw).apply([n]),s=e.apply([2*n]);return Xv(Xv(r,o),s)}}).className="CustomInit",t)}else a=this.biasInitializer;this.bias=this.addWeight("bias",[4*this.units],null,a,this.biasRegularizer,!0,this.biasConstraint)}else this.bias=null;this.built=!0}call(e,t){return Hu((()=>{const n=null!=t.training&&t.training;if(3!==e.length)throw new qx("LSTMCell expects 3 input Tensors (inputs, h, c), got "+"".concat(e.length,"."));let a=e[1];const r=e[2];e=e[0],0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=TS({ones:()=>hf(e),rate:this.dropout,training:n,count:4,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=TS({ones:()=>hf(a),rate:this.recurrentDropout,training:n,count:4,dropoutFunc:this.dropoutFunc}));const o=this.dropoutMask,s=this.recurrentDropoutMask;let i,c,l,u;0<this.dropout&&this.dropout<1&&(e=Bd(e,o[0]));let d=Jv(e,this.kernel.read());0<this.recurrentDropout&&this.recurrentDropout<1&&(a=Bd(a,s[0])),d=Ld(d,Jv(a,this.recurrentKernel.read())),this.useBias&&(d=tw(d,this.bias.read()));const[h,p,f,m]=Of(d,4,d.rank-1);i=this.recurrentActivation.apply(h),c=this.recurrentActivation.apply(p),l=Ld(Bd(c,r),Bd(i,this.activation.apply(f))),u=this.recurrentActivation.apply(m);const g=Bd(u,this.activation.apply(l));return[g,g,l]}))}getConfig(){const e=super.getConfig(),t={units:this.units,activation:DI(this.activation),recurrentActivation:DI(this.recurrentActivation),useBias:this.useBias,kernelInitializer:Sw(this.kernelInitializer),recurrentInitializer:Sw(this.recurrentInitializer),biasInitializer:Sw(this.biasInitializer),unitForgetBias:this.unitForgetBias,kernelRegularizer:VI(this.kernelRegularizer),recurrentRegularizer:VI(this.recurrentRegularizer),biasRegularizer:VI(this.biasRegularizer),activityRegularizer:VI(this.activityRegularizer),kernelConstraint:ak(this.kernelConstraint),recurrentConstraint:ak(this.recurrentConstraint),biasConstraint:ak(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation};return Object.assign(Object.assign({},e),t)}}SS.className="LSTMCell",Yd(SS);class NS extends yS{constructor(e){0===e.implementation&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),e.cell=new SS(e),super(e)}call(e,t){return Hu((()=>{null!=this.cell.dropoutMask&&(ju(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(ju(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);const n=null==t?null:t.mask,a=null==t?null:t.training,r=null==t?null:t.initialState;return super.call(e,{mask:n,training:a,initialState:r})}))}static fromConfig(e,t){return 0===t.implmentation&&(t.implementation=1),new e(t)}}NS.className="LSTM",Yd(NS);class CS extends xS{constructor(e){super(e),this.cells=e.cells}get stateSize(){const e=[];for(const t of this.cells.slice().reverse())Array.isArray(t.stateSize)?e.push(...t.stateSize):e.push(t.stateSize);return e}call(e,t){return Hu((()=>{let n=e.slice(1);const a=[];for(const e of this.cells.slice().reverse())Array.isArray(e.stateSize)?a.push(n.splice(0,e.stateSize.length)):a.push(n.splice(0,1));a.reverse();const r=[];let o;for(let s=0;s<this.cells.length;++s){const i=this.cells[s];n=a[s],o=0===s?[e[0]].concat(n):[o[0]].concat(n),o=i.call(o,t),r.push(o.slice(1))}n=[];for(const e of r.slice().reverse())n.push(...e);return[o[0]].concat(n)}))}build(e){let t;Cw(e)&&(e=e[0]),this.cells.forEach(((n,a)=>{Av("RNNCell_".concat(a),(()=>{n.build(e),t=Array.isArray(n.stateSize)?n.stateSize[0]:n.stateSize,e=[e[0],t]}))})),this.built=!0}getConfig(){const e=super.getConfig(),t={cells:this.cells.map((e=>({className:e.getClassName(),config:e.getConfig()})))};return Object.assign(Object.assign({},e),t)}static fromConfig(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};const a=[];for(const r of t.cells)a.push(bk(r,n));return new e({cells:a})}get trainableWeights(){if(!this.trainable)return[];const e=[];for(const t of this.cells)e.push(...t.trainableWeights);return e}get nonTrainableWeights(){const e=[];for(const t of this.cells)e.push(...t.nonTrainableWeights);if(!this.trainable){const t=[];for(const e of this.cells)t.push(...e.trainableWeights);return t.concat(e)}return e}getWeights(){const e=[];for(const t of this.cells)e.push(...t.weights);return Ow(e)}setWeights(e){const t=[];for(const n of this.cells){const a=n.weights.length,r=e.splice(a);for(let e=0;e<n.weights.length;++e)t.push([n.weights[e],r[e]])}Dw(t)}}function TS(e){const{ones:t,rate:n,training:a=!1,count:r=1,dropoutFunc:o}=e,s=()=>null!=o?o(t(),n):nw(t(),n),i=()=>aw(s,t,a);if(!r||r<=1)return Ku(i().clone());return Array(r).fill(void 0).map(i).map((e=>Ku(e.clone())))}CS.className="StackedRNNCells",Yd(CS);var ES=function(e,t){var n={};for(var a in e)Object.prototype.hasOwnProperty.call(e,a)&&t.indexOf(a)<0&&(n[a]=e[a]);if(null!=e&&"function"===typeof Object.getOwnPropertySymbols){var r=0;for(a=Object.getOwnPropertySymbols(e);r<a.length;r++)t.indexOf(a[r])<0&&Object.prototype.propertyIsEnumerable.call(e,a[r])&&(n[a[r]]=e[a[r]])}return n};class RS extends yS{constructor(e){if(e.unroll)throw new Xx("Unrolling is not possible with convolutional RNNs.");if(Array.isArray(e.cell))throw new Xx("It is not possible at the moment to stack convolutional cells.");super(e),this.inputSpec=[new Mw({ndim:5})]}call(e,t){return Hu((()=>{if(null!=this.cell.dropoutMask&&(ju(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(ju(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null),t&&t.constants)throw new qx("ConvRNN2D cell does not support constants");const n=null==t?null:t.mask,a=null==t?null:t.training,r=null==t?null:t.initialState;return super.call(e,{mask:n,training:a,initialState:r})}))}computeOutputShape(e){let t=this.computeSingleOutputShape(e);return this.returnSequences||(t=[t[0],...t.slice(2)]),this.returnState&&(t=[t,...Array(2).fill([e[0],...t.slice(-3)])]),t}getInitialState(e){return Hu((()=>{const{stateSize:t}=this.cell,n=e.shape,a=this.computeSingleOutputShape(n),r=uf([a[0],...a.slice(2)]);return Array.isArray(t)?Array(t.length).fill(r):[r]}))}resetStates(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];Hu((()=>{if(!this.stateful)throw new jx("Cannot call resetStates() on an RNN Layer that is not stateful.");const n=this.inputSpec[0].shape,a=this.computeSingleOutputShape(n),r=[a[0],...a.slice(2)];if(null==n[0])throw new qx("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(null==this.getStates())Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map((()=>uf(r))):this.states_=[uf(r)];else if(null==e)ju(this.states_),null!=this.keptStates&&(ju(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map((()=>uf(r))):this.states_[0]=uf(r);else{if(Array.isArray(e)||(e=[e]),e.length!==this.states_.length)throw new qx("Layer ".concat(this.name," expects ").concat(this.states_.length," state(s), ")+"but it received ".concat(e.length," state value(s). Input ")+"received: ".concat(e));t?this.keptStates.push(this.states_.slice()):ju(this.states_);for(let t=0;t<this.states_.length;++t){const n=e[t],a=r;if(!xo(n.shape,a))throw new qx("State ".concat(t," is incompatible with layer ").concat(this.name,": ")+"expected shape=".concat(a,", received shape=").concat(n.shape));this.states_[t]=n}}this.states_=this.states_.map((e=>Ku(e.clone())))}))}computeSingleOutputShape(e){const{dataFormat:t,filters:n,kernelSize:a,padding:r,strides:o,dilationRate:s}=this.cell,i="channelsFirst"===t,c=e[i?3:2],l=e[i?4:3],u=JI(c,a[0],r,o[0],s[0]),d=JI(l,a[1],r,o[1],s[1]);return[...e.slice(0,2),...i?[n,u,d]:[u,d,n]]}}RS.className="ConvRNN2D";class _S extends SS{constructor(e){const{filters:t,kernelSize:n,strides:a,padding:r,dataFormat:o,dilationRate:s}=e;super(Object.assign(Object.assign({},e),{units:t})),this.filters=t,pv(this.filters,"filters"),this.kernelSize=QI(n,2,"kernelSize"),this.kernelSize.forEach((e=>pv(e,"kernelSize"))),this.strides=QI(a||1,2,"strides"),this.strides.forEach((e=>pv(e,"strides"))),this.padding=r||"valid",Tv(this.padding),this.dataFormat=o||"channelsLast",Cv(this.dataFormat),this.dilationRate=QI(s||1,2,"dilationRate"),this.dilationRate.forEach((e=>pv(e,"dilationRate")))}build(e){var t;e=Rw(e);const n="channelsFirst"===this.dataFormat?1:e.length-1;if(null==e[n])throw new qx("The channel dimension of the input should be defined. "+"Found ".concat(e[n]));const a=e[n],r=this.kernelSize.concat([a,4*this.filters]);this.kernel=this.addWeight("kernel",r,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint);const o=this.kernelSize.concat([this.filters,4*this.filters]);if(this.recurrentKernel=this.addWeight("recurrent_kernel",o,null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias){let e;if(this.unitForgetBias){const n=this.biasInitializer,a=this.filters;e=new((t=class extends sw{apply(e,t){return qv([n.apply([a]),df([a]),n.apply([2*a])])}}).className="CustomInit",t)}else e=this.biasInitializer;this.bias=this.addWeight("bias",[4*this.filters],null,e,this.biasRegularizer,!0,this.biasConstraint)}this.built=!0}call(e,t){return Hu((()=>{if(3!==e.length)throw new qx("ConvLSTM2DCell expects 3 input Tensors (inputs, h, c), got "+"".concat(e.length,"."));const n=t.training||!1,a=e[0],r=e[1],o=e[2];0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=TS({ones:()=>hf(a),rate:this.dropout,training:n,count:4,dropoutFunc:this.dropoutFunc}));const s=this.dropoutMask,i=(e,t,n)=>t&&t[n]?Bd(t[n],e):e;let c=i(a,s,0),l=i(a,s,1),u=i(a,s,2),d=i(a,s,3);0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=TS({ones:()=>hf(r),rate:this.recurrentDropout,training:n,count:4,dropoutFunc:this.dropoutFunc}));const h=this.recurrentDropoutMask;let p=i(r,h,0),f=i(r,h,1),m=i(r,h,2),g=i(r,h,3);const[b,y,x,v]=Of(this.kernel.read(),4,3),[w,k,I,S]=this.useBias?Of(this.bias.read(),4):[null,null,null,null];c=this.inputConv(c,b,w,this.padding),l=this.inputConv(l,y,k,this.padding),u=this.inputConv(u,x,I,this.padding),d=this.inputConv(d,v,S,this.padding);const[N,C,T,E]=Of(this.recurrentKernel.read(),4,3);p=this.recurrentConv(p,N),f=this.recurrentConv(f,C),m=this.recurrentConv(m,T),g=this.recurrentConv(g,E);const R=this.recurrentActivation.apply(Ld(c,p)),_=this.recurrentActivation.apply(Ld(l,f)),A=Ld(Bd(_,o),Bd(R,this.activation.apply(Ld(u,m)))),F=Bd(this.recurrentActivation.apply(Ld(d,g)),this.activation.apply(A));return[F,F,A]}))}getConfig(){const e=super.getConfig(),{units:t}=e,n=ES(e,["units"]),a={filters:this.filters,kernelSize:this.kernelSize,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,strides:this.strides};return Object.assign(Object.assign({},n),a)}inputConv(e,t,n,a){const r=yp(e,t,this.strides,a||"valid","channelsFirst"===this.dataFormat?"NCHW":"NHWC",this.dilationRate);return n?tw(r,n,this.dataFormat):r}recurrentConv(e,t){return yp(e,t,1,"same","channelsFirst"===this.dataFormat?"NCHW":"NHWC")}}_S.className="ConvLSTM2DCell",Yd(_S);class AS extends RS{constructor(e){const t=new _S(e);super(Object.assign(Object.assign({},e),{cell:t}))}static fromConfig(e,t){return new e(t)}}AS.className="ConvLSTM2D",Yd(AS);class FS extends Ww{constructor(e){super(e),this.rate=Math.max(Math.min(e.rate,1),0),this.noiseShape=e.noiseShape,this.seed=e.seed,this.supportsMasking=!0}getNoiseShape(e){if(null==this.noiseShape)return this.noiseShape;const t=e.shape,n=[];for(let a=0;a<this.noiseShape.length;++a)n.push(null==this.noiseShape[a]?t[a]:this.noiseShape[a]);return n}call(e,t){return Hu((()=>{this.invokeCallHook(e,t);const n=Ew(e);if(0<this.rate&&this.rate<1){const e=null!=t.training&&t.training,a=this.getNoiseShape(n);return aw((()=>nw(n,this.rate,a,this.seed)),(()=>n),e)}return e}))}getConfig(){const e={rate:this.rate,noiseShape:this.noiseShape,seed:this.seed},t=super.getConfig();return Object.assign(e,t),e}dispose(){return super.dispose()}}FS.className="Dropout",Yd(FS);class OS extends FS{constructor(e){super(e),this.inputSpec=[{ndim:3}]}getNoiseShape(e){const t=e.shape;return[t[0],1,t[2]]}}OS.className="SpatialDropout1D",Yd(OS);class DS extends Ww{constructor(e){if(super(e),this.activation=null,this.useBias=!0,this.kernel=null,this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",null==e.batchInputShape&&null==e.inputShape&&null!=e.inputDim){let t=null;null!=e.batchSize&&(t=e.batchSize),this.batchInputShape=[t,e.inputDim]}this.units=e.units,pv(this.units,"units"),this.activation=LI(e.activation),null!=e.useBias&&(this.useBias=e.useBias),this.kernelInitializer=Nw(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.biasInitializer=Nw(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelConstraint=ok(e.kernelConstraint),this.biasConstraint=ok(e.biasConstraint),this.kernelRegularizer=GI(e.kernelRegularizer),this.biasRegularizer=GI(e.biasRegularizer),this.activityRegularizer=GI(e.activityRegularizer),this.supportsMasking=!0,this.inputSpec=[{minNDim:2}]}build(e){const t=(e=Rw(e))[e.length-1];null==this.kernel&&(this.kernel=this.addWeight("kernel",[t,this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint))),this.inputSpec=[{minNDim:2,axes:{[-1]:t}}],this.built=!0}computeOutputShape(e){const t=(e=Rw(e)).slice();return t[t.length-1]=this.units,t}call(e,t){return Hu((()=>{this.invokeCallHook(e,t);const n=Ew(e),a=mv(this.activation.getClassName());let r;return null!=a?r=Jv(n,this.kernel.read(),a,this.bias?this.bias.read():null):(r=Jv(n,this.kernel.read()),null!=this.bias&&(r=tw(r,this.bias.read())),null!=this.activation&&(r=this.activation.apply(r))),r}))}getConfig(){const e={units:this.units,activation:DI(this.activation),useBias:this.useBias,kernelInitializer:Sw(this.kernelInitializer),biasInitializer:Sw(this.biasInitializer),kernelRegularizer:VI(this.kernelRegularizer),biasRegularizer:VI(this.biasRegularizer),activityRegularizer:VI(this.activityRegularizer),kernelConstraint:ak(this.kernelConstraint),biasConstraint:ak(this.biasConstraint)},t=super.getConfig();return Object.assign(e,t),e}}DS.className="Dense",Yd(DS);class MS extends Ww{constructor(e){super(e=e||{}),this.inputSpec=[{minNDim:3}],this.dataFormat=e.dataFormat}computeOutputShape(e){e=Rw(e);for(const t of e.slice(1))if(null==t)throw new qx('The shape of the input to "Flatten" is not fully defined '+"(got ".concat(e.slice(1),"). Make sure to pass a complete ")+'"input_shape" or "batch_input_shape" argument to the first layer in your model.');return[e[0],Lv(e,1)]}call(e,t){return Hu((()=>{this.invokeCallHook(e,t);let n=Ew(e);if("channelsFirst"===this.dataFormat&&n.rank>1){const e=[0];for(let t=2;t<n.rank;++t)e.push(t);e.push(1),n=Hf(n,e)}return function(e){if(e.rank<=1)throw new qx("batchFlatten requires a minimum rank of 2. Got rank: ".concat(e.rank,"."));const t=[e.shape[0],Lv(e.shape,1)];return rp(e,t)}(n)}))}getConfig(){const e={};null!=this.dataFormat&&(e.dataFormat=this.dataFormat);const t=super.getConfig();return Object.assign(e,t),e}}MS.className="Flatten",Yd(MS);class LS extends Ww{constructor(e){super(e),this.supportsMasking=!0,this.activation=LI(e.activation)}call(e,t){return Hu((()=>{this.invokeCallHook(e,t);const n=Ew(e);return this.activation.apply(n)}))}getConfig(){const e={activation:DI(this.activation)},t=super.getConfig();return Object.assign(e,t),e}}LS.className="Activation",Yd(LS);class PS extends Ww{constructor(e){super(e),this.n=e.n,this.inputSpec=[{ndim:2}]}computeOutputShape(e){return[e[0],this.n,e[1]]}call(e,t){return Hu((()=>function(e,t){return Hu((()=>{if(2!==e.shape.length)throw new qx("repeat() expects a rank-2 tensor, but received a "+"rank-".concat(e.shape.length," tensor."));return Yv(Gv(e,1),[1,t,1])}))}(e=Ew(e),this.n)))}getConfig(){const e={n:this.n},t=super.getConfig();return Object.assign(e,t),e}}PS.className="RepeatVector",Yd(PS);class zS extends Ww{constructor(e){super(e),this.targetShape=e.targetShape;for(let t=0;t<this.targetShape.length;++t)this.isUnknown(this.targetShape[t])&&(this.targetShape[t]=null)}isUnknown(e){return e<0||null==e}fixUnknownDimension(e,t){const n="Total size of new array must be unchanged.",a=t.slice();let r=1,o=null;for(let i=0;i<a.length;++i){const e=a[i];if(this.isUnknown(e)){if(null!==o)throw new qx("Can only specifiy one unknown dimension.");o=i}else r*=e}const s=Lv(e);if(null!==o){if(0===r||s%r!==0)throw new qx(n);a[o]=s/r}else if(s!==r)throw new qx(n);return a}computeOutputShape(e){let t=!1;for(let n=0;n<e.length;++n)if(this.isUnknown(e[n])){t=!0;break}return t?e.slice(0,1).concat(this.targetShape):e.slice(0,1).concat(this.fixUnknownDimension(e.slice(1),this.targetShape))}call(e,t){return Hu((()=>{this.invokeCallHook(e,t);const n=Ew(e),a=n.shape,r=a.slice(0,1).concat(this.fixUnknownDimension(a.slice(1),this.targetShape));return rp(n,r)}))}getConfig(){const e={targetShape:this.targetShape},t=super.getConfig();return Object.assign(e,t),e}}zS.className="Reshape",Yd(zS);class BS extends Ww{constructor(e){if(super(e),null==e.dims)throw new Error("Required configuration field `dims` is missing during Permute constructor call.");if(!Array.isArray(e.dims))throw new Error("Permute constructor requires `dims` to be an Array, but received "+"".concat(e.dims," instead."));const t=Bv(1,e.dims.length+1);if(!xo(e.dims.slice().sort(),t))throw new Error("Invalid permutation `dims`: "+JSON.stringify(e.dims)+" `dims` must contain consecutive integers starting from 1.");this.dims=e.dims,this.dimsIncludingBatch=[0].concat(this.dims),this.inputSpec=[new Mw({ndim:this.dims.length+1})]}computeOutputShape(e){const t=(e=Rw(e)).slice();return this.dims.forEach(((n,a)=>{t[a+1]=e[n]})),t}call(e,t){return Hf(Ew(e),this.dimsIncludingBatch)}getConfig(){const e={dims:this.dims},t=super.getConfig();return Object.assign(e,t),e}}BS.className="Permute",Yd(BS);class WS extends Ww{constructor(e){super(null==e?{}:e),this.supportsMasking=!0,this.maskValue=null!=e?null==e.maskValue?0:e.maskValue:0}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),t={maskValue:this.maskValue};return Object.assign(t,e),t}computeMask(e,t){const n=Ew(e);return Vh(cf(n,this.maskValue),-1)}call(e,t){return Hu((()=>{this.invokeCallHook(e,t);const n=Ew(e),a=Vh(cf(n,this.maskValue),-1,!0);return Bd(n,Dd(a,n.dtype))}))}}WS.className="Masking",Yd(WS);class VS extends Ww{constructor(e){if(super(e),this.embeddings=null,this.DEFAULT_EMBEDDINGS_INITIALIZER="randomUniform",null==e.batchInputShape&&null==e.inputShape){let t=null;null!=e.batchSize&&(t=e.batchSize),null==e.inputLength?this.batchInputShape=[t,null]:this.batchInputShape=[t].concat(tv(e.inputLength))}this.inputDim=e.inputDim,pv(this.inputDim,"inputDim"),this.outputDim=e.outputDim,pv(this.outputDim,"outputDim"),this.embeddingsInitializer=Nw(e.embeddingsInitializer||this.DEFAULT_EMBEDDINGS_INITIALIZER),this.embeddingsRegularizer=GI(e.embeddingsRegularizer),this.activityRegularizer=GI(e.activityRegularizer),this.embeddingsConstraint=ok(e.embeddingsConstraint),this.maskZero=e.maskZero,this.supportsMasking=e.maskZero,this.inputLength=e.inputLength}build(e){this.embeddings=this.addWeight("embeddings",[this.inputDim,this.outputDim],this.dtype,this.embeddingsInitializer,this.embeddingsRegularizer,!0,this.embeddingsConstraint),this.built=!0}warnOnIncompatibleInputShape(e){}computeMask(e,t){return Hu((()=>this.maskZero?(e=Ew(e),cf(e,Ud(e))):null))}computeOutputShape(e){if(e=Rw(e),null==this.inputLength)return[...e,this.outputDim];const t=tv(this.inputLength);if(t.length!==e.length-1)throw new qx('"inputLength" is '.concat(this.inputLength,", but received ")+"input shape has shape ".concat(e));{let n=0;for(let a=0;a<t.length;++a){const r=t[a],o=e[a+1];if(null!=r&&null!=o&&r!==o)throw new qx('"inputLength" is '.concat(this.inputLength,", but received ")+"input shape has shape ".concat(e));null==r&&(t[n]=o),n++}}return[e[0],...t,this.outputDim]}call(e,t){return Hu((()=>{this.invokeCallHook(e,t);let n=Ew(e);"int32"!==n.dtype&&(n=Uv(n,"int32"));const a=Zv(this.embeddings.read(),rp(n,[n.size]));return rp(a,Rw(this.computeOutputShape(n.shape)))}))}getConfig(){const e={inputDim:this.inputDim,outputDim:this.outputDim,embeddingsInitializer:Sw(this.embeddingsInitializer),embeddingsRegularizer:VI(this.embeddingsRegularizer),activityRegularizer:VI(this.activityRegularizer),embeddingsConstraint:ak(this.embeddingsConstraint),maskZero:this.maskZero,inputLength:this.inputLength},t=super.getConfig();return Object.assign(e,t),e}}VS.className="Embedding",Yd(VS);class US extends Ww{constructor(e){super(e||{}),this.supportsMasking=!0}mergeFunction(e){throw new Xx}computeElementwiseOpOutputShape(e,t){if(null==e||null==t)return null;if(e.length<t.length)return this.computeElementwiseOpOutputShape(t,e);if(0===t.length)return e;const n=e.slice(0,e.length-t.length);for(let a=0;a<t.length;++a){const r=e[e.length-t.length+a],o=t[a];if(null==r||null==o||r<0||o<0)n.push(null);else if(1===r)n.push(o);else if(1===o)n.push(r);else{if(r!==o)throw new qx("Operands could not be broadcast together with shapes "+JSON.stringify(e)+" "+JSON.stringify(t));n.push(r)}}return n}build(e){if(Array.isArray(e)&&!Array.isArray(e[0])&&(e=[Rw(e)]),e.length<2)throw new qx("A merge layer should be called on an Array of at least 2 inputs."+" Got ".concat(e.length," input(s)."));let t=[];for(const r of e)null!=r&&null!==r[0]&&t.push(r[0]);if(t=lv(t),t.length>1)throw new qx("Can not merge tensors with different batch sizes. "+"Got tensors with shapes: ".concat(JSON.stringify(e),"."));let n=null==e[0]?null:e[0].slice(1);for(let r=1;r<e.length;++r){const t=null==e[r]?null:e[r].slice(1);n=this.computeElementwiseOpOutputShape(n,t)}const a=e.map((e=>e.length));-1===e.indexOf(null)&&1===lv(a).length?this.reshapeRequired=!1:this.reshapeRequired=!0}call(e,t){return Hu((()=>{if(this.reshapeRequired){const t=[],n=e.map((e=>e.rank));if(-1===n.indexOf(null)){const a=zv(n);for(let n of e){const e=n.rank;for(let t=0;t<a-e;++t)n=Gv(n,1);t.push(n)}return this.mergeFunction(t)}{let n=!1;for(const o of e){const e=o.rank;if(null==e){const e=o.shape,a=e[0],r=e.slice(1).concat([a]);let s=rp(o,[a].concat(Lv(e.slice(1))));s=Hf(s,[1,0]),s=rp(s,r),t.push(s),n=!0}else if(e>1){const a=Bv(1,e).concat([0]);t.push(Hf(o,a)),n=!0}else t.push(o)}let a=this.mergeFunction(t);const r=a.rank;if(n)if(null==r){const e=a.shape,t=e[e.length-1],n=[t].concat(e.slice(0,e.length-1));a=rp(Hf(rp(a,[-1,t]),[1,0]),n)}else if(r>1){const e=[r-1].concat(Bv(0,r-1));a=Hf(a,e)}return a}}return this.mergeFunction(e)}))}computeOutputShape(e){let t;t=null==e[0]?null:e[0].slice(1);for(let a=1;a<e.length;++a){const n=null==e[a]?null:e[a].slice(1);t=this.computeElementwiseOpOutputShape(t,n)}let n=[];for(const a of e)null!=a&&null!==a[0]&&n.push(a[0]);return n=lv(n),t=1===n.length?n.concat(t):[null].concat(t),t}computeMask(e,t){return Hu((()=>{if(null==t)return null;if(!Array.isArray(t))throw new qx("`mask` should be an Array");if(!Array.isArray(e))throw new qx("`inputs` should be an Array");if(t.length!==e.length)throw new qx("The Array 'inputs' and 'mask' are expected to have the same length, but have different lengths "+"(".concat(e.length," vs ").concat(t.length,")"));if(t.every((e=>null==e)))return null;t=t.map((e=>null==e?e:_p(e,0)));let n=t[0];for(let e=1;e<t.length-1;++e)n=Zp(n,t[e]);return n}))}}class GS extends US{constructor(e){super(e)}mergeFunction(e){return Hu((()=>{let t=e[0].clone();for(let n=1;n<e.length;++n)t=Ld(t,e[n]);return t}))}}GS.className="Add",Yd(GS);class HS extends US{constructor(e){super(e)}mergeFunction(e){return Hu((()=>{let t=e[0].clone();for(let n=1;n<e.length;++n)t=Bd(t,e[n]);return t}))}}HS.className="Multiply",Yd(HS);class jS extends US{constructor(e){super(e)}mergeFunction(e){return Hu((()=>{let t=e[0].clone();for(let n=1;n<e.length;++n)t=Ld(t,e[n]);return Bd(1/e.length,t)}))}}jS.className="Average",Yd(jS);class KS extends US{constructor(e){super(e)}mergeFunction(e){return Hu((()=>{let t=e[0];for(let n=1;n<e.length;++n)t=ih(t,e[n]);return t}))}}KS.className="Maximum",Yd(KS);class qS extends US{constructor(e){super(e)}mergeFunction(e){return Hu((()=>{let t=e[0];for(let n=1;n<e.length;++n)t=rf(t,e[n]);return t}))}}qS.className="Minimum",Yd(qS);class XS extends US{constructor(e){super(e),this.DEFAULT_AXIS=-1,null==e&&(e={}),this.axis=null==e.axis?this.DEFAULT_AXIS:e.axis,this.supportsMasking=!0,this.reshapeRequired=!1}build(e){if(!Array.isArray(e)||!Array.isArray(e[0])||1===e.length)throw new qx("A `Concatenate` layer should be called on a list of at least 2 inputs");let t=!0;for(const a of e)if(null!=a){t=!1;break}if(t)return;const n=[];for(let a=0;a<e.length;++a){const t=e[a].slice();t.splice(this.axis,1);let r=!1;for(const e of n)if(xo(e,t)){r=!0;break}r||n.push(t)}if(n.length>1)throw new qx("A `Concatenate` layer requires inputs with matching shapes except for the concat axis. Got input shapes: "+JSON.stringify(e))}mergeFunction(e){return Hu((()=>qv(e,this.axis)))}computeOutputShape(e){if(!Array.isArray(e)||!Array.isArray(e[0]))throw new qx("A `Concatenate` layer should be called on a list of inputs.");const t=e,n=t[0].slice(),a=this.axis<0?n.length+this.axis:this.axis;for(const r of t.slice(1)){if(null==n[a]||null==r[a]){n[a]=null;break}n[a]+=r[a]}return n}computeMask(e,t){if(null==t)return null;if(!Array.isArray(t))throw new qx("`mask` should be an array for Concatenate");if(!Array.isArray(e))throw new qx("`inputs` should be an array for Concatenate");if(t.length!==e.length)throw new qx("Mismatch in the length of mask (".concat(t.length,") ")+"and the legnth of inputs (".concat(e.length,")"));return Hu((()=>{let n=!0;if(t.forEach((e=>{null==e||(n=!1)})),n)return null;const a=[];for(let o=0;o<e.length;++o)null==t[o]?a.push(Dd(hf(e[o]),"bool")):t[o].rank<e[o].rank?a.push(_p(t[o],-1)):a.push(t[o]);const r=pp(a,this.axis);return Wh(r,-1,!1)}))}getConfig(){const e={axis:this.axis},t=super.getConfig();return Object.assign(e,t),e}}function YS(e,t){for(;e<0;)e+=t;return e}XS.className="Concatenate",Yd(XS);class QS extends US{constructor(e){super(e),this.axes=e.axes,this.normalize=null!=e.normalize&&e.normalize,this.supportsMasking=!0,this.reshapeRequired=!1}build(e){mo(Array.isArray(e)&&2===e.length&&Array.isArray(e[0])&&Array.isArray(e[1]),(()=>"A `Dot` layer should be called on a list of exactly 2 inputs."));const t=e[0],n=e[1];if(t.length>3||n.length>3)throw new Xx("Dot layer does not support tensors of 4D or higher rank yet.");const a=this.interpretAxes(t,n);if(t[a[0]]!==n[a[1]])throw new qx("Dimension incompatibility: "+"".concat(t[a[0]]," !== ").concat(n[a[1]]))}mergeFunction(e){if(2!==e.length)throw new qx("A `Dot` layer must be called on exactly 2 inputs, "+"but received ".concat(e.length," input(s)."));let t,n=e[0],a=e[1];return t=Array.isArray(this.axes)?this.axes.map(((t,n)=>YS(t,e[n].shape.length))):[YS(this.axes,n.shape.length),YS(this.axes,a.shape.length)],this.normalize&&(n=yk(n,t[0]),a=yk(a,t[1])),function(e,t,n){if(e.shape.length>3||t.shape.length>3)throw new Xx("batchDot is not implemented for tensors of 4D or higher rank yet");if(mo(e.shape.length>=2,(()=>"batchDot requires the rank of x to be >= 2, "+"but got ".concat(e.shape.length))),mo(e.shape.length>=2,(()=>"batchDot requires the rank of y to be >= 2, "+"but got ".concat(t.shape.length))),"number"===typeof n&&(n=[n,n]),"complex64"===e.dtype||"complex64"===t.dtype)throw new Xx("batchDot is not implemented for complex64-type Tensors yet.");const a=e.shape.length,r=t.shape.length;null==n&&(n=[a-1,r-2]);const o=n;return Hu((()=>{let n,s;if(a>r){n=a-r;const e=[];for(let t=0;t<n;++t)e.push(1);t=rp(t,t.shape.concat(e))}else if(r>a){n=r-a;const t=[];for(let e=0;e<n;++e)t.push(1);e=rp(e,e.shape.concat(t))}else n=0;if(2===e.shape.length&&2===t.shape.length)s=o[0]===o[1]?Vp(Bd(e,t),o[0]):Vp(Bd(Hf(e,[1,0]),t),o[1]);else{const n=o[0]!==e.shape.length-1,a=o[1]===t.shape.length-1;s=$p(e,t,n,a)}if(n>0){let e;e=a>r?a+r-3:a-1;const t=[];for(let a=e;a<e+n;++a)t.push(a);s=Df(s,t)}return 1===s.shape.length&&(s=_p(s,1)),s}))}(n,a,t)}interpretAxes(e,t){let n;return n=Array.isArray(this.axes)?this.axes:[YS(this.axes,e.length),YS(this.axes,t.length)],n}computeOutputShape(e){mo(Array.isArray(e)&&2===e.length&&Array.isArray(e[0])&&Array.isArray(e[1]),(()=>"A `Dot` layer should be called on a list of exactly 2 inputs."));const t=e[0].slice(),n=e[1].slice();if(t.length>3||n.length>3)throw new Xx("Dot layer does not support tensors of 4D or higher rank yet.");const a=this.interpretAxes(t,n);t.splice(a[0],1),n.splice(a[1],1),n.splice(0,1);const r=t.concat(n);return 1===r.length&&r.push(1),r}computeMask(e,t){return null}getConfig(){const e={axes:this.axes,normalize:this.normalize},t=super.getConfig();return Object.assign(e,t),e}}QS.className="Dot",Yd(QS);class JS extends Ww{constructor(e){super(e),this.supportsMasking=!0,this.stddev=e.stddev}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),t={stddev:this.stddev};return Object.assign(t,e),t}call(e,t){return Hu((()=>{this.invokeCallHook(e,t);const n=Ew(e);return aw((()=>Ld(Qv(n.shape,0,this.stddev),n)),(()=>n),t.training||!1)}))}}JS.className="GaussianNoise",Yd(JS);class ZS extends Ww{constructor(e){super(e),this.supportsMasking=!0,this.rate=e.rate}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),t={rate:this.rate};return Object.assign(t,e),t}call(e,t){return Hu((()=>{this.invokeCallHook(e,t);const n=Ew(e);if(this.rate>0&&this.rate<1){return aw((()=>{const e=Math.sqrt(this.rate/(1-this.rate));return Bd(n,Qv(n.shape,1,e))}),(()=>n),t.training||!1)}return n}))}}ZS.className="GaussianDropout",Yd(ZS);class $S extends Ww{constructor(e){super(e),this.supportsMasking=!0,this.rate=e.rate,this.noiseShape=e.noiseShape}_getNoiseShape(e){return this.noiseShape||Ew(e).shape}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),t={rate:this.rate};return Object.assign(t,e),t}call(e,t){return Hu((()=>{if(this.rate<1&&this.rate>0){const n=this._getNoiseShape(e),a=()=>{const t=Ew(e),a=-1.7580993408473766;let r=Lp(xf(n),this.rate);r=Uv(r,"float32");const o=((1-this.rate)*(1+this.rate*a**2))**-.5,s=-o*a*this.rate,i=Ld(Bd(t,r),Bd(Ld(r,-1),a));return Ld(Bd(i,o),s)};return aw(a,(()=>Ew(e)),t.training||!1)}return e}))}}function eN(e,t,n,a,r){let o,s=arguments.length>5&&void 0!==arguments[5]?arguments[5]:.001;if(2===e.rank)o=cp(e,t,n,a,r,s);else if(3===e.rank)o=lp(e,t,n,a,r,s);else{if(4!==e.rank)throw new Xx("batchNormalization is not implemented for array of rank ".concat(e.rank," ")+"yet");o=up(e,t,n,a,r,s)}return o}function tN(e,t,n,a){let r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:.001;return xo(a.slice().sort(),Bv(0,e.rank-1))?function(e,t,n,a){let r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:.001;return Hu((()=>{const o=of(e,a),s=o.mean,i=o.variance;return[eN(e,s,i,n,t,r),s,i]}))}(e,t,n,a,r):function(e,t,n,a){let r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:.001;return Hu((()=>{const o=of(e,a),s=o.mean,i=o.variance,c=[];for(const t of Bv(0,e.rank))-1!==a.indexOf(t)?c.push(1):c.push(e.shape[t]);const l=rp(s,c),u=rp(i,c),d=null==t?null:rp(t,c),h=null==n?null:rp(n,c);return[eN(e,l,u,h,d,r),s,i]}))}(e,t,n,a,r)}$S.className="AlphaDropout",Yd($S);class nN extends Ww{constructor(e){null==e&&(e={}),super(e),this.supportsMasking=!0,this.axis=null==e.axis?-1:e.axis,this.momentum=null==e.momentum?.99:e.momentum,this.epsilon=null==e.epsilon?.001:e.epsilon,this.center=null==e.center||e.center,this.scale=null==e.scale||e.scale,this.betaInitializer=Nw(e.betaInitializer||"zeros"),this.gammaInitializer=Nw(e.gammaInitializer||"ones"),this.movingMeanInitializer=Nw(e.movingMeanInitializer||"zeros"),this.movingVarianceInitializer=Nw(e.movingVarianceInitializer||"ones"),this.betaConstraint=ok(e.betaConstraint),this.gammaConstraint=ok(e.gammaConstraint),this.betaRegularizer=GI(e.betaRegularizer),this.gammaRegularizer=GI(e.gammaRegularizer)}build(e){e=Rw(e);const t=this.axis>=0?this.axis:this.axis+e.length,n=e[t];if(null==n)throw new qx("Axis ".concat(t," of input tensor should have a defined dimension but ")+"the layer received an input with shape "+"".concat(JSON.stringify(e),"."));this.inputSpec=[new Mw({ndim:e.length,axes:{[t]:n}})];const a=[n];this.scale&&(this.gamma=this.addWeight("gamma",a,null,this.gammaInitializer,this.gammaRegularizer,!0,this.gammaConstraint)),this.center&&(this.beta=this.addWeight("beta",a,null,this.betaInitializer,this.betaRegularizer,!0,this.betaConstraint)),this.movingMean=this.addWeight("moving_mean",a,null,this.movingMeanInitializer,null,!1),this.movingVariance=this.addWeight("moving_variance",a,null,this.movingVarianceInitializer,null,!1),this.built=!0}call(e,t){return Hu((()=>{const n=null!=t.training&&t.training,a=Ew(e),r=a.shape,o=r.length,s=Bv(0,o),i=this.axis>=0?this.axis:this.axis+o;s.splice(i,1);const c=Jx(1,o);c[i]=r[i];const l=s.slice();l.sort();const u=!xo(l,Bv(0,o).slice(0,o-1));if(!n)return(()=>{if(u){const e=rp(this.movingMean.read(),c),t=rp(this.movingVariance.read(),c),n=this.center?rp(this.beta.read(),c):null,r=this.scale?rp(this.gamma.read(),c):null;return eN(a,e,t,n,r,this.epsilon)}return eN(a,this.movingMean.read(),this.movingVariance.read(),null==this.beta?null:this.beta.read(),null==this.gamma?null:this.gamma.read(),this.epsilon)})();const[d,h,p]=tN(a,this.gamma.read(),this.beta.read(),s,this.epsilon),f=(e,t,n)=>{Hu((()=>{const a=1-n,r=e.read(),o=Bd(th(r,t),a);e.write(th(r,o))}))};return(()=>{f(this.movingMean,h,this.momentum),f(this.movingVariance,p,this.momentum)})(),d}))}getConfig(){const e={axis:this.axis,momentum:this.momentum,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:Sw(this.betaInitializer),gammaInitializer:Sw(this.gammaInitializer),movingMeanInitializer:Sw(this.movingMeanInitializer),movingVarianceInitializer:Sw(this.movingVarianceInitializer),betaRegularizer:VI(this.betaRegularizer),gammaRegularizer:VI(this.gammaRegularizer),betaConstraint:ak(this.betaConstraint),gammaConstraint:ak(this.gammaConstraint)},t=super.getConfig();return Object.assign(e,t),e}}nN.className="BatchNormalization",Yd(nN);class aN extends Ww{constructor(e){if(null==e&&(e={}),super(e),this.axis=null==e.axis?-1:e.axis,"number"===typeof this.axis){if(!Number.isInteger(this.axis))throw new Error("Expected axis to be an integer, but received ".concat(this.axis))}else{if(!Array.isArray(this.axis))throw new Error("Expected axis to be an integer or an array of integers, "+"but received ".concat(JSON.stringify(this.axis)));for(const e of this.axis)if(!Number.isInteger(e))throw new Error("Expected axis to be an array of integers, "+"but received ".concat(JSON.stringify(this.axis)))}this.epsilon=null==e.epsilon?.001:e.epsilon,this.center=null==e.center||e.center,this.scale=null==e.scale||e.scale,this.betaInitializer=Nw(e.betaInitializer||"zeros"),this.gammaInitializer=Nw(e.gammaInitializer||"ones"),this.betaRegularizer=GI(e.betaRegularizer),this.gammaRegularizer=GI(e.gammaRegularizer),this.supportsMasking=!0}build(e){const t=(e=Rw(e)).length;"number"===typeof this.axis&&(this.axis=[this.axis]);for(let r=0;r<this.axis.length;++r)this.axis[r]<0&&(this.axis[r]+=t);for(const r of this.axis)if(r<0||r>=t)throw new Error("Invalid axis: ".concat(r));if(this.axis.length!==lv(this.axis).length)throw new Error("Found duplicate axes in: ".concat(this.axis));const n=this.axis.map((t=>e[t])),a=!0;this.scale?this.gamma=this.addWeight("gamma",n,"float32",this.gammaInitializer,this.gammaRegularizer,a):this.gamma=null,this.center?this.beta=this.addWeight("beta",n,"float32",this.betaInitializer,this.betaRegularizer,a):this.beta=null,this.built=!0}call(e,t){const n=Ew(e),a=n.shape,r=a.length;return Hu((()=>{let{mean:e,variance:t}=of(n,this.axis,!0);const o=Jx(1,r);for(const n of this.axis)o[n]=a[n];const s=e=>null!=e&&e.shape.length!==r?rp(e,o):e;let i=this.scale?s(this.gamma.read()):null,c=this.center?s(this.beta.read()):null;const l=[],u=[];for(let n=0;n<r;++n)-1!==this.axis.indexOf(n)?(l.push(a[n]),u.push(1)):(l.push(1),u.push(a[n]));return e=Ap(e,l),t=Ap(t,l),null!=i&&(i=Ap(i,u)),null!=c&&(c=Ap(c,u)),eN(n,e,t,c,i,this.epsilon)}))}getConfig(){const e={axis:this.axis,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:Sw(this.betaInitializer),gammaInitializer:Sw(this.gammaInitializer),betaRegularizer:VI(this.betaRegularizer),gammaRegularizer:VI(this.gammaRegularizer)},t=super.getConfig();return Object.assign(e,t),e}}aN.className="LayerNormalization",Yd(aN);class rN extends Ww{constructor(e){if(null==e&&(e={}),super(e),this.dataFormat=null==e.dataFormat?"channelsLast":e.dataFormat,null==e.padding)this.padding=[[1,1],[1,1]];else if("number"===typeof e.padding)this.padding=[[e.padding,e.padding],[e.padding,e.padding]];else{if(e.padding=e.padding,2!==e.padding.length)throw new qx("ZeroPadding2D expects padding to be a length-2 array, but "+"received a length-".concat(e.padding.length," array."));let t,n;if("number"===typeof e.padding[0])t=[e.padding[0],e.padding[0]],n=[e.padding[1],e.padding[1]];else{if(e.padding=e.padding,2!==e.padding[0].length)throw new qx("ZeroPadding2D expects height padding to be a length-2 array, "+"but received a length-".concat(e.padding[0].length," array."));if(t=e.padding[0],2!==e.padding[1].length)throw new qx("ZeroPadding2D expects width padding to be a length-2 array, "+"but received a length-".concat(e.padding[1].length," array."));n=e.padding[1]}this.padding=[t,n]}this.inputSpec=[new Mw({ndim:4})]}computeOutputShape(e){let t,n;return e=Rw(e),"channelsFirst"===this.dataFormat?(t=null!=e[2]&&e[2]>=0?e[2]+this.padding[0][0]+this.padding[0][1]:null,n=null!=e[3]&&e[3]>=0?e[3]+this.padding[1][0]+this.padding[1][1]:null,[e[0],e[1],t,n]):(t=null!=e[1]&&e[1]>=0?e[1]+this.padding[0][0]+this.padding[0][1]:null,n=null!=e[2]&&e[2]>=0?e[2]+this.padding[1][0]+this.padding[1][1]:null,[e[0],t,n,e[3]])}call(e,t){return Hu((()=>{return t=Ew(e),n=this.padding,a=this.dataFormat,Hu((()=>{if(4!==t.rank)throw new qx("temporalPadding expects input tensor to be 4-D, but received a "+"".concat(t.rank,"-D tensor."));if(null==n&&(n=[[1,1],[1,1]]),2!==n.length||2!==n[0].length||2!==n[1].length)throw new qx("spatial2dPadding expects `padding` to be an Array of two Arrays, each of which is an Array of two integers.");if(null==a&&(a="channelsLast"),"channelsLast"!==a&&"channelsFirst"!==a)throw new qx("Unknown data format: ".concat(a,". ")+"Supported data formats are 'channelsLast' and 'channelsFirst.");let e;return e="channelsFirst"===a?[[0,0],[0,0],n[0],n[1]]:[[0,0],n[0],n[1],[0,0]],pf(t,e)}));var t,n,a}))}getConfig(){const e={padding:this.padding,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}}function oN(e,t,n,a,r,o){return Hu((()=>{let s;Cv(r),Ev(o),Tv(a),null==n&&(n=[1,1]),null==a&&(a="valid"),null==r&&(r="channelsLast"),null==o&&(o="max"),e=$I(e,r);const i="same"===a?"same":"valid";return s="max"===o?ef(e,t,n,i):op(e,t,n,i),"channelsFirst"===r&&(s=Hf(s,[0,3,1,2])),s}))}function sN(e,t,n,a,r,o){return Hu((()=>{let s;Cv(r),Ev(o),Tv(a),null==n&&(n=[1,1,1]),null==a&&(a="valid"),null==r&&(r="channelsLast"),null==o&&(o="max"),e=eS(e,r);const i="same"===a?"same":"valid";return s="max"===o?tf(e,t,n,i):sp(e,t,n,i),"channelsFirst"===r&&(s=Hf(s,[0,4,1,2,3])),s}))}rN.className="ZeroPadding2D",Yd(rN);class iN extends Ww{constructor(e){if(null==e.poolSize&&(e.poolSize=2),super(e),"number"===typeof e.poolSize)this.poolSize=[e.poolSize];else{if(!Array.isArray(e.poolSize)||1!==e.poolSize.length||"number"!==typeof e.poolSize[0])throw new qx("poolSize for 1D convolutional layer must be a number or an Array of a single number, but received "+"".concat(JSON.stringify(e.poolSize)));this.poolSize=e.poolSize}if(pv(this.poolSize,"poolSize"),null==e.strides)this.strides=this.poolSize;else if("number"===typeof e.strides)this.strides=[e.strides];else{if(!Array.isArray(e.strides)||1!==e.strides.length||"number"!==typeof e.strides[0])throw new qx("strides for 1D convolutional layer must be a number or an Array of a single number, but received "+"".concat(JSON.stringify(e.strides)));this.strides=e.strides}pv(this.strides,"strides"),this.padding=null==e.padding?"valid":e.padding,Tv(this.padding),this.inputSpec=[new Mw({ndim:3})]}computeOutputShape(e){const t=JI((e=Rw(e))[1],this.poolSize[0],this.padding,this.strides[0]);return[e[0],t,e[2]]}call(e,t){return Hu((()=>{this.invokeCallHook(e,t),e=Gv(Ew(e),2);const n=this.poolingFunction(Ew(e),[this.poolSize[0],1],[this.strides[0],1],this.padding,"channelsLast");return Df(n,[2])}))}getConfig(){const e={poolSize:this.poolSize,padding:this.padding,strides:this.strides},t=super.getConfig();return Object.assign(e,t),e}}class cN extends iN{constructor(e){super(e)}poolingFunction(e,t,n,a,r){return Cv(r),Tv(a),oN(e,t,n,a,r,"max")}}cN.className="MaxPooling1D",Yd(cN);class lN extends iN{constructor(e){super(e)}poolingFunction(e,t,n,a,r){return Cv(r),Tv(a),oN(e,t,n,a,r,"avg")}}lN.className="AveragePooling1D",Yd(lN);class uN extends Ww{constructor(e){if(null==e.poolSize&&(e.poolSize=[2,2]),super(e),this.poolSize=Array.isArray(e.poolSize)?e.poolSize:[e.poolSize,e.poolSize],null==e.strides)this.strides=this.poolSize;else if(Array.isArray(e.strides)){if(2!==e.strides.length)throw new qx("If the strides property of a 2D pooling layer is an Array, it is expected to have a length of 2, but received length "+"".concat(e.strides.length,"."));this.strides=e.strides}else this.strides=[e.strides,e.strides];pv(this.poolSize,"poolSize"),pv(this.strides,"strides"),this.padding=null==e.padding?"valid":e.padding,this.dataFormat=null==e.dataFormat?"channelsLast":e.dataFormat,Cv(this.dataFormat),Tv(this.padding),this.inputSpec=[new Mw({ndim:4})]}computeOutputShape(e){e=Rw(e);let t="channelsFirst"===this.dataFormat?e[2]:e[1],n="channelsFirst"===this.dataFormat?e[3]:e[2];return t=JI(t,this.poolSize[0],this.padding,this.strides[0]),n=JI(n,this.poolSize[1],this.padding,this.strides[1]),"channelsFirst"===this.dataFormat?[e[0],e[1],t,n]:[e[0],t,n,e[3]]}call(e,t){return Hu((()=>(this.invokeCallHook(e,t),this.poolingFunction(Ew(e),this.poolSize,this.strides,this.padding,this.dataFormat))))}getConfig(){const e={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}}class dN extends uN{constructor(e){super(e)}poolingFunction(e,t,n,a,r){return Cv(r),Tv(a),oN(e,t,n,a,r,"max")}}dN.className="MaxPooling2D",Yd(dN);class hN extends uN{constructor(e){super(e)}poolingFunction(e,t,n,a,r){return Cv(r),Tv(a),oN(e,t,n,a,r,"avg")}}hN.className="AveragePooling2D",Yd(hN);class pN extends Ww{constructor(e){if(null==e.poolSize&&(e.poolSize=[2,2,2]),super(e),this.poolSize=Array.isArray(e.poolSize)?e.poolSize:[e.poolSize,e.poolSize,e.poolSize],null==e.strides)this.strides=this.poolSize;else if(Array.isArray(e.strides)){if(3!==e.strides.length)throw new qx("If the strides property of a 3D pooling layer is an Array, it is expected to have a length of 3, but received length "+"".concat(e.strides.length,"."));this.strides=e.strides}else this.strides=[e.strides,e.strides,e.strides];pv(this.poolSize,"poolSize"),pv(this.strides,"strides"),this.padding=null==e.padding?"valid":e.padding,this.dataFormat=null==e.dataFormat?"channelsLast":e.dataFormat,Cv(this.dataFormat),Tv(this.padding),this.inputSpec=[new Mw({ndim:5})]}computeOutputShape(e){e=Rw(e);let t="channelsFirst"===this.dataFormat?e[2]:e[1],n="channelsFirst"===this.dataFormat?e[3]:e[2],a="channelsFirst"===this.dataFormat?e[4]:e[3];return t=JI(t,this.poolSize[0],this.padding,this.strides[0]),n=JI(n,this.poolSize[1],this.padding,this.strides[1]),a=JI(a,this.poolSize[2],this.padding,this.strides[2]),"channelsFirst"===this.dataFormat?[e[0],e[1],t,n,a]:[e[0],t,n,a,e[4]]}call(e,t){return Hu((()=>(this.invokeCallHook(e,t),this.poolingFunction(Ew(e),this.poolSize,this.strides,this.padding,this.dataFormat))))}getConfig(){const e={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}}class fN extends pN{constructor(e){super(e)}poolingFunction(e,t,n,a,r){return Cv(r),Tv(a),sN(e,t,n,a,r,"max")}}fN.className="MaxPooling3D",Yd(fN);class mN extends pN{constructor(e){super(e)}poolingFunction(e,t,n,a,r){return Cv(r),Tv(a),sN(e,t,n,a,r,"avg")}}mN.className="AveragePooling3D",Yd(mN);class gN extends Ww{constructor(e){super(e),this.inputSpec=[new Mw({ndim:3})]}computeOutputShape(e){return[e[0],e[2]]}call(e,t){throw new Xx}}class bN extends gN{constructor(e){super(e||{})}call(e,t){return Hu((()=>{const t=Ew(e);return nf(t,1)}))}}bN.className="GlobalAveragePooling1D",Yd(bN);class yN extends gN{constructor(e){super(e||{})}call(e,t){return Hu((()=>{const t=Ew(e);return Wp(t,1)}))}}yN.className="GlobalMaxPooling1D",Yd(yN);class xN extends Ww{constructor(e){super(e),this.dataFormat=null==e.dataFormat?"channelsLast":e.dataFormat,Cv(this.dataFormat),this.inputSpec=[new Mw({ndim:4})]}computeOutputShape(e){return"channelsLast"===this.dataFormat?[e[0],e[3]]:[e[0],e[1]]}call(e,t){throw new Xx}getConfig(){const e={dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}}class vN extends xN{call(e,t){return Hu((()=>{const t=Ew(e);return"channelsLast"===this.dataFormat?nf(t,[1,2]):nf(t,[2,3])}))}}vN.className="GlobalAveragePooling2D",Yd(vN);class wN extends xN{call(e,t){return Hu((()=>{const t=Ew(e);return"channelsLast"===this.dataFormat?Wp(t,[1,2]):Wp(t,[2,3])}))}}wN.className="GlobalMaxPooling2D",Yd(wN);class kN extends Ww{constructor(e){super(e),this.layer=e.layer}build(e){this.built=!0}get trainable(){return null!=this.layer&&this.layer.trainable}set trainable(e){null!=this.layer&&(this.layer.trainable=e)}get trainableWeights(){return this.layer.trainableWeights}get nonTrainableWeights(){return this.layer.nonTrainableWeights}get updates(){return this.layer._updates}get losses(){return this.layer.losses}getWeights(){return this.layer.getWeights()}setWeights(e){this.layer.setWeights(e)}getConfig(){const e={layer:{className:this.layer.getClassName(),config:this.layer.getConfig()}},t=super.getConfig();return Object.assign(e,t),e}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),null!=this.layer&&this.layer.setFastWeightInitDuringBuild(e)}static fromConfig(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};const a=bk(t.layer,n);delete t.layer;const r={layer:a};return Object.assign(r,t),new e(r)}}class IN extends kN{constructor(e){super(e),this.supportsMasking=!0}build(e){if((e=Rw(e)).length<3)throw new qx("TimeDistributed layer expects an input shape >= 3D, but received "+"input shape ".concat(JSON.stringify(e)));this.inputSpec=[{shape:e}];const t=[e[0]].concat(e.slice(2));this.layer.built||(this.layer.build(t),this.layer.built=!0),super.build(e)}computeOutputShape(e){const t=[(e=Rw(e))[0]].concat(e.slice(2)),n=this.layer.computeOutputShape(t),a=e[1];return[n[0],a].concat(n.slice(1))}call(e,t){return Hu((()=>bS(((e,n)=>[Ew(this.layer.call(e,t)),[]]),e=Ew(e),[],!1,null,null,!1,!0)[1]))}}IN.className="TimeDistributed",Yd(IN);class SN extends kN{constructor(e){super(e);const t=e.layer.getConfig(),n={};n.className=e.layer.getClassName(),n.config=t,this.forwardLayer=bk(n),t.goBackwards=!0!==t.goBackwards;const a={};var r;if(a.className=e.layer.getClassName(),a.config=t,this.backwardLayer=bk(a),this.forwardLayer.name="forward_"+this.forwardLayer.name,this.backwardLayer.name="backward_"+this.backwardLayer.name,this.mergeMode=void 0===e.mergeMode?"concat":e.mergeMode,r=this.mergeMode,dv(Sv,"BidirectionalMergeMode",r),e.weights)throw new Xx("weights support is not implemented for Bidirectional layer yet.");this._stateful=e.layer.stateful,this.returnSequences=e.layer.returnSequences,this.returnState=e.layer.returnState,this.supportsMasking=!0,this._trainable=!0,this.inputSpec=e.layer.inputSpec,this.numConstants=null}get trainable(){return this._trainable}set trainable(e){this._trainable=e,null!=this.forwardLayer&&(this.forwardLayer.trainable=e),null!=this.backwardLayer&&(this.backwardLayer.trainable=e)}getWeights(){return this.forwardLayer.getWeights().concat(this.backwardLayer.getWeights())}setWeights(e){const t=e.length,n=Math.floor(t/2);this.forwardLayer.setWeights(e.slice(0,n)),this.backwardLayer.setWeights(e.slice(n))}computeOutputShape(e){let t,n,a,r=this.forwardLayer.computeOutputShape(e);return Array.isArray(r)&&Array.isArray(r[0])||(r=[r]),this.returnState?(a=r.slice(1),t=r[0]):t=r[0],"concat"===this.mergeMode?(t[t.length-1]*=2,n=[t]):n=null==this.mergeMode?[t,t.slice()]:[t],this.returnState?null==this.mergeMode?n.concat(a).concat(a.slice()):[t].concat(a).concat(a.slice()):ev(n)}apply(e,t){let n=null==t?null:t.initialState,a=null==t?null:t.constants;null==t&&(t={});const r=gS(e,n,a,this.numConstants);if(e=r.inputs,n=r.initialState,a=r.constants,Array.isArray(e)&&(n=e.slice(1),e=e[0]),(null==n||0===n.length)&&null==a)return super.apply(e,t);const o=[],s=[];if(null!=n){const e=n.length;if(e%2>0)throw new qx("When passing `initialState` to a Bidrectional RNN, the state should be an Array containing the states of the underlying RNNs.");t.initialState=n,o.push(...n);const a=n.map((e=>new Mw({shape:e.shape})));this.forwardLayer.stateSpec=a.slice(0,e/2),this.backwardLayer.stateSpec=a.slice(e/2),s.push(...a)}if(null!=a)throw new Xx("Support for constants in Bidirectional layers is not implemented yet.");const i=o[0]instanceof Lw;for(const c of o)if(c instanceof Lw!==i)throw new qx("The initial state of a Bidirectional layer cannot be specified as a mix of symbolic and non-symbolic tensors");if(i){const n=[e].concat(o),a=this.inputSpec.concat(s),r=this.inputSpec;this.inputSpec=a;const i=super.apply(n,t);return this.inputSpec=r,i}return super.apply(e,t)}call(e,t){return Hu((()=>{const n=t.initialState;let a,r,o,s;if(null==n)a=this.forwardLayer.call(e,t),r=this.backwardLayer.call(e,t);else{const o=n.slice(0,n.length/2),s=n.slice(n.length/2);a=this.forwardLayer.call(e,Object.assign(t,{initialState:o})),r=this.backwardLayer.call(e,Object.assign(t,{initialState:s}))}return this.returnState&&(Array.isArray(a)&&(o=a.slice(1).concat(r.slice(1))),a=a[0],r=r[0]),this.returnSequences&&(r=kf(r,1)),"concat"===this.mergeMode?s=qv([a,r]):"sum"===this.mergeMode?s=Ld(a,r):"ave"===this.mergeMode?s=Bd(.5,Ld(a,r)):"mul"===this.mergeMode?s=Bd(a,r):null==this.mergeMode&&(s=[a,r]),this.returnState?null==this.mergeMode?s.concat(o):[s].concat(o):s}))}resetStates(e){this.forwardLayer.resetStates(),this.backwardLayer.resetStates()}build(e){Av(this.forwardLayer.name,(()=>{this.forwardLayer.build(e)})),Av(this.backwardLayer.name,(()=>{this.backwardLayer.build(e)})),this.built=!0}computeMask(e,t){let n;if(Array.isArray(t)&&(t=t[0]),n=this.returnSequences?null==this.mergeMode?[t,t]:t:null==this.mergeMode?[null,null]:null,this.returnState){const e=this.forwardLayer.states.map((e=>null));return Array.isArray(n)?n.concat(e).concat(e):[n].concat(e).concat(e)}return n}get trainableWeights(){return this.forwardLayer.trainableWeights.concat(this.backwardLayer.trainableWeights)}get nonTrainableWeights(){return this.forwardLayer.nonTrainableWeights.concat(this.backwardLayer.nonTrainableWeights)}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),null!=this.forwardLayer&&this.forwardLayer.setFastWeightInitDuringBuild(e),null!=this.backwardLayer&&this.backwardLayer.setFastWeightInitDuringBuild(e)}getConfig(){const e={mergeMode:this.mergeMode},t=super.getConfig();return Object.assign(e,t),e}static fromConfig(e,t){const n=bk(t.layer);if(delete t.layer,null!=t.numConstants)throw new Xx("Deserialization of a Bidirectional layer with numConstants present is not supported yet.");const a=t;return a.layer=n,new e(a)}}SN.className="Bidirectional",Yd(SN);class NN extends Ww{constructor(e){super(e),this.scale=e.scale,e.offset?this.offset=e.offset:this.offset=0}getConfig(){const e={scale:this.scale,offset:this.offset},t=super.getConfig();return Object.assign(e,t),e}call(e,t){return Hu((()=>("float32"!==(e=Ew(e)).dtype&&(e=Uv(e,"float32")),Ld(Bd(e,this.scale),this.offset))))}}NN.className="Rescaling",Yd(NN);const{resizeBilinear:CN,cropAndResize:TN}=jm;class EN extends Ww{constructor(e){super(e),this.height=e.height,this.width=e.width}centerCrop(e,t,n,a,r,o,s,i){return Hu((()=>{let c,l=!1;const u=[t/o,n/s,(a+t)/o,(r+n)/s],d=[];3===e.rank?(l=!0,c=Mf([e])):c=e;for(let e=0;e<c.shape[0];e++)d.push(u);const h=Wu(d,[d.length,4]),p=vf(0,d.length,1,"int32"),f=TN(c,h,p,[a,r],"nearest");return Uv(l?Ew(Wf(f)):f,i)}))}upsize(e,t,n,a){return Hu((()=>Uv(CN(e,[t,n]),a)))}call(e,t){return Hu((()=>{const t=Ew(e),n=t.dtype,a=t.shape,r=a[a.length-3],o=a[a.length-2];let s=0;r!==this.height&&(s=Math.floor((r-this.height)/2));let i=0;return o!==this.width&&(i=Math.floor((o-this.width)/2),0===i&&(i=1)),s>=0&&i>=0?this.centerCrop(t,s,i,this.height,this.width,r,o,n):this.upsize(e,this.height,this.width,n)}))}getConfig(){const e={height:this.height,width:this.width},t=super.getConfig();return Object.assign(e,t),e}computeOutputShape(e){const t=(e=Rw(e)).length-3,n=e.length-2;return e[t]=this.height,e[n]=this.width,e}}EN.className="CenterCrop",Yd(EN);class RN extends Ww{constructor(e){super(e),this.numTokens=e.numTokens,e.outputMode?this.outputMode=e.outputMode:this.outputMode="multiHot"}getConfig(){const e={numTokens:this.numTokens,outputMode:this.outputMode},t=super.getConfig();return Object.assign(e,t),e}computeOutputShape(e){return null==(e=Rw(e))?[this.numTokens]:"oneHot"===this.outputMode&&1!==e[e.length-1]?(e.push(this.numTokens),e):(e[e.length-1]=this.numTokens,e)}call(e,t){return Hu((()=>{let n;if("int32"!==(e=Ew(e)).dtype&&(e=Uv(e,"int32")),"undefined"!==typeof t.countWeights){if("count"!==this.outputMode)throw new qx("countWeights is not used when outputMode !== count.\n              Received countWeights=".concat(t.countWeights));n=Ew(t.countWeights)}const a=Wp(e),r=af(e),o=Mp(this.numTokens,a).bufferSync().get(0),s=Lp(r,0).bufferSync().get(0);if(!o||!s)throw new qx("Input values must be between 0 < values <="+" numTokens with numTokens=".concat(this.numTokens));return function(e,t,n,a){let r=Ew(e);if("int32"!==r.dtype&&(r=Uv(r,"int32")),"int"===t)return r;const o=r.shape;if(0===r.rank&&(r=_p(r,-1)),"oneHot"===t&&1!==r.shape[r.shape.length-1]&&(r=_p(r,-1)),r.rank>2)throw new qx("When outputMode is not int, maximum output rank is 2"+" Received outputMode ".concat(t," and input shape ").concat(o)+" which would result in output rank ".concat(r.rank,"."));const s=["multiHot","oneHot"].includes(t),i=r;let c;if(c=Np(i,"undefined"!==typeof a&&"count"===t?a:[],n,s),"tfIdf"!==t)return c;if(a)return Bd(c,a);throw new qx("When outputMode is 'tfIdf', weights must be provided.")}(e,this.outputMode,this.numTokens,n)}))}}RN.className="CategoryEncoding",Yd(RN);const _N=new Set(["bilinear","nearest"]);class AN extends Ww{constructor(e){if(super(e),this.height=e.height,this.width=e.width,e.interpolation){if(!_N.has(e.interpolation))throw new qx("Invalid interpolation parameter: ".concat(e.interpolation," is not implemented"));this.interpolation=e.interpolation}else this.interpolation="bilinear";this.cropToAspectRatio=Boolean(e.cropToAspectRatio)}computeOutputShape(e){const t=(e=Rw(e))[2];return[this.height,this.width,t]}getConfig(){const e={height:this.height,width:this.width,interpolation:this.interpolation,cropToAspectRatio:this.cropToAspectRatio},t=super.getConfig();return Object.assign(e,t),e}call(e,t){return Hu((()=>{const t=[this.height,this.width];if("bilinear"===this.interpolation)return jm.resizeBilinear(e,t,!this.cropToAspectRatio);if("nearest"===this.interpolation)return jm.resizeNearestNeighbor(e,t,!this.cropToAspectRatio);throw new Error("Interpolation is ".concat(this.interpolation," but only ").concat([..._N]," are supported"))}))}}AN.className="Resizing",Yd(AN);class FN{constructor(e){this.seed=e}next(){if(void 0!==this.seed)return this.seed++}}FN.className="RandomSeed";class ON extends Ww{constructor(e){super(e),this.randomGenerator=new FN(e.seed)}getConfig(){const e={seed:this.randomGenerator.seed},t=super.getConfig();return Object.assign(e,t),e}}ON.className="BaseRandomLayer";const DN=new Set(["bilinear","nearest"]);class MN extends ON{constructor(e){super(e);const{factor:t,interpolation:n="bilinear"}=e;if(this.factor=t,Array.isArray(this.factor)&&2===this.factor.length)this.widthLower=this.factor[0],this.widthUpper=this.factor[1];else{if(Array.isArray(this.factor)||!(this.factor>0))throw new qx("Invalid factor: ".concat(this.factor,". Must be positive number or tuple of 2 numbers"));this.widthLower=-this.factor,this.widthUpper=this.factor}if(this.widthLower<-1||this.widthUpper<-1)throw new qx("factor must have values larger than -1. Got: ".concat(this.factor));if(this.widthUpper<this.widthLower)throw new qx("factor cannot have upper bound less than lower bound.\n        Got upper bound: ".concat(this.widthUpper,".\n        Got lower bound: ").concat(this.widthLower,"\n      "));if(n){if(!DN.has(n))throw new qx("Invalid interpolation parameter: ".concat(n," is not implemented"));this.interpolation=n}}getConfig(){const e={factor:this.factor,interpolation:this.interpolation},t=super.getConfig();return Object.assign(e,t),e}computeOutputShape(e){const t=(e=Rw(e))[2];return[this.imgHeight,-1,t]}call(e,t){return Hu((()=>{const t=Ew(e);this.imgHeight=t.shape[t.shape.length-3];const n=t.shape[t.shape.length-2];this.widthFactor=xf([1],1+this.widthLower,1+this.widthUpper,"float32",this.randomGenerator.next());let a=this.widthFactor.dataSync()[0]*n;a=Math.round(a);const r=[this.imgHeight,a];switch(this.interpolation){case"bilinear":return jm.resizeBilinear(e,r);case"nearest":return jm.resizeNearestNeighbor(e,r);default:throw new Error("Interpolation is ".concat(this.interpolation,"\n          but only ").concat([...DN]," are supported"))}}))}}MN.className="RandomWidth",Yd(MN);var LN,PN;Yo().registerFlag("KEEP_INTERMEDIATE_TENSORS",(()=>!1),(e=>{e&&console.warn("Keep intermediate tensors is ON. This will print the values of all intermediate tensors during model inference. Not all models support this mode. For details, check e2e/benchmarks/ model_config.js. This significantly impacts performance.")})),function(e){e[e.DT_INVALID=0]="DT_INVALID",e[e.DT_FLOAT=1]="DT_FLOAT",e[e.DT_DOUBLE=2]="DT_DOUBLE",e[e.DT_INT32=3]="DT_INT32",e[e.DT_UINT8=4]="DT_UINT8",e[e.DT_INT16=5]="DT_INT16",e[e.DT_INT8=6]="DT_INT8",e[e.DT_STRING=7]="DT_STRING",e[e.DT_COMPLEX64=8]="DT_COMPLEX64",e[e.DT_INT64=9]="DT_INT64",e[e.DT_BOOL=10]="DT_BOOL",e[e.DT_QINT8=11]="DT_QINT8",e[e.DT_QUINT8=12]="DT_QUINT8",e[e.DT_QINT32=13]="DT_QINT32",e[e.DT_BFLOAT16=14]="DT_BFLOAT16",e[e.DT_QINT16=15]="DT_QINT16",e[e.DT_QUINT16=16]="DT_QUINT16",e[e.DT_UINT16=17]="DT_UINT16",e[e.DT_COMPLEX128=18]="DT_COMPLEX128",e[e.DT_HALF=19]="DT_HALF",e[e.DT_RESOURCE=20]="DT_RESOURCE",e[e.DT_VARIANT=21]="DT_VARIANT",e[e.DT_UINT32=22]="DT_UINT32",e[e.DT_UINT64=23]="DT_UINT64",e[e.DT_FLOAT_REF=101]="DT_FLOAT_REF",e[e.DT_DOUBLE_REF=102]="DT_DOUBLE_REF",e[e.DT_INT32_REF=103]="DT_INT32_REF",e[e.DT_UINT8_REF=104]="DT_UINT8_REF",e[e.DT_INT16_REF=105]="DT_INT16_REF",e[e.DT_INT8_REF=106]="DT_INT8_REF",e[e.DT_STRING_REF=107]="DT_STRING_REF",e[e.DT_COMPLEX64_REF=108]="DT_COMPLEX64_REF",e[e.DT_INT64_REF=109]="DT_INT64_REF",e[e.DT_BOOL_REF=110]="DT_BOOL_REF",e[e.DT_QINT8_REF=111]="DT_QINT8_REF",e[e.DT_QUINT8_REF=112]="DT_QUINT8_REF",e[e.DT_QINT32_REF=113]="DT_QINT32_REF",e[e.DT_BFLOAT16_REF=114]="DT_BFLOAT16_REF",e[e.DT_QINT16_REF=115]="DT_QINT16_REF",e[e.DT_QUINT16_REF=116]="DT_QUINT16_REF",e[e.DT_UINT16_REF=117]="DT_UINT16_REF",e[e.DT_COMPLEX128_REF=118]="DT_COMPLEX128_REF",e[e.DT_HALF_REF=119]="DT_HALF_REF",e[e.DT_RESOURCE_REF=120]="DT_RESOURCE_REF",e[e.DT_VARIANT_REF=121]="DT_VARIANT_REF",e[e.DT_UINT32_REF=122]="DT_UINT32_REF",e[e.DT_UINT64_REF=123]="DT_UINT64_REF"}(LN||(LN={})),function(e){let t;!function(e){e[e.LEGACY=0]="LEGACY",e[e.V1=1]="V1",e[e.V2=2]="V2"}(t=e.CheckpointFormatVersion||(e.CheckpointFormatVersion={}))}(PN||(PN={}));Error;new Set(["Switch","Merge","Enter","Exit","NextIteration","StatelessIf","StatelessWhile","if","While"]),new Set(["NonMaxSuppressionV2","NonMaxSuppressionV3","NonMaxSuppressionV5","Where"]),new Set(["HashTable","HashTableV2","LookupTableImport","LookupTableImportV2","LookupTableFind","LookupTableFindV2","LookupTableSize","LookupTableSizeV2"]);function zN(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:new Map,a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:new Set;if(null==e)return null;if("function"===typeof Blob&&e instanceof Blob)return e.slice();if(a.has(e))throw new Error("Circular references are not supported.");if(n.has(e))return n.get(e);const r=t(e);if(r.recurse&&null!==r.value)throw new Error("A deep map function may not return both a value and recurse=true.");if(r.recurse){if(UN(e)){const r=Array.isArray(e)?[]:{};a.add(e);for(const o in e){const s=zN(e[o],t,n,a);r[o]=s}return a.delete(e),e.__proto__&&(r.__proto__=e.__proto__),r}throw new Error("Can't recurse into non-iterable type: ".concat(e))}return n.set(e,r.value),r.value}function BN(e){return WN(e,arguments.length>1&&void 0!==arguments[1]?arguments[1]:VN)}function WN(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:new Set;const a=e[0];if(n.has(a))throw new Error("Circular references are not supported.");const r=t(e);if(r.recurse&&null!==r.value)throw new Error("A deep zip function may not return both a value and recurse=true.");if(r.recurse){if(UN(a)){const r=Array.isArray(a)?[]:{};n.add(a);for(const o in a){const a=WN(e.map((e=>e[o])),t,n);r[o]=a}return n.delete(a),r}throw new Error("Can't recurse into non-iterable type: ".concat(a))}return r.value}function VN(e){return null===e?null:UN(e[0])?{value:null,recurse:!0}:{value:e,recurse:!1}}function UN(e){let t=!1;if(Yo().get("IS_BROWSER"))t=e instanceof TextDecoder;else{const{StringDecoder:a}=n(222);t=e instanceof a}return null!=e&&!ArrayBuffer.isView(e)&&(Array.isArray(e)||"object"===typeof e&&!(e instanceof ou)&&!(e instanceof Promise)&&!t)}function GN(e){return function(e,t){return zN(e,t)}(e,HN)}function HN(e){return e instanceof ou?{value:e.clone(),recurse:!1}:UN(e)?{value:null,recurse:!0}:{value:e,recurse:!1}}class jN{constructor(e){if(this.capacity=e,this.begin=0,this.end=0,null==e)throw new RangeError("Can't create a ring buffer of unknown capacity.");if(e<1)throw new RangeError("Can't create ring buffer of capacity < 1.");this.data=new Array(e),this.doubledCapacity=2*e}wrap(e){for(;e<0;)e+=this.doubledCapacity;return e%this.doubledCapacity}get(e){if(e<0)throw new RangeError("Can't get item at a negative index.");return this.data[e%this.capacity]}set(e,t){if(e<0)throw new RangeError("Can't set item at a negative index.");this.data[e%this.capacity]=t}length(){let e=this.end-this.begin;return e<0&&(e=this.doubledCapacity+e),e}isFull(){return this.length()===this.capacity}isEmpty(){return 0===this.length()}push(e){if(this.isFull())throw new RangeError("Ring buffer is full.");this.set(this.end,e),this.end=this.wrap(this.end+1)}pushAll(e){for(const t of e)this.push(t)}pop(){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");this.end=this.wrap(this.end-1);const e=this.get(this.end);return this.set(this.end,void 0),e}unshift(e){if(this.isFull())throw new RangeError("Ring buffer is full.");this.begin=this.wrap(this.begin-1),this.set(this.begin,e)}shift(){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");const e=this.get(this.begin);return this.set(this.begin,void 0),this.begin=this.wrap(this.begin+1),e}shuffleExcise(e){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");const t=this.wrap(this.begin+e),n=this.get(t);return this.set(t,this.pop()),n}}class KN extends jN{constructor(){super(KN.INITIAL_CAPACITY)}isFull(){return!1}push(e){super.isFull()&&this.expand(),super.push(e)}unshift(e){super.isFull()&&this.expand(),super.unshift(e)}expand(){const e=2*this.capacity,t=new Array(e),n=this.length();for(let a=0;a<n;a++)t[a]=this.get(this.wrap(this.begin+a));this.data=t,this.capacity=e,this.doubledCapacity=2*this.capacity,this.begin=0,this.end=n}}function qN(e){return new JN(e)}function XN(e,t){return new cC(e,t)}KN.INITIAL_CAPACITY=32;class YN{async toArray(){const e=[];let t=await this.next();for(;!t.done;)e.push(t.value),t=await this.next();return e}async toArrayForTest(){const e=this.prefetch(100),t=[];let n=await e.next();for(;!n.done;)t.push(n.value),n=await e.next();return t}async resolveFully(){let e=await this.next();for(;!e.done;)e=await this.next()}async resolveWhile(e){let t=await this.next(),n=e(t.value);for(;!t.done&&n;)t=await this.next(),n=e(t.value)}handleErrors(e){return new rC(this,e)}filter(e){return new nC(this,e)}map(e){return new aC(this,e)}mapAsync(e){return new oC(this,e)}serialMapAsync(e){return new oC(this,e).serial()}flatmap(e){return new iC(this,e)}async forEachAsync(e){return this.map(e).resolveFully()}async serialForEach(e){return this.serialMapAsync(e).resolveWhile((e=>!0===e))}rowMajorBatch(e){return new tC(this,e,!(arguments.length>1&&void 0!==arguments[1])||arguments[1])}columnMajorBatch(e){let t=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:VN;return this.rowMajorBatch(e,t).map((e=>BN(e,n)))}concatenate(e,t){return new cC(new QN([this,e]),t)}take(e){return e<0||null==e?this:new eC(this,e)}skip(e){return e<0||null==e?this:new $N(this,e)}prefetch(e){return new uC(this,e)}shuffle(e,t){return new dC(this,e,t)}serial(){return new ZN(this)}}class QN extends YN{constructor(e){super(),this.items=e,this.trav=0}summary(){return"Array of ".concat(this.items.length," items")}async next(){if(this.trav>=this.items.length)return{value:null,done:!0};const e=this.items[this.trav];return this.trav++,{value:GN(e),done:!1}}}class JN extends YN{constructor(e){super(),this.nextFn=e}summary(){return"Function call"}async next(){try{return this.nextFn()}catch(B){throw B.message="Error thrown while iterating through a dataset: ".concat(B.message),B}}}class ZN extends YN{constructor(e){super(),this.upstream=e,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return"".concat(this.upstream.summary()," -> Serial")}async next(){return this.lastRead=this.lastRead.then((()=>this.serialNext())),this.lastRead}async serialNext(){return this.upstream.next()}}class $N extends YN{constructor(e,t){super(),this.upstream=e,this.maxCount=t,this.count=0,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return"".concat(this.upstream.summary()," -> Skip")}async next(){return this.lastRead=this.lastRead.then((()=>this.serialNext())),this.lastRead}async serialNext(){for(;this.count++<this.maxCount;){const e=await this.upstream.next();if(e.done)return e;ju(e.value)}return this.upstream.next()}}class eC extends YN{constructor(e,t){super(),this.upstream=e,this.maxCount=t,this.count=0}summary(){return"".concat(this.upstream.summary()," -> Take")}async next(){return this.count++>=this.maxCount?{value:null,done:!0}:this.upstream.next()}}class tC extends YN{constructor(e,t){let n=!(arguments.length>2&&void 0!==arguments[2])||arguments[2];super(),this.upstream=e,this.batchSize=t,this.enableSmallLastBatch=n,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return"".concat(this.upstream.summary()," -> RowMajorBatch")}async next(){return this.lastRead=this.lastRead.then((()=>this.serialNext())),this.lastRead}async serialNext(){const e=[];for(;e.length<this.batchSize;){const t=await this.upstream.next();if(t.done)return this.enableSmallLastBatch&&e.length>0?{value:e,done:!1}:{value:null,done:!0};e.push(t.value)}return{value:e,done:!1}}}class nC extends YN{constructor(e,t){super(),this.upstream=e,this.predicate=t,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return"".concat(this.upstream.summary()," -> Filter")}async next(){return this.lastRead=this.lastRead.then((()=>this.serialNext())),this.lastRead}async serialNext(){for(;;){const e=await this.upstream.next();if(e.done||this.predicate(e.value))return e;ju(e.value)}}}class aC extends YN{constructor(e,t){super(),this.upstream=e,this.transform=t}summary(){return"".concat(this.upstream.summary()," -> Map")}async next(){const e=await this.upstream.next();if(e.done)return{value:null,done:!0};const t=vu(e.value),n=this.transform(e.value),a=vu(n);for(const r of t)xu(r,a)||r.dispose();return{value:n,done:!1}}}class rC extends YN{constructor(e,t){super(),this.upstream=e,this.handler=t,this.count=0,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return"".concat(this.upstream.summary()," -> handleErrors")}async next(){return this.lastRead=this.lastRead.then((()=>this.serialNext())),this.lastRead}async serialNext(){for(;;)try{return await this.upstream.next()}catch(B){if(!this.handler(B))return{value:null,done:!0}}}}class oC extends YN{constructor(e,t){super(),this.upstream=e,this.transform=t}summary(){return"".concat(this.upstream.summary()," -> AsyncMap")}async next(){const e=await this.upstream.next();if(e.done)return{value:null,done:!0};const t=vu(e.value),n=await this.transform(e.value),a=vu(n);for(const r of t)xu(r,a)||r.dispose();return{value:n,done:!1}}}class sC extends YN{constructor(){super(),this.outputQueue=new KN,this.lastRead=Promise.resolve({value:null,done:!1})}async next(){return this.lastRead=this.lastRead.then((()=>this.serialNext())),this.lastRead}async serialNext(){for(;0===this.outputQueue.length();)if(!await this.pump())return{value:null,done:!0};return{value:this.outputQueue.shift(),done:!1}}}class iC extends sC{constructor(e,t){super(),this.upstream=e,this.transform=t}summary(){return"".concat(this.upstream.summary()," -> Flatmap")}async pump(){const e=await this.upstream.next();if(e.done)return!1;const t=vu(e.value),n=this.transform(e.value),a=vu(n);this.outputQueue.pushAll(n);for(const r of t)xu(r,a)||r.dispose();return!0}}class cC extends YN{constructor(e,t){super(),this.baseErrorHandler=t,this.lastRead=null,this.iterator=null,this.moreIterators=e}summary(){return"".concat("TODO: fill in upstream of chained summaries"," -> Chained")}async next(){return this.lastRead=this.readFromChain(this.lastRead),this.lastRead}async readFromChain(e){if(await e,null==this.iterator){const e=await this.moreIterators.next();if(e.done)return{value:null,done:!0};this.iterator=e.value,null!=this.baseErrorHandler&&(this.iterator=this.iterator.handleErrors(this.baseErrorHandler))}const t=await this.iterator.next();return t.done?(this.iterator=null,this.readFromChain(e)):t}}var lC;!function(e){e[e.FAIL=0]="FAIL",e[e.SHORTEST=1]="SHORTEST",e[e.LONGEST=2]="LONGEST"}(lC||(lC={}));class uC extends YN{constructor(e,t){super(),this.upstream=e,this.bufferSize=t,this.buffer=new jN(t)}summary(){return"".concat(this.upstream.summary()," -> Prefetch")}refill(){for(;!this.buffer.isFull();){const e=this.upstream.next();this.buffer.push(e)}}next(){return this.refill(),this.buffer.shift()}}class dC extends uC{constructor(e,t,n){super(e,t),this.upstream=e,this.windowSize=t,this.upstreamExhausted=!1,this.random=mf.alea(n||Bl().toString()),this.lastRead=Promise.resolve({value:null,done:!1})}async next(){return this.lastRead=this.lastRead.then((()=>this.serialNext())),this.lastRead}randomInt(e){return Math.floor(this.random()*e)}chooseIndex(){return this.randomInt(this.buffer.length())}async serialNext(){for(this.upstreamExhausted||this.refill();!this.buffer.isEmpty();){const e=this.chooseIndex(),t=await this.buffer.shuffleExcise(e);if(!t.done)return this.refill(),t;this.upstreamExhausted=!0}return{value:null,done:!0}}}class hC{constructor(){this.size=null}batch(e){let t=!(arguments.length>1&&void 0!==arguments[1])||arguments[1];const n=this;let a;return mo(e>0,(()=>"batchSize needs to be positive, but it is\n      ".concat(e))),a=this.size===1/0||null==this.size?this.size:t?Math.ceil(this.size/e):Math.floor(this.size/e),pC((async()=>(await n.iterator()).columnMajorBatch(e,t,fC)),a)}concatenate(e){const t=this;let n;return n=this.size===1/0||e.size===1/0?1/0:null!=this.size&&null!=e.size?this.size+e.size:null,pC((async()=>(await t.iterator()).concatenate(await e.iterator())),n)}filter(e){const t=this;let n;return n=this.size===1/0?1/0:null,pC((async()=>(await t.iterator()).filter((t=>Hu((()=>e(t)))))),n)}async forEachAsync(e){return(await this.iterator()).forEachAsync(e)}map(e){const t=this;return pC((async()=>(await t.iterator()).map((t=>Hu((()=>e(t)))))),this.size)}mapAsync(e){const t=this;return pC((async()=>(await t.iterator()).mapAsync(e)),this.size)}prefetch(e){if(null==e)throw new RangeError("`Dataset.prefetch()` requires bufferSize to be specified.");const t=this;return pC((async()=>(await t.iterator()).prefetch(e)),this.size)}repeat(e){const t=this;let n;return n=null!=this.size&&e>0?this.size*e:0===e?0:null!=this.size&&(void 0===e||e<0)?1/0:null,pC((async()=>XN(qN((async()=>({value:await t.iterator(),done:!1}))).take(e))),n)}skip(e){const t=this;let n;return n=null!=this.size&&e>=0&&this.size>=e?this.size-e:null!=this.size&&(this.size<e||void 0===e||e<0)?0:null,pC((async()=>(await t.iterator()).skip(e)),n)}shuffle(e,t){let n=!(arguments.length>2&&void 0!==arguments[2])||arguments[2];if(null==e||e<0)throw null==this.size?new RangeError("`Dataset.shuffle()` requires bufferSize to be specified."):new RangeError("`Dataset.shuffle()` requires bufferSize to be specified.  If your data fits in main memory (for regular JS objects), and/or GPU memory (for `tf.Tensor`s), consider setting "+"bufferSize to the dataset size (".concat(this.size," elements)"));const a=this,r=mf.alea(t||Bl().toString());return pC((async()=>{let t=r.int32();return n&&(t+=r.int32()),(await a.iterator()).shuffle(e,t.toString())}),this.size)}take(e){const t=this;let n;return n=null!=this.size&&this.size>e?e:null!=this.size&&this.size<=e?this.size:null,pC((async()=>(await t.iterator()).take(e)),n)}async toArray(){if(this.size===1/0)throw new Error("Can not convert infinite data stream to array.");return(await this.iterator()).toArray()}async toArrayForTest(){if(this.size===1/0)throw new Error("Can not convert infinite data stream to array.");return(await this.iterator()).toArrayForTest()}}function pC(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;return new class extends hC{constructor(){super(...arguments),this.size=t}async iterator(){return e()}}}function fC(e){if(null===e)return null;if(function(e){return null==e||null===(t=e)||"object"!==typeof t&&"function"!==typeof t||Array.isArray(e)||"object"===typeof e&&e instanceof ou||Ul(e);var t}(e[0])){return{value:function(e){if(0===e.length)throw new Error("Can't make a batch of zero elements.");return e[0]instanceof ou?Mf(e):Wu(e)}(e),recurse:!1}}return{value:null,recurse:!0}}hC.MAX_BUFFER_SIZE=1e4;Symbol("out"),Symbol("field"),Symbol("quote"),Symbol("quoteafterquote"),Symbol("quoteinquote");function mC(e,t){Array.isArray(e)||(e=[e]),e.forEach((e=>{null!=e&&mo("complex64"!==e.dtype,(()=>"".concat(t," does not support complex64 tensors in the CPU backend.")))}))}const gC=ob;class bC extends co{nextDataId(){return bC.nextDataId++}constructor(){super(),this.blockSize=48,this.firstUse=!0,this.data=new io(this,Uu())}write(e,t,n){this.firstUse&&(this.firstUse=!1,Yo().get("IS_NODE")&&dl("\n============================\nHi, looks like you are running TensorFlow.js in Node.js. To speed things up dramatically, install our node backend, visit https://github.com/tensorflow/tfjs-node for more details. \n============================"));const a={id:this.nextDataId()};return this.data.set(a,{values:e,dtype:n,refCount:1}),a}makeTensorInfo(e,t,n){let a;if("string"===t&&null!=n&&n.length>0&&Ao(n[0])){const r=n.map((e=>Wl(e)));a=this.write(r,e,t)}else a=this.write(n,e,t);return{dataId:a,shape:e,dtype:t}}refCount(e){if(this.data.has(e)){return this.data.get(e).refCount}return 0}incRef(e){this.data.get(e).refCount++}decRef(e){if(this.data.has(e)){this.data.get(e).refCount--}}move(e,t,n,a,r){this.data.set(e,{values:t,dtype:a,refCount:r})}numDataIds(){return this.data.numDataIds()}async read(e){return this.readSync(e)}readSync(e){const{dtype:t,complexTensorInfos:n}=this.data.get(e);if("complex64"===t){return Ig(this.readSync(n.real.dataId),this.readSync(n.imag.dataId))}return function(e,t){if(Array.isArray(e))return e;if("float32"===t)return e instanceof Float32Array?e:new Float32Array(e);if("int32"===t)return e instanceof Int32Array?e:new Int32Array(e);if("bool"===t||"string"===t)return Uint8Array.from(new Int32Array(e));throw new Error("Unknown dtype ".concat(t))}(this.data.get(e).values,t)}bufferSync(e){const t=this.readSync(e.dataId);if("string"===e.dtype)try{const n=t.map((e=>Vl(e)));return Od(e.shape,e.dtype,n)}catch(n){throw new Error("Failed to decode encoded string bytes into utf-8")}return Od(e.shape,e.dtype,t)}makeOutput(e,t,n){return Uu().makeTensorFromTensorInfo(this.makeTensorInfo(t,n,e),this)}disposeData(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];if(this.data.has(e)){if(this.data.get(e).refCount--,!t&&this.data.get(e).refCount>0)return!1;const{complexTensorInfos:n}=this.data.get(e);null!=n&&(this.disposeData(n.real.dataId,!0),this.disposeData(n.imag.dataId,!0)),this.data.delete(e)}return!0}disposeIntermediateTensorInfo(e){this.disposeData(e.dataId)}async time(e){const t=Bl();e();return{kernelMs:Bl()-t}}memory(){return{unreliable:!0,reasons:["The reported memory is an upper bound. Due to automatic garbage collection, the true allocated memory may be less."]}}where(e){mC([e],"where");const t=this.readSync(e.dataId);return gC(e.shape,t)}dispose(){}floatPrecision(){return 32}epsilon(){return super.epsilon()}}bC.nextDataId=0;function yC(e){return(t,n,a)=>{const r=Eo(n,t.length);for(let o=0;o<t.length;++o)r[o]=e(t[o],a);return r}}function xC(e,t,n){return vC(e,yC(t),n)}function vC(e,t,n){return a=>{let{inputs:r,attrs:o,backend:s}=a;const{x:i}=r;mC(i,e);const c=s,l=c.data.get(i.dataId).values;let u;if("string"===i.dtype){if(!Array.isArray(l))throw new Error("String tensor's value was not an instance of Array");u=ab(l)}else u=l;const d=n||i.dtype,h=t(u,d,o);return c.makeTensorInfo(i.shape,d,h)}}Xu("cpu",(()=>new bC),1);const wC=xC(Zs,(e=>e>=0?e:Math.exp(e)-1)),kC={kernelName:Zs,backendName:"cpu",kernelFunc:wC};function IC(e){const{inputs:t,backend:n}=e,{x:a}=t;return n.incRef(a.dataId),{dataId:a.dataId,shape:a.shape,dtype:a.dtype}}const SC={kernelName:mi,backendName:"cpu",kernelFunc:IC};function NC(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{alpha:o}=a;mC([r],"leakyRelu");const s=yo(r.shape),i=n.data.get(r.dataId).values,c=To("float32",s);for(let l=0;l<i.length;l++)c[l]=i[l]<0?o*i[l]:i[l];return n.makeTensorInfo(r.shape,"float32",c)}const CC={kernelName:wi,backendName:"cpu",kernelFunc:NC};function TC(e){return(t,n,a,r,o)=>{const s=sh(t,n),i=s.length,c=Lo(s),l=To(o,yo(s)),u=t.length,d=n.length,h=Lo(t),p=Lo(n),f=rh(t,s),m=rh(n,s);if(f.length+m.length===0)for(let g=0;g<l.length;++g)l[g]=e(a[g%a.length],r[g%r.length]);else for(let g=0;g<l.length;++g){const t=Ho(g,i,c),n=t.slice(-u);f.forEach((e=>n[e]=0));const o=Go(n,u,h),s=t.slice(-d);m.forEach((e=>s[e]=0));const b=Go(s,d,p);l[g]=e(a[o],r[b])}return[l,s]}}const EC=TC(((e,t)=>e<0?t*e:e));function RC(e){const{inputs:t,backend:n}=e,{x:a,alpha:r}=t;mC([a,r],"prelu");const o=n.data.get(a.dataId).values,s=n.data.get(r.dataId).values,[i,c]=EC(a.shape,r.shape,o,s,"float32");return n.makeTensorInfo(c,"float32",i)}const _C={kernelName:nc,backendName:"cpu",kernelFunc:RC},AC=xC(uc,(e=>Math.max(0,e))),FC={kernelName:uc,backendName:"cpu",kernelFunc:AC},OC=xC(gc,(e=>Math.min(Math.max(0,e),6))),DC={kernelName:gc,backendName:"cpu",kernelFunc:OC},MC=yC((e=>1/(1+Math.exp(-e)))),LC=xC(Rc,(e=>1/(1+Math.exp(-e)))),PC={kernelName:Rc,backendName:"cpu",kernelFunc:LC};function zC(e,t,n,a,r){if("linear"===n)return IC({inputs:{x:t},backend:e});if("relu"===n)return AC({inputs:{x:t},backend:e});if("elu"===n)return wC({inputs:{x:t},backend:e});if("relu6"===n)return OC({inputs:{x:t},backend:e});if("prelu"===n)return RC({inputs:{x:t,alpha:a},backend:e});if("leakyrelu"===n)return NC({inputs:{x:t},backend:e,attrs:{alpha:r}});if("sigmoid"===n)return LC({inputs:{x:t},backend:e});throw new Error("Activation ".concat(n," has not been implemented for the CPU backend."))}function BC(e){const{inputs:t,backend:n}=e,{real:a,imag:r}=t,o=n.data.get(a.dataId).values,s=n.data.get(r.dataId).values,i=n.makeTensorInfo(a.shape,"complex64");return n.data.get(i.dataId).complexTensorInfos={real:n.makeTensorInfo(a.shape,"float32",o),imag:n.makeTensorInfo(r.shape,"float32",s)},i}const WC={kernelName:Cs,backendName:"cpu",kernelFunc:BC};function VC(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"float32";if("complex64"===n){return BC({inputs:{real:VC(e,t,"float32"),imag:VC(e,t,"float32")},backend:e})}const a=Wo(yo(t),n);return e.makeTensorInfo(t,n,a)}function UC(e){const{inputs:t,backend:n}=e,{input:a}=t,r=n.data.get(a.dataId).complexTensorInfos.real,o=n.data.get(r.dataId).values;return n.makeTensorInfo(r.shape,r.dtype,o)}const GC={kernelName:cc,backendName:"cpu",kernelFunc:UC};function HC(e,t,n,a){if("int32"===a){return[t,"int32",Int32Array.from(e)]}if("bool"===a){const a=zl([0],n),[r,o]=TC(((e,t)=>e!==t?1:0))(t,[],e,a,"bool");return[o,"bool",r]}throw new Error("Error in Cast: failed to cast ".concat(n," to ").concat(a))}function jC(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{dtype:o}=a;if("complex64"===o){if("complex64"===r.dtype)return IC({inputs:{x:r},backend:n});const e=VC(n,r.shape,r.dtype),t=jC({inputs:{x:r},backend:n,attrs:{dtype:"float32"}}),a=BC({inputs:{real:t,imag:e},backend:n});return n.disposeIntermediateTensorInfo(e),n.disposeIntermediateTensorInfo(t),a}if("complex64"===r.dtype){const e=UC({inputs:{input:r},backend:n}),t=jC({inputs:{x:e},backend:n,attrs:{dtype:o}});return n.disposeIntermediateTensorInfo(e),t}if(!Ro(r.dtype,o)){const e=IC({inputs:{x:r},backend:n});return{dataId:e.dataId,shape:e.shape,dtype:o}}const s=n.data.get(r.dataId).values,[i,c,l]=HC(s,r.shape,r.dtype,o);return n.makeTensorInfo(i,c,l)}const KC={kernelName:Is,backendName:"cpu",kernelFunc:jC};function qC(e,t,n,a){return null==n?n=>{let{inputs:r,backend:o}=n;const{a:s,b:i}=r,c=o;mC([s,i],e);const l=c.data.get(s.dataId).values,u=c.data.get(i.dataId).values,d="string"===s.dtype?ab(l):l,h="string"===s.dtype?ab(u):u,p=a||s.dtype,[f,m]=t(s.shape,i.shape,d,h,p);return c.makeTensorInfo(m,p,f)}:e=>{let{inputs:r,backend:o}=e;const{a:s,b:i}=r,c=o;if("complex64"===s.dtype||"complex64"===i.dtype){const e=jC({inputs:{x:s},backend:c,attrs:{dtype:"complex64"}}),t=c.data.get(e.dataId),a=t.complexTensorInfos.real,r=t.complexTensorInfos.imag,o=c.data.get(a.dataId).values,l=c.data.get(r.dataId).values,u=jC({inputs:{x:i},backend:c,attrs:{dtype:"complex64"}}),d=c.data.get(u.dataId),h=d.complexTensorInfos.real,p=d.complexTensorInfos.imag,f=c.data.get(h.dataId).values,m=c.data.get(p.dataId).values,[g,b,y]=n(s.shape,i.shape,o,l,f,m),x=c.makeTensorInfo(y,"float32",g),v=c.makeTensorInfo(y,"float32",b),w=BC({inputs:{real:x,imag:v},backend:c});return c.disposeIntermediateTensorInfo(e),c.disposeIntermediateTensorInfo(u),c.disposeIntermediateTensorInfo(x),c.disposeIntermediateTensorInfo(v),w}{const e=c.data.get(s.dataId).values,n=c.data.get(i.dataId).values,r=a||s.dtype,[o,l]=t(s.shape,i.shape,e,n,r);return c.makeTensorInfo(l,r,o)}}}function XC(e){return(t,n,a,r,o,s)=>{const i=sh(t,n),c=yo(i),l=i.length,u=Lo(i),d=To("float32",c),h=To("float32",c),p=rh(t,i),f=rh(n,i),m=Ig(a,r),g=Ig(o,s),b=t.length,y=Lo(t),x=n.length,v=Lo(n);if(p.length+f.length===0)for(let w=0;w<d.length;w++){const t=w%m.length,n=w%g.length,a=e(m[2*t],m[2*t+1],g[2*n],g[2*n+1]);d[w]=a.real,h[w]=a.imag}else for(let w=0;w<d.length;w++){const t=Ho(w,l,u),n=t.slice(-b);p.forEach((e=>n[e]=0));const a=Go(n,b,y),r=t.slice(-x);f.forEach((e=>r[e]=0));const o=Go(r,x,v),s=e(m[2*a],m[2*a+1],g[2*o],g[2*o+1]);d[w]=s.real,h[w]=s.imag}return[d,h,i]}}const YC=TC(((e,t)=>e+t)),QC=XC(((e,t,n,a)=>({real:e+n,imag:t+a}))),JC=qC(as,YC,QC),ZC={kernelName:as,backendName:"cpu",kernelFunc:JC};function $C(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{shape:o}=a,s=yo(r.shape),i=So(o,s),c=yo(i);mo(s===c,(()=>"The new shape (".concat(i,") has ").concat(c," elements and the old ")+"shape (".concat(r.shape,") has ").concat(s," elements. The new shape and old ")+"shape must have the same number of elements.")),n.incRef(r.dataId);const l=n.data.get(r.dataId);if(null!=l.complexTensorInfos){const e=l.complexTensorInfos.real,t=l.complexTensorInfos.imag;e.shape=i,t.shape=i}return{dataId:r.dataId,shape:i,dtype:r.dtype}}const eT={kernelName:dc,backendName:"cpu",kernelFunc:$C};function tT(e){const{inputs:t,backend:n,attrs:a}=e,{a:r,b:o}=t,{transposeA:s,transposeB:i}=a;mC([r,o],"matMul");const c=r.shape.length,l=o.shape.length,u=s?r.shape[c-2]:r.shape[c-1],d=i?o.shape[l-1]:o.shape[l-2],h=s?r.shape[c-1]:r.shape[c-2],p=i?o.shape[l-2]:o.shape[l-1],f=r.shape.slice(0,-2),m=o.shape.slice(0,-2),g=yo(f),b=yo(m),y=sh(r.shape.slice(0,-2),o.shape.slice(0,-2)).concat([h,p]);mo(u===d,(()=>"Error in matMul: inner shapes (".concat(u,") and (")+"".concat(d,") of Tensors with shapes ").concat(r.shape," and ")+"".concat(o.shape," and transposeA=").concat(s)+" and transposeB=".concat(i," must match.")));const x=i?[b,p,d]:[b,d,p],v=$C({inputs:{x:r},backend:n,attrs:{shape:s?[g,u,h]:[g,h,u]}}),w=$C({inputs:{x:o},backend:n,attrs:{shape:x}}),k=s?v.shape[1]:v.shape[2],I=s?v.shape[2]:v.shape[1],S=i?w.shape[1]:w.shape[2],N=Math.max(g,b),C=n.data.get(v.dataId).values,T=n.data.get(w.dataId).values,E=Lo(v.shape),R=Lo(w.shape),[_,A,F]=s?[E[0],1,E[1]]:[E[0],E[1],1],[O,D,M]=i?[1,R[1],R[0]]:[R[1],1,R[0]],L=I*S,P=Od([N,I,S],v.dtype),z=P.values,B=n.blockSize;for(let W=0;W<N;W++){const e=W%g,t=W%b;for(let n=0;n<I;n+=B){const a=Math.min(n+B,I);for(let r=0;r<S;r+=B){const o=Math.min(r+B,S);for(let s=0;s<k;s+=B){const i=Math.min(s+B,k);for(let c=n;c<a;c++)for(let n=r;n<o;n++){let a=0;for(let r=s;r<i;r++){a+=C[e*_+c*A+r*F]*T[r*O+n*D+t*M]}z[W*L+(c*S+n)]+=a}}}}}return n.disposeIntermediateTensorInfo(v),n.disposeIntermediateTensorInfo(w),n.makeTensorInfo(y,P.dtype,P.values)}const nT={kernelName:ys,backendName:"cpu",kernelFunc:tT};const aT={kernelName:cl,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{a:r,b:o,bias:s,preluActivationWeights:i}=t,{transposeA:c,transposeB:l,activation:u,leakyreluAlpha:d}=a;let h,p,f;const m=[];h=tT({inputs:{a:r,b:o},attrs:{transposeA:c,transposeB:l},backend:n}),s&&(p=JC({inputs:{a:h,b:s},backend:n}),m.push(h),h=p),u&&(f=zC(n,h,u,i,d),m.push(h),h=f);for(const g of m)n.disposeIntermediateTensorInfo(g);return h}};function rT(e){const t=new Float32Array(e.length);for(let n=0;n<e.length;++n)t[n]=Math.abs(e[n]);return t}const oT={kernelName:es,backendName:"cpu",kernelFunc:e=>{const{x:t}=e.inputs,n=e.backend;mC(t,"abs");let a=new Float32Array(yo(t.shape));return a=rT(n.data.get(t.dataId).values),n.makeOutput(a,t.shape,t.dtype)}},sT=xC(ts,(e=>Math.acos(e))),iT={kernelName:ts,backendName:"cpu",kernelFunc:sT},cT=xC(ns,(e=>Math.acosh(e))),lT={kernelName:ns,backendName:"cpu",kernelFunc:cT};const uT={kernelName:rs,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,a=t;mC(t,"addN");const r=a.map((e=>n.data.get(e.dataId).values)),o=Od(a[0].shape,a[0].dtype),s=o.values;for(let i=0;i<a.length;i++){const e=r[i];for(let t=0;t<s.length;t++)s[t]+=e[t]}return n.makeTensorInfo(o.shape,o.dtype,o.values)}};function dT(e,t,n,a,r){const o=t.length,s=yo(t),i=Lo(t),c=Lo(r),l=To(n,yo(r));for(let u=0;u<s;++u){const t=Ho(u,o,i),n=new Array(t.length);for(let e=0;e<n.length;e++)n[e]=t[a[e]];l[Go(n,o,c)]=e[u]}return l}function hT(e){const{inputs:t,attrs:n,backend:a}=e,{x:r}=t,{perm:o}=n;mC(r,"transpose");const s=r.shape.length,i=new Array(s);for(let l=0;l<i.length;l++)i[l]=r.shape[o[l]];const c=dT(a.data.get(r.dataId).values,r.shape,r.dtype,o,i);return{dataId:a.write(c,i,r.dtype),shape:i,dtype:r.dtype}}const pT={kernelName:el,backendName:"cpu",kernelFunc:hT};const fT={kernelName:os,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{axis:o,keepDims:s}=a;mC(r,"all");const i=No(o,r.shape);let c=i;const l=Xp(c,r.shape.length);let u=r;null!=l&&(u=hT({inputs:{x:r},backend:n,attrs:{perm:l}}),c=Qp(c.length,r.shape.length)),qp("all",c,u.shape.length);const[d,h]=jp(u.shape,c),p=yo(h),f=Wo(yo(d),u.dtype),m=n.data.get(u.dataId).values;for(let b=0;b<f.length;++b){const e=b*p;let t=m[e];for(let n=0;n<p;++n){const a=m[e+n];t=t&&a}f[b]=t}null!=l&&n.disposeIntermediateTensorInfo(u);const g=n.makeTensorInfo(d,u.dtype,f);if(s){const e=$C({inputs:{x:g},backend:n,attrs:{shape:Kp(d,i)}});return n.disposeIntermediateTensorInfo(g),e}return g}};const mT={kernelName:ss,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{axis:o,keepDims:s}=a;mC(r,"any");const i=No(o,r.shape);let c=i;const l=Xp(c,r.shape.length);let u=r;null!=l&&(u=hT({inputs:{x:r},backend:n,attrs:{perm:l}}),c=Qp(c.length,r.shape.length)),qp("any",c,u.shape.length);const[d,h]=jp(u.shape,c),p=yo(h),f=Wo(yo(d),u.dtype),m=n.data.get(u.dataId).values;for(let b=0;b<f.length;++b){const e=b*p;let t=m[e];for(let n=0;n<p;++n){const a=m[e+n];t=t||a}f[b]=t}null!=l&&n.disposeIntermediateTensorInfo(u);const g=n.makeTensorInfo(d,u.dtype,f);if(s){const e=$C({inputs:{x:g},backend:n,attrs:{shape:Kp(d,i)}});return n.disposeIntermediateTensorInfo(g),e}return g}};const gT={kernelName:is,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{axis:o}=a;mC(r,"argMax");let s=No(o,r.shape);const i=Xp(s,r.shape.length);let c=r;const l=[];null!=i&&(c=hT({inputs:{x:r},backend:n,attrs:{perm:i}}),l.push(c),s=Qp(s.length,c.shape.length)),s=[s[0]],qp("argMax",s,c.shape.length);const[u,d]=jp(c.shape,s),h=Wo(yo(u),"int32"),p=yo(d),f=n.data.get(c.dataId).values;for(let m=0;m<h.length;++m){const e=m*p;let t=f[e],n=0;for(let a=0;a<p;++a){const r=f[e+a];r>t&&(t=r,n=a)}h[m]=n}return l.forEach((e=>n.disposeIntermediateTensorInfo(e))),n.makeTensorInfo(u,"int32",h)}};const bT={kernelName:cs,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{axis:o}=a;mC(r,"argMin");let s=No(o,r.shape);const i=Xp(s,r.shape.length);let c=r;const l=[];null!=i&&(c=hT({inputs:{x:r},backend:n,attrs:{perm:i}}),l.push(c),s=Qp(s.length,c.shape.length)),s=[s[0]],qp("argMin",s,c.shape.length);const[u,d]=jp(c.shape,s),h=Wo(yo(u),"int32"),p=yo(d),f=n.data.get(c.dataId).values;for(let m=0;m<h.length;++m){const e=m*p;let t=f[e],n=0;for(let a=0;a<p;++a){const r=f[e+a];r<t&&(t=r,n=a)}h[m]=n}return l.forEach((e=>n.disposeIntermediateTensorInfo(e))),n.makeTensorInfo(u,"int32",h)}},yT=xC(ls,(e=>Math.asin(e))),xT={kernelName:ls,backendName:"cpu",kernelFunc:yT},vT=xC(us,(e=>Math.asinh(e))),wT={kernelName:us,backendName:"cpu",kernelFunc:vT},kT=xC(ds,(e=>Math.atan(e))),IT={kernelName:ds,backendName:"cpu",kernelFunc:kT},ST=TC(((e,t)=>Math.atan2(e,t))),NT=qC(ps,ST),CT={kernelName:ps,backendName:"cpu",kernelFunc:NT},TT=xC(hs,(e=>Math.atanh(e))),ET={kernelName:hs,backendName:"cpu",kernelFunc:TT};function RT(e,t,n,a,r,o){const s=r.strideHeight,i=r.strideWidth,c=r.dilationHeight,l=r.dilationWidth,u=r.effectiveFilterHeight,d=r.effectiveFilterWidth,h=r.padInfo.top,p=r.padInfo.left,f="max"===o?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,m=Od(r.outShape,n),g=m.values,b=r.outShape[1]*r.outShape[2]*r.outShape[3],y=r.outShape[2]*r.outShape[3],x=r.outShape[3];for(let v=0;v<r.batchSize;++v){const t=v*b,n=v*a[0];for(let m=0;m<r.inChannels;++m)for(let b=0;b<r.outHeight;++b){const v=b*s-h,w=Math.max(0,v),k=Math.min(r.inHeight,u+v),I=t+b*y;for(let t=0;t<r.outWidth;++t){const s=t*i-p,u=Math.max(0,s),h=Math.min(r.inWidth,d+s);let b=f,y=0,v=0;for(let t=w;t<k;t+=c){const r=n+t*a[1];for(let t=u;t<h;t+=l){const n=e[r+t*a[2]+m];"max"===o&&n>b?b=n:"avg"===o&&(y+=n,v++)}if(isNaN(b))break}g[I+t*x+m]="avg"===o?y/v:b}}}return m}function _T(e,t,n,a){let r=arguments.length>4&&void 0!==arguments[4]&&arguments[4],o=arguments.length>5&&void 0!==arguments[5]&&arguments[5];const s=Od(a.outShape,"int32"),i=a.strideHeight,c=a.strideWidth,l=a.dilationHeight,u=a.dilationWidth,d=a.effectiveFilterHeight,h=a.effectiveFilterWidth,p=a.padInfo.top,f=a.padInfo.left,m=Od(t,n,e);for(let g=0;g<a.batchSize;++g)for(let e=0;e<a.inChannels;++e)for(let t=0;t<a.outHeight;++t){const n=t*i-p;let b=n;for(;b<0;)b+=l;const y=Math.min(a.inHeight,d+n);for(let i=0;i<a.outWidth;++i){const d=i*c-f;let p=d;for(;p<0;)p+=u;const x=Math.min(a.inWidth,h+d);let v=Number.NEGATIVE_INFINITY,w=-1;for(let t=b;t<y;t+=l){const s=t-n;for(let n=p;n<x;n+=u){const i=n-d,c=m.get(g,t,n,e);c>v&&(v=c,w=r?o?((g*a.inHeight+t)*a.inWidth+n)*a.inChannels+e:(t*a.inWidth+n)*a.inChannels+e:s*h+i)}}s.set(w,g,t,i,e)}}return s}function AT(e,t,n,a,r,o){const s=r.strideDepth,i=r.strideHeight,c=r.strideWidth,l=r.dilationDepth,u=r.dilationHeight,d=r.dilationWidth,h=r.effectiveFilterDepth,p=r.effectiveFilterHeight,f=r.effectiveFilterWidth,m=r.padInfo.front,g=r.padInfo.top,b=r.padInfo.left,y="max"===o?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,x=Od(r.outShape,n),v=x.values,w=r.outShape[1]*r.outShape[2]*r.outShape[3]*r.outShape[4],k=r.outShape[2]*r.outShape[3]*r.outShape[4],I=r.outShape[3]*r.outShape[4],S=r.outShape[4];for(let N=0;N<r.batchSize;++N){const t=N*w,n=N*a[0];for(let x=0;x<r.inChannels;++x)for(let w=0;w<r.outDepth;++w){const N=w*s-m;let C=N;for(;C<0;)C+=l;const T=Math.min(r.inDepth,h+N),E=t+w*k;for(let t=0;t<r.outHeight;++t){const s=t*i-g;let h=s;for(;h<0;)h+=u;const m=Math.min(r.inHeight,p+s),w=E+t*I;for(let t=0;t<r.outWidth;++t){const s=t*c-b;let i=s;for(;i<0;)i+=d;const p=Math.min(r.inWidth,f+s),g=w+t*S;let k=y,I=0,N=0;for(let t=C;t<T;t+=l){const r=n+t*a[1];for(let t=h;t<m;t+=u){const n=r+t*a[2];for(let t=i;t<p;t+=d){const r=e[n+t*a[3]+x];if("max"===o&&r>k?k=r:"avg"===o&&(I+=r,N++),isNaN(k))break}if(isNaN(k))break}if(isNaN(k))break}v[g+x]="avg"===o?I/Math.max(N,1):k}}}}return x}const FT={kernelName:fs,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t;mC(r,"avgPool");const{filterSize:o,strides:s,pad:i,dimRoundingMode:c}=a;mo(ep(s,1),(()=>"Error in avgPool: Either strides or dilations must be 1. "+"Got strides ".concat(s," and dilations '").concat(1,"'")));const l=Hh(r.shape,o,s,1,i,c);let u;if(1===l.filterWidth&&1===l.filterHeight&&xo(l.inShape,l.outShape))u=IC({inputs:{x:r},backend:n});else{const e=n.data.get(r.dataId).values,t=Lo(r.shape),a=RT(e,r.shape,r.dtype,t,l,"avg");u=n.makeTensorInfo(l.outShape,r.dtype,a.values)}return u}};const OT={kernelName:gs,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{filterSize:o,strides:s,pad:i,dimRoundingMode:c,dataFormat:l}=a;mC(r,"avgPool3d");const u=jh(r.shape,o,s,1,i,c,l),d=AT(n.data.get(r.dataId).values,r.shape,r.dtype,Lo(r.shape),u,"avg");return n.makeTensorInfo(d.shape,"float32",d.values)}};const DT={kernelName:bs,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{dy:r,input:o}=t,{filterSize:s,strides:i,pad:c,dimRoundingMode:l}=a;mC([r,o],"avgPool3DGrad");const u=jh(o.shape,s,i,1,c,l),d=u.strideDepth,h=u.strideHeight,p=u.strideWidth,f=u.filterDepth,m=u.filterHeight,g=u.filterWidth,b=u.dilationDepth,y=u.dilationHeight,x=u.dilationWidth,v=u.effectiveFilterDepth,w=u.effectiveFilterHeight,k=u.effectiveFilterWidth,I=v-1-u.padInfo.front,S=k-1-u.padInfo.left,N=w-1-u.padInfo.top,C=Od(o.shape,"float32"),T=1/(f*m*g),E=n.bufferSync(r);for(let R=0;R<u.batchSize;++R)for(let e=0;e<u.inChannels;++e)for(let t=0;t<u.inDepth;++t)for(let n=0;n<u.inHeight;++n)for(let a=0;a<u.inWidth;++a){const r=t-I,o=n-N,s=a-S;let i=0;for(let t=0;t<v;t+=b){const n=(r+t)/d;if(!(n<0||n>=u.outDepth||Math.floor(n)!==n))for(let t=0;t<w;t+=y){const a=(o+t)/h;if(!(a<0||a>=u.outHeight||Math.floor(a)!==a))for(let t=0;t<k;t+=x){const r=(s+t)/p;if(r<0||r>=u.outWidth||Math.floor(r)!==r)continue;i+=E.get(R,n,a,r,e)}}}C.set(i*T,R,t,n,a,e)}return n.makeTensorInfo(C.shape,C.dtype,C.values)}};const MT={kernelName:ms,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{dy:r,input:o}=t,s=o;mC([r,o],"avgPoolGrad");const{filterSize:i,strides:c,pad:l}=a,u=Hh(s.shape,i,c,1,l),d=u.strideHeight,h=u.strideWidth,p=u.filterHeight,f=u.filterWidth,m=u.dilationHeight,g=u.dilationWidth,b=u.effectiveFilterHeight,y=u.effectiveFilterWidth,x=y-1-u.padInfo.left,v=b-1-u.padInfo.top,w=Od(s.shape,"float32"),k=1/(p*f),I=n.data.get(r.dataId).values,S=Od(r.shape,"float32",I);for(let N=0;N<u.batchSize;++N)for(let e=0;e<u.inChannels;++e)for(let t=0;t<u.inHeight;++t)for(let n=0;n<u.inWidth;++n){const a=t-v,r=n-x;let o=0;for(let t=0;t<b;t+=m){const n=(a+t)/d;if(!(n<0||n>=u.outHeight||Math.floor(n)!==n))for(let t=0;t<y;t+=g){const a=(r+t)/h;if(a<0||a>=u.outWidth||Math.floor(a)!==a)continue;o+=S.get(N,n,a,e)}}w.set(o*k,N,t,n,e)}return n.makeTensorInfo(w.shape,w.dtype,w.values)}};const LT={kernelName:ui,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r,scale:o,offset:s,mean:i,variance:c}=t;mo(i.shape.length===c.shape.length,(()=>"Batch normalization gradient requires mean and variance to have equal ranks.")),mo(null==s||i.shape.length===s.shape.length,(()=>"Batch normalization gradient requires mean and offset to have equal ranks.")),mo(null==o||i.shape.length===o.shape.length,(()=>"Batch normalization gradient requires mean and scale to have equal ranks.")),mC([r,i,c,o,s],"batchNorm");let{varianceEpsilon:l}=a;null==l&&(l=.001);const u=n.data.get(r.dataId).values,d=n.data.get(i.dataId).values,h=n.data.get(c.dataId).values,p=o?n.data.get(o.dataId).values:new Float32Array([1]),f=s?n.data.get(s.dataId).values:new Float32Array([0]),m=new Float32Array(u.length),g=f.length,b=p.length,y=h.length,x=d.length;let v=0,w=0,k=0,I=0;for(let S=0;S<u.length;++S)m[S]=f[v++]+(u[S]-d[w++])*p[k++]/Math.sqrt(h[I++]+l),v>=g&&(v=0),w>=x&&(w=0),k>=b&&(k=0),I>=y&&(I=0);return n.makeTensorInfo(r.shape,r.dtype,m)}};function PT(e,t,n,a,r){const o=Mh(a,t,n),s=yo(n),i=Lo(a);if(o){const n=Lh(t,i);return"string"===r?e.slice(n,n+s):e.subarray(n,n+s)}const c=Od(a,r,"string"===r?ab(e):e),l=Od(n,r);for(let u=0;u<l.size;++u){const e=l.indexToLoc(u),n=e.map(((e,n)=>e+t[n]));l.set(c.get(...n),...e)}return"string"===r?rb(l.values):l.values}function zT(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{begin:o,size:s}=a;mC(r,"slice");const[i,c]=Ph(r,o,s);Ih(r,i,c);const l=PT(n.data.get(r.dataId).values,i,c,r.shape,r.dtype);return n.makeTensorInfo(c,r.dtype,l)}const BT={kernelName:Nc,backendName:"cpu",kernelFunc:zT};const WT={kernelName:xs,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{blockShape:o,crops:s}=a;mC([r],"batchToSpaceND");const i=o.reduce(((e,t)=>e*t)),c=sg(r.shape,o,i),l=ig(c.length,o.length),u=cg(r.shape,o,i),d=lg(s,o.length),h=ug(u,s,o.length),p=$C({inputs:{x:r},backend:n,attrs:{shape:c}}),f=hT({inputs:{x:p},backend:n,attrs:{perm:l}}),m=$C({inputs:{x:f},backend:n,attrs:{shape:u}}),g=zT({inputs:{x:m},backend:n,attrs:{begin:d,size:h}});return n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),g}};function VT(e,t,n,a,r){const o=yo(a),s=Wo(r,n);for(let i=0;i<e.length;i++){const n=e[i];if(n<0)throw new Error("Input x must be non-negative!");n>=r||(s[n]+=o>0?t[i]:1)}return s}function UT(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const r=e.shape[0],o=e.shape[1],s=Od([r,n],t.dtype);for(let i=0;i<r;i++)for(let r=0;r<o;r++){const o=e.get(i,r);if(o<0)throw new Error("Input x must be non-negative!");o>=n||(a?s.set(1,i,o):t.size>0?s.set(s.get(i,o)+t.get(i,r),i,o):s.set(s.get(i,o)+1,i,o))}return s}const GT={kernelName:vs,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r,weights:o}=t,{size:s}=a,i=VT(n.data.get(r.dataId).values,n.data.get(o.dataId).values,o.dtype,o.shape,s);return n.makeTensorInfo([s],o.dtype,i)}},HT=TC(((e,t)=>e&t)),jT={kernelName:ws,backendName:"cpu",kernelFunc:qC(ws,HT)};const KT={kernelName:ks,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{s0:a,s1:r}=t,o=n.data.get(a.dataId).values,s=n.data.get(r.dataId).values,i=sh(Array.from(o),Array.from(s));return n.makeTensorInfo([i.length],"int32",Int32Array.from(i))}},qT=yC((e=>Math.ceil(e))),XT=vC(Ss,qT),YT={kernelName:Ss,backendName:"cpu",kernelFunc:XT},QT=xC(Ns,((e,t)=>{const n=t;return e>n.clipValueMax?n.clipValueMax:e<n.clipValueMin?n.clipValueMin:e})),JT={kernelName:Ns,backendName:"cpu",kernelFunc:QT},ZT={kernelName:Ts,backendName:"cpu",kernelFunc:e=>{const{x:t}=e.inputs,n=e.backend,a=new Float32Array(yo(t.shape)),r=n.data.get(t.dataId),o=r.complexTensorInfos.real,s=r.complexTensorInfos.imag,i=n.data.get(o.dataId).values,c=n.data.get(s.dataId).values;for(let l=0;l<i.length;l++){const e=i[l],t=c[l];a[l]=Math.hypot(e,t)}return n.makeOutput(a,t.shape,"float32")}};function $T(e,t,n,a){const r=Eo(n,yo(t));if(a&&"string"!==n){let t=0;e.forEach((e=>{const n=yo(e.shape);r.set(e.vals,t),t+=n}))}else{let a=0;e.forEach((e=>{const o="string"===n?ab(e.vals):e.vals;let s=0;for(let n=0;n<e.shape[0];++n){const i=n*t[1]+a;for(let t=0;t<e.shape[1];++t)r[i+t]=o[s++]}a+=e.shape[1]}))}return r}function eE(e){const{inputs:t,backend:n}=e,{input:a}=t,r=n.data.get(a.dataId).complexTensorInfos.imag,o=n.data.get(r.dataId).values;return n.makeTensorInfo(r.shape,r.dtype,o)}const tE={kernelName:bi,backendName:"cpu",kernelFunc:eE};function nE(e){const{inputs:t,backend:n,attrs:a}=e,{axis:r}=a,o=No(r,t[0].shape)[0],s=t.map((e=>e.shape));Qm(s,o);let i=Jm(t.map((e=>e.shape)),o);if(0===yo(i))return n.makeTensorInfo(i,t[0].dtype,[]);const c=t.filter((e=>yo(e.shape)>0));if(1===c.length)return IC({inputs:{x:c[0]},backend:n});if("complex64"===c[0].dtype){const e=c.map((e=>UC({inputs:{input:e},backend:n}))),t=c.map((e=>eE({inputs:{input:e},backend:n}))),a=nE({inputs:e,backend:n,attrs:{axis:o}}),r=nE({inputs:t,backend:n,attrs:{axis:o}}),s=BC({inputs:{real:a,imag:r},backend:n});return e.forEach((e=>n.disposeIntermediateTensorInfo(e))),t.forEach((e=>n.disposeIntermediateTensorInfo(e))),n.disposeIntermediateTensorInfo(a),n.disposeIntermediateTensorInfo(r),s}const l=c.map((e=>{const t=yo(e.shape.slice(o));return $C({inputs:{x:e},backend:n,attrs:{shape:[-1,t]}})})),u=l.map((e=>({vals:n.data.get(e.dataId).values,shape:e.shape})));i=Jm(l.map((e=>e.shape)),1);const d=1===l[0].shape[0],h=$T(u,i,t[0].dtype,d),p=Jm(c.map((e=>e.shape)),o),f=n.makeTensorInfo(p,t[0].dtype,h);return l.forEach((e=>n.disposeIntermediateTensorInfo(e))),f}const aE={kernelName:Es,backendName:"cpu",kernelFunc:nE};function rE(e){const{inputs:t,backend:n,attrs:a}=e,{x:r,filter:o}=t,{strides:s,pad:i,dataFormat:c,dilations:l,dimRoundingMode:u}=a;mC([r,o],"conv2d");const d=np(c),h=Kh(r.shape,o.shape,s,l,i,u,!1,d),p=h.filterHeight,f=h.filterWidth,m=h.dilationHeight,g=h.dilationWidth,b=h.padInfo.left,y=h.padInfo.top,x="channelsLast"===h.dataFormat,v=new tu(h.outShape,r.dtype),w=Lo(r.shape),k=Lo(o.shape),I=w[0],S=x?w[1]:w[2],N=x?w[2]:1,C=x?1:w[1],T=v.strides[0],E=x?v.strides[1]:v.strides[2],R=x?v.strides[2]:1,_=x?1:v.strides[1],A=n.data.get(r.dataId).values,F=n.data.get(o.dataId).values,O=v.values;for(let D=0;D<h.batchSize;++D){const e=D*I,t=D*T;for(let n=0;n<h.outHeight;++n){const a=t+n*E,r=n*h.strideHeight-y;for(let t=0;t<p;++t){const n=r+t*m;if(n<0||n>=h.inHeight)continue;const o=t*k[0],s=e+n*S;for(let e=0;e<h.outWidth;++e){const t=a+e*R,n=e*h.strideWidth-b;for(let e=0;e<f;++e){const a=n+e*g;if(a<0||a>=h.inWidth)continue;const r=s+a*N;let i=o+e*k[1];for(let e=0;e<h.inChannels;++e){const n=A[r+e*C];for(let e=0;e<h.outChannels;++e)O[t+e*_]+=n*F[i+e];i+=h.outChannels}}}}}}return n.makeTensorInfo(v.shape,v.dtype,O)}const oE={kernelName:Rs,backendName:"cpu",kernelFunc:rE};const sE={kernelName:_s,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r,dy:o}=t,{strides:s,pad:i,dataFormat:c,dimRoundingMode:l,filterShape:u}=a;mC([r,o],"conv2dBackpropFilter");const d=np(c),h=Kh(r.shape,u,s,1,i,l,!1,d),{strideHeight:p,strideWidth:f,filterHeight:m,filterWidth:g}=h,b="channelsLast"===h.dataFormat,y=new tu(h.filterShape,"float32"),x=h.padInfo.left,v=h.padInfo.top,w=n.data.get(r.dataId).values,k=n.data.get(o.dataId).values,I=new tu(r.shape,r.dtype,w),S=new tu(o.shape,o.dtype,k);for(let N=0;N<m;++N){const e=Math.max(0,Math.ceil((v-N)/p)),t=Math.min(h.outHeight,(h.inHeight+v-N)/p);for(let n=0;n<g;++n){const a=Math.max(0,Math.ceil((x-n)/f)),r=Math.min(h.outWidth,(h.inWidth+x-n)/f);for(let o=0;o<h.inChannels;++o)for(let s=0;s<h.outChannels;++s){let i=0;for(let c=0;c<h.batchSize;++c)for(let l=e;l<t;++l){const e=N+l*p-v;for(let t=a;t<r;++t){const a=n+t*f-x;i+=b?I.get(c,e,a,o)*S.get(c,l,t,s):I.get(c,o,e,a)*S.get(c,s,l,t)}}y.set(i,N,n,o,s)}}}return n.makeTensorInfo(y.shape,y.dtype,y.values)}};const iE={kernelName:As,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{dy:r,filter:o}=t,{inputShape:s,strides:i,pad:c,dataFormat:l,dimRoundingMode:u}=a;mC([r,o],"conv2dBackpropInput");const d=Lo(o.shape),h=Lo(r.shape);let p=np(l);const f=Kh(s,o.shape,i,1,c,u,!1,p),m=new tu(f.inShape,"float32"),g=m.values,b=n.data.get(r.dataId).values,y=n.data.get(o.dataId).values,[x,v,w]=d,{batchSize:k,filterHeight:I,filterWidth:S,inChannels:N,inHeight:C,inWidth:T,outChannels:E,outHeight:R,outWidth:_,strideHeight:A,strideWidth:F}=f;p=f.dataFormat;const O=I-1-f.padInfo.top,D=S-1-f.padInfo.left,M="channelsLast"===p,L=m.strides[0],P=M?m.strides[1]:m.strides[2],z=M?m.strides[2]:1,B=M?1:m.strides[1],W=h[0],V=M?h[1]:h[2],U=M?h[2]:1,G=M?1:h[1];for(let H=0;H<k;++H)for(let e=0;e<N;++e)for(let t=0;t<C;++t){const n=t-O,a=Math.max(0,Math.ceil(n/A)),r=Math.min(R,(I+n)/A);for(let o=0;o<T;++o){const s=o-D,i=Math.max(0,Math.ceil(s/F)),c=Math.min(_,(S+s)/F);let l=0;for(let t=a;t<r;++t){const a=t*A-n;for(let n=i;n<c;++n){const r=W*H+V*t+U*n,o=x*(I-1-a)+v*(S-1-(n*F-s))+w*e;for(let e=0;e<E;++e){l+=b[r+G*e]*y[o+e]}}}g[L*H+P*t+z*o+B*e]=l}}return n.makeTensorInfo(m.shape,m.dtype,m.values)}};const cE={kernelName:Fs,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r,filter:o}=t,{strides:s,pad:i,dilations:c}=a;mC([r,o],"conv3d");const l=qh(r.shape,o.shape,s,c,i),{filterDepth:u,filterHeight:d,filterWidth:h,dilationDepth:p,dilationHeight:f,dilationWidth:m,padInfo:g}=l,b=g.front,y=g.left,x=g.top,v=new tu(l.outShape,r.dtype),w=n.data.get(r.dataId).values,k=n.data.get(o.dataId).values,I=v.values,S=Lo(r.shape),N=Lo(o.shape);for(let C=0;C<l.batchSize;++C){const e=C*S[0],t=C*v.strides[0];for(let n=0;n<l.outDepth;++n){const a=t+n*v.strides[1],r=n*l.strideDepth-b;for(let t=0;t<u;++t){const n=r+t*p;if(n<0||n>=l.inDepth)continue;const o=t*N[0],s=e+n*S[1];for(let e=0;e<l.outHeight;++e){const t=a+e*v.strides[2],n=e*l.strideHeight-x;for(let e=0;e<d;++e){const a=n+e*f;if(a<0||a>=l.inHeight)continue;const r=o+e*N[1],i=s+a*S[2];for(let e=0;e<l.outWidth;++e){const n=t+e*l.outChannels,a=e*l.strideWidth-y;for(let e=0;e<h;++e){const t=a+e*m;if(t<0||t>=l.inWidth)continue;const o=r+e*N[2],s=i+t*l.inChannels;let c=o;for(let e=0;e<l.inChannels;++e){const t=w[s+e];for(let e=0;e<l.outChannels;++e)I[n+e]+=t*k[c+e];c+=l.outChannels}}}}}}}}return n.makeTensorInfo(v.shape,v.dtype,v.values)}};const lE={kernelName:Os,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r,dy:o}=t,{strides:s,pad:i,filterShape:c}=a;mC([r,o],"conv3dBackpropFilterV2");const l=Lo(r.shape),u=Lo(o.shape),d=qh(r.shape,c,s,1,i),h=d.strideDepth,p=d.strideHeight,f=d.strideWidth,m=d.filterDepth,g=d.filterHeight,b=d.filterWidth,y=new tu(d.filterShape,"float32"),x=y.values,[v,w,k,I]=y.strides,S=n.data.get(o.dataId).values,[N,C,T,E]=u,R=n.data.get(r.dataId).values,[_,A,F,O]=l,D=d.padInfo.front,M=d.padInfo.left,L=d.padInfo.top;for(let P=0;P<m;++P){const e=Math.max(0,Math.ceil((D-P)/h)),t=Math.min(d.outDepth,(d.inDepth+D-P)/h),n=P*v;for(let a=0;a<g;++a){const r=Math.max(0,Math.ceil((L-a)/p)),o=Math.min(d.outHeight,(d.inHeight+L-a)/p),s=a*w+n;for(let n=0;n<b;++n){const i=Math.max(0,Math.ceil((M-n)/f)),c=Math.min(d.outWidth,(d.inWidth+M-n)/f),l=n*k+s;for(let s=0;s<d.inChannels;++s){const u=s*I+l;for(let l=0;l<d.outChannels;++l){let m=0;for(let u=0;u<d.batchSize;++u){const d=u*_,g=u*N;for(let u=e;u<t;++u){const e=(P+u*h-D)*A+d,t=u*C+g;for(let u=r;u<o;++u){const r=(a+u*p-L)*F+e,o=u*T+t;for(let e=i;e<c;++e){const t=e*E+o;m+=R[(n+e*f-M)*O+r+s]*S[t+l]}}}}x[u+l]=m}}}}}return n.makeTensorInfo(y.shape,y.dtype,y.values)}};const uE={kernelName:Ds,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{dy:r,filter:o}=t,{pad:s,strides:i,inputShape:c}=a;mC([r],"conv3dBackpropInputV2");const l=Lo(r.shape),u=Lo(o.shape),d=qh(c,o.shape,i,1,s),h=new tu(d.inShape,"float32"),p=h.values,[f,m,g,b]=h.strides,y=n.data.get(r.dataId).values,[x,v,w,k]=l,I=n.data.get(o.dataId).values,[S,N,C,T]=u,{batchSize:E,filterDepth:R,filterHeight:_,filterWidth:A,inChannels:F,inDepth:O,inHeight:D,inWidth:M,outChannels:L,outDepth:P,outHeight:z,outWidth:B,strideDepth:W,strideHeight:V,strideWidth:U}=d,G=R-1-d.padInfo.front,H=_-1-d.padInfo.top,j=A-1-d.padInfo.left;for(let K=0;K<E;++K)for(let e=0;e<F;++e)for(let t=0;t<O;++t){const n=t-G,a=Math.max(0,Math.ceil(n/W)),r=Math.min(P,(R+n)/W);for(let o=0;o<D;++o){const s=o-H,i=Math.max(0,Math.ceil(s/V)),c=Math.min(z,(_+s)/V);for(let l=0;l<M;++l){const u=l-j,d=Math.max(0,Math.ceil(u/U)),h=Math.min(B,(A+u)/U);let E=0;for(let t=a;t<r;++t){const a=t*W-n;for(let n=i;n<c;++n){const r=n*V-s;for(let o=d;o<h;++o){const s=x*K+v*t+w*n+k*o,i=S*(R-1-a)+N*(_-1-r)+C*(A-1-(o*U-u))+T*e;for(let e=0;e<L;++e){E+=y[s+e]*I[i+e]}}}}p[f*K+m*t+g*o+b*l+e]=E}}}return n.makeTensorInfo(h.shape,h.dtype,h.values)}},dE=xC(Ms,(e=>Math.cos(e))),hE={kernelName:Ms,backendName:"cpu",kernelFunc:dE},pE=xC(Ls,(e=>Math.cosh(e))),fE={kernelName:Ls,backendName:"cpu",kernelFunc:pE};const mE={kernelName:Bs,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{image:r,boxes:o,boxInd:s}=t,{cropSize:i,method:c,extrapolationValue:l}=a,[u,d,h,p]=r.shape,f=o.shape[0],[m,g]=i,b=Od([f,m,g,p],"float32"),y=n.data.get(o.dataId).values,x=n.data.get(s.dataId).values,v=n.data.get(r.dataId).values,w=Lo(r.shape),k=Lo(b.shape);for(let I=0;I<f;I++){const e=4*I,t=y[e],n=y[e+1],a=y[e+2],r=y[e+3],o=x[I];if(o>=u)continue;const s=m>1?(a-t)*(d-1)/(m-1):0,i=g>1?(r-n)*(h-1)/(g-1):0;for(let u=0;u<m;u++){const e=m>1?t*(d-1)+u*s:.5*(t+a)*(d-1);if(e<0||e>d-1)for(let t=0;t<g;t++)for(let e=0;e<p;e++){const n=e+t*k[2]+u*k[1]+I*k[0];b.values[n]=l}else if("bilinear"===c){const t=Math.floor(e),a=Math.ceil(e),s=e-t;for(let e=0;e<g;e++){const c=g>1?n*(h-1)+e*i:.5*(n+r)*(h-1);if(c<0||c>h-1){for(let t=0;t<p;t++){const n=t+e*k[2]+u*k[1]+I*k[0];b.values[n]=l}continue}const d=Math.floor(c),f=Math.ceil(c),m=c-d;for(let n=0;n<p;n++){let r=n+d*w[2]+t*w[1]+o*w[0];const i=v[r];r=n+f*w[2]+t*w[1]+o*w[0];const c=v[r];r=n+d*w[2]+a*w[1]+o*w[0];const l=v[r];r=n+f*w[2]+a*w[1]+o*w[0];const h=i+(c-i)*m,p=l+(v[r]-l)*m;r=n+e*k[2]+u*k[1]+I*k[0],b.values[r]=h+(p-h)*s}}}else for(let t=0;t<g;++t){const a=g>1?n*(h-1)+t*i:.5*(n+r)*(h-1);if(a<0||a>h-1){for(let e=0;e<p;e++){const n=e+t*k[2]+u*k[1]+I*k[0];b.values[n]=l}continue}const s=Math.round(a),c=Math.round(e);for(let e=0;e<p;e++){const n=e+s*w[2]+c*w[1]+o*w[0],a=e+t*k[2]+u*k[1]+I*k[0];b.values[a]=v[n]}}}}return n.makeTensorInfo(b.shape,b.dtype,b.values)}};const gE={kernelName:Ps,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{axis:o,exclusive:s,reverse:i}=a;mC(r,"cumprod");const c=Xp([o],r.shape.length);let l=r;null!=c&&(l=hT({inputs:{x:r},backend:n,attrs:{perm:c}}));const u=Qp(1,r.shape.length)[0];if(u!==l.shape.length-1)throw new Error("backend.cumprod in CPU expects an inner-most "+"axis=".concat(l.shape.length-1," but got axis=").concat(u));const d=fu(l.dtype,"int32"),h=Bo(yo(l.shape),d),p=n.data.get(l.dataId).values,f=l.shape[l.shape.length-1],m=i?(e,t)=>e+f-t-1:(e,t)=>e+t;for(let b=0;b<p.length;b+=f)for(let e=0;e<f;e++){const t=m(b,e);if(0===e)h[t]=s?1:p[t];else{const n=m(b,e-1);h[t]=s?p[n]*h[n]:p[t]*h[n]}}const g=n.makeTensorInfo(l.shape,d,h);if(null!=c){const e=hT({inputs:{x:g},backend:n,attrs:{perm:Yp(c)}});return n.disposeIntermediateTensorInfo(g),n.disposeIntermediateTensorInfo(l),e}return g}};const bE={kernelName:zs,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{axis:o,exclusive:s,reverse:i}=a;mC(r,"cumsum");const c=Xp([o],r.shape.length);let l=r;null!=c&&(l=hT({inputs:{x:r},backend:n,attrs:{perm:c}}));const u=Qp(1,r.shape.length)[0];if(u!==l.shape.length-1)throw new Error("backend.cumsum in CPU expects an inner-most "+"axis=".concat(l.shape.length-1," but got axis=").concat(u));const d=fu(l.dtype,"int32"),h=Wo(yo(l.shape),d),p=n.data.get(l.dataId).values,f=l.shape[l.shape.length-1],m=i?(e,t)=>e+f-t-1:(e,t)=>e+t;for(let b=0;b<p.length;b+=f)for(let e=0;e<f;e++){const t=m(b,e);if(0===e)h[t]=s?0:p[t];else{const n=m(b,e-1);h[t]=s?p[n]+h[n]:p[t]+h[n]}}const g=n.makeTensorInfo(l.shape,d,h);if(null!=c){const e=hT({inputs:{x:g},backend:n,attrs:{perm:Yp(c)}});return n.disposeIntermediateTensorInfo(g),n.disposeIntermediateTensorInfo(l),e}return g}};const yE={kernelName:Ws,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r,weights:o}=t,{size:s,binaryOutput:i}=a;if(1===r.shape.length){const e=VT(n.data.get(r.dataId).values,n.data.get(o.dataId).values,o.dtype,o.shape,s);return n.makeTensorInfo([s],o.dtype,e)}if(2===r.shape.length){const e=UT(n.bufferSync(r),n.bufferSync(o),s,i);return n.makeTensorInfo(e.shape,o.dtype,e.values)}throw new Error("Error in denseBincount: input must be at most rank 2, but got rank"+"".concat(r.shape.length,"."))}};const xE={kernelName:Vs,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{blockSize:o,dataFormat:s}=a;mo("NHWC"===s,(()=>"Only NHWC dataFormat supported on CPU for depthToSpace. Got ".concat(s)));const i=r.shape[0],c=r.shape[1],l=r.shape[2],u=r.shape[3],d=c*o,h=l*o,p=u/(o*o),f=n.data.get(r.dataId).values,m=new Float32Array(i*d*h*p);let g=0;for(let b=0;b<i;++b)for(let e=0;e<d;++e){const t=Math.floor(e/o),n=e%o;for(let e=0;e<h;++e){const a=Math.floor(e/o),r=(n*o+e%o)*p;for(let e=0;e<p;++e){const n=e+r+u*(a+l*(t+c*b));m[g++]=f[n]}}}return n.makeTensorInfo([i,d,h,p],r.dtype,m)}};function vE(e){const{inputs:t,backend:n,attrs:a}=e,{x:r,filter:o}=t,{strides:s,pad:i,dilations:c,dimRoundingMode:l}=a;mC([r,o],"depthwiseConv2DNative");const u=Lo(r.shape),d=Lo(o.shape);let h=c;null==h&&(h=[1,1]),mo(ep(s,h),(()=>"Error in depthwiseConv2d: Either strides or dilations must be "+"1. Got strides ".concat(s," and dilations '").concat(h,"'")));const p=Kh(r.shape,o.shape,s,h,i,l,!0),{filterHeight:f,filterWidth:m,dilationHeight:g,dilationWidth:b,padInfo:y}=p,x=y.left,v=y.top,w=p.outChannels/p.inChannels,k=new tu(p.outShape,r.dtype),I=n.data.get(r.dataId).values,S=n.data.get(o.dataId).values,N=k.values;for(let C=0;C<p.batchSize;++C){const e=C*u[0],t=C*k.strides[0];for(let n=0;n<p.outHeight;++n){const a=t+n*k.strides[1],r=n*p.strideHeight-v;for(let t=0;t<f;++t){const n=r+t*g;if(n<0||n>=p.inHeight)continue;const o=t*d[0],s=e+n*u[1];for(let e=0;e<p.outWidth;++e){const t=a+e*k.strides[2],n=e*p.strideWidth-x;for(let e=0;e<m;++e){const a=n+e*b;if(a<0||a>=p.inWidth)continue;const r=o+e*d[1],i=s+a*p.inChannels;let c=t,l=r;for(let e=0;e<p.inChannels;++e){const t=I[i+e];for(let e=0;e<w;++e)N[c+e]+=t*S[l+e];c+=w,l+=w}}}}}}return n.makeTensorInfo(k.shape,k.dtype,k.values)}const wE={kernelName:Us,backendName:"cpu",kernelFunc:vE};const kE={kernelName:Gs,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r,dy:o}=t,{strides:s,dilations:i,pad:c,dimRoundingMode:l,filterShape:u}=a;mC([r,o],"depthwiseConv2dNativeBackpropFilter");const d=Kh(r.shape,u,s,i,c,l,!0),{strideHeight:h,strideWidth:p,filterHeight:f,filterWidth:m}=d,g=new tu(d.filterShape,"float32"),b=d.padInfo.left,y=d.padInfo.top,x=d.outChannels/d.inChannels,v=n.data.get(r.dataId).values,w=new tu(r.shape,r.dtype,v),k=n.data.get(o.dataId).values,I=new tu(o.shape,o.dtype,k);for(let S=0;S<f;++S){const e=Math.max(0,Math.ceil((y-S)/h)),t=Math.min(d.outHeight,(d.inHeight+y-S)/h);for(let n=0;n<m;++n){const a=Math.max(0,Math.ceil((b-n)/p)),r=Math.min(d.outWidth,(d.inWidth+b-n)/p);for(let o=0;o<d.outChannels;++o){const s=Math.trunc(o/x),i=o%x;let c=0;for(let l=0;l<d.batchSize;++l)for(let i=e;i<t;++i){const e=S+i*h-y;for(let t=a;t<r;++t){const a=n+t*p-b;c+=w.get(l,e,a,s)*I.get(l,i,t,o)}}g.set(c,S,n,s,i)}}}return n.makeTensorInfo(g.shape,g.dtype,g.values)}};const IE={kernelName:Hs,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{dy:r,filter:o}=t,{strides:s,dilations:i,pad:c,dimRoundingMode:l,inputShape:u}=a;mC([r,o],"depthwiseConv2DNativeBackpropInput");const d=Lo(r.shape),h=Lo(o.shape),p=Kh(u,o.shape,s,i,c,l,!0),f=new tu(p.inShape,"float32"),m=f.values,[g,b,y]=f.strides,x=n.data.get(r.dataId).values,[v,w,k]=d,I=n.data.get(o.dataId).values,[S,N,C]=h,{batchSize:T,filterHeight:E,filterWidth:R,inChannels:_,inHeight:A,inWidth:F,outChannels:O,outHeight:D,outWidth:M,strideHeight:L,strideWidth:P}=p,z=E-1-p.padInfo.top,B=R-1-p.padInfo.left,W=O/_;for(let V=0;V<T;++V)for(let e=0;e<_;++e)for(let t=0;t<A;++t){const n=t-z,a=Math.max(0,Math.ceil(n/L)),r=Math.min(D,(E+n)/L);for(let o=0;o<F;++o){const s=o-B,i=Math.max(0,Math.ceil(s/P)),c=Math.min(M,(R+s)/P);let l=0;for(let t=a;t<r;++t){const a=t*L-n;for(let n=i;n<c;++n){const r=v*V+w*t+k*n,o=S*(E-1-a)+N*(R-1-(n*P-s))+C*e;for(let t=0;t<W;++t){l+=x[r+(e*W+t)]*I[o+t]}}}m[g*V+b*t+y*o+e]=l}}return n.makeTensorInfo(f.shape,f.dtype,f.values)}};const SE={kernelName:js,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{x:a}=t,r=yo(a.shape),o=n.data.get(a.dataId).values,s=Od([r,r],a.dtype),i=s.values;for(let l=0;l<o.length;l++)i[l*r+l]=o[l];const c=[...a.shape,...a.shape];return n.makeTensorInfo(c,s.dtype,s.values)}},NE={kernelName:Ks,backendName:"cpu",kernelFunc:e=>{let{inputs:t,backend:n,attrs:a}=e;const{x:r,filter:o}=t,{strides:s,pad:i,dilations:c}=a,l=n,u=l.data.get(r.dataId).values,d=r.shape.length,h=l.data.get(o.dataId).values,p=o.shape.length,{batchSize:f,inHeight:m,inWidth:g,inChannels:b,outHeight:y,outWidth:x,padInfo:v,strideHeight:w,strideWidth:k,filterHeight:I,filterWidth:S,dilationHeight:N,dilationWidth:C,outShape:T}=Gh(r.shape,o.shape,s,i,"NHWC",c),E=yo(T),R=T.length,_=Eo(r.dtype,E);for(let A=0;A<f;++A)for(let e=0;e<y;++e){const t=e*w-v.top;for(let n=0;n<x;++n){const a=n*k-v.left;for(let s=0;s<b;++s){let i=Number.MIN_SAFE_INTEGER;for(let e=0;e<I;++e){const n=t+e*N;if(n>=0&&n<m)for(let t=0;t<S;++t){const c=a+t*C;if(c>=0&&c<g){const a=Go([A,n,c,s],d,Lo(r.shape)),l=Go([e,t,s],p,Lo(o.shape)),f=u[a]+h[l];f>i&&(i=f)}}}_[Go([A,e,n,s],R,Lo(T))]=i}}}return{dataId:l.write(zl(_,r.dtype),T,r.dtype),shape:T,dtype:r.dtype}}},CE={kernelName:Xs,backendName:"cpu",kernelFunc:e=>{let{inputs:t,backend:n,attrs:a}=e;const{x:r,filter:o,dy:s}=t,{strides:i,pad:c,dilations:l}=a,u=n,d=zo(r.shape,u.data.get(r.dataId).values),h=zo(o.shape,u.data.get(o.dataId).values),{batchSize:p,inHeight:f,inWidth:m,inChannels:g,outHeight:b,outWidth:y,padInfo:x,strideHeight:v,strideWidth:w,filterHeight:k,filterWidth:I,dilationHeight:S,dilationWidth:N,outShape:C}=Gh(r.shape,o.shape,i,c,"NHWC",l);mo(s.rank===C.length,(()=>"Error in ".concat(Xs,", dy ")+"must have the same rank as output ".concat(C.length,", but got ")+"".concat(s.rank)));const T=zo(C,u.data.get(s.dataId).values),E=Vo(o.shape,o.dtype);for(let R=0;R<p;++R)for(let e=0;e<b;++e){const t=e*v-x.top;for(let n=0;n<y;++n){const a=n*w-x.left;for(let r=0;r<g;++r){let o=Number.MIN_SAFE_INTEGER,s=0,i=0;for(let e=0;e<k;++e){const n=t+e*S;if(n>=0&&n<f)for(let t=0;t<I;++t){const c=a+t*N;if(c>=0&&c<m){const a=d[R][n][c][r]+h[e][t][r];a>o&&(o=a,s=e,i=t)}}}E[s][i][r]+=T[R][e][n][r]}}}return{dataId:u.write(zl(E,r.dtype),o.shape,o.dtype),shape:o.shape,dtype:o.dtype}}},TE={kernelName:qs,backendName:"cpu",kernelFunc:e=>{let{inputs:t,backend:n,attrs:a}=e;const{x:r,filter:o,dy:s}=t,{strides:i,pad:c,dilations:l}=a,u=n,d=zo(r.shape,u.data.get(r.dataId).values),h=zo(o.shape,u.data.get(o.dataId).values),{batchSize:p,inHeight:f,inWidth:m,inChannels:g,outHeight:b,outWidth:y,padInfo:x,strideHeight:v,strideWidth:w,filterHeight:k,filterWidth:I,dilationHeight:S,dilationWidth:N,outShape:C}=Gh(r.shape,o.shape,i,c,"NHWC",l);mo(s.rank===C.length,(()=>"Error in ".concat(qs,", dy ")+"must have the same rank as output ".concat(C.length,", but got ")+"".concat(s.rank)));const T=zo(C,u.data.get(s.dataId).values),E=Vo(r.shape,r.dtype);for(let R=0;R<p;++R)for(let e=0;e<b;++e){const t=e*v-x.top;for(let n=0;n<y;++n){const a=n*w-x.left;for(let r=0;r<g;++r){let o=Number.MIN_SAFE_INTEGER,s=t<0?0:t,i=a<0?0:a;for(let e=0;e<k;++e){const n=t+e*S;if(n>=0&&n<f)for(let t=0;t<I;++t){const c=a+t*N;if(c>=0&&c<m){const a=d[R][n][c][r]+h[e][t][r];a>o&&(o=a,s=n,i=c)}}}E[R][s][i][r]+=T[R][e][n][r]}}}return{dataId:u.write(zl(E,r.dtype),r.shape,r.dtype),shape:r.shape,dtype:r.dtype}}};const EE={kernelName:Ys,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{image:r}=t,{canvas:o,options:s}=a,{contextOptions:i,imageOptions:c}=s||{},l=(null===c||void 0===c?void 0:c.alpha)||1,u=(null===i||void 0===i?void 0:i.contextType)||"2d";if("2d"!==u)throw new Error("Context type ".concat(i.contextType," is not supported by the CPU backend."));const d=o.getContext(u,(null===i||void 0===i?void 0:i.contextAttributes)||{});if(null==d)throw new Error("Could not get the context with ".concat(u," type."));const[h,p]=r.shape.slice(0,2),f=2===r.shape.length?1:r.shape[2],m=n.data.get(r.dataId).values,g="float32"===r.dtype?255:1,b=new Uint8ClampedArray(p*h*4);for(let x=0;x<h*p;++x){const e=[0,0,0,255*l];for(let n=0;n<f;n++){const t=m[x*f+n];if("float32"===r.dtype){if(t<0||t>1)throw new Error("Tensor values for a float32 Tensor must be in the "+"range [0 - 1] but encountered ".concat(t,"."))}else if("int32"===r.dtype&&(t<0||t>255))throw new Error("Tensor values for a int32 Tensor must be in the "+"range [0 - 255] but encountered ".concat(t,"."));1===f?(e[0]=t*g,e[1]=t*g,e[2]=t*g):e[n]=t*g}const t=4*x;b[t+0]=Math.round(e[0]),b[t+1]=Math.round(e[1]),b[t+2]=Math.round(e[2]),b[t+3]=Math.round(e[3])}o.width=p,o.height=h;const y=new ImageData(b,p,h);return d.putImageData(y,0,0),r}},RE=TC(((e,t)=>e*t)),_E=XC(((e,t,n,a)=>({real:e*n-t*a,imag:e*a+t*n}))),AE=qC(ji,RE,_E),FE={kernelName:ji,backendName:"cpu",kernelFunc:AE};function OE(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{axis:o,keepDims:s}=a;let i;mC(r,"sum"),i="bool"===r.dtype?jC({inputs:{x:r},backend:n,attrs:{dtype:"int32"}}):IC({inputs:{x:r},backend:n});const c=i.shape.length,l=No(o,i.shape),u=Xp(l,c);let d=l,h=i;null!=u&&(h=hT({inputs:{x:i},backend:n,attrs:{perm:u}}),d=Qp(d.length,c)),qp("sum",d,h.shape.length);const[p,f]=jp(h.shape,d);let m=VC(n,p,fu(h.dtype,"int32"));const g=yo(f),b=n.data.get(m.dataId).values,y=n.data.get(h.dataId).values;for(let x=0;x<b.length;++x){const e=x*g;let t=0;for(let n=0;n<g;++n)t+=y[e+n];b[x]=t}if(s){const e=m;m=$C({inputs:{x:m},backend:n,attrs:{shape:Kp(m.shape,l)}}),n.disposeIntermediateTensorInfo(e)}return n.disposeIntermediateTensorInfo(i),null!=u&&n.disposeIntermediateTensorInfo(h),m}const DE={kernelName:Fc,backendName:"cpu",kernelFunc:OE};const ME={kernelName:Js,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{equation:r}=a,o=t,{allDims:s,summedDims:i,idDims:c}=Mg(r,o.length);Pg(s.length,c,o);const{path:l,steps:u}=zg(i,c),d=u.length;let h=null,p=s.length;const f=[];for(let m=0;m<d;++m){for(const e of u[m]){const{permutationIndices:t,expandDims:a}=Lg(p,c[e]);let r;Bg(t)?r=o[e]:(r=hT({inputs:{x:o[e]},backend:n,attrs:{perm:t}}),f.push(r));const s=r.shape.slice();for(let e=0;e<a.length;++e)s.splice(a[e],0,1);xo(r.shape,s)||(r=$C({inputs:{x:r},backend:n,attrs:{shape:s}}),f.push(r)),null===h?h=r:(h=AE({inputs:{a:r,b:h},backend:n}),f.push(h))}m<d-1&&(l[m]>=0&&(h=OE({inputs:{x:h},backend:n,attrs:{axis:l[m]-(s.length-p),keepDims:!1}}),f.push(h)),p--)}for(const m of f)m!==h&&n.disposeIntermediateTensorInfo(m);return h}};const LE={kernelName:$s,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{dy:a,y:r}=t;mC([a,r],"eluGrad");const o=new Float32Array(yo(r.shape)),s=n.data.get(r.dataId).values,i=n.data.get(a.dataId).values;for(let c=0;c<s.length;++c){const e=s[c];o[c]=e>=0?i[c]:i[c]*(e+1)}return n.makeTensorInfo(r.shape,"float32",o)}},PE=TC(((e,t)=>e===t?1:0)),zE=qC(ti,PE,null,"bool"),BE={kernelName:ti,backendName:"cpu",kernelFunc:zE},WE=bg,VE=yg,UE=xg,GE=vg,HE=wg,jE=kg,KE=xC(ei,(e=>{const t=Math.sign(e),n=Math.abs(e),a=1/(1+WE*n);return t*(1-((((jE*a+HE)*a+GE)*a+UE)*a+VE)*a*Math.exp(-n*n))})),qE={kernelName:ei,backendName:"cpu",kernelFunc:KE},XE=yC((e=>Math.exp(e))),YE=vC(ni,XE,"float32"),QE={kernelName:ni,backendName:"cpu",kernelFunc:YE};function JE(e){const{inputs:t,backend:n,attrs:a}=e,{input:r}=t,{dim:o}=a,s=r.shape.length,i=r.shape.slice();let c=o;return o<0&&(mo(-(s+1)<=o,(()=>"Axis must be in the interval [".concat(-(s+1),", ").concat(s,"]"))),c=s+o+1),i.splice(c,0,1),$C({inputs:{x:r},backend:n,attrs:{shape:i}})}const ZE={kernelName:ai,backendName:"cpu",kernelFunc:JE},$E=yC((e=>Math.expm1(e))),eR=vC(ri,$E),tR={kernelName:ri,backendName:"cpu",kernelFunc:eR},nR=TC(((e,t)=>e/t)),aR=qC(Qs,nR),rR={kernelName:Qs,backendName:"cpu",kernelFunc:aR},oR=TC(((e,t)=>e-t)),sR=XC(((e,t,n,a)=>({real:e-n,imag:t-a}))),iR=qC(Xc,oR,sR),cR={kernelName:Xc,backendName:"cpu",kernelFunc:iR};function lR(e,t,n){const a=e.shape,r=a[0],o=a[1],s=n.data.get(e.dataId),i=s.complexTensorInfos.real,c=s.complexTensorInfos.imag,l=[r,o],u=yo(l),d=To("float32",u),h=To("float32",u);for(let g=0;g<r;g++){const e=zT({inputs:{x:i},backend:n,attrs:{begin:[g,0],size:[1,o]}}),a=zT({inputs:{x:c},backend:n,attrs:{begin:[g,0],size:[1,o]}}),r=BC({inputs:{real:e,imag:a},backend:n}),{real:s,imag:l}=uR(r,t,n),u=Ig(s,l);for(let t=0;t<o;t++){const e=Tg(u,t);d[g*o+t]=e.real,h[g*o+t]=e.imag}n.disposeIntermediateTensorInfo(e),n.disposeIntermediateTensorInfo(a),n.disposeIntermediateTensorInfo(r)}const p=n.makeTensorInfo(l,"float32",d),f=n.makeTensorInfo(l,"float32",h),m=BC({inputs:{real:p,imag:f},backend:n});return n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(f),m}function uR(e,t,n){const a=yo(e.shape),r=n.data.get(e.dataId),o=n.data.get(r.complexTensorInfos.real.dataId).values,s=n.data.get(r.complexTensorInfos.imag.dataId).values;if(0===((i=a)&i-1)){const r=dR(o,s,a,t,n),i=[e.shape[0],e.shape[1]];if(t){const e=n.makeTensorInfo(i,"float32",r.real),t=n.makeTensorInfo(i,"float32",r.imag),o=n.makeTensorInfo([],"float32",Pl(a,"float32")),s=IC({inputs:{x:o},backend:n}),c=rR.kernelFunc({inputs:{a:e,b:o},backend:n}),l=rR.kernelFunc({inputs:{a:t,b:s},backend:n}),u=n.data.get(c.dataId).values,d=n.data.get(l.dataId).values;return n.disposeIntermediateTensorInfo(e),n.disposeIntermediateTensorInfo(t),n.disposeIntermediateTensorInfo(o),n.disposeIntermediateTensorInfo(s),n.disposeIntermediateTensorInfo(c),n.disposeIntermediateTensorInfo(l),{real:u,imag:d}}return r}{const e=function(e,t,n){const a=new Float32Array(2*t);for(let r=0;r<t;r++){let o=0,s=0;for(let a=0;a<t;a++){const i=_g(r*a,t,n),c=Tg(e,a);o+=c.real*i.real-c.imag*i.imag,s+=c.real*i.imag+c.imag*i.real}n&&(o/=t,s/=t),Eg(a,o,s,r)}return a}(Ig(o,s),a,t);return Sg(e)}var i}function dR(e,t,n,a,r){if(1===n)return{real:e,imag:t};const o=Ig(e,t),s=n/2,i=Ng(o),c=i.real,l=i.imag,u=[c.length],d=r.makeTensorInfo(u,"float32",c),h=r.makeTensorInfo(u,"float32",l),p=BC({inputs:{real:d,imag:h},backend:r}),f=Cg(o),m=f.real,g=f.imag,b=[m.length],y=r.makeTensorInfo(b,"float32",m),x=r.makeTensorInfo(b,"float32",g),v=BC({inputs:{real:y,imag:x},backend:r}),w=dR(c,l,s,a,r),k=w.real,I=w.imag,S=[k.length],N=r.makeTensorInfo(S,"float32",k),C=r.makeTensorInfo(S,"float32",I),T=BC({inputs:{real:N,imag:C},backend:r}),E=dR(m,g,s,a,r),R=E.real,_=E.imag,A=[R.length],F=r.makeTensorInfo(A,"float32",R),O=r.makeTensorInfo(A,"float32",_),D=BC({inputs:{real:F,imag:O},backend:r}),M=Rg(n,a),L=[M.real.length],P=r.makeTensorInfo(L,"float32",M.real),z=r.makeTensorInfo(L,"float32",M.imag),B=BC({inputs:{real:P,imag:z},backend:r}),W=AE({inputs:{a:B,b:D},backend:r}),V=JC({inputs:{a:T,b:W},backend:r}),U=iR({inputs:{a:T,b:W},backend:r}),G=UC({inputs:{input:V},backend:r}),H=UC({inputs:{input:U},backend:r}),j=eE({inputs:{input:V},backend:r}),K=eE({inputs:{input:U},backend:r}),q=nE({inputs:[G,H],backend:r,attrs:{axis:0}}),X=nE({inputs:[j,K],backend:r,attrs:{axis:0}}),Y=r.data.get(q.dataId).values,Q=r.data.get(X.dataId).values;return r.disposeIntermediateTensorInfo(d),r.disposeIntermediateTensorInfo(h),r.disposeIntermediateTensorInfo(p),r.disposeIntermediateTensorInfo(y),r.disposeIntermediateTensorInfo(x),r.disposeIntermediateTensorInfo(v),r.disposeIntermediateTensorInfo(N),r.disposeIntermediateTensorInfo(C),r.disposeIntermediateTensorInfo(T),r.disposeIntermediateTensorInfo(F),r.disposeIntermediateTensorInfo(O),r.disposeIntermediateTensorInfo(D),r.disposeIntermediateTensorInfo(P),r.disposeIntermediateTensorInfo(z),r.disposeIntermediateTensorInfo(B),r.disposeIntermediateTensorInfo(W),r.disposeIntermediateTensorInfo(V),r.disposeIntermediateTensorInfo(U),r.disposeIntermediateTensorInfo(G),r.disposeIntermediateTensorInfo(j),r.disposeIntermediateTensorInfo(H),r.disposeIntermediateTensorInfo(K),r.disposeIntermediateTensorInfo(q),r.disposeIntermediateTensorInfo(X),{real:Y,imag:Q}}const hR={kernelName:oi,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{input:a}=t,r=yo(a.shape),o=a.shape[a.shape.length-1],s=$C({inputs:{x:a},backend:n,attrs:{shape:[r/o,o]}}),i=lR(s,!1,n),c=$C({inputs:{x:i},backend:n,attrs:{shape:a.shape}});return n.disposeIntermediateTensorInfo(s),n.disposeIntermediateTensorInfo(i),c}};function pR(e){const{backend:t,attrs:n}=e,{shape:a,value:r,dtype:o}=n,s=o||Oo(r),i=Eo(s,yo(a));return function(e,t,n){e.fill(t)}(i,r),t.makeTensorInfo(a,s,i)}const fR={kernelName:si,backendName:"cpu",kernelFunc:pR};const mR={kernelName:ii,backendName:"cpu",kernelFunc:e=>{let{inputs:t,attrs:n,backend:a}=e;const{image:r}=t,o=a,s=To(r.dtype,yo(r.shape)),[i,c,l,u]=r.shape,d=o.data.get(r.dataId).values;for(let h=0;h<i;h++){const e=h*l*c*u;for(let t=0;t<c;t++){const n=t*(l*u);for(let t=0;t<l;t++){const a=t*u;for(let r=0;r<u;r++){const o=Math.round(l-t-1),i=e+n+a+r;let c=d[i];if(o>=0&&o<l){c=d[e+n+o*u+r]}s[i]=c}}}}return{dataId:o.write(s,r.shape,r.dtype),shape:r.shape,dtype:r.dtype}}},gR=yC((e=>Math.floor(e))),bR=vC(ci,gR),yR={kernelName:ci,backendName:"cpu",kernelFunc:bR},xR=TC(((e,t)=>Math.floor(e/t))),vR=qC(li,xR,null,"int32"),wR={kernelName:li,backendName:"cpu",kernelFunc:vR};const kR={kernelName:ll,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r,filter:o,bias:s,preluActivationWeights:i}=t,{strides:c,pad:l,dataFormat:u,dilations:d,dimRoundingMode:h,activation:p,leakyreluAlpha:f}=a;let m=rE({inputs:{x:r,filter:o},backend:n,attrs:{strides:c,pad:l,dataFormat:u,dilations:d,dimRoundingMode:h}});if(s){const e=m;if("NCHW"===u&&1===s.shape.length&&1!==s.shape[0]){const e=$C({inputs:{x:s},backend:n,attrs:{shape:[s.shape[0],1,1]}});m=JC({inputs:{a:m,b:e},backend:n}),n.disposeIntermediateTensorInfo(e)}else m=JC({inputs:{a:m,b:s},backend:n});n.disposeIntermediateTensorInfo(e)}if(p){const e=m;if("NCHW"===u&&"prelu"===p&&1===i.shape.length&&1!==i.shape[0]){const e=$C({inputs:{x:i},backend:n,attrs:{shape:[i.shape[0],1,1]}});m=zC(n,m,p,e,f),n.disposeIntermediateTensorInfo(e)}else m=zC(n,m,p,i,f);n.disposeIntermediateTensorInfo(e)}return m}};const IR={kernelName:ul,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r,filter:o,bias:s,preluActivationWeights:i}=t,{strides:c,pad:l,dataFormat:u,dilations:d,dimRoundingMode:h,activation:p,leakyreluAlpha:f}=a;let m=vE({inputs:{x:r,filter:o},backend:n,attrs:{strides:c,pad:l,dataFormat:u,dilations:d,dimRoundingMode:h}});if(s){const e=m;m=JC({inputs:{a:m,b:s},backend:n}),n.disposeIntermediateTensorInfo(e)}if(p){const e=m;m=zC(n,m,p,i,f),n.disposeIntermediateTensorInfo(e)}return m}};function SR(e,t,n,a,r,o,s,i,c){const l=Od([a,o],n);for(let u=0;u<a;u++){const n=[];let a=0;for(let t=0;t<r;t++){const o=e[u*r+t];a+=o*s[t],n.push(o)}if(a<0||a>=c/o)throw new Error("Invalid indices: ".concat(n," does not index into ").concat(i));for(let e=0;e<o;e++)l.values[u*o+e]=t.get(...t.indexToLoc(a*o+e))}return l}const NR={kernelName:hi,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{params:a,indices:r}=t,o=yo(a.shape),s=r.shape,i=s[s.length-1],[c,l,u,d]=dg(a,r);if(0===l)return n.makeTensorInfo(c,a.dtype,[]);const h=SR(n.data.get(r.dataId).values,n.bufferSync(a),a.dtype,l,i,u,d,a.shape,o);return n.makeTensorInfo(c,a.dtype,h.values)}};function CR(e,t,n){const a=Od(n,e.dtype);for(let r=0;r<a.size;++r){const n=a.indexToLoc(r).slice(),o=n[0],s=n[2],i=t.locToIndex([o,s]);n[2]=t.values[i];const c=e.locToIndex(n);0<=c&&c<e.values.length&&(a.values[r]=e.values[c])}return a}const TR={kernelName:di,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r,indices:o}=t,{axis:s,batchDims:i}=a;mC([r,o],"gatherV2");const c=No(s,r.shape)[0],l=n.data.get(o.dataId).values,u=r.shape[c];for(let x=0;x<l.length;++x){const e=l[x];mo(e<=u-1&&e>=0,(()=>"GatherV2: the index value ".concat(e," is not in [0, ").concat(u-1,"]")))}let d=i;null==i&&(d=0);const h=yo(o.shape),p=nb(r,o,c,d),f=$C({inputs:{x:r},backend:n,attrs:{shape:[p.batchSize,p.outerSize,p.dimSize,p.sliceSize]}}),m=$C({inputs:{x:o},backend:n,attrs:{shape:[p.batchSize,h/p.batchSize]}}),g=[p.batchSize,p.outerSize,h/p.batchSize,p.sliceSize],b=n.bufferSync(m),y=CR(n.bufferSync(f),b,g);return n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),n.makeTensorInfo(p.outputShape,y.dtype,y.values)}},ER=TC(((e,t)=>e>t?1:0)),RR=qC(pi,ER,null,"bool"),_R={kernelName:pi,backendName:"cpu",kernelFunc:RR},AR=TC(((e,t)=>e>=t?1:0)),FR=qC(fi,AR,null,"bool"),OR={kernelName:fi,backendName:"cpu",kernelFunc:FR};const DR={kernelName:gi,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{input:a}=t,r=yo(a.shape),o=a.shape[a.shape.length-1],s=$C({inputs:{x:a},backend:n,attrs:{shape:[r/o,o]}}),i=lR(s,!0,n),c=$C({inputs:{x:i},backend:n,attrs:{shape:a.shape}});return n.disposeIntermediateTensorInfo(s),n.disposeIntermediateTensorInfo(i),c}},MR=xC(yi,(e=>Number.isFinite(e)?1:0),"bool"),LR={kernelName:yi,backendName:"cpu",kernelFunc:MR},PR=xC(xi,(e=>Math.abs(e)===1/0?1:0),"bool"),zR={kernelName:xi,backendName:"cpu",kernelFunc:PR},BR=xC(vi,(e=>Number.isNaN(e)?1:0),"bool"),WR={kernelName:vi,backendName:"cpu",kernelFunc:BR},VR=TC(((e,t)=>e<t?1:0)),UR=qC(ki,VR,null,"bool"),GR={kernelName:ki,backendName:"cpu",kernelFunc:UR},HR=TC(((e,t)=>e<=t?1:0)),jR=qC(Ii,HR,null,"bool"),KR={kernelName:Ii,backendName:"cpu",kernelFunc:jR};function qR(e,t,n){const a=(t-e)/(n-1),r=Wo(n,"float32");r[0]=e;for(let o=1;o<r.length;o++)r[o]=r[o-1]+a;return r}const XR={kernelName:Si,backendName:"cpu",kernelFunc:function(e){const{backend:t,attrs:n}=e,{start:a,stop:r,num:o}=n,s=qR(a,r,o);return t.makeTensorInfo([s.length],"float32",s)}},YR=yC((e=>Math.log(e))),QR=vC(Ni,YR),JR={kernelName:Ni,backendName:"cpu",kernelFunc:QR},ZR=xC(Ci,(e=>Math.log1p(e))),$R={kernelName:Ci,backendName:"cpu",kernelFunc:ZR},e_=TC(((e,t)=>e&&t)),t_=qC(Ti,e_,null,"bool"),n_={kernelName:Ti,backendName:"cpu",kernelFunc:t_},a_=xC(Ei,(e=>e?0:1),"bool"),r_={kernelName:Ei,backendName:"cpu",kernelFunc:a_},o_=TC(((e,t)=>e||t)),s_=qC(Ri,o_,null,"bool"),i_={kernelName:Ri,backendName:"cpu",kernelFunc:s_};const c_={kernelName:_i,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{depthRadius:o,bias:s,alpha:i,beta:c}=a;mC(r,"LRN");const l=r.shape[3],u=l-1,d=n.data.get(r.dataId).values,h=yo(r.shape),p=new Float32Array(h);function f(e){const t=e%l;let n=e-t+Math.max(0,t-o);const a=e-t+Math.min(t+o,u);let r=0;for(;n<=a;n++){const e=d[n];r+=e*e}return r}for(let m=0;m<h;m++){const e=f(m),t=d[m]*Math.pow(s+i*e,-c);p[m]=t}return n.makeTensorInfo(r.shape,r.dtype,p)}};const l_={kernelName:Ai,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r,y:o,dy:s}=t,{depthRadius:i,bias:c,alpha:l,beta:u}=a;mC(s,"LRNGrad");const d=yo(s.shape),h=s.shape[3],p=n.data.get(s.dataId).values,f=n.data.get(r.dataId).values,m=n.data.get(o.dataId).values,g=new Float32Array(d),b=d;for(let y=0;y<b;y++){const e=y%h,t=y-e+Math.max(0,e-i),n=y-e+Math.min(h,e+i+1);let a=0;for(let r=t;r<n;r++)a+=Math.pow(f[r],2);a=l*a+c;for(let r=t;r<n;r++){let e=-2*l*u*f[r]*m[y]/a;y===r&&(e+=Math.pow(a,-u)),e*=p[y],g[r]+=e}}return n.makeTensorInfo(s.shape,r.dtype,g)}};function u_(e,t,n,a){const r=To(a,yo(n));for(let o=0;o<r.length;++o){const n=o*t;let a=e[n];for(let r=0;r<t;++r){const t=e[n+r];(Number.isNaN(t)||t>a)&&(a=t)}r[o]=a}return r}function d_(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{reductionIndices:o,keepDims:s}=a,i=n;let c=r.shape;const l=c.length,u=No(o,c);let d=u;const h=Xp(d,l);let p=i.data.get(r.dataId).values;if(null!=h){const e=new Array(l);for(let t=0;t<e.length;t++)e[t]=c[h[t]];p=dT(p,c,r.dtype,h,e),d=Qp(d.length,l),c=e}mC(r,"max"),qp("max",d,l);const[f,m]=jp(c,d),g=u_(p,yo(m),f,r.dtype),b=i.write(g,f,r.dtype);let y=f;if(s){y=Kp(f,u)}return{dataId:b,shape:y,dtype:r.dtype}}const h_={kernelName:Fi,backendName:"cpu",kernelFunc:d_},p_=TC(((e,t)=>Math.max(e,t))),f_=qC(Oi,p_),m_={kernelName:Oi,backendName:"cpu",kernelFunc:f_};const g_={kernelName:Di,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t;mC(r,"maxPool");const{filterSize:o,strides:s,pad:i,dimRoundingMode:c}=a;mo(ep(s,1),(()=>"Error in maxPool: Either strides or dilations must be 1. "+"Got strides ".concat(s," and dilations '").concat(1,"'")));const l=Hh(r.shape,o,s,1,i,c);let u;if(1===l.filterWidth&&1===l.filterHeight&&xo(l.inShape,l.outShape))u=IC({inputs:{x:r},backend:n});else{const e=n.data.get(r.dataId).values,t=Lo(r.shape),a=RT(e,r.shape,r.dtype,t,l,"max");u=n.makeTensorInfo(l.outShape,r.dtype,a.values)}return u}};const b_={kernelName:Li,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{filterSize:o,strides:s,pad:i,dimRoundingMode:c,dataFormat:l}=a;mC(r,"maxPool3d");const u=jh(r.shape,o,s,1,i,c,l),d=AT(n.data.get(r.dataId).values,r.shape,r.dtype,Lo(r.shape),u,"max");return n.makeTensorInfo(d.shape,"float32",d.values)}};const y_={kernelName:Pi,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{dy:r,input:o}=t,{filterSize:s,strides:i,pad:c,dimRoundingMode:l}=a;mC([r,o],"maxPool3DGrad");const u=jh(o.shape,s,i,1,c,l),d=function(e,t){const n=Od(t.outShape,"int32"),a=t.strideDepth,r=t.strideHeight,o=t.strideWidth,s=t.dilationDepth,i=t.dilationHeight,c=t.dilationWidth,l=t.effectiveFilterDepth,u=t.effectiveFilterHeight,d=t.effectiveFilterWidth,h=t.padInfo.front,p=t.padInfo.top,f=t.padInfo.left;for(let m=0;m<t.batchSize;++m)for(let g=0;g<t.inChannels;++g)for(let b=0;b<t.outDepth;++b){const y=b*a-h;let x=y;for(;x<0;)x+=s;const v=Math.min(t.inDepth,l+y);for(let a=0;a<t.outHeight;++a){const l=a*r-p;let h=l;for(;h<0;)h+=i;const w=Math.min(t.inHeight,u+l);for(let r=0;r<t.outWidth;++r){const p=r*o-f;let k=p;for(;k<0;)k+=c;const I=Math.min(t.inWidth,d+p);let S=Number.NEGATIVE_INFINITY,N=-1;for(let t=x;t<v;t+=s){const n=t-y;for(let a=h;a<w;a+=i){const r=a-l;for(let o=k;o<I;o+=c){const s=o-p,i=e.get(m,t,a,o,g);i>=S&&(S=i,N=n*u*d+r*u+s)}}}n.set(N,m,b,a,r,g)}}}return n}(n.bufferSync(o),u),h=u.strideDepth,p=u.strideHeight,f=u.strideWidth,m=u.dilationDepth,g=u.dilationHeight,b=u.dilationWidth,y=u.effectiveFilterDepth,x=u.effectiveFilterHeight,v=u.effectiveFilterWidth,w=y-1-u.padInfo.front,k=v-1-u.padInfo.left,I=x-1-u.padInfo.top,S=Od(o.shape,"float32"),N=n.bufferSync(r);for(let C=0;C<u.batchSize;++C)for(let e=0;e<u.inChannels;++e)for(let t=0;t<u.inDepth;++t)for(let n=0;n<u.inHeight;++n)for(let a=0;a<u.inWidth;++a){const r=t-w,o=n-I,s=a-k;let i=0;for(let t=0;t<y;t+=m){const n=(r+t)/h;if(!(n<0||n>=u.outDepth||Math.floor(n)!==n))for(let a=0;a<x;a+=g){const r=(o+a)/p;if(!(r<0||r>=u.outHeight||Math.floor(r)!==r))for(let o=0;o<v;o+=b){const c=(s+o)/f;if(c<0||c>=u.outWidth||Math.floor(c)!==c)continue;const l=y*x*v-1-d.get(C,n,r,c,e)===t*x*v+a*v+o?1:0;if(0===l)continue;i+=N.get(C,n,r,c,e)*l}}}S.set(i,C,t,n,a,e)}return n.makeTensorInfo(S.shape,S.dtype,S.values)}};const x_={kernelName:Mi,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{dy:r,input:o,output:s}=t,i=o;mC([o,s],"maxPoolGrad");const{filterSize:c,strides:l,pad:u,dimRoundingMode:d}=a,h=Hh(i.shape,c,l,1,u,d),p=n.data.get(i.dataId).values,f=Od(h.outShape,i.dtype,_T(p,i.shape,i.dtype,h).values),m=h.strideHeight,g=h.strideWidth,b=h.dilationHeight,y=h.dilationWidth,x=h.effectiveFilterHeight,v=h.effectiveFilterWidth,w=v-1-h.padInfo.left,k=x-1-h.padInfo.top,I=Od(i.shape,"float32"),S=n.data.get(r.dataId).values,N=Od(r.shape,"float32",S);for(let C=0;C<h.batchSize;++C)for(let e=0;e<h.inChannels;++e)for(let t=0;t<h.inHeight;++t)for(let n=0;n<h.inWidth;++n){const a=t-k,r=n-w;let o=0;for(let t=0;t<x;t+=b){const n=(a+t)/m;if(!(n<0||n>=h.outHeight||Math.floor(n)!==n))for(let a=0;a<v;a+=y){const s=(r+a)/g;if(s<0||s>=h.outWidth||Math.floor(s)!==s)continue;const i=x*v-1-f.get(C,n,s,e)===t*v+a?1:0;if(0===i)continue;o+=N.get(C,n,s,e)*i}}I.set(o,C,t,n,e)}return n.makeTensorInfo(I.shape,I.dtype,I.values)}};const v_={kernelName:zi,backendName:"cpu",kernelFunc:e=>{let{inputs:t,attrs:n,backend:a}=e;const{x:r}=t,{filterSize:o,strides:s,pad:i,includeBatchInIndex:c}=n,l=a;mC(r,"MaxPoolWithArgmax");const u=l.data.get(r.dataId).values,d=Hh(r.shape,o,s,[1,1],i),[h,p]=function(e,t,n,a,r){const o=RT(e,0,n,Lo(t),r,"max"),s=_T(e,t,n,r,!0,a);return[o.values,s.values]}(u,r.shape,r.dtype,c,d),f=l.write(h,d.outShape,r.dtype),m=l.write(p,d.outShape,r.dtype);return[{dataId:f,shape:d.outShape,dtype:r.dtype},{dataId:m,shape:d.outShape,dtype:"int32"}]}};const w_={kernelName:Bi,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{axis:o,keepDims:s}=a,i=No(o,r.shape),c=yo(jp(r.shape,i)[1]),l=[],u=n.makeTensorInfo([],"float32",new Float32Array([c]));l.push(u);const d=jC({inputs:{x:r},backend:n,attrs:{dtype:"float32"}});l.push(d);const h=aR({inputs:{a:d,b:u},backend:n});l.push(h);const p=OE({inputs:{x:h},backend:n,attrs:{axis:o,keepDims:s}});return l.forEach((e=>n.disposeIntermediateTensorInfo(e))),p}};const k_={kernelName:Wi,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{axis:o,keepDims:s}=a;mC(r,"min");const i=No(o,r.shape);let c=i;const l=Xp(c,r.shape.length);let u=r;null!=l&&(u=hT({inputs:{x:r},backend:n,attrs:{perm:l}}),c=Qp(c.length,r.shape.length)),qp("min",c,u.shape.length);const[d,h]=jp(u.shape,c),p=yo(h),f=Wo(yo(d),u.dtype),m=n.data.get(u.dataId).values;for(let b=0;b<f.length;++b){const e=b*p;let t=m[e];for(let n=0;n<p;++n){const a=m[e+n];(Number.isNaN(a)||a<t)&&(t=a)}f[b]=t}null!=l&&n.disposeIntermediateTensorInfo(u);const g=n.makeTensorInfo(d,u.dtype,f);if(s){const e=$C({inputs:{x:g},backend:n,attrs:{shape:Kp(d,i)}});return n.disposeIntermediateTensorInfo(g),e}return g}},I_=TC(((e,t)=>Math.min(e,t))),S_=qC(Vi,I_),N_={kernelName:Vi,backendName:"cpu",kernelFunc:S_};const C_={kernelName:Ui,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{paddings:o,mode:s}=a;mC(r,"mirrorPad");const i=o.map(((e,t)=>e[0]+r.shape[t]+e[1])),c=o.map((e=>e[0])),l=o.map(((e,t)=>e[0]+r.shape[t])),u="reflect"===s?0:1,d=n.data.get(r.dataId).values,h=r.shape.length,p=Lo(r.shape),f=yo(i),m=i.length,g=Lo(i),b=To(r.dtype,f);for(let y=0;y<f;y++){let e=Ho(y,m,g);for(let n=0;n<m;n++)e[n]<c[n]?e[n]=2*c[n]-e[n]-u:e[n]>=l[n]&&(e[n]=2*(l[n]-1)-e[n]+u);e=e.map(((e,t)=>e-c[t]));const t=Go(e,h,p);b[y]=d[t]}return{dataId:n.write(b,i,r.dtype),shape:i,dtype:r.dtype}}},T_=TC(((e,t)=>{const n=e%t;return e<0&&t<0||e>=0&&t>=0?n:(n+t)%t})),E_=qC(Gi,T_),R_={kernelName:Gi,backendName:"cpu",kernelFunc:E_};function __(e){const{inputs:t,backend:n,attrs:a}=e,{logits:r}=t,{dim:o}=a,s=r.shape.length;let i=o;if(-1===i&&(i=s-1),i!==s-1)throw Error("Softmax along a non-last dimension is not yet supported. "+"Logits was rank ".concat(s," and dim was ").concat(i));const c=No([i],r.shape),l=d_({inputs:{x:r},backend:n,attrs:{reductionIndices:c,keepDims:!1}}),u=Kp(l.shape,c),d=$C({inputs:{x:l},backend:n,attrs:{shape:u}}),h=iR({inputs:{a:r,b:d},backend:n}),p=YE({inputs:{x:h},backend:n}),f=OE({inputs:{x:p},backend:n,attrs:{axis:c,keepDims:!1}}),m=$C({inputs:{x:f},backend:n,attrs:{shape:u}}),g=aR({inputs:{a:p,b:m},backend:n});return n.disposeIntermediateTensorInfo(l),n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),g}const A_={kernelName:Mc,backendName:"cpu",kernelFunc:__};const F_={kernelName:Hi,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{logits:r}=t,{numSamples:o,seed:s,normalized:i}=a;mC(r,"multinomial");const c=i?r:__({inputs:{logits:r},backend:n,attrs:{dim:-1}}),l=c.shape[0],u=c.shape[1],d=n.data.get(c.dataId).values,h=[l,o],p=Wo(yo(h),"int32");for(let f=0;f<l;++f){const e=f*u,t=new Float32Array(u-1);t[0]=d[e];for(let r=1;r<t.length;++r)t[r]=t[r-1]+d[e+r];const n=mf.alea(s.toString()),a=f*o;for(let r=0;r<o;++r){const e=n();p[a+r]=t.length;for(let n=0;n<t.length;n++)if(e<t[n]){p[a+r]=n;break}}}return i||n.disposeIntermediateTensorInfo(c),n.makeTensorInfo(h,"int32",p)}};function O_(e,t,n){const a=Pl(-1,n);return RE([],t,a,e,n)}const D_={kernelName:Ki,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{x:a}=t;mC(a,"neg");const r=n.data.get(a.dataId).values,[o,s]=O_(r,a.shape,a.dtype);return n.makeTensorInfo(s,a.dtype,o)}},M_=bm;const L_={kernelName:Xi,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{boxes:r,scores:o}=t,{maxOutputSize:s,iouThreshold:i,scoreThreshold:c}=a;mC(r,"NonMaxSuppression");const l=n.data.get(r.dataId).values,u=n.data.get(o.dataId).values,{selectedIndices:d}=M_(l,u,s,i,c);return n.makeTensorInfo([d.length],"int32",new Int32Array(d))}},P_=ym;const z_={kernelName:Yi,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{boxes:r,scores:o}=t,{maxOutputSize:s,iouThreshold:i,scoreThreshold:c,padToMaxOutputSize:l}=a;mC(r,"NonMaxSuppressionPadded");const u=n.data.get(r.dataId).values,d=n.data.get(o.dataId).values,{selectedIndices:h,validOutputs:p}=P_(u,d,s,i,c,l);return[n.makeTensorInfo([h.length],"int32",new Int32Array(h)),n.makeTensorInfo([],"int32",new Int32Array([p]))]}},B_=xm;const W_={kernelName:Qi,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{boxes:r,scores:o}=t,{maxOutputSize:s,iouThreshold:i,scoreThreshold:c,softNmsSigma:l}=a;mC(r,"NonMaxSuppressionWithScore");const u=n.data.get(r.dataId).values,d=n.data.get(o.dataId).values,h=s,p=i,f=c,m=l,{selectedIndices:g,selectedScores:b}=B_(u,d,h,p,f,m);return[n.makeTensorInfo([g.length],"int32",new Int32Array(g)),n.makeTensorInfo([b.length],"float32",new Float32Array(b))]}},V_=TC(((e,t)=>e!==t?1:0)),U_=qC(qi,V_,null,"bool"),G_={kernelName:qi,backendName:"cpu",kernelFunc:U_};const H_={kernelName:Zi,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{indices:r}=t,{dtype:o,depth:s,onValue:i,offValue:c}=a;mC(r,"oneHot");const l=yo(r.shape),u=new Float32Array(l*s);u.fill(c);const d=n.data.get(r.dataId).values;for(let h=0;h<l;++h)d[h]>=0&&d[h]<s&&(u[h*s+d[h]]=i);return n.makeTensorInfo([...r.shape,s],o,u)}};function j_(e){const{inputs:t,backend:n}=e,{x:a}=t;if("string"===a.dtype)throw new Error("zerosLike is not supported for string tensors");if("complex64"===a.dtype){const e=UC({inputs:{input:a},backend:n}),t=j_({inputs:{x:e},backend:n}),r=eE({inputs:{input:a},backend:n}),o=j_({inputs:{x:r},backend:n}),s=BC({inputs:{real:t,imag:o},backend:n});return n.disposeIntermediateTensorInfo(e),n.disposeIntermediateTensorInfo(t),n.disposeIntermediateTensorInfo(r),n.disposeIntermediateTensorInfo(o),s}return pR({backend:n,attrs:{shape:a.shape,value:0,dtype:a.dtype}})}const K_={kernelName:rl,backendName:"cpu",kernelFunc:j_};const q_={kernelName:Ji,backendName:"cpu",kernelFunc:function e(t){const{inputs:n,backend:a}=t,{x:r}=n;if("string"===r.dtype)throw new Error("onesLike is not supported for string tensors");if("complex64"===r.dtype){const t=UC({inputs:{input:r},backend:a}),n=e({inputs:{x:t},backend:a}),o=eE({inputs:{input:r},backend:a}),s=j_({inputs:{x:o},backend:a}),i=BC({inputs:{real:n,imag:s},backend:a});return a.disposeIntermediateTensorInfo(t),a.disposeIntermediateTensorInfo(n),a.disposeIntermediateTensorInfo(o),a.disposeIntermediateTensorInfo(s),i}return pR({backend:a,attrs:{shape:r.shape,value:1,dtype:r.dtype}})}};function X_(e){const{inputs:t,backend:n,attrs:a}=e,{axis:r}=a;if(1===t.length)return JE({inputs:{input:t[0]},backend:n,attrs:{dim:r}});const o=t[0].shape,s=t[0].dtype;t.forEach((e=>{go(o,e.shape,"All tensors passed to stack must have matching shapes"),mo(s===e.dtype,(()=>"All tensors passed to stack must have matching dtypes"))}));const i=[],c=t.map((e=>{const t=JE({inputs:{input:e},backend:n,attrs:{dim:r}});return i.push(t),t})),l=nE({inputs:c,backend:n,attrs:{axis:r}});return i.forEach((e=>n.disposeIntermediateTensorInfo(e))),l}const Y_={kernelName:$i,backendName:"cpu",kernelFunc:X_};const Q_={kernelName:ec,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{paddings:o,constantValue:s}=a;mC(r,"pad");const i=o.map(((e,t)=>e[0]+r.shape[t]+e[1])),c=o.map((e=>e[0])),l=n.data.get(r.dataId).values,u=yo(r.shape),d=r.shape.length,h=Lo(r.shape),p=yo(i),f=i.length,m=Lo(i),g=To(r.dtype,p);0!==s&&g.fill(s);for(let b=0;b<u;b++){const e=Ho(b,d,h).map(((e,t)=>e+c[t]));g[Go(e,f,m)]=l[b]}return{dataId:n.write(g,i,r.dtype),shape:i,dtype:r.dtype}}},J_=TC(((e,t)=>Math.pow(e,t))),Z_=qC(tc,J_),$_={kernelName:tc,backendName:"cpu",kernelFunc:Z_};function eA(e,t,n,a){const[r,o]=jp(e,a),s=fu(t,"int32"),i=Wo(yo(r),s),c=yo(o);for(let l=0;l<i.length;++l){const e=l*c;let t=1;for(let a=0;a<c;++a)t*=n[e+a];i[l]=t}return{outVals:i,outShape:r,outDtype:s}}const tA={kernelName:ac,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{axis:o,keepDims:s}=a;mC(r,"prod");const i=r.shape.length,c=No(o,r.shape),l=Xp(c,i);let u=c,d=r;const h=[];null!=l&&(d=hT({inputs:{x:r},backend:n,attrs:{perm:l}}),h.push(d),u=Qp(u.length,i));const p=n.data.get(d.dataId).values,{outVals:f,outShape:m,outDtype:g}=eA(d.shape,d.dtype,p,u);let b=m;return s&&(b=Kp(m,c)),h.forEach((e=>n.disposeIntermediateTensorInfo(e))),n.makeTensorInfo(b,g,f)}};function nA(e,t,n,a){const r=[];let o=0;const s=t.length-1+n.length,i=new Array(s).fill(null).map((()=>[0]));!function(e,t){for(let n=0;n<e.length;++n){const a=e[n],r=n===e.length-1?t:e[n+1].length;if(0===a.length)throw new Error("Ragged splits may not be empty");if(a[0]<0)throw new Error("Ragged splits must be non-negative");if(a[a.length-1]>r)throw new Error("Ragged splits must not point past values");for(let e=1;e<a.length;++e)if(a[e-1]>a[e])throw new Error("Ragged splits must be sorted in ascending order")}}(n,a);let c=1;for(let l=0;l<t.length-1;++l){c*=t[l];const e=t[l+1];for(let t=1;t<c+1;++t)i[l].push(t*e)}for(let l=0;l<e.length;++l){let a=e[l],s=e[l]+1;for(let e=0;e<n.length;++e){const r=n[e],o=e+t.length-1;if(o>=0){const e=i[o],t=e[e.length-1]-r[a];for(let n=a;n<s;++n)i[o].push(r[n+1]+t)}a=r[a],s=r[s]}s!==a&&(r.push([a,s]),o+=s-a)}return{outSplits:i,valueSlices:r,numValues:o}}function aA(e,t){const n=e.slice(0,t);for(;n.length<t;)n.push(1);for(let a=t;a<e.length;a++)n[t-1]*=e[a];return n}function rA(e,t,n,a,r){const o=t.slice();o[0]=r;const s=Eo(n,yo(o)),i=e.length;return function(e,t,n,a,r,o){const s=aA(t,2)[1],i=aA(o,2)[1];let c=0;for(const l of n)for(let t=l[0];t<l[1];++t){for(let n=0;n<a;++n)r[c*i+n]=e[t*s+n];++c}}(e,t,a,0===i?0:i/t[0],s,o),[s,o]}function oA(e,t,n,a,r,o,s,i){if(0===e.length)throw new Error("paramsNestedSplits must be non empty");if(0===t[0].length)throw new Error("Split tensors must not be scalars");if(function(e,t,n){e.forEach(((e,a)=>{if(e<0||e>=n){const r=Ho(a,t.length,Lo(t)).join(",");throw new Error("indices[".concat(r,"] = ").concat(e," is not in [0, ").concat(n,")"))}}))}(o,s,t[0][0]-1),0===a.length)throw new Error("params.rank must be nonzero");const c=a[0],{outSplits:l,valueSlices:u,numValues:d}=nA(o,s,e,c),h=function(e){const t=[];for(let n=0;n<e.length;++n){const a=Eo("int32",e[n].length);t.push(a),e[n].forEach(((e,t)=>a[t]=e))}return t}(l),p=rA(n,a,r,u,d);return[h,p[0],p[1]]}const sA={kernelName:rc,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{paramsNestedSplits:r,paramsDenseValues:o,indices:s}=t,{outputRaggedRank:i}=a,c=r.map((e=>n.data.get(e.dataId).values)),l=r.map((e=>e.shape)),u=n.data.get(o.dataId).values,d=n.data.get(s.dataId).values,[h,p,f]=oA(c,l,u,o.shape,o.dtype,d,s.shape),m=h.map((e=>n.makeTensorInfo([e.length],"int32",e))),g=n.makeTensorInfo(f,o.dtype,p);return m.concat([g])}},iA=2147483647;function cA(e,t,n,a,r,o,s){if(t.length>1)throw new Error("starts must be a scalar or vector");if(r.length>1)throw new Error("limits must be a scalar or vector");if(s.length>1)throw new Error("deltas must be a scalar or vector");const i=0===t.length,c=0===r.length,l=0===s.length,u=[];i||u.push(t[0]),c||u.push(r[0]),l||u.push(s[0]);for(let m=1;m<u.length;++m)if(u[m]!==u[m-1])throw new Error("starts, limits, and deltas must have the same shape");const d=0===u.length?1:u[0],h=Eo("int32",d+1);h[0]=0;for(let m=0;m<d;++m){const t=i?e[0]:e[m],n=c?a[0]:a[m],r=l?o[0]:o[m];if(0===r)throw new Error("Requires delta != 0");let s;if(r>0&&n<t||r<0&&n>t)s=0;else if(s=Math.ceil(Math.abs((n-t)/r)),s>iA)throw new Error("Requires ((limit - start) / delta) <= ".concat(iA));h[m+1]=h[m]+s}const p=Eo(n,h[d]);let f=0;for(let m=0;m<d;++m){const t=h[m+1]-h[m];let n=i?e[0]:e[m];const a=l?o[0]:o[m];for(let e=0;e<t;++e)p[f++]=n,n+=a}return[h,p]}const lA={kernelName:oc,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{starts:a,limits:r,deltas:o}=t,s=n.data.get(a.dataId).values,i=n.data.get(r.dataId).values,c=n.data.get(o.dataId).values,[l,u]=cA(s,a.shape,a.dtype,i,r.shape,c,o.shape);return[n.makeTensorInfo([l.length],"int32",l),n.makeTensorInfo([u.length],a.dtype,u)]}};var uA=Zm;class dA{constructor(e,t,n,a,r,o,s,i,c,l){this.shape=e,this.shapeShape=t,this.values=n,this.valuesShape=a,this.valuesDType=r,this.defaultValue=o,this.defaultValueShape=s,this.rowPartitionValues=i,this.rowPartitionValuesShapes=c,this.rowPartitionTypes=eg(l),this.raggedRank=tg(this.rowPartitionTypes)}getRowPartitionTypeByDimension(e){return this.rowPartitionTypes[0]===uA.FIRST_DIM_SIZE?this.rowPartitionTypes[e+1]:this.rowPartitionTypes[e]}getRowPartitionTensor(e){return this.rowPartitionTypes[0]===uA.FIRST_DIM_SIZE?this.rowPartitionValues[e+1]:this.rowPartitionValues[e]}getMaxWidth(e){const t=this.getRowPartitionTensor(e-1);switch(this.getRowPartitionTypeByDimension(e-1)){case uA.VALUE_ROWIDS:return dA.getMaxWidthValueRowID(t);case uA.ROW_SPLITS:return dA.getMaxWidthRowSplit(t);default:throw new Error("Cannot handle partition type ".concat(uA[this.getRowPartitionTypeByDimension(e-1)]))}}static getMaxWidthRowSplit(e){const t=e.length;if(0===t||1===t)return 0;let n=0;for(let a=0;a<t-1;++a){const t=e[a+1]-e[a];t>n&&(n=t)}return n}static getMaxWidthValueRowID(e){const t=e.length;if(0===t)return 0;let n=0,a=e[0],r=0;for(let o=1;o<t;++o){const t=e[o];t!==a&&(a=t,r=Math.max(o-n,r),n=o)}return Math.max(t-n,r)}tensorShapeFromTensor(e,t){let n=!(arguments.length>2&&void 0!==arguments[2])||arguments[2];if(0===t.length){if(-1===e[0])return[];throw new Error("The only valid scalar shape tensor is the fully unknown shape specified as -1.")}return pA(e,n)}calculateOutputSize(e){const t=this.valuesShape;ng(this.defaultValueShape,t);const n=this.tensorShapeFromTensor(this.shape,this.shapeShape),a=$m(this.raggedRank,n,t);a[0]<0&&(a[0]=e);for(let r=1;r<=this.raggedRank;++r)a[r]<0&&(a[r]=this.getMaxWidth(r));return a}calculateFirstParentOutputIndex(e,t,n){const a=Math.min(e,n),r=[];let o=0;for(let s=0;s<a;++s,o+=t)r.push(o);for(let s=a;s<e;++s)r.push(-1);return mo(r.length===e,(()=>"Final length of result must be equal to firstDimension.")),r}calculateOutputIndexRowSplit(e,t,n,a){const r=e.length,o=[];for(let s=0;s<r-1;++s){const r=e[s+1]-e[s];let i=Math.min(a,r),c=t[s];-1===c&&(i=0);for(let e=0;e<i;++e)o.push(c),c+=n;for(let e=0;e<r-i;++e)o.push(-1)}if(r>0&&o.length!==e[r-1])throw new Error("Invalid row split size.");return o}calculateOutputIndexValueRowID(e,t,n,a){const r=e.length,o=[];if(0===r)return[];let s=0,i=e[0];if(i>=t.length)throw new Error("Got currentValueRowId=".concat(i,", which is not less than ").concat(t.length));let c=t[i];o.push(c);for(let l=1;l<r;++l){const r=e[l];if(r===i)c>=0&&(++s,s<a?c+=n:c=-1);else{if(s=0,i=r,r>=t.length)throw new Error("Got nextValueRowId=".concat(r," which is not less than ").concat(t.length));c=t[r]}o.push(c)}if(o.length!==e.length)throw new Error("Invalid row ids.");return o}calculateOutputIndex(e,t,n,a){const r=this.getRowPartitionTensor(e),o=this.getRowPartitionTypeByDimension(e);switch(o){case uA.VALUE_ROWIDS:return this.calculateOutputIndexValueRowID(r,t,n,a);case uA.ROW_SPLITS:if(r.length-1>t.length)throw new Error("Row partition size is greater than output size: ".concat(r.length-1," > ").concat(t.length));return this.calculateOutputIndexRowSplit(r,t,n,a);default:throw new Error("Unsupported partition type: ".concat(uA[o]))}}getFirstDimensionSize(){const e=this.rowPartitionValues[0];if(0===this.rowPartitionTypes.length)throw new Error("No row_partition_types given.");const t=this.rowPartitionTypes[0];switch(t){case uA.FIRST_DIM_SIZE:return e[0];case uA.VALUE_ROWIDS:throw new Error("Cannot handle VALUE_ROWIDS in first dimension.");case uA.ROW_SPLITS:return this.rowPartitionValuesShapes[0][0]-1;default:throw new Error("Cannot handle type ".concat(uA[t]))}}compute(){if(this.rowPartitionValues[0].length<=0)throw new Error("Invalid first partition input. Tensor requires at least one element.");const e=this.getFirstDimensionSize(),t=this.calculateOutputSize(e),n=new Array(this.raggedRank+1);n[n.length-1]=1;for(let o=n.length-2;o>=0;--o)n[o]=n[o+1]*t[o+1];const a=pA(t,!1),r=Eo(this.valuesDType,yo(a));if(n[0]*t[0]>0){let o=this.calculateFirstParentOutputIndex(e,n[0],t[0]);for(let e=1;e<=this.raggedRank;++e){o=this.calculateOutputIndex(e-1,o,n[e],t[e])}this.setOutput(this.raggedRank,o,r,a)}return[a,r]}setOutput(e,t,n,a){if(0===n.length)return;const r=this.values,o=n;let s=a.slice();s=s.slice(e+1);const i=yo(s),c=t.length;let l=this.defaultValue;if(l.length!==i&&1!==l.length){const e=this.defaultValueShape;Hu((()=>{const t=rp(l,e),n=dp(t,s);l=n.dataSync()}))}let u=0,d=0,h=0;for(let p=0;p<=c;++p){let e=p<c?t[p]:-1;if(e!==h){if(d<h){const e=r.subarray(u*i);hA(o.subarray(d*i),e,(h-d)*i)}if(p>=c){const t=n.length;e=Math.floor(t/i)}if(e>h)if(1===this.defaultValue.length)o.subarray(h*i,e*i).fill(this.defaultValue[0]),h=e;else for(;e>h;){hA(o.slice(h*i),l,i),++h}e<0?(u=p+1,d=h):(u=p,d=h,h=d+1)}else++h}}}function hA(e,t,n){for(let a=0;a<n;a++)e[a]=t[a]}function pA(e,t){const n=[];for(let a of e){if(a<0){if(!t)throw new Error("Dimension ".concat(a," must be >= 0"));if(a<-1)throw new Error("Dimension ".concat(a," must be >= -1"));a=-1}n.push(a)}return n}function fA(e,t,n,a,r,o,s,i,c,l){return new dA(e,t,n,a,r,o,s,i,c,l).compute()}const mA={kernelName:sc,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{shape:r,values:o,defaultValue:s,rowPartitionTensors:i}=t,{rowPartitionTypes:c}=a,l=n.data.get(r.dataId).values,u=n.data.get(o.dataId).values,d=n.data.get(s.dataId).values,h=i.map((e=>n.data.get(e.dataId).values)),p=i.map((e=>e.shape)),[f,m]=fA(l,r.shape,u,o.shape,o.dtype,d,s.shape,h,p,c);return n.makeTensorInfo(f,o.dtype,m)}};function gA(e,t,n,a){if(e===t||e<t&&n<0||t<e&&n>1)return Wo(0,a);const r=Wo(Math.abs(Math.ceil((t-e)/n)),a);t<e&&1===n&&(n=-1),r[0]=e;for(let o=1;o<r.length;o++)r[o]=r[o-1]+n;return r}const bA={kernelName:ic,backendName:"cpu",kernelFunc:function(e){const{backend:t,attrs:n}=e,{start:a,stop:r,dtype:o,step:s}=n,i=gA(a,r,s,o);return t.makeTensorInfo([i.length],o,i)}},yA=xC(lc,(e=>1/e)),xA={kernelName:lc,backendName:"cpu",kernelFunc:yA};const vA={kernelName:fc,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{images:r}=t,{alignCorners:o,halfPixelCenters:s,size:i}=a;mC(r,"resizeBilinear");const c=Lo(r.shape),[l,u]=i,[d,h,p,f]=r.shape,m=n.data.get(r.dataId).values,g=new Float32Array(yo([d,l,u,f])),b=[o&&l>1?h-1:h,o&&u>1?p-1:p],y=[o&&l>1?l-1:l,o&&u>1?u-1:u];let x=0;const v=b[0]/y[0],w=b[1]/y[1];for(let k=0;k<d;k++)for(let e=0;e<l;e++){let t;t=s?v*(e+.5)-.5:v*e;const n=Math.max(0,Math.floor(t)),a=t-n,r=Math.min(h-1,Math.ceil(t)),o=k*c[0]+n*c[1],i=k*c[0]+r*c[1];for(let e=0;e<u;e++){let t;t=s?w*(e+.5)-.5:w*e;const n=Math.max(0,Math.floor(t)),r=t-n,l=Math.min(p-1,Math.ceil(t)),u=o+n*c[2],d=i+n*c[2],h=o+l*c[2],b=i+l*c[2];for(let e=0;e<f;e++){const t=m[u+e],n=m[d+e],o=t+(m[h+e]-t)*r,s=o+(n+(m[b+e]-n)*r-o)*a;g[x++]=s}}}return n.makeTensorInfo([d,l,u,f],"float32",g)}};const wA={kernelName:mc,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{images:r,dy:o}=t,{alignCorners:s}=a;mC([o,r],"resizeBilinearGrad");const i=Lo(r.shape),[c,l,u,d]=r.shape,[,h,p]=o.shape,f=new Float32Array(c*l*u*d),m=[s&&h>1?l-1:l,s&&p>1?u-1:u],g=[s&&h>1?h-1:h,s&&p>1?p-1:p],b=m[0]/g[0],y=m[1]/g[1],x=n.data.get(o.dataId).values;let v=0;for(let w=0;w<c;w++){const e=w*i[0];for(let t=0;t<h;t++){const n=t*b,a=Math.floor(n),r=Math.min(Math.ceil(n),l-1),o=e+a*i[1],s=e+r*i[1],c=n-a,h=1-c;for(let e=0;e<p;e++){const t=e*y,n=Math.floor(t),a=Math.min(Math.ceil(t),u-1),r=t-n,l=1-r,p=o+n*i[2],m=o+a*i[2],g=s+n*i[2],b=s+a*i[2],w=h*l,k=h*r,I=c*l,S=c*r;for(let e=0;e<d;e++){const t=x[v++];f[p+e]+=t*w,f[m+e]+=t*k,f[g+e]+=t*I,f[b+e]+=t*S}}}}return n.makeTensorInfo([c,u,l,d],"float32",f)}};const kA={kernelName:hc,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{images:r}=t,{alignCorners:o,halfPixelCenters:s,size:i}=a;mC(r,"resizeNearestNeighbor");const c=Lo(r.shape),[l,u]=i,[d,h,p,f]=r.shape,m=n.data.get(r.dataId).values,g=new Float32Array(d*l*u*f),b=[o&&l>1?h-1:h,o&&u>1?p-1:p],y=[o&&l>1?l-1:l,o&&u>1?u-1:u],x=b[0]/y[0],v=b[1]/y[1];let w=0;for(let k=0;k<d;k++){const e=k*c[0];for(let t=0;t<l;t++){const n=s?x*(t+.5):x*t;let a=Math.min(h-1,o?Math.round(n):Math.floor(n));s&&(a=Math.max(0,a));const r=e+a*c[1];for(let e=0;e<u;e++){const t=s?v*(e+.5):v*e;let n=Math.min(p-1,o?Math.round(t):Math.floor(t));s&&(n=Math.max(0,n));const a=r+n*c[2];for(let e=0;e<f;e++){const t=m[a+e];g[w++]=t}}}}return n.makeTensorInfo([d,l,u,f],r.dtype,g)}};const IA={kernelName:pc,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{images:r,dy:o}=t,{alignCorners:s}=a;mC([o,r],"resizeNearestNeighborGrad");const i=Lo(r.shape),c=Lo(o.shape),[l,u,d,h]=r.shape,[,p,f]=o.shape,m=new Float32Array(l*u*d*h),g=n.data.get(o.dataId).values,b=[s&&p>1?u-1:u,s&&f>1?d-1:d],y=[s&&p>1?p-1:p,s&&f>1?f-1:f],x=b[0]/y[0],v=b[1]/y[1],w=1/x,k=1/v,I=2*Math.ceil(w)+2,S=2*Math.ceil(k)+2;for(let N=0;N<l;N++){const e=N*i[0];for(let t=0;t<u;t++){const n=e+t*i[1],a=Math.floor(t*w),r=Math.floor(a-I/2);for(let o=0;o<d;o++){const a=n+o*i[2],l=Math.floor(o*k),b=Math.floor(l-S/2);for(let n=0;n<h;n++){let i=0;for(let a=0;a<I;a++){const l=a+r;if(l<0||l>=p)continue;const h=e+l*c[1],m=l*x;if(t===Math.min(u-1,s?Math.round(m):Math.floor(m)))for(let e=0;e<S;e++){const t=e+b;if(t<0||t>=f)continue;const a=h+t*c[2],r=t*v;o===Math.min(d-1,s?Math.round(r):Math.floor(r))&&(i+=g[a+n])}}m[a+n]=i}}}}return n.makeTensorInfo(r.shape,r.dtype,m)}};const SA={kernelName:bc,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{dims:o}=a;mC(r,"reverse");const s=r.shape.length,i=No(o,r.shape);if(0===s)return IC({inputs:{x:r},backend:n});const c=new tu(r.shape,r.dtype),l=n.bufferSync(r);for(let u=0;u<c.size;u++){const e=c.indexToLoc(u),t=e.slice();i.forEach((e=>t[e]=r.shape[e]-1-t[e])),c.set(l.get(...t),...e)}return n.makeTensorInfo(c.shape,c.dtype,c.values)}},NA={kernelName:il,backendName:"cpu",kernelFunc:e=>{let{inputs:t,attrs:n,backend:a}=e;const{image:r}=t,{radians:o,fillValue:s,center:i}=n,c=a,l=To(r.dtype,yo(r.shape)),[u,d,h,p]=r.shape,[f,m]=og(i,d,h),g=Math.sin(o),b=Math.cos(o),y=c.data.get(r.dataId).values;for(let x=0;x<u;x++){const e=x*h*d*p;for(let t=0;t<d;t++){const n=t*(h*p);for(let a=0;a<h;a++){const r=a*p;for(let o=0;o<p;o++){const i=[u,t,a,o],c=i[2],x=i[1];let v=(c-f)*b-(x-m)*g,w=(c-f)*g+(x-m)*b;v=Math.round(v+f),w=Math.round(w+m);let k=s;if("number"!==typeof s&&(k=3===o?255:s[o]),v>=0&&v<h&&w>=0&&w<d){k=y[e+w*(h*p)+v*p+o]}l[e+n+r+o]=k}}}}return{dataId:c.write(l,r.shape,r.dtype),shape:r.shape,dtype:r.dtype}}},CA=xC(yc,(e=>{const t=Math.floor(e);return e-t<.5?Math.floor(e):e-t>.5?Math.ceil(e):t%2===0?t:t+1})),TA={kernelName:yc,backendName:"cpu",kernelFunc:CA},EA=yC((e=>1/Math.sqrt(e))),RA=vC(xc,EA),_A={kernelName:xc,backendName:"cpu",kernelFunc:RA};function AA(e,t,n,a,r,o,s,i,c,l){const u=[a/r,r],d=e.values,h=t.values;if(0===a)return Od(n,t.dtype);const p=c instanceof tu?c:Od(u,t.dtype);"string"===typeof c||"number"===typeof c?p.values.fill(c):"boolean"===typeof c&&p.values.fill(+c);for(let f=0;f<o;f++){const e=[];let o=0;for(let t=0;t<s;t++){const n=d[f*s+t];e.push(n),o+=n*i[t]}if(o<0||o>=a/r)throw new Error("Invalid indices: ".concat(e," does not index into ").concat(n));for(let n=0;n<r;n++)l?p.values[o*r+n]+=h[f*r+n]:p.values[o*r+n]=0===t.rank?h[0]:h[f*r+n]}return p}const FA={kernelName:vc,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{indices:r,updates:o}=t,{shape:s}=a,{sliceRank:i,numUpdates:c,sliceSize:l,strides:u,outputSize:d}=fg(0,r,s),h=AA(n.bufferSync(r),n.bufferSync(o),s,d,l,c,i,u,0,!0);return n.makeTensorInfo(s,h.dtype,h.values)}};function OA(e,t){let n=0,a=e.length,r=0;for(;n<a;)r=Math.floor((n+a)/2),e[r]<t?n=r+1:a=r;return a}function DA(e,t){let n=0,a=e.length,r=0;for(;n<a;)r=Math.floor((n+a)/2),e[r]<=t?n=r+1:a=r;return a}const MA={kernelName:kc,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{sortedSequence:r,values:o}=t,{side:s}=a,i=function(e,t,n,a,r,o){const s=Eo("int32",n*r);for(let i=0;i<n;++i){const n=e.slice(i*a,(i+1)*a),c=i*r;for(let e=0;e<r;++e)s[c+e]="left"===o?OA(n,t[e+c]):DA(n,t[e+c])}return s}(n.data.get(r.dataId).values,n.data.get(o.dataId).values,r.shape[0],r.shape[1],o.shape[1],s);return n.makeTensorInfo(o.shape,"int32",i)}};const LA={kernelName:Ic,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{condition:a,t:r,e:o}=t;mC([a,r,o],"select");const s=a.shape.length,i=n.data.get(a.dataId).values,c=n.data.get(r.dataId).values,l=n.data.get(o.dataId).values,u=fu(r.dtype,o.dtype),d=Wo(yo(r.shape),u);let h=0;const p=0===s||s>1||1===r.shape.length?1:yo(r.shape.slice(1));for(let f=0;f<i.length;f++)for(let e=0;e<p;e++)1===i[f]?d[h++]=c[f]:d[h++]=l[f];return n.makeTensorInfo(r.shape,u,d)}},PA=mg,zA=gg,BA=xC(Sc,(e=>e>=0?zA*e:PA*(Math.exp(e)-1))),WA={kernelName:Sc,backendName:"cpu",kernelFunc:BA},VA=xC(Ec,(e=>e<0?-1:e>0?1:0)),UA={kernelName:Ec,backendName:"cpu",kernelFunc:VA},GA=xC(Cc,(e=>Math.sin(e))),HA={kernelName:Cc,backendName:"cpu",kernelFunc:GA},jA=xC(Tc,(e=>Math.sinh(e))),KA={kernelName:Tc,backendName:"cpu",kernelFunc:jA},qA=Math.log(1.1920928955078125e-7)+2,XA=xC(_c,(e=>{const t=e>-qA,n=e<qA,a=Math.exp(e);let r;return r=n?a:t?e:Math.log(1+a),r})),YA={kernelName:_c,backendName:"cpu",kernelFunc:XA};const QA={kernelName:Oc,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{blockShape:o,paddings:s}=a;mC([r],"spaceToBatchND");const i=yo(o),c=[[0,0]];c.push(...s);for(let g=1+o.length;g<r.shape.length;++g)c.push([0,0]);const l=Q_.kernelFunc({inputs:{x:r},backend:n,attrs:{paddings:c,constantValue:0}}),u=sg(l.shape,o,i,!1),d=ig(u.length,o.length,!1),h=cg(l.shape,o,i,!1),p=$C({inputs:{x:l},backend:n,attrs:{shape:u}}),f=hT({inputs:{x:p},backend:n,attrs:{perm:d}}),m=$C({inputs:{x:f},backend:n,attrs:{shape:h}});return n.disposeIntermediateTensorInfo(l),n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(f),m}};function JA(e,t,n,a,r,o,s){const i=t[0],c=o[0],l=new Array(c),u=new Array(i),d=t[1];if(0===c){if(0!==i)throw new Error(Ug(i));return[Eo(n,0),[0,d],Eo(r,0),l,u]}let h=!0,p=0;const f=new Array(c).fill(0);for(let g=0;g<i;++g){const t=e[g*d];if(t<0)throw new Error(Gg(g,t));if(t>=c)throw new Error(Hg(g,t,c));++f[t],h=h&&t>=p,p=t}let m=!0;for(let g=0;g<c;++g){const e=0===f[g];l[g]=e,m=m&&!e,f[g]=Math.max(f[g],1),g>0&&(f[g]+=f[g-1])}if(m&&h){const t=e,n=a;for(let e=0;e<i;++e)u[e]=e;return[t,[i,d],n,l,u]}{const t=f[c-1],o=Eo(n,t*d),h=Eo(r,t),p=new Array(c).fill(0);for(let n=0;n<i;++n){const t=e[n*d],r=p[t],s=(0===t?0:f[t-1])+r;p[t]++;for(let a=0;a<d;++a)o[s*d+a]=e[n*d+a];h[s]=a[n],u[n]=s}for(let e=0;e<c;++e){if(0===p[e]){const t=0===e?0:f[e-1];o[t*d+0]=e;for(let e=1;e<d;++e)o[t*d+e]=0;h[t]=s}}return[o,[t,d],h,l,u]}}const ZA={kernelName:Lc,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{indices:a,values:r,denseShape:o,defaultValue:s}=t;if(1!==o.shape.length)throw new Error("Dense shape must be a vector, saw:\n        ".concat(o.shape));if(2!==a.shape.length)throw new Error("Indices must be a matrix, saw:\n        ".concat(a.shape));if(1!==r.shape.length)throw new Error("Values must be a vector, saw:\n        ".concat(r.shape));if(0!==s.shape.length)throw new Error("Default value must be a scalar, saw:\n        ".concat(s.shape));const i=n.data.get(a.dataId).values,c=n.data.get(r.dataId).values,l=n.data.get(o.dataId).values,u=n.data.get(s.dataId).values[0],[d,h,p,f,m]=JA(i,a.shape,a.dtype,c,r.dtype,l,u);return[n.makeTensorInfo(h,a.dtype,d),n.makeTensorInfo([h[0]],r.dtype,p),n.makeTensorInfo([f.length],"bool",new Uint8Array(f.map((e=>Number(e))))),n.makeTensorInfo([m.length],a.dtype,new Int32Array(m))]}};function $A(e,t,n,a,r){const o=yo(a),s=t[0],i=r.length,c=[];let l=1,u=-1;for(let m=0;m<i;++m){const e=r[m];if(-1===e){if(-1!==u)throw new Error(jg(u,m));u=m,c.push(1)}else{if(e<0)throw new Error(Kg(m,e));l*=e,c.push(e)}}if(-1!==u){if(l<=0)throw new Error("reshape cannot infer the missing input size for an empty tensor unless all specified input sizes are non-zero");const e=Math.trunc(o/l);if(l*e!==o)throw new Error(Xg(a,c));c[u]=e}if(yo(c)!==o)throw new Error(Yg(a,c));const d=a.length,h=[];if(d>0){h[d-1]=1;for(let e=d-2;e>=0;--e)h[e]=h[e+1]*a[e+1]}const p=[];if(i>0){p[i-1]=1;for(let e=i-2;e>=0;--e)p[e]=p[e+1]*c[e+1]}const f=Eo(n,s*i);for(let m=0;m<s;++m){let t=0;for(let n=0;n<d;++n)t+=e[m*d+n]*h[n];for(let e=0;e<i;++e)f[m*i+e]=Math.trunc(t/p[e]),t%=p[e]}return[f,[s,i],c]}const eF={kernelName:Pc,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{inputIndices:a,inputShape:r,newShape:o}=t;if(2!==a.shape.length)throw new Error("Input indices should be a matrix but received shape\n        ".concat(a.shape));if(1!==r.shape.length)throw new Error("Input shape should be a vector but received shape\n        ".concat(r.shape));if(1!==o.shape.length)throw new Error("Target shape should be a vector but received shape ".concat(o.shape));const s=Array.from(n.data.get(r.dataId).values),i=n.data.get(a.dataId).values,c=Array.from(n.data.get(o.dataId).values),[l,u,d]=$A(i,a.shape,a.dtype,s,c);return[n.makeTensorInfo(u,a.dtype,l),n.makeTensorInfo([d.length],o.dtype,new Int32Array(d))]}};function tF(e,t,n,a,r){let o=arguments.length>5&&void 0!==arguments[5]&&arguments[5],s=arguments.length>6&&void 0!==arguments[6]?arguments[6]:0;const i=a.length,c=[t[0],e.length/t[0]],l=c[1],u=i>0?r[i-1]+1:0;if(u<0)throw new Error("segment ids must be >= 0");const d=t.slice();d[0]=u;const h=Eo(n,d.reduce(((e,t)=>e*t),1));if(0===i)return u>0&&h.fill(s),[h,d];if(u<=0)throw new Error("segment ids must be >= 0");let p=0,f=1,m=0,g=r[p];for(;;){let t=0;if(f<i){if(t=r[f],g===t){++f;continue}if(g>=t)throw new Error("segment ids are not increasing")}if(g<0||g>=u)throw new Error(Zg(g,u));g>m&&h.fill(s,m*l,g*l);for(let n=p;n<f;++n){const t=a[n];if(t<0||t>=c[0])throw new Error($g(n,a[n],c[0]));for(let n=0;n<l;n++)h[g*l+n]+=e[t*l+n]}if(o)for(let e=0;e<l;e++)h[g*l+e]/=f-p;if(p=f,++f,m=g+1,g=t,f>i)break}return m<u&&h.fill(s,m*l,u*l),[h,d]}const nF={kernelName:zc,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{data:a,indices:r,segmentIds:o}=t;if(a.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==r.shape.length)throw new Error("Indices should be a vector but received shape\n          ".concat(r.shape));if(1!==o.shape.length)throw new Error("Segment ids should be a vector but received shape\n          ".concat(o.shape));if(r.shape[0]!==o.shape[0])throw new Error("segmentIds and indices should have same size.");const s=n.data.get(a.dataId).values,i=n.data.get(r.dataId).values,c=n.data.get(o.dataId).values,[l,u]=tF(s,a.shape,a.dtype,i,c,!0);return n.makeTensorInfo(u,a.dtype,l)}};const aF={kernelName:Bc,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{data:a,indices:r,segmentIds:o}=t;if(a.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==r.shape.length)throw new Error("Indices should be a vector but received shape\n         ".concat(r.shape));if(1!==o.shape.length)throw new Error("Segment ids should be a vector but received shape\n         ".concat(o.shape));if(r.shape[0]!==o.shape[0])throw new Error("segmentIds and indices should have same size.");const s=n.data.get(a.dataId).values,i=n.data.get(r.dataId).values,c=n.data.get(o.dataId).values,[l,u]=tF(s,a.shape,a.dtype,i,c);return n.makeTensorInfo(u,a.dtype,l)}};const rF={kernelName:Wc,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{sparseIndices:r,sparseValues:o,defaultValue:s}=t,{outputShape:i}=a,{sliceRank:c,numUpdates:l,sliceSize:u,strides:d,outputSize:h}=fg(0,r,i),p=!1,f=n.bufferSync(r);let m;switch(o.dtype){case"bool":m=AA(f,n.bufferSync(o),i,h,u,l,c,d,Boolean(n.data.get(s.dataId).values[0]),p);break;case"float32":m=AA(f,n.bufferSync(o),i,h,u,l,c,d,n.data.get(s.dataId).values[0],p);break;case"int32":m=AA(f,n.bufferSync(o),i,h,u,l,c,d,n.data.get(s.dataId).values[0],p);break;case"string":m=AA(f,n.bufferSync(o),i,h,u,l,c,d,Vl(n.data.get(s.dataId).values[0]),p);break;default:throw new Error("Unsupported type ".concat(o.dtype))}return n.makeTensorInfo(i,m.dtype,m.values)}};const oF={kernelName:Dc,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{numOrSizeSplits:o,axis:s}=a,i=No(s,r.shape)[0],c=Vg(r,o,i),l=new Array(r.shape.length).fill(0),u=r.shape.slice();return c.map((e=>{const t=[...u];t[i]=e;const a=zT({inputs:{x:r},backend:n,attrs:{begin:l,size:t}});return l[i]+=e,a}))}},sF=yC((e=>Math.sqrt(e))),iF=xC(Ac,(e=>Math.sqrt(e))),cF={kernelName:Ac,backendName:"cpu",kernelFunc:iF},lF={kernelName:Uc,backendName:"cpu",kernelFunc:e=>{let{inputs:t,backend:n}=e;const{x:a}=t,r=n;mC(a,"square");const o=r.data.get(a.dataId).values,s=new Float32Array(o.length);for(let i=0;i<o.length;++i){const e=o[i];s[i]=e*e}return{dataId:r.write(s,a.shape,a.dtype),shape:a.shape,dtype:a.dtype}}},uF=TC(((e,t)=>{const n=e-t;return n*n})),dF=qC(Vc,uF),hF={kernelName:Vc,backendName:"cpu",kernelFunc:dF},pF=yC(((e,t)=>{const{pattern:n,replaceGlobal:a,rewrite:r}=t;return e.replace(new RegExp(n,a?"g":""),r)})),fF=vC(Gc,pF),mF={kernelName:Gc,backendName:"cpu",kernelFunc:fF},gF=xC(ol,((e,t)=>{const n=t;return isNaN(e)?NaN:e>0?1:n.alpha})),bF={kernelName:ol,backendName:"cpu",kernelFunc:gF};function yF(e,t,n,a){const r=Od(e,t.dtype);for(let o=0;o<r.size;o++){const e=r.indexToLoc(o),s=new Array(e.length);for(let t=0;t<s.length;t++)s[t]=e[t]*n[t]+a[t];r.set(t.get(...s),...e)}return r}const xF={kernelName:Hc,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{begin:o,end:s,strides:i,beginMask:c,endMask:l,ellipsisMask:u,newAxisMask:d,shrinkAxisMask:h}=a;mC(r,"stridedSlice");const{finalShapeSparse:p,finalShape:f,isIdentity:m,sliceDim0:g,isSimpleSlice:b,begin:y,end:x,strides:v}=zh(r.shape,o,s,i,c,l,u,d,h);let w;if(m)w=$C({inputs:{x:r},backend:n,attrs:{shape:f}});else if(g||b){mo(r.shape.length>=1,(()=>"Input must have rank at least 1, got: ".concat(r.shape.length)));const e=Nh(y,x,v),t=zT({inputs:{x:r},backend:n,attrs:{begin:y,size:e}});w=$C({inputs:{x:t},backend:n,attrs:{shape:f}}),n.disposeIntermediateTensorInfo(t)}else{const e=yF(p,n.bufferSync(r),v,y);w=n.makeTensorInfo(f,e.dtype,e.values)}return w}};class vF{constructor(e,t,n,a,r,o){this.separator=Wl(e),this.nGramWidths=t,this.leftPad=Wl(n),this.rightPad=Wl(a),this.padWidth=r,this.preserveShort=o}getPadWidth(e){return Math.min(this.padWidth<0?e-1:this.padWidth,e-1)}getNumNGrams(e,t){const n=this.getPadWidth(t);return Math.max(0,e+2*n-t+1)}createNGrams(e,t,n,a,r,o){for(let s=0;s<r;++s){const i=this.getPadWidth(o),c=Math.max(0,i-s),l=Math.max(0,i-(r-(s+1))),u=o-(c+l),d=t+(c>0?0:s-i);let h=0;h+=c*this.leftPad.length;for(let t=0;t<u;++t)h+=e[d+t].length;h+=l*this.rightPad.length;h+=(c+l+u-1)*this.separator.length,n[a+s]=new Uint8Array(h);const p=n[a+s];let f=0;const m=e=>e.forEach((e=>p[f++]=e));for(let e=0;e<c;++e)m(this.leftPad),m(this.separator);for(let t=0;t<u-1;++t)m(e[d+t]),m(this.separator);if(u>0){m(e[d+u-1]);for(let e=0;e<l;++e)m(this.separator),m(this.rightPad)}else{for(let e=0;e<l-1;++e)m(this.rightPad),m(this.separator);m(this.rightPad)}}}compute(e,t){const n=e.length,a=t.length;if(a>0){let e=t[0];if(0!==e)throw new Error("First split value must be 0, got ".concat(e));for(let r=1;r<a;++r){let a=t[r]>=e;if(a=a&&t[r]<=n,!a)throw new Error("Invalid split value ".concat(t[r],", must be in [").concat(e,", ").concat(n,"]"));e=t[r]}if(e!==n)throw new Error("Last split value must be data size. Expected ".concat(n,", got ").concat(e))}const r=a-1,o=Eo("int32",a);if(0===n||0===a){const e=new Array(n);for(let t=0;t<=r;++t)o[t]=0;return[e,o]}o[0]=0;for(let i=1;i<=r;++i){const e=t[i]-t[i-1];let n=0;this.nGramWidths.forEach((t=>{n+=this.getNumNGrams(e,t)})),this.preserveShort&&e>0&&0===n&&(n=1),o[i]=o[i-1]+n}const s=new Array(o[r]);for(let i=0;i<r;++i){const n=t[i];let a=o[i];if(this.nGramWidths.forEach((r=>{const o=t[i+1]-t[i],c=this.getNumNGrams(o,r);this.createNGrams(e,n,s,a,c,r),a+=c})),this.preserveShort&&a===o[i]){const r=t[i+1]-t[i];if(0===r)continue;const o=r+2*this.padWidth,c=1;this.createNGrams(e,n,s,a,c,o)}}return[s,o]}}function wF(e,t,n,a,r,o,s,i){return new vF(n,a,r,o,s,i).compute(e,t)}const kF={kernelName:jc,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{separator:r,nGramWidths:o,leftPad:s,rightPad:i,padWidth:c,preserveShortSequences:l}=a,{data:u,dataSplits:d}=t,h=n.data.get(u.dataId).values,p=n.data.get(d.dataId).values,[f,m]=wF(h,p,r,o,s,i,c,l);return[n.makeTensorInfo([f.length],"string",f),n.makeTensorInfo(d.shape,"int32",m)]}};function IF(e,t,n,a){if(!e.length)return;if(0===t.length){for(let t=0;t<e.length;++t)a.push(e.subarray(t,t+1));return}if(1===t.length){const r=t[0];let o=e.indexOf(r);for(;-1!==o;){const t=e.subarray(0,o);n&&0===t.length||a.push(t),o=(e=e.subarray(o+1)).indexOf(r)}return void(n&&0===e.length||a.push(e))}let r=0;for(let o=0;o<e.length+1;o++)if(o===e.length||-1!==t.indexOf(e[o])){const t=e.subarray(r,o);n&&0===t.length||a.push(t),r=o+1}}function SF(e,t,n){const a=e.length,r=[];let o=0,s=0;const i=new Array(a);for(let h=0;h<a;++h){const a=r.length;IF(e[h],t,n,r);const c=r.length-a;i[h]=c,o+=c,s=Math.max(s,c)}const c=Eo("int32",2*o),l=new Array(o),u=[a,s];let d=0;for(let h=0;h<a;++h)for(let e=0;e<i[h];++e)c[2*d]=h,c[2*d+1]=e,l[d]=r[d],++d;return[c,l,u]}const NF={kernelName:Kc,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{skipEmpty:r}=a,{input:o,delimiter:s}=t;if("string"!==o.dtype)throw new Error("Input must be of datatype string");if(1!==o.shape.length)throw new Error("Input must be a vector, got shape: ".concat(o.shape));if(0!==s.shape.length)throw new Error("Delimiter must be a scalar, got shape: ".concat(s.shape));const i=n.data.get(o.dataId).values,c=n.data.get(s.dataId).values[0],[l,u,d]=SF(i,c,r),h=u.length;return[n.makeTensorInfo([h,2],"int32",l),n.makeTensorInfo([h],"string",u),n.makeTensorInfo([2],"int32",new Int32Array(d))]}};function CF(e,t){const n=Eo("int32",e.length);for(let a=0;a<e.length;++a)n[a]=Ll(e[a]).modulo(t).getLowBitsUnsigned();return n}const TF={kernelName:qc,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{numBuckets:r}=a,{input:o}=t;if("string"!==o.dtype)throw new Error("Input must be of datatype string");if(r<=0)throw new Error("Number of buckets must be at least 1");const s=CF(n.data.get(o.dataId).values,r);return n.makeTensorInfo(o.shape,"int32",s)}},EF=xC(Yc,(e=>Math.tan(e))),RF={kernelName:Yc,backendName:"cpu",kernelFunc:EF},_F=xC(Qc,(e=>Math.tanh(e)));const AF={kernelName:wc,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{tensor:a,indices:r,updates:o}=t,{sliceRank:s,numUpdates:i,sliceSize:c,strides:l,outputSize:u}=fg(0,r,a.shape),d=n.bufferSync(r),h=n.bufferSync(o),p=n.bufferSync(a),f=AA(d,h,a.shape,u,c,i,s,l,p,!1);return n.makeTensorInfo(a.shape,f.dtype,f.values)}};function FF(e,t){const n=new Array(e.rank);for(let r=0;r<n.length;r++)n[r]=e.shape[r]*t[r];const a=Od(n,e.dtype);for(let r=0;r<a.values.length;++r){const t=a.indexToLoc(r),n=new Array(e.rank);for(let a=0;a<n.length;a++)n[a]=t[a]%e.shape[a];const o=e.locToIndex(n);a.values[r]=e.values[o]}return a}const OF={kernelName:Jc,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{reps:o}=a;mC(r,"tile");const s=FF(n.bufferSync(r),o);return n.makeTensorInfo(s.shape,s.dtype,s.values)}},DF=(e,t)=>{const n=t.value-e.value;return 0===n?e.index-t.index:n};function MF(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:e.length-1;for(;a>n;){if(a-n>600){const r=a-n+1,o=t-n+1,s=Math.log(r),i=.5*Math.exp(2*s/3),c=.5*Math.sqrt(s*i*(r-i)/r)*Math.sign(o-r/2);MF(e,t,Math.max(n,Math.floor(t-o*i/r+c)),Math.min(a,Math.floor(t+(r-o)*i/r+c)))}const r=e[t];let o=n,s=a;for(fo(e,n,t),DF(e[a],r)>0&&fo(e,n,a);o<s;){for(fo(e,o,s),o++,s--;DF(e[o],r)<0;)o+=1;for(;DF(e[s],r)>0;)s-=1}0===DF(e[n],r)?fo(e,n,s):(s+=1,fo(e,s,a)),s<=t&&(n=s+1),t<=s&&(a=s-1)}}function LF(e,t,n,a,r){const o=t[t.length-1],[s,i]=[e.length/o,o],c=To(n,s*a),l=To("int32",s*a);for(let d=0;d<s;d++){const t=d*i,n=e.subarray(t,t+i);let o=new Array(n.length);n.forEach(((e,t)=>o[t]={value:e,index:t})),a<o.length&&(MF(o,a),o=o.slice(0,a)),r&&o.sort(DF);const s=d*a,u=c.subarray(s,s+a),h=l.subarray(s,s+a);for(let e=0;e<a;e++)u[e]=o[e].value,h[e]=o[e].index}const u=t.slice();return u[u.length-1]=a,[Od(u,n,c),Od(u,"int32",l)]}const PF={kernelName:Zc,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{k:o,sorted:s}=a;mC(r,"topk");const i=n.data.get(r.dataId).values,[c,l]=LF(i,r.shape,r.dtype,o,s);return[n.makeTensorInfo(c.shape,c.dtype,c.values),n.makeTensorInfo(l.shape,l.dtype,l.values)]}};const zF={kernelName:$c,backendName:"cpu",kernelFunc:function(e){const{inputs:t,attrs:n,backend:a}=e,{image:r,transforms:o}=t,{interpolation:s,fillMode:i,fillValue:c,outputShape:l}=n,[u,d,h,p]=r.shape,[f,m]=null!=l?l:[d,h],g=[u,f,m,p],b=Lo(r.shape),y=b[0],x=b[1],v=b[2],w=Lo(g),k=w[0],I=w[1],S=w[2],N=To(r.dtype,yo(g));N.fill(c);const C=a.data.get(r.dataId).values,T=a.data.get(o.dataId).values;for(let E=0;E<u;++E){const e=1===o.shape[0]?T:T.subarray(8*E,8*E+8);for(let t=0;t<f;++t)for(let n=0;n<m;++n)for(let a=0;a<p;++a){let r;const o=e[6]*n+e[7]*t+1;if(0===o)continue;const l=(e[0]*n+e[1]*t+e[2])/o,u=(e[3]*n+e[4]*t+e[5])/o,p=BF(l,h,i),f=BF(u,d,i);switch(s){case"nearest":r=VF(C,d,h,y,x,v,E,f,p,a,c);break;case"bilinear":r=UF(C,d,h,y,x,v,E,f,p,a,c);break;default:throw new Error("Error in Transform: Expect 'nearest' or "+"'bilinear', but got ".concat(s))}N[E*k+t*I+n*S+a]=r}return a.makeTensorInfo(g,r.dtype,N)}return{dataId:a.write(N,g,r.dtype),shape:r.shape,dtype:r.dtype}}};function BF(e,t,n){switch(n){case"reflect":return function(e,t){let n=e;if(n<0)if(t<=1)n=0;else{const e=2*t;n<e&&(n=e*Math.trunc(-n/e)+n),n=n<-t?n+e:-n-1}else if(n>t-1)if(t<=1)n=0;else{const e=2*t;n-=e*Math.trunc(n/e),n>=t&&(n=e-n-1)}return ho(0,n,t-1)}(e,t);case"wrap":return function(e,t){let n=e;if(n<0)if(t<=1)n=0;else{const e=t-1;n+=t*(Math.trunc(-n/e)+1)}else if(n>t-1)if(t<=1)n=0;else{const e=t-1;n-=t*Math.trunc(n/e)}return ho(0,n,t-1)}(e,t);case"nearest":return function(e,t){return ho(0,e,t-1)}(e,t);default:return function(e,t){return e}(e)}}function WF(e,t,n,a,r,o,s,i,c,l,u){return 0<=i&&i<t&&0<=c&&c<n?e[s*a+i*r+c*o+l]:u}function VF(e,t,n,a,r,o,s,i,c,l,u){return WF(e,t,n,a,r,o,s,Math.round(i),Math.round(c),l,u)}function UF(e,t,n,a,r,o,s,i,c,l,u){const d=Math.floor(i),h=Math.floor(c),p=d+1,f=h+1;return(p-i)*((f-c)*WF(e,t,n,a,r,o,s,d,h,l,u)+(c-h)*WF(e,t,n,a,r,o,s,d,f,l,u))+(i-d)*((f-c)*WF(e,t,n,a,r,o,s,p,h,l,u)+(c-h)*WF(e,t,n,a,r,o,s,p,f,l,u))}function GF(e,t,n,a){const r=No(t,n)[0],o=[1,n[0],1];for(let f=0;f<r;f++)o[0]*=n[f];o[1]=n[r];for(let f=r+1;f<n.length;f++)o[2]*=n[f];const s=new Map,i=new Int32Array(n[r]),c=new tu(o,a,e),l=[],u=1===o[0]&&1===o[2];for(let f=0;f<n[r];f++){let t;if(u)t=e[f].toString();else{const e=[];for(let t=0;t<o[0];t++)for(let n=0;n<o[2];n++)e.push(c.get(t,f,n));t=e.join(",")}const n=s.get(t);if(null!=n)i[f]=n;else{const e=s.size;s.set(t,e),i[f]=e,l.push(f)}}const d=o.slice();d[1]=s.size;const h=new tu(d,a);l.forEach(((e,t)=>{for(let n=0;n<o[0];n++)for(let a=0;a<o[2];a++)h.set(c.get(n,e,a),n,t,a)}));const p=n.slice();return p[r]=d[1],{outputValues:h.values,outputShape:p,indices:i}}const HF={kernelName:tl,backendName:"cpu",kernelFunc:function(e){const{inputs:t,attrs:n,backend:a}=e,{axis:r}=n,{x:o}=t;mC(o,"unique");const s=a.data.get(o.dataId).values,{outputValues:i,outputShape:c,indices:l}=GF(s,r,o.shape,o.dtype);return[a.makeTensorInfo(c,o.dtype,i),a.makeTensorInfo([l.length],"int32",l)]}};const jF={kernelName:nl,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{value:r}=t;let{axis:o}=a;o<0&&(o+=r.shape.length);const s=r.shape.length,i=r.shape[o],c=new Array(s-1);let l=0;for(let p=0;p<s;p++)p!==o&&(c[l++]=r.shape[p]);const u=new Array(s).fill(0),d=r.shape.slice();d[o]=1;const h=new Array(i);for(let p=0;p<h.length;p++){u[o]=p;const e=zT({inputs:{x:r},backend:n,attrs:{begin:u,size:d}});h[p]=$C({inputs:{x:e},backend:n,attrs:{shape:c}}),n.disposeIntermediateTensorInfo(e)}return h}};const KF={kernelName:al,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r,segmentIds:o}=t,{numSegments:s}=a;mC(r,"unsortedSegmentSum");const i=[],c=[],l=r.shape.length-o.shape.length;let u=o;for(let h=0;h<l;++h){const e=JE({inputs:{input:u},backend:n,attrs:{dim:h+1}});u=e,c.push(e)}for(let h=0;h<s;++h){const e=Pl(h,"int32"),t=n.makeTensorInfo([],"int32",e),a=zE({inputs:{a:t,b:u},backend:n}),o=jC({inputs:{x:a},backend:n,attrs:{dtype:"float32"}}),s=AE({inputs:{a:o,b:r},backend:n}),l=OE({inputs:{x:s},backend:n,attrs:{axis:0,keepDims:!1}});i.push(l),c.push(t),c.push(a),c.push(o),c.push(s),c.push(l)}const d=X_({inputs:i,backend:n,attrs:{axis:0}});return c.forEach((e=>n.disposeIntermediateTensorInfo(e))),d}},qF=[aT,oT,iT,lT,ZC,uT,fT,mT,gT,bT,xT,wT,IT,CT,ET,FT,OT,DT,MT,nT,LT,WT,GT,jT,KT,KC,YT,JT,WC,ZT,aE,oE,sE,iE,cE,lE,uE,hE,fE,mE,gE,bE,yE,xE,wE,kE,IE,SE,NE,CE,TE,EE,ME,kC,LE,BE,qE,QE,ZE,tR,hR,fR,mR,yR,wR,kR,IR,NR,TR,_R,OR,SC,DR,tE,LR,zR,WR,CC,GR,KR,XR,JR,$R,n_,r_,i_,c_,l_,h_,m_,g_,b_,y_,x_,v_,w_,k_,N_,C_,R_,F_,FE,D_,L_,z_,W_,G_,H_,q_,Y_,Q_,$_,_C,tA,sA,lA,mA,bA,GC,rR,xA,FC,DC,eT,vA,wA,kA,IA,SA,NA,TA,_A,FA,MA,LA,WA,PC,UA,HA,KA,BT,A_,YA,QA,ZA,eF,nF,aF,rF,oF,cF,lF,hF,mF,bF,xF,kF,NF,TF,cR,DE,RF,{kernelName:Qc,backendName:"cpu",kernelFunc:_F},AF,OF,PF,zF,pT,HF,jF,KF,K_];for(const n of qF)yl(n);const XF={},YF={alpha:!1,antialias:!1,premultipliedAlpha:!1,preserveDrawingBuffer:!1,depth:!1,stencil:!1,failIfMajorPerformanceCaveat:!0};function QF(e,t){if(!(e in XF)||null!=t){const n=function(e,t){if(1!==e&&2!==e)throw new Error("Cannot get WebGL rendering context, WebGL is disabled.");const n=null==t?function(e){if(Yo().getBool("IS_SAFARI")||"undefined"===typeof OffscreenCanvas||2!==e){if("undefined"!==typeof document)return document.createElement("canvas");throw new Error("Cannot create a canvas in this context")}return new OffscreenCanvas(300,150)}(e):t;n.addEventListener("webglcontextlost",(t=>{t.preventDefault(),delete XF[e]}),!1),Yo().getBool("SOFTWARE_WEBGL_ENABLED")&&(YF.failIfMajorPerformanceCaveat=!1);if(1===e)return n.getContext("webgl",YF)||n.getContext("experimental-webgl",YF);return n.getContext("webgl2",YF)}(e,t);if(null===n)return console.log("Could not get context for WebGL version",e),null;XF[e]=n}const n=XF[e];return null==n||n.isContextLost()?(delete XF[e],QF(e)):(n.disable(n.DEPTH_TEST),n.disable(n.STENCIL_TEST),n.disable(n.BLEND),n.disable(n.DITHER),n.disable(n.POLYGON_OFFSET_FILL),n.disable(n.SAMPLE_COVERAGE),n.enable(n.SCISSOR_TEST),n.enable(n.CULL_FACE),n.cullFace(n.BACK),XF[e])}var JF,ZF,$F;function eO(e,t){return[t,e]}function tO(e){const t=yo(e);return wo(Math.ceil(t/4))}function nO(e,t){return[Math.max(1,Math.ceil(t/2)),Math.max(1,Math.ceil(e/2))]}function aO(e,t){const n=e;let a,r,o,s,i,c,l,u,d,h;return 2===Yo().getNumber("WEBGL_VERSION")?(a=n.R32F,r=n.R16F,o=n.RGBA16F,s=n.RGBA32F,i=n.RED,l=4,u=1,d=n.HALF_FLOAT,h=n.FLOAT,c=n.RGBA8):(a=e.RGBA,r=e.RGBA,o=e.RGBA,s=n.RGBA,i=e.RGBA,l=4,u=4,d=null!=t?t.HALF_FLOAT_OES:null,h=e.FLOAT,c=e.RGBA),{internalFormatFloat:a,internalFormatHalfFloat:r,internalFormatPackedHalfFloat:o,internalFormatPackedFloat:s,textureFormatFloat:i,downloadTextureFormat:c,downloadUnpackNumChannels:l,defaultNumChannels:u,textureTypeHalfFloat:d,textureTypeFloat:h}}function rO(e,t){const n=t();return Yo().getBool("DEBUG")&&function(e){const t=e.getError();if(t!==e.NO_ERROR)throw new Error("WebGL Error: "+function(e,t){switch(t){case e.NO_ERROR:return"NO_ERROR";case e.INVALID_ENUM:return"INVALID_ENUM";case e.INVALID_VALUE:return"INVALID_VALUE";case e.INVALID_OPERATION:return"INVALID_OPERATION";case e.INVALID_FRAMEBUFFER_OPERATION:return"INVALID_FRAMEBUFFER_OPERATION";case e.OUT_OF_MEMORY:return"OUT_OF_MEMORY";case e.CONTEXT_LOST_WEBGL:return"CONTEXT_LOST_WEBGL";default:return"Unknown error code ".concat(t)}}(e,t))}(e),n}!function(e){e[e.DENSE=0]="DENSE",e[e.SHARED_BATCH=1]="SHARED_BATCH"}(JF||(JF={})),function(e){e[e.RENDER=0]="RENDER",e[e.UPLOAD=1]="UPLOAD",e[e.PIXELS=2]="PIXELS",e[e.DOWNLOAD=3]="DOWNLOAD"}(ZF||(ZF={})),function(e){e[e.UNPACKED_FLOAT16=0]="UNPACKED_FLOAT16",e[e.UNPACKED_FLOAT32=1]="UNPACKED_FLOAT32",e[e.PACKED_4X1_UNSIGNED_BYTE=2]="PACKED_4X1_UNSIGNED_BYTE",e[e.PACKED_2X2_FLOAT32=3]="PACKED_2X2_FLOAT32",e[e.PACKED_2X2_FLOAT16=4]="PACKED_2X2_FLOAT16"}($F||($F={}));function oO(e){return!!(Yo().getBool("WEBGL_RENDER_FLOAT32_ENABLED")||0===e||5.96e-8<Math.abs(e)&&Math.abs(e)<65504)}function sO(e,t){return mO(e,(()=>e.getExtension(t)),'Extension "'+t+'" not supported on this browser.')}const iO=/ERROR: [0-9]+:([0-9]+):/g;function cO(e,t){const n=iO.exec(t);if(null==n)return console.log("Couldn't parse line number in error: ".concat(t)),void console.log(e);const a=+n[1],r=e.split("\n"),o=r.length.toString().length+2,s=r.map(((e,t)=>ko((t+1).toString(),o)+e));let i=0;for(let d=0;d<s.length;d++)i=Math.max(s[d].length,i);const c=s.slice(0,a-1),l=s.slice(a-1,a),u=s.slice(a);console.log(c.join("\n")),console.log(t.split("\n")[0]),console.log("%c ".concat(ko(l[0],i)),"border:1px solid red; background-color:#e3d2d2; color:#a61717"),console.log(u.join("\n"))}function lO(e,t){if(rO(e,(()=>e.validateProgram(t))),!1===e.getProgramParameter(t,e.VALIDATE_STATUS))throw console.log(e.getProgramInfoLog(t)),new Error("Shader program validation failed.")}function uO(e,t,n,a,r,o,s){const i=e.getAttribLocation(t,n);return-1!==i&&(rO(e,(()=>e.bindBuffer(e.ARRAY_BUFFER,a))),rO(e,(()=>e.vertexAttribPointer(i,r,e.FLOAT,!1,o,s))),rO(e,(()=>e.enableVertexAttribArray(i))),!0)}function dO(e,t,n,a){rO(e,(()=>function(e,t,n){gO(e,n),rO(e,(()=>e.activeTexture(e.TEXTURE0+n))),rO(e,(()=>e.bindTexture(e.TEXTURE_2D,t)))}(e,t,a))),rO(e,(()=>e.uniform1i(n,a)))}function hO(e,t,n){rO(e,(()=>e.bindFramebuffer(e.FRAMEBUFFER,n))),rO(e,(()=>e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,t,0)))}function pO(e,t){rO(e,(()=>e.bindFramebuffer(e.FRAMEBUFFER,t))),rO(e,(()=>e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,null,0)))}function fO(e){const t=e.checkFramebufferStatus(e.FRAMEBUFFER);if(t!==e.FRAMEBUFFER_COMPLETE)throw new Error("Error binding framebuffer: "+function(e,t){switch(t){case e.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_ATTACHMENT";case e.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT";case e.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:return"FRAMEBUFFER_INCOMPLETE_DIMENSIONS";case e.FRAMEBUFFER_UNSUPPORTED:return"FRAMEBUFFER_UNSUPPORTED";default:return"unknown error ".concat(t)}}(e,t))}function mO(e,t,n){const a=rO(e,(()=>t()));if(null==a)throw new Error(n);return a}function gO(e,t){const n=e.MAX_COMBINED_TEXTURE_IMAGE_UNITS-1,a=t+e.TEXTURE0;if(a<e.TEXTURE0||a>n){const e="[gl.TEXTURE0, gl.TEXTURE".concat(n,"]");throw new Error("textureUnit must be in ".concat(e,"."))}}function bO(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:2;return yo(e.slice(0,e.length-t))}function yO(e){if(0===e.length)throw Error("Cannot get rows and columns of an empty shape array.");return[e.length>1?e[e.length-2]:1,e[e.length-1]]}function xO(e){let t=[1,1,1];return 0===e.length||1===e.length&&1===e[0]||(t=[bO(e),...yO(e)]),t}function vO(e){return e%2===0}function wO(e,t){if(xo(e=e.slice(-2),t=t.slice(-2)))return!0;if(!e.length||!t.length)return!0;if(0===e[0]||0===e[1]||0===t[0]||0===t[1])return!0;if(e.length!==t.length){const n=e[e.length-1],a=t[t.length-1];if(n===a)return!0;if(vO(n)&&vO(a)&&(1===e[0]||1===t[0]))return!0}return e[1]===t[1]&&vO(e[0])&&vO(t[0])}let kO,IO;function SO(e,t){return null!=e.getExtension(t)}function NO(e){try{if(null!=QF(e))return!0}catch(B){return console.log("Error when getting WebGL context: ",B),!1}return!1}function CO(e){if(0===e)return!1;const t=QF(e);if(1!==e){if(SO(t,"EXT_color_buffer_float"))return TO(t);const e="EXT_color_buffer_half_float";if(SO(t,e)){const n=t.getExtension(e);return function(e,t){const n=aO(e,t),a=e.createTexture();e.bindTexture(e.TEXTURE_2D,a);const r=1,o=1;e.texImage2D(e.TEXTURE_2D,0,n.internalFormatHalfFloat,r,o,0,n.textureFormatFloat,n.textureTypeHalfFloat,null);const s=e.createFramebuffer();e.bindFramebuffer(e.FRAMEBUFFER,s),e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,a,0);const i=e.checkFramebufferStatus(e.FRAMEBUFFER)===e.FRAMEBUFFER_COMPLETE;return e.bindTexture(e.TEXTURE_2D,null),e.bindFramebuffer(e.FRAMEBUFFER,null),e.deleteTexture(a),e.deleteFramebuffer(s),i}(t,n)}return!1}if(!SO(t,"OES_texture_float"))return!1;if(!SO(t,"WEBGL_color_buffer_float"))return!1;return TO(t)}function TO(e){const t=aO(e),n=e.createTexture();e.bindTexture(e.TEXTURE_2D,n);e.texImage2D(e.TEXTURE_2D,0,t.internalFormatFloat,1,1,0,t.textureFormatFloat,t.textureTypeFloat,null);const a=e.createFramebuffer();e.bindFramebuffer(e.FRAMEBUFFER,a),e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,n,0);const r=e.checkFramebufferStatus(e.FRAMEBUFFER)===e.FRAMEBUFFER_COMPLETE;return e.bindTexture(e.TEXTURE_2D,null),e.bindFramebuffer(e.FRAMEBUFFER,null),e.deleteTexture(n),e.deleteFramebuffer(a),r}function EO(e,t){Array.isArray(e)||(e=[e]),e.forEach((e=>{null!=e&&mo("complex64"!==e.dtype,(()=>"".concat(t," does not support complex64 tensors ")+"in the WebGL backend."))}))}const RO=Yo();function _O(){let e,t,n,a,r,o,s,i,c,l;return 2===Yo().getNumber("WEBGL_VERSION")?(e="#version 300 es",t="in",n="out",a="in",r="texture",o="outputColor",s="out vec4 outputColor;",i=Yo().getBool("WEBGL2_ISNAN_CUSTOM")?"\n      bool isnan_custom(float val) {\n        uint floatToUint = floatBitsToUint(val);\n        return (floatToUint & 0x7fffffffu) > 0x7f800000u;\n      }\n\n      bvec4 isnan_custom(vec4 val) {\n        return bvec4(isnan_custom(val.x),\n          isnan_custom(val.y), isnan_custom(val.z), isnan_custom(val.w));\n      }\n\n      #define isnan(value) isnan_custom(value)\n    ":"",c="",l="\n      #define round(value) newRound(value)\n      int newRound(float value) {\n        return int(floor(value + 0.5));\n      }\n\n      ivec4 newRound(vec4 value) {\n        return ivec4(floor(value + vec4(0.5)));\n      }\n    "):(e="",t="attribute",n="varying",a="varying",r="texture2D",o="gl_FragColor",s="",i="\n      #define isnan(value) isnan_custom(value)\n      bool isnan_custom(float val) {\n        return (val > 0. || val < 1. || val == 0.) ? false : true;\n      }\n      bvec4 isnan_custom(vec4 val) {\n        return bvec4(isnan(val.x), isnan(val.y), isnan(val.z), isnan(val.w));\n      }\n    ",c="\n      uniform float INFINITY;\n\n      bool isinf(float val) {\n        return abs(val) == INFINITY;\n      }\n      bvec4 isinf(vec4 val) {\n        return equal(abs(val), vec4(INFINITY));\n      }\n    ",l="\n      int round(float value) {\n        return int(floor(value + 0.5));\n      }\n\n      ivec4 round(vec4 value) {\n        return ivec4(floor(value + vec4(0.5)));\n      }\n    "),{version:e,attribute:t,varyingVs:n,varyingFs:a,texture2D:r,output:o,defineOutput:s,defineSpecialNaN:i,defineSpecialInf:c,defineRound:l}}function AO(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"index";const a=Lo(t);return a.map(((t,r)=>{const o="int ".concat(e[r]," = ").concat(n," / ").concat(t),s=r===a.length-1?"int ".concat(e[r+1]," = ").concat(n," - ").concat(e[r]," * ").concat(t):"index -= ".concat(e[r]," * ").concat(t);return"".concat(o,"; ").concat(s,";")})).join("")}function FO(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"index";const a=Lo(t);return a.map(((t,r)=>{const o="int ".concat(e[r]," = ").concat(n," / outShapeStrides[").concat(r,"]"),s=r===a.length-1?"int ".concat(e[r+1]," = ").concat(n," - ").concat(e[r]," * outShapeStrides[").concat(r,"]"):"index -= ".concat(e[r]," * outShapeStrides[").concat(r,"]");return"".concat(o,"; ").concat(s,";")})).join("")}function OO(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"index";const a=e.map(((e,t)=>t)),r=function(e,t){const n=e.length,a=e.map((e=>"".concat(t,"[").concat(e,"]"))),r=new Array(n-1);r[n-2]=a[n-1];for(let o=n-3;o>=0;--o)r[o]="(".concat(r[o+1]," * ").concat(a[o+1],")");return r}(a,t);return r.map(((t,a)=>{const o="int ".concat(e[a]," = ").concat(n," / ").concat(r[a]),s=a===r.length-1?"int ".concat(e[a+1]," = ").concat(n," - ").concat(e[a]," * ").concat(r[a]):"index -= ".concat(e[a]," * ").concat(r[a]);return"".concat(o,"; ").concat(s,";")})).join("")}function DO(e){const t=Lo(e).map((e=>e.toString()));return"\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * ".concat(t[0]," + coords.y * ").concat(t[1]," + coords.z;\n  }\n")}RO.registerFlag("HAS_WEBGL",(()=>RO.getNumber("WEBGL_VERSION")>0)),RO.registerFlag("WEBGL_VERSION",(()=>NO(2)?2:NO(1)?1:0)),RO.registerFlag("WEBGL_CHECK_NUMERICAL_PROBLEMS",(()=>!1)),RO.registerFlag("WEBGL_BUFFER_SUPPORTED",(()=>2===RO.get("WEBGL_VERSION"))),RO.registerFlag("WEBGL_CPU_FORWARD",(()=>!0)),RO.registerFlag("WEBGL_FORCE_F16_TEXTURES",(()=>!1)),RO.registerFlag("WEBGL_PACK",(()=>RO.getBool("HAS_WEBGL"))),RO.registerFlag("WEBGL_PACK_NORMALIZATION",(()=>RO.getBool("WEBGL_PACK"))),RO.registerFlag("WEBGL_PACK_CLIP",(()=>RO.getBool("WEBGL_PACK"))),RO.registerFlag("WEBGL_PACK_DEPTHWISECONV",(()=>RO.getBool("WEBGL_PACK"))),RO.registerFlag("WEBGL_PACK_BINARY_OPERATIONS",(()=>RO.getBool("WEBGL_PACK"))),RO.registerFlag("WEBGL_PACK_UNARY_OPERATIONS",(()=>RO.getBool("WEBGL_PACK"))),RO.registerFlag("WEBGL_PACK_ARRAY_OPERATIONS",(()=>RO.getBool("WEBGL_PACK"))),RO.registerFlag("WEBGL_PACK_IMAGE_OPERATIONS",(()=>RO.getBool("WEBGL_PACK"))),RO.registerFlag("WEBGL_PACK_REDUCE",(()=>RO.getBool("WEBGL_PACK"))),RO.registerFlag("WEBGL_LAZILY_UNPACK",(()=>RO.getBool("WEBGL_PACK"))),RO.registerFlag("WEBGL_CONV_IM2COL",(()=>RO.getBool("WEBGL_PACK"))),RO.registerFlag("WEBGL_PACK_CONV2DTRANSPOSE",(()=>RO.getBool("WEBGL_PACK"))),RO.registerFlag("WEBGL_MAX_TEXTURE_SIZE",(()=>function(e){if(null==kO){const t=QF(e);kO=t.getParameter(t.MAX_TEXTURE_SIZE)}return kO}(RO.getNumber("WEBGL_VERSION")))),RO.registerFlag("WEBGL_MAX_TEXTURES_IN_SHADER",(()=>function(e){if(null==IO){const t=QF(e);IO=t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS)}return Math.min(16,IO)}(RO.getNumber("WEBGL_VERSION")))),RO.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION",(()=>{const e=RO.getNumber("WEBGL_VERSION");return 0===e?0:function(e){if(0===e)return 0;let t;const n=QF(e);return t=SO(n,"EXT_disjoint_timer_query_webgl2")&&2===e?2:SO(n,"EXT_disjoint_timer_query")?1:0,t}(e)})),RO.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE",(()=>RO.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0&&!Ru())),RO.registerFlag("WEBGL_RENDER_FLOAT32_CAPABLE",(()=>function(e){if(0===e)return!1;const t=QF(e);if(1===e){if(!SO(t,"OES_texture_float"))return!1}else if(!SO(t,"EXT_color_buffer_float"))return!1;return TO(t)}(RO.getNumber("WEBGL_VERSION")))),RO.registerFlag("WEBGL_RENDER_FLOAT32_ENABLED",(()=>!RO.getBool("WEBGL_FORCE_F16_TEXTURES")&&RO.getBool("WEBGL_RENDER_FLOAT32_CAPABLE"))),RO.registerFlag("WEBGL_DOWNLOAD_FLOAT_ENABLED",(()=>CO(RO.getNumber("WEBGL_VERSION")))),RO.registerFlag("WEBGL_FENCE_API_ENABLED",(()=>{return 2===(e=RO.getNumber("WEBGL_VERSION"))&&null!=QF(e).fenceSync;var e})),RO.registerFlag("WEBGL_SIZE_UPLOAD_UNIFORM",(()=>RO.getBool("WEBGL_RENDER_FLOAT32_ENABLED")?4:0)),RO.registerFlag("WEBGL_DELETE_TEXTURE_THRESHOLD",(()=>-1),(e=>{if("number"!==typeof e)throw new Error("WEBGL_DELETE_TEXTURE_THRESHOLD must be a number but "+"got ".concat(e,"."));if(e<0&&-1!==e)throw new Error("WEBGL_DELETE_TEXTURE_THRESHOLD must be -1 (indicating never "+"delete) or at least 0, but got ".concat(e,"."))})),RO.registerFlag("WEBGL_FLUSH_THRESHOLD",(()=>Ru()?1:-1),(e=>{if("number"!==typeof e)throw new Error("WEBGL_FLUSH_THRESHOLD must be a number but got "+"".concat(e,"."));if(e<0&&-1!==e)throw new Error("WEBGL_FLUSH_THRESHOLD must be -1 (indicating never "+"manual flush) or at least 0, but got ".concat(e,"."))})),RO.registerFlag("CPU_HANDOFF_SIZE_THRESHOLD",(()=>128)),RO.registerFlag("WEBGL_USE_SHAPES_UNIFORMS",(()=>!1)),RO.registerFlag("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD",(()=>1e5)),RO.registerFlag("TOPK_K_CPU_HANDOFF_THRESHOLD",(()=>128)),RO.registerFlag("WEBGL_EXP_CONV",(()=>!1)),RO.registerFlag("SOFTWARE_WEBGL_ENABLED",(()=>RO.getBool("IS_TEST"))),RO.registerFlag("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE",(()=>1/0)),RO.registerFlag("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE",(()=>!1)),RO.registerFlag("WEBGL2_ISNAN_CUSTOM",(()=>!1)),RO.registerFlag("ENGINE_COMPILE_ONLY",(()=>!1));const MO="\n  const float FLOAT_MAX = 1.70141184e38;\n  const float FLOAT_MIN = 1.17549435e-38;\n\n  lowp vec4 encode_float(highp float v) {\n    if (isnan(v)) {\n      return vec4(255, 255, 255, 255);\n    }\n\n    highp float av = abs(v);\n\n    if(av < FLOAT_MIN) {\n      return vec4(0.0, 0.0, 0.0, 0.0);\n    } else if(v > FLOAT_MAX) {\n      return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;\n    } else if(v < -FLOAT_MAX) {\n      return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;\n    }\n\n    highp vec4 c = vec4(0,0,0,0);\n\n    highp float e = floor(log2(av));\n    highp float m = exp2(fract(log2(av))) - 1.0;\n\n    c[2] = floor(128.0 * m);\n    m -= c[2] / 128.0;\n    c[1] = floor(32768.0 * m);\n    m -= c[1] / 32768.0;\n    c[0] = floor(8388608.0 * m);\n\n    highp float ebias = e + 127.0;\n    c[3] = floor(ebias / 2.0);\n    ebias -= c[3] * 2.0;\n    c[2] += floor(ebias) * 128.0;\n\n    c[3] += 128.0 * step(0.0, -v);\n\n    return c / 255.0;\n  }\n",{getBroadcastDims:LO}=a;function PO(e,t,n){const a=[];if(e.forEach((e=>{const t=yo(e.shapeInfo.logicalShape);if(e.shapeInfo.isUniform?a.push("uniform float ".concat(e.name).concat(t>1?"[".concat(t,"]"):"",";")):(a.push("uniform sampler2D ".concat(e.name,";")),a.push("uniform int offset".concat(e.name,";"))),n.enableShapeUniforms){const{uniformShape:t}=qO(n.packedInputs,e.shapeInfo.logicalShape,e.shapeInfo.texShape);switch(t.length){case 1:a.push("uniform int ".concat(e.name,"Shape;"));break;case 2:a.push("uniform ivec2 ".concat(e.name,"Shape;"));break;case 3:a.push("uniform ivec3 ".concat(e.name,"Shape;"));break;case 4:a.push("uniform ivec4 ".concat(e.name,"Shape;"))}a.push("uniform ivec2 ".concat(e.name,"TexShape;"))}})),n.enableShapeUniforms){switch(t.logicalShape.length){case 1:a.push("uniform int outShape;");break;case 2:a.push("uniform ivec2 outShape;"),a.push("uniform int outShapeStrides;");break;case 3:a.push("uniform ivec3 outShape;"),a.push("uniform ivec2 outShapeStrides;");break;case 4:a.push("uniform ivec4 outShape;"),a.push("uniform ivec3 outShapeStrides;")}a.push("uniform ivec2 outTexShape;")}n.customUniforms&&n.customUniforms.forEach((e=>{a.push("uniform ".concat(e.type," ").concat(e.name).concat(e.arrayIndex?"[".concat(e.arrayIndex,"]"):"",";"))}));const r=a.join("\n"),o=e.map((e=>function(e,t){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],a=arguments.length>3?arguments[3]:void 0,r="";r+=n?BO(e,a):zO(e,a);const o=e.shapeInfo.logicalShape,s=t.logicalShape;o.length<=s.length&&(r+=n?function(e,t){const n=e.name,a=n.charAt(0).toUpperCase()+n.slice(1),r="get"+a+"AtOutCoords",o=e.shapeInfo.logicalShape.length,s=t.logicalShape.length,i=LO(e.shapeInfo.logicalShape,t.logicalShape),c=KO(s),l=s-o;let u;const d=["x","y","z","w","u","v"];u=0===o?"":s<2&&i.length>=1?"coords = 0;":i.map((e=>"coords.".concat(d[e+l]," = 0;"))).join("\n");let h="";h=s<2&&o>0?"coords":e.shapeInfo.logicalShape.map(((e,t)=>"coords.".concat(d[t+l]))).join(", ");let p="return outputValue;";const f=1===yo(e.shapeInfo.logicalShape),m=yo(t.logicalShape),g=1===m;if(1!==o||f||g){if(f&&!g)p=1===s?"\n        return vec4(outputValue.x, outputValue.x, 0., 0.);\n      ":"\n        return vec4(outputValue.x);\n      ";else if(i.length){const e=o-2,t=o-1;i.indexOf(e)>-1&&i.indexOf(t)>-1?p="return vec4(outputValue.x);":i.indexOf(e)>-1?p="return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);":i.indexOf(t)>-1&&(p="return vec4(outputValue.xx, outputValue.zz);")}}else p="\n      return vec4(outputValue.xy, outputValue.xy);\n    ";return"\n    vec4 ".concat(r,"() {\n      ").concat(c," coords = getOutputCoords();\n      ").concat(u,"\n      vec4 outputValue = get").concat(a,"(").concat(h,");\n      ").concat(p,"\n    }\n  ")}(e,t):function(e,t){const n=e.name,a=n.charAt(0).toUpperCase()+n.slice(1),r="get"+a+"AtOutCoords",o=t.texShape,s=e.shapeInfo.texShape,i=e.shapeInfo.logicalShape.length,c=t.logicalShape.length;if(!e.shapeInfo.isUniform&&i===c&&null==e.shapeInfo.flatOffset&&xo(s,o))return"\n      float ".concat(r,"() {\n        return sampleTexture(").concat(n,", resultUV);\n      }\n    ");const l=KO(c),u=LO(e.shapeInfo.logicalShape,t.logicalShape),d=c-i;let h;const p=["x","y","z","w","u","v"];h=0===i?"":c<2&&u.length>=1?"coords = 0;":u.map((e=>"coords.".concat(p[e+d]," = 0;"))).join("\n");let f="";f=c<2&&i>0?"coords":e.shapeInfo.logicalShape.map(((e,t)=>"coords.".concat(p[t+d]))).join(", ");return"\n    float ".concat(r,"() {\n      ").concat(l," coords = getOutputCoords();\n      ").concat(h,"\n      return get").concat(a,"(").concat(f,");\n    }\n  ")}(e,t));return r}(e,t,n.packedInputs,n.enableShapeUniforms))).join("\n"),s=t.texShape,i=_O(),c=function(e){return"\n    float sampleTexture(sampler2D textureSampler, vec2 uv) {\n      return ".concat(e.texture2D,"(textureSampler, uv).r;\n    }\n  ")}(i);let l,u,d=function(e){const t="".concat(e.version,"\n    precision highp float;\n    precision highp int;\n    precision highp sampler2D;\n    ").concat(e.varyingFs," vec2 resultUV;\n    ").concat(e.defineOutput,"\n    const vec2 halfCR = vec2(0.5, 0.5);\n\n    struct ivec5\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n    };\n\n    struct ivec6\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n      int v;\n    };\n\n    uniform float NAN;\n    ").concat(e.defineSpecialNaN,"\n    ").concat(e.defineSpecialInf,"\n    ").concat(e.defineRound,"\n\n    int imod(int x, int y) {\n      return x - y * (x / y);\n    }\n\n    int idiv(int a, int b, float sign) {\n      int res = a / b;\n      int mod = imod(a, b);\n      if (sign < 0. && mod != 0) {\n        res -= 1;\n      }\n      return res;\n    }\n\n    //Based on the work of Dave Hoskins\n    //https://www.shadertoy.com/view/4djSRW\n    #define HASHSCALE1 443.8975\n    float random(float seed){\n      vec2 p = resultUV * seed;\n      vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);\n      p3 += dot(p3, p3.yzx + 19.19);\n      return fract((p3.x + p3.y) * p3.z);\n    }\n\n    ").concat(WO,"\n    ").concat(VO,"\n    ").concat(UO,"\n  ");return t}(i);t.isPacked?(l=function(e,t,n){switch(e.length){case 0:return"\n    int getOutputCoords() {\n      return 0;\n    }\n  ";case 1:return function(e,t,n){const a=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)];if(1===a[0])return n?"\n      int getOutputCoords() {\n        return 2 * int(resultUV.x * ceil(float(outTexShape[1]) / 2.0));\n      }\n    ":"\n      int getOutputCoords() {\n        return 2 * int(resultUV.x * ".concat(a[1],".0);\n      }\n    ");if(1===a[1])return n?"\n      int getOutputCoords() {\n        return 2 * int(resultUV.y * ceil(float(outTexShape[0]) / 2.0));\n      }\n    ":"\n      int getOutputCoords() {\n        return 2 * int(resultUV.y * ".concat(a[0],".0);\n      }\n    ");if(n)return"\n    int getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n      return 2 * (resTexRC.x * packedTexShape[1] + resTexRC.y);\n    }\n  ";return"\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(".concat(a[0],", ").concat(a[1],"));\n      return 2 * (resTexRC.x * ").concat(a[1]," + resTexRC.y);\n    }\n  ")}(0,t,n);case 2:return function(e,t,n){const a=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)];if(xo(e,t))return n?"\n      ivec2 getOutputCoords() {\n        ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n        return 2 * ivec2(resultUV.yx * vec2(packedTexShape[0], packedTexShape[1]));\n      }\n    ":"\n      ivec2 getOutputCoords() {\n        return 2 * ivec2(resultUV.yx * vec2(".concat(a[0],", ").concat(a[1],"));\n      }\n    ");const r=Math.ceil(e[1]/2);if(n)return"\n    ivec2 getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      int texelsInLogicalRow = int(ceil(float(outShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n\n      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;\n      int r = 2 * (index / texelsInLogicalRow);\n      int c = imod(index, texelsInLogicalRow) * 2;\n\n      return ivec2(r, c);\n    }\n  ";return"\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(".concat(a[0],", ").concat(a[1],"));\n\n      int index = resTexRC.x * ").concat(a[1]," + resTexRC.y;\n      int r = 2 * (index / ").concat(r,");\n      int c = imod(index, ").concat(r,") * 2;\n\n      return ivec2(r, c);\n    }\n  ")}(e,t,n);case 3:return function(e,t,n){if(n)return"\n    ivec3 getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      int texelsInLogicalRow = int(ceil(float(outShape[2]) / 2.0));\n      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;\n\n      int b = index / texelsInBatch;\n      index -= b * texelsInBatch;\n\n      int r = 2 * (index / texelsInLogicalRow);\n      int c = imod(index, texelsInLogicalRow) * 2;\n\n      return ivec3(b, r, c);\n    }\n  ";const a=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)],r=Math.ceil(e[2]/2),o=r*Math.ceil(e[1]/2);return"\n    ivec3 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(".concat(a[0],", ").concat(a[1],"));\n      int index = resTexRC.x * ").concat(a[1]," + resTexRC.y;\n\n      int b = index / ").concat(o,";\n      index -= b * ").concat(o,";\n\n      int r = 2 * (index / ").concat(r,");\n      int c = imod(index, ").concat(r,") * 2;\n\n      return ivec3(b, r, c);\n    }\n  ")}(e,t,n);default:return function(e,t,n){if(n)return"\n    ivec4 getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;\n\n      int texelsInLogicalRow = int(ceil(float(outShape[3]) / 2.0));\n      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[2]) / 2.0));\n      int texelsInBatchN = texelsInBatch * outShape[1];\n\n      int b2 = index / texelsInBatchN;\n      index -= b2 * texelsInBatchN;\n\n      int b = index / texelsInBatch;\n      index -= b * texelsInBatch;\n\n      int r = 2 * (index / texelsInLogicalRow);\n      int c = imod(index, texelsInLogicalRow) * 2;\n\n      return ivec4(b2, b, r, c);\n    }\n  ";const a=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)],r=Math.ceil(e[e.length-1]/2),o=r*Math.ceil(e[e.length-2]/2);let s=o,i="",c="b, r, c";for(let l=2;l<e.length-1;l++)s*=e[e.length-l-1],i="\n      int b".concat(l," = index / ").concat(s,";\n      index -= b").concat(l," * ").concat(s,";\n    ")+i,c="b".concat(l,", ")+c;return"\n    ivec".concat(e.length," getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(").concat(a[0],", ").concat(a[1],"));\n      int index = resTexRC.x * ").concat(a[1]," + resTexRC.y;\n\n      ").concat(i,"\n\n      int b = index / ").concat(o,";\n      index -= b * ").concat(o,";\n\n      int r = 2 * (index / ").concat(r,");\n      int c = imod(index, ").concat(r,") * 2;\n\n      return ivec").concat(e.length,"(").concat(c,");\n    }\n  ")}(e,t,n)}}(t.logicalShape,s,n.enableShapeUniforms),u=function(e){return"\n    void setOutput(vec4 val) {\n      ".concat(e.output," = val;\n    }\n  ")}(i)):(l=function(e,t,n){switch(e.length){case 0:return"\n    int getOutputCoords() {\n      return 0;\n    }\n  ";case 1:return function(e,t,n){if(1===t[0])return n?"\n      int getOutputCoords() {\n        return int(resultUV.x * float(outTexShape[1]));\n      }\n    ":"\n      int getOutputCoords() {\n        return int(resultUV.x * ".concat(t[1],".0);\n      }\n    ");if(1===t[1])return n?"\n      int getOutputCoords() {\n        return int(resultUV.y * float(outTexShape[0]));\n      }\n    ":"\n      int getOutputCoords() {\n        return int(resultUV.y * ".concat(t[0],".0);\n      }\n    ");if(n)return"\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(outTexShape[0], outTexShape[1]));\n      return resTexRC.x * outTexShape[1] + resTexRC.y;\n    }\n  ";return"\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(".concat(t[0],", ").concat(t[1],"));\n      return resTexRC.x * ").concat(t[1]," + resTexRC.y;\n    }\n  ")}(0,t,n);case 2:return function(e,t,n){if(xo(e,t))return n?"\n      ivec2 getOutputCoords() {\n        return ivec2(resultUV.yx * vec2(outTexShape[0], outTexShape[1]));\n      }\n    ":"\n      ivec2 getOutputCoords() {\n        return ivec2(resultUV.yx * vec2(".concat(t[0],", ").concat(t[1],"));\n      }\n    ");if(1===e[1])return n?"\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(outTexShape[0], outTexShape[1]));\n        int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n        return ivec2(index, 0);\n      }\n    ":"\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(".concat(t[0],", ").concat(t[1],"));\n        int index = resTexRC.x * ").concat(t[1]," + resTexRC.y;\n        return ivec2(index, 0);\n      }\n    ");if(1===e[0])return n?"\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(outTexShape[0], outTexShape[1]));\n        int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n        return ivec2(0, index);\n      }\n    ":"\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(".concat(t[0],", ").concat(t[1],"));\n        int index = resTexRC.x * ").concat(t[1]," + resTexRC.y;\n        return ivec2(0, index);\n      }\n    ");if(n)return"\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(outTexShape[0], outTexShape[1]));\n      int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n      int r = index / outShape[1];\n      int c = index - r * outShape[1];\n      return ivec2(r, c);\n    }\n  ";return"\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(".concat(t[0],", ").concat(t[1],"));\n      int index = resTexRC.x * ").concat(t[1]," + resTexRC.y;\n      int r = index / ").concat(e[1],";\n      int c = index - r * ").concat(e[1],";\n      return ivec2(r, c);\n    }\n  ")}(e,t,n);case 3:return function(e,t,n){if(n){const t=FO(["r","c","d"],e);return"\n  ivec3 getOutputCoords() {\n    ivec2 resTexRC = ivec2(resultUV.yx *\n                           vec2(outTexShape[0], outTexShape[1]));\n    int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n    ".concat(t,"\n    return ivec3(r, c, d);\n  }\n")}const a=AO(["r","c","d"],e);return"\n    ivec3 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(".concat(t[0],", ").concat(t[1],"));\n      int index = resTexRC.x * ").concat(t[1]," + resTexRC.y;\n      ").concat(a,"\n      return ivec3(r, c, d);\n    }\n  ")}(e,t,n);case 4:return function(e,t,n){if(n){const t=FO(["r","c","d","d2"],e);return"\n    ivec4 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(outTexShape[0], outTexShape[1]));\n      int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n      ".concat(t,"\n      return ivec4(r, c, d, d2);\n    }\n  ")}const a=AO(["r","c","d","d2"],e);return"\n    ivec4 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(".concat(t[0],", ").concat(t[1],"));\n      int index = resTexRC.x * ").concat(t[1]," + resTexRC.y;\n      ").concat(a,"\n      return ivec4(r, c, d, d2);\n    }\n  ")}(e,t,n);case 5:return function(e,t){const n=AO(["r","c","d","d2","d3"],e);return"\n    ivec5 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx * vec2(".concat(t[0],",\n                             ").concat(t[1],"));\n\n      int index = resTexRC.x * ").concat(t[1]," + resTexRC.y;\n\n      ").concat(n,"\n\n      ivec5 outShape = ivec5(r, c, d, d2, d3);\n      return outShape;\n    }\n  ")}(e,t);case 6:return function(e,t){const n=AO(["r","c","d","d2","d3","d4"],e);return"\n    ivec6 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(".concat(t[0],", ").concat(t[1],"));\n      int index = resTexRC.x * ").concat(t[1]," + resTexRC.y;\n\n      ").concat(n,"\n\n      ivec6 result = ivec6(r, c, d, d2, d3, d4);\n      return result;\n    }\n  ")}(e,t);default:throw new Error("".concat(e.length,"-D output sampling is not yet supported"))}}(t.logicalShape,s,n.enableShapeUniforms),u=function(e){return"\n    void setOutput(float val) {\n      ".concat(e.output," = vec4(val, 0, 0, 0);\n    }\n  ")}(i)),n.packedInputs&&(d+=GO);return[d,c,u,r,l,o,n.userCode].join("\n")}function zO(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];const n=e.shapeInfo.logicalShape;switch(n.length){case 0:return function(e,t){const n=e.name,a="get"+n.charAt(0).toUpperCase()+n.slice(1);if(e.shapeInfo.isUniform)return"float ".concat(a,"() {return ").concat(n,";}");const[r,o]=e.shapeInfo.texShape;if(1===r&&1===o)return"\n      float ".concat(a,"() {\n        return sampleTexture(").concat(n,", halfCR);\n      }\n    ");const s=HO(n);if(t)return"\n    float ".concat(a,"() {\n      vec2 uv = uvFromFlat(").concat(n,"TexShape[0], ").concat(n,"TexShape[1], ").concat(s,");\n      return sampleTexture(").concat(n,", uv);\n    }\n  ");const[i,c]=e.shapeInfo.texShape;return"\n    float ".concat(a,"() {\n      vec2 uv = uvFromFlat(").concat(i,", ").concat(c,", ").concat(s,");\n      return sampleTexture(").concat(n,", uv);\n    }\n  ")}(e,t);case 1:return function(e,t){const n=e.name,a="get"+n.charAt(0).toUpperCase()+n.slice(1);if(e.shapeInfo.isUniform)return"\n      float ".concat(a,"(int index) {\n        ").concat(jO(e),"\n      }\n    ");const r=e.shapeInfo.texShape,o=r[0],s=r[1];if(1===s&&1===o)return"\n      float ".concat(a,"(int index) {\n        return sampleTexture(").concat(n,", halfCR);\n      }\n    ");const i=HO(n);if(1===s)return t?"\n      float ".concat(a,"(int index) {\n        vec2 uv = vec2(0.5, (float(index + ").concat(i,") + 0.5) / float(").concat(n,"TexShape[0]));\n        return sampleTexture(").concat(n,", uv);\n      }\n    "):"\n      float ".concat(a,"(int index) {\n        vec2 uv = vec2(0.5, (float(index + ").concat(i,") + 0.5) / ").concat(o,".0);\n        return sampleTexture(").concat(n,", uv);\n      }\n    ");if(1===o)return t?"\n      float ".concat(a,"(int index) {\n        vec2 uv = vec2((float(index + ").concat(i,") + 0.5) / float(").concat(n,"TexShape[1]), 0.5);\n        return sampleTexture(").concat(n,", uv);\n      }\n    "):"\n      float ".concat(a,"(int index) {\n        vec2 uv = vec2((float(index + ").concat(i,") + 0.5) / ").concat(s,".0, 0.5);\n        return sampleTexture(").concat(n,", uv);\n      }\n    ");if(t)return"\n    float ".concat(a,"(int index) {\n      vec2 uv = uvFromFlat(").concat(n,"TexShape[0], ").concat(n,"TexShape[1], index + ").concat(i,");\n      return sampleTexture(").concat(n,", uv);\n    }\n  ");return"\n    float ".concat(a,"(int index) {\n      vec2 uv = uvFromFlat(").concat(o,", ").concat(s,", index + ").concat(i,");\n      return sampleTexture(").concat(n,", uv);\n    }\n  ")}(e,t);case 2:return function(e,t){const n=e.shapeInfo.logicalShape,a=e.name,r="get"+a.charAt(0).toUpperCase()+a.slice(1),o=e.shapeInfo.texShape;if(null!=o&&xo(n,o)){if(t)return"\n      float ".concat(r,"(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(").concat(a,"TexShape[1], ").concat(a,"TexShape[0]);\n        return sampleTexture(").concat(a,", uv);\n      }\n    ");const e=o[0],n=o[1];return"\n    float ".concat(r,"(int row, int col) {\n      vec2 uv = (vec2(col, row) + halfCR) / vec2(").concat(n,".0, ").concat(e,".0);\n      return sampleTexture(").concat(a,", uv);\n    }\n  ")}const{newShape:s,keptDims:i}=Co(n),c=s;if(c.length<n.length){const n=XO(e,c),a=["row","col"];return"\n      ".concat(zO(n,t),"\n      float ").concat(r,"(int row, int col) {\n        return ").concat(r,"(").concat(YO(a,i),");\n      }\n    ")}if(e.shapeInfo.isUniform)return"\n      float ".concat(r,"(int row, int col) {\n        int index = round(dot(vec2(row, col), vec2(").concat(n[1],", 1)));\n        ").concat(jO(e),"\n      }\n    ");const l=o[0],u=o[1],d=HO(a);if(1===u)return t?"\n      float ".concat(r,"(int row, int col) {\n        float index = dot(vec3(row, col, ").concat(d,"), vec3(").concat(a,"Shape[1], 1, 1));\n        vec2 uv = vec2(0.5, (index + 0.5) / float(").concat(a,"TexShape[0]));\n        return sampleTexture(").concat(a,", uv);\n      }\n    "):"\n    float ".concat(r,"(int row, int col) {\n      float index = dot(vec3(row, col, ").concat(d,"), vec3(").concat(n[1],", 1, 1));\n      vec2 uv = vec2(0.5, (index + 0.5) / ").concat(l,".0);\n      return sampleTexture(").concat(a,", uv);\n    }\n  ");if(1===l)return t?"\n      float ".concat(r,"(int row, int col) {\n        float index = dot(vec3(row, col, ").concat(d,"), vec3(").concat(a,"Shape[1], 1, 1));\n        vec2 uv = vec2((index + 0.5) / float(").concat(a,"TexShape[1]), 0.5);\n        return sampleTexture(").concat(a,", uv);\n      }\n    "):"\n    float ".concat(r,"(int row, int col) {\n      float index = dot(vec3(row, col, ").concat(d,"), vec3(").concat(n[1],", 1, 1));\n      vec2 uv = vec2((index + 0.5) / ").concat(u,".0, 0.5);\n      return sampleTexture(").concat(a,", uv);\n    }\n  ");if(t)return"\n      float ".concat(r,"(int row, int col) {\n        // Explicitly use integer operations as dot() only works on floats.\n        int index = row * ").concat(a,"Shape[1] + col + ").concat(d,";\n        vec2 uv = uvFromFlat(").concat(a,"TexShape[0], ").concat(a,"TexShape[1], index);\n        return sampleTexture(").concat(a,", uv);\n      }\n    ");return"\n  float ".concat(r,"(int row, int col) {\n    // Explicitly use integer operations as dot() only works on floats.\n    int index = row * ").concat(n[1]," + col + ").concat(d,";\n    vec2 uv = uvFromFlat(").concat(l,", ").concat(u,", index);\n    return sampleTexture(").concat(a,", uv);\n  }\n")}(e,t);case 3:return function(e,t){const n=e.shapeInfo.logicalShape,a=e.name,r="get"+a.charAt(0).toUpperCase()+a.slice(1),o=n[1]*n[2],s=n[2],{newShape:i,keptDims:c}=Co(n),l=i;if(l.length<n.length){const n=XO(e,l),a=["row","col","depth"];return"\n        ".concat(zO(n,t),"\n        float ").concat(r,"(int row, int col, int depth) {\n          return ").concat(r,"(").concat(YO(a,c),");\n        }\n      ")}if(e.shapeInfo.isUniform)return"\n      float ".concat(r,"(int row, int col, int depth) {\n        int index = round(dot(vec3(row, col, depth),\n                          vec3(").concat(o,", ").concat(s,", 1)));\n        ").concat(jO(e),"\n      }\n    ");const u=e.shapeInfo.texShape,d=u[0],h=u[1],p=e.shapeInfo.flatOffset;if(h===o&&null==p)return t?"\n      float ".concat(r,"(int row, int col, int depth) {\n        int stride1 = ").concat(a,"Shape[2];\n        float texR = float(row);\n        float texC = dot(vec2(col, depth), vec2(stride1, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(").concat(a,"TexShape[1], ").concat(a,"TexShape[0]);\n        return sampleTexture(").concat(a,", uv);\n      }\n    "):"\n        float ".concat(r,"(int row, int col, int depth) {\n          float texR = float(row);\n          float texC = dot(vec2(col, depth), vec2(").concat(s,", 1));\n          vec2 uv = (vec2(texC, texR) + halfCR) /\n                     vec2(").concat(h,".0, ").concat(d,".0);\n          return sampleTexture(").concat(a,", uv);\n        }\n      ");if(h===s&&null==p)return t?"\n      float ".concat(r,"(int row, int col, int depth) {\n        float texR = dot(vec2(row, col), vec2(").concat(a,"Shape[1], 1));\n        float texC = float(depth);\n        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(").concat(a,"TexShape[1], ").concat(a,"TexShape[0]);\n        return sampleTexture(").concat(a,", uv);\n      }\n    "):"\n    float ".concat(r,"(int row, int col, int depth) {\n      float texR = dot(vec2(row, col), vec2(").concat(n[1],", 1));\n      float texC = float(depth);\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(").concat(h,".0, ").concat(d,".0);\n      return sampleTexture(").concat(a,", uv);\n    }\n  ");const f=HO(a);if(t)return"\n    float ".concat(r,"(int row, int col, int depth) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int stride0 = ").concat(a,"Shape[1] * ").concat(a,"Shape[2];\n      int stride1 = ").concat(a,"Shape[2];\n      int index = row * stride0 + col * stride1 + depth + ").concat(f,";\n      vec2 uv = uvFromFlat(").concat(a,"TexShape[0], ").concat(a,"TexShape[1], index);\n      return sampleTexture(").concat(a,", uv);\n    }\n    ");return"\n      float ".concat(r,"(int row, int col, int depth) {\n        // Explicitly use integer operations as dot() only works on floats.\n        int index = row * ").concat(o," + col * ").concat(s," + depth + ").concat(f,";\n        vec2 uv = uvFromFlat(").concat(d,", ").concat(h,", index);\n        return sampleTexture(").concat(a,", uv);\n      }\n  ")}(e,t);case 4:return function(e,t){const n=e.shapeInfo.logicalShape,a=e.name,r="get"+a.charAt(0).toUpperCase()+a.slice(1),o=n[3],s=n[2]*o,i=n[1]*s,{newShape:c,keptDims:l}=Co(n);if(c.length<n.length){const n=XO(e,c),a=["row","col","depth","depth2"];return"\n      ".concat(zO(n,t),"\n      float ").concat(r,"(int row, int col, int depth, int depth2) {\n        return ").concat(r,"(").concat(YO(a,l),");\n      }\n    ")}if(e.shapeInfo.isUniform)return"\n      float ".concat(r,"(int row, int col, int depth, int depth2) {\n        int index = round(dot(vec4(row, col, depth, depth2),\n                          vec4(").concat(i,", ").concat(s,", ").concat(o,", 1)));\n        ").concat(jO(e),"\n      }\n    ");const u=e.shapeInfo.flatOffset,d=e.shapeInfo.texShape,h=d[0],p=d[1],f="int stride2 = ".concat(a,"Shape[3];"),m="int stride1 = ".concat(a,"Shape[2] * stride2;"),g="int stride0 = ".concat(a,"Shape[1] * stride1;");if(p===i&&null==u)return t?"\n      float ".concat(r,"(int row, int col, int depth, int depth2) {\n        ").concat(f,"\n        ").concat(m,"\n        float texR = float(row);\n        float texC =\n            dot(vec3(col, depth, depth2),\n                vec3(stride1, stride2, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(").concat(a,"TexShape[1], ").concat(a,"TexShape[0]);\n        return sampleTexture(").concat(a,", uv);\n      }\n    "):"\n      float ".concat(r,"(int row, int col, int depth, int depth2) {\n        float texR = float(row);\n        float texC =\n            dot(vec3(col, depth, depth2),\n                vec3(").concat(s,", ").concat(o,", 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(").concat(p,".0, ").concat(h,".0);\n        return sampleTexture(").concat(a,", uv);\n      }\n    ");if(p===o&&null==u)return t?"\n      float ".concat(r,"(int row, int col, int depth, int depth2) {\n        float texR = dot(vec3(row, col, depth),\n                         vec3(").concat(a,"Shape[1] * ").concat(a,"Shape[2], ").concat(a,"Shape[2], 1));\n        float texC = float(depth2);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(").concat(a,"TexShape[1], ").concat(a,"TexShape[0]);\n        return sampleTexture(").concat(a,", uv);\n      }\n    "):"\n      float ".concat(r,"(int row, int col, int depth, int depth2) {\n        float texR = dot(vec3(row, col, depth),\n                         vec3(").concat(n[1]*n[2],", ").concat(n[2],", 1));\n        float texC = float(depth2);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(").concat(p,".0, ").concat(h,".0);\n        return sampleTexture(").concat(a,", uv);\n      }\n    ");const b=HO(a);if(t)return"\n    float ".concat(r,"(int row, int col, int depth, int depth2) {\n      // Explicitly use integer operations as dot() only works on floats.\n      ").concat(f,"\n      ").concat(m,"\n      ").concat(g,"\n      int index = row * stride0 + col * stride1 +\n          depth * stride2 + depth2;\n      vec2 uv = uvFromFlat(").concat(a,"TexShape[0], ").concat(a,"TexShape[1], index + ").concat(b,");\n      return sampleTexture(").concat(a,", uv);\n    }\n  ");return"\n    float ".concat(r,"(int row, int col, int depth, int depth2) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ").concat(i," + col * ").concat(s," +\n          depth * ").concat(o," + depth2;\n      vec2 uv = uvFromFlat(").concat(h,", ").concat(p,", index + ").concat(b,");\n      return sampleTexture(").concat(a,", uv);\n    }\n  ")}(e,t);case 5:return function(e){const t=e.shapeInfo.logicalShape,n=e.name,a="get"+n.charAt(0).toUpperCase()+n.slice(1),r=t[4],o=t[3]*r,s=t[2]*o,i=t[1]*s,{newShape:c,keptDims:l}=Co(t);if(c.length<t.length){const t=XO(e,c),n=["row","col","depth","depth2","depth3"];return"\n      ".concat(zO(t),"\n      float ").concat(a,"(int row, int col, int depth, int depth2, int depth3) {\n        return ").concat(a,"(").concat(YO(n,l),");\n      }\n    ")}if(e.shapeInfo.isUniform)return"\n      float ".concat(a,"(int row, int col, int depth, int depth2, int depth3) {\n        float index = dot(\n          vec4(row, col, depth, depth2),\n          vec4(").concat(i,", ").concat(s,", ").concat(o,", ").concat(r,")) +\n          depth3;\n        ").concat(jO(e),"\n      }\n    ");const u=e.shapeInfo.flatOffset,d=e.shapeInfo.texShape,h=d[0],p=d[1];if(p===i&&null==u)return"\n      float ".concat(a,"(int row, int col, int depth, int depth2, int depth3) {\n        int texR = row;\n        float texC = dot(vec4(col, depth, depth2, depth3),\n                         vec4(").concat(s,", ").concat(o,", ").concat(r,", 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(").concat(p,".0, ").concat(h,".0);\n        return sampleTexture(").concat(n,", uv);\n      }\n    ");if(p===r&&null==u)return"\n      float ".concat(a,"(int row, int col, int depth, int depth2, int depth3) {\n        float texR = dot(\n          vec4(row, col, depth, depth2),\n          vec4(").concat(t[1]*t[2]*t[3],",\n               ").concat(t[2]*t[3],", ").concat(t[3],", 1));\n        int texC = depth3;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(").concat(p,".0, ").concat(h,".0);\n        return sampleTexture(").concat(n,", uv);\n      }\n    ");const f=HO(n);return"\n    float ".concat(a,"(int row, int col, int depth, int depth2, int depth3) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ").concat(i," + col * ").concat(s," + depth * ").concat(o," +\n          depth2 * ").concat(r," + depth3 + ").concat(f,";\n      vec2 uv = uvFromFlat(").concat(h,", ").concat(p,", index);\n      return sampleTexture(").concat(n,", uv);\n    }\n  ")}(e);case 6:return function(e){const t=e.shapeInfo.logicalShape,n=e.name,a="get"+n.charAt(0).toUpperCase()+n.slice(1),{newShape:r,keptDims:o}=Co(t);if(r.length<t.length){const t=XO(e,r),n=["row","col","depth","depth2","depth3","depth4"];return"\n      ".concat(zO(t),"\n      float ").concat(a,"(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        return ").concat(a,"(").concat(YO(n,o),");\n      }\n    ")}const s=t[5],i=t[4]*s,c=t[3]*i,l=t[2]*c,u=t[1]*l;if(e.shapeInfo.isUniform)return"\n      float ".concat(a,"(int row, int col, int depth,\n                  int depth2, int depth3, int depth4) {\n        int index = round(dot(\n          vec4(row, col, depth, depth2),\n          vec4(").concat(u,", ").concat(l,", ").concat(c,", ").concat(i,")) +\n          dot(\n            vec2(depth3, depth4),\n            vec2(").concat(s,", 1)));\n        ").concat(jO(e),"\n      }\n    ");const d=e.shapeInfo.flatOffset,h=e.shapeInfo.texShape,p=h[0],f=h[1];if(f===u&&null==d)return"\n      float ".concat(a,"(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        int texR = row;\n        float texC = dot(vec4(col, depth, depth2, depth3),\n          vec4(").concat(l,", ").concat(c,", ").concat(i,", ").concat(s,")) +\n               float(depth4);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(").concat(f,".0, ").concat(p,".0);\n        return sampleTexture(").concat(n,", uv);\n      }\n    ");if(f===s&&null==d)return"\n      float ".concat(a,"(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        float texR = dot(vec4(row, col, depth, depth2),\n          vec4(").concat(t[1]*t[2]*t[3]*t[4],",\n               ").concat(t[2]*t[3]*t[4],",\n               ").concat(t[3]*t[4],",\n               ").concat(t[4],")) + float(depth3);\n        int texC = depth4;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(").concat(f,".0, ").concat(p,".0);\n        return sampleTexture(").concat(n,", uv);\n      }\n    ");const m=HO(n);return"\n    float ".concat(a,"(int row, int col, int depth,\n                  int depth2, int depth3, int depth4) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ").concat(u," + col * ").concat(l," + depth * ").concat(c," +\n          depth2 * ").concat(i," + depth3 * ").concat(s," + depth4 + ").concat(m,";\n      vec2 uv = uvFromFlat(").concat(p,", ").concat(f,", index);\n      return sampleTexture(").concat(n,", uv);\n    }\n  ")}(e);default:throw new Error("".concat(n.length,"-D input sampling")+" is not yet supported")}}function BO(e,t){switch(e.shapeInfo.logicalShape.length){case 0:return function(e){const t=e.name,n="get"+t.charAt(0).toUpperCase()+t.slice(1),a=_O();return"\n    vec4 ".concat(n,"() {\n      return ").concat(a.texture2D,"(").concat(t,", halfCR);\n    }\n  ")}(e);case 1:return function(e,t){const n=e.name,a="get"+n.charAt(0).toUpperCase()+n.slice(1),r=e.shapeInfo.texShape,o=_O();if(t)return"\n    vec4 ".concat(a,"(int index) {\n      ivec2 packedTexShape = ivec2(ceil(float(").concat(n,"TexShape[0]) / 2.0), ceil(float(").concat(n,"TexShape[1]) / 2.0));\n      vec2 uv = packedUVfrom1D(\n        packedTexShape[0], packedTexShape[1], index);\n      return ").concat(o.texture2D,"(").concat(n,", uv);\n    }\n  ");const s=[Math.ceil(r[0]/2),Math.ceil(r[1]/2)];return"\n    vec4 ".concat(a,"(int index) {\n      vec2 uv = packedUVfrom1D(\n        ").concat(s[0],", ").concat(s[1],", index);\n      return ").concat(o.texture2D,"(").concat(n,", uv);\n    }\n  ")}(e,t);case 2:return function(e,t){const n=e.shapeInfo.logicalShape,a=e.name,r="get"+a.charAt(0).toUpperCase()+a.slice(1),o=e.shapeInfo.texShape,s=o[0],i=o[1],c=_O();if(null!=o&&xo(n,o))return t?"\n      vec4 ".concat(r,"(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(").concat(a,"TexShape[1], ").concat(a,"TexShape[0]);\n\n        return ").concat(c.texture2D,"(").concat(a,", uv);\n      }\n    "):"\n      vec4 ".concat(r,"(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(").concat(i,".0, ").concat(s,".0);\n\n        return ").concat(c.texture2D,"(").concat(a,", uv);\n      }\n    ");if(t)return"\n    vec4 ".concat(r,"(int row, int col) {\n      ivec2 packedTexShape = ivec2(ceil(float(").concat(a,"TexShape[0]) / 2.0), ceil(float(").concat(a,"TexShape[1]) / 2.0));\n      int valuesPerRow = int(ceil(float(").concat(a,"Shape[1]) / 2.0));\n      vec2 uv = packedUVfrom2D(valuesPerRow, packedTexShape[0], packedTexShape[1], row, col);\n      return ").concat(c.texture2D,"(").concat(a,", uv);\n    }\n  ");const l=[Math.ceil(o[0]/2),Math.ceil(o[1]/2)],u=Math.ceil(n[1]/2);return"\n    vec4 ".concat(r,"(int row, int col) {\n      vec2 uv = packedUVfrom2D(").concat(u,", ").concat(l[0],", ").concat(l[1],", row, col);\n      return ").concat(c.texture2D,"(").concat(a,", uv);\n    }\n  ")}(e,t);case 3:return function(e,t){const n=e.shapeInfo.logicalShape,a=e.name,r="get"+a.charAt(0).toUpperCase()+a.slice(1),o=e.shapeInfo.texShape,s=[Math.ceil(o[0]/2),Math.ceil(o[1]/2)];if(1===n[0]){const a=[1,2],o=XO(e,n.slice(1)),s=["b","row","col"];return"\n        ".concat(BO(o,t),"\n        vec4 ").concat(r,"(int b, int row, int col) {\n          return ").concat(r,"(").concat(YO(s,a),");\n        }\n      ")}const i=_O();if(t)return"\n    vec4 ".concat(r,"(int b, int row, int col) {\n      ivec2 packedTexShape = ivec2(ceil(float(").concat(a,"TexShape[0]) / 2.0), ceil(float(").concat(a,"TexShape[1]) / 2.0));\n      int valuesPerRow = int(ceil(float(").concat(a,"Shape[2]) / 2.0));\n      int texelsInBatch = valuesPerRow * int(ceil(float(").concat(a,"Shape[1]) / 2.0));\n      vec2 uv = packedUVfrom3D(\n        packedTexShape[0], packedTexShape[1], texelsInBatch, valuesPerRow, b, row, col);\n      return ").concat(i.texture2D,"(").concat(a,", uv);\n    }\n  ");const c=s[0],l=s[1],u=Math.ceil(n[2]/2),d=u*Math.ceil(n[1]/2);return"\n    vec4 ".concat(r,"(int b, int row, int col) {\n      vec2 uv = packedUVfrom3D(\n        ").concat(c,", ").concat(l,", ").concat(d,", ").concat(u,", b, row, col);\n      return ").concat(i.texture2D,"(").concat(a,", uv);\n    }\n  ")}(e,t);default:return function(e,t){const n=e.name,a="get"+n.charAt(0).toUpperCase()+n.slice(1),r=_O();if(t)return"\n    vec4 ".concat(a,"(int b2, int b, int row, int col) {\n      int valuesPerRow = int(ceil(float(").concat(n,"Shape[3]) / 2.0));\n      int texelsInBatch = valuesPerRow * int(ceil(float(").concat(n,"Shape[2]) / 2.0));\n      int index = b * texelsInBatch + (row / 2) * valuesPerRow + (col / 2);\n      texelsInBatch *= ").concat(n,"Shape[1];\n      index = b2 * texelsInBatch + index;\n      ivec2 packedTexShape = ivec2(ceil(float(").concat(n,"TexShape[0]) / 2.0), ceil(float(").concat(n,"TexShape[1]) / 2.0));\n      int texR = index / packedTexShape[1];\n      int texC = index - texR * packedTexShape[1];\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(packedTexShape[1], packedTexShape[0]); return ").concat(r.texture2D,"(").concat(n,", uv);\n    }\n  ");const o=e.shapeInfo.logicalShape,s=o.length,i=e.shapeInfo.texShape,c=[Math.ceil(i[0]/2),Math.ceil(i[1]/2)],l=c[0],u=c[1],d=Math.ceil(o[s-1]/2);let h=d*Math.ceil(o[s-2]/2),p="int b, int row, int col",f="b * ".concat(h," + (row / 2) * ").concat(d," + (col / 2)");for(let m=2;m<s-1;m++)p="int b".concat(m,", ")+p,h*=o[s-m-1],f="b".concat(m," * ").concat(h," + ")+f;return"\n    vec4 ".concat(a,"(").concat(p,") {\n      int index = ").concat(f,";\n      int texR = index / ").concat(u,";\n      int texC = index - texR * ").concat(u,";\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(").concat(u,", ").concat(l,");\n      return ").concat(r.texture2D,"(").concat(n,", uv);\n    }\n  ")}(e,t)}}const WO="\nvec2 uvFromFlat(int texNumR, int texNumC, int index) {\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\nvec2 packedUVfrom1D(int texNumR, int texNumC, int index) {\n  int texelIndex = index / 2;\n  int texR = texelIndex / texNumC;\n  int texC = texelIndex - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",VO="\nvec2 packedUVfrom2D(int texelsInLogicalRow, int texNumR,\n  int texNumC, int row, int col) {\n  int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);\n  int texR = texelIndex / texNumC;\n  int texC = texelIndex - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",UO="\nvec2 packedUVfrom3D(int texNumR, int texNumC,\n    int texelsInBatch, int texelsInLogicalRow, int b,\n    int row, int col) {\n  int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",GO="\n  float getChannel(vec4 frag, vec2 innerDims) {\n    vec2 modCoord = mod(innerDims, 2.);\n    return modCoord.x == 0. ?\n      (modCoord.y == 0. ? frag.r : frag.g) :\n      (modCoord.y == 0. ? frag.b : frag.a);\n  }\n  float getChannel(vec4 frag, int dim) {\n    float modCoord = mod(float(dim), 2.);\n    return modCoord == 0. ? frag.r : frag.g;\n  }\n";function HO(e){return"offset".concat(e)}function jO(e){const t=e.name,n=yo(e.shapeInfo.logicalShape);return n<2?"return ".concat(t,";"):"\n    for (int i = 0; i < ".concat(n,"; i++) {\n      if (i == index) {\n        return ").concat(t,"[i];\n      }\n    }\n  ")}function KO(e){if(e<=1)return"int";if(2===e)return"ivec2";if(3===e)return"ivec3";if(4===e)return"ivec4";if(5===e)return"ivec5";if(6===e)return"ivec6";throw Error("GPU for rank ".concat(e," is not yet supported"))}function qO(e,t,n){const{newShape:a,keptDims:r}=Co(t),o=t.length,s=e&&3===o&&1===t[0],i=s?t.slice(1):a,c=!e&&o>1&&!xo(t,n)&&a.length<o||s;return{useSqueezeShape:c,uniformShape:c?i:t,keptDims:r}}function XO(e,t){const n=JSON.parse(JSON.stringify(e));return n.shapeInfo.logicalShape=t,n}function YO(e,t){return t.map((t=>e[t])).join(", ")}function QO(e,t,n,a){const r=n.map(((e,n)=>{const a={logicalShape:e.shape,texShape:e.isUniform?null:e.texData.texShape,isUniform:e.isUniform,isPacked:!e.isUniform&&e.texData.isPacked,flatOffset:null};return null!=e.texData&&null!=e.texData.slice&&e.texData.slice.flatOffset>0&&(a.flatOffset=e.texData.slice.flatOffset),{name:t.variableNames[n],shapeInfo:a}})),o=r.map((e=>e.shapeInfo)),s={logicalShape:a.shape,texShape:a.texData.texShape,isUniform:!1,isPacked:a.texData.isPacked,flatOffset:null},i=PO(r,s,t),c=function(e,t){const n=mO(e,(()=>e.createShader(e.FRAGMENT_SHADER)),"Unable to create fragment WebGLShader.");if(rO(e,(()=>e.shaderSource(n,t))),rO(e,(()=>e.compileShader(n))),Yo().get("ENGINE_COMPILE_ONLY"))return n;if(!1===e.getShaderParameter(n,e.COMPILE_STATUS))throw cO(t,e.getShaderInfoLog(n)),new Error("Failed to compile fragment shader.");return n}(e.gl,i),l=e.createProgram(c);return Yo().get("ENGINE_COMPILE_ONLY")?{program:t,fragmentShader:c,source:i,webGLProgram:l,inShapeInfos:o,outShapeInfo:s,variablesLocations:null,customUniformLocations:null,infLoc:null,nanLoc:null,outShapeLocation:null,outShapeStridesLocation:null,outTexShapeLocation:null}:(e.buildVao(l),Object.assign({program:t,fragmentShader:c,source:i,webGLProgram:l,inShapeInfos:o,outShapeInfo:s},JO(e,t,l)))}function JO(e,t,n){const a=[],r=[];let o,s,i,c=null,l=null;l=e.getUniformLocation(n,"NAN",!1),1===Yo().getNumber("WEBGL_VERSION")&&(c=e.getUniformLocation(n,"INFINITY",!1));const u=!1;for(const d of t.variableNames){const r={name:d,uniform:e.getUniformLocation(n,d,u),offset:e.getUniformLocation(n,"offset".concat(d),u)};t.enableShapeUniforms&&(r.shape=e.getUniformLocation(n,"".concat(d,"Shape"),u),r.texShape=e.getUniformLocation(n,"".concat(d,"TexShape"),u)),a.push(r)}if(t.enableShapeUniforms&&(o=e.getUniformLocation(n,"outShape",u),i=e.getUniformLocation(n,"outShapeStrides",u),s=e.getUniformLocation(n,"outTexShape",u)),t.customUniforms)for(const d of t.customUniforms)r.push(e.getUniformLocation(n,d.name,u));return{variablesLocations:a,customUniformLocations:r,infLoc:c,nanLoc:l,outShapeLocation:o,outShapeStridesLocation:i,outTexShapeLocation:s}}function ZO(e,t){if(e.length!==t.length)throw Error("Binary was compiled with ".concat(e.length," inputs, but ")+"was executed with ".concat(t.length," inputs"));e.forEach(((e,n)=>{const a=e.logicalShape,r=t[n],o=r.shape;if(!xo(a,o))throw Error("Binary was compiled with different shapes than "+"the current args. Shapes ".concat(a," and ").concat(o," must match"));if(e.isUniform&&r.isUniform)return;const s=e.texShape,i=r.isUniform?null:r.texData.texShape;if(!xo(s,i))throw Error("Binary was compiled with different texture shapes than the"+" current args. Shape ".concat(s," and ").concat(i," must match"))}))}function $O(e){return Yo().getBool("WEBGL_USE_SHAPES_UNIFORMS")&&e<=4}class eD{constructor(e){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outPackingScheme=JF.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];const t=_O();this.outputShape=e,this.enableShapeUniforms=$O(this.outputShape.length),this.userCode="\n      ivec3 outCoordsFromFlatIndex(int index) {\n        ".concat(this.enableShapeUniforms?FO(["r","c","d"],e):AO(["r","c","d"],e),"\n        return ivec3(r, c, d);\n      }\n\n      void main() {\n        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));\n        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);\n\n        vec4 result = vec4(0.);\n\n        for (int i=0; i<4; i++) {\n          int flatIndex = index + i;\n          ivec3 rc = outCoordsFromFlatIndex(flatIndex);\n          result[i] = getA(rc.x, rc.y, rc.z);\n        }\n\n        ").concat(t.output," = result;\n      }\n    ")}}class tD{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outPackingScheme=JF.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];const t=_O();this.outputShape=e,this.enableShapeUniforms=$O(this.outputShape.length),this.userCode="\n      ivec3 outCoordsFromFlatIndex(int index) {\n        ".concat(this.enableShapeUniforms?FO(["r","c","d"],e):AO(["r","c","d"],e),"\n        return ivec3(r, c, d);\n      }\n\n      void main() {\n        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));\n        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);\n\n        vec4 result = vec4(0.);\n\n        for (int i=0; i<4; i++) {\n          int flatIndex = index + i;\n          ivec3 rc = outCoordsFromFlatIndex(flatIndex);\n          result[i] = getChannel(getA(rc.x, rc.y, rc.z), vec2(rc.y, rc.z));\n        }\n\n        ").concat(t.output," = result;\n      }\n    ")}}class nD{constructor(e){this.variableNames=["A"],this.outTexUsage=ZF.DOWNLOAD;const t=_O();this.outputShape=e,this.userCode="\n      ".concat(MO,"\n\n      void main() {\n        float x = getAAtOutCoords();\n        ").concat(t.output," = encode_float(x);\n      }\n    ")}}class aD{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outTexUsage=ZF.DOWNLOAD;const t=_O();this.outputShape=e,this.userCode="\n      ".concat(MO,"\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n        float x = getChannel(getAAtOutCoords(), vec2(coords.y, coords.z));\n        ").concat(t.output," = encode_float(x);\n      }\n    ")}}const rD={R:0,G:1,B:2,A:3};class oD{constructor(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1],n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"RGBA";this.variableNames=["A"],this.customUniforms=[{name:"texShape",type:"ivec2"}];const a=_O();this.outputShape=e,this.enableShapeUniforms=$O(this.outputShape.length);let r="result";t&&(r="floor(result * 255. + 0.5)");let o="";for(let s=0;s<n.length;s++){const e=n[s];o+="\n          if(offset == ".concat(s,") {\n            result = values[").concat(rD[e],"];\n          }")}this.userCode="\n      ".concat(this.enableShapeUniforms?"\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;\n  }\n":DO(e),"\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int flatIndex = getFlatIndex(coords);\n        float result = 0.;\n        int offset = imod(flatIndex, ").concat(n.length,");\n\n        flatIndex = idiv(flatIndex, ").concat(n.length,", 1.);\n\n        int r = flatIndex / texShape[1];\n        if (r < texShape[0]) {\n          int c = imod(flatIndex, texShape[1]);\n          vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);\n          vec4 values = ").concat(a.texture2D,"(A, uv);\n          ").concat(o,"\n        }\n        ").concat(a.output," = vec4(").concat(r,", 0., 0., 0.);\n      }\n    ")}}class sD{constructor(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.customUniforms=[{name:"texShape",type:"ivec2"}];const n=_O();this.outputShape=e,this.enableShapeUniforms=$O(this.outputShape.length);let a="",r="result";t&&(r="floor(result * 255. + 0.5)");for(let o=0;o<=1;o++)for(let t=0;t<=1;t++){const r=2*o+t;a+="\n          localCoords = coords;\n          if(localCoords[2] + ".concat(t," < ").concat(this.enableShapeUniforms?"outShape[2]":"".concat(e[2]),") {\n          localCoords[2] += ").concat(t,";\n          if (localCoords[1] + ").concat(o," < ").concat(this.enableShapeUniforms?"outShape[1]":"".concat(e[1]),") {\n            localCoords[1] += ").concat(o,";\n\n            flatIndex = getFlatIndex(localCoords);\n            offset = imod(flatIndex, 4);\n\n            flatIndex = idiv(flatIndex, 4, 1.);\n\n            int r = flatIndex / texShape[1];\n            int c = imod(flatIndex, texShape[1]);\n            vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);\n            values = ").concat(n.texture2D,"(A, uv);\n\n            if (offset == 0) {\n              result[").concat(r,"] = values[0];\n            } else if (offset == 1) {\n              result[").concat(r,"] = values[1];\n            } else if (offset == 2) {\n              result[").concat(r,"] = values[2];\n            } else {\n              result[").concat(r,"] = values[3];\n            }\n          }\n        }\n        ")}this.userCode="\n        ".concat(this.enableShapeUniforms?"\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;\n  }\n":DO(e),"\n\n        void main() {\n          ivec3 coords = getOutputCoords();\n\n          vec4 result = vec4(0.);\n          int flatIndex, r, c, offset;\n          ivec3 localCoords;\n          vec2 uv;\n          vec4 values;\n\n          ").concat(a,"\n\n          ").concat(n.output," = ").concat(r,";\n        }\n    ")}}function iD(e){const t=_O();return function(e,t){const n=mO(e,(()=>e.createShader(e.VERTEX_SHADER)),"Unable to create vertex WebGLShader.");if(rO(e,(()=>e.shaderSource(n,t))),rO(e,(()=>e.compileShader(n))),!1===e.getShaderParameter(n,e.COMPILE_STATUS))throw console.log(e.getShaderInfoLog(n)),new Error("Failed to compile vertex shader.");return n}(e,"".concat(t.version,"\n    precision highp float;\n    ").concat(t.attribute," vec3 clipSpacePos;\n    ").concat(t.attribute," vec2 uv;\n    ").concat(t.varyingVs," vec2 resultUV;\n\n    void main() {\n      gl_Position = vec4(clipSpacePos, 1);\n      resultUV = uv;\n    }"))}function cD(e){return function(e,t){const n=mO(e,(()=>e.createBuffer()),"Unable to create WebGLBuffer");return rO(e,(()=>e.bindBuffer(e.ARRAY_BUFFER,n))),rO(e,(()=>e.bufferData(e.ARRAY_BUFFER,t,e.STATIC_DRAW))),n}(e,new Float32Array([-1,1,0,0,1,-1,-1,0,0,0,1,1,0,1,1,1,-1,0,1,0]))}function lD(e){return function(e,t){const n=mO(e,(()=>e.createBuffer()),"Unable to create WebGLBuffer");return rO(e,(()=>e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,n))),rO(e,(()=>e.bufferData(e.ELEMENT_ARRAY_BUFFER,t,e.STATIC_DRAW))),n}(e,new Uint16Array([0,1,2,2,1,3]))}function uD(e,t,n,a,r,o){!function(e,t){const n=Yo().getNumber("WEBGL_MAX_TEXTURE_SIZE");if(e<=0||t<=0){const n="[".concat(e,"x").concat(t,"]");throw new Error("Requested texture size "+n+" is invalid.")}if(e>n||t>n){const a="[".concat(e,"x").concat(t,"]"),r="[".concat(n,"x").concat(n,"]");throw new Error("Requested texture size "+a+" greater than WebGL maximum on this browser / GPU "+r+".")}}(t,n);const s=function(e){return mO(e,(()=>e.createTexture()),"Unable to create WebGLTexture.")}(e),i=e.TEXTURE_2D;return rO(e,(()=>e.bindTexture(i,s))),rO(e,(()=>e.texParameteri(i,e.TEXTURE_WRAP_S,e.CLAMP_TO_EDGE))),rO(e,(()=>e.texParameteri(i,e.TEXTURE_WRAP_T,e.CLAMP_TO_EDGE))),rO(e,(()=>e.texParameteri(i,e.TEXTURE_MIN_FILTER,e.NEAREST))),rO(e,(()=>e.texParameteri(i,e.TEXTURE_MAG_FILTER,e.NEAREST))),1===Yo().getNumber("WEBGL_VERSION")?rO(e,(()=>e.texImage2D(i,0,a,t,n,0,r,o,null))):rO(e,(()=>e.texStorage2D(i,1,a,t,n))),rO(e,(()=>e.bindTexture(e.TEXTURE_2D,null))),{texture:s,texShape:[n,t]}}function dD(e){return e.internalFormatFloat}function hD(e){return e.internalFormatHalfFloat}function pD(e){return e.downloadTextureFormat}function fD(e){return e.internalFormatPackedFloat}function mD(e){return e.internalFormatPackedHalfFloat}function gD(e,t,n,a,r,o,s,i){const c=e,l=new Float32Array(function(e,t){const[n,a]=nO(e,t);return n*a*4}(o,s));return c.bindBuffer(c.PIXEL_PACK_BUFFER,t),c.getBufferSubData(c.PIXEL_PACK_BUFFER,0,l),c.bindBuffer(c.PIXEL_PACK_BUFFER,null),l}class bD{constructor(e){this.outputTexture=null,this.program=null,this.disposed=!1,this.itemsToPoll=[];const t=Yo().getNumber("WEBGL_VERSION");if(null!=e?(this.gl=e,function(e,t){XF[e]=t}(t,e)):this.gl=QF(t),e=this.gl,2===Yo().getNumber("WEBGL_VERSION")){const t=e;this.createVertexArray=()=>rO(t,(()=>t.createVertexArray())),this.bindVertexArray=e=>rO(t,(()=>t.bindVertexArray(e))),this.deleteVertexArray=e=>rO(t,(()=>t.deleteVertexArray(e))),this.getVertexArray=()=>rO(t,(()=>t.getParameter(t.VERTEX_ARRAY_BINDING)))}else if(null!=e){const t=e.getExtension("OES_vertex_array_object");if(null==t)throw new Error("All WebGL1 implementations are expected to offer OES_vertex_array_object.");this.createVertexArray=()=>rO(e,(()=>t.createVertexArrayOES())),this.bindVertexArray=n=>rO(e,(()=>t.bindVertexArrayOES(n))),this.deleteVertexArray=n=>rO(e,(()=>t.deleteVertexArrayOES(n))),this.getVertexArray=()=>rO(e,(()=>e.getParameter(t.VERTEX_ARRAY_BINDING_OES)))}let n="WEBGL_color_buffer_float";const a="EXT_color_buffer_half_float";if(this.parallelCompilationExtension=this.gl.getExtension("KHR_parallel_shader_compile"),1===Yo().getNumber("WEBGL_VERSION")){const e="OES_texture_float",t="OES_texture_half_float";if(this.textureFloatExtension=sO(this.gl,e),SO(this.gl,t))this.textureHalfFloatExtension=sO(this.gl,t);else if(Yo().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support half float textures, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.");if(this.colorBufferFloatExtension=this.gl.getExtension(n),SO(this.gl,a))this.colorBufferHalfFloatExtension=sO(this.gl,a);else if(Yo().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support color renderable half floats, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.")}else if(n="EXT_color_buffer_float",SO(this.gl,n))this.colorBufferFloatExtension=this.gl.getExtension(n);else{if(!SO(this.gl,a))throw new Error("GL context does not support color renderable floats");this.colorBufferHalfFloatExtension=this.gl.getExtension(a)}this.vertexBuffer=cD(this.gl),this.indexBuffer=lD(this.gl),this.framebuffer=function(e){return mO(e,(()=>e.createFramebuffer()),"Unable to create WebGLFramebuffer.")}(this.gl),this.textureConfig=aO(this.gl,this.textureHalfFloatExtension)}get debug(){return Yo().getBool("DEBUG")}dispose(){if(this.disposed)return;null!=this.program&&console.warn("Disposing a GPGPUContext that still has a bound WebGLProgram. This is probably a resource leak, delete the program with GPGPUContext.deleteProgram before disposing."),null!=this.outputTexture&&console.warn("Disposing a GPGPUContext that still has a bound output matrix texture.  This is probably a resource leak, delete the output matrix texture with GPGPUContext.deleteMatrixTexture before disposing.");const e=this.gl;rO(e,(()=>e.finish())),rO(e,(()=>e.bindFramebuffer(e.FRAMEBUFFER,null))),rO(e,(()=>e.deleteFramebuffer(this.framebuffer))),rO(e,(()=>e.bindBuffer(e.ARRAY_BUFFER,null))),rO(e,(()=>e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,null))),rO(e,(()=>e.deleteBuffer(this.indexBuffer))),this.disposed=!0}createFloat32MatrixTexture(e,t){return this.throwIfDisposed(),function(e,t,n,a){const[r,o]=eO(t,n);return uD(e,r,o,dD(a),a.textureFormatFloat,e.FLOAT)}(this.gl,e,t,this.textureConfig)}createFloat16MatrixTexture(e,t){return this.throwIfDisposed(),function(e,t,n,a){const[r,o]=eO(t,n);return uD(e,r,o,hD(a),a.textureFormatFloat,a.textureTypeHalfFloat)}(this.gl,e,t,this.textureConfig)}createUnsignedBytesMatrixTexture(e,t){return this.throwIfDisposed(),function(e,t,n,a){const[r,o]=eO(t,n);return uD(e,r,o,pD(a),e.RGBA,e.UNSIGNED_BYTE)}(this.gl,e,t,this.textureConfig)}uploadPixelDataToTexture(e,t){this.throwIfDisposed(),function(e,t,n){rO(e,(()=>e.bindTexture(e.TEXTURE_2D,t))),n.data instanceof Uint8Array?2===Yo().getNumber("WEBGL_VERSION")?rO(e,(()=>e.texSubImage2D(e.TEXTURE_2D,0,0,0,n.width,n.height,e.RGBA,e.UNSIGNED_BYTE,n.data))):rO(e,(()=>e.texImage2D(e.TEXTURE_2D,0,e.RGBA,n.width,n.height,0,e.RGBA,e.UNSIGNED_BYTE,n.data))):2===Yo().getNumber("WEBGL_VERSION")?rO(e,(()=>e.texSubImage2D(e.TEXTURE_2D,0,0,0,e.RGBA,e.UNSIGNED_BYTE,n))):rO(e,(()=>e.texImage2D(e.TEXTURE_2D,0,e.RGBA,e.RGBA,e.UNSIGNED_BYTE,n))),rO(e,(()=>e.bindTexture(e.TEXTURE_2D,null)))}(this.gl,e,t)}uploadDenseMatrixToTexture(e,t,n,a){this.throwIfDisposed(),function(e,t,n,a,r,o){let s,i,c;rO(e,(()=>e.bindTexture(e.TEXTURE_2D,t))),r instanceof Uint8Array?(s=new Uint8Array(n*a*4),i=e.UNSIGNED_BYTE,c=e.RGBA):(s=new Float32Array(n*a*4),i=e.FLOAT,c=o.internalFormatPackedFloat),s.set(r),2===Yo().getNumber("WEBGL_VERSION")?rO(e,(()=>e.texSubImage2D(e.TEXTURE_2D,0,0,0,n,a,e.RGBA,i,s))):rO(e,(()=>e.texImage2D(e.TEXTURE_2D,0,c,n,a,0,e.RGBA,i,s))),rO(e,(()=>e.bindTexture(e.TEXTURE_2D,null)))}(this.gl,e,t,n,a,this.textureConfig)}createFloat16PackedMatrixTexture(e,t){return this.throwIfDisposed(),function(e,t,n,a){const[r,o]=nO(t,n);return uD(e,r,o,mD(a),e.RGBA,a.textureTypeHalfFloat)}(this.gl,e,t,this.textureConfig)}createPackedMatrixTexture(e,t){return this.throwIfDisposed(),function(e,t,n,a){const[r,o]=nO(t,n);return uD(e,r,o,fD(a),e.RGBA,e.FLOAT)}(this.gl,e,t,this.textureConfig)}deleteMatrixTexture(e){this.throwIfDisposed(),this.outputTexture===e&&(pO(this.gl,this.framebuffer),this.outputTexture=null),rO(this.gl,(()=>this.gl.deleteTexture(e)))}downloadByteEncodedFloatMatrixFromOutputTexture(e,t,n){return this.downloadMatrixDriver(e,(()=>function(e,t,n,a){const[r,o]=eO(t,n),s=new Uint8Array(t*n*4);return rO(e,(()=>e.readPixels(0,0,r,o,a.downloadTextureFormat,e.UNSIGNED_BYTE,s))),new Float32Array(s.buffer)}(this.gl,t,n,this.textureConfig)))}downloadPackedMatrixFromBuffer(e,t,n,a,r,o){return gD(this.gl,e,0,0,0,r,o,this.textureConfig)}downloadFloat32MatrixFromBuffer(e,t){return function(e,t,n){const a=e,r=new Float32Array(n);return a.bindBuffer(a.PIXEL_PACK_BUFFER,t),a.getBufferSubData(a.PIXEL_PACK_BUFFER,0,r),a.bindBuffer(a.PIXEL_PACK_BUFFER,null),r}(this.gl,e,t)}createBufferFromTexture(e,t,n){this.bindTextureToFrameBuffer(e);const a=function(e,t,n,a){const r=e.createBuffer();rO(e,(()=>e.bindBuffer(e.PIXEL_PACK_BUFFER,r)));const o=16*t*n;return rO(e,(()=>e.bufferData(e.PIXEL_PACK_BUFFER,o,e.STREAM_READ))),rO(e,(()=>e.readPixels(0,0,n,t,e.RGBA,e.FLOAT,0))),rO(e,(()=>e.bindBuffer(e.PIXEL_PACK_BUFFER,null))),r}(this.gl,t,n,this.textureConfig);return this.unbindTextureToFrameBuffer(),a}createAndWaitForFence(){const e=this.createFence(this.gl);return this.pollFence(e)}createFence(e){let t,n;if(Yo().getBool("WEBGL_FENCE_API_ENABLED")){const a=e,r=a.fenceSync(a.SYNC_GPU_COMMANDS_COMPLETE,0);e.flush(),n=()=>{const e=a.clientWaitSync(r,0,0);return e===a.ALREADY_SIGNALED||e===a.CONDITION_SATISFIED},t=r}else Yo().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0?(t=this.beginQuery(),this.endQuery(),n=()=>this.isQueryAvailable(t,Yo().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))):n=()=>!0;return{query:t,isFencePassed:n}}downloadMatrixFromPackedTexture(e,t,n){return this.downloadMatrixDriver(e,(()=>function(e,t,n){const a=new Float32Array(t*n*4);return rO(e,(()=>e.readPixels(0,0,n,t,e.RGBA,e.FLOAT,a))),a}(this.gl,t,n)))}createProgram(e){this.throwIfDisposed();const t=this.gl;null==this.vertexShader&&(this.vertexShader=iD(t));const n=function(e){return mO(e,(()=>e.createProgram()),"Unable to create WebGLProgram.")}(t);rO(t,(()=>t.attachShader(n,this.vertexShader))),rO(t,(()=>t.attachShader(n,e))),function(e,t){if(rO(e,(()=>e.linkProgram(t))),!Yo().get("ENGINE_COMPILE_ONLY")&&!1===e.getProgramParameter(t,e.LINK_STATUS))throw console.log(e.getProgramInfoLog(t)),new Error("Failed to link vertex and fragment shaders.")}(t,n);const a=Object.assign(n,{vao:this.createVertexArray()});return this.debug&&lO(t,a),a}buildVao(e){this.setProgram(e),this.bindVertexArray(e.vao);const t=this.gl;rO(t,(()=>t.bindBuffer(t.ELEMENT_ARRAY_BUFFER,this.indexBuffer))),function(e,t,n){rO(e,(()=>e.bindBuffer(e.ARRAY_BUFFER,n))),uO(e,t,"clipSpacePos",n,3,20,0)&&uO(e,t,"uv",n,2,20,12)}(t,e,this.vertexBuffer)}deleteProgram(e){this.throwIfDisposed(),e===this.program&&(this.program=null),null!=e&&(rO(this.gl,(()=>this.gl.deleteProgram(e))),this.deleteVertexArray(e.vao))}setProgram(e){this.throwIfDisposed(),this.program=e,null!=this.program&&this.debug&&lO(this.gl,this.program),rO(this.gl,(()=>this.gl.useProgram(e)))}getUniformLocation(e,t){let n=!(arguments.length>2&&void 0!==arguments[2])||arguments[2];return this.throwIfDisposed(),n?function(e,t,n){return mO(e,(()=>e.getUniformLocation(t,n)),'uniform "'+n+'" not present in program.')}(this.gl,e,t):function(e,t,n){return e.getUniformLocation(t,n)}(this.gl,e,t)}getAttributeLocation(e,t){return this.throwIfDisposed(),rO(this.gl,(()=>this.gl.getAttribLocation(e,t)))}getUniformLocationNoThrow(e,t){return this.throwIfDisposed(),this.gl.getUniformLocation(e,t)}setInputMatrixTexture(e,t,n){this.throwIfDisposed(),this.throwIfNoProgram(),dO(this.gl,e,t,n)}setOutputMatrixTexture(e,t,n){this.setOutputMatrixTextureDriver(e,n,t)}setOutputPackedMatrixTexture(e,t,n){this.throwIfDisposed();const[a,r]=nO(t,n);this.setOutputMatrixTextureDriver(e,a,r)}setOutputMatrixWriteRegion(e,t,n,a){this.setOutputMatrixWriteRegionDriver(n,e,a,t)}setOutputPackedMatrixWriteRegion(e,t,n,a){throw new Error("setOutputPackedMatrixWriteRegion not implemented.")}debugValidate(){null!=this.program&&lO(this.gl,this.program),fO(this.gl)}executeProgram(){this.throwIfDisposed(),this.throwIfNoProgram();const e=this.gl;if(this.debug){const e=this.getVertexArray();console.assert(e===this.program.vao,"VAO changed between setProgram and executeProgram!"),this.debugValidate()}rO(e,(()=>e.drawElements(e.TRIANGLES,6,e.UNSIGNED_SHORT,0)))}blockUntilAllProgramsCompleted(){this.throwIfDisposed(),rO(this.gl,(()=>this.gl.finish()))}getQueryTimerExtension(){return null==this.disjointQueryTimerExtension&&(this.disjointQueryTimerExtension=sO(this.gl,2===Yo().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")?"EXT_disjoint_timer_query_webgl2":"EXT_disjoint_timer_query")),this.disjointQueryTimerExtension}getQueryTimerExtensionWebGL2(){return this.getQueryTimerExtension()}getQueryTimerExtensionWebGL1(){return this.getQueryTimerExtension()}beginQuery(){if(2===Yo().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")){const e=this.gl,t=this.getQueryTimerExtensionWebGL2(),n=e.createQuery();return e.beginQuery(t.TIME_ELAPSED_EXT,n),n}const e=this.getQueryTimerExtensionWebGL1(),t=e.createQueryEXT();return e.beginQueryEXT(e.TIME_ELAPSED_EXT,t),t}endQuery(){if(2===Yo().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")){const e=this.gl,t=this.getQueryTimerExtensionWebGL2();return void e.endQuery(t.TIME_ELAPSED_EXT)}const e=this.getQueryTimerExtensionWebGL1();e.endQueryEXT(e.TIME_ELAPSED_EXT)}async waitForQueryAndGetTime(e){return await Io((()=>this.disposed||this.isQueryAvailable(e,Yo().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")))),this.getQueryTime(e,Yo().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))}getQueryTime(e,t){if(0===t)return null;if(2===t){const t=this.gl;return t.getQueryParameter(e,t.QUERY_RESULT)/1e6}{const t=this.getQueryTimerExtensionWebGL1();return t.getQueryObjectEXT(e,t.QUERY_RESULT_EXT)/1e6}}isQueryAvailable(e,t){if(0===t)return!0;if(2===t){const t=this.gl,n=this.getQueryTimerExtensionWebGL2(),a=t.getQueryParameter(e,t.QUERY_RESULT_AVAILABLE);return null==this.disjoint&&(this.disjoint=this.gl.getParameter(n.GPU_DISJOINT_EXT)),a&&!this.disjoint}{const t=this.getQueryTimerExtensionWebGL1(),n=t.getQueryObjectEXT(e,t.QUERY_RESULT_AVAILABLE_EXT);return null==this.disjoint&&(this.disjoint=this.gl.getParameter(t.GPU_DISJOINT_EXT)),n&&!this.disjoint}}pollFence(e){return new Promise((t=>{this.addItemToPoll((()=>e.isFencePassed()),(()=>t()))}))}pollItems(){const e=function(e){let t=0;for(;t<e.length;++t){if(!e[t]())break}return t-1}(this.itemsToPoll.map((e=>e.isDoneFn)));for(let t=0;t<=e;++t){const{resolveFn:e}=this.itemsToPoll[t];e()}this.itemsToPoll=this.itemsToPoll.slice(e+1)}addItemToPoll(e,t){if(this.itemsToPoll.push({isDoneFn:e,resolveFn:t}),this.itemsToPoll.length>1)return;let n;"setTimeoutCustom"in Yo().platform&&(n=Yo().platform.setTimeoutCustom.bind(Yo().platform)),Io((()=>(this.pollItems(),0===this.itemsToPoll.length)),(()=>0),null,n)}bindTextureToFrameBuffer(e){this.throwIfDisposed(),hO(this.gl,e,this.framebuffer),this.debug&&fO(this.gl)}unbindTextureToFrameBuffer(){null!=this.outputTexture?(hO(this.gl,this.outputTexture,this.framebuffer),this.debug&&fO(this.gl)):pO(this.gl,this.framebuffer)}downloadMatrixDriver(e,t){this.bindTextureToFrameBuffer(e);const n=t();return this.unbindTextureToFrameBuffer(),n}setOutputMatrixTextureDriver(e,t,n){this.throwIfDisposed();const a=this.gl;hO(a,e,this.framebuffer),this.debug&&fO(a),this.outputTexture=e,rO(a,(()=>a.viewport(0,0,t,n))),rO(a,(()=>a.scissor(0,0,t,n)))}setOutputMatrixWriteRegionDriver(e,t,n,a){this.throwIfDisposed(),rO(this.gl,(()=>this.gl.scissor(e,t,n,a)))}throwIfDisposed(){if(this.disposed)throw new Error("Attempted to use disposed GPGPUContext.")}throwIfNoProgram(){if(null==this.program)throw new Error("No GPU program is currently set.")}}const{addImpl:yD,bincountImpl:xD,bincountReduceImpl:vD,bitwiseAndImpl:wD,castImpl:kD,ceilImpl:ID,concatImpl:SD,equalImpl:ND,expImpl:CD,expm1Impl:TD,floorImpl:ED,gatherNdImpl:RD,gatherV2Impl:_D,greaterImpl:AD,greaterEqualImpl:FD,lessImpl:OD,lessEqualImpl:DD,linSpaceImpl:MD,logImpl:LD,maxImpl:PD,maximumImpl:zD,minimumImpl:BD,multiplyImpl:WD,negImpl:VD,notEqualImpl:UD,prodImpl:GD,raggedGatherImpl:HD,raggedRangeImpl:jD,raggedTensorToTensorImpl:KD,rangeImpl:qD,rsqrtImpl:XD,scatterImpl:YD,sigmoidImpl:QD,simpleAbsImpl:JD,sliceImpl:ZD,sparseFillEmptyRowsImpl:$D,sparseReshapeImpl:eM,sparseSegmentReductionImpl:tM,sqrtImpl:nM,staticRegexReplaceImpl:aM,stridedSliceImpl:rM,stringNGramsImpl:oM,stringSplitImpl:sM,stringToHashBucketFastImpl:iM,subImpl:cM,tileImpl:lM,topKImpl:uM,transposeImpl:dM,uniqueImpl:hM}=r;function pM(e,t){return["x","y","z","w","u","v"].slice(0,t).map((t=>"".concat(e,".").concat(t)))}function fM(e,t){return 1===t?[e]:pM(e,t)}class mM{constructor(e){if(this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outputShape=e,this.rank=e.length,this.enableShapeUniforms=$O(this.outputShape.length),0===this.rank)this.userCode="\n        void main() {\n          setOutput(vec4(getA(), 0., 0., 0.));\n        }\n      ";else{const e=fM("rc",this.rank),t=KO(this.rank),n=this.getOutOfBoundsCondition(e),a=this.getSetup(e),r=this.getOutput(e);this.userCode="\n        void main() {\n          ".concat(t," rc = getOutputCoords();\n\n          if(").concat(n,") {\n            setOutput(vec4(0));\n          } else {\n            ").concat(a,"\n\n            setOutput(vec4(").concat(r,"));\n          }\n        }\n      ")}}getSourceCoordsArr(e){const t=[];for(let n=0;n<=1;n++)for(let a=0;a<=1;a++){let r="".concat(0===n?"r":"rp1",", ").concat(0===a?"c":"cp1");for(let t=2;t<this.rank;t++)r="".concat(e[e.length-1-t],",")+r;t.push(r)}return t}getOutOfBoundsCondition(e){if(1===this.rank)return"rc > ".concat(this.enableShapeUniforms?"outShape":this.outputShape[0]);let t="";for(let n=this.rank-2;n<this.rank;n++)t+="".concat(e[n]," >= ").concat(this.enableShapeUniforms?"outShape[".concat(n,"]"):this.outputShape[n]),n<this.rank-1&&(t+="||");return t}getSetup(e){if(1===this.rank)return"";const t=e.slice(-2),n=this.enableShapeUniforms?"outShape[".concat(this.rank," - 1]"):this.outputShape[this.rank-1],a=this.enableShapeUniforms?"outShape[".concat(this.rank," - 2]"):this.outputShape[this.rank-2];return"\n      int r = ".concat(t[0],";\n      int c = ").concat(t[1],";\n      int rp1 = r + 1;\n      int cp1 = c + 1;\n\n      bool cEdge = cp1 >= ").concat(n,";\n      bool rEdge = rp1 >= ").concat(a,";\n    ")}getOutput(e){const t=this.getSourceCoordsArr(e);if(1===this.rank){const e=this.enableShapeUniforms?"outShape":this.outputShape[0];return"getA(rc), (rc + 1 >= ".concat(e," ? 0. : getA(rc + 1)), 0, 0")}return"getA(".concat(t[0],"),\n            cEdge ? 0. : getA(").concat(t[1],"),\n            rEdge ? 0. : getA(").concat(t[2],"),\n            rEdge || cEdge ? 0. : getA(").concat(t[3],")")}}class gM{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec3"}],this.outputShape=e,this.enableShapeUniforms=$O(this.outputShape.length);let n="";for(let a=0;a<4;a++){let e="thisRC = rc;";a%2===1&&(e+="thisRC.z += 1;"),a>1&&(e+="thisRC.y += 1;"),n+="\n        ".concat(e,"\n        ").concat(a>0?"if(thisRC.y < rows && thisRC.z < cols){":"","\n          int flatIndex = getFlatIndex(thisRC);\n\n          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flatIndex);\n          vec2 inputRCInnerDims = vec2(float(inputRC.y),float(inputRC.z));\n\n          result[").concat(a,"] =\n            getChannel(getA(inputRC.x, inputRC.y, inputRC.z), inputRCInnerDims);\n        ").concat(a>0?"}":"","\n      ")}this.userCode="\n      ".concat(function(e,t){const n=t?OO(["r","c","d"],"inputShape"):AO(["r","c","d"],e);return"\n    ivec3 inputCoordsFromReshapedOutCoords(int index) {\n      ".concat(n,"\n      return ivec3(r, c, d);\n    }\n  ")}(t,this.enableShapeUniforms),"\n      ").concat(this.enableShapeUniforms?"\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;\n  }\n":DO(e),"\n\n      void main() {\n        ivec3 rc = getOutputCoords();\n\n        vec4 result = vec4(0.);\n\n        ivec3 thisRC;\n        int rows = ").concat(this.enableShapeUniforms?"outShape[1]":e[1],";\n        int cols = ").concat(this.enableShapeUniforms?"outShape[2]":e[2],";\n\n        ").concat(n,"\n\n        setOutput(result);\n      }\n    ")}}class bM{constructor(e){this.gpgpu=e,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0,this.freeTextures={},this.usedTextures={},this.logEnabled=!1}acquireTexture(e,t,n){const a=xM(t,n),r=vM(e,a,n);r in this.freeTextures||(this.freeTextures[r]=[]),r in this.usedTextures||(this.usedTextures[r]=[]);const o=yM(e,a,this.gpgpu.gl,this.gpgpu.textureConfig,n);if(this.freeTextures[r].length>0){this.numFreeTextures--,this.numUsedTextures++,this._numBytesFree-=o,this.log();const e=this.freeTextures[r].pop();return this.usedTextures[r].push(e),e}let s;return a===$F.PACKED_2X2_FLOAT32?s=this.gpgpu.createPackedMatrixTexture(e[0],e[1]):a===$F.PACKED_2X2_FLOAT16?s=this.gpgpu.createFloat16PackedMatrixTexture(e[0],e[1]):a===$F.UNPACKED_FLOAT32?s=this.gpgpu.createFloat32MatrixTexture(e[0],e[1]):a===$F.UNPACKED_FLOAT16?s=this.gpgpu.createFloat16MatrixTexture(e[0],e[1]):a===$F.PACKED_4X1_UNSIGNED_BYTE&&(s=this.gpgpu.createUnsignedBytesMatrixTexture(e[0],e[1])),this.usedTextures[r].push(s),this.numUsedTextures++,this._numBytesAllocated+=o,this.log(),s}releaseTexture(e,t,n,a){if(null==this.freeTextures)return;const r=xM(n,a),o=vM(t,r,a);o in this.freeTextures||(this.freeTextures[o]=[]);const s=yM(t,r,this.gpgpu.gl,this.gpgpu.textureConfig,a),i=Yo().getNumber("WEBGL_DELETE_TEXTURE_THRESHOLD");-1!==i&&this._numBytesAllocated>i?(this.gpgpu.deleteMatrixTexture(e.texture),this._numBytesAllocated-=s):(this.freeTextures[o].push(e),this.numFreeTextures++,this._numBytesFree+=s),this.numUsedTextures--;const c=this.usedTextures[o],l=c&&c.indexOf(e);if(null==l||l<0)throw new Error("Cannot release a texture that was never provided by this texture manager");c[l]=c[c.length-1],c.pop(),this.log()}log(){if(!this.logEnabled)return;const e=this.numFreeTextures+this.numUsedTextures;console.log("Free/Used","".concat(this.numFreeTextures," / ").concat(this.numUsedTextures),"(".concat(e,")"));const t=this._numBytesFree/this._numBytesAllocated;console.log("Bytes allocated: ".concat(this._numBytesAllocated)),console.log("Bytes unused: ".concat(this._numBytesFree," (").concat(Math.round(100*t),"%)"))}get numBytesAllocated(){return this._numBytesAllocated}get numBytesFree(){return this._numBytesFree}getNumUsedTextures(){return this.numUsedTextures}getNumFreeTextures(){return this.numFreeTextures}dispose(){if(null!=this.freeTextures){for(const e in this.freeTextures)this.freeTextures[e].forEach((e=>{this.gpgpu.deleteMatrixTexture(e.texture)}));for(const e in this.usedTextures)this.usedTextures[e].forEach((e=>{this.gpgpu.deleteMatrixTexture(e.texture)}));this.freeTextures=null,this.usedTextures=null,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0}}}function yM(e,t,n,a,r){const o=function(e,t){switch(e){case $F.PACKED_2X2_FLOAT32:return fD(t);case $F.PACKED_2X2_FLOAT16:return mD(t);case $F.UNPACKED_FLOAT32:return dD(t);case $F.UNPACKED_FLOAT16:return hD(t);case $F.PACKED_4X1_UNSIGNED_BYTE:return pD(t);default:throw new Error("Unknown physical texture type ".concat(e))}}(t,a);let s;if(r){const[t,n]=nO(e[0],e[1]);s=t*n}else{const[t,n]=eO(e[0],e[1]);s=t*n}const i=function(e,t){const n=e;if(t===n.R32F)return 4;if(t===n.R16F)return 2;if(t===n.RGBA32F)return 16;if(t===e.RGBA)return 16;if(t===n.RGBA16F)return 8;if(t===n.RGBA8)return 4;throw new Error("Unknown internal format ".concat(t))}(n,o);return s*i}function xM(e,t){if(e===ZF.UPLOAD)return $F.PACKED_2X2_FLOAT32;if(e===ZF.RENDER||null==e)return function(e){return Yo().getBool("WEBGL_RENDER_FLOAT32_ENABLED")?e?$F.PACKED_2X2_FLOAT32:$F.UNPACKED_FLOAT32:e?$F.PACKED_2X2_FLOAT16:$F.UNPACKED_FLOAT16}(t);if(e===ZF.DOWNLOAD||e===ZF.PIXELS)return $F.PACKED_4X1_UNSIGNED_BYTE;throw new Error("Unknown logical texture type ".concat(e))}function vM(e,t,n){return"".concat(e[0],"_").concat(e[1],"_").concat(t,"_").concat(n)}class wM{constructor(e,t){this.variableNames=["A"],this.outputShape=e,this.enableShapeUniforms=$O(this.outputShape.length),this.userCode="\n      float unaryOperation(float x) {\n        ".concat(t,"\n      }\n\n      void main() {\n        float x = getAAtOutCoords();\n        float y = unaryOperation(x);\n\n        setOutput(y);\n      }\n    ")}}const kM="if (isnan(x)) return x;",IM="return x;",SM="return abs(x);";const NM="return (x >= 0.0) ? x : (exp(x) - 1.0);",CM=kM+"\n  return (x < 0.0) ? 0.0 : x;\n",TM=kM+"\n  return (x < 0.0) ? 0.0 : min(6.0, x);\n",EM="return x;",RM="return 1.0 / (1.0 + exp(-1.0 * x));",_M="return x;",AM="\n  vec4 result;\n\n  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);\n  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);\n  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);\n  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);\n\n  return result;\n",FM="\n  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n",OM="\n  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n",DM="return 1.0 / (1.0 + exp(-1.0 * x));";class MM{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.enableShapeUniforms=$O(this.outputShape.length),this.userCode="\n      vec4 unaryOperation(vec4 x) {\n        ".concat(t,"\n      }\n\n      void main() {\n        vec4 x = getAAtOutCoords();\n        vec4 y = unaryOperation(x);\n\n        setOutput(y);\n      }\n    ")}}class LM{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outputShape=e,this.enableShapeUniforms=$O(this.outputShape.length);const t=e.length,n=fM("rc",t),a=KO(t),r=function(e,t){if(1===e)return"rc";let n="";for(let a=0;a<e;a++)n+=t[a],a<e-1&&(n+=",");return n}(t,n),o=n.slice(-2),s=t<=1?"rc":"vec2(".concat(o.join(","),")");this.userCode="\n      void main() {\n        ".concat(a," rc = getOutputCoords();\n        vec4 packedInput = getA(").concat(r,");\n\n        setOutput(getChannel(packedInput, ").concat(s,"));\n      }\n    ")}}const PM=ob,zM={};const BM=Yo().getNumber("CPU_HANDOFF_SIZE_THRESHOLD");class WM extends co{nextDataId(){return WM.nextDataId++}constructor(e){if(super(),this.pendingRead=new WeakMap,this.pendingDisposal=new WeakSet,this.dataRefCount=new WeakMap,this.numBytesInGPU=0,this.uploadWaitMs=0,this.downloadWaitMs=0,this.lastGlFlushTime=0,this.warnedAboutMemory=!1,this.pendingDeletes=0,this.disposed=!1,!Yo().getBool("HAS_WEBGL"))throw new Error("WebGL is not supported on this device");let t;if(null!=e){if(e instanceof bD)t=e;else{const n=QF(Yo().getNumber("WEBGL_VERSION"),e);t=new bD(n)}this.binaryCache={},this.gpgpuCreatedLocally=!1}else{const e=QF(Yo().getNumber("WEBGL_VERSION"));t=new bD(e),this.binaryCache=((n=Yo().getNumber("WEBGL_VERSION"))in zM||(zM[n]={}),zM[n]),this.gpgpuCreatedLocally=!0}var n;this.gpgpu=t,this.canvas=this.gpgpu.gl.canvas,this.textureManager=new bM(this.gpgpu),this.numMBBeforeWarning=null==Yo().global.screen?1024:Yo().global.screen.height*Yo().global.screen.width*window.devicePixelRatio*600/1024/1024,this.texData=new io(this,Uu())}numDataIds(){return this.texData.numDataIds()-this.pendingDeletes}writeTexture(e,t,n,a,r,o){const s=this.makeTensorInfo(t,n),i=this.texData.get(s.dataId);i.isPacked=!1,i.texture={texture:e,texShape:[a,r]},i.texShape=[a,r];const c=xO(t),l=new oD(c,!1,o),u=this.runWebGLProgram(l,[s],n,[[a,r]]);return u.shape=t,i.texture=null,this.disposeIntermediateTensorInfo(s),u.dataId}write(e,t,n){if((Yo().getBool("WEBGL_CHECK_NUMERICAL_PROBLEMS")||Yo().getBool("DEBUG"))&&this.checkNumericalProblems(e),"complex64"===n&&null!=e)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");const a={id:this.nextDataId()};return this.texData.set(a,{shape:t,dtype:n,values:e,usage:ZF.UPLOAD,refCount:1}),a}refCount(e){if(this.texData.has(e)){return this.texData.get(e).refCount}return 0}incRef(e){this.texData.get(e).refCount++}decRef(e){if(this.texData.has(e)){this.texData.get(e).refCount--}}move(e,t,n,a,r){if(Yo().getBool("DEBUG")&&this.checkNumericalProblems(t),"complex64"===a)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");this.texData.set(e,{shape:n,dtype:a,values:t,usage:ZF.UPLOAD,refCount:r})}disposeIntermediateTensorInfo(e){this.disposeData(e.dataId)}readSync(e){const t=this.texData.get(e),{values:n,dtype:a,complexTensorInfos:r,slice:o,shape:s,isPacked:i}=t;if(null!=o){let t;t=i?new MM(s,EM):new wM(s,EM);const n=this.runWebGLProgram(t,[{dataId:e,shape:s,dtype:a}],a),r=this.readSync(n.dataId);return this.disposeIntermediateTensorInfo(n),r}if(null!=n)return this.convertAndCacheOnCPU(e);if("string"===a)return n;const c=null!=this.activeTimers;let l,u;if(c&&(l=Bl()),"complex64"===a){u=Ig(this.readSync(r.real.dataId),this.readSync(r.imag.dataId))}else u=this.getValuesFromTexture(e);return c&&(this.downloadWaitMs+=Bl()-l),this.convertAndCacheOnCPU(e,u)}async read(e){if(this.pendingRead.has(e)){const t=this.pendingRead.get(e);return new Promise((e=>t.push(e)))}const t=this.texData.get(e),{values:n,shape:a,slice:r,dtype:o,complexTensorInfos:s,isPacked:i}=t;if(null!=r){let t;t=i?new MM(a,EM):new wM(a,EM);const n=this.runWebGLProgram(t,[{dataId:e,shape:a,dtype:o}],o),r=this.read(n.dataId);return this.disposeIntermediateTensorInfo(n),r}if(null!=n)return this.convertAndCacheOnCPU(e);if(Yo().getBool("DEBUG")&&!Yo().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")&&2===Yo().getNumber("WEBGL_VERSION"))throw new Error("tensor.data() with WEBGL_DOWNLOAD_FLOAT_ENABLED=false and WEBGL_VERSION=2 not yet supported.");let c,l,u=null;if("complex64"!==o&&Yo().get("WEBGL_BUFFER_SUPPORTED")){c=this.decode(e);const t=this.texData.get(c.dataId);u=this.gpgpu.createBufferFromTexture(t.texture.texture,...tO(a))}if(this.pendingRead.set(e,[]),"complex64"!==o&&await this.gpgpu.createAndWaitForFence(),"complex64"===o){const e=await Promise.all([this.read(s.real.dataId),this.read(s.imag.dataId)]);l=Ig(e[0],e[1])}else if(null==u)l=this.getValuesFromTexture(e);else{const e=yo(a);l=this.gpgpu.downloadFloat32MatrixFromBuffer(u,e)}if(null!=c&&this.disposeIntermediateTensorInfo(c),null!=u){const e=this.gpgpu.gl;rO(e,(()=>e.deleteBuffer(u)))}const d=this.convertAndCacheOnCPU(e,l),h=this.pendingRead.get(e);return this.pendingRead.delete(e),h.forEach((e=>e(d))),this.pendingDisposal.has(e)&&(this.pendingDisposal.delete(e),this.disposeData(e)&&Uu().removeDataId(e,this),this.pendingDeletes--),d}readToGPU(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const n=this.texData.get(e),{values:a,shape:r,slice:o,dtype:s,isPacked:i,texture:c}=n;if("complex64"===s)throw new Error("Does not support reading texture for complex64 dtype.");if(null!=o){let n;n=i?new MM(r,EM):new wM(r,EM);const a=this.runWebGLProgram(n,[{dataId:e,shape:r,dtype:s}],s),o=this.readToGPU(a,t);return this.disposeIntermediateTensorInfo(a),o}if(null==c)throw null!=a?new Error("Data is not on GPU but on CPU."):new Error("There is no data on GPU or CPU.");const l=this.decode(e,t.customTexShape),u=Uu().makeTensorFromTensorInfo(l),d=this.texData.get(l.dataId);return Object.assign({tensorRef:u},d.texture)}bufferSync(e){const t=this.readSync(e.dataId);if("string"===e.dtype)try{const n=t.map((e=>Vl(e)));return Od(e.shape,e.dtype,n)}catch(n){throw new Error("Failed to decode encoded string bytes into utf-8")}return Od(e.shape,e.dtype,t)}checkNumericalProblems(e){if(null!=e)for(let t=0;t<e.length;t++){const n=e[t];if(!oO(n)){if(Yo().getBool("WEBGL_RENDER_FLOAT32_CAPABLE"))throw Error("The value ".concat(n," cannot be represented with your ")+"current settings. Consider enabling float32 rendering: 'tf.env().set('WEBGL_RENDER_FLOAT32_ENABLED', true);'");throw Error("The value ".concat(n," cannot be represented on this device."))}}}getValuesFromTexture(e){const{shape:t,dtype:n,isPacked:a}=this.texData.get(e),r=yo(t);if(Yo().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")){const n=this.decode(e),a=this.texData.get(n.dataId),o=this.gpgpu.downloadMatrixFromPackedTexture(a.texture.texture,...tO(t)).subarray(0,r);return this.disposeIntermediateTensorInfo(n),o}const o=Yo().getBool("WEBGL_PACK")&&!0===a,s=o?xO(t):t,i=o?new aD(s):new nD(s),c=this.runWebGLProgram(i,[{shape:s,dtype:n,dataId:e}],"float32"),l=this.texData.get(c.dataId),u=this.gpgpu.downloadByteEncodedFloatMatrixFromOutputTexture(l.texture.texture,l.texShape[0],l.texShape[1]).subarray(0,r);return this.disposeIntermediateTensorInfo(c),u}timerAvailable(){return Yo().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0}time(e){const t=this.activeTimers,n=[];let a=!1;null==this.programTimersStack?(this.programTimersStack=n,a=!0):this.activeTimers.push(n),this.activeTimers=n,e();const r=Gl(this.activeTimers.map((e=>e.query))).filter((e=>null!=e)),o=Gl(this.activeTimers.map((e=>e.name))).filter((e=>null!=e));this.activeTimers=t,a&&(this.programTimersStack=null);const s={uploadWaitMs:this.uploadWaitMs,downloadWaitMs:this.downloadWaitMs,kernelMs:null,wallMs:null};return(async()=>{if(Yo().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0){const e=await Promise.all(r);s.kernelMs=function(e){let t=0;for(let n=0;n<e.length;n++)t+=e[n];return t}(e),s.getExtraProfileInfo=()=>e.map(((e,t)=>({name:o[t],ms:e}))).map((e=>"".concat(e.name,": ").concat(e.ms))).join(", ")}else s.kernelMs={error:"WebGL query timers are not supported in this environment."};return this.uploadWaitMs=0,this.downloadWaitMs=0,s})()}memory(){return{unreliable:!1,numBytesInGPU:this.numBytesInGPU,numBytesInGPUAllocated:this.textureManager.numBytesAllocated,numBytesInGPUFree:this.textureManager.numBytesFree}}startTimer(){return Yo().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?this.gpgpu.beginQuery():{startMs:Bl(),endMs:null}}endTimer(e){return Yo().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?(this.gpgpu.endQuery(),e):(e.endMs=Bl(),e)}async getQueryTime(e){if(Yo().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0)return this.gpgpu.waitForQueryAndGetTime(e);const t=e;return t.endMs-t.startMs}disposeData(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];if(this.pendingDisposal.has(e))return!1;if(!this.texData.has(e))return!0;if(t?this.texData.get(e).refCount=0:this.texData.get(e).refCount--,!t&&this.texData.get(e).refCount>0)return!1;if(this.pendingRead.has(e))return this.pendingDisposal.add(e),this.pendingDeletes++,!1;this.releaseGPUData(e);const{complexTensorInfos:n}=this.texData.get(e);return null!=n&&(this.disposeData(n.real.dataId,t),this.disposeData(n.imag.dataId,t)),this.texData.delete(e),!0}releaseGPUData(e){const{texture:t,dtype:n,texShape:a,usage:r,isPacked:o,slice:s}=this.texData.get(e),i=s&&s.origDataId||e,c=this.dataRefCount.get(i);c>1?this.dataRefCount.set(i,c-1):(this.dataRefCount.delete(i),null!=t&&(this.numBytesInGPU-=this.computeBytes(a,n),this.textureManager.releaseTexture(t,a,r,o)));const l=this.texData.get(e);l.texture=null,l.texShape=null,l.isPacked=!1,l.slice=null}getTexture(e){return this.uploadToGPU(e),this.texData.get(e).texture.texture}getDataInfo(e){return this.texData.get(e)}shouldExecuteOnCPU(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:BM;return Yo().getBool("WEBGL_CPU_FORWARD")&&e.every((e=>null==this.texData.get(e.dataId).texture&&yo(e.shape)<t))}getGPGPUContext(){return this.gpgpu}where(e){dl("tf.where() in webgl locks the UI thread. Call tf.whereAsync() instead");const t=e.dataSync();return PM(e.shape,t)}packedUnaryOp(e,t,n){const a=new MM(e.shape,t),r=this.compileAndRun(a,[e],n);return Uu().makeTensorFromTensorInfo(r)}abs(e){if(this.shouldExecuteOnCPU([e])&&"complex64"!==e.dtype){const t=JD(this.texData.get(e.dataId).values);return this.makeOutput(e.shape,e.dtype,t)}if(Yo().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(e,SM,e.dtype);const t=new wM(e.shape,SM),n=this.compileAndRun(t,[e]);return Uu().makeTensorFromTensorInfo(n)}makeTensorInfo(e,t,n){let a;if("string"===t&&null!=n&&n.length>0&&Ao(n[0])){const r=n.map((e=>Wl(e)));a=this.write(r,e,t)}else a=this.write(n,e,t);return this.texData.get(a).usage=null,{dataId:a,shape:e,dtype:t}}makeOutput(e,t,n){return Uu().makeTensorFromTensorInfo(this.makeTensorInfo(e,t,n),this)}unpackTensor(e){const t=new LM(e.shape);return this.runWebGLProgram(t,[e],e.dtype)}packTensor(e){const t=new mM(e.shape);return this.runWebGLProgram(t,[e],e.dtype,null,!0)}packedReshape(e,t){const n=[bO(e.shape),...yO(e.shape)],a={dtype:e.dtype,shape:n,dataId:e.dataId},r=[bO(t),...yO(t)],o=new gM(r,n),s=[n],i=this.runWebGLProgram(o,[a],e.dtype,s,!0);return{dataId:i.dataId,shape:t,dtype:i.dtype}}decode(e,t){const n=this.texData.get(e),{isPacked:a,shape:r,dtype:o}=n;if(null!=t){mo(yo(r)<=t[0]*t[1]*4,(()=>"customTexShape is too small. Row * Column * 4 should be equal or larger than the size of the tensor data."))}const s=xO(r);let i;i=a?new tD(s):new eD(s);const c=[null!=t?t:tO(s)];return{dtype:o,shape:r,dataId:this.runWebGLProgram(i,[{shape:s,dtype:o,dataId:e}],o,c,!0,t).dataId}}runWebGLProgram(e,t,n,a){let r=arguments.length>4&&void 0!==arguments[4]&&arguments[4],o=arguments.length>5?arguments[5]:void 0;const s=this.makeTensorInfo(e.outputShape,n),i=this.texData.get(s.dataId);if(e.packedOutput&&(i.isPacked=!0),e.outPackingScheme===JF.DENSE){const t=null!=o?o:tO(e.outputShape);i.texShape=t.map((e=>2*e))}if(null!=e.outTexUsage&&(i.usage=e.outTexUsage),0===yo(s.shape))return i.values=To(s.dtype,0),s;const c=[],l=t.map((t=>{if("complex64"===t.dtype)throw new Error("GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.");let n=this.texData.get(t.dataId);if(null==n.texture){if(!e.packedInputs&&yo(t.shape)<=Yo().getNumber("WEBGL_SIZE_UPLOAD_UNIFORM"))return{shape:t.shape,texData:null,isUniform:!0,uniformValues:n.values};e.packedInputs&&(n.isPacked=!0,n.shape=t.shape)}if(this.uploadToGPU(t.dataId),!!n.isPacked!==!!e.packedInputs)t=n.isPacked?this.unpackTensor(t):this.packTensor(t),c.push(t),n=this.texData.get(t.dataId);else if(n.isPacked&&!wO(n.shape,t.shape)){const e=t,a=t.shape;t.shape=n.shape,t=this.packedReshape(t,a),c.push(t),n=this.texData.get(t.dataId),e.shape=a}return{shape:t.shape,texData:n,isUniform:!1}}));this.uploadToGPU(s.dataId);const u={shape:s.shape,texData:i,isUniform:!1},d=function(e,t,n){let a="";t.concat(n).forEach((t=>{const r=null!=t.texData&&null!=t.texData.slice&&t.texData.slice.flatOffset>0;if(e.enableShapeUniforms&&!t.isUniform){const o=t.texData.texShape,{useSqueezeShape:s,uniformShape:i,keptDims:c}=qO(e.packedInputs,t.shape,o);let l="",u="",d="";if(1===i.length&&e.packedInputs){const e=[Math.ceil(o[0]/2),Math.ceil(o[1]/2)];l="".concat(e[0]>1,"_").concat(e[1]>1)}else if(2!==i.length||e.packedInputs){if(i.length>2&&!e.packedInputs){const e=Lo(i);d="".concat(e[0]===o[1],"_").concat(e[e.length-1]===o[1])}}else u="".concat(i[0]>1,"_").concat(i[1]>1);const h=t.shape.length,p=2===i.length&&xo(t.shape,o),f=1===yo(t.shape),m=rh(t.shape,n.shape),g=!e.packedInputs&&h===n.shape.length&&xo(o,n.texData.texShape),b=e.packedInputs||i.length>2?"":"".concat(o[0]>1,"_").concat(o[1]>1);a+="".concat(h,"_").concat(g,"_").concat(s?c:"","_").concat(i.length,"_").concat(f,"_").concat(m,"_").concat(p,"_").concat(l,"_").concat(u,"_").concat(d,"_").concat(b,"_").concat(r)}else{const e=t.isUniform?"uniform":t.texData.texShape;a+="".concat(t.shape,"_").concat(e,"_").concat(r)}}));const r=e.userCode;let o=e.constructor.name;return o+="_"+a+"_"+r+"".concat(Yo().getNumber("WEBGL_VERSION")),o}(e,l,u),h=this.getAndSaveBinary(d,(()=>QO(this.gpgpu,e,l,u))),p=null!=this.activeTimers;let f;p&&(f=this.startTimer()),Yo().get("ENGINE_COMPILE_ONLY")||function(e,t,n,a,r){t.program.enableShapeUniforms||(ZO(t.inShapeInfos,n),ZO([t.outShapeInfo],[a]));const o=a.texData.texture,s=a.texData.texShape;a.texData.isPacked?e.setOutputPackedMatrixTexture(o.texture,s[0],s[1]):e.setOutputMatrixTexture(o.texture,s[0],s[1]),e.setProgram(t.webGLProgram),e.bindVertexArray(t.webGLProgram.vao),1===Yo().getNumber("WEBGL_VERSION")&&null!==t.infLoc&&e.gl.uniform1f(t.infLoc,1/0),null!==t.nanLoc&&e.gl.uniform1f(t.nanLoc,NaN);for(let c=0;c<n.length;++c){const a=n[c],{uniform:r,offset:o,shape:s,texShape:i}=t.variablesLocations[c];if(s){const{uniformShape:n}=qO(t.program.packedInputs,a.shape,a.texData.texShape);switch(n.length){case 1:e.gl.uniform1iv(s,new Int32Array(n));break;case 2:e.gl.uniform2iv(s,new Int32Array(n));break;case 3:e.gl.uniform3iv(s,new Int32Array(n));break;case 4:e.gl.uniform4iv(s,new Int32Array(n))}}if(i&&e.gl.uniform2i(i,a.texData.texShape[0],a.texData.texShape[1]),null!=r)if(a.isUniform)if(yo(a.shape)<2)e.gl.uniform1f(r,a.uniformValues[0]);else{let t=a.uniformValues;t instanceof Float32Array||(t=new Float32Array(t)),e.gl.uniform1fv(r,t)}else null!=a.texData.slice&&null!=o&&e.gl.uniform1i(o,a.texData.slice.flatOffset),e.setInputMatrixTexture(a.texData.texture.texture,r,c)}const i=t.outShapeLocation;if(i)switch(a.shape.length){case 1:e.gl.uniform1iv(i,new Int32Array(a.shape));break;case 2:e.gl.uniform2iv(i,new Int32Array(a.shape));break;case 3:e.gl.uniform3iv(i,new Int32Array(a.shape));break;case 4:e.gl.uniform4iv(i,new Int32Array(a.shape))}if(t.outShapeStridesLocation){const n=Lo(a.shape);switch(a.shape.length){case 2:e.gl.uniform1iv(t.outShapeStridesLocation,new Int32Array(n));break;case 3:e.gl.uniform2iv(t.outShapeStridesLocation,new Int32Array(n));break;case 4:e.gl.uniform3iv(t.outShapeStridesLocation,new Int32Array(n))}}if(t.outTexShapeLocation&&e.gl.uniform2i(t.outTexShapeLocation,a.texData.texShape[0],a.texData.texShape[1]),t.program.customUniforms&&r)for(let c=0;c<t.program.customUniforms.length;++c){const n=t.program.customUniforms[c],a=t.customUniformLocations[c],o=r[c];if("float"===n.type)e.gl.uniform1fv(a,o);else if("vec2"===n.type)e.gl.uniform2fv(a,o);else if("vec3"===n.type)e.gl.uniform3fv(a,o);else if("vec4"===n.type)e.gl.uniform4fv(a,o);else if("int"===n.type)e.gl.uniform1iv(a,o);else if("ivec2"===n.type)e.gl.uniform2iv(a,o);else if("ivec3"===n.type)e.gl.uniform3iv(a,o);else{if("ivec4"!==n.type)throw Error("uniform type ".concat(n.type," is not supported yet."));e.gl.uniform4iv(a,o)}}e.executeProgram()}(this.gpgpu,h,l,u,a),c.forEach((e=>this.disposeIntermediateTensorInfo(e))),p&&(f=this.endTimer(f),this.activeTimers.push({name:e.constructor.name,query:this.getQueryTime(f)}));const m=Yo().getNumber("WEBGL_FLUSH_THRESHOLD");if(m>0){const e=Bl();e-this.lastGlFlushTime>m&&(this.gpgpu.gl.flush(),this.lastGlFlushTime=e)}if(!Yo().getBool("WEBGL_LAZILY_UNPACK")&&i.isPacked&&!1===r){const e=this.unpackTensor(s);return this.disposeIntermediateTensorInfo(s),e}return s}compileAndRun(e,t,n,a){let r=arguments.length>4&&void 0!==arguments[4]&&arguments[4];n=n||t[0].dtype;return this.runWebGLProgram(e,t,n,a,r)}getAndSaveBinary(e,t){return e in this.binaryCache||(this.binaryCache[e]=t()),this.binaryCache[e]}getTextureManager(){return this.textureManager}dispose(){if(!this.disposed){if(!Yo().getBool("IS_TEST")){Object.keys(this.binaryCache).forEach((e=>{this.gpgpu.deleteProgram(this.binaryCache[e].webGLProgram),delete this.binaryCache[e]}))}this.textureManager.dispose(),null!=this.canvas&&"undefined"!==typeof HTMLCanvasElement&&this.canvas instanceof HTMLCanvasElement?this.canvas.remove():this.canvas=null,this.gpgpuCreatedLocally&&(this.gpgpu.program=null,this.gpgpu.dispose()),this.disposed=!0}}floatPrecision(){return null==this.floatPrecisionValue&&(this.floatPrecisionValue=Hu((()=>{if(!Yo().get("WEBGL_RENDER_FLOAT32_ENABLED")){const e=Yo().getBool("DEBUG");Yo().set("DEBUG",!1);const t=this.abs(Hd(1e-8)).dataSync()[0];if(Yo().set("DEBUG",e),t>0)return 32}return 16}))),this.floatPrecisionValue}epsilon(){return 32===this.floatPrecision()?1e-7:1e-4}uploadToGPU(e){const t=this.texData.get(e),{shape:n,dtype:a,values:r,texture:o,usage:s,isPacked:i}=t;if(null!=o)return;const c=null!=this.activeTimers;let l;c&&(l=Bl());let u=t.texShape;if(null==u&&(u=function(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1],n=Yo().getNumber("WEBGL_MAX_TEXTURE_SIZE"),a=Yo().getNumber("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE");if(a===1/0&&Yo().getBool("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE")&&(a=n/2),t&&(n*=2,a*=2,e=e.map(((t,n)=>n>=e.length-2?po(e[n]):e[n])),1===e.length&&(e=[2,e[0]])),2!==e.length){const t=Co(e);e=t.newShape}let r=yo(e),o=null;e.length<=1&&r<=n?o=[1,r]:2===e.length&&e[0]<=n&&e[1]<=n?o=e:3===e.length&&e[0]*e[1]<=n&&e[2]<=n?o=[e[0]*e[1],e[2]]:3===e.length&&e[0]<=n&&e[1]*e[2]<=n?o=[e[0],e[1]*e[2]]:4===e.length&&e[0]*e[1]*e[2]<=n&&e[3]<=n?o=[e[0]*e[1]*e[2],e[3]]:4===e.length&&e[0]<=n&&e[1]*e[2]*e[3]<=n&&(o=[e[0],e[1]*e[2]*e[3]]);const s=null!=o&&Math.max(...o)>a&&Math.min(...o)<=(t?2:1)&&Math.min(...o)>0;if(null==o||s)if(t){const t=bO(e);let n=2,a=2;e.length&&([n,a]=yO(e)),r=t*(n/2)*(a/2),o=wo(r).map((e=>2*e))}else o=wo(r);return o}(n,i),t.texShape=u),null!=r){const e=xO(n);let o,s=u[1],d=u[0];const h=r instanceof Uint8Array||r instanceof Uint8ClampedArray;!i&&h||([s,d]=nO(u[0],u[1])),o=i?new sD(e,h):new oD(e,h);const p=h?[d,s]:u,f=this.makeTensorInfo(p,a),m=this.texData.get(f.dataId);m.usage=h?ZF.PIXELS:ZF.UPLOAD,m.texShape=p,this.gpgpu.uploadDenseMatrixToTexture(this.getTexture(f.dataId),s,d,r);const g=[[d,s]],b=!0,y=this.runWebGLProgram(o,[f],a,g,b),x=this.texData.get(y.dataId);t.texShape=x.texShape,t.isPacked=x.isPacked,t.usage=x.usage,Yo().get("ENGINE_COMPILE_ONLY")?this.disposeData(y.dataId):(t.texture=x.texture,t.values=null,this.texData.delete(y.dataId)),this.disposeIntermediateTensorInfo(f),c&&(this.uploadWaitMs+=Bl()-l)}else{const e=this.acquireTexture(u,s,a,i);t.texture=e}}convertAndCacheOnCPU(e,t){const n=this.texData.get(e),{dtype:a}=n;return null!=t&&(n.values=function(e,t){if("float32"===t||"complex64"===t)return e;if("int32"===t||"bool"===t){const n="int32"===t?new Int32Array(e.length):new Uint8Array(e.length);for(let t=0;t<n.length;++t)n[t]=Math.round(e[t]);return n}throw new Error("Unknown dtype ".concat(t))}(t,a)),n.values}acquireTexture(e,t,n,a){if(this.numBytesInGPU+=this.computeBytes(e,n),!this.warnedAboutMemory&&this.numBytesInGPU>1024*this.numMBBeforeWarning*1024){const e=(this.numBytesInGPU/1024/1024).toFixed(2);this.warnedAboutMemory=!0,console.warn("High memory usage in GPU: ".concat(e," MB, ")+"most likely due to a memory leak")}return this.textureManager.acquireTexture(e,t,a)}computeBytes(e,t){return e[0]*e[1]*_o(t)}checkCompileCompletion(){for(const[,e]of Object.entries(this.binaryCache))this.checkCompletion_(e)}async checkCompileCompletionAsync(){const e=[];if(this.gpgpu.parallelCompilationExtension){for(const[,t]of Object.entries(this.binaryCache))e.push(this.checkCompletionAsync_(t));return Promise.all(e)}for(const[,t]of Object.entries(this.binaryCache)){const n=new Promise((e=>{try{this.checkCompletion_(t),e(!0)}catch(n){throw n}}));e.push(n)}return Promise.all(e)}async checkCompletionAsync_(e){return this.gpgpu.gl.getProgramParameter(e.webGLProgram,this.gpgpu.parallelCompilationExtension.COMPLETION_STATUS_KHR)?this.checkCompletion_(e):(await Ym(),this.checkCompletionAsync_(e))}checkCompletion_(e){if(!1===this.gpgpu.gl.getProgramParameter(e.webGLProgram,this.gpgpu.gl.LINK_STATUS)){if(console.log(this.gpgpu.gl.getProgramInfoLog(e.webGLProgram)),!1===this.gpgpu.gl.getShaderParameter(e.fragmentShader,this.gpgpu.gl.COMPILE_STATUS))throw cO(e.source,this.gpgpu.gl.getShaderInfoLog(e.fragmentShader)),new Error("Failed to compile fragment shader.");throw new Error("Failed to link vertex and fragment shaders.")}return!0}getUniformLocations(){for(const e of Object.values(this.binaryCache)){this.gpgpu.buildVao(e.webGLProgram);const{variablesLocations:t,customUniformLocations:n,infLoc:a,nanLoc:r,outShapeLocation:o,outShapeStridesLocation:s,outTexShapeLocation:i}=JO(this.gpgpu,e.program,e.webGLProgram);e.variablesLocations=t,e.customUniformLocations=n,e.infLoc=a,e.nanLoc=r,e.outShapeLocation=o,e.outShapeStridesLocation=s,e.outTexShapeLocation=i}}createTensorFromGPUData(e,t,n){e.channels=e.channels||"RGBA";const{texture:a,height:r,width:o,channels:s}=e,i=Uu().backend;if(!i.gpgpu.gl.isTexture(a))throw new Error("The texture is invalid. Also, please make sure the texture and the TFJS WebGL backend are using the same canvas. If you want to use your own custom canvas, you have to create and use the custom TFJS WebGL backend created from the canvas through 'new tf.MathBackendWebGL(customCanvas)'.");const c=i.writeTexture(a,t,n,r,o,s);return Uu().makeTensorFromDataId(c,t,n,i)}}WM.nextDataId=0;_u()&&Xu("webgl",(()=>new WM),2);const VM="\n  if (isnan(a)) return a;\n  if (isnan(b)) return b;\n";class UM{constructor(e,t,n){this.variableNames=["A","B"],this.outputShape=sh(t,n),this.enableShapeUniforms=$O(this.outputShape.length),this.userCode="\n      float binaryOperation(float a, float b) {\n        ".concat(e,"\n      }\n\n      void main() {\n        float a = getAAtOutCoords();\n        float b = getBAtOutCoords();\n        setOutput(binaryOperation(a, b));\n      }\n    ")}}const GM="\n  result.r = isNaN.r ? NAN : result.r;\n  result.g = isNaN.g ? NAN : result.g;\n  result.b = isNaN.b ? NAN : result.b;\n  result.a = isNaN.a ? NAN : result.a;\n";class HM{constructor(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]&&arguments[3];this.variableNames=["A","B"],this.supportsBroadcasting=!0,this.packedInputs=!0,this.packedOutput=!0,this.outputShape=sh(t,n);const r=this.outputShape.length;this.enableShapeUniforms=$O(r);let o="";if(a)if(0===r||1===yo(this.outputShape))o="\n          result.y = 0.;\n          result.z = 0.;\n          result.w = 0.;\n        ";else{const e=KO(r);if(o="\n          ".concat(e," coords = getOutputCoords();\n        "),1===r)this.enableShapeUniforms?o+="\n            result.y = (coords + 1) >= outShape ? 0. : result.y;\n            result.z = 0.;\n            result.w = 0.;\n          ":o+="\n            result.y = (coords + 1) >= ".concat(this.outputShape[0]," ? 0. : result.y;\n            result.z = 0.;\n            result.w = 0.;\n          ");else{const e=fM("coords",r);this.enableShapeUniforms?o+="\n            bool nextRowOutOfBounds =\n              (".concat(e[r-2]," + 1) >= outShape[").concat(r," - 2];\n            bool nextColOutOfBounds =\n              (").concat(e[r-1]," + 1) >= outShape[").concat(r," - 1];\n            result.y = nextColOutOfBounds ? 0. : result.y;\n            result.z = nextRowOutOfBounds ? 0. : result.z;\n            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;\n          "):o+="\n            bool nextRowOutOfBounds =\n              (".concat(e[r-2]," + 1) >= ").concat(this.outputShape[r-2],";\n            bool nextColOutOfBounds =\n              (").concat(e[r-1]," + 1) >= ").concat(this.outputShape[r-1],";\n            result.y = nextColOutOfBounds ? 0. : result.y;\n            result.z = nextRowOutOfBounds ? 0. : result.z;\n            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;\n          ")}}this.userCode="\n      vec4 binaryOperation(vec4 a, vec4 b) {\n        ".concat(e,"\n      }\n\n      void main() {\n        vec4 a = getAAtOutCoords();\n        vec4 b = getBAtOutCoords();\n\n        vec4 result = binaryOperation(a, b);\n        ").concat(o,"\n\n        setOutput(result);\n      }\n    ")}}function jM(e){const{inputs:t,backend:n}=e,{x:a}=t;return n.incRef(a.dataId),{dataId:a.dataId,shape:a.shape,dtype:a.dtype}}const KM={kernelName:mi,backendName:"webgl",kernelFunc:jM};function qM(e){const{inputs:t,backend:n}=e,{real:a,imag:r}=t,o=n.makeTensorInfo(a.shape,"complex64"),s=n.texData.get(o.dataId),i=jM({inputs:{x:a},backend:n}),c=jM({inputs:{x:r},backend:n});return s.complexTensorInfos={real:i,imag:c},o}const XM={kernelName:Cs,backendName:"webgl",kernelFunc:qM},YM="return (a < 0.) ? b * a : a;",QM="\n  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));\n  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);\n";const JM={kernelName:wi,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{alpha:o}=a,s=n.makeTensorInfo([],"float32",Pl(o,"float32")),i=Yo().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new HM(QM,r.shape,s.shape):new UM(YM,r.shape,s.shape),c=n.runWebGLProgram(i,[r,s],"float32");return n.disposeIntermediateTensorInfo(s),c}},ZM="return (a < 0.) ? b * a : a;",$M="\n  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));\n  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);\n";const eL={kernelName:nc,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{x:a,alpha:r}=t,o=Yo().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new HM($M,a.shape,r.shape):new UM(ZM,a.shape,r.shape);return n.runWebGLProgram(o,[a,r],"float32")}},tL="if (isnan(x)) return x;";function nL(e){let{opSnippet:t,packedOpSnippet:n,cpuKernelImpl:a,dtype:r}=e;return e=>{let{inputs:o,backend:s}=e;const{x:i}=o,c=s,l=r||i.dtype;if(c.shouldExecuteOnCPU([i])&&null!=a){const e=c.texData.get(i.dataId),t=a(e.values,l);return c.makeTensorInfo(i.shape,l,t)}let u;return u=Yo().getBool("WEBGL_PACK_UNARY_OPERATIONS")&&null!=n?new MM(i.shape,n):new wM(i.shape,t),c.runWebGLProgram(u,[i],l)}}function aL(e){let{opSnippet:t,packedOpSnippet:n,checkOutOfBounds:a=!1,supportsComplex:r=!1,cpuKernelImpl:o,dtype:s}=e;return e=>{let{inputs:i,backend:c}=e;const{a:l,b:u}=i,d=c;if(r&&"complex64"===l.dtype){const e=d.texData.get(l.dataId),n=d.texData.get(u.dataId),[a,r]=[[e.complexTensorInfos.real,n.complexTensorInfos.real],[e.complexTensorInfos.imag,n.complexTensorInfos.imag]].map((e=>{const[n,a]=e,r={dataId:n.dataId,dtype:n.dtype,shape:l.shape},o={dataId:a.dataId,dtype:a.dtype,shape:u.shape},s=new UM(t,l.shape,u.shape);return d.runWebGLProgram(s,[r,o],fu(n.dtype,a.dtype))})),o=qM({inputs:{real:a,imag:r},backend:d});return d.disposeIntermediateTensorInfo(a),d.disposeIntermediateTensorInfo(r),o}const h=s||fu(l.dtype,u.dtype);if(("string"===l.dtype||"string"===u.dtype||d.shouldExecuteOnCPU([l,u]))&&null!=o){const e=d.texData.get(l.dataId).values,t=d.texData.get(u.dataId).values,n="string"===l.dtype?ab(e):e,a="string"===l.dtype?ab(t):t,[r,s]=o(l.shape,u.shape,n,a,h),i=d.makeTensorInfo(s,h);return d.texData.get(i.dataId).values=r,i}let p;return p=Yo().getBool("WEBGL_PACK_BINARY_OPERATIONS")&&null!=n?new HM(n,l.shape,u.shape,a):new UM(t,l.shape,u.shape),d.runWebGLProgram(p,[l,u],h)}}function rL(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];if("linear"===e)return t?_M:IM;if("relu"===e)return t?FM:CM;if("elu"===e)return t?AM:NM;if("relu6"===e)return t?OM:TM;if("prelu"===e)return t?$M:ZM;if("leakyrelu"===e)return t?QM:YM;if("sigmoid"===e)return t?DM:RM;throw new Error("Activation ".concat(e," has not been implemented for the WebGL backend."))}class oL{constructor(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]&&arguments[3],r=arguments.length>4&&void 0!==arguments[4]&&arguments[4],o=arguments.length>5&&void 0!==arguments[5]&&arguments[5],s=arguments.length>6&&void 0!==arguments[6]?arguments[6]:null,i=arguments.length>7&&void 0!==arguments[7]&&arguments[7],c=arguments.length>8&&void 0!==arguments[8]&&arguments[8];this.variableNames=["matrixA","matrixB"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=n,this.enableShapeUniforms=$O(this.outputShape.length);const l=a?e[1]:e[2],u=Math.ceil(l/2),d=a?"i * 2, rc.y":"rc.y, i * 2",h=r?"rc.z, i * 2":"i * 2, rc.z",p=a?["a.xxyy","a.zzww"]:["a.xxzz","a.yyww"],f=r?["b.xzxz","b.ywyw"]:["b.xyxy","b.zwzw"];let m="",g="";s&&(m=i?"vec4 activation(vec4 a) {\n          vec4 b = getPreluActivationWeightsAtOutCoords();\n          ".concat(s,"\n        }"):c?"vec4 activation(vec4 a) {\n          vec4 b = getLeakyreluAlphaAtOutCoords();\n          ".concat(s,"\n        }"):"vec4 activation(vec4 x) {\n          ".concat(s,"\n        }"),g="result = activation(result);");const b=o?"result += getBiasAtOutCoords();":"";o&&this.variableNames.push("bias"),i&&this.variableNames.push("preluActivationWeights"),c&&this.variableNames.push("leakyreluAlpha");let y="rc.x",x="rc.x";e[0]<t[0]?y="imod(rc.x, ".concat(e[0],")"):t[0]<e[0]&&(x="imod(rc.x, ".concat(t[0],")")),this.userCode="\n      ".concat(m,"\n      // Don't use uniform for sharedDimensionPacked for performance.\n      const float sharedDimension = ").concat(u,".0;\n\n      vec4 dot2x2ARowBCol(ivec3 rc) {\n        vec4 result = vec4(0);\n        int batchA = ").concat(y,";\n        int batchB = ").concat(x,";\n        for (int i = 0; i < ").concat(u,"; i++) {\n          vec4 a = getMatrixA(batchA, ").concat(d,");\n          vec4 b = getMatrixB(batchB, ").concat(h,");\n\n          // These swizzled products need to be separately added.\n          // See: https://github.com/tensorflow/tfjs/issues/1735\n          result += (").concat(p[0]," * ").concat(f[0],");\n          result += (").concat(p[1]," * ").concat(f[1],");\n        }\n        return result;\n      }\n\n      void main() {\n        ivec3 rc = getOutputCoords();\n        vec4 result = dot2x2ARowBCol(rc);\n\n        ").concat(b,"\n\n        ").concat(g,"\n\n        setOutput(result);\n      }\n    ")}}const sL={REAL:"return areal * breal - aimag * bimag;",IMAG:"return areal * bimag + aimag * breal;"};class iL{constructor(e,t,n){this.variableNames=["AReal","AImag","BReal","BImag"],this.outputShape=sh(t,n),this.userCode="\n      float binaryOpComplex(\n          float areal, float aimag, float breal, float bimag) {\n        ".concat(e,"\n      }\n\n      void main() {\n        float areal = getARealAtOutCoords();\n        float aimag = getAImagAtOutCoords();\n        float breal = getBRealAtOutCoords();\n        float bimag = getBImagAtOutCoords();\n        setOutput(binaryOpComplex(areal, aimag, breal, bimag));\n      }\n    ")}}const cL="return a * b;";function lL(e){const{inputs:t,backend:n}=e,{a:a,b:r}=t,o=fu(a.dtype,r.dtype);if("complex64"===a.dtype){const e=n.texData.get(a.dataId),t=n.texData.get(r.dataId),o=new iL(sL.REAL,a.shape,r.shape),s=new iL(sL.IMAG,a.shape,r.shape),i=[{dataId:e.complexTensorInfos.real.dataId,dtype:e.complexTensorInfos.real.dtype,shape:a.shape},{dataId:e.complexTensorInfos.imag.dataId,dtype:e.complexTensorInfos.imag.dtype,shape:a.shape},{dataId:t.complexTensorInfos.real.dataId,dtype:t.complexTensorInfos.real.dtype,shape:r.shape},{dataId:t.complexTensorInfos.imag.dataId,dtype:t.complexTensorInfos.imag.dtype,shape:r.shape}],c=n.runWebGLProgram(o,i,"float32"),l=n.runWebGLProgram(s,i,"float32"),u=qM({inputs:{real:c,imag:l},backend:n});return n.disposeIntermediateTensorInfo(c),n.disposeIntermediateTensorInfo(l),u}if(n.shouldExecuteOnCPU([a,r])){const e=n.texData.get(a.dataId),t=n.texData.get(r.dataId),[s,i]=WD(a.shape,r.shape,e.values,t.values,o),c=n.makeTensorInfo(i,o);return n.texData.get(c.dataId).values=s,c}let s;return s=Yo().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new HM(cL,a.shape,r.shape):new UM(cL,a.shape,r.shape),n.runWebGLProgram(s,[a,r],o)}const uL={kernelName:ji,backendName:"webgl",kernelFunc:lL};function dL(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{shape:o}=a,s=n,i=yo(r.shape),c=So(o,i),l=yo(c);mo(i===l,(()=>"The new shape (".concat(c,") has ").concat(l," elements and the old ")+"shape (".concat(r.shape,") has ").concat(i," elements. The new shape and old ")+"shape must have the same number of elements."));const u=s.texData.get(r.dataId);return!u.isPacked||wO(r.shape,c)||null!==u.texture&&wO(u.shape,c)?(s.incRef(r.dataId),{dataId:r.dataId,shape:c,dtype:r.dtype}):function(e,t,n){const a=[bO(e.shape),...yO(e.shape)],r={dtype:e.dtype,shape:a,dataId:e.dataId},o=[bO(t),...yO(t)],s=new gM(o,a),i=[a],c=n.runWebGLProgram(s,[r],e.dtype,i,!0);return{dataId:c.dataId,shape:t,dtype:c.dtype}}(r,c,s)}const hL={kernelName:dc,backendName:"webgl",kernelFunc:dL};class pL{constructor(e,t){this.variableNames=["x"];const{windowSize:n,batchSize:a,inSize:r,outSize:o}=e;this.outputShape=[a,o];const s=4*Math.floor(n/4),i=n%4;let c="sumValue += dot(values, ones);";if(null!=t){const e=1/t;c="sumValue += dot(values * ".concat(vo(e)?e.toPrecision(2):e,", ones);")}let l="";r%n>0&&(l="\n        if (inIdx < 0 || inIdx >= ".concat(r,") {\n          return 0.0;\n        }\n      ")),this.userCode="\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float getValue(int batch, int inIdx) {\n        ".concat(l,"\n        return getX(batch, inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ").concat(n,";\n\n        float sumValue = 0.0;\n\n        for (int i = 0; i < ").concat(s,"; i += 4) {\n          int inIdx = inOffset + i;\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          ").concat(c,"\n        }\n\n        int inIdx = inOffset + ").concat(s,";\n        if (").concat(1===i,") {\n          vec4 values = vec4(getValue(batch, inIdx), 0.0, 0.0, 0.0);\n\n          ").concat(c,"\n        } else if (").concat(2===i,") {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1), 0.0, 0.0);\n\n          ").concat(c,"\n        } else if (").concat(3===i,") {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2), 0.0);\n\n          ").concat(c,"\n        }\n        setOutput(sumValue);\n      }\n    ")}}class fL{constructor(e,t){this.variableNames=["x"];const{windowSize:n,batchSize:a,inSize:r,outSize:o}=e;this.outputShape=[a,o];let s="0.0",i="";"prod"===t?s="1.0":"min"===t?(s="1.0 / 1e-20",i="min"):"max"===t&&(s="-1.0 / 1e-20",i="max");let c="".concat(t,"(").concat(t,"(").concat(t,"(")+"minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])";"sum"===t?c="sumValue":"prod"===t?c="prodValue":"all"===t?c="allValue":"any"===t&&(c="anyValue");const l=4*Math.floor(n/4),u=n%4;let d="\n      if (".concat("sum"===t,") {\n        sumValue += dot(values, ones);\n      } else if (").concat("prod"===t,") {\n        vec2 tmp = vec2(values[0], values[1]) * vec2(values[2], values[3]);\n        prodValue *= tmp[0] * tmp[1];\n      } else {\n        minMaxValue = ").concat(i,"(values, minMaxValue);\n        if (").concat("min"===t," || ").concat("max"===t,") {\n          minMaxValue = ").concat(i,"(values, minMaxValue);\n          bvec4 isNaN = isnan(values);\n          if (isNaN.r || isNaN.g || isNaN.b || isNaN.a) {\n            minMaxValue = vec4(NAN);\n          }\n        }\n      }\n    "),h="vec4";"all"===t?(s="1.0",d="\n        bool reducedAllValue = all(values);\n        float floatedReducedAllValue = float(reducedAllValue);\n        allValue = float(allValue >= 1.0 && floatedReducedAllValue >= 1.0);\n      ",h="bvec4"):"any"===t&&(s="0.0",d="\n        bool reducedAnyValue = any(values);\n        float floatedReducedAnyValue = float(reducedAnyValue);\n        anyValue = float(anyValue >= 1.0 || floatedReducedAnyValue >= 1.0);\n      ",h="bvec4");let p="";r%n>0&&(p="\n        if (inIdx < 0 || inIdx >= ".concat(r,") {\n          return initializationValue;\n        }\n      ")),this.userCode="\n      const float initializationValue = ".concat(s,";\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float getValue(int batch, int inIdx) {\n        ").concat(p,"\n        return getX(batch, inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ").concat(n,";\n\n        vec4 minMaxValue = vec4(").concat(s,");\n        float prodValue = 1.0;\n        float sumValue = 0.0;\n        float allValue = 1.0;\n        float anyValue = 0.0;\n\n        for (int i = 0; i < ").concat(l,"; i += 4) {\n          int inIdx = inOffset + i;\n          ").concat(h," values = ").concat(h,"(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          ").concat(d,"\n        }\n\n        int inIdx = inOffset + ").concat(l,";\n        if (").concat(1===u,") {\n          ").concat(h," values = ").concat(h,"(\n            getValue(batch, inIdx),\n            initializationValue,\n            initializationValue,\n            initializationValue\n          );\n\n          ").concat(d,"\n        } else if (").concat(2===u,") {\n          ").concat(h," values = ").concat(h,"(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            initializationValue,\n            initializationValue\n          );\n\n          ").concat(d,"\n        } else if (").concat(3===u,") {\n          ").concat(h," values = ").concat(h,"(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            initializationValue\n          );\n\n          ").concat(d,"\n        }\n        setOutput(").concat(c,");\n      }\n    ")}}function mL(e,t,n,a){const r=function(e){const t=[];for(;0===t.length||1!==t[t.length-1].outSize;){const n=t.length?t[t.length-1].outSize:e[1],a=rg(n);t.push({inSize:n,windowSize:a,outSize:Math.ceil(n/a)})}return t}(e.shape);let o=e;for(let s=0;s<r.length;s++){const{inSize:i,windowSize:c,outSize:l}=r[s];let u,d;u="mean"===n?0===s?new pL({windowSize:c,inSize:i,batchSize:e.shape[0],outSize:l},i):new pL({windowSize:c,inSize:i,batchSize:e.shape[0],outSize:l}):new fL({windowSize:c,inSize:i,batchSize:e.shape[0],outSize:l},n),d=o,o=a.runWebGLProgram(u,[o],t),d.dataId!==e.dataId&&a.disposeIntermediateTensorInfo(d)}return o}class gL{constructor(e,t){this.variableNames=["A"];const n=new Array(e.length);for(let o=0;o<n.length;o++)n[o]=e[t[o]];this.outputShape=n,this.rank=n.length;const a=KO(this.rank),r=function(e){const t=e.length;if(t>6)throw Error("Transpose for rank ".concat(t," is not yet supported"));const n=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u","resRC.v"],a=new Array(t);for(let r=0;r<e.length;r++)a[e[r]]=n[r];return a.join()}(t);this.userCode="\n    void main() {\n      ".concat(a," resRC = getOutputCoords();\n      setOutput(getA(").concat(r,"));\n    }\n    ")}}class bL{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0;const n=new Array(e.length);for(let l=0;l<n.length;l++)n[l]=e[t[l]];if(this.outputShape=n,this.rank=n.length,this.rank>6)throw Error("Packed transpose for rank ".concat(this.rank," is not yet supported."));const a=KO(this.rank),r=pM("rc",this.rank),o=new Array(this.rank);for(let l=0;l<t.length;l++)o[t[l]]=r[l];const s="vec2(".concat(o.slice(-2).join(),")"),i="++".concat(r[this.rank-1]," < ").concat(n[this.rank-1]),c="getChannel(getA(".concat(o.join(),"), ").concat(s,")");this.userCode="\n    void main() {\n      ".concat(a," rc = getOutputCoords();\n      vec4 result = vec4(0.);\n      result[0] = ").concat(c,";\n      if(").concat(i,") {\n        result[1] = ").concat(c,";\n      }\n      --").concat(r[this.rank-1],";\n      if(++").concat(r[this.rank-2]," < ").concat(n[this.rank-2],") {\n        result[2] = ").concat(c,";\n        if(").concat(i,") {\n          result[3] = ").concat(c,";\n        }\n      }\n      setOutput(result);\n    }\n    ")}}function yL(e,t,n){const a=Yo().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new bL(e.shape,t):new gL(e.shape,t);return n.runWebGLProgram(a,[e],e.dtype)}function xL(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{axis:o,keepDims:s}=a;return function(e,t,n,a){const r=t,o=e.shape.length,s=No(r,e.shape);let i=s;const c=Xp(i,o),l=null!=c;let u=e;l&&(u=yL(e,c,a),i=Qp(i.length,o)),qp("sum",i,o);const[d,h]=jp(u.shape,i);let p=d;n&&(p=Kp(d,s));const f=yo(h),m=dL({inputs:{x:u},attrs:{shape:[yo(e.shape)/f,f]},backend:a}),g=mL(m,mu(e.dtype),"sum",a),b=dL({inputs:{x:g},attrs:{shape:p},backend:a});return a.disposeIntermediateTensorInfo(m),a.disposeIntermediateTensorInfo(g),l&&a.disposeIntermediateTensorInfo(u),b}(r,o,s,n)}const vL={kernelName:Fc,backendName:"webgl",kernelFunc:xL};function wL(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{perm:o}=a,s=n,i=r.shape.length,c=new Array(i);for(let u=0;u<c.length;u++)c[u]=r.shape[o[u]];let l;if(s.shouldExecuteOnCPU([r])){const e=s.texData.get(r.dataId).values,t=dM(e,r.shape,r.dtype,o,c);l=s.makeTensorInfo(c,r.dtype);s.texData.get(l.dataId).values=t}else l=yL(r,o,s);return l}const kL={kernelName:el,backendName:"webgl",kernelFunc:wL},IL=1e3;function SL(e){let{a:t,b:n,transposeA:a,transposeB:r,backend:o,bias:s=null,preluActivationWeights:i=null,leakyreluAlpha:c=0,activation:l=null}=e;const u=t.shape.length,d=n.shape.length,h=a?t.shape[u-2]:t.shape[u-1],p=r?n.shape[d-1]:n.shape[d-2],f=a?t.shape[u-1]:t.shape[u-2],m=r?n.shape[d-2]:n.shape[d-1],g=t.shape.slice(0,-2),b=n.shape.slice(0,-2),y=yo(g),x=yo(b),v=sh(t.shape.slice(0,-2),n.shape.slice(0,-2)).concat([f,m]);mo(h===p,(()=>"Error in matMul: inner shapes (".concat(h,") and (")+"".concat(p,") of Tensors with shapes ").concat(t.shape," and ")+"".concat(n.shape," and transposeA=").concat(a)+" and transposeB=".concat(r," must match.")));const w=a?[y,h,f]:[y,f,h],k=r?[x,m,p]:[x,p,m],I=dL({inputs:{x:t},backend:o,attrs:{shape:w}}),S=dL({inputs:{x:n},backend:o,attrs:{shape:k}}),N=[I,S],C=Math.max(y,x),T=a?I.shape[1]:I.shape[2],E=null!=s,R=null!=i,_="leakyrelu"===l,A=null!=l?rL(l,!0):null;let F;if((1===f||1===m)&&T>IL&&!1===(E||R||_||null!=A)){let e=I,t=S;a&&(e=wL({inputs:{x:I},backend:o,attrs:{perm:[0,2,1]}}),N.push(e)),r&&(t=wL({inputs:{x:S},backend:o,attrs:{perm:[0,2,1]}}),N.push(t));const n=1===m;let s=e;1!==m&&(s=dL({inputs:{x:e},backend:o,attrs:{shape:[C,T,1]}}),N.push(s));const i=1===m?2:1;let c=t;n&&(c=dL({inputs:{x:t},backend:o,attrs:{shape:[C,1,T]}}),N.push(c));const l=lL({inputs:{a:s,b:c},backend:o});F=xL({inputs:{x:l},backend:o,attrs:{axis:i,keepDims:!0}}),N.push(l)}else{const e=fu(t.dtype,n.dtype),l=new oL(w,k,[C,f,m],a,r,E,A,R,_),u=[I,S];if(null!=s&&u.push(s),R&&u.push(i),_){const e=o.makeTensorInfo([],"float32",Pl(c,"float32"));u.push(e),N.push(e)}F=o.runWebGLProgram(l,u,e)}const O=dL({inputs:{x:F},backend:o,attrs:{shape:v}});N.push(F);for(const D of N)o.disposeIntermediateTensorInfo(D);return O}const NL={kernelName:cl,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{a:r,b:o,bias:s,preluActivationWeights:i}=t,{transposeA:c,transposeB:l,activation:u,leakyreluAlpha:d}=a;return SL({a:r,b:o,transposeA:c,transposeB:l,backend:n,bias:s,preluActivationWeights:i,leakyreluAlpha:d,activation:u})}},CL="return abs(x);";const TL={kernelName:es,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{x:a}=t;if(n.shouldExecuteOnCPU([a])&&"complex64"!==a.dtype){const e=n.texData.get(a.dataId),t=JD(e.values);return n.makeTensorInfo(a.shape,a.dtype,t)}let r;return r=Yo().getBool("WEBGL_PACK_UNARY_OPERATIONS")?new MM(a.shape,CL):new wM(a.shape,CL),n.runWebGLProgram(r,[a],a.dtype)}},EL=nL({opSnippet:kM+"\n  if (abs(x) > 1.) {\n    return NAN;\n  }\n  return acos(x);\n"}),RL={kernelName:ts,backendName:"webgl",kernelFunc:EL},_L=nL({opSnippet:kM+"\n  if (x < 1.0) return NAN;\nreturn log(x + sqrt(x * x - 1.0));"}),AL={kernelName:ns,backendName:"webgl",kernelFunc:_L},FL="return a + b;",OL=aL({opSnippet:FL,packedOpSnippet:FL,supportsComplex:!0,cpuKernelImpl:yD}),DL={kernelName:as,backendName:"webgl",kernelFunc:OL};class ML{constructor(e,t){this.outputShape=[],this.outputShape=e,this.variableNames=t.map(((e,t)=>"T".concat(t)));const n=[];this.variableNames.forEach((e=>{n.push("float v".concat(e," = get").concat(e,"AtOutCoords();"))}));const a=this.variableNames.map((e=>"v".concat(e))).join(" + ");this.userCode="\n      void main() {\n        ".concat(n.join("\n        "),"\n\n        float result = ").concat(a,";\n        setOutput(result);\n      }\n    ")}}class LL{constructor(e,t){this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.variableNames=t.map(((e,t)=>"T".concat(t)));const n=[];this.variableNames.forEach((e=>{n.push("vec4 v".concat(e," = get").concat(e,"AtOutCoords();"))}));const a=this.variableNames.map((e=>"v".concat(e))).join(" + ");this.userCode="\n      void main() {\n        ".concat(n.join("\n        "),"\n\n        vec4 result = ").concat(a,";\n        setOutput(result);\n      }\n    ")}}const PL={kernelName:rs,backendName:"webgl",kernelFunc:function e(t){const{inputs:n,backend:a}=t,r=n;if(1===r.length)return jM({inputs:{x:r[0]},backend:a});if(r.length>Yo().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER")){const t=Math.floor(r.length/2),n=e({inputs:r.slice(0,t),backend:a}),o=e({inputs:r.slice(t),backend:a});return e({inputs:[n,o],backend:a})}const o=r.map((e=>e.dtype)).reduce(((e,t)=>fu(e,t))),s=r.map((e=>e.shape)),i=Yo().getBool("WEBGL_PACK")?new LL(r[0].shape,s):new ML(r[0].shape,s);return a.runWebGLProgram(i,r,o)}};const zL={kernelName:os,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{axis:o,keepDims:s}=a,i=r.shape.length,c=No(o,r.shape);let l=c;const u=Xp(l,i);let d=r;null!=u&&(d=wL({inputs:{x:r},backend:n,attrs:{perm:u}}),l=Qp(l.length,i)),qp("all",l,i);const[h,p]=jp(d.shape,l),f=dL({inputs:{x:d},backend:n,attrs:{shape:[-1,yo(p)]}}),m=mL(f,f.dtype,"all",n);let g;if(s){g=dL({inputs:{x:m},backend:n,attrs:{shape:Kp(h,c)}})}else g=dL({inputs:{x:m},backend:n,attrs:{shape:h}});return n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),null!=u&&n.disposeIntermediateTensorInfo(d),g}};const BL={kernelName:ss,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{axis:o,keepDims:s}=a,i=r.shape.length,c=No(o,r.shape);let l=c;const u=Xp(l,i);let d=r;null!=u&&(d=wL({inputs:{x:r},backend:n,attrs:{perm:u}}),l=Qp(l.length,i)),qp("any",l,i);const[h,p]=jp(d.shape,l),f=dL({inputs:{x:d},backend:n,attrs:{shape:[-1,yo(p)]}}),m=mL(f,f.dtype,"any",n);let g;if(s){g=dL({inputs:{x:m},backend:n,attrs:{shape:Kp(h,c)}})}else g=dL({inputs:{x:m},backend:n,attrs:{shape:h}});return n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),null!=u&&n.disposeIntermediateTensorInfo(d),g}};class WL{constructor(e,t,n){this.variableNames=["A"];const{windowSize:a,batchSize:r,outSize:o}=e;n||this.variableNames.push("bestIndicesA"),this.outputShape=[r,o];const s="max"===t?">":"<",i=n?"inOffset + i;":"round(getBestIndicesA(batch, inOffset + i));";this.userCode="\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ".concat(a,";\n\n        int bestIndex = inOffset;\n        float bestValue = getA(batch, bestIndex);\n\n        for (int i = 0; i < ").concat(a,"; i++) {\n          int inIdx = ").concat(i,";\n          float candidate = getA(batch, inIdx);\n          if (candidate ").concat(s," bestValue) {\n            bestValue = candidate;\n            bestIndex = inIdx;\n          }\n        }\n        setOutput(float(bestIndex));\n      }\n    ")}}class VL{constructor(e,t,n,a){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,mo(e.length>2,(()=>"Packed arg".concat(n.charAt(0).toUpperCase()+n.slice(1)," supports only inputs with rank above 2.")));const r=e[e.length-1],o=Math.ceil(r/t);this.outputShape=e.slice(0,-1),o>1&&this.outputShape.push(o),a||this.variableNames.push("bestIndicesA");const s=this.outputShape,i=s.length,c=KO(i),l=fM("coords",i);let u,d;if(1===o){d=i+1;const e=KO(d);u="\n        ".concat(e," sourceLocR = ").concat(e,"(").concat(l.join(),", 0);\n        ++").concat(l[i-1],";\n        ").concat(e," sourceLocG = ").concat(e,"(").concat(l.join(),", 0);\n        ++").concat(l[i-2],";\n        ").concat(e," sourceLocA = ").concat(e,"(").concat(l.join(),", 0);\n        --").concat(l[i-1],";\n        ").concat(e," sourceLocB = ").concat(e,"(").concat(l.join(),", 0);\n        --").concat(l[i-2],";")}else d=i,u="\n        ".concat(c," sourceLocR = coords;\n        ++").concat(l[i-1],";\n        ").concat(c," sourceLocG = coords;\n        ++").concat(l[i-2],";\n        ").concat(c," sourceLocA = coords;\n        --").concat(l[i-1],";\n        ").concat(c," sourceLocB = coords;\n        --").concat(l[i-2],";");const h=["x","y","z","w","u","v"].slice(0,d),p="."+h[d-1],f=h.map((e=>"int "+e)),m=fM("sourceLocR",d-1).concat("inIdx.r"),g=fM("sourceLocG",d-1).concat("inIdx.g"),b=fM("sourceLocB",d-1).concat("inIdx.b"),y=fM("sourceLocA",d-1).concat("inIdx.a"),x="max"===n?"greaterThan":"lessThan",v=a?"":"\n          inIdx = round(vec4(getBestIndicesAChannel(".concat(m.join(),"),\n                             getBestIndicesAChannel(").concat(g.join(),"),\n                             getBestIndicesAChannel(").concat(b.join(),"),\n                             getBestIndicesAChannel(").concat(y.join(),")));"),w="vec4(\n            getAChannel(".concat(m.join(),"),\n            hasNextCol ? getAChannel(").concat(g.join(),") : 0.,\n            hasNextRow ? getAChannel(").concat(b.join(),") : 0.,\n            hasNextRow && hasNextCol ? getAChannel(").concat(y.join(),") : 0.)"),k=a?"":"\n      float getBestIndicesAChannel(".concat(f.join(),") {\n        return getChannel(getBestIndicesA(").concat(h.join(),"),\n                                          vec2(").concat(h.slice(-2).join(),"));\n      }");this.userCode="\n      float getAChannel(".concat(f.join(),") {\n        return getChannel(getA(").concat(h.join(),"),\n                               vec2(").concat(h.slice(-2).join(),"));\n      }\n      ").concat(k,"\n      void main() {\n        ").concat(c," coords = getOutputCoords();\n        bool hasNextCol = ").concat(l[i-1]," < ").concat(s[i-1]-1,";\n        bool hasNextRow = ").concat(l[i-2]," < ").concat(s[i-2]-1,";\n        ").concat(u,"\n        ivec4 srcIdx = ivec4(sourceLocR").concat(p,", sourceLocG").concat(p,",\n          sourceLocB").concat(p,", sourceLocA").concat(p,") * ").concat(t,";\n        ivec4 inIdx = srcIdx;\n        vec4 bestIndex = vec4(inIdx);\n        vec4 bestValue = ").concat(w,";\n\n        for (int i = 0; i < ").concat(t,"; i++) {\n          inIdx = srcIdx;\n          ").concat(v,"\n          vec4 candidate = ").concat(w,";\n          bvec4 nan = isnan(candidate);\n          bvec4 replace = bvec4(\n            vec4(").concat(x,"(candidate, bestValue)) * (vec4(1.0) - vec4(nan)));\n\n          bestValue = vec4(replace.x  ? candidate.x : bestValue.x,\n                           replace.y  ? candidate.y : bestValue.y,\n                           replace.z  ? candidate.z : bestValue.z,\n                           replace.w  ? candidate.w : bestValue.w);\n          bestIndex = mix(bestIndex, vec4(inIdx), vec4(replace));\n          srcIdx++;\n        }\n        setOutput(bestIndex);\n      }\n    ")}}function UL(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:null,r=t.shape[0],o=t.shape[1];null!=a&&(r=a.shape[0],o=a.shape[1]);const s=rg(o),i={windowSize:s,inSize:o,batchSize:r,outSize:Math.ceil(o/s)},c=new WL(i,n,null==a),l=[t];null!=a&&l.push(a);const u=e.runWebGLProgram(c,l,"int32");if(1===u.shape[1])return u;const d=UL(e,t,n,u);return e.disposeIntermediateTensorInfo(u),d}function GL(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:null;const r=null!=a?a.shape:t.shape,o=rg(r[r.length-1]),s=new VL(r,o,n,null==a),i=null==a?[t]:[t,a],c=e.runWebGLProgram(s,i,"int32");if(c.shape.length===t.shape.length){const a=GL(e,t,n,c);return e.disposeIntermediateTensorInfo(c),a}return c}function HL(e,t,n,a){const r=[n];if(qp("arg"+a.charAt(0).toUpperCase()+a.slice(1),r,t.shape.length),!Yo().getBool("WEBGL_PACK_REDUCE")||t.shape.length<=2){const n=[],o=e.texData.get(t.dataId);let s=t;null!==o&&o.isPacked&&(s=e.unpackTensor(t),n.push(s));const[i,c]=jp(s.shape,r),l=yo(c),u=dL({inputs:{x:s},backend:e,attrs:{shape:[-1,l]}});n.push(u);const d=UL(e,u,a);n.push(d);const h=dL({inputs:{x:d},backend:e,attrs:{shape:i}});return n.forEach((t=>e.disposeIntermediateTensorInfo(t))),h}return GL(e,t,a)}const jL={kernelName:is,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{axis:o}=a;let s=No(o,r.shape);const i=Xp(s,r.shape.length);let c=r;const l=[];null!=i&&(c=wL({inputs:{x:r},backend:n,attrs:{perm:i}}),l.push(c),s=Qp(s.length,c.shape.length)),qp("argMax",[s[0]],c.shape.length);const u=HL(n,c,s[0],"max");return l.forEach((e=>n.disposeIntermediateTensorInfo(e))),u}};const KL={kernelName:cs,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{axis:o}=a;let s=No(o,r.shape);const i=Xp(s,r.shape.length);let c=r;const l=[];null!=i&&(c=wL({inputs:{x:r},backend:n,attrs:{perm:i}}),l.push(c),s=Qp(s.length,c.shape.length)),qp("argMin",[s[0]],c.shape.length);const u=HL(n,c,s[0],"min");return l.forEach((e=>n.disposeIntermediateTensorInfo(e))),u}},qL=nL({opSnippet:kM+"\n  if (abs(x) > 1.) {\n    return NAN;\n  }\n  return asin(x);\n"}),XL={kernelName:ls,backendName:"webgl",kernelFunc:qL},YL=nL({opSnippet:kM+"return log(x + sqrt(x * x + 1.0));"}),QL={kernelName:us,backendName:"webgl",kernelFunc:YL},JL=nL({opSnippet:kM+"\n  return atan(x);\n"}),ZL={kernelName:ds,backendName:"webgl",kernelFunc:JL},$L=aL({opSnippet:VM+"\n  return atan(a, b);\n",packedOpSnippet:"\n  vec4 result = atan(a, b);\n  bvec4 isNaNA = isnan(a);\n  bvec4 isNaNB = isnan(b);\n  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);\n  "+GM+"\n  return result;\n"}),eP={kernelName:ps,backendName:"webgl",kernelFunc:$L},tP=nL({opSnippet:kM+"\n  if ((x < -1.0) || (x > 1.0)) return NAN;\nreturn (log(1.0 + x) - log(1.0 - x)) / 2.0;"}),nP={kernelName:hs,backendName:"webgl",kernelFunc:tP};class aP{constructor(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]&&arguments[3],r=arguments.length>4&&void 0!==arguments[4]&&arguments[4];if(this.variableNames=["x"],"avg"===t&&n)throw new Error("Cannot compute positions for average pool.");const o=e.filterWidth,s=e.strideHeight,i=e.strideWidth,c=e.dilationHeight,l=e.dilationWidth,u=e.effectiveFilterHeight,d=e.effectiveFilterWidth,h=e.padInfo.top,p=e.padInfo.left;this.outputShape=e.outShape;const f="avg"===t,m="((batch  * ".concat(e.inHeight," + xR) * ").concat(e.inWidth," + xC) * ").concat(e.inChannels," + d"),g="(xR * ".concat(e.inWidth," + xC) * ").concat(e.inChannels," + d");let b="0.0";if(f||(b="-1.0 / 1e-20"),n){const t=">=";return void(this.userCode="\n        const ivec2 strides = ivec2(".concat(s,", ").concat(i,");\n        const ivec2 pads = ivec2(").concat(h,", ").concat(p,");\n\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int batch = coords[0];\n          int d = coords[3];\n\n          ivec2 xRCCorner = coords.yz * strides - pads;\n          int xRCorner = xRCCorner.x;\n          int xCCorner = xRCCorner.y;\n\n          // max/min x(?, ?, d) to get y(yR, yC, d).\n          // ? = to be determined\n          float minMaxValue = 0.0;\n          float minMaxValueFound = 0.0;\n          int minMaxPosition = 0;\n          float avgValue = 0.0;\n\n          for (int wR = 0; wR < ").concat(u,";\n              wR += ").concat(c,") {\n            int xR = xRCorner + wR;\n\n            if (xR < 0 || xR >= ").concat(e.inHeight,") {\n              continue;\n            }\n\n            for (int wC = 0; wC < ").concat(d,";\n                wC += ").concat(l,") {\n              int xC = xCCorner + wC;\n\n              if (xC < 0 || xC >= ").concat(e.inWidth,") {\n                continue;\n              }\n\n              float value = getX(batch, xR, xC, d);\n\n              // If a min / max value has already been found, use it. If not,\n              // use the current value.\n              float currMinMaxValue = mix(\n                  value, minMaxValue, minMaxValueFound);\n              if (value ").concat(t," currMinMaxValue) {\n                minMaxValue = value;\n                minMaxValueFound = 1.0;\n                minMaxPosition = ").concat(a?r?m:g:"wR * ".concat(d," + wC"),";\n              }\n            }\n          }\n          setOutput(float(minMaxPosition));\n        }\n      "))}let y="".concat(t,"(").concat(t,"(").concat(t,"(")+"minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])";"avg"===t&&(y="avgValue / max(count, 1.0)");const x=4*Math.floor(o/4),v=o%4,w="\n      if (".concat(f,") {\n        avgValue += dot(values, ones);\n      } else {\n        minMaxValue = ").concat("max","(values, minMaxValue);\n      }\n    ");this.userCode="\n      const ivec2 strides = ivec2(".concat(s,", ").concat(i,");\n      const ivec2 pads = ivec2(").concat(h,", ").concat(p,");\n      const float initializationValue = ").concat(b,";\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float count = 0.0;\n\n      float getValue(int batch, int xR, int xC, int d) {\n        if (xC < 0 || xC >= ").concat(e.inWidth,") {\n          return initializationValue;\n        }\n        count += 1.0;\n        return getX(batch, xR, xC, d);\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d = coords[3];\n\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // max/min x(?, ?, d) to get y(yR, yC, d).\n        // ? = to be determined\n        vec4 minMaxValue = vec4(").concat(b,");\n        float avgValue = 0.0;\n        count = 0.0;\n\n        for (int wR = 0; wR < ").concat(u,";\n            wR += ").concat(c,") {\n          int xR = xRCorner + wR;\n\n          if (xR < 0 || xR >= ").concat(e.inHeight,") {\n            continue;\n          }\n\n          for (int wC = 0; wC < ").concat(x,"; wC += 4) {\n            int xC = xCCorner + wC * ").concat(l,";\n\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ").concat(l,", d),\n              getValue(batch, xR, xC + 2 * ").concat(l,", d),\n              getValue(batch, xR, xC + 3 * ").concat(l,", d)\n            );\n\n            ").concat(w,"\n          }\n\n          int xC = xCCorner + ").concat(x,";\n          if (").concat(1===v,") {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              initializationValue,\n              initializationValue,\n              initializationValue\n            );\n\n            ").concat(w,"\n          } else if (").concat(2===v,") {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ").concat(l,", d),\n              initializationValue,\n              initializationValue\n            );\n\n            ").concat(w,"\n          } else if (").concat(3===v,") {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ").concat(l,", d),\n              getValue(batch, xR, xC + 2 * ").concat(l,", d),\n              initializationValue\n            );\n\n            ").concat(w,"\n          }\n        }\n        setOutput(").concat(y,");\n      }\n    ")}}class rP{constructor(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]&&arguments[3],r=arguments.length>4&&void 0!==arguments[4]&&arguments[4];if(this.variableNames=["x"],"avg"===t&&n)throw new Error("Cannot compute positions for average pool.");const o=e.filterWidth,s=e.strideDepth,i=e.strideHeight,c=e.strideWidth,l=e.dilationDepth,u=e.dilationHeight,d=e.dilationWidth,h=e.effectiveFilterDepth,p=e.effectiveFilterHeight,f=e.effectiveFilterWidth,m=e.padInfo.front,g=e.padInfo.top,b=e.padInfo.left;this.outputShape=e.outShape;const y="avg"===t;let x="0.0";if(y||(x="-1.0 / 1e-20"),n){const t=">=";return void(this.userCode="\n        const ivec3 strides =\n            ivec3(".concat(s,", ").concat(i,", ").concat(c,");\n        const ivec3 pads = ivec3(").concat(m,", ").concat(g,", ").concat(b,");\n\n        void main() {\n          ivec5 coords = getOutputCoords();\n          int batch = coords.x;\n          int ch = coords.u;\n\n          ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n          int xDCorner = xCorner.x;\n          int xRCorner = xCorner.y;\n          int xCCorner = xCorner.z;\n\n          // max/min x(?, ?, ?, ch) to get y(yD, yR, yC, ch).\n          // ? = to be determined\n          float minMaxValue = 0.0;\n          float minMaxValueFound = 0.0;\n          int minMaxPosition = 0;\n\n          for (int wD = 0; wD < ").concat(h,";\n              wD += ").concat(l,") {\n            int xD = xDCorner + wD;\n\n            if (xD < 0 || xD >= ").concat(e.inDepth,") {\n              continue;\n            }\n\n            for (int wR = 0; wR < ").concat(p,";\n                wR += ").concat(u,") {\n              int xR = xRCorner + wR;\n\n              if (xR < 0 || xR >= ").concat(e.inHeight,") {\n                continue;\n              }\n\n              for (int wC = 0; wC < ").concat(f,";\n                  wC += ").concat(d,") {\n                int xC = xCCorner + wC;\n\n                if (xC < 0 || xC >= ").concat(e.inWidth,") {\n                  continue;\n                }\n\n                float value = getX(batch, xD, xR, xC, ch);\n\n                // If a min / max value has already been found, use it. If not,\n                // use the current value.\n                float currMinMaxValue = mix(\n                    value, minMaxValue, minMaxValueFound);\n                if (value ").concat(t," currMinMaxValue) {\n                  minMaxValue = value;\n                  minMaxValueFound = 1.0;\n                  minMaxPosition = ").concat(a?r?"(((batch * ".concat(e.inDepth," + xD) * ").concat(e.inHeight," + xR) * ").concat(e.inWidth," + xC) * ").concat(e.inChannels," + ch"):"((xD * ".concat(e.inHeight," + xR) * ").concat(e.inWidth," + xC) * ").concat(e.inChannels," + ch"):"wD * ".concat(p," * ").concat(f," +\n                      wR * ").concat(f," + wC"),";\n                }\n              }\n            }\n          }\n          setOutput(float(minMaxPosition));\n        }\n      "))}let v="".concat(t,"(").concat(t,"(").concat(t,"(")+"minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])";"avg"===t&&(v="avgValue / max(count, 1.0)");const w=4*Math.floor(o/4),k=o%4,I="\n      if (".concat(y,") {\n        avgValue += dot(values, ones);\n      } else {\n        minMaxValue = ").concat("max","(values, minMaxValue);\n      }\n    ");this.userCode="\n      const ivec3 strides =\n        ivec3(".concat(s,", ").concat(i,", ").concat(c,");\n      const ivec3 pads = ivec3(").concat(m,", ").concat(g,", ").concat(b,");\n      const float initializationValue = ").concat(x,";\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float count = 0.0;\n\n      float getValue(int batch, int xD, int xR, int xC, int ch) {\n        if (xC < 0 || xC >= ").concat(e.inWidth,") {\n          return initializationValue;\n        }\n        count += 1.0;\n        return getX(batch, xD, xR, xC, ch);\n      }\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n        int xDCorner = xCorner.x;\n        int xRCorner = xCorner.y;\n        int xCCorner = xCorner.z;\n\n        // max/min x(?, ?, ?, d) to get y(yD, yR, yC, ch).\n        // ? = to be determined\n        vec4 minMaxValue = vec4(").concat(x,");\n        float avgValue = 0.0;\n        count = 0.0;\n\n        for (int wD = 0; wD < ").concat(h,";\n            wD += ").concat(l,") {\n          int xD = xDCorner + wD;\n\n          if (xD < 0 || xD >= ").concat(e.inDepth,") {\n            continue;\n          }\n\n          for (int wR = 0; wR < ").concat(p,";\n            wR += ").concat(u,") {\n            int xR = xRCorner + wR;\n\n            if (xR < 0 || xR >= ").concat(e.inHeight,") {\n              continue;\n            }\n\n            for (int wC = 0; wC < ").concat(w,"; wC += 4) {\n              int xC = xCCorner + wC * ").concat(d,";\n\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ").concat(d,", ch),\n                getValue(batch, xD, xR, xC + 2 * ").concat(d,", ch),\n                getValue(batch, xD, xR, xC + 3 * ").concat(d,", ch)\n              );\n\n              ").concat(I,"\n            }\n\n            int xC = xCCorner + ").concat(w,";\n            if (").concat(1===k,") {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                initializationValue,\n                initializationValue,\n                initializationValue\n              );\n\n              ").concat(I,"\n            } else if (").concat(2===k,") {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ").concat(d,", ch),\n                initializationValue,\n                initializationValue\n              );\n\n              ").concat(I,"\n            } else if (").concat(3===k,") {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ").concat(d,", ch),\n                getValue(batch, xD, xR, xC + 2 * ").concat(d,", ch),\n                initializationValue\n              );\n\n              ").concat(I,"\n            }\n          }\n        }\n        setOutput(").concat(v,");\n      }\n    ")}}const oP={kernelName:fs,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t;EO(r,"avgPool");const{filterSize:o,strides:s,pad:i,dimRoundingMode:c}=a;mo(ep(s,1),(()=>"Error in avgPool: Either strides or dilations must be 1. "+"Got strides ".concat(s," and dilations '").concat(1,"'")));const l=Hh(r.shape,o,s,1,i,c);if(1===l.filterWidth&&1===l.filterHeight&&xo(l.inShape,l.outShape))return jM({inputs:{x:r},backend:n});const u=new aP(l,"avg",!1);return n.runWebGLProgram(u,[r],"float32")}};const sP={kernelName:gs,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{filterSize:o,strides:s,pad:i,dimRoundingMode:c,dataFormat:l}=a,u=jh(r.shape,o,s,[1,1,1],i,c,l),d=new rP(u,"avg",!1);return n.runWebGLProgram(d,[r],"float32")}};class iP{constructor(e){this.variableNames=["dy"],this.outputShape=e.inShape;const t=e.filterHeight,n=e.filterWidth,a=e.strideHeight,r=e.strideWidth,o=e.dilationHeight,s=e.dilationWidth,i=e.effectiveFilterHeight,c=e.effectiveFilterWidth,l=i-1-e.padInfo.top,u=c-1-e.padInfo.left,d=1/(t*n);this.userCode="\n      const ivec2 pads = ivec2(".concat(l,", ").concat(u,");\n      const float avgMultiplier = float(").concat(d,");\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n\n        ivec2 dyRCCorner = coords.yz - pads;\n        int dyRCorner = dyRCCorner.x;\n        int dyCCorner = dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ").concat(i,";\n            wR += ").concat(o,") {\n          float dyR = float(dyRCorner + wR) / ").concat(a,".0;\n\n          if (dyR < 0.0 || dyR >= ").concat(e.outHeight,".0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          for (int wC = 0; wC < ").concat(c,";\n            wC+= ").concat(s,") {\n            float dyC = float(dyCCorner + wC) / ").concat(r,".0;\n\n            if (dyC < 0.0 || dyC >= ").concat(e.outWidth,".0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            float dyValue = getDy(b, idyR, idyC, d);\n\n            dotProd += dyValue * avgMultiplier;\n          }\n        }\n        setOutput(dotProd);\n      }\n    ")}}class cP{constructor(e){this.variableNames=["dy"],this.outputShape=e.inShape;const t=e.filterDepth,n=e.filterHeight,a=e.filterWidth,r=e.strideDepth,o=e.strideHeight,s=e.strideWidth,i=e.dilationDepth,c=e.dilationHeight,l=e.dilationWidth,u=e.effectiveFilterDepth,d=e.effectiveFilterHeight,h=e.effectiveFilterWidth,p=u-1-e.padInfo.front,f=d-1-e.padInfo.top,m=h-1-e.padInfo.left,g=1/(t*n*a);this.userCode="\n      const ivec3 pads = ivec3(".concat(p,", ").concat(f,", ").concat(m,");\n      const float avgMultiplier = float(").concat(g,");\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyDCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        // Convolve dy(?, ?, ?, d) with pos mask(:, :, :, ch) to get\n        // dx(xD, xR, xC, ch).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int wD = 0; wD < ").concat(u,";\n            wD += ").concat(i,") {\n          float dyD = float(dyDCorner + wD) / ").concat(r,".0;\n\n          if (dyD < 0.0 || dyD >= ").concat(e.outDepth,".0 || fract(dyD) > 0.0) {\n            continue;\n          }\n          int idyD = int(dyD);\n\n          for (int wR = 0; wR < ").concat(d,";\n              wR += ").concat(c,") {\n            float dyR = float(dyRCorner + wR) / ").concat(o,".0;\n\n            if (dyR < 0.0 || dyR >= ").concat(e.outHeight,".0 ||\n                fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            for (int wC = 0; wC < ").concat(h,";\n                wC += ").concat(l,") {\n              float dyC = float(dyCCorner + wC) / ").concat(s,".0;\n\n              if (dyC < 0.0 || dyC >= ").concat(e.outWidth,".0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              float dyValue = getDy(batch, idyD, idyR, idyC, ch);\n\n              dotProd += dyValue * avgMultiplier;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    ")}}const lP={kernelName:bs,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{dy:r,input:o}=t,s=o,{filterSize:i,strides:c,pad:l,dimRoundingMode:u}=a,d=jh(s.shape,i,c,[1,1,1],l,u),h=new cP(d);return n.runWebGLProgram(h,[r],s.dtype)}};const uP={kernelName:ms,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{dy:r,input:o}=t,s=o;EO([r,o],"avgPoolGrad");const{filterSize:i,strides:c,pad:l}=a,u=Hh(s.shape,i,c,1,l),d=new iP(u);return n.runWebGLProgram(d,[r],s.dtype)}};const dP={kernelName:ys,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{a:r,b:o}=t,{transposeA:s,transposeB:i}=a;return SL({a:r,b:o,transposeA:s,transposeB:i,backend:n})}};class hP{constructor(e,t,n,a,r,o){this.outputShape=[],this.variableNames=["x","mean","variance"],sh(e,t),sh(e,n);let s="0.0";null!=a&&(sh(e,a),this.variableNames.push("offset"),s="getOffsetAtOutCoords()");let i="1.0";null!=r&&(sh(e,r),this.variableNames.push("scale"),i="getScaleAtOutCoords()"),this.outputShape=e,this.userCode="\n      void main() {\n        float x = getXAtOutCoords();\n        float mean = getMeanAtOutCoords();\n        float variance = getVarianceAtOutCoords();\n        float offset = ".concat(s,";\n        float scale = ").concat(i,";\n        float inv = scale * inversesqrt(variance + float(").concat(o,"));\n        setOutput(dot(vec3(x, -mean, offset), vec3(inv, inv, 1)));\n      }\n    ")}}class pP{constructor(e,t,n,a,r,o){this.packedInputs=!0,this.packedOutput=!0,this.variableNames=["x","mean","variance"],sh(e,t),sh(e,n);let s="vec4(0.0)";null!=a&&(sh(e,a),this.variableNames.push("offset"),s="getOffsetAtOutCoords()");let i="vec4(1.0)";null!=r&&(sh(e,r),this.variableNames.push("scale"),i="getScaleAtOutCoords()"),this.outputShape=e,this.userCode="\n      void main() {\n        vec4 offset = ".concat(s,";\n        vec4 scale = ").concat(i,";\n\n        vec4 x = getXAtOutCoords();\n        vec4 mean = getMeanAtOutCoords();\n        vec4 variance = getVarianceAtOutCoords();\n\n        vec4 inv = scale * inversesqrt(variance + vec4(").concat(o,"));\n\n        setOutput((x - mean) * inv + offset);\n      }\n    ")}}const fP={kernelName:ui,backendName:"webgl",kernelFunc:e=>{let{inputs:t,backend:n,attrs:a}=e;const{x:r,mean:o,variance:s,offset:i,scale:c}=t;mo(o.shape.length===s.shape.length,(()=>"Batch normalization gradient requires mean and variance to have equal ranks.")),mo(null==i||o.shape.length===i.shape.length,(()=>"Batch normalization gradient requires mean and offset to have equal ranks.")),mo(null==c||o.shape.length===c.shape.length,(()=>"Batch normalization gradient requires mean and scale to have equal ranks."));let{varianceEpsilon:l}=a;null==l&&(l=.001);const u=[r,o,s];let d=null;null!=i&&(d=i.shape,u.push(i));let h=null;null!=c&&(h=c.shape,u.push(c));const p=Yo().getBool("WEBGL_PACK_NORMALIZATION")?new pP(r.shape,o.shape,s.shape,d,h,l):new hP(r.shape,o.shape,s.shape,d,h,l);return n.runWebGLProgram(p,u,u[0].dtype)}};class mP{constructor(e){this.variableNames=["source"],this.outputShape=e,this.rank=e.length;const t=KO(this.rank);this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];const n=function(e){if(1===e)return"sourceLoc";if(e<=6)return gP.slice(0,e).map((e=>"sourceLoc."+e)).join(",");throw Error("Slicing for rank ".concat(e," is not yet supported"))}(this.rank);let a;const r=e.map(((e,t)=>"sourceLoc.".concat(gP[t]," = start[").concat(t,"] + coords.").concat(gP[t],";")));a="\n        ".concat(t," sourceLoc;\n        ").concat(t," coords = getOutputCoords();\n        ").concat(r.join("\n"),"\n      "),this.userCode="\n      void main() {\n        ".concat(a,"\n        setOutput(getSource(").concat(n,"));\n      }\n    ")}}const gP=["x","y","z","w","u","v"];class bP{constructor(e){this.variableNames=["source"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.rank=e.length,this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];const t=KO(this.rank),n=fM("coords",this.rank),a=fM("sourceLoc",this.rank),r=1===this.rank?"sourceLoc":"vec2(".concat(a.slice(-2).join(),")"),o="getChannel(getSource(".concat(a.join(),"), ").concat(r,")"),s="\n      result.x = ".concat(o,";\n      if (++").concat(n[this.rank-1]," < ").concat(e[this.rank-1],") {\n        ++").concat(a[this.rank-1],";\n        result.y = ").concat(o,";\n        --").concat(a[this.rank-1],";\n      }\n    "),i=1===this.rank?"":"\n      --".concat(n[this.rank-1],";\n      if (++").concat(n[this.rank-2]," < ").concat(e[this.rank-2],") {\n        ++").concat(a[this.rank-2],";\n        result.z = ").concat(o,";\n        if (++").concat(n[this.rank-1]," < ").concat(e[this.rank-1],") {\n          ++").concat(a[this.rank-1],";\n          result.w = ").concat(o,";\n        }\n      }\n    "),c=this.rank<=4?"sourceLoc = coords +\n            ".concat(t,"(").concat(e.map(((e,t)=>"start[".concat(t,"]"))).join(),");"):e.map(((e,t)=>"".concat(a[t]," = ").concat(n[t]," + start[").concat(t,"];"))).join("\n");this.userCode="\n      void main() {\n        ".concat(t," coords = getOutputCoords();\n        ").concat(t," sourceLoc;\n        ").concat(c,"\n        vec4 result = vec4(0.);\n        ").concat(s,"\n        ").concat(i,"\n        setOutput(result);\n      }\n    ")}}function yP(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{begin:o,size:s}=a,[i,c]=Ph(r,o,s);if(Ih(r,i,c),0===yo(c))return n.makeTensorInfo(c,r.dtype,[]);if(n.shouldExecuteOnCPU([r])||"string"===r.dtype){const e=n.texData.get(r.dataId),t=ZD(e.values,i,c,r.shape,r.dtype);return n.makeTensorInfo(c,r.dtype,t)}const{isPacked:l}=n.texData.get(r.dataId),u=Mh(r.shape,i,c);if(l||!u){const e=Yo().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new bP(c):new mP(c),t=[i];return n.runWebGLProgram(e,[r],r.dtype,t)}return n.uploadToGPU(r.dataId),function(e,t,n,a){const r=a.texData.get(e.dataId),o=a.makeTensorInfo(n,e.dtype),s=a.texData.get(o.dataId);Object.assign(s,r),s.refCount=1,s.shape=n,s.dtype=e.dtype;let i=Lh(t,Lo(e.shape));r.slice&&(i+=r.slice.flatOffset),s.slice={flatOffset:i,origDataId:r.slice&&r.slice.origDataId||e.dataId};const c=a.dataRefCount.get(s.slice.origDataId)||1;return a.dataRefCount.set(s.slice.origDataId,c+1),o}(r,i,c,n)}const xP={kernelName:Nc,backendName:"webgl",kernelFunc:yP},vP={kernelName:xs,backendName:"webgl",kernelFunc:e=>{const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{blockShape:o,crops:s}=a;mo(r.shape.length<=4,(()=>"batchToSpaceND for rank > 4 with a WebGL backend not implemented yet"));const i=o.reduce(((e,t)=>e*t)),c=sg(r.shape,o,i),l=ig(c.length,o.length),u=cg(r.shape,o,i),d=lg(s,o.length),h=ug(u,s,o.length),p=[],f=dL({inputs:{x:r},backend:n,attrs:{shape:c}}),m=wL({inputs:{x:f},backend:n,attrs:{perm:l}}),g=dL({inputs:{x:m},backend:n,attrs:{shape:u}}),b=yP({inputs:{x:g},backend:n,attrs:{begin:d,size:h}});return p.push(f),p.push(m),p.push(g),p.forEach((e=>n.disposeIntermediateTensorInfo(e))),b}};const wP={kernelName:vs,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r,weights:o}=t,{size:s}=a,i=n.readSync(r.dataId),c=n.readSync(o.dataId),l=xD(i,c,o.dtype,o.shape,s);return n.makeTensorInfo([s],o.dtype,l)}};const kP={kernelName:ws,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{a:a,b:r}=t,o=Yo().getBool("WEBGL_PACK_BINARY_OPERATIONS"),s=Yo().getNumber("WEBGL_VERSION");if(n.shouldExecuteOnCPU([a,r])||1===s){const e=n.texData.get(a.dataId).values,t=n.texData.get(r.dataId).values,[o,s]=wD(a.shape,r.shape,e,t,a.dtype),i=n.makeTensorInfo(s,a.dtype);return n.texData.get(i.dataId).values=o,i}let i;return i=o?new HM("\n  int r = int(a.r) & int(b.r);\n  int g = int(a.g) & int(b.g);\n  int rb = int(a.b) & int(b.b);\n  int ra = int(a.a) & int(b.a);\n  return vec4(r, g, rb, ra);\n",a.shape,r.shape,!1):new UM("\n  return float(int(a.r) & int(b.r));\n",a.shape,r.shape),n.runWebGLProgram(i,[a,r],a.dtype)}};const IP={kernelName:ks,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{s0:a,s1:r}=t,o=n.readSync(a.dataId),s=n.readSync(r.dataId),i=sh(Array.from(o),Array.from(s));return n.makeTensorInfo([i.length],"int32",Int32Array.from(i))}},SP=aL({opSnippet:"return float(a != b);",cpuKernelImpl:UD,dtype:"bool"}),NP={kernelName:qi,backendName:"webgl",kernelFunc:SP};function CP(e){const{inputs:t,backend:n}=e,{input:a}=t;return jM({inputs:{x:n.texData.get(a.dataId).complexTensorInfos.real},backend:n})}const TP={kernelName:cc,backendName:"webgl",kernelFunc:CP},EP="return float(int(x));";const RP={kernelName:Is,backendName:"webgl",kernelFunc:function e(t){const{inputs:n,backend:a,attrs:r}=t,{x:o}=n,{dtype:s}=r;if("complex64"===s){if("complex64"===o.dtype)return jM({inputs:{x:o},backend:a});const t=uf(o.shape),n=e({inputs:{x:o},backend:a,attrs:{dtype:"float32"}}),r=qM({inputs:{real:n,imag:t},backend:a});return t.dispose(),a.disposeIntermediateTensorInfo(n),r}if("complex64"===o.dtype){const t=CP({inputs:{input:o},backend:a}),n=e({inputs:{x:t},backend:a,attrs:{dtype:s}});return a.disposeIntermediateTensorInfo(t),n}if(!Ro(o.dtype,s)){const e=jM({inputs:{x:o},backend:a});return{dataId:e.dataId,shape:e.shape,dtype:s}}if(a.shouldExecuteOnCPU([o])){const e=a.texData.get(o.dataId).values,[t,n,r]=kD(e,o.shape,o.dtype,s);return a.makeTensorInfo(t,n,r)}if("int32"===s)return function(e,t){const n=new wM(e.shape,EP),a=t.runWebGLProgram(n,[e],"int32");return{dataId:a.dataId,shape:a.shape,dtype:a.dtype}}(o,a);if("bool"===s){const e=a.makeTensorInfo([],"bool",To("bool",1)),t=SP({inputs:{a:o,b:e},backend:a});return a.disposeIntermediateTensorInfo(e),t}throw new Error("Error in Cast: failed to cast ".concat(o.dtype," to ").concat(s))}},_P="return ceil(x);",AP=nL({opSnippet:_P,packedOpSnippet:_P,cpuKernelImpl:ID}),FP={kernelName:Ss,backendName:"webgl",kernelFunc:AP};class OP{constructor(e){this.variableNames=["A"],this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=e,this.userCode="\n\n      void main() {\n        float value = getAAtOutCoords();\n        if (isnan(value)) {\n          setOutput(value);\n          return;\n        }\n\n        setOutput(clamp(value, minVal, maxVal));\n      }\n    "}}class DP{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=e,this.userCode="\n      void main() {\n        vec4 value = getAAtOutCoords();\n\n        if (any(isnan(value))) {\n          setOutput(value);\n          return;\n        }\n\n        setOutput(clamp(value, vec4(minVal), vec4(maxVal)));\n      }\n    "}}const MP={kernelName:Ns,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{clipValueMin:o,clipValueMax:s}=a;let i;i=Yo().getBool("WEBGL_PACK_CLIP")?new DP(r.shape):new OP(r.shape);const c=[[o],[s]];return n.runWebGLProgram(i,[r],r.dtype,c)}};class LP{constructor(e){this.variableNames=["real","imag"],this.outputShape=e,this.userCode="\n      void main() {\n        float re = abs(getRealAtOutCoords());\n        float im = abs(getImagAtOutCoords());\n        float mx = max(re, im);\n\n        // sadly the length function in glsl is not underflow-safe\n        // (at least not on Intel GPUs). So the safe solution is\n        // to ensure underflow-safety in all cases.\n        setOutput(\n          mx == 0.0 ? 0.0 : mx * length(vec2(1, min(re, im)/mx))\n        );\n      }\n    "}}function PP(e,t){return{dataId:t.dataId,dtype:t.dtype,shape:e.shape}}const zP={kernelName:Ts,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{x:a}=t,r=n.texData.get(a.dataId),o=new LP(a.shape),s=[PP(a,r.complexTensorInfos.real),PP(a,r.complexTensorInfos.imag)];return n.runWebGLProgram(o,s,s[0].dtype)}};class BP{constructor(e){this.outputShape=[],this.outputShape=Jm(e,1),this.variableNames=e.map(((e,t)=>"T".concat(t)));const t=new Array(e.length-1);t[0]=e[0][1];for(let o=1;o<t.length;o++)t[o]=t[o-1]+e[o][1];const n=["if (yC < ".concat(t[0],") setOutput(getT0(yR, yC));")];for(let o=1;o<t.length;o++){const e=t[o-1];n.push("else if (yC < ".concat(t[o],") ")+"setOutput(getT".concat(o,"(yR, yC-").concat(e,"));"))}const a=t.length,r=t[t.length-1];n.push("else setOutput(getT".concat(a,"(yR, yC-").concat(r,"));")),this.userCode="\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int yR = coords.x;\n        int yC = coords.y;\n\n        ".concat(n.join("\n        "),"\n      }\n    ")}}class WP{constructor(e,t){this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[],this.outputShape=Jm(e,t);const n=this.outputShape,a=n.length,r=KO(a),o=fM("coords",a),s=["x","y","z","w","u","v"].slice(0,a);this.variableNames=e.map(((e,t)=>"T".concat(t)));const i=new Array(e.length-1);i[0]=e[0][t];for(let f=1;f<i.length;f++)i[f]=i[f-1]+e[f][t];const c=s[t],l=s.slice(-2),u=s.join();let d="if (".concat(c," < ").concat(i[0],") {\n        return getChannel(\n            getT0(").concat(u,"), vec2(").concat(l.join(),"));\n        }");for(let f=1;f<i.length;f++){const e=i[f-1];d+="\n        if (".concat(c," < ").concat(i[f],"  && ").concat(c," >= ").concat(i[f-1],") {\n          return getChannel(\n            getT").concat(f,"(").concat(VP(s,c,e),"),\n            vec2(").concat(VP(l,c,e),"));\n        }")}const h=i.length,p=i[i.length-1];d+="\n        return getChannel(\n          getT".concat(h,"(").concat(VP(s,c,p),"),\n          vec2(").concat(VP(l,c,p),"));"),this.userCode="\n      float getValue(".concat(s.map((e=>"int "+e)),") {\n        ").concat(d,"\n      }\n\n      void main() {\n        ").concat(r," coords = getOutputCoords();\n        vec4 result = vec4(getValue(").concat(o,"), 0., 0., 0.);\n\n        ").concat(o[a-1]," = ").concat(o[a-1]," + 1;\n        if (").concat(o[a-1]," < ").concat(n[a-1],") {\n          result.g = getValue(").concat(o,");\n        }\n\n        ").concat(o[a-2]," = ").concat(o[a-2]," + 1;\n        if (").concat(o[a-2]," < ").concat(n[a-2],") {\n          result.a = getValue(").concat(o,");\n        }\n\n        ").concat(o[a-1]," = ").concat(o[a-1]," - 1;\n        if (").concat(o[a-2]," < ").concat(n[a-2]," &&\n            ").concat(o[a-1]," < ").concat(n[a-1],") {\n          result.b = getValue(").concat(o,");\n        }\n        setOutput(result);\n      }\n    ")}}function VP(e,t,n){const a=e.indexOf(t),r=e.map(((e,t)=>t===a?"".concat(e," - ").concat(n):e));return r.join()}function UP(e){const{inputs:t,backend:n}=e,{input:a}=t;return jM({inputs:{x:n.texData.get(a.dataId).complexTensorInfos.imag},backend:n})}const GP={kernelName:bi,backendName:"webgl",kernelFunc:UP};function HP(e,t,n){const a=e[0].dtype;if("complex64"===a){const a=e.map((e=>CP({inputs:{input:e},backend:n}))),r=e.map((e=>UP({inputs:{input:e},backend:n}))),o=HP(a,t,n),s=HP(r,t,n),i=qM({inputs:{real:o,imag:s},backend:n});return a.forEach((e=>n.disposeIntermediateTensorInfo(e))),r.forEach((e=>n.disposeIntermediateTensorInfo(e))),n.disposeIntermediateTensorInfo(o),n.disposeIntermediateTensorInfo(s),i}let r=n.shouldExecuteOnCPU(e);if("string"===a&&(r=!0),r){const r=e.map((e=>{const a=yo(e.shape.slice(t));return dL({inputs:{x:e},backend:n,attrs:{shape:[-1,a]}})})),o=r.map((e=>({vals:n.readSync(e.dataId),shape:e.shape}))),s=Jm(r.map((e=>e.shape)),1),i=1===r[0].shape[0],c=SD(o,s,a,i),l=Jm(e.map((e=>e.shape)),t),u=n.makeTensorInfo(l,a,c);return r.forEach((e=>n.disposeIntermediateTensorInfo(e))),u}const o=e.filter((e=>yo(e.shape)>0)),s=Yo().getBool("WEBGL_PACK_ARRAY_OPERATIONS")&&o[0].shape.length>1;if(1===o.length){const t=s?new wM(e[0].shape,EM):new MM(e[0].shape,EM);return n.runWebGLProgram(t,e,a)}const i=Yo().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER");if(o.length>i){const e=[];for(let r=0;r<o.length;r+=i){const a=o.slice(r,r+i);e.push(HP(a,t,n))}const a=HP(e,t,n);for(const t of e)n.disposeIntermediateTensorInfo(t);return a}if(s){const e=new WP(o.map((e=>e.shape)),t);return n.runWebGLProgram(e,o,a)}const{tensors2D:c,outShape:l}=function(e,t,n){const a=Jm(e.map((e=>e.shape)),t),r=e.map((e=>dL({inputs:{x:e},attrs:{shape:[-1,yo(e.shape.slice(t))]},backend:n})));return{tensors2D:r,outShape:a}}(o,t,n),u=new BP(c.map((e=>e.shape))),d=n.runWebGLProgram(u,c,a);c.forEach((e=>n.disposeIntermediateTensorInfo(e)));const h=dL({inputs:{x:d},attrs:{shape:l},backend:n});return n.disposeIntermediateTensorInfo(d),h}function jP(e){const{inputs:t,backend:n,attrs:a}=e,{axis:r}=a,o=No(r,t[0].shape)[0],s=t.map((e=>e.shape));Qm(s,o);const i=Jm(t.map((e=>e.shape)),o);if(0===yo(i))return n.makeTensorInfo(i,t[0].dtype,[]);const c=t.filter((e=>yo(e.shape)>0));return 1===c.length?jM({inputs:{x:c[0]},backend:n}):HP(c,o,n)}const KP={kernelName:Es,backendName:"webgl",kernelFunc:jP};class qP{constructor(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1],n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null,a=arguments.length>3&&void 0!==arguments[3]&&arguments[3],r=arguments.length>4&&void 0!==arguments[4]&&arguments[4];this.variableNames=["x","W"],this.outputShape=e.outShape;const o=e.padInfo.top,s=e.padInfo.left,i=e.strideHeight,c=e.strideWidth,l=e.dilationHeight,u=e.dilationWidth,d=e.filterHeight,h=e.filterWidth,p=4*Math.floor(e.inChannels/4),f=e.inChannels%4,m="channelsLast"===e.dataFormat,g=m?1:2,b=m?2:3,y=m?3:1;let x="",v="";n&&(x=a?"float activation(float a) {\n          float b = getPreluActivationWeightsAtOutCoords();\n          ".concat(n,"\n        }"):r?"float activation(float a) {\n          float b = getLeakyreluAlphaAtOutCoords();\n          ".concat(n,"\n        }"):"\n          float activation(float x) {\n            ".concat(n,"\n          }\n        "),v="result = activation(result);");const w=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),a&&this.variableNames.push("preluActivationWeights"),r&&this.variableNames.push("leakyreluAlpha"),this.userCode="\n      ".concat(x,"\n\n      const ivec2 strides = ivec2(").concat(i,", ").concat(c,");\n      const ivec2 pads = ivec2(").concat(o,", ").concat(s,");\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d2 = coords[").concat(y,"];\n\n        ivec2 xRCCorner =\n            ivec2(coords[").concat(g,"], coords[").concat(b,"]) * strides - pads;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // Convolve x(?, ?, d1) with w(:, :, d1, d2) to get y(yR, yC, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ").concat(d,"; wR++) {\n          int xR = xRCorner + wR * ").concat(l,";\n\n          if (xR < 0 || xR >= ").concat(e.inHeight,") {\n            continue;\n          }\n\n          for (int wC = 0; wC < ").concat(h,"; wC++) {\n            int xC = xCCorner + wC * ").concat(u,";\n\n            if (xC < 0 || xC >= ").concat(e.inWidth,") {\n              continue;\n            }\n\n            for (int d1 = 0; d1 < ").concat(p,"; d1 += 4) {\n              vec4 wValues = vec4(\n                getW(wR, wC, d1, d2),\n                getW(wR, wC, d1 + 1, d2),\n                getW(wR, wC, d1 + 2, d2),\n                getW(wR, wC, d1 + 3, d2)\n              );\n\n              if (").concat(m,") {\n                vec4 xValues = vec4(\n                  getX(batch, xR, xC, d1),\n                  getX(batch, xR, xC, d1 + 1),\n                  getX(batch, xR, xC, d1 + 2),\n                  getX(batch, xR, xC, d1 + 3)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec4 xValues = vec4(\n                  getX(batch, d1, xR, xC),\n                  getX(batch, d1 + 1, xR, xC),\n                  getX(batch, d1 + 2, xR, xC),\n                  getX(batch, d1 + 3, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n            }\n\n            if (").concat(1===f,") {\n\n              if (").concat(m,") {\n                dotProd +=\n                    getX(batch, xR, xC, ").concat(p,") *\n                    getW(wR, wC, ").concat(p,", d2);\n              } else {\n                dotProd +=\n                    getX(batch, ").concat(p,", xR, xC) *\n                    getW(wR, wC, ").concat(p,", d2);\n              }\n\n            } else if (").concat(2===f,") {\n              vec2 wValues = vec2(\n                getW(wR, wC, ").concat(p,", d2),\n                getW(wR, wC, ").concat(p," + 1, d2)\n              );\n\n              if (").concat(m,") {\n                vec2 xValues = vec2(\n                  getX(batch, xR, xC, ").concat(p,"),\n                  getX(batch, xR, xC, ").concat(p," + 1)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec2 xValues = vec2(\n                  getX(batch, ").concat(p,", xR, xC),\n                  getX(batch, ").concat(p," + 1, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n\n            } else if (").concat(3===f,") {\n              vec3 wValues = vec3(\n                getW(wR, wC, ").concat(p,", d2),\n                getW(wR, wC, ").concat(p," + 1, d2),\n                getW(wR, wC, ").concat(p," + 2, d2)\n              );\n\n              if (").concat(m,") {\n                vec3 xValues = vec3(\n                  getX(batch, xR, xC, ").concat(p,"),\n                  getX(batch, xR, xC, ").concat(p," + 1),\n                  getX(batch, xR, xC, ").concat(p," + 2)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec3 xValues = vec3(\n                  getX(batch, ").concat(p,", xR, xC),\n                  getX(batch, ").concat(p," + 1, xR, xC),\n                  getX(batch, ").concat(p," + 2, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n\n            }\n          }\n        }\n\n        float result = dotProd;\n        ").concat(w,"\n        ").concat(v,"\n        setOutput(result);\n      }\n    ")}}class XP{constructor(e){this.variableNames=["x","W"],this.outputShape=e.outShape;const t=e.padInfo.front,n=e.padInfo.top,a=e.padInfo.left,r=e.strideDepth,o=e.strideHeight,s=e.strideWidth,i=e.dilationDepth,c=e.dilationHeight,l=e.dilationWidth,u=e.filterDepth,d=e.filterHeight,h=e.filterWidth,p=4*Math.floor(e.inChannels/4),f=e.inChannels%4;this.userCode="\n      const ivec3 strides = ivec3(".concat(r,", ").concat(o,", ").concat(s,");\n      const ivec3 pads = ivec3(").concat(t,", ").concat(n,", ").concat(a,");\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int d2 = coords.u;\n\n        ivec3 xFRCCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n        int xFCorner = xFRCCorner.x;\n        int xRCorner = xFRCCorner.y;\n        int xCCorner = xFRCCorner.z;\n\n        // Convolve x(?, ?, ?, d1) with w(:, :, :, d1, d2) to get\n        // y(yF, yR, yC, d2). ? = to be determined. : = across all\n        // values in that axis.\n        float dotProd = 0.0;\n        for (int wF = 0; wF < ").concat(u,"; wF++) {\n          int xF = xFCorner + wF * ").concat(i,";\n\n          if (xF < 0 || xF >= ").concat(e.inDepth,") {\n            continue;\n          }\n\n          for (int wR = 0; wR < ").concat(d,"; wR++) {\n            int xR = xRCorner + wR * ").concat(c,";\n\n            if (xR < 0 || xR >= ").concat(e.inHeight,") {\n              continue;\n            }\n\n            for (int wC = 0; wC < ").concat(h,"; wC++) {\n              int xC = xCCorner + wC * ").concat(l,";\n\n              if (xC < 0 || xC >= ").concat(e.inWidth,") {\n                continue;\n              }\n\n              for (int d1 = 0; d1 < ").concat(p,"; d1 += 4) {\n                vec4 xValues = vec4(\n                  getX(batch, xF, xR, xC, d1),\n                  getX(batch, xF, xR, xC, d1 + 1),\n                  getX(batch, xF, xR, xC, d1 + 2),\n                  getX(batch, xF, xR, xC, d1 + 3)\n                );\n                vec4 wValues = vec4(\n                  getW(wF, wR, wC, d1, d2),\n                  getW(wF, wR, wC, d1 + 1, d2),\n                  getW(wF, wR, wC, d1 + 2, d2),\n                  getW(wF, wR, wC, d1 + 3, d2)\n                );\n\n                dotProd += dot(xValues, wValues);\n              }\n\n              if (").concat(1===f,") {\n                dotProd +=\n                  getX(batch, xF, xR, xC, ").concat(p,") *\n                  getW(wF, wR, wC, ").concat(p,", d2);\n              } else if (").concat(2===f,") {\n                vec2 xValues = vec2(\n                  getX(batch, xF, xR, xC, ").concat(p,"),\n                  getX(batch, xF, xR, xC, ").concat(p," + 1)\n                );\n                vec2 wValues = vec2(\n                  getW(wF, wR, wC, ").concat(p,", d2),\n                  getW(wF, wR, wC, ").concat(p," + 1, d2)\n                );\n                dotProd += dot(xValues, wValues);\n              } else if (").concat(3===f,") {\n                vec3 xValues = vec3(\n                  getX(batch, xF, xR, xC, ").concat(p,"),\n                  getX(batch, xF, xR, xC, ").concat(p," + 1),\n                  getX(batch, xF, xR, xC, ").concat(p," + 2)\n                );\n                vec3 wValues = vec3(\n                  getW(wF, wR, wC, ").concat(p,", d2),\n                  getW(wF, wR, wC, ").concat(p," + 1, d2),\n                  getW(wF, wR, wC, ").concat(p," + 2, d2)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    ")}}class YP{constructor(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1],n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null,a=arguments.length>3&&void 0!==arguments[3]&&arguments[3],r=arguments.length>4&&void 0!==arguments[4]&&arguments[4];this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=$O(this.outputShape.length);const o=e.padInfo.left,s=e.strideWidth,i=e.dilationWidth,c=e.filterHeight,l=e.filterWidth,u=l;let d="\n       int xR; int xC; int xCOffset;\n       vec4 wTexel; vec4 previous; vec4 final;";for(let m=0;m<l;m++)d+="\n           vec4 xTexelC".concat(2*m,";\n           int xTexelC").concat(2*m,"Ready;\n           vec4 xTexelC").concat(2*m+1,";\n           int xTexelC").concat(2*m+1,"Ready;\n           vec4 xC").concat(m,";");d+="\n     for (int r = 0; r < ".concat(c,"; r++) {\n      for (int d1 = 0; d1 < ").concat(e.inChannels,"; d1 += 2) {\n       ");for(let m=0;m<l;m++)d+="\n           xTexelC".concat(2*m," = vec4(0.0);\n           xTexelC").concat(2*m,"Ready = 0;\n           xTexelC").concat(2*m+1," = vec4(0.0);\n           xTexelC").concat(2*m+1,"Ready = 0;\n           xC").concat(m," = vec4(0.0);");d+="\n         xR = xRCorner + r * dilations[0];\n         if (xR >=0 && xR < inDims[0]) {\n       ";for(let m=0;m<(u+1)/2;m++){const t=2*m;if(d+="\n           xC = xCCorner + ".concat(t*i,";\n           "),1===s){if(t<l&&(o%2===1?(d+="\n                 xCOffset = xC + 1;\n                 if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC".concat(t,"Ready == 0) {\n                   xTexelC").concat(t," = getX(batch, xR, xCOffset, d1);\n\n                   // Need to manually clear unused channels in case\n                   // we're reading from recycled texture.\n                   if (xCOffset + 1 >= inDims[1]) {\n                     xTexelC").concat(t,".zw = vec2(0.0);\n                   }\n                   xTexelC").concat(t,"Ready = 1;\n                 }\n               "),d+=1===i&&t>0?"\n                 xC".concat(t," = vec4(xTexelC").concat(t-2,".zw, xTexelC").concat(t,".xy);\n                 "):"\n                   xCOffset = xC + 1 - 2;\n\n                   if (xCOffset >= 0 && xCOffset < inDims[1]) {\n                     previous = getX(batch, xR, xCOffset, d1);\n\n                     // Need to manually clear unused channels in case\n                     // we're reading from recycled texture.\n                     if (xCOffset + 1 >= inDims[1]) {\n                       previous.zw = vec2(0.0);\n                     }\n\n                     xC".concat(t," = vec4(previous.zw, xTexelC").concat(t,".xy);\n                   } else {\n                     xC").concat(t," = vec4(0.0, 0.0, xTexelC").concat(t,".xy);\n                   }\n                   ")):d+="\n                 if (xC >= 0 && xC < inDims[1] && xTexelC".concat(t,"Ready == 0) {\n                   xTexelC").concat(t," = getX(batch, xR, xC, d1);\n                   if (xC + 1 >= inDims[1]) {\n                     xTexelC").concat(t,".zw = vec2(0.0);\n                   }\n                   xTexelC").concat(t,"Ready = 1;\n                 }\n\n                 xC").concat(t," = xTexelC").concat(t,";\n                 "),t+1<l)){const e=o%2===0?po(i):i;i%2===0&&o%2===1||i%2!==0&&o%2!==1?(d+="\n                   xCOffset = xC + imod(pads[1], 2) + ".concat(e,";\n\n                   if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC").concat(t+1,"Ready == 0) {\n                     xTexelC").concat(t+1," = getX(batch, xR, xCOffset, d1);\n\n                     // Need to manually clear unused channels in case\n                     // we're reading from recycled texture.\n                     if (xCOffset + 1 >= inDims[1]) {\n                       xTexelC").concat(t+1,".zw = vec2(0.0);\n                     }\n                     xTexelC").concat(t+1,"Ready = 1;\n                   }\n                   "),d+=i>1?"\n                     xCOffset -= 2;\n                     if (xCOffset >= 0 && xCOffset < inDims[1]) {\n                      previous = getX(batch, xR, xCOffset, d1);\n                      xC".concat(t+1," = vec4(previous.zw, xTexelC").concat(t+1,".xy);\n                     } else {\n                      xC").concat(t+1," = vec4(0.0, 0.0, xTexelC").concat(t+1,".xy);\n                     }\n                     "):"\n                     xC".concat(t+1," = vec4(xTexelC").concat(t,".zw, xTexelC").concat(t+1,".xy);\n                     ")):d+=1===e?"\n                     xC".concat(t+1," = xTexelC").concat(t,";\n                     "):"\n                     xCOffset = xC + ".concat(e,";\n\n                     if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC").concat(t+1,"Ready == 0) {\n                       xTexelC").concat(t+1," = getX(batch, xR, xCOffset, d1);\n                       if (xCOffset + 1 >= inDims[1]) {\n                         xTexelC").concat(t+1,".zw = vec2(0.0);\n                       }\n                       xTexelC").concat(t+1,"Ready = 1;\n                     }\n\n                     xC").concat(t+1," = xTexelC").concat(t+1,";\n                     ")}}else t<l&&(o%2===1?(d+="\n                 xCOffset = xC + 1 - strides[1];\n                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC".concat(t,"Ready == 0) {\n                   xTexelC").concat(t," = getX(batch, xR, xCOffset, d1);\n                   // Need to manually clear unused channels in case\n                   // we're reading from recycled texture.\n                   if (xCOffset + 1 >= inDims[1]) {\n                     xTexelC").concat(t,".zw = vec2(0.0);\n                   }\n                   xTexelC").concat(t,"Ready = 1;\n                 }\n\n                 if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC").concat(t+1,"Ready == 0) {\n                   xTexelC").concat(t+1," = getX(batch, xR, xC + 1, d1);\n                   // Need to manually clear unused channels in case\n                   // we're reading from recycled texture.\n                   if (xC + 2 >= inDims[1]) {\n                     xTexelC").concat(t+1,".zw = vec2(0.0);\n                   }\n                   xTexelC").concat(t+1,"Ready = 1;\n                 }\n\n                 xC").concat(t," = vec4(xTexelC").concat(t,".zw, xTexelC").concat(t+1,".zw);\n               "),t+1<l&&(d+="\n                   final = vec4(0.0);\n                   xCOffset = xC + 1 + strides[1];\n                   if(xCOffset >= 0 && xCOffset < inDims[1]) {\n                     final = getX(batch, xR, xCOffset, d1);\n                   }\n                   xC".concat(t+1," = vec4(xTexelC").concat(t+1,".xy, final.xy);\n                 "))):(d+="\n                 if(xC >= 0 && xC < inDims[1] && xTexelC".concat(t,"Ready == 0) {\n                   xTexelC").concat(t," = getX(batch, xR, xC, d1);\n                   if (xC + 1 >= inDims[1]) {\n                     xTexelC").concat(t,".zw = vec2(0.0);\n                   }\n                   xTexelC").concat(t,"Ready = 1;\n                 }\n\n                 xCOffset = xC + strides[1];\n                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC").concat(t+1,"Ready == 0) {\n                   xTexelC").concat(t+1," = getX(batch, xR, xCOffset, d1);\n                   if (xCOffset + 1 >= inDims[1]) {\n                     xTexelC").concat(t+1,".zw = vec2(0.);\n                   }\n                   xTexelC").concat(t+1,"Ready = 1;\n                 }\n\n                 xC").concat(t," = vec4(\n                   xTexelC").concat(t,".xy, xTexelC").concat(t+1,".xy);\n               "),t+1<l&&(d+="\n                   xC".concat(t+1," = vec4(xTexelC").concat(t,".zw, xTexelC").concat(t+1,".zw);\n                 "))));t<l&&(d+="\n             wTexel = getW(r, ".concat(t,", d1, d2);\n             dotProd += xC").concat(t,".xxzz * vec4(wTexel.xy, wTexel.xy);\n             if(d1 + 1 < ").concat(e.inChannels,") {\n               dotProd += xC").concat(t,".yyww * vec4(wTexel.zw, wTexel.zw);\n             }\n           "),t+1<l&&(d+="\n               wTexel = getW(r, ".concat(t+1,", d1, d2);\n               dotProd += xC").concat(t+1,".xxzz * vec4(wTexel.xy, wTexel.xy);\n               if(d1 + 1 < ").concat(e.inChannels,") {\n                 dotProd += xC").concat(t+1,".yyww * vec4(wTexel.zw, wTexel.zw);\n               }\n             ")))}d+="\n     }\n   ",d+="\n     }\n   ",d+="\n     }\n   ";let h="",p="";n&&(h=a?"vec4 activation(vec4 a) {\n           vec4 b = getPreluActivationWeightsAtOutCoords();\n           ".concat(n,"\n         }"):r?"vec4 activation(vec4 a) {\n           vec4 b = getLeakyreluAlphaAtOutCoords();\n           ".concat(n,"\n         }"):"vec4 activation(vec4 x) {\n           ".concat(n,"\n         }"),p="result = activation(result);");const f=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),a&&this.variableNames.push("preluActivationWeights"),r&&this.variableNames.push("leakyreluAlpha"),this.userCode="\n       ".concat(h,"\n\n       void main() {\n         ivec4 coords = getOutputCoords();\n         int batch = coords.x;\n         ivec2 xRCCorner = coords.yz * strides - pads;\n         int d2 = coords.w;\n         int xRCorner = xRCCorner.x;\n         int xCCorner = xRCCorner.y;\n\n         //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.\n         vec4 dotProd = vec4(0.000000000000001);\n\n         ").concat(d,"\n\n         vec4 result = dotProd - vec4(0.000000000000001);\n         ").concat(f,"\n         ").concat(p,"\n         setOutput(result);\n       }\n     ")}}class QP{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec4"},{name:"pad",type:"ivec2"},{name:"stride",type:"ivec2"},{name:"dilation",type:"ivec2"},{name:"inChannels",type:"int"},{name:"itemsPerBlockRow",type:"int"},{name:"outWidth",type:"int"}],this.outputShape=e,this.enableShapeUniforms=$O(this.outputShape.length);const{dataFormat:n}=t,a=_O(),r="channelsLast"===n,o=r?1:2,s=r?2:3,i=this.enableShapeUniforms?"if(blockIndex < outShape[2] && pos < outShape[1]) {":"if(blockIndex < ".concat(e[2]," && pos < ").concat(e[1],") {");let c="";for(let l=0;l<=1;l++)for(let e=0;e<=1;e++)c+="\n          blockIndex = rc.z + ".concat(e,";\n          pos = rc.y + ").concat(l,";\n\n          ").concat(i,"\n            offsetY = int(blockIndex / outWidth) * stride[0] - pad[0];\n            d0 = offsetY + dilation[0] * (pos / itemsPerBlockRow);\n\n            if(d0 < inputShape[").concat(o,"] && d0 >= 0) {\n              // Use custom imod instead mod. On Intel GPU, mod may generate\n              // unexpected value.\n              // https://github.com/tensorflow/tfjs/issues/5447\n              offsetX = imod(blockIndex, outWidth) * stride[1] - pad[1];\n              d1 = offsetX + dilation[1] * (imod(pos, itemsPerBlockRow) /\n                  inChannels);\n\n              if(d1 < inputShape[").concat(s,"] && d1 >= 0) {\n\n                ch = imod(pos, inChannels);\n\n                if (").concat(r,") {\n                  innerDims = vec2(d1, ch);\n                  result[").concat(2*l+e,"] = getChannel(\n                    getA(rc.x, d0, int(innerDims.x),\n                    int(innerDims.y)), innerDims);\n                } else {\n                  innerDims = vec2(d0, d1);\n                  result[").concat(2*l+e,"] = getChannel(\n                    getA(rc.x, ch, int(innerDims.x),\n                    int(innerDims.y)), innerDims);\n                }\n              }\n            }\n          }\n        ");this.userCode="\n      void main() {\n        ivec3 rc = getOutputCoords();\n\n        vec4 result = vec4(0);\n\n        int blockIndex, pos, offsetY, d0, offsetX, d1, ch;\n        vec2 innerDims;\n\n        ".concat(c,"\n\n        ").concat(a.output," = result;\n      }\n    ")}}function JP(e,t){const n=e.length;return n>=3?t?[...e.slice(0,-3),e[n-3]*e[n-2],e[n-1]]:[...e.slice(0,-3),e[n-3],e[n-2]*e[n-1]]:!t&&1===n&&e[0]>1?[e[0],1]:null}function ZP(e){let{x:t,filter:n,convInfo:a,backend:r,bias:o=null,preluActivationWeights:s=null,leakyreluAlpha:i=0,activation:c=null}=e;const l=t.shape,u=r.texData.get(t.dataId),d=a.inChannels,h=l[0]*l[1]*l[2],p=a.outChannels,f="channelsLast"===a.dataFormat,m=!1;let g;const b=[];if(null!=s){const e=JP(s.shape,f);null!=e&&(s=dL({inputs:{x:s},backend:r,attrs:{shape:e}}),b.push(s))}if(null!=o){const e=JP(o.shape,f);null!=e&&(o=dL({inputs:{x:o},backend:r,attrs:{shape:e}}),b.push(o))}if(!((1===h||1===p)&&d>IL)&&u.isPacked&&f&&null!=u.texture&&l[2]%2!==0&&xo(u.shape.slice(-3),l.slice(-3))){const e=l[0]*l[1]*(l[2]+1),d={dataId:t.dataId,shape:[1,e,a.inChannels],dtype:t.dtype},h=u.shape;u.shape=u.shape.slice(),u.shape[u.shape.length-2]++,mo(wO(u.shape,d.shape),(()=>"packed reshape ".concat(u.shape," to ").concat(d.shape," isn't free")));const p=dL({inputs:{x:n},backend:r,attrs:{shape:[1,a.inChannels,a.outChannels]}});b.push(p);const f=SL({a:d,b:p,backend:r,transposeA:false,transposeB:m,bias:o,activation:c,preluActivationWeights:s,leakyreluAlpha:i}),y=r.texData.get(f.dataId);mo(y.isPacked,(()=>"batchMatMul result is expected to be packed")),u.shape=h,y.shape=a.outShape,g=jM({inputs:{x:f},backend:r}),g.shape=a.outShape,b.push(f)}else{const e=a.outHeight*a.outWidth,l=dL({inputs:{x:t},backend:r,attrs:{shape:f?[a.batchSize,e,a.inChannels]:[a.batchSize,a.inChannels,e]}}),u=dL({inputs:{x:n},backend:r,attrs:{shape:[1,a.inChannels,a.outChannels]}}),d=SL({a:f?l:u,b:f?u:l,transposeA:!f,transposeB:m,backend:r,bias:o,activation:c,preluActivationWeights:s,leakyreluAlpha:i});g=dL({inputs:{x:d},backend:r,attrs:{shape:a.outShape}}),b.push(l),b.push(u),b.push(d)}for(const y of b)r.disposeIntermediateTensorInfo(y);return g}function $P(e){let{x:t,filter:n,convInfo:a,backend:r,bias:o=null,preluActivationWeights:s=null,leakyreluAlpha:i=0,activation:c=null}=e;const{filterWidth:l,filterHeight:u,inChannels:d,outWidth:h,outHeight:p,dataFormat:f}=a,m="channelsLast"===f,g=l*u*d,b=p*h,y=[a.batchSize,g,b],x=[];if(null!=s){const e=JP(s.shape,m);null!=e&&(s=dL({inputs:{x:s},backend:r,attrs:{shape:e}}),x.push(s))}if(null!=o){const e=JP(o.shape,m);null!=e&&(o=dL({inputs:{x:o},backend:r,attrs:{shape:e}}),x.push(o))}const v=dL({inputs:{x:n},backend:r,attrs:{shape:[1,g,yo(n.shape)/g]}});x.push(v);const w=new QP(y,a),k=[t.shape,[a.padInfo.top,a.padInfo.left],[a.strideHeight,a.strideWidth],[a.dilationHeight,a.dilationWidth],[a.inChannels],[a.filterWidth*a.inChannels],[a.outWidth]],I=r.runWebGLProgram(w,[t],"float32",k),S=dL({inputs:{x:I},backend:r,attrs:{shape:y}});x.push(I),x.push(S);const N=null!=o,C=null!=s,T="leakyrelu"===c,E=c?rL(c,!0):null,R=new oL(m?S.shape:v.shape,m?v.shape:S.shape,m?[a.batchSize,b,a.outChannels]:[a.batchSize,a.outChannels,b],!0,!1,N,E,C,T),_=m?[S,v]:[v,S];if(o&&_.push(o),C&&_.push(s),T){const e=r.makeTensorInfo([],"float32",Pl(i,"float32"));_.push(e),x.push(e)}const A=r.runWebGLProgram(R,_,"float32"),F=dL({inputs:{x:A},backend:r,attrs:{shape:a.outShape}});x.push(A);for(const O of x)r.disposeIntermediateTensorInfo(O);return F}const ez={kernelName:Rs,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r,filter:o}=t,{strides:s,pad:i,dataFormat:c,dilations:l,dimRoundingMode:u}=a,d=np(c),h=Kh(r.shape,o.shape,s,l,i,u,!1,d);let p;if(1!==h.filterHeight||1!==h.filterWidth||1!==h.dilationHeight||1!==h.dilationWidth||1!==h.strideHeight||1!==h.strideWidth||"SAME"!==h.padInfo.type&&"VALID"!==h.padInfo.type)if(h.strideWidth<=2&&"channelsLast"===d&&Yo().getBool("WEBGL_EXP_CONV")){const e=new YP(h),t=[[h.padInfo.top,h.padInfo.left],[h.strideHeight,h.strideWidth],[h.dilationHeight,h.dilationWidth],[h.inHeight,h.inWidth]];p=n.runWebGLProgram(e,[r,o],"float32",t)}else if(Yo().getBool("WEBGL_CONV_IM2COL"))p=$P({x:r,filter:o,convInfo:h,backend:n});else{const e=new qP(h);p=n.runWebGLProgram(e,[r,o],"float32")}else p=ZP({x:r,filter:o,convInfo:h,backend:n});const f=dL({inputs:{x:p},backend:n,attrs:{shape:h.outShape}});return n.disposeIntermediateTensorInfo(p),f}};class tz{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;const t=e.strideHeight,n=e.strideWidth,a=e.padInfo.top,r=e.padInfo.left,o="channelsLast"===e.dataFormat;this.userCode="\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int wR = coords.x;\n        int wC = coords.y;\n        int d1 = coords.z;\n        int d2 = coords.w;\n\n        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int b = 0; b < ".concat(e.batchSize,"; b++) {\n          for (int yR = 0; yR < ").concat(e.outHeight,"; yR++) {\n            int xR = wR + yR * ").concat(t," - ").concat(a,";\n\n            if (xR < 0 || xR >= ").concat(e.inHeight,") {\n              continue;\n            }\n\n            for (int yC = 0; yC < ").concat(e.outWidth,"; yC++) {\n              int xC = wC + yC * ").concat(n," - ").concat(r,";\n\n              if (xC < 0 || xC >= ").concat(e.inWidth,") {\n                continue;\n              }\n\n              ").concat(o?"float dyValue = getDy(b, yR, yC, d2);\n              float xValue = getX(b, xR, xC, d1);\n              dotProd += (xValue * dyValue);":"float dyValue = getDy(b, d2, yR, yC);\n              float xValue = getX(b, d1, xR, xC);\n              dotProd += (xValue * dyValue);","\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    ")}}class nz{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;const t=e.filterHeight,n=e.filterWidth,a=e.strideHeight,r=e.strideWidth,o="channelsLast"===e.dataFormat,s=t-1-e.padInfo.top,i=n-1-e.padInfo.left,c=o?1:2,l=o?2:3,u=o?3:1;this.userCode="\n      const ivec2 pads = ivec2(".concat(s,", ").concat(i,");\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[").concat(u,"];\n\n        ivec2 dyCorner = ivec2(coords[").concat(c,"], coords[").concat(l,"]) - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ").concat(t,"; wR++) {\n          float dyR = float(dyRCorner + wR) / ").concat(a,".0;\n\n          if (dyR < 0.0 || dyR >= ").concat(e.outHeight,".0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          int wRPerm = ").concat(t," - 1 - wR;\n\n          for (int wC = 0; wC < ").concat(n,"; wC++) {\n            float dyC = float(dyCCorner + wC) / ").concat(r,".0;\n\n            if (dyC < 0.0 || dyC >= ").concat(e.outWidth,".0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            int wCPerm = ").concat(n," - 1 - wC;\n\n            for (int d2 = 0; d2 < ").concat(e.outChannels,"; d2++) {\n\n              if (").concat(o,") {\n                float xValue = getDy(batch, idyR, idyC, d2);\n                float wValue = getW(wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              } else {\n                float xValue = getDy(batch, d2, idyR, idyC);\n                float wValue = getW(wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              }\n\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    ")}}class az{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;const t=e.strideDepth,n=e.strideHeight,a=e.strideWidth,r=e.padInfo.front,o=e.padInfo.top,s=e.padInfo.left;this.userCode="\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int wF = coords.x;\n        int wR = coords.y;\n        int wC = coords.z;\n        int d1 = coords.w;\n        int d2 = coords.u;\n\n        float dotProd = 0.0;\n\n        for (int b = 0; b < ".concat(e.batchSize,"; b++) {\n          for (int yF = 0; yF < ").concat(e.outDepth,"; yF++) {\n            int xF = wF + yF * ").concat(t," - ").concat(r,";\n\n            if (xF < 0 || xF >= ").concat(e.inDepth,") {\n              continue;\n            }\n\n            for (int yR = 0; yR < ").concat(e.outHeight,"; yR++) {\n              int xR = wR + yR * ").concat(n," - ").concat(o,";\n\n              if (xR < 0 || xR >= ").concat(e.inHeight,") {\n                continue;\n              }\n\n              for (int yC = 0; yC < ").concat(e.outWidth,"; yC++) {\n                int xC = wC + yC * ").concat(a," - ").concat(s,";\n\n                if (xC < 0 || xC >= ").concat(e.inWidth,") {\n                  continue;\n                }\n\n                float dyValue = getDy(b, yF, yR, yC, d2);\n                float xValue = getX(b, xF, xR, xC, d1);\n                dotProd += (xValue * dyValue);\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    ")}}class rz{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;const t=e.filterDepth,n=e.filterHeight,a=e.filterWidth,r=e.strideDepth,o=e.strideHeight,s=e.strideWidth,i=t-1-e.padInfo.front,c=n-1-e.padInfo.top,l=a-1-e.padInfo.left;this.userCode="\n      const ivec3 pads = ivec3(".concat(i,", ").concat(c,", ").concat(l,");\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int d1 = coords.u;\n\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyFCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        float dotProd = 0.0;\n        for (int wF = 0; wF < ").concat(t,"; wF++) {\n          float dyF = float(dyFCorner + wF) / ").concat(r,".0;\n\n          if (dyF < 0.0 || dyF >= ").concat(e.outDepth,".0 || fract(dyF) > 0.0) {\n            continue;\n          }\n          int idyF = int(dyF);\n\n          int wFPerm = ").concat(t," - 1 - wF;\n\n          for (int wR = 0; wR < ").concat(n,"; wR++) {\n            float dyR = float(dyRCorner + wR) / ").concat(o,".0;\n\n            if (dyR < 0.0 || dyR >= ").concat(e.outHeight,".0 ||\n              fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            int wRPerm = ").concat(n," - 1 - wR;\n\n            for (int wC = 0; wC < ").concat(a,"; wC++) {\n              float dyC = float(dyCCorner + wC) / ").concat(s,".0;\n\n              if (dyC < 0.0 || dyC >= ").concat(e.outWidth,".0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              int wCPerm = ").concat(a," - 1 - wC;\n\n              for (int d2 = 0; d2 < ").concat(e.outChannels,"; d2++) {\n                float xValue = getDy(batch, idyF, idyR, idyC, d2);\n                float wValue = getW(wFPerm, wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    ")}}const oz={kernelName:_s,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r,dy:o}=t,{strides:s,pad:i,dataFormat:c,dimRoundingMode:l,filterShape:u}=a,d=np(c),h=Kh(r.shape,u,s,1,i,l,!1,d),p=new tz(h);return n.runWebGLProgram(p,[r,o],"float32")}};class sz{constructor(e){this.variableNames=["dy","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"strides",type:"vec2"}],this.outputShape=e.inShape,this.enableShapeUniforms=$O(this.outputShape.length);const t=e.filterHeight,n=e.filterWidth,a=t-1-e.padInfo.top,r=n-1-e.padInfo.left;this.userCode="\n      const ivec2 pads = ivec2(".concat(a,", ").concat(r,");\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[3];\n\n        ivec2 dyCorner = ivec2(coords[1], coords[2]) - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        vec4 result = vec4(0.);\n        for (int wR = 0; wR < ").concat(t,"; wR++) {\n          float dyR = float(dyRCorner + wR) / strides[0];\n          if (dyR < 0.0 || dyR >= ").concat(e.outHeight,".0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n          int wRPerm = ").concat(t," - 1 - wR;\n\n          for (int wC = 0; wC < ").concat(n,"; wC++) {\n            int wCPerm = ").concat(n," - 1 - wC;\n\n            float dyC = float(dyCCorner + wC) / strides[1];\n            bool idyCVal = (dyC >= 0.0) && (dyC < ").concat(e.outWidth,".0)\n              && (fract(dyC) == 0.0);\n            int idyC = int(dyC);\n\n            float dyC2 = float(dyCCorner + wC + 1) / strides[1];\n            bool idyCVal2 = (dyC2 >= 0.0) && (dyC2 < ").concat(e.outWidth,".0)\n              && (fract(dyC2) == 0.0);\n            int idyC2 = int(dyC2);\n\n            if (idyCVal && idyCVal2) {\n              for (int d2 = 0; d2 < ").concat(e.outChannels,"; d2 += 2) {\n                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);\n                vec4 dySample = getDy(batch, idyR, idyC, d2);\n                vec4 dySample2 = (idyC / 2 == idyC2 / 2) ?\n                  dySample : getDy(batch, idyR, idyC2, d2);\n\n                vec2 dyValue = mod(float(idyC), 2.) == 0. ?\n                  dySample.xy : dySample.zw;\n                result.xy += vec2(dot(dyValue, wValue.xy),\n                  dot(dyValue, wValue.zw));\n\n                dyValue = mod(float(idyC2), 2.) == 0. ?\n                  dySample2.xy : dySample2.zw;\n                result.zw += vec2(dot(dyValue, wValue.xy),\n                  dot(dyValue, wValue.zw));\n              }\n            } else if (idyCVal) {\n              for (int d2 = 0; d2 < ").concat(e.outChannels,"; d2 += 2) {\n                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);\n                vec4 dySample = getDy(batch, idyR, idyC, d2);\n                vec2 dyValue = mod(float(idyC), 2.) == 0. ?\n                  dySample.xy : dySample.zw;\n                result.xy += vec2(dot(dyValue, wValue.xy),\n                  dot(dyValue, wValue.zw));\n              }\n            } else if (idyCVal2) {\n              for (int d2 = 0; d2 < ").concat(e.outChannels,"; d2 += 2) {\n                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);\n                vec4 dySample = getDy(batch, idyR, idyC2, d2);\n                vec2 dyValue = mod(float(idyC2), 2.) == 0. ?\n                  dySample.xy : dySample.zw;\n                result.zw += vec2(dot(dyValue, wValue.xy),\n                  dot(dyValue, wValue.zw));\n              }\n            }\n          }\n        }\n        setOutput(result);\n      }\n    ")}}const iz={kernelName:As,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{dy:r,filter:o}=t,{inputShape:s,strides:i,pad:c,dataFormat:l,dimRoundingMode:u}=a,d=np(l),h=Kh(s,o.shape,i,1,c,u,!1,d);if(Yo().getBool("WEBGL_PACK_CONV2DTRANSPOSE")&&"channelsLast"===d){const e=[[h.strideHeight,h.strideWidth]],t=new sz(h);return n.runWebGLProgram(t,[r,o],"float32",e)}{const e=new nz(h);return n.runWebGLProgram(e,[r,o],"float32")}}};const cz={kernelName:Fs,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r,filter:o}=t,{strides:s,pad:i,dilations:c}=a,l=qh(r.shape,o.shape,s,c,i),u=new XP(l);return n.runWebGLProgram(u,[r,o],"float32")}};const lz={kernelName:Os,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r,dy:o}=t,{strides:s,pad:i,filterShape:c}=a,l=qh(r.shape,c,s,1,i),u=new az(l);return n.runWebGLProgram(u,[r,o],"float32")}};const uz={kernelName:Ds,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{dy:r,filter:o}=t,{pad:s,strides:i,inputShape:c}=a,l=qh(c,o.shape,i,1,s),u=new rz(l);return n.runWebGLProgram(u,[r,o],"float32")}},dz=nL({opSnippet:tL+"\n  return cos(x);\n",packedOpSnippet:"\n  vec4 result = cos(x);\n  bvec4 isNaN = isnan(x);\n  ".concat(GM,"\n  return result;\n")}),hz={kernelName:Ms,backendName:"webgl",kernelFunc:dz},pz=nL({opSnippet:"\n  float e2x = exp(-x);\n  return (e2x + 1.0 / e2x) / 2.0;\n"}),fz={kernelName:Ls,backendName:"webgl",kernelFunc:pz};class mz{constructor(e,t,n,a,r){this.variableNames=["Image","Boxes","BoxInd"],this.outputShape=[];const[o,s,i,c]=e,[l]=t,[u,d]=n;this.outputShape=[l,u,d,c];const h="bilinear"===a?1:0,[p,f]=["".concat(s-1,".0"),"".concat(i-1,".0")],[m,g,b]=u>1?["".concat((s-1)/(u-1)),"(y2-y1) * height_ratio","y1*".concat(p," + float(y)*(height_scale)")]:["0.0","0.0","0.5 * (y1+y2) * ".concat(p)],[y,x,v]=d>1?["".concat((i-1)/(d-1)),"(x2-x1) * width_ratio","x1*".concat(f," + float(x)*(width_scale)")]:["0.0","0.0","0.5 * (x1+x2) * ".concat(f)];this.userCode="\n      const float height_ratio = float(".concat(m,");\n      const float width_ratio = float(").concat(y,");\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int y = coords[1];\n        int x = coords[2];\n        int d = coords[3];\n\n        // get box vals\n        float y1 = getBoxes(b,0);\n        float x1 = getBoxes(b,1);\n        float y2 = getBoxes(b,2);\n        float x2 = getBoxes(b,3);\n\n        // get image in batch index\n        int bInd = round(getBoxInd(b));\n        if(bInd < 0 || bInd >= ").concat(o,") {\n          return;\n        }\n\n        float height_scale = ").concat(g,";\n        float width_scale = ").concat(x,";\n\n        float in_y = ").concat(b,";\n        if( in_y < 0.0 || in_y > ").concat(p," ) {\n          setOutput(float(").concat(r,"));\n          return;\n        }\n        float in_x = ").concat(v,";\n        if( in_x < 0.0 || in_x > ").concat(f," ) {\n          setOutput(float(").concat(r,"));\n          return;\n        }\n\n        vec2 sourceFracIndexCR = vec2(in_x,in_y);\n        if(").concat(h," == 1) {\n          // Compute the four integer indices.\n          ivec2 sourceFloorCR = ivec2(sourceFracIndexCR);\n          ivec2 sourceCeilCR = ivec2(ceil(sourceFracIndexCR));\n\n          float topLeft = getImage(b, sourceFloorCR.y, sourceFloorCR.x, d);\n          float bottomLeft = getImage(b, sourceCeilCR.y, sourceFloorCR.x, d);\n          float topRight = getImage(b, sourceFloorCR.y, sourceCeilCR.x, d);\n          float bottomRight = getImage(b, sourceCeilCR.y, sourceCeilCR.x, d);\n\n          vec2 fracCR = sourceFracIndexCR - vec2(sourceFloorCR);\n\n          float top = topLeft + (topRight - topLeft) * fracCR.x;\n          float bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;\n          float newValue = top + (bottom - top) * fracCR.y;\n          setOutput(newValue);\n        } else {\n          // Compute the coordinators of nearest neighbor point.\n          ivec2 sourceNearestCR = ivec2(floor(\n            sourceFracIndexCR + vec2(0.5,0.5)));\n          float newValue = getImage(b, sourceNearestCR.y, sourceNearestCR.x, d);\n          setOutput(newValue);\n        }\n      }\n    ")}}const gz={kernelName:Bs,backendName:"webgl",kernelFunc:e=>{const{inputs:t,backend:n,attrs:a}=e,{image:r,boxes:o,boxInd:s}=t,{cropSize:i,method:c,extrapolationValue:l}=a,u=new mz(r.shape,o.shape,i,c,l);return n.runWebGLProgram(u,[r,o,s],"float32")}};var bz;!function(e){e.Prod="*",e.Sum="+"}(bz||(bz={}));class yz{constructor(e,t,n,a){this.op=e,this.outputShape=t,this.variableNames=["x"],this.customUniforms=[{name:"index",type:"float"}];const r=this.outputShape.length,o=this.op===bz.Prod?"1.0":"0.0",s=n?o:"getX(".concat(xz(r,"coords",this.op),")"),i=this.outputShape[this.outputShape.length-1];let c="",l="";n?(c=a?"end != ".concat(i-1):"end != 0",l=a?"end + 1":"end - 1"):(c=a?"end + pow2 < ".concat(i):"end >= pow2",l=a?"end + pow2":"end - pow2"),this.userCode="\n      void main() {\n        ".concat(KO(r)," coords = getOutputCoords();\n        int end = ").concat(vz(r,"coords",this.op),";\n        float val = ").concat(s,";\n        int pow2 = int(pow(2.0, index));\n        if (").concat(c,") {\n          int idx = ").concat(l,";\n          ").concat(vz(r,"coords",this.op)," = idx;\n          val ").concat(this.op,"= getX(").concat(xz(r,"coords",this.op),");\n        }\n        setOutput(val);\n      }\n    ")}}function xz(e,t,n){if(1===e)return"".concat(t);if(2===e)return"".concat(t,".x, ").concat(t,".y");if(3===e)return"".concat(t,".x, ").concat(t,".y, ").concat(t,".z");if(4===e)return"".concat(t,".x, ").concat(t,".y, ").concat(t,".z, ").concat(t,".w");throw new Error("Cumulative ".concat(n," for rank ").concat(e," is not yet supported"))}function vz(e,t,n){if(1===e)return"".concat(t);if(2===e)return"".concat(t,".y");if(3===e)return"".concat(t,".z");if(4===e)return"".concat(t,".w");throw new Error("Cumulative ".concat(n," for rank ").concat(e," is not yet supported"))}function wz(e,t,n,a,r,o){const s=t.shape.length,i=Xp([a],s);let c=t;null!=i&&(c=wL({inputs:{x:t},backend:n,attrs:{perm:i}}));const l=Qp(1,s)[0];if(l!==s-1)throw new Error("WebGL cumprod shader expects an inner-most axis=".concat(t.shape.length-1," ")+"but got axis=".concat(a));const u=c.shape[l];let d=jM({inputs:{x:c},backend:n});for(let h=0;h<=Math.ceil(Math.log2(u))-1;h++){const t=new yz(e,c.shape,!1,o),a=[[h]],r=d;d=n.runWebGLProgram(t,[d],d.dtype,a),n.disposeIntermediateTensorInfo(r)}if(r){const t=new yz(e,c.shape,r,o),a=d;d=n.runWebGLProgram(t,[d],d.dtype),n.disposeIntermediateTensorInfo(a)}if(null!=i){const e=wL({inputs:{x:d},backend:n,attrs:{perm:Yp(i)}});return n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(c),e}return d}const kz={kernelName:Ps,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{axis:o,exclusive:s,reverse:i}=a;return wz(bz.Prod,r,n,o,s,i)}};const Iz={kernelName:zs,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{axis:o,exclusive:s,reverse:i}=a;return wz(bz.Sum,r,n,o,s,i)}};const Sz={kernelName:Ws,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r,weights:o}=t,{size:s,binaryOutput:i}=a;if(1===r.shape.length){const e=n.readSync(r.dataId),t=n.readSync(o.dataId),a=xD(e,t,o.dtype,o.shape,s);return n.makeTensorInfo([s],o.dtype,a)}if(2===r.shape.length){const e=n.bufferSync(r),t=n.bufferSync(o),a=vD(e,t,s,i);return n.makeTensorInfo(a.shape,o.dtype,a.values)}throw new Error("Error in denseBincount: input must be at most rank 2, but got rank"+"".concat(r.shape.length,"."))}};class Nz{constructor(e,t,n){this.variableNames=["x"],this.outputShape=[],this.outputShape=e,this.blockSize=t,this.dataFormat=n,this.userCode="\n    void main() {\n      ivec4 coords = getOutputCoords();\n      int b = coords[0];\n      int h = ".concat(this.getHeightCoordString(),";\n      int w = ").concat(this.getWidthCoordString(),";\n      int d = ").concat(this.getDepthCoordString(),";\n\n      int in_h = h / ").concat(t,";\n      int offset_h = imod(h, ").concat(t,");\n      int in_w = w / ").concat(t,";\n      int offset_w = imod(w, ").concat(t,");\n      int offset_d = (offset_h * ").concat(t," + offset_w) *\n        ").concat(this.getOutputDepthSize(),";\n      int in_d = d + offset_d;\n\n      float result = ").concat(this.getInputSamplingString(),";\n      setOutput(result);\n    }\n  ")}getHeightCoordString(){return"NHWC"===this.dataFormat?"coords[1]":"coords[2]"}getWidthCoordString(){return"NHWC"===this.dataFormat?"coords[2]":"coords[3]"}getDepthCoordString(){return"NHWC"===this.dataFormat?"coords[3]":"coords[1]"}getOutputDepthSize(){return"NHWC"===this.dataFormat?this.outputShape[3]:this.outputShape[1]}getInputSamplingString(){return"NHWC"===this.dataFormat?"getX(b, in_h, in_w, in_d)":"getX(b, in_d, in_h, in_w)"}}const Cz={kernelName:Vs,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{blockSize:o,dataFormat:s}=a,i=r.shape[0],c=("NHWC"===s?r.shape[1]:r.shape[2])*o,l=("NHWC"===s?r.shape[2]:r.shape[3])*o,u=("NHWC"===s?r.shape[3]:r.shape[1])/(o*o),d=new Nz("NHWC"===s?[i,c,l,u]:[i,u,c,l],o,s);return n.runWebGLProgram(d,[r],r.dtype)}};class Tz{constructor(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1],n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null,a=arguments.length>3&&void 0!==arguments[3]&&arguments[3],r=arguments.length>4&&void 0!==arguments[4]&&arguments[4];this.variableNames=["x","W"],this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=$O(this.outputShape.length);const o=e.filterHeight,s=e.filterWidth,i=e.outChannels/e.inChannels;let c="",l="";n&&(c=a?"float activation(float a) {\n          float b = getPreluActivationWeightsAtOutCoords();\n          ".concat(n,"\n        }"):r?"float activation(float a) {\n          float b = getLeakyreluAlphaAtOutCoords();\n          ".concat(n,"\n        }"):"\n          float activation(float x) {\n            ".concat(n,"\n          }\n        "),l="result = activation(result);");const u=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),a&&this.variableNames.push("preluActivationWeights"),r&&this.variableNames.push("leakyreluAlpha"),this.userCode="\n      ".concat(c,"\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int d2 = coords.w;\n        int d1 = d2 / ").concat(i,";\n        int q = d2 - d1 * ").concat(i,";\n\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // Convolve x(?, ?, d1) with w(:, :, d1, q) to get y(yR, yC, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        // TO DO(dsmilkov): Flatten the two for loops and vec4 the operations.\n        for (int wR = 0; wR < ").concat(o,"; wR++) {\n          int xR = xRCorner + wR * dilations[0];\n\n          if (xR < 0 || xR >= inDims[0]) {\n            continue;\n          }\n\n          for (int wC = 0; wC < ").concat(s,"; wC++) {\n            int xC = xCCorner + wC * dilations[1];\n\n            if (xC < 0 || xC >= inDims[1]) {\n              continue;\n            }\n\n            float xVal = getX(batch, xR, xC, d1);\n            float wVal = getW(wR, wC, d1, q);\n            dotProd += xVal * wVal;\n          }\n        }\n\n        float result = dotProd;\n        ").concat(u,"\n        ").concat(l,"\n        setOutput(result);\n      }\n    ")}}class Ez{constructor(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1],n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null,a=arguments.length>3&&void 0!==arguments[3]&&arguments[3],r=arguments.length>4&&void 0!==arguments[4]&&arguments[4];this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=$O(this.outputShape.length);const o=e.outChannels/e.inChannels,s=e.padInfo.left,i=e.strideWidth,c=e.dilationWidth,l=e.filterHeight,u=e.filterWidth,d=u;let h="\n      int xR; int xC; int xCOffset;\n      vec4 wTexel; vec4 previous; vec4 final;";for(let g=0;g<u;g++)h+="\n          vec4 xTexelC".concat(2*g,";\n          int xTexelC").concat(2*g,"Ready;\n          vec4 xTexelC").concat(2*g+1,";\n          int xTexelC").concat(2*g+1,"Ready;\n          vec4 xC").concat(g,";");h+="\n    for (int r = 0; r < ".concat(l,"; r++) {\n      ");for(let g=0;g<u;g++)h+="\n          xTexelC".concat(2*g," = vec4(0.0);\n          xTexelC").concat(2*g,"Ready = 0;\n          xTexelC").concat(2*g+1," = vec4(0.0);\n          xTexelC").concat(2*g+1,"Ready = 0;\n          xC").concat(g," = vec4(0.0);");h+="\n        xR = xRCorner + r * dilations[0];\n        if (xR >=0 && xR < inDims[0]) {\n      ";for(let g=0;g<(d+1)/2;g++){const e=2*g;if(h+="\n          xC = xCCorner + ".concat(e*c,";\n          "),1===i){if(e<u&&(s%2===1?(h+="\n                xCOffset = xC + 1;\n                if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC".concat(e,"Ready == 0) {\n                  xTexelC").concat(e," = getX(batch, xR, xCOffset, d1);\n\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if (xCOffset + 1 >= inDims[1]) {\n                    xTexelC").concat(e,".zw = vec2(0.0);\n                  }\n                  xTexelC").concat(e,"Ready = 1;\n                }\n              "),h+=1===c&&e>0?"\n                xC".concat(e," = vec4(xTexelC").concat(e-2,".zw, xTexelC").concat(e,".xy);\n                "):"\n                  xCOffset = xC + 1 - 2;\n\n                  if (xCOffset >= 0 && xCOffset < inDims[1]) {\n                    previous = getX(batch, xR, xCOffset, d1);\n\n                    // Need to manually clear unused channels in case\n                    // we're reading from recycled texture.\n                    if (xCOffset + 1 >= inDims[1]) {\n                      previous.zw = vec2(0.0);\n                    }\n\n                    xC".concat(e," = vec4(previous.zw, xTexelC").concat(e,".xy);\n                  } else {\n                    xC").concat(e," = vec4(0.0, 0.0, xTexelC").concat(e,".xy);\n                  }\n                  ")):h+="\n                if (xC >= 0 && xC < inDims[1] && xTexelC".concat(e,"Ready == 0) {\n                  xTexelC").concat(e," = getX(batch, xR, xC, d1);\n                  if (xC + 1 >= inDims[1]) {\n                    xTexelC").concat(e,".zw = vec2(0.0);\n                  }\n                  xTexelC").concat(e,"Ready = 1;\n                }\n\n                xC").concat(e," = xTexelC").concat(e,";\n                "),e+1<u)){const t=s%2===0?po(c):c;c%2===0&&s%2===1||c%2!==0&&s%2!==1?(h+="\n                  xCOffset = xC + imod(pads[1], 2) + ".concat(t,";\n\n                  if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC").concat(e+1,"Ready == 0) {\n                    xTexelC").concat(e+1," = getX(batch, xR, xCOffset, d1);\n\n                    // Need to manually clear unused channels in case\n                    // we're reading from recycled texture.\n                    if (xCOffset + 1 >= inDims[1]) {\n                      xTexelC").concat(e+1,".zw = vec2(0.0);\n                    }\n                    xTexelC").concat(e+1,"Ready = 1;\n                  }\n                  "),h+=c>1?"\n                    xCOffset -= 2;\n                    if (xCOffset >= 0 && xCOffset < inDims[1]) {\n                     previous = getX(batch, xR, xCOffset, d1);\n                     xC".concat(e+1," = vec4(previous.zw, xTexelC").concat(e+1,".xy);\n                    } else {\n                     xC").concat(e+1," = vec4(0.0, 0.0, xTexelC").concat(e+1,".xy);\n                    }\n                    "):"\n                    xC".concat(e+1," = vec4(xTexelC").concat(e,".zw, xTexelC").concat(e+1,".xy);\n                    ")):h+=1===t?"\n                    xC".concat(e+1," = xTexelC").concat(e,";\n                    "):"\n                    xCOffset = xC + ".concat(t,";\n\n                    if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC").concat(e+1,"Ready == 0) {\n                      xTexelC").concat(e+1," = getX(batch, xR, xCOffset, d1);\n                      if (xCOffset + 1 >= inDims[1]) {\n                        xTexelC").concat(e+1,".zw = vec2(0.0);\n                      }\n                      xTexelC").concat(e+1,"Ready = 1;\n                    }\n\n                    xC").concat(e+1," = xTexelC").concat(e+1,";\n                    ")}}else e<u&&(s%2===1?(h+="\n                xCOffset = xC + 1 - strides[1];\n                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC".concat(e,"Ready == 0) {\n                  xTexelC").concat(e," = getX(batch, xR, xCOffset, d1);\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if (xCOffset + 1 >= inDims[1]) {\n                    xTexelC").concat(e,".zw = vec2(0.0);\n                  }\n                  xTexelC").concat(e,"Ready = 1;\n                }\n\n                if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC").concat(e+1,"Ready == 0) {\n                  xTexelC").concat(e+1," = getX(batch, xR, xC + 1, d1);\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if (xC + 2 >= inDims[1]) {\n                    xTexelC").concat(e+1,".zw = vec2(0.0);\n                  }\n                  xTexelC").concat(e+1,"Ready = 1;\n                }\n\n                xC").concat(e," = vec4(xTexelC").concat(e,".zw, xTexelC").concat(e+1,".zw);\n              "),e+1<u&&(h+="\n                  final = vec4(0.0);\n                  xCOffset = xC + 1 + strides[1];\n                  if(xCOffset >= 0 && xCOffset < inDims[1]) {\n                    final = getX(batch, xR, xCOffset, d1);\n                  }\n                  xC".concat(e+1," = vec4(xTexelC").concat(e+1,".xy, final.xy);\n                "))):(h+="\n                if(xC >= 0 && xC < inDims[1] && xTexelC".concat(e,"Ready == 0) {\n                  xTexelC").concat(e," = getX(batch, xR, xC, d1);\n                  if (xC + 1 >= inDims[1]) {\n                    xTexelC").concat(e,".zw = vec2(0.0);\n                  }\n                  xTexelC").concat(e,"Ready = 1;\n                }\n\n                xCOffset = xC + strides[1];\n                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC").concat(e+1,"Ready == 0) {\n                  xTexelC").concat(e+1," = getX(batch, xR, xCOffset, d1);\n                  if (xCOffset + 1 >= inDims[1]) {\n                    xTexelC").concat(e+1,".zw = vec2(0.);\n                  }\n                  xTexelC").concat(e+1,"Ready = 1;\n                }\n\n                xC").concat(e," = vec4(\n                  xTexelC").concat(e,".xy, xTexelC").concat(e+1,".xy);\n              "),e+1<u&&(h+="\n                  xC".concat(e+1," = vec4(xTexelC").concat(e,".zw, xTexelC").concat(e+1,".zw);\n                "))));e<u&&(h+="\n            wTexel = getW(r, ".concat(e,", d1, q);\n            dotProd += xC").concat(e," * vec4(wTexel.xz, wTexel.xz);\n          "),e+1<u&&(h+="\n              wTexel = getW(r, ".concat(e+1,", d1, q);\n              dotProd += xC").concat(e+1," * vec4(wTexel.xz, wTexel.xz);\n            ")))}h+="\n    }\n  ",h+="\n      }\n    ";let p="",f="";n&&(p=a?"vec4 activation(vec4 a) {\n          vec4 b = getPreluActivationWeightsAtOutCoords();\n          ".concat(n,"\n        }"):r?"vec4 activation(vec4 a) {\n          vec4 b = getLeakyreluAlphaAtOutCoords();\n          ".concat(n,"\n        }"):"vec4 activation(vec4 x) {\n          ".concat(n,"\n        }"),f="result = activation(result);");const m=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),a&&this.variableNames.push("preluActivationWeights"),r&&this.variableNames.push("leakyreluAlpha"),this.userCode="\n      ".concat(p,"\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int d2 = coords.w;\n        int d1 = d2 / ").concat(o,";\n        int q = d2 - d1 * ").concat(o,";\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.\n        vec4 dotProd = vec4(0.000000000000001);\n\n        ").concat(h,"\n\n        vec4 result = dotProd - vec4(0.000000000000001);\n        ").concat(m,"\n        ").concat(f,"\n        setOutput(result);\n      }\n    ")}}const Rz={kernelName:Us,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r,filter:o}=t,{strides:s,pad:i,dilations:c,dimRoundingMode:l}=a;let u=c;null==u&&(u=[1,1]),mo(ep(s,u),(()=>"Error in depthwiseConv2d: Either strides or dilations must be "+"1. Got strides ".concat(s," and dilations '").concat(u,"'")));const d=Kh(r.shape,o.shape,s,u,i,l,!0);let h;h=Yo().getBool("WEBGL_PACK_DEPTHWISECONV")&&d.strideWidth<=2&&d.outChannels/d.inChannels===1?new Ez(d):new Tz(d);const p=[[d.padInfo.top,d.padInfo.left],[d.strideHeight,d.strideWidth],[d.dilationHeight,d.dilationWidth],[d.inHeight,d.inWidth]];return n.runWebGLProgram(h,[r,o],"float32",p)}};class _z{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;const t=e.strideHeight,n=e.strideWidth,a=e.padInfo.top,r=e.padInfo.left,o=e.outChannels/e.inChannels;this.userCode="\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int wR = coords.x;\n        int wC = coords.y;\n        int d1 = coords.z;\n        int dm = coords.w;\n        int d2 = d1 * ".concat(o," + dm;\n\n        float dotProd = 0.0;\n\n        // TO DO: Vec4 over the batch size\n        for (int b = 0; b < ").concat(e.batchSize,"; b++) {\n          for (int yR = 0; yR < ").concat(e.outHeight,"; yR++) {\n            int xR = wR + yR * ").concat(t," - ").concat(a,";\n\n            if (xR < 0 || xR >= ").concat(e.inHeight,") {\n              continue;\n            }\n\n            for (int yC = 0; yC < ").concat(e.outWidth,"; yC++) {\n              int xC = wC + yC * ").concat(n," - ").concat(r,";\n\n              if (xC < 0 || xC >= ").concat(e.inWidth,") {\n                continue;\n              }\n\n              float dyValue = getDy(b, yR, yC, d2);\n              float xValue = getX(b, xR, xC, d1);\n              dotProd += (xValue * dyValue);\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    ")}}class Az{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;const t=e.filterHeight,n=e.filterWidth,a=e.strideHeight,r=e.strideWidth,o=t-1-e.padInfo.top,s=n-1-e.padInfo.left,i=e.outChannels/e.inChannels;this.userCode="\n      const ivec2 pads = ivec2(".concat(o,", ").concat(s,");\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[3];\n        ivec2 dyCorner = coords.yz - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        float dotProd = 0.0;\n\n        for (int wR = 0; wR < ").concat(t,"; wR++) {\n          float dyR = float(dyRCorner + wR) / ").concat(a,".0;\n\n          if (dyR < 0.0 || dyR >= ").concat(e.outHeight,".0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          int wRPerm = ").concat(t," - 1 - wR;\n\n          for (int wC = 0; wC < ").concat(n,"; wC++) {\n            float dyC = float(dyCCorner + wC) / ").concat(r,".0;\n\n            if (dyC < 0.0 || dyC >= ").concat(e.outWidth,".0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            int wCPerm = ").concat(n," - 1 - wC;\n\n            // TO DO: Vec4 over the channelMul\n            for (int dm = 0; dm < ").concat(i,"; dm++) {\n              int d2 = d1 * ").concat(i," + dm;\n              float xValue = getDy(batch, idyR, idyC, d2);\n              float wValue = getW(wRPerm, wCPerm, d1, dm);\n              dotProd += xValue * wValue;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    ")}}const Fz={kernelName:Gs,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r,dy:o}=t,{strides:s,dilations:i,pad:c,dimRoundingMode:l,filterShape:u}=a,d=Kh(r.shape,u,s,i,c,l,!0),h=new _z(d);return n.runWebGLProgram(h,[r,o],"float32")}};const Oz={kernelName:Hs,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{dy:r,filter:o}=t,{strides:s,dilations:i,pad:c,dimRoundingMode:l,inputShape:u}=a,d=Kh(u,o.shape,s,i,c,l,!0),h=new Az(d);return n.runWebGLProgram(h,[r,o],"float32")}};class Dz{constructor(e){this.variableNames=["X"],this.outputShape=[e,e],this.userCode="\n      void main() {\n          ivec2 coords = getOutputCoords();\n          float val = coords[0] == coords[1] ? getX(coords[0]) : 0.0;\n          setOutput(val);\n      }\n    "}}const Mz={kernelName:js,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{x:a}=t,r=[...a.shape,...a.shape],o=yo(a.shape),s=dL({inputs:{x:a},backend:n,attrs:{shape:[o]}}),i=new Dz(o),c=n.runWebGLProgram(i,[s],s.dtype),l=dL({inputs:{x:c},backend:n,attrs:{shape:r}});return n.disposeIntermediateTensorInfo(s),n.disposeIntermediateTensorInfo(c),l}};class Lz{constructor(e){this.variableNames=["x","W"],this.outputShape=e.outShape;const{inHeight:t,inWidth:n,padInfo:a,strideHeight:r,strideWidth:o,filterHeight:s,filterWidth:i,dilationHeight:c,dilationWidth:l}=e,{top:u,left:d}=a;this.userCode="\n      const ivec2 strides = ivec2(".concat(r,", ").concat(o,");\n      const ivec2 pads = ivec2(").concat(u,", ").concat(d,");\n      const float neg_infinity = -3.4e38;\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        int d1 = coords.w;\n        ivec2 outTopLeftCorner =\n            coords.yz * strides - pads;\n        int hBeg = outTopLeftCorner.x;\n        int wBeg = outTopLeftCorner.y;\n\n        float curVal = neg_infinity;\n        for (int h = 0; h < ").concat(s,"; h++) {\n          int hIn = hBeg + h * ").concat(c,";\n\n          if (hIn >= 0 && hIn < ").concat(t,") {\n            for (int w = 0; w < ").concat(i,"; w++) {\n              int wIn = wBeg + w * ").concat(l,";\n\n              if (wIn >= 0 && wIn < ").concat(n,") {\n                float xVal = getX(batch, hIn, wIn, d1);\n                float wVal = getW(h, w, d1);\n\n                float val = xVal + wVal;\n                if (val > curVal) {\n                  curVal = val;\n                }\n              }\n            }\n          }\n        }\n\n        float result = curVal;\n        setOutput(result);\n      }\n    ")}}const Pz={kernelName:Ks,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r,filter:o}=t,{strides:s,pad:i,dilations:c}=a,l=Gh(r.shape,o.shape,s,i,"NHWC",c);let u;const d=new Lz(l);u=n.runWebGLProgram(d,[r,o],"float32");const h=dL({inputs:{x:u},backend:n,attrs:{shape:l.outShape}});return n.disposeIntermediateTensorInfo(u),h}};const zz={kernelName:Js,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{equation:r}=a,o=t,{allDims:s,summedDims:i,idDims:c}=Mg(r,o.length);Pg(s.length,c,o);const{path:l,steps:u}=zg(i,c),d=u.length;let h=null,p=s.length;const f=[];for(let m=0;m<d;++m){for(const e of u[m]){const{permutationIndices:t,expandDims:a}=Lg(p,c[e]);let r;Bg(t)?r=o[e]:(r=wL({inputs:{x:o[e]},backend:n,attrs:{perm:t}}),f.push(r));const s=r.shape.slice();for(let e=0;e<a.length;++e)s.splice(a[e],0,1);xo(r.shape,s)||(r=dL({inputs:{x:r},backend:n,attrs:{shape:s}}),f.push(r)),null===h?h=r:(h=lL({inputs:{a:r,b:h},backend:n}),f.push(h))}m<d-1&&(l[m]>=0&&(h=xL({inputs:{x:h},backend:n,attrs:{axis:l[m]-(s.length-p),keepDims:!1}}),f.push(h)),p--)}for(const m of f)m!==h&&n.disposeIntermediateTensorInfo(m);return h}},Bz=nL({opSnippet:"return (x >= 0.0) ? x : (exp(x) - 1.0);",packedOpSnippet:"\n  vec4 result;\n\n  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);\n  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);\n  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);\n  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);\n\n  return result;\n"}),Wz={kernelName:Zs,backendName:"webgl",kernelFunc:Bz},Vz={kernelName:$s,backendName:"webgl",kernelFunc:e=>{const{inputs:t,backend:n}=e,{dy:a,y:r}=t,o=Yo().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new HM("\n  vec4 bGTEZero = vec4(greaterThanEqual(b, vec4(0.)));\n  return (bGTEZero * a) + ((vec4(1.0) - bGTEZero) * (a * (b + vec4(1.0))));\n",a.shape,r.shape):new UM("return (b >= 0.0) ? a : a * (b + 1.0);",a.shape,r.shape);return n.runWebGLProgram(o,[a,r],a.dtype)}},Uz=aL({opSnippet:"return float(a == b);",packedOpSnippet:"\n  return vec4(equal(a, b));\n",dtype:"bool",cpuKernelImpl:ND}),Gz={kernelName:ti,backendName:"webgl",kernelFunc:Uz},Hz=nL({opSnippet:'\n  // Error function is calculated approximately with elementary function.\n  // See "Handbook of Mathematical Functions with Formulas,\n  // Graphs, and Mathematical Tables", Abramowitz and Stegun.\n  float p = '.concat(bg,";\n  float a1 = ").concat(yg,";\n  float a2 = ").concat(xg,";\n  float a3 = ").concat(vg,";\n  float a4 = ").concat(wg,";\n  float a5 = ").concat(kg,";\n\n  float sign = sign(x);\n  x = abs(x);\n  float t = 1.0 / (1.0 + p * x);\n  return sign * (1.0 - (((((a5*t + a4)*t) + a3)*t + a2)*t + a1)*t*exp(-x*x));\n")}),jz={kernelName:ei,backendName:"webgl",kernelFunc:Hz},Kz=nL({opSnippet:tL+"\n  return exp(x);\n",packedOpSnippet:"\n  vec4 result = exp(x);\n  bvec4 isNaN = isnan(x);\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n",cpuKernelImpl:CD,dtype:"float32"}),qz={kernelName:ni,backendName:"webgl",kernelFunc:Kz};function Xz(e){const{inputs:t,attrs:n,backend:a}=e,{dim:r}=n,{input:o}=t,s=o.shape.length,i=o.shape.slice();let c=r;return r<0&&(mo(-(s+1)<=r,(()=>"Axis must be in the interval [".concat(-(s+1),", ").concat(s,"]"))),c=s+r+1),i.splice(c,0,1),dL({inputs:{x:o},backend:a,attrs:{shape:i}})}const Yz={kernelName:ai,backendName:"webgl",kernelFunc:Xz},Qz="return exp(x) - 1.0;",Jz=nL({opSnippet:Qz,packedOpSnippet:Qz,cpuKernelImpl:TD}),Zz={kernelName:ri,backendName:"webgl",kernelFunc:Jz};class $z{constructor(e,t,n){this.variableNames=["real","imag"];const a=t[1];this.outputShape=t;const r=n?"2.0 * ".concat(Math.PI):"-2.0 * ".concat(Math.PI),o=n?"".concat(a,".0"):"1.0";let s;if("real"===e)s="return real * expR - imag * expI;";else{if("imag"!==e)throw new Error('FFT component must be either "real" or "imag", got '.concat(e,"."));s="return real * expI + imag * expR;"}this.userCode="\n      const float exponentMultiplier = ".concat(r,";\n\n      float unaryOpComplex(float real, float expR, float imag, float expI) {\n        ").concat(s,"\n      }\n\n      float mulMatDFT(int batch, int index) {\n        float indexRatio = float(index) / float(").concat(a,");\n        float exponentMultiplierTimesIndexRatio =\n            exponentMultiplier * indexRatio;\n\n        float result = 0.0;\n\n        for (int i = 0; i < ").concat(a,"; i++) {\n          // x = (-2|2 * PI / N) * index * i;\n          float x = exponentMultiplierTimesIndexRatio * float(i);\n          float expR = cos(x);\n          float expI = sin(x);\n          float real = getReal(batch, i);\n          float imag = getImag(batch, i);\n\n          result +=\n              unaryOpComplex(real, expR, imag, expI) / ").concat(o,";\n        }\n\n        return result;\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        setOutput(mulMatDFT(coords[0], coords[1]));\n      }\n    ")}}function eB(e,t,n){const a=n.texData.get(e.dataId),r=yo(e.shape),o=e.shape[e.shape.length-1],s=dL({inputs:{x:e},backend:n,attrs:{shape:[r/o,o]}}),i=s.shape,c=new $z("real",i,t),l=new $z("imag",i,t),u=[{dataId:a.complexTensorInfos.real.dataId,dtype:a.complexTensorInfos.real.dtype,shape:i},{dataId:a.complexTensorInfos.imag.dataId,dtype:a.complexTensorInfos.imag.dtype,shape:i}],d=n.runWebGLProgram(c,u,"float32"),h=n.runWebGLProgram(l,u,"float32"),p=qM({inputs:{real:d,imag:h},backend:n});n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(h);const f=dL({inputs:{x:p},backend:n,attrs:{shape:e.shape}});return n.disposeIntermediateTensorInfo(s),n.disposeIntermediateTensorInfo(p),f}const tB={kernelName:oi,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{input:a}=t;return eB(a,!1,n)}};class nB{constructor(e,t){this.outputShape=[],this.customUniforms=[{name:"value",type:"float"}],this.variableNames=["x"],this.outputShape=e,this.userCode="\n      void main() {\n        // Input can be obtained from uniform value.\n        setOutput(value);\n      }\n    "}}function aB(e){const{backend:t,attrs:n}=e,{shape:a,value:r}=n;let{dtype:o}=n;if(o=o||Oo(r),"string"===o){const e=Eo(o,yo(a));return e.fill(r),t.makeTensorInfo(a,o,e)}{const e=new nB(a,r),n=[[r]];return t.runWebGLProgram(e,[],o,n)}}const rB={kernelName:si,backendName:"webgl",kernelFunc:aB};class oB{constructor(e){this.variableNames=["Image"],this.outputShape=[];const t=e[2];this.outputShape=e,this.userCode="\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int x = coords[2];\n\n          int coordX = ".concat(t," - x - 1;\n          float outputValue;\n          if(coordX >= 0 && coordX < ").concat(t,") {\n            outputValue = getImage(coords[0], coords[1], coordX, coords[3]);\n          } else {\n            outputValue = getImage(coords[0], coords[1], coords[2], coords[3]);\n          }\n          setOutput(outputValue);\n        }\n    ")}}const sB={kernelName:ii,backendName:"webgl",kernelFunc:e=>{let{inputs:t,backend:n}=e;const{image:a}=t,r=n,o=new oB(a.shape);return r.runWebGLProgram(o,[a],a.dtype)}},iB="return floor(x);",cB=nL({opSnippet:iB,packedOpSnippet:iB,cpuKernelImpl:ED}),lB={kernelName:ci,backendName:"webgl",kernelFunc:cB},uB=aL({opSnippet:"\n  float s = sign(a) * sign(b);\n  int ia = round(a);\n  int ib = round(b);\n  if (ib != 0) {\n    // Windows (D3D) wants guaranteed non-zero int division at compile-time.\n    return float(idiv(ia, ib, s));\n  } else {\n    return NAN;\n  }\n",packedOpSnippet:"\n  ivec4 ia = round(a);\n  ivec4 ib = round(b);\n  bvec4 cond = notEqual(ib, ivec4(0));\n  ivec4 result = ivec4(0);\n  vec4 s = sign(a) * sign(b);\n\n  // Windows (D3D) wants guaranteed non-zero int division at compile-time.\n  if (cond[0]) {\n    result[0] = idiv(ia[0], ib[0], s[0]);\n  }\n  if (cond[1]) {\n    result[1] = idiv(ia[1], ib[1], s[1]);\n  }\n  if (cond[2]) {\n    result[2] = idiv(ia[2], ib[2], s[2]);\n  }\n  if (cond[3]) {\n    result[3] = idiv(ia[3], ib[3], s[3]);\n  }\n  return vec4(result);\n",dtype:"int32"}),dB={kernelName:li,backendName:"webgl",kernelFunc:uB};class hB{constructor(e){this.variableNames=["A"];const t=_O(),[n,a]=e;this.outputShape=e,this.userCode="\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int texR = coords[0];\n        int texC = coords[1];\n        int depth = coords[2];\n        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(".concat(a,".0, ").concat(n,".0);\n\n        vec4 values = ").concat(t.texture2D,"(A, uv);\n        float value;\n        if (depth == 0) {\n          value = values.r;\n        } else if (depth == 1) {\n          value = values.g;\n        } else if (depth == 2) {\n          value = values.b;\n        } else if (depth == 3) {\n          value = values.a;\n        }\n\n        setOutput(floor(value * 255.0 + 0.5));\n      }\n    ")}}class pB{constructor(e){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0;const t=_O(),[n,a]=e;this.outputShape=e,this.userCode="\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int texR = coords[0];\n        int texC = coords[1];\n        int depth = coords[2];\n\n        vec4 result = vec4(0.);\n\n        for(int row=0; row<=1; row++) {\n          for(int col=0; col<=1; col++) {\n            texC = coords[1] + row;\n            depth = coords[2] + col;\n\n            vec2 uv = (vec2(texC, texR) + halfCR) /\n                       vec2(".concat(a,".0, ").concat(n,".0);\n            vec4 values = ").concat(t.texture2D,"(A, uv);\n            float value;\n            if (depth == 0) {\n              value = values.r;\n            } else if (depth == 1) {\n              value = values.g;\n            } else if (depth == 2) {\n              value = values.b;\n            } else if (depth == 3) {\n              value = values.a;\n            }\n\n            result[row * 2 + col] = floor(value * 255.0 + 0.5);\n          }\n        }\n\n        ").concat(t.output," = result;\n      }\n    ")}}const fB={kernelName:sl,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e;let{pixels:r}=t;const{numChannels:o}=a,s="undefined"!==typeof HTMLVideoElement&&r instanceof HTMLVideoElement,i="undefined"!==typeof HTMLImageElement&&r instanceof HTMLImageElement,[c,l]=s?[r.videoWidth,r.videoHeight]:[r.width,r.height],u=[l,c],d=[l,c,o];if(i||s){const e=Yo().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");null!=mB&&e===gB||(gB=e,mB=document.createElement("canvas").getContext("2d",{willReadFrequently:gB})),mB.canvas.width=c,mB.canvas.height=l,mB.drawImage(r,0,0,c,l),r=mB.canvas}const h=n.makeTensorInfo(u,"int32");n.texData.get(h.dataId).usage=ZF.PIXELS,n.gpgpu.uploadPixelDataToTexture(n.getTexture(h.dataId),r);const p=Yo().getBool("WEBGL_PACK")?new pB(d):new hB(d),f=n.runWebGLProgram(p,[h],"int32");return n.disposeData(h.dataId),f}};let mB,gB=Yo().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");const bB={kernelName:ll,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r,filter:o,bias:s,preluActivationWeights:i}=t,{strides:c,pad:l,dataFormat:u,dilations:d,dimRoundingMode:h,activation:p,leakyreluAlpha:f}=a,m=np(u),g=Kh(r.shape,o.shape,c,d,l,h,!1,m);let b;const y=[],x=null!=s,v=null!=i,w="leakyrelu"===p,k=()=>{const e=[r,o],t=(e,t)=>{if("NCHW"===t&&1===e.shape.length&&1!==e.shape[0]){const t=dL({inputs:{x:e},backend:n,attrs:{shape:[e.shape[0],1,1]}});return y.push(t),t}return e};if(x&&e.push(t(s,u)),v&&e.push(t(i,u)),w){const t=n.makeTensorInfo([],"float32",Pl(f,"float32"));e.push(t),y.push(t)}return e};if(1!==g.filterHeight||1!==g.filterWidth||1!==g.dilationHeight||1!==g.dilationWidth||1!==g.strideHeight||1!==g.strideWidth||"SAME"!==g.padInfo.type&&"VALID"!==g.padInfo.type)if(g.strideWidth<=2&&"channelsLast"===m&&Yo().getBool("WEBGL_EXP_CONV")){const e=p?rL(p,!0):null,t=new YP(g,x,e,v,w),a=[[g.padInfo.top,g.padInfo.left],[g.strideHeight,g.strideWidth],[g.dilationHeight,g.dilationWidth],[g.inHeight,g.inWidth]],r=k();b=n.runWebGLProgram(t,r,"float32",a)}else if(Yo().getBool("WEBGL_CONV_IM2COL"))b=$P({x:r,filter:o,convInfo:g,backend:n,bias:s,activation:p,preluActivationWeights:i,leakyreluAlpha:f});else{const e=p?rL(p,!1):null,t=new qP(g,x,e,v,w),a=k();b=n.runWebGLProgram(t,a,"float32")}else b=ZP({x:r,filter:o,convInfo:g,backend:n,bias:s,activation:p,preluActivationWeights:i,leakyreluAlpha:f});const I=dL({inputs:{x:b},backend:n,attrs:{shape:g.outShape}});return y.push(b),y.forEach((e=>n.disposeIntermediateTensorInfo(e))),I}};const yB={kernelName:ul,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r,filter:o,bias:s,preluActivationWeights:i}=t,{strides:c,pad:l,dilations:u,dimRoundingMode:d,activation:h,leakyreluAlpha:p}=a,f=[];let m=u;null==m&&(m=[1,1]),mo(ep(c,m),(()=>"Error in depthwiseConv2d: Either strides or dilations must be "+"1. Got strides ".concat(c," and dilations '").concat(m,"'")));const g=Kh(r.shape,o.shape,c,m,l,d,!0),b=Yo().getBool("WEBGL_PACK_DEPTHWISECONV")&&g.strideWidth<=2&&g.outChannels/g.inChannels===1,y=h?rL(h,b):null,x=[r,o],v=null!=s,w=null!=i,k="leakyrelu"===h;if(v&&x.push(s),w&&x.push(i),k){const e=n.makeTensorInfo([],"float32",Pl(p,"float32"));x.push(e),f.push(e)}let I;I=b?new Ez(g,v,y,w,k):new Tz(g,v,y,w,k);const S=[[g.padInfo.top,g.padInfo.left],[g.strideHeight,g.strideWidth],[g.dilationHeight,g.dilationWidth],[g.inHeight,g.inWidth]],N=n.runWebGLProgram(I,x,"float32",S);return f.forEach((e=>n.disposeIntermediateTensorInfo(e))),N}};class xB{constructor(e,t,n,a){this.sliceDim=e,this.strides=t,this.paramsShape=a,this.variableNames=["x","indices"],this.outputShape=n;const r=KO(n.length);let o="\n    int index;";for(let s=0;s<this.sliceDim;s++)o+="\n          index = round(getIndices(coords[0], ".concat(s,"));\n          out_of_bounds = out_of_bounds || index < 0;\n          out_of_bounds = out_of_bounds || index >= ").concat(this.paramsShape[s],";\n          flattenIndex += index * ").concat(this.strides[s],";");this.userCode="\n         void main() {\n          ".concat(r," coords = getOutputCoords();\n          int flattenIndex = 0;\n          bool out_of_bounds = false;\n\n          ").concat(o,"\n\n          setOutput(out_of_bounds ? 0.0 : getX(flattenIndex, coords[1]));\n        }\n      ")}}const vB={kernelName:hi,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{params:a,indices:r}=t,o=r.shape,s=o[o.length-1],i=yo(a.shape),[c,l,u,d]=dg(a,r),h=dL({inputs:{x:r},backend:n,attrs:{shape:[l,s]}}),p=dL({inputs:{x:a},backend:n,attrs:{shape:[yo(a.shape)/u,u]}});if(n.shouldExecuteOnCPU([a,r])||"string"===a.dtype){const e=n.readSync(r.dataId),t=n.bufferSync(a),o=RD(e,t,a.dtype,l,s,u,d,a.shape,i);return n.makeTensorInfo(c,a.dtype,o.values)}const f=new xB(s,d,[l,u],a.shape),m=n.runWebGLProgram(f,[p,h],p.dtype),g=dL({inputs:{x:m},backend:n,attrs:{shape:c}});return n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(m),g}};class wB{constructor(e,t){this.variableNames=["A","indices"],this.outputShape=t,this.rank=t.length;const n=KO(this.rank),a=function(e,t){const n=["resRC.x","resRC.y","resRC.z","resRC.w"],a=[];for(let r=0;r<e.length;r++)2===r?a.push("index"):a.push("".concat(n[r]));return a.join()}(e);this.userCode="\n      void main() {\n        ".concat(n," resRC = getOutputCoords();\n        int index = int(getIndices(resRC.x, resRC.z));\n        float inBounds = (index >= 0) && (index < ").concat(e[2],") ? 1.0 : 0.0;\n        setOutput(inBounds * getA(").concat(a,"));\n      }\n    ")}}function kB(e){const{inputs:t,backend:n,attrs:a}=e,{x:r,indices:o}=t,{axis:s,batchDims:i}=a,c=No(s,r.shape)[0];if(Yo().get("DEBUG")){const e=n.readSync(o.dataId),t=r.shape[c];for(let n=0;n<e.length;++n){const a=e[n];mo(a<=t-1&&a>=0,(()=>"GatherV2: the index value ".concat(a," is not in [0, ").concat(t-1,"]")))}}const l=nb(r,o,c,i),u=yo(o.shape),d=[],h=dL({inputs:{x:r},backend:n,attrs:{shape:[l.batchSize,l.outerSize,l.dimSize,l.sliceSize]}}),p=dL({inputs:{x:o},backend:n,attrs:{shape:[l.batchSize,u/l.batchSize]}});d.push(h),d.push(p);const f=[l.batchSize,l.outerSize,u/l.batchSize,l.sliceSize];if(n.shouldExecuteOnCPU([r,o])||"string"===r.dtype){const e=n.bufferSync(p),t=n.bufferSync(h),a=_D(t,e,f);return d.forEach((e=>n.disposeIntermediateTensorInfo(e))),n.makeTensorInfo(l.outputShape,a.dtype,a.values)}const m=new wB(h.shape,f),g=n.runWebGLProgram(m,[h,p],h.dtype);d.push(g);const b=dL({inputs:{x:g},backend:n,attrs:{shape:l.outputShape}});return d.forEach((e=>n.disposeIntermediateTensorInfo(e))),b}const IB={kernelName:di,backendName:"webgl",kernelFunc:kB},SB=aL({opSnippet:"return float(a > b);",packedOpSnippet:"\n  return vec4(greaterThan(a, b));\n",cpuKernelImpl:AD,dtype:"bool"}),NB={kernelName:pi,backendName:"webgl",kernelFunc:SB},CB=aL({opSnippet:"return float(a >= b);",packedOpSnippet:"\n  return vec4(greaterThanEqual(a, b));\n",dtype:"bool",cpuKernelImpl:FD}),TB={kernelName:fi,backendName:"webgl",kernelFunc:CB};const EB={kernelName:gi,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{input:a}=t;return eB(a,!0,n)}},RB=nL({opSnippet:"return float(!isnan(x) && !isinf(x));",dtype:"bool"}),_B={kernelName:yi,backendName:"webgl",kernelFunc:RB},AB=nL({opSnippet:"return float(isinf(x));",dtype:"bool"}),FB={kernelName:xi,backendName:"webgl",kernelFunc:AB},OB=nL({opSnippet:"return float(isnan(x));",dtype:"bool"}),DB={kernelName:vi,backendName:"webgl",kernelFunc:OB},MB=aL({opSnippet:"return float(a < b);",packedOpSnippet:"\n  return vec4(lessThan(a, b));\n",cpuKernelImpl:OD,dtype:"bool"}),LB={kernelName:ki,backendName:"webgl",kernelFunc:MB},PB=aL({opSnippet:"return float(a <= b);",packedOpSnippet:"\n  return vec4(lessThanEqual(a, b));\n",cpuKernelImpl:DD,dtype:"bool"}),zB={kernelName:Ii,backendName:"webgl",kernelFunc:PB};const BB={kernelName:Si,backendName:"webgl",kernelFunc:function(e){const{backend:t,attrs:n}=e,{start:a,stop:r,num:o}=n,s=MD(a,r,o);return t.makeTensorInfo([s.length],"float32",s)}},WB=nL({opSnippet:tL+"\n  return x < 0.0 ? 0./0. : log(x);\n",packedOpSnippet:"\n  vec4 result = log(x);\n  bvec4 isNaN = isnan(x);\n  result.r = isNaN.r ? x.r : (x.r < 0.0 ? 0./0. : result.r);\n  result.g = isNaN.g ? x.g : (x.g < 0.0 ? 0./0. : result.g);\n  result.b = isNaN.b ? x.b : (x.b < 0.0 ? 0./0. : result.b);\n  result.a = isNaN.a ? x.a : (x.a < 0.0 ? 0./0. : result.a);\n  return result;\n",cpuKernelImpl:LD}),VB={kernelName:Ni,backendName:"webgl",kernelFunc:WB},UB=nL({opSnippet:tL+"\n  return log(1.0 + x);\n"}),GB={kernelName:Ci,backendName:"webgl",kernelFunc:UB},HB=aL({opSnippet:"return float(a >= 1.0 && b >= 1.0);",packedOpSnippet:"\n  return vec4(\n    vec4(greaterThanEqual(a, vec4(1.0))) *\n    vec4(greaterThanEqual(b, vec4(1.0))));\n",dtype:"bool"}),jB={kernelName:Ti,backendName:"webgl",kernelFunc:HB},KB=nL({opSnippet:"return float(!(x >= 1.0));"}),qB={kernelName:Ei,backendName:"webgl",kernelFunc:KB},XB=aL({opSnippet:"return float(a >= 1.0 || b >= 1.0);",packedOpSnippet:"\n  return min(\n    vec4(greaterThanEqual(a, vec4(1.0))) +\n    vec4(greaterThanEqual(b, vec4(1.0))),\n    vec4(1.0));\n",dtype:"bool"}),YB={kernelName:Ri,backendName:"webgl",kernelFunc:XB};class QB{constructor(e,t,n,a,r){this.variableNames=["x"],this.outputShape=[];const o=t,s=e[3]-1;let i;this.outputShape=e;const c="float(".concat(n,") + float(").concat(a,") * sum");i=.5===r?"inversesqrt(".concat(c,")"):1===r?"1.0/(".concat(c,")"):"exp(log(".concat(c,") * float(-").concat(r,"));"),this.userCode="\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int r = coords[1];\n        int c = coords[2];\n        int d = coords[3];\n        float x = getX(b, r, c, d);\n        float sum = 0.0;\n        for (int j = -".concat(o,"; j <= ").concat(o,"; j++) {\n          int idx = d + j;\n          if (idx >= 0 && idx <=  ").concat(s,") {\n            float z = getX(b, r, c, idx);\n            sum += z * z;\n          }\n        }\n        float val = x * ").concat(i,";\n        setOutput(val);\n      }\n    ")}}class JB{constructor(e,t,n,a,r){this.variableNames=["x"],this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0;const o=t,s=e[3]-1;let i;this.outputShape=e;const c="float(".concat(n,") + float(").concat(a,") * sum");i=.5===r?"inversesqrt(".concat(c,")"):1===r?"1.0/(".concat(c,")"):"exp(log(".concat(c,") * float(-").concat(r,"));"),this.userCode="\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords.x;\n        int r = coords.y;\n        int c = coords.z;\n        int d = coords.w;\n\n        bool hasNextCol = d < ".concat(this.outputShape[3],";\n        bool hasNextRow = c < ").concat(this.outputShape[2],";\n\n        vec4 sum = vec4(0.);\n        vec4 xFragAtOutputCoords = getX(b, r, c, d);\n\n        vec4 xAtOutputCoords = vec4(\n          getChannel(xFragAtOutputCoords, vec2(c, d)),\n          hasNextCol ?\n            getChannel(xFragAtOutputCoords, vec2(c, d + 1)) : 0.0,\n          hasNextRow ?\n            getChannel(xFragAtOutputCoords , vec2(c + 1, d)) : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getChannel(xFragAtOutputCoords, vec2(c + 1, d + 1)) : 0.0\n        );\n\n        int firstChannel = d - ").concat(o,";\n        vec2 cache = vec2(0.);\n        if(firstChannel >= 0){\n          vec4 firstChannelFrag = getX(b, r, c, firstChannel);\n          cache.x = getChannel(firstChannelFrag, vec2(c, firstChannel));\n            if(hasNextRow){\n              cache.y = getChannel(firstChannelFrag, vec2(c + 1, firstChannel));\n            }\n        }\n\n        ivec2 depth = ivec2(d, d + 1);\n        for (int j = - ").concat(o,"; j <= ").concat(o,"; j++) {\n          ivec2 idx = depth + j;\n          bvec2 aboveLowerBound = greaterThanEqual(idx, ivec2(0));\n          bvec2 belowUpperBound = lessThanEqual(idx, ivec2(").concat(s,"));\n\n          bool depthInRange = aboveLowerBound.x && belowUpperBound.x;\n          bool depthPlusOneInRange = aboveLowerBound.y && belowUpperBound.y;\n\n          if(depthInRange || depthPlusOneInRange){\n            vec4 z = vec4(0.);\n            vec4 xFragAtCurrentDepth;\n            z.xz = cache.xy;\n            if(depthPlusOneInRange && hasNextCol){\n              xFragAtCurrentDepth = idx.y != d ?\n                getX(b, r, c, idx.y) : xFragAtOutputCoords;\n              z.y = getChannel(xFragAtCurrentDepth, vec2(c, idx.y));\n              if(hasNextRow){\n                z.w = getChannel(xFragAtCurrentDepth, vec2(c + 1, idx.y));\n              }\n            }\n            cache.xy = z.yw;\n            sum += z * z;\n          }\n        }\n        vec4 result = xAtOutputCoords * ").concat(i,";\n        setOutput(result);\n      }\n    ")}}const ZB={kernelName:_i,backendName:"webgl",kernelFunc:e=>{const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{depthRadius:o,bias:s,alpha:i,beta:c}=a,l=Yo().getBool("WEBGL_PACK_NORMALIZATION")?new JB(r.shape,o,s,i,c):new QB(r.shape,o,s,i,c);return n.runWebGLProgram(l,[r],r.dtype)}};class $B{constructor(e,t,n,a,r){this.variableNames=["inputImage","outputImage","dy"],this.outputShape=[],this.outputShape=e,this.depth=e[3],this.depthRadius=t,this.bias=n,this.alpha=a,this.beta=r,this.userCode="\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int r = coords[1];\n        int c = coords[2];\n\n        float result = 0.0;\n        for (int d = 0; d < ".concat(this.depth,"; ++d) {\n          int depthBegin = int(max(0.0, float(d - ").concat(t,")));\n          int depthEnd = int(min(float(").concat(this.depth,"),\n              float(d + ").concat(t," + 1)));\n\n          const int MIN_DEPTH_BEGIN = 0;\n          const int MAX_DEPTH_END = ").concat(this.depth,";\n\n          float norm = 0.0;\n          for (int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k) {\n            if (k < depthBegin){\n              continue;\n            }\n            else if (k >= depthBegin && k < depthEnd) {\n              norm += getInputImage(b, r, c, k) * getInputImage(b, r, c, k);\n            }\n            else {\n              break;\n            }\n          }\n\n          norm = float(").concat(a,") * norm + float(").concat(n,");\n\n          for(int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k){\n            if (k < depthBegin){\n              continue;\n            }\n            else if (k >= depthBegin && k < depthEnd){\n              float dyi = -2.0 * float(").concat(a,")\n                * float(").concat(r,")\n                * getInputImage(b, r, c, k) * getOutputImage(b, r, c, d)\n                / norm;\n              if (k == d) {\n                dyi += pow(norm, -1.0 * ").concat(r,");\n              }\n              if (k == coords[3]) {\n                dyi *= getDy(b, r, c, d);\n                result += dyi;\n              }\n            }\n            else {\n              break;\n            }\n          }\n      }\n      setOutput(result);\n      }\n    ")}}const eW={kernelName:Ai,backendName:"webgl",kernelFunc:e=>{const{inputs:t,backend:n,attrs:a}=e,{x:r,y:o,dy:s}=t,{depthRadius:i,bias:c,alpha:l,beta:u}=a,d=new $B(r.shape,i,c,l,u);return n.runWebGLProgram(d,[r,o,s],r.dtype)}};function tW(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{reductionIndices:o,keepDims:s}=a,i=r.shape.length,c=No(o,r.shape);let l=c;const u=Xp(l,i),d=null!=u,h=n.shouldExecuteOnCPU([r]);let p=r;if(d){if(h){const e=n.texData.get(p.dataId).values,t=new Array(i);for(let n=0;n<t.length;n++)t[n]=r.shape[u[n]];const a=dM(e,r.shape,r.dtype,u,t);p=n.makeTensorInfo(t,r.dtype);n.texData.get(p.dataId).values=a}else p=yL(r,u,n);l=Qp(l.length,i)}qp("max",l,i);const[f,m]=jp(p.shape,l);let g,b=f;if(s&&(b=Kp(f,c)),h){const e=n.texData.get(p.dataId).values,t=PD(e,yo(m),b,r.dtype);g=n.makeTensorInfo(b,r.dtype);n.texData.get(g.dataId).values=t}else g=function(e,t,n,a){const r=yo(t),o=dL({inputs:{x:e},attrs:{shape:[yo(e.shape)/r,r]},backend:a}),s=mL(o,e.dtype,"max",a),i=dL({inputs:{x:s},attrs:{shape:n},backend:a});return a.disposeIntermediateTensorInfo(o),a.disposeIntermediateTensorInfo(s),i}(p,m,b,n);return d&&n.disposeIntermediateTensorInfo(p),g}const nW={kernelName:Fi,backendName:"webgl",kernelFunc:tW},aW=aL({opSnippet:VM+"\n  return max(a, b);\n",packedOpSnippet:"\n  vec4 result = vec4(max(a, b));\n  bvec4 isNaNA = isnan(a);\n  bvec4 isNaNB = isnan(b);\n  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);\n  "+GM+"\n  return result;\n",cpuKernelImpl:zD}),rW={kernelName:Oi,backendName:"webgl",kernelFunc:aW};const oW={kernelName:Di,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t;EO(r,"maxPool");const{filterSize:o,strides:s,pad:i,dimRoundingMode:c}=a;mo(ep(s,1),(()=>"Error in maxPool: Either strides or dilations must be 1. "+"Got strides ".concat(s," and dilations '").concat(1,"'")));const l=Hh(r.shape,o,s,1,i,c);if(1===l.filterWidth&&1===l.filterHeight&&xo(l.inShape,l.outShape))return jM({inputs:{x:r},backend:n});const u=new aP(l,"max",!1);return n.runWebGLProgram(u,[r],r.dtype)}};const sW={kernelName:Li,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{filterSize:o,strides:s,pad:i,dataFormat:c,dimRoundingMode:l}=a,u=jh(r.shape,o,s,[1,1,1],i,l,c),d=new rP(u,"max",!1);return n.runWebGLProgram(d,[r],r.dtype)}};class iW{constructor(e){this.variableNames=["dy","maxPos"],this.outputShape=e.inShape;const t=e.strideHeight,n=e.strideWidth,a=e.dilationHeight,r=e.effectiveFilterHeight,o=e.effectiveFilterWidth,s=r-1-e.padInfo.top,i=o-1-e.padInfo.left,c=r*o-1;this.userCode="\n      const ivec2 pads = ivec2(".concat(s,", ").concat(i,");\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n\n        ivec2 dyRCCorner = coords.yz - pads;\n        int dyRCorner = dyRCCorner.x;\n        int dyCCorner = dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ").concat(r,";\n          wR += ").concat(a,") {\n          float dyR = float(dyRCorner + wR) / ").concat(t,".0;\n\n          if (dyR < 0.0 || dyR >= ").concat(e.outHeight,".0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          for (int wC = 0; wC < ").concat(o,"; wC++) {\n            float dyC = float(dyCCorner + wC) / ").concat(n,".0;\n\n            if (dyC < 0.0 || dyC >= ").concat(e.outWidth,".0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            float dyValue = getDy(b, idyR, idyC, d);\n            int maxPosValue = ").concat(c," - int(getMaxPos(b, idyR, idyC, d));\n\n            // Get the current value, check it against the value from the\n            // position matrix.\n            int curPosValue = wR * ").concat(o," + wC;\n            float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);\n\n            dotProd += dyValue * mask;\n          }\n        }\n        setOutput(dotProd);\n      }\n    ")}}class cW{constructor(e){this.variableNames=["dy","maxPos"],this.outputShape=e.inShape;const t=e.strideDepth,n=e.strideHeight,a=e.strideWidth,r=e.dilationDepth,o=e.dilationHeight,s=e.dilationWidth,i=e.effectiveFilterDepth,c=e.effectiveFilterHeight,l=e.effectiveFilterWidth,u=i-1-e.padInfo.front,d=c-1-e.padInfo.top,h=l-1-e.padInfo.left,p=i*c*l-1;this.userCode="\n      const ivec3 pads = ivec3(".concat(u,", ").concat(d,", ").concat(h,");\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyDCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        // Convolve dy(?, ?, ?, ch) with pos mask(:, :, :, d) to get\n        // dx(xD, xR, xC, ch).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int wD = 0; wD < ").concat(i,";\n           wD += ").concat(r,") {\n          float dyD = float(dyDCorner + wD) / ").concat(t,".0;\n\n          if (dyD < 0.0 || dyD >= ").concat(e.outDepth,".0 || fract(dyD) > 0.0) {\n            continue;\n          }\n          int idyD = int(dyD);\n\n          for (int wR = 0; wR < ").concat(c,";\n              wR += ").concat(o,") {\n            float dyR = float(dyRCorner + wR) / ").concat(n,".0;\n\n            if (dyR < 0.0 || dyR >= ").concat(e.outHeight,".0 ||\n                fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            for (int wC = 0; wC < ").concat(l,";\n                wC += ").concat(s,") {\n              float dyC = float(dyCCorner + wC) / ").concat(a,".0;\n\n              if (dyC < 0.0 || dyC >= ").concat(e.outWidth,".0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              float dyValue = getDy(batch, idyD, idyR, idyC, ch);\n              int maxPosValue = ").concat(p," -\n                  int(getMaxPos(batch, idyD, idyR, idyC, ch));\n\n              // Get the current value, check it against the value from the\n              // position matrix.\n              int curPosValue =\n                  wD * ").concat(c," * ").concat(l," +\n                  wR * ").concat(l," + wC;\n              float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);\n\n              dotProd += dyValue * mask;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    ")}}const lW={kernelName:Pi,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{dy:r,input:o}=t,s=o,{filterSize:i,strides:c,pad:l,dimRoundingMode:u}=a,d=jh(s.shape,i,c,[1,1,1],l,u),h=new rP(d,"max",!0),p=n.runWebGLProgram(h,[s],s.dtype),f=new cW(d),m=n.runWebGLProgram(f,[r,p],s.dtype);return n.disposeIntermediateTensorInfo(p),m}};const uW={kernelName:Mi,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{dy:r,input:o,output:s}=t,i=o;EO([o,s],"maxPoolGrad");const{filterSize:c,strides:l,pad:u,dimRoundingMode:d}=a,h=Hh(i.shape,c,l,1,u,d),p=new aP(h,"max",!0),f=n.runWebGLProgram(p,[i],i.dtype),m=new iW(h),g=n.runWebGLProgram(m,[r,f],i.dtype);return n.disposeIntermediateTensorInfo(f),g}};const dW={kernelName:zi,backendName:"webgl",kernelFunc:e=>{let{inputs:t,attrs:n,backend:a}=e;const{x:r}=t,{filterSize:o,strides:s,pad:i,includeBatchInIndex:c}=n,l=a;mo(4===r.shape.length,(()=>"Error in maxPool: input must be rank 4 but got rank ".concat(r.shape.length,".")));const u=[1,1];mo(ep(s,u),(()=>"Error in maxPool: Either strides or dilations must be 1. "+"Got strides ".concat(s," and dilations '").concat(u,"'")));const d=Hh(r.shape,o,s,u,i),[h,p]=function(e,t,n,a){let r=new aP(n,"max",!1);const o=a.runWebGLProgram(r,[e],"float32");return r=new aP(n,"max",!0,!0,t),[o,a.runWebGLProgram(r,[e],"float32")]}(r,c,d,l);return[h,p]}};const hW={kernelName:Bi,backendName:"webgl",kernelFunc:e=>{let{inputs:t,attrs:n,backend:a}=e;const{x:r}=t,{keepDims:o,axis:s}=n,i=a,c=r.shape.length,l=No(s,r.shape);let u=l;const d=Xp(u,c),h=null!=d,p=i.shouldExecuteOnCPU([r]),f=[];let m=r;if(h){if(p){const e=i.texData.get(m.dataId).values,t=new Array(c);for(let a=0;a<t.length;a++)t[a]=r.shape[d[a]];const n=dM(e,r.shape,r.dtype,d,t);m=i.makeTensorInfo(t,r.dtype);i.texData.get(m.dataId).values=n}else m=yL(r,d,i);f.push(m),u=Qp(u.length,c)}qp("sum",u,c);const[g,b]=jp(m.shape,u);let y=g;o&&(y=Kp(g,l));const x=function(e,t,n,a){const r=yo(t),o=dL({inputs:{x:e},attrs:{shape:[yo(e.shape)/r,r]},backend:a}),s=mL(o,"float32","mean",a),i=dL({inputs:{x:s},attrs:{shape:n},backend:a});return a.disposeIntermediateTensorInfo(o),a.disposeIntermediateTensorInfo(s),i}(m,b,y,i);for(const v of f)i.disposeIntermediateTensorInfo(v);return x}};const pW={kernelName:Wi,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{axis:o,keepDims:s}=a,i=r.shape.length,c=No(o,r.shape);let l=c;const u=Xp(l,i);let d=r;null!=u&&(d=wL({inputs:{x:r},backend:n,attrs:{perm:u}}),l=Qp(l.length,r.shape.length)),qp("min",l,i);const[h,p]=jp(d.shape,l),f=dL({inputs:{x:d},backend:n,attrs:{shape:[-1,yo(p)]}}),m=mL(f,f.dtype,"min",n);let g;if(s){g=dL({inputs:{x:m},backend:n,attrs:{shape:Kp(h,c)}})}else g=dL({inputs:{x:m},backend:n,attrs:{shape:h}});return n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),null!=u&&n.disposeIntermediateTensorInfo(d),g}},fW=aL({opSnippet:VM+"\n  return min(a, b);\n",packedOpSnippet:"\n  vec4 result = vec4(min(a, b));\n  bvec4 isNaNA = isnan(a);\n  bvec4 isNaNB = isnan(b);\n  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);\n  "+GM+"\n  return result;\n",cpuKernelImpl:BD}),mW={kernelName:Vi,backendName:"webgl",kernelFunc:fW};class gW{constructor(e,t,n){this.variableNames=["x"],this.outputShape=t.map(((t,n)=>t[0]+e[n]+t[1]));const a=e.length,r=KO(a),o=t.map((e=>e[0])).join(","),s=t.map(((t,n)=>t[0]+e[n])).join(","),i=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,a),c="reflect"===n?0:1;this.userCode=1!==a?"\n      ".concat(r," start = ").concat(r,"(").concat(o,");\n      ").concat(r," end = ").concat(r,"(").concat(s,");\n\n      void main() {\n        ").concat(r," outC = getOutputCoords();\n        for (int i = 0; i < ").concat(a,"; i++) {\n          if (outC[i] < start[i]) {\n            outC[i] = start[i] * 2 - outC[i] - ").concat(c,";\n          } else if(outC[i] >= end[i]) {\n            outC[i] = (end[i] - 1) * 2 - outC[i] + ").concat(c,";\n          }\n        }\n        ").concat(r," coords = outC - start;\n        setOutput(getX(").concat(i,"));\n      }\n    "):"\n        int start = ".concat(o,";\n        int end = ").concat(s,";\n\n        void main() {\n          int outC = getOutputCoords();\n          if (outC < start) {\n            outC = start * 2 - outC - ").concat(c,";\n          } else if(outC >= end) {\n            outC = (end - 1) * 2 - outC + ").concat(c,";\n          }\n          setOutput(getX(outC - start));\n        }\n      ")}}class bW{constructor(e,t,n){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t.map(((t,n)=>t[0]+e[n]+t[1]));const a=e.length,r=KO(a),o=t.map((e=>e[0])).join(","),s=t.map(((t,n)=>t[0]+e[n])).join(","),i=fM("rc",a),c=fM("source",a),l="".concat(i[a-1]," < ").concat(this.outputShape[a-1]),u=1===a?"source":"vec2(".concat(c.slice(-2).join(),")"),d="reflect"===n?0:1;let h="";if(1===a){const e="\n        ".concat(r," source = rc;\n        if (source < start) {\n          source = start * 2 - source - ").concat(d,";\n        } else if (source >= end) {\n          source = (end - 1) * 2 - source + ").concat(d,";\n        }\n        source -= start;\n      ");h="\n        ".concat(r," rc = outputLoc;\n        ").concat(e,"\n        result[0] = getChannel(getX(").concat(c.join(),"), ").concat(u,");\n        ").concat(i[a-1]," += 1;\n        if(").concat(l,") {\n          ").concat(e,"\n          result[1] = getChannel(getX(").concat(c.join(),"), ").concat(u,");\n        }\n      ")}else{const e="\n        ".concat(r," source = rc;\n        ").concat(r," lt = ").concat(r,"(lessThan(source, start));\n        ").concat(r," gte = ").concat(r,"(greaterThanEqual(source, end));\n        ").concat(r," orig = 1 - (lt + gte);\n        source = orig * source +\n                lt * (start * 2 - source - ").concat(d,") +\n                gte * ((end - 1) * 2 - source + ").concat(d,");\n        source -= start;\n      ");h="\n        ".concat(r," rc = outputLoc;\n        ").concat(e,"\n        result[0] = getChannel(getX(").concat(c.join(),"), ").concat(u,");\n        ").concat(i[a-1]," += 1;\n        if(").concat(l,") {\n          ").concat(e,"\n          result[1] = getChannel(getX(").concat(c.join(),"), ").concat(u,");\n        }\n        rc = outputLoc;\n        ").concat(i[a-2]," += 1;\n        if(").concat(i[a-2]," < ").concat(this.outputShape[a-2],") {\n          ").concat(e,"\n          result[2] = getChannel(getX(").concat(c.join(),"), ").concat(u,");\n          ").concat(i[a-1]," += 1;\n          if(").concat(l,") {\n            ").concat(e,"\n            result[3] = getChannel(getX(").concat(c.join(),"), ").concat(u,");\n          }\n        }\n      ")}this.userCode="\n      const ".concat(r," start = ").concat(r,"(").concat(o,");\n      const ").concat(r," end = ").concat(r,"(").concat(s,");\n\n      void main() {\n        ").concat(r," outputLoc = getOutputCoords();\n        vec4 result = vec4(0.);\n        ").concat(h,"\n        setOutput(result);\n      }\n    ")}}const yW={kernelName:Ui,backendName:"webgl",kernelFunc:e=>{let{inputs:t,backend:n,attrs:a}=e;const{x:r}=t,{paddings:o,mode:s}=a,i=Yo().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new bW(r.shape,o,s):new gW(r.shape,o,s);return n.runWebGLProgram(i,[r],r.dtype)}},xW=aL({opSnippet:"if (b == 0.0) return NAN;\n  return mod(a, b);",packedOpSnippet:"\n  vec4 result = mod(a, b);\n  bvec4 isNaN = equal(b, vec4(0.0));\n  "+GM+"\n  return result;\n"}),vW={kernelName:Gi,backendName:"webgl",kernelFunc:xW};class wW{constructor(e,t,n){this.variableNames=["probs"],this.customUniforms=[{name:"seed",type:"float"}],this.outputShape=[e,n],this.userCode="\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n\n        float r = random(seed);\n        float cdf = 0.0;\n\n        for (int i = 0; i < ".concat(t-1,"; i++) {\n          cdf += getProbs(batch, i);\n\n          if (r < cdf) {\n            setOutput(float(i));\n            return;\n          }\n        }\n\n        // If no other event happened, last event happened.\n        setOutput(float(").concat(t-1,"));\n      }\n    ")}}const kW=aL({opSnippet:"\nif (a == b) {\n  return 1.0;\n};\nreturn a / b;",packedOpSnippet:"\n  // vec4 one = vec4(equal(a, b));\n  // return one + (vec4(1.0) - one) * a / b;\n  vec4 result = a / b;\n  if(a.x == b.x) {\n    result.x = 1.;\n  }\n  if(a.y == b.y) {\n    result.y = 1.;\n  }\n  if(a.z == b.z) {\n    result.z = 1.;\n  }\n  if(a.w == b.w) {\n    result.w = 1.;\n  }\n\n  return result;\n",checkOutOfBounds:!0}),IW={kernelName:Qs,backendName:"webgl",kernelFunc:kW},SW="return a - b;",NW=aL({opSnippet:SW,packedOpSnippet:SW,supportsComplex:!0,cpuKernelImpl:cM}),CW={kernelName:Xc,backendName:"webgl",kernelFunc:NW};function TW(e){const{inputs:t,backend:n,attrs:a}=e,{logits:r}=t,{dim:o}=a,s=No([o],r.shape),i=tW({inputs:{x:r},backend:n,attrs:{reductionIndices:s,keepDims:!1}}),c=Kp(i.shape,s),l=dL({inputs:{x:i},backend:n,attrs:{shape:c}}),u=NW({inputs:{a:r,b:l},backend:n}),d=Kz({inputs:{x:u},backend:n}),h=xL({inputs:{x:d},backend:n,attrs:{axis:s,keepDims:!1}}),p=dL({inputs:{x:h},backend:n,attrs:{shape:c}}),f=kW({inputs:{a:d,b:p},backend:n});return n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(l),n.disposeIntermediateTensorInfo(u),n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(p),f}const EW={kernelName:Mc,backendName:"webgl",kernelFunc:TW};const RW={kernelName:Hi,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{logits:r}=t,{numSamples:o,seed:s,normalized:i}=a,c=i?r:TW({inputs:{logits:r},backend:n,attrs:{dim:r.shape.length-1}}),l=c.shape[0],u=c.shape[1],d=new wW(l,u,o),h=[[s]],p=n.runWebGLProgram(d,[c],"int32",h);return i||n.disposeIntermediateTensorInfo(c),p}},_W=kM+"\n  return -x;\n";const AW={kernelName:Ki,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{x:a}=t;if(n.shouldExecuteOnCPU([a])){const e=n.texData.get(a.dataId),[t,r]=VD(e.values,a.shape,a.dtype);return n.makeTensorInfo(r,a.dtype,t)}let r;return r=Yo().getBool("WEBGL_PACK_UNARY_OPERATIONS")?new MM(a.shape,"\n  vec4 result = -x;\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n"):new wM(a.shape,_W),n.runWebGLProgram(r,[a],a.dtype)}},FW=bm;const OW={kernelName:Xi,backendName:"webgl",kernelFunc:function(e){dl("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:t,backend:n,attrs:a}=e,{boxes:r,scores:o}=t,{maxOutputSize:s,iouThreshold:i,scoreThreshold:c}=a,l=n.readSync(r.dataId),u=n.readSync(o.dataId),{selectedIndices:d}=FW(l,u,s,i,c);return n.makeTensorInfo([d.length],"int32",new Int32Array(d))}},DW=ym;const MW={kernelName:Yi,backendName:"webgl",kernelFunc:function(e){dl("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:t,backend:n,attrs:a}=e,{boxes:r,scores:o}=t,{maxOutputSize:s,iouThreshold:i,scoreThreshold:c,padToMaxOutputSize:l}=a,u=n.readSync(r.dataId),d=n.readSync(o.dataId),{selectedIndices:h,validOutputs:p}=DW(u,d,s,i,c,l);return[n.makeTensorInfo([h.length],"int32",new Int32Array(h)),n.makeTensorInfo([],"int32",new Int32Array([p]))]}},LW=xm;const PW={kernelName:Qi,backendName:"webgl",kernelFunc:function(e){dl("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:t,backend:n,attrs:a}=e,{boxes:r,scores:o}=t,{maxOutputSize:s,iouThreshold:i,scoreThreshold:c,softNmsSigma:l}=a,u=n.readSync(r.dataId),d=n.readSync(o.dataId),h=s,p=i,f=c,m=l,{selectedIndices:g,selectedScores:b}=LW(u,d,h,p,f,m);return[n.makeTensorInfo([g.length],"int32",new Int32Array(g)),n.makeTensorInfo([b.length],"float32",new Float32Array(b))]}};class zW{constructor(e,t,n,a){this.variableNames=["indices"],this.outputShape=[e,t],this.userCode="\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int index = round(getIndices(coords.x));\n        setOutput(mix(float(".concat(a,"), float(").concat(n,"),\n                      float(index == coords.y)));\n      }\n    ")}}const BW={kernelName:Zi,backendName:"webgl",kernelFunc:e=>{const{inputs:t,backend:n,attrs:a}=e,{indices:r}=t,{dtype:o,depth:s,onValue:i,offValue:c}=a,l=yo(r.shape),u=new zW(l,s,i,c),d=dL({inputs:{x:r},backend:n,attrs:{shape:[l]}}),h=n.runWebGLProgram(u,[d],o);n.disposeIntermediateTensorInfo(d);const p=dL({inputs:{x:h},backend:n,attrs:{shape:[...r.shape,s]}});return n.disposeIntermediateTensorInfo(h),p}};function WW(e){const{inputs:t,backend:n}=e,{x:a}=t;if("complex64"===a.dtype){const e=CP({inputs:{input:a},backend:n}),t=WW({inputs:{x:e},backend:n}),r=UP({inputs:{input:a},backend:n}),o=WW({inputs:{x:r},backend:n}),s=qM({inputs:{real:t,imag:o},backend:n});return n.disposeIntermediateTensorInfo(e),n.disposeIntermediateTensorInfo(t),n.disposeIntermediateTensorInfo(r),n.disposeIntermediateTensorInfo(o),s}return aB({attrs:{shape:a.shape,dtype:a.dtype,value:"string"===a.dtype?"":0},backend:n})}const VW={kernelName:rl,backendName:"webgl",kernelFunc:WW};const UW={kernelName:Ji,backendName:"webgl",kernelFunc:function e(t){const{inputs:n,backend:a}=t,{x:r}=n;if("string"===r.dtype)throw new Error("onesLike is not supported under string dtype");if("complex64"===r.dtype){const t=CP({inputs:{input:r},backend:a}),n=e({inputs:{x:t},backend:a}),o=UP({inputs:{input:r},backend:a}),s=WW({inputs:{x:o},backend:a}),i=qM({inputs:{real:n,imag:s},backend:a});return a.disposeIntermediateTensorInfo(t),a.disposeIntermediateTensorInfo(n),a.disposeIntermediateTensorInfo(o),a.disposeIntermediateTensorInfo(s),i}return aB({attrs:{shape:r.shape,dtype:r.dtype,value:1},backend:a})}};const GW={kernelName:$i,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{axis:r}=a;if(1===t.length)return Xz({inputs:{input:t[0]},backend:n,attrs:{dim:r}});const o=t[0].shape,s=t[0].dtype;t.forEach((e=>{go(o,e.shape,"All tensors passed to stack must have matching shapes"),mo(s===e.dtype,(()=>"All tensors passed to stack must have matching dtypes"))}));const i=[],c=t.map((e=>{const t=Xz({inputs:{input:e},backend:n,attrs:{dim:r}});return i.push(t),t})),l=jP({inputs:c,backend:n,attrs:{axis:r}});return i.forEach((e=>n.disposeIntermediateTensorInfo(e))),l}};class HW{constructor(e,t,n){this.variableNames=["x"],this.customUniforms=[{name:"value",type:"float"}],this.outputShape=t.map(((t,n)=>t[0]+e[n]+t[1]));const a=e.length,r=KO(a),o=t.map((e=>e[0])).join(","),s=t.map(((t,n)=>t[0]+e[n])).join(","),i=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,a);this.userCode=1!==a?"\n      ".concat(r," start = ").concat(r,"(").concat(o,");\n      ").concat(r," end = ").concat(r,"(").concat(s,");\n\n      void main() {\n        ").concat(r," outC = getOutputCoords();\n        if (any(lessThan(outC, start)) || any(greaterThanEqual(outC, end))) {\n          setOutput(value);\n        } else {\n          ").concat(r," coords = outC - start;\n          setOutput(getX(").concat(i,"));\n        }\n      }\n    "):"\n        int start = ".concat(o,";\n        int end = ").concat(s,";\n\n        void main() {\n          int outC = getOutputCoords();\n          if (outC < start || outC >= end) {\n            setOutput(value);\n          } else {\n            setOutput(getX(outC - start));\n          }\n        }\n      ")}}class jW{constructor(e,t,n){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"value",type:"float"}],this.outputShape=t.map(((t,n)=>t[0]+e[n]+t[1]));const a=e.length,r=KO(a),o=t.map((e=>e[0])).join(","),s=t.map(((t,n)=>t[0]+e[n])).join(","),i=fM("rc",a),c=fM("source",a),l="".concat(i[a-1]," < ").concat(this.outputShape[a-1]),u=1===a?"source":"vec2(".concat(c.slice(-2).join(),")"),d=["".concat(r," rc = outputLoc;"),"".concat(i[a-1]," += 1;\n       if(").concat(l,") {\n      "),1===a?"":"}\n       rc = outputLoc;\n       ".concat(i[a-2]," += 1;\n       if(").concat(i[a-2]," < ").concat(this.outputShape[a-2],") {"),1===a?"":"  ".concat(i[a-1]," += 1;\n         if(").concat(l,") {")],h=1===a?"rc < start || rc >= end":"any(lessThan(rc, start)) || any(greaterThanEqual(rc, end))";let p="";for(let f=0,m=1===a?2:4;f<m;f++)p+="\n        ".concat(d[f],"\n        if (").concat(h,") {\n          result[").concat(f,"] = float(value);\n        } else {\n          ").concat(r," source = rc - start;\n          result[").concat(f,"] = getChannel(getX(").concat(c.join(),"), ").concat(u,");\n        }\n      ");p+=1===a?"} ":"}}",this.userCode="\n      const ".concat(r," start = ").concat(r,"(").concat(o,");\n      const ").concat(r," end = ").concat(r,"(").concat(s,");\n\n      void main() {\n        ").concat(r," outputLoc = getOutputCoords();\n        vec4 result = vec4(0.);\n        ").concat(p,"\n        setOutput(result);\n      }\n    ")}}const KW=e=>{const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{paddings:o,constantValue:s}=a;if(0===yo(r.shape)){const e=o.map(((e,t)=>e[0]+r.shape[t]+e[1]));return aB({backend:n,attrs:{shape:e,value:s,dtype:r.dtype}})}const i=Yo().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new jW(r.shape,o,s):new HW(r.shape,o,s),c=[[s]];return n.runWebGLProgram(i,[r],r.dtype,c)},qW={kernelName:ec,backendName:"webgl",kernelFunc:KW},XW=aL({opSnippet:"\n  if(a < 0.0 && floor(b) < b){\n    return NAN;\n  }\n  if (b == 0.0) {\n    return 1.0;\n  }\n  return (round(mod(b, 2.0)) != 1) ?\n      pow(abs(a), b) : sign(a) * pow(abs(a), b);\n",packedOpSnippet:"\n  // isModRound1 has 1 for components with round(mod(b, 2.0)) == 1, 0 otherwise.\n  vec4 isModRound1 = vec4(equal(round(mod(b, 2.0)), ivec4(1)));\n  vec4 multiplier = sign(a) * isModRound1 + (vec4(1.0) - isModRound1);\n  vec4 result = multiplier * pow(abs(a), b);\n\n  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS\n  bvec4 isExpZero = equal(b, vec4(0.0));\n  result.r = isExpZero.r ? 1.0 : result.r;\n  result.g = isExpZero.g ? 1.0 : result.g;\n  result.b = isExpZero.b ? 1.0 : result.b;\n  result.a = isExpZero.a ? 1.0 : result.a;\n\n  bvec4 isNaN1 = lessThan(a, vec4(0.0));\n  bvec4 isNaN2 = lessThan(floor(b), b);\n  bvec4 isNaN = bvec4(isNaN1.x && isNaN2.x, isNaN1.y && isNaN2.y, isNaN1.z && isNaN2.z, isNaN1.w && isNaN2.w);\n  "+GM+"\n  return result;\n"}),YW={kernelName:tc,backendName:"webgl",kernelFunc:XW};const QW={kernelName:ac,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{axis:o,keepDims:s}=a,i=r.shape.length,c=[],l=No(o,r.shape);let u=l;const d=Xp(u,i);let h,p=r;if(null!=d&&(p=wL({inputs:{x:r},backend:n,attrs:{perm:d}}),u=Qp(u.length,i),c.push(p)),qp("prod",u,i),n.shouldExecuteOnCPU([p])){const e=n.texData.get(p.dataId).values,{outVals:t,outShape:a,outDtype:r}=GD(p.shape,p.dtype,e,u);h=n.makeTensorInfo(a,r,t)}else{const[e,t]=jp(p.shape,u),a=yo(t),o=dL({inputs:{x:p},backend:n,attrs:{shape:[-1,a]}}),s=mL(o,mu(r.dtype),"prod",n);h=dL({inputs:{x:s},backend:n,attrs:{shape:e}}),c.push(o),c.push(s)}if(s){c.push(h);const e=Kp(h.shape,l);h=dL({inputs:{x:h},backend:n,attrs:{shape:e}})}return c.forEach((e=>n.disposeIntermediateTensorInfo(e))),h}};const JW={kernelName:rc,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{paramsNestedSplits:r,paramsDenseValues:o,indices:s}=t,{outputRaggedRank:i}=a,c=r.map((e=>n.readSync(e.dataId))),l=r.map((e=>e.shape)),u=n.readSync(o.dataId),d=n.readSync(s.dataId),[h,p,f]=HD(c,l,u,o.shape,o.dtype,d,s.shape,i),m=h.map((e=>n.makeTensorInfo([e.length],"int32",e))),g=n.makeTensorInfo(f,o.dtype,p);return m.concat([g])}};const ZW={kernelName:oc,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{starts:a,limits:r,deltas:o}=t,s=n.readSync(a.dataId),i=n.readSync(r.dataId),c=n.readSync(o.dataId),[l,u]=jD(s,a.shape,a.dtype,i,r.shape,c,o.shape);return[n.makeTensorInfo([l.length],"int32",l),n.makeTensorInfo([u.length],a.dtype,u)]}};const $W={kernelName:sc,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{shape:r,values:o,defaultValue:s,rowPartitionTensors:i}=t,{rowPartitionTypes:c}=a,l=n.readSync(r.dataId),u=n.readSync(o.dataId),d=n.readSync(s.dataId),h=i.map((e=>n.readSync(e.dataId))),p=i.map((e=>e.shape)),[f,m]=KD(l,r.shape,u,o.shape,o.dtype,d,s.shape,h,p,c);return n.makeTensorInfo(f,o.dtype,m)}},eV=e=>{const{backend:t,attrs:n}=e,{start:a,stop:r,step:o,dtype:s}=n,i=qD(a,r,o,s);return t.makeTensorInfo([i.length],s,i)},tV={kernelName:ic,backendName:"webgl",kernelFunc:eV},nV=nL({opSnippet:"return 1.0 / x;"}),aV={kernelName:lc,backendName:"webgl",kernelFunc:nV},rV=nL({opSnippet:kM+"\n  return (x < 0.0) ? 0.0 : x;\n",packedOpSnippet:"\n  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n"}),oV={kernelName:uc,backendName:"webgl",kernelFunc:rV},sV=nL({opSnippet:kM+"\n  return (x < 0.0) ? 0.0 : min(6.0, x);\n",packedOpSnippet:"\n  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n"}),iV={kernelName:gc,backendName:"webgl",kernelFunc:sV};class cV{constructor(e,t,n,a,r){this.variableNames=["A"],this.outputShape=[];const[o,s,i,c]=e;this.outputShape=[o,t,n,c];const l=[a&&t>1?s-1:s,a&&n>1?i-1:i],u=[a&&t>1?t-1:t,a&&n>1?n-1:n];let d;d=r?"(vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC - vec2(0.5)":"vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode="\n      const vec2 effectiveInputOverOutputRatioRC = vec2(\n          ".concat(l[0]/u[0],",\n          ").concat(l[1]/u[1],");\n      const vec2 inputShapeRC = vec2(").concat(s,".0, ").concat(i,".0);\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        ivec2 yRC = coords.yz;\n\n        // Fractional source index.\n        vec2 sourceFracIndexRC = ").concat(d,";\n\n        // Compute the four integer indices.\n        ivec2 sourceFloorRC = ivec2(max(sourceFracIndexRC, vec2(0.0)));\n        ivec2 sourceCeilRC = ivec2(\n          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));\n\n        float topLeft = getA(b, sourceFloorRC.x, sourceFloorRC.y, d);\n        float bottomLeft = getA(b, sourceCeilRC.x, sourceFloorRC.y, d);\n        float topRight = getA(b, sourceFloorRC.x, sourceCeilRC.y, d);\n        float bottomRight = getA(b, sourceCeilRC.x, sourceCeilRC.y, d);\n\n        vec2 fracRC = sourceFracIndexRC - vec2(sourceFloorRC);\n\n        float top = topLeft + (topRight - topLeft) * fracRC.y;\n        float bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;\n        float newValue = top + (bottom - top) * fracRC.x;\n\n        setOutput(newValue);\n      }\n    ")}}class lV{constructor(e,t,n,a,r){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];const[o,s,i,c]=e;this.outputShape=[o,t,n,c];const l=[a&&t>1?s-1:s,a&&n>1?i-1:i],u=[a&&t>1?t-1:t,a&&n>1?n-1:n];let d;d=r?"(vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC - vec3(0.5)":"vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode="\n      const vec3 effectiveInputOverOutputRatioRC = vec3(\n          ".concat(l[0]/u[0],",\n          ").concat(l[1]/u[1],",\n          ").concat(l[1]/u[1],");\n      const vec3 inputShapeRC = vec3(").concat(s,".0, ").concat(i,".0,\n                                     ").concat(i,".0);\n\n      float getAValue(int b, int r, int c, int d) {\n        return getChannel(getA(b, r, c, d), vec2(c, d));\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        // Calculate values for next column in yRC.z.\n        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);\n\n        // Fractional source index.\n        vec3 sourceFracIndexRC = ").concat(d,";\n\n        // Compute the four integer indices.\n        ivec3 sourceFloorRC = ivec3(max(sourceFracIndexRC, vec3(0.0)));\n        ivec3 sourceCeilRC = ivec3(\n          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));\n\n        // Should we calculate next column and row elements in 2x2 packed cell.\n        bool hasNextCol = d < ").concat(c-1,";\n        bool hasNextRow = coords.z < ").concat(n-1,";\n\n        // In parallel, construct four corners for all four components in\n        // packed 2x2 cell.\n        vec4 topLeft = vec4(\n          getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d),\n          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d + 1) : 0.0);\n\n        vec4 bottomLeft = vec4(\n          getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d),\n          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d + 1) : 0.0);\n\n        vec4 topRight = vec4(\n          getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d),\n          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d + 1) : 0.0);\n\n        vec4 bottomRight = vec4(\n          getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d),\n          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d + 1) : 0.0);\n\n        vec3 fracRC = sourceFracIndexRC - vec3(sourceFloorRC);\n\n        vec4 top = mix(topLeft, topRight, fracRC.yyzz);\n        vec4 bottom = mix(bottomLeft, bottomRight, fracRC.yyzz);\n        vec4 newValue = mix(top, bottom, fracRC.x);\n\n        setOutput(newValue);\n      }\n    ")}}const uV={kernelName:fc,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{images:r}=t,{alignCorners:o,halfPixelCenters:s,size:i}=a,[c,l]=i,u=Yo().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new lV(r.shape,c,l,o,s):new cV(r.shape,c,l,o,s);return n.runWebGLProgram(u,[r],"float32")}};class dV{constructor(e,t,n){this.variableNames=["dy"],this.outputShape=[],this.outputShape=t;const[,a,r]=t,[,o,s]=e,i=[n&&o>1?a-1:a,n&&s>1?r-1:r],c=[n&&o>1?o-1:o,n&&s>1?s-1:s],l=i[0]/c[0],u=i[1]/c[1],d=1/l,h=1/u,p=2*Math.ceil(d)+2,f=2*Math.ceil(h)+2;this.userCode="\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        int r = coords[1];\n        int c = coords[2];\n\n        float accumulator = 0.0;\n\n        const float heightScale = float(".concat(l,");\n        const float widthScale = float(").concat(u,");\n\n        const float invHeightScale = float(").concat(d,");\n        const float invWidthScale = float(").concat(h,");\n\n        const int winHeight = int(").concat(p,");\n        const int winWidth = int(").concat(f,");\n\n        // Compute bounds for where in dy we will look\n        float startRLerp = floor(float(r) * invHeightScale);\n        int startDyR = int(startRLerp - float(winHeight / 2));\n\n        float startCLerp = floor(float(c) * invWidthScale);\n        int startDyC = int(startCLerp - float(winWidth / 2));\n\n        // Loop over dy\n        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {\n          int dyR = dyROffset + startDyR;\n\n          // Guard against the window exceeding the bounds of dy\n          if (dyR < 0 || dyR >= ").concat(o,") {\n            continue;\n          }\n\n          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {\n            int dyC = dyCOffset + startDyC;\n\n            // Guard against the window exceeding the bounds of dy\n            if (dyC < 0 || dyC >= ").concat(s,") {\n              continue;\n            }\n\n            float dxR = float(dyR) * heightScale;\n            int topDxRIndex = int(floor(dxR));\n            int bottomDxRIndex = int(min(ceil(dxR), ").concat(a-1,".0));\n            float dxRLerp = dxR - float(topDxRIndex);\n            float inverseDxRLerp = 1.0 - dxRLerp;\n\n            float dxC = float(dyC) * widthScale;\n            int leftDxCIndex = int(floor(dxC));\n            int rightDxCIndex = int(min(ceil(dxC), ").concat(r-1,".0));\n            float dxCLerp = dxC - float(leftDxCIndex);\n            float inverseDxCLerp = 1.0 - dxCLerp;\n\n            if (r == topDxRIndex && c == leftDxCIndex) {\n              // topLeft\n              accumulator +=\n                getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;\n            }\n\n            if (r == topDxRIndex && c == rightDxCIndex) {\n              // topRight\n              accumulator += getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;\n            }\n\n            if (r == bottomDxRIndex && c == leftDxCIndex) {\n              // bottomLeft\n              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;\n            }\n\n            if (r == bottomDxRIndex && c == rightDxCIndex) {\n              // bottomRight\n              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;\n            }\n          }\n        }\n        // End loop over dy\n\n        setOutput(accumulator);\n      }\n    ")}}const hV={kernelName:mc,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{images:r,dy:o}=t,{alignCorners:s}=a,i=new dV(o.shape,r.shape,s);return n.runWebGLProgram(i,[o],o.dtype)}};class pV{constructor(e,t,n,a,r){this.variableNames=["A"],this.outputShape=[];const[o,s,i,c]=e;this.outputShape=[o,t,n,c];const l=[a&&t>1?s-1:s,a&&n>1?i-1:i],u=[a&&t>1?t-1:t,a&&n>1?n-1:n],d=a?"0.5":"0.0";let h;h=r?"max((vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC, vec2(0.0))":"vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode="\n      const vec2 effectiveInputOverOutputRatioRC = vec2(\n          ".concat(l[0]/u[0],",\n          ").concat(l[1]/u[1],");\n      const vec2 inputShapeRC = vec2(").concat(s,".0, ").concat(i,".0);\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        ivec2 yRC = coords.yz;\n\n        // Fractional source index.\n        vec2 sourceFracIndexRC = ").concat(h,";\n\n        // Compute the coordinators of nearest neighbor point.\n        ivec2 sourceNearestRC = ivec2(\n          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ").concat(d,")));\n        float newValue = getA(b, sourceNearestRC.x, sourceNearestRC.y, d);\n\n        setOutput(newValue);\n      }\n    ")}}class fV{constructor(e,t,n,a,r){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];const[o,s,i,c]=e;this.outputShape=[o,t,n,c];const l=[a&&t>1?s-1:s,a&&n>1?i-1:i],u=[a&&t>1?t-1:t,a&&n>1?n-1:n],d=a?"0.5":"0.0";let h;h=r?"max((vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC, vec3(0.0))":"vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode="\n      const vec3 effectiveInputOverOutputRatioRC = vec3(\n          ".concat(l[0]/u[0],",\n          ").concat(l[1]/u[1],",\n          ").concat(l[1]/u[1],");\n      const vec3 inputShapeRC = vec3(").concat(s,".0, ").concat(i,".0,\n                                     ").concat(i,".0);\n\n      float getAValue(int b, int r, int c, int d) {\n        return getChannel(getA(b, r, c, d), vec2(c, d));\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        // Calculate values for next column in yRC.z.\n        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);\n\n        // Fractional source index.\n        vec3 sourceFracIndexRC = ").concat(h,";\n\n        // Compute the coordinators of nearest neighbor point.\n        ivec3 sourceNearestRC = ivec3(\n          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ").concat(d,")));\n\n        // Should we calculate next column and row elements in 2x2 packed cell.\n        bool hasNextCol = d < ").concat(c-1,";\n        bool hasNextRow = coords.z < ").concat(n-1,";\n\n        vec4 newValue = vec4(\n          getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d),\n          hasNextCol ? getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d + 1) : 0.0);\n\n        setOutput(newValue);\n      }\n    ")}}const mV={kernelName:hc,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{images:r}=t,{alignCorners:o,halfPixelCenters:s,size:i}=a,[c,l]=i,u=Yo().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new fV(r.shape,c,l,o,s):new pV(r.shape,c,l,o,s);return n.runWebGLProgram(u,[r],r.dtype)}};class gV{constructor(e,t,n){this.variableNames=["dy"],this.outputShape=[],this.outputShape=t;const[,a,r]=t,[,o,s]=e,i=[n&&o>1?a-1:a,n&&s>1?r-1:r],c=[n&&o>1?o-1:o,n&&s>1?s-1:s],l=i[0]/c[0],u=i[1]/c[1],d=1/l,h=1/u,p=2*Math.ceil(d)+2,f=2*Math.ceil(h)+2;this.userCode="\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        int r = coords[1];\n        int c = coords[2];\n\n        float accumulator = 0.0;\n\n        const float heightScale = float(".concat(l,");\n        const float widthScale = float(").concat(u,");\n\n        const float invHeightScale = float(").concat(d,");\n        const float invWidthScale = float(").concat(h,");\n\n        const int winHeight = int(").concat(p,");\n        const int winWidth = int(").concat(f,");\n\n        // Compute bounds for where in dy we will look\n        float startRLerp = floor(float(r) * invHeightScale);\n        int startDyR = int(floor(startRLerp - float(winHeight / 2)));\n\n        float startCLerp = floor(float(c) * invWidthScale);\n        int startDyC = int(floor(startCLerp - float(winWidth / 2)));\n\n        // Loop over dy\n        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {\n          int dyR = dyROffset + startDyR;\n\n          // Guard against the window exceeding the bounds of dy\n          if (dyR < 0 || dyR >= ").concat(o,") {\n            continue;\n          }\n\n          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {\n            int dyC = dyCOffset + startDyC;\n\n            // Guard against the window exceeding the bounds of dy\n            if (dyC < 0 || dyC >= ").concat(s,") {\n              continue;\n            }\n\n            float sourceFracRow =\n              float(").concat(i[0],") *\n                (float(dyR) / float(").concat(c[0],"));\n\n            float sourceFracCol =\n                float(").concat(i[1],") *\n                  (float(dyC) / float(").concat(c[1],"));\n\n            int sourceNearestRow = int(min(\n                float(int(").concat(a,") - 1),\n                ").concat(n," ? float(round(sourceFracRow)) :\n                                  float(floor(sourceFracRow))));\n\n            int sourceNearestCol = int(min(\n                float(int(").concat(r,") - 1),\n                ").concat(n," ? float(round(sourceFracCol)) :\n                                  float(floor(sourceFracCol))));\n\n            if (r == sourceNearestRow && c == sourceNearestCol) {\n              accumulator += getDy(b, dyR, dyC, d);\n            }\n          }\n        }\n        // End loop over dy\n\n        setOutput(accumulator);\n      }\n    ")}}const bV={kernelName:pc,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{images:r,dy:o}=t,{alignCorners:s}=a,i=new gV(o.shape,r.shape,s);return n.runWebGLProgram(i,[o],o.dtype)}};class yV{constructor(e,t){this.variableNames=["x"];const n=e.length;if(n>4)throw new Error("WebGL backend: Reverse of rank-".concat(n," tensor is not yet supported"));if(this.outputShape=e,1===n)return void(this.userCode="\n        void main() {\n          int coord = getOutputCoords();\n          setOutput(getX(".concat(e[0]," - coord - 1));\n        }\n      "));const a=e.map(((n,a)=>(n=>-1!==t.indexOf(n)&&1!==e[n]?"".concat(e[n]," - coords[").concat(n,"] - 1"):"coords[".concat(n,"]"))(a))).join(","),r=KO(n);this.userCode="\n      void main() {\n        ".concat(r," coords = getOutputCoords();\n        setOutput(getX(").concat(a,"));\n      }\n    ")}}class xV{constructor(e,t){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0;const n=e.length;if(n>4)throw new Error("WebGL backend: Reverse of rank-".concat(n," tensor is not yet supported"));this.outputShape=e;const a=fM("rc",n),r="".concat(a[n-1]," + 1 < ").concat(this.outputShape[n-1]),o="".concat(a[n-2]," + 1 < ").concat(this.outputShape[n-2]),s=KO(n);function i(n){const a=e.map(((a,r)=>function(n,a){return-1!==t.indexOf(n)&&1!==e[n]?"".concat(e[n]," - ").concat(a[n]," - 1"):"".concat(a[n])}(r,n))),r=a.join(","),o=a.slice(-2).join(",");return"getChannel(getX(".concat(r,"), vec2(").concat(o,"))")}this.userCode=1===n?"\n        void main(){\n          int rc = getOutputCoords();\n          vec4 result = vec4(0.);\n          result.r = getChannel(getX(".concat(e[0]," - rc - 1),\n            ").concat(e[0]," - rc - 1);\n          if(").concat(r,"){\n              result.g = getChannel(getX(").concat(e[0]," - (rc  + 1) - 1),\n                ").concat(e[0]," - (rc  + 1) - 1);\n          }\n          setOutput(result);\n        }\n      "):"\n        void main() {\n          ".concat(s," rc = getOutputCoords();\n          vec4 result = vec4(0.);\n          result.r = ").concat(function(e){return i(e)}(a.slice()),";\n          if(").concat(r,"){\n            result.g = ").concat(function(e){return e[n-1]="("+e[n-1]+" + 1)",i(e)}(a.slice()),";\n          }\n          if(").concat(o,") {\n            result.b = ").concat(function(e){return e[n-2]="("+e[n-2]+" + 1)",i(e)}(a.slice()),";\n            if(").concat(r,") {\n              result.a = ").concat(function(e){return e[n-1]="("+e[n-1]+" + 1)",e[n-2]="("+e[n-2]+" + 1)",i(e)}(a.slice()),";\n            }\n          }\n          setOutput(result);\n        }\n    ")}}const vV={kernelName:bc,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{dims:o}=a,s=r.shape.length,i=No(o,r.shape);if(0===s)return jM({inputs:{x:r},backend:n});const c=Yo().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new xV(r.shape,i):new yV(r.shape,i);return n.runWebGLProgram(c,[r],r.dtype)}};class wV{constructor(e,t){this.variableNames=["Image"],this.outputShape=[],this.customUniforms=[{name:"params",type:"vec4"}];const n=e[1],a=e[2];this.outputShape=e;let r="";r="number"===typeof t?"float outputValue = ".concat(t.toFixed(2),";"):"\n        vec3 fill = vec3(".concat(t.join(","),");\n        float outputValue = fill[coords[3]];"),this.userCode="\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int x = coords[2];\n          int y = coords[1];\n          float coordXFloat = (float(x) - params[0]) * params[3] -\n            (float(y) - params[1]) * params[2];\n          float coordYFloat = (float(x) - params[0]) * params[2] +\n            (float(y) - params[1]) * params[3];\n          int coordX = int(round(coordXFloat + params[0]));\n          int coordY = int(round(coordYFloat + params[1]));\n          ".concat(r,"\n          if(coordX >= 0 && coordX < ").concat(a," && coordY >= 0 && coordY < ").concat(n,") {\n            outputValue = getImage(coords[0], coordY, coordX, coords[3]);\n          }\n          setOutput(outputValue);\n        }\n    ")}}const kV={kernelName:il,backendName:"webgl",kernelFunc:e=>{let{inputs:t,attrs:n,backend:a}=e;const{image:r}=t,{radians:o,fillValue:s,center:i}=n,c=a,l=new wV(r.shape,s),[u,d]=og(i,r.shape[1],r.shape[2]),h=[[u,d,Math.sin(o),Math.cos(o)]];return c.runWebGLProgram(l,[r],r.dtype,h)}},IV=nL({opSnippet:"\n  // OpenGL ES does not support round function.\n  // The algorithm is based on banker's rounding.\n  float base = floor(x);\n  if ((x - base) < 0.5) {\n    return floor(x);\n  } else if ((x - base) > 0.5) {\n    return ceil(x);\n  } else {\n    if (mod(base, 2.0) == 0.0) {\n      return base;\n    } else {\n      return base + 1.0;\n    }\n  }\n"}),SV={kernelName:yc,backendName:"webgl",kernelFunc:IV},NV=nL({opSnippet:"return inversesqrt(x);",cpuKernelImpl:XD}),CV={kernelName:xc,backendName:"webgl",kernelFunc:NV};class TV{constructor(e,t,n,a,r,o){let s=arguments.length>7&&void 0!==arguments[7]&&arguments[7];this.variableNames=["updates","indices","defaultValue"],this.outputShape=o;const i=KO(r.length),c=KO(o.length);let l="";1===n?l="i":2===n&&(l="i, j");const u="getIndices(".concat(l,")");let d="";1===a?d="i":2===a&&(d="i, coords[1]");const h="getUpdates(".concat(d,")");let p="";s&&(p="coords[0], coords[1]");const f="getDefaultValue(".concat(p,")"),m=t>1?"strides[j]":"strides";this.userCode="\n        ".concat(i," strides = ").concat(i,"(").concat(r,");\n\n        void main() {\n          ").concat(c," coords = getOutputCoords();\n          float sum = 0.0;\n          bool found = false;\n          for (int i = 0; i < ").concat(e,"; i++) {\n            int flattenedIndex = 0;\n            for (int j = 0; j < ").concat(t,"; j++) {\n              int index = round(").concat(u,");\n              flattenedIndex += index * ").concat(m,";\n            }\n            if (flattenedIndex == coords[0]) {\n              sum += ").concat(h,";\n              found = true;\n            }\n          }\n          setOutput(mix(").concat(f,", sum, float(found)));\n        }\n      ")}}class EV{constructor(e,t,n,a,r,o){let s=arguments.length>7&&void 0!==arguments[7]&&arguments[7];this.variableNames=["updates","indices","defaultValue"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=o;const i=KO(r.length),c=KO(o.length);let l="";1===n?l="i":2===n&&(l="i, j");const u="getIndices(".concat(l,")");let d="";1===a?d="i":2===a&&(d="i, coords[1]");const h="getUpdates(".concat(d,")");let p="";s&&(p="coords[0], coords[1]");const f="getDefaultValue(".concat(p,")"),m=t>1?"strides[j]":"strides",g=t>1?"strides[j + 1]":"strides";this.userCode="\n        ".concat(i," strides = ").concat(i,"(").concat(r,");\n\n        void main() {\n          ").concat(c," coords = getOutputCoords();\n          vec4 sum = vec4(0.);\n          vec4 found = vec4(0.);\n          for (int i = 0; i < ").concat(e,"; i+=2) {\n            ivec2 flattenedIndex = ivec2(0);\n            for (int j = 0; j < ").concat(t,"; j+=2) {\n              ivec4 index = round(").concat(u,");\n              flattenedIndex += index.xz * ").concat(m,";\n              if (j + 1 < ").concat(t,") {\n                flattenedIndex += index.yw * ").concat(g,";\n              }\n            }\n            if (flattenedIndex[0] == coords[0] || flattenedIndex[1] == coords[0] ||\n                flattenedIndex[0] == coords[0] + 1 || flattenedIndex[1] == coords[0] + 1) {\n              vec4 updVals = ").concat(h,";\n              if (flattenedIndex[0] == coords[0]) {\n                sum.xy += updVals.xy;\n                found.xy = vec2(1.);\n              } else if (flattenedIndex[0] == coords[0] + 1) {\n                sum.zw += updVals.xy;\n                found.zw = vec2(1.);\n              }\n              if (flattenedIndex[1] == coords[0]) {\n                sum.xy += updVals.zw;\n                found.xy = vec2(1.);\n              } else if (flattenedIndex[1] == coords[0] + 1) {\n                sum.zw += updVals.zw;\n                found.zw = vec2(1.);\n              }\n            }\n          }\n          setOutput(mix(").concat(f,", sum, found));\n        }\n      ")}}const RV={kernelName:vc,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{indices:r,updates:o}=t,{shape:s}=a,{sliceRank:i,numUpdates:c,sliceSize:l,strides:u,outputSize:d}=fg(0,r,s),h=[d/l,l];if(0===d)return n.makeTensorInfo(s,r.dtype);const p=dL({inputs:{x:r},backend:n,attrs:{shape:[c,i]}}),f=dL({inputs:{x:o},backend:n,attrs:{shape:[c,l]}}),m=n.makeTensorInfo([],"float32",new Float32Array([0]));let g;g=Yo().getBool("WEBGL_PACK")?new EV(c,i,p.shape.length,f.shape.length,u,h):new TV(c,i,p.shape.length,f.shape.length,u,h);const b=n.runWebGLProgram(g,[f,p,m],f.dtype),y=dL({inputs:{x:b},backend:n,attrs:{shape:s}});return n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(b),n.disposeIntermediateTensorInfo(m),y}};class _V{constructor(e,t,n,a){this.variableNames=["sortedSequence","values"],this.customUniforms=[{name:"numInputs",type:"int"}],this.outputShape=[e,n];const r="for (int i = 0; i < ".concat(Math.ceil(Math.log2(t+1)),"; ++i) { if (left >= right) break;"),o=2===Yo().getNumber("WEBGL_VERSION")?"while (left < right) {":r,s="left"===a?"<":"<=";this.userCode="\n       int findBound(int batch, float value) {\n         int left = 0;\n         int right = numInputs;\n         int mid;\n         ".concat(o,"\n           mid = (left + right) / 2;\n           if (getSortedSequence(batch, mid) ").concat(s," value) {\n             left = mid + 1;\n           } else {\n             right = mid;\n           }\n         }\n         return right;\n       }\n\n       void main() {\n         ivec2 coords = getOutputCoords();\n         int batch = coords[0];\n         int valueIndex = coords[1];\n\n         float value = getValues(batch, valueIndex);\n\n         setOutput(float(findBound(batch, value)));\n       }\n     ")}}const AV={kernelName:kc,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{sortedSequence:r,values:o}=t,{side:s}=a,i=new _V(r.shape[0],r.shape[1],o.shape[1],s),c=[[r.shape[1]]];return n.runWebGLProgram(i,[r,o],"int32",c)}};class FV{constructor(e,t,n){let a,r;if(this.variableNames=["c","a","b"],this.outputShape=t,n>4)throw Error("Where for rank ".concat(n," is not yet supported"));if(1===n)r="resRC",a="resRC";else{const n=["resRC.x","resRC.y","resRC.z","resRC.w"],o=[],s=[];for(let a=0;a<t.length;a++)s.push("".concat(n[a])),a<e&&o.push("".concat(n[a]));a=o.join(),r=s.join()}const o=KO(n);this.userCode="\n      void main() {\n        ".concat(o," resRC = getOutputCoords();\n        float cVal = getC(").concat(a,");\n        if (cVal >= 1.0) {\n          setOutput(getA(").concat(r,"));\n        } else {\n          setOutput(getB(").concat(r,"));\n        }\n      }\n    ")}}const OV={kernelName:Ic,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{condition:a,t:r,e:o}=t,s=new FV(a.shape.length,r.shape,r.shape.length);return n.runWebGLProgram(s,[a,r,o],fu(r.dtype,o.dtype))}},DV=nL({opSnippet:"\n  // Stable and Attracting Fixed Point (0, 1) for Normalized Weights.\n  // see: https://arxiv.org/abs/1706.02515\n  float scaleAlpha = ".concat(mg,";\n  float scale = ").concat(gg,";\n  return (x >= 0.0) ? scale * x : scaleAlpha * (exp(x) - 1.0);\n")}),MV={kernelName:Sc,backendName:"webgl",kernelFunc:DV},LV=nL({opSnippet:tL+"\n  return 1.0 / (1.0 + exp(-1.0 * x));\n",packedOpSnippet:"\n  vec4 result = 1.0 / (1.0 + exp(-1.0 * x));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n",cpuKernelImpl:QD}),PV={kernelName:Rc,backendName:"webgl",kernelFunc:LV},zV=nL({opSnippet:"\n  if (isnan(x)) { return 0.0; }\n  return sign(x);\n"}),BV={kernelName:Ec,backendName:"webgl",kernelFunc:zV},WV=nL({opSnippet:tL+"\n  return sin(x);\n",packedOpSnippet:"\n  vec4 result = sin(x);\n  bvec4 isNaN = isnan(x);\n  ".concat(GM,"\n  return result;\n")}),VV={kernelName:Cc,backendName:"webgl",kernelFunc:WV},UV=nL({opSnippet:"\n  float e2x = exp(x);\n  return (e2x - 1.0 / e2x) / 2.0;\n"}),GV={kernelName:Tc,backendName:"webgl",kernelFunc:UV},HV=nL({opSnippet:"\n  float epsilon = 1.1920928955078125e-7;\n  float threshold = log(epsilon) + 2.0;\n\n  bool too_large = x > -threshold;\n  bool too_small = x < threshold;\n\n  float result;\n  float exp_x = exp(x);\n\n  if (too_large){\n    result = x;\n  }\n  else if (too_small){\n    result = exp_x;\n  }\n  else{\n    result = log(exp_x + 1.0);\n  }\n  return result;\n"}),jV={kernelName:_c,backendName:"webgl",kernelFunc:HV},KV={kernelName:Oc,backendName:"webgl",kernelFunc:e=>{const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{blockShape:o,paddings:s}=a;mo(r.shape.length<=4,(()=>"spaceToBatchND for rank > 4 with a WebGL backend not implemented yet"));const i=o.reduce(((e,t)=>e*t)),c=[[0,0]];c.push(...s);for(let b=1+o.length;b<r.shape.length;++b)c.push([0,0]);const l=[],u=KW({inputs:{x:r},backend:n,attrs:{paddings:c,constantValue:0}}),d=sg(u.shape,o,i,!1),h=ig(d.length,o.length,!1),p=cg(u.shape,o,i,!1),f=dL({inputs:{x:u},backend:n,attrs:{shape:d}}),m=wL({inputs:{x:f},backend:n,attrs:{perm:h}}),g=dL({inputs:{x:m},backend:n,attrs:{shape:p}});return l.push(u),l.push(f),l.push(m),l.forEach((e=>n.disposeIntermediateTensorInfo(e))),g}};const qV={kernelName:Lc,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{indices:a,values:r,denseShape:o,defaultValue:s}=t;if(1!==o.shape.length)throw new Error("Dense shape must be a vector, saw:\n         ".concat(o.shape));if(2!==a.shape.length)throw new Error("Indices must be a matrix, saw:\n         ".concat(a.shape));if(1!==r.shape.length)throw new Error("Values must be a vector, saw:\n         ".concat(r.shape));if(0!==s.shape.length)throw new Error("Default value must be a scalar, saw:\n        ".concat(s.shape));const i=n.readSync(a.dataId),c=n.readSync(r.dataId),l=n.readSync(o.dataId),u=n.readSync(s.dataId)[0],[d,h,p,f,m]=$D(i,a.shape,a.dtype,c,r.dtype,l,u);return[n.makeTensorInfo(h,a.dtype,d),n.makeTensorInfo([h[0]],r.dtype,p),n.makeTensorInfo([f.length],"bool",new Uint8Array(f.map((e=>Number(e))))),n.makeTensorInfo([m.length],a.dtype,new Int32Array(m))]}};const XV={kernelName:Pc,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{inputIndices:a,inputShape:r,newShape:o}=t;if(2!==a.shape.length)throw new Error("Input indices should be a matrix but received shape ".concat(a.shape));if(1!==r.shape.length)throw new Error("Input shape should be a vector but received shape ".concat(r.shape));if(1!==o.shape.length)throw new Error("Target shape should be a vector but received shape ".concat(o.shape));const s=Array.from(n.readSync(r.dataId)),i=n.readSync(a.dataId),c=Array.from(n.readSync(o.dataId)),[l,u,d]=eM(i,a.shape,a.dtype,s,c);return[n.makeTensorInfo(u,a.dtype,l),n.makeTensorInfo([d.length],o.dtype,new Int32Array(d))]}};const YV={kernelName:zc,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{data:a,indices:r,segmentIds:o}=t;if(a.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==r.shape.length)throw new Error("Indices should be a vector but received shape\n              ".concat(r.shape));if(1!==o.shape.length)throw new Error("Segment ids should be a vector but received shape\n              ".concat(o.shape));const s=n.readSync(a.dataId),i=n.readSync(r.dataId),c=n.readSync(o.dataId),[l,u]=tM(s,a.shape,a.dtype,i,c,!0);return n.makeTensorInfo(u,a.dtype,l)}};const QV={kernelName:Bc,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{data:a,indices:r,segmentIds:o}=t;if(a.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==r.shape.length)throw new Error("Indices should be a vector but received shape\n             ".concat(r.shape));if(1!==o.shape.length)throw new Error("Segment ids should be a vector but received shape\n             ".concat(o.shape));const s=n.readSync(a.dataId),i=n.readSync(r.dataId),c=n.readSync(o.dataId),[l,u]=tM(s,a.shape,a.dtype,i,c);return n.makeTensorInfo(u,a.dtype,l)}};const JV={kernelName:Wc,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{sparseIndices:r,sparseValues:o,defaultValue:s}=t,{outputShape:i}=a,{sliceRank:c,numUpdates:l,sliceSize:u,strides:d,outputSize:h}=fg(0,r,i),p=!1;if("string"===o.dtype){const e=n.bufferSync(r),t=n.bufferSync(o),a=Vl(n.readSync(s.dataId)[0]),f=YD(e,t,i,h,u,l,c,d,a,p);return n.makeTensorInfo(i,f.dtype,f.values)}const f=new TV(l,c,r.shape.length,o.shape.length,d,[h,1],p),m=n.runWebGLProgram(f,[o,r,s],o.dtype),g=dL({inputs:{x:m},backend:n,attrs:{shape:i}});return n.disposeIntermediateTensorInfo(m),g}};const ZV={kernelName:Dc,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{numOrSizeSplits:o,axis:s}=a,i=No(s,r.shape)[0],c=Vg(r,o,i),l=r.shape.length,u=new Array(l).fill(0),d=r.shape.slice();return c.map((e=>{const t=[...d];t[i]=e;const a=yP({inputs:{x:r},backend:n,attrs:{begin:u,size:t}});return u[i]+=e,a}))}},$V="return sqrt(x);",eU=nL({opSnippet:$V,packedOpSnippet:$V,cpuKernelImpl:nM}),tU={kernelName:Ac,backendName:"webgl",kernelFunc:eU},nU={kernelName:Uc,backendName:"webgl",kernelFunc:nL({opSnippet:"return x * x;"})},aU="return (a - b) * (a - b);",rU=aL({opSnippet:aU,packedOpSnippet:aU}),oU={kernelName:Vc,backendName:"webgl",kernelFunc:rU};const sU={kernelName:Gc,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t;if("string"!==r.dtype)throw new Error("Input must be of datatype string");const o=ab(n.readSync(r.dataId)),s=aM(o,"string",a);return n.makeTensorInfo(r.shape,"string",s)}};const iU={kernelName:ol,backendName:"webgl",kernelFunc:function(e){let{inputs:t,attrs:n,backend:a}=e;const{x:r}=t,o=kM+"\n    return x > 0.0 ? 1.0 : float(".concat(n.alpha,");\n  "),s=new wM(r.shape,o);return a.runWebGLProgram(s,[r],r.dtype)}};class cU{constructor(e,t,n){this.variableNames=["x"],this.outputShape=n;const a=n.length,r=KO(n.length),o=KO(n.length);let s="";if(1===a)s="coords * strides + begin";else{let e=0;s=n.map(((t,a)=>(e++,1===n.length?"coords * strides[".concat(a,"] + begin[").concat(a,"]"):"coords[".concat(e-1,"] * strides[").concat(a,"] + begin[").concat(a,"]")))).join(",")}this.userCode="\n      ".concat(r," begin = ").concat(r,"(").concat(e,");\n      ").concat(r," strides = ").concat(r,"(").concat(t,");\n\n      void main() {\n        ").concat(o," coords = getOutputCoords();\n        setOutput(getX(").concat(s,"));\n      }\n    ")}}const lU={kernelName:Hc,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{begin:o,end:s,strides:i,beginMask:c,endMask:l,ellipsisMask:u,newAxisMask:d,shrinkAxisMask:h}=a,{finalShapeSparse:p,finalShape:f,isIdentity:m,sliceDim0:g,isSimpleSlice:b,begin:y,end:x,strides:v}=zh(r.shape,o,s,i,c,l,u,d,h);let w;if(m)w=dL({inputs:{x:r},backend:n,attrs:{shape:f}});else if(g||b){mo(r.shape.length>=1,(()=>"Input must have rank at least 1, got: ".concat(r.shape.length)));const e=Nh(y,x,v),t=yP({inputs:{x:r},backend:n,attrs:{begin:y,size:e}});w=dL({inputs:{x:t},backend:n,attrs:{shape:f}}),n.disposeIntermediateTensorInfo(t)}else{if(n.shouldExecuteOnCPU([r])){const e=n.readSync(r.dataId),t=Od(r.shape,r.dtype,e),a=rM(p,t,v,y);w=n.makeTensorInfo(f,r.dtype,a.values)}else{const e=new cU(y,v,p);w=n.runWebGLProgram(e,[r],r.dtype)}}const k=dL({inputs:{x:w},backend:n,attrs:{shape:f}});return n.disposeIntermediateTensorInfo(w),k}};const uU={kernelName:jc,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{separator:r,nGramWidths:o,leftPad:s,rightPad:i,padWidth:c,preserveShortSequences:l}=a,{data:u,dataSplits:d}=t,h=n.readSync(u.dataId),p=n.readSync(d.dataId),[f,m]=oM(h,p,r,o,s,i,c,l);return[n.makeTensorInfo([f.length],"string",f),n.makeTensorInfo(d.shape,"int32",m)]}};const dU={kernelName:Kc,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{skipEmpty:r}=a,{input:o,delimiter:s}=t;if("string"!==o.dtype)throw new Error("Input must be of datatype string");if(1!==o.shape.length)throw new Error("Input must be a vector, got shape: ".concat(o.shape));if(0!==s.shape.length)throw new Error("Delimiter must be a scalar, got shape: ".concat(s.shape));const i=n.readSync(o.dataId),c=n.readSync(s.dataId)[0],[l,u,d]=sM(i,c,r),h=u.length;return[n.makeTensorInfo([h,2],"int32",l),n.makeTensorInfo([h],"string",u),n.makeTensorInfo([2],"int32",new Int32Array(d))]}};const hU={kernelName:qc,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{numBuckets:r}=a,{input:o}=t;if("string"!==o.dtype)throw new Error("Input must be of datatype string");if(r<=0)throw new Error("Number of buckets must be at least 1");const s=n.readSync(o.dataId),i=iM(s,r);return n.makeTensorInfo(o.shape,"int32",i)}},pU=nL({opSnippet:"return tan(x);"}),fU={kernelName:Yc,backendName:"webgl",kernelFunc:pU},mU=nL({opSnippet:"\n  float e2x = exp(-2.0 * abs(x));\n  return sign(x) * (1.0 - e2x) / (1.0 + e2x);\n"}),gU={kernelName:Qc,backendName:"webgl",kernelFunc:mU};const bU={kernelName:wc,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{tensor:r,indices:o,updates:s}=t,{}=a,{sliceRank:i,numUpdates:c,sliceSize:l,strides:u,outputSize:d}=fg(0,o,r.shape),h=[d/l,l];if(0===d)return n.makeTensorInfo(r.shape,o.dtype);const p=dL({inputs:{x:o},backend:n,attrs:{shape:[c,i]}}),f=dL({inputs:{x:s},backend:n,attrs:{shape:[c,l]}}),m=dL({inputs:{x:r},backend:n,attrs:{shape:h}}),g=new TV(c,i,p.shape.length,f.shape.length,u,h,!1,!0),b=n.runWebGLProgram(g,[f,p,m],m.dtype),y=dL({inputs:{x:b},backend:n,attrs:{shape:r.shape}});return n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),n.disposeIntermediateTensorInfo(b),y}};class yU{constructor(e,t){this.variableNames=["A"];const n=new Array(e.length);for(let o=0;o<n.length;o++)n[o]=e[o]*t[o];this.outputShape=n,this.rank=n.length;const a=KO(this.rank),r=function(e){const t=e.length;if(t>5)throw Error("Tile for rank ".concat(t," is not yet supported"));if(1===t)return"imod(resRC, ".concat(e[0],")");const n=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u"],a=[];for(let r=0;r<e.length;r++)a.push("imod(".concat(n[r],", ").concat(e[r],")"));return a.join()}(e);this.userCode="\n      void main() {\n        ".concat(a," resRC = getOutputCoords();\n        setOutput(getA(").concat(r,"));\n      }\n    ")}}function xU(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{reps:o}=a;if("string"===r.dtype||r.shape.length>5){const e=n.readSync(r.dataId),t="string"===r.dtype?e.map((e=>Vl(e))):e,a=Od(r.shape,r.dtype,t),s=lM(a,o);return n.makeTensorInfo(s.shape,s.dtype,s.values)}const s=new yU(r.shape,o);return n.runWebGLProgram(s,[r],r.dtype)}const vU={kernelName:Jc,backendName:"webgl",kernelFunc:xU};class wU{constructor(e){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"negativeInf",type:"float"},{name:"dir",type:"int"},{name:"inc",type:"int"}],this.outputShape=e,this.userCode="\n       void main() {\n         ivec2 coords = getOutputCoords();\n         int batch = coords[0];\n         int elemIdx = coords[1];\n\n         // We compare elements pair-wise within a group of size 2 * inc.\n         // The comparing rule for each group alternates between ascending\n         // and descending. Within each group, we compare each pair at\n         // positions i and i+inc. To decide whether an element at position i\n         // is x0 or x1, we mod it by 2 * inc, if the result is smaller than\n         // inc, it is in the first half of the group, we denote it as x0,\n         // otherwise we denote it as x1.\n         // For example, as shown in the Bitonic top K paper referenced above,\n         // Figure5(a) shows that element[1] is in the\n         // second half of the group when group size is 2, but it is in the\n         // first half of the group when group size is 4.\n\n         bool isFirstInPair = imod(elemIdx, 2 * inc) < inc;\n         int i = isFirstInPair ? elemIdx : elemIdx - inc;\n\n         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));\n         int i1 = firstPass == 1 ? i + inc : int(getIndices(batch, i + inc));\n         float x0 = i0 < n ? getX(batch, i0) : negativeInf;\n         float x1 = i1 < n ? getX(batch, i1) : negativeInf;\n\n         // Denotes which direction indices are in (ascending or descending).\n         bool reverse = imod(elemIdx, 2 * dir) >= dir;\n         bool isGreater = x0 > x1 || (x0 == x1 && i1 > i0);\n         if (reverse == isGreater) { // Elements in opposite order of direction\n           int iTemp = i0;\n           i0 = i1;\n           i1 = iTemp;\n         }\n         if (isFirstInPair) {\n            setOutput(float(i0));\n         } else {\n            setOutput(float(i1));\n         }\n       }\n     "}}class kU{constructor(e){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"k",type:"int"}],this.outputShape=e,this.userCode="\n    void main() {\n         // Takes max of indices (0, k), (1, k + 1), (2, k + 2) ...\n         ivec2 coords = getOutputCoords();\n         int batch = coords[0];\n         int elemIdx = coords[1];\n\n         // The output size is half of the previous size.\n         // If the previous sequence is | | | | _ _ _ _  | | | |  _ _ _ _ (k=4),\n         // we only need to output the indices at positions |, the indices at\n         // positions _ can be thrown away, see Figure5(b) After Phase 2\n         // (Merge phase) in the Bitonic Top K paper referenced above.\n         // For example, the paper shows we only need to output the orange bars.\n         // The output sequence should look like this | | | | | | | |.\n         // Because the sequence is halved, to map the output index back\n         // to the previous sequence to find the corresponding value,\n         // we need to double the index. When we double the index,\n         // we basically interpolate a position, so 2i looks like\n         // | _ | _ | _ | _ | _ | _ | _. We move the | to the first k position\n         // of each 2k positions by - elemIdx % k. E.g. for output at\n         // index 4,5,6,7, we want to get the corresponding element at\n         // original index 8,9,10,11, for output at index 8,9,10,11,\n         // we want to get the corresponding element at original index\n         // 16,17,18,19, so on and so forth.\n\n         int i = elemIdx < k ? elemIdx : (elemIdx * 2 - imod(elemIdx, k));\n         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));\n         int i1 = firstPass == 1 ? i + k : int(getIndices(batch, i + k));\n\n         float x0 = getX(batch, i0);\n         float x1 = i1 < n ? getX(batch, i1) : x0;\n\n         setOutput(x0 >= x1 ? float(i0) : float(i1));\n       }\n     "}}function IU(e,t){null!==t&&e.disposeIntermediateTensorInfo(t)}function SU(e){let t=1;for(;t<e;)t*=2;return t}const NU={kernelName:Zc,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{k:o,sorted:s}=a,i=Yo().getNumber("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD"),c=Yo().getNumber("TOPK_K_CPU_HANDOFF_THRESHOLD"),l=r.shape,u=l[l.length-1];if(n.shouldExecuteOnCPU([r])||u<i||o>c){const e=n.readSync(r.dataId),[t,a]=uM(e,l,r.dtype,o,s);return[n.makeTensorInfo(t.shape,t.dtype,t.values),n.makeTensorInfo(a.shape,a.dtype,a.values)]}if(0===o)return l[l.length-1]=0,[n.makeTensorInfo(l,r.dtype,[]),n.makeTensorInfo(l,"int32",[])];if(1===u)return[r,aB({attrs:{shape:l,dtype:"int32",value:0},backend:n})];const d=n.texData.get(r.dataId),h=null!==d&&d.isPacked,p=h?n.unpackTensor(r):r,f=yo(l)/u,m=dL({inputs:{x:p},attrs:{shape:[f,u]},backend:n});h&&IU(n,p);const g=SU(o),b=SU(u);let y=null;const x=()=>null===y?[m,m]:[m,y],v=(e,t,a)=>{const r=x(),o=new wU(a),s=[[u],[null===y?1:0],[Number.NEGATIVE_INFINITY],[e],[t]],i=y;y=n.runWebGLProgram(o,r,"int32",s),IU(n,i)};for(let N=1;N<g;N*=2){const e=2*N;for(let t=N;t>=1;t/=2)v(e,t,[f,b])}for(let N=b;N>g;N/=2){const e=x(),t=new kU([f,N/2]),a=[[u],[null===y?1:0],[g]],r=y;y=n.runWebGLProgram(t,e,"int32",a),IU(n,r);const o=g/2,s=2*o;for(let n=o;n>=1;n/=2)v(s,n,y.shape)}let w=y;y=yP({inputs:{x:y},backend:n,attrs:{begin:0,size:[f,o]}}),IU(n,w);let k=kB({inputs:{x:m,indices:y},backend:n,attrs:{axis:1,batchDims:1}});IU(n,m);const I=l.slice(0,-1);I.push(o),w=y,y=dL({inputs:{x:y},attrs:{shape:I},backend:n}),IU(n,w);const S=k;return k=dL({inputs:{x:k},attrs:{shape:I},backend:n}),IU(n,S),[k,y]}};class CU{constructor(e,t,n,a,r,o){this.variableNames=["Image","Transforms"],this.outputShape=o;const s="nearest"===n?1:2;let i;switch(a){case"constant":default:i=1;break;case"reflect":i=2;break;case"wrap":i=3;break;case"nearest":i=4}this.userCode="\n            float mapCoord(float outCoord, float len) {\n              float inCoord = outCoord;\n              if(".concat(i," == 2) {\n                if (inCoord < 0.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz2 = 2.0 * len;\n                    if (inCoord < sz2) {\n                      inCoord = sz2 * float(int(float(-inCoord / sz2))) +\n                      inCoord;\n                    }\n                    inCoord = inCoord < -len ? inCoord + sz2 : -inCoord - 1.0;\n                  }\n                } else if (inCoord > len - 1.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz2 = 2.0 * len;\n                    inCoord -= sz2 * float(int(float(inCoord / sz2)));\n                    if (inCoord >= len) {\n                      inCoord = sz2 - inCoord - 1.0;\n                    }\n                  }\n                }\n                return clamp(inCoord, 0.0, len - 1.0);\n              } else if (").concat(i," == 3) {\n                if (inCoord < 0.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz = len - 1.0;\n                    inCoord += len * (float(int(float(-inCoord / sz))) + 1.0);\n                  }\n                } else if (inCoord > len - 1.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz = len - 1.0;\n                    inCoord -= len * float(int(float(inCoord / sz)));\n                  }\n                }\n                return clamp(inCoord, 0.0, len - 1.0);\n              } else if (").concat(i," == 4) {\n                return clamp(outCoord, 0.0, len - 1.0);\n              } else {\n                return outCoord;\n              }\n            }\n\n            float readWithFillValue(int batch, int coordY, int coordX,\n              int channel) {\n              float outputValue;\n              if (0 <= coordY && coordY < ").concat(e," && 0 <= coordX && coordX < ").concat(t,") {\n                  outputValue = getImage(batch, coordY, coordX, channel);\n              } else {\n                outputValue = float(").concat(r,");\n              }\n              return outputValue;\n            }\n\n            void main() {\n              ivec4 coords = getOutputCoords();\n              float outputValue;\n              int batch = coords[0];\n              int x = coords[2];\n              int y = coords[1];\n              int channel = coords[3];\n              float xf = float(x);\n              float yf = float(y);\n              float a1 = getTransforms(batch, 0);\n              float a2 = getTransforms(batch, 1);\n              float a3 = getTransforms(batch, 2);\n              float b1 = getTransforms(batch, 3);\n              float b2 = getTransforms(batch, 4);\n              float b3 = getTransforms(batch, 5);\n              float c1 = getTransforms(batch, 6);\n              float c2 = getTransforms(batch, 7);\n              float projection = c1 * xf + c2 * yf + 1.0;\n              if (projection == 0.0) {\n                outputValue = float(").concat(r,");\n              } else {\n                float inX = (a1 * xf + a2 * yf + a3) / projection;\n                float inY = (b1 * xf + b2 * yf + b3) / projection;\n                float mapX = mapCoord(inX, float(").concat(t,"));\n                float mapY = mapCoord(inY, float(").concat(e,"));\n\n                if (").concat(s," == 1) {\n                  int coordY = int(round(mapY));\n                  int coordX = int(round(mapX));\n                  outputValue = readWithFillValue(batch, coordY, coordX,\n                    channel);\n                } else {\n                  float yFloor = floor(mapY);\n                  float xFloor = floor(mapX);\n                  float yCeil = yFloor + 1.0;\n                  float xCeil = xFloor + 1.0;\n                  float valueYFloor = (xCeil - mapX) *\n                  readWithFillValue(batch, int(yFloor), int(xFloor), channel) +\n                  (mapX - xFloor) *\n                  readWithFillValue(batch, int(yFloor), int(xCeil), channel);\n                  float valueYCeil = (xCeil - mapX) *\n                  readWithFillValue(batch, int(yCeil), int(xFloor), channel) +\n                  (mapX - xFloor) *\n                  readWithFillValue(batch, int(yCeil), int(xCeil), channel);\n                  outputValue = (yCeil - mapY) * valueYFloor +\n                  (mapY - yFloor) * valueYCeil;\n                }\n              }\n              setOutput(outputValue);\n            }\n        ")}}const TU={kernelName:$c,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{image:r,transforms:o}=t,{interpolation:s,fillMode:i,fillValue:c,outputShape:l}=a,[u,d,h,p]=r.shape,[f,m]=null!=l?l:[d,h],g=new CU(d,h,s,i,c,[u,f,m,p]);return n.runWebGLProgram(g,[r,o],"float32")}};const EU={kernelName:tl,backendName:"webgl",kernelFunc:function(e){const{inputs:t,attrs:n,backend:a}=e,{axis:r}=n,{x:o}=t;EO(o,"unique"),console.warn("WARNING: ","UI might be locked temporarily as data is being downloaded");const s=a.readSync(o.dataId),{outputValues:i,outputShape:c,indices:l}=hM(s,r,o.shape,o.dtype);return[a.makeTensorInfo(c,o.dtype,i),a.makeTensorInfo([l.length],"int32",l)]}};const RU={kernelName:nl,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{value:r}=t;let{axis:o}=a;o<0&&(o+=r.shape.length);const s=r,i=s.shape.length,c=r.shape[o],l=new Array(i-1);let u=0;for(let m=0;m<i;m++)m!==o&&(l[u++]=s.shape[m]);const d=[],h=new Array(i).fill(0),p=s.shape.slice();p[o]=1;const f=new Array(c);for(let m=0;m<f.length;m++){h[o]=m;const e=yP({inputs:{x:s},backend:n,attrs:{begin:h,size:p}}),t=dL({inputs:{x:e},backend:n,attrs:{shape:l}});f[m]=t,d.push(e)}return d.forEach((e=>n.disposeIntermediateTensorInfo(e))),f}};class _U{constructor(e,t){this.variableNames=["x","segmentIds"];const n=e.windowSize,a=e.batchSize,r=e.inSize,o=e.numSegments,s=o*Math.ceil(r/n);this.outputShape=[a,s];const i=4*Math.floor(n/4),c=n%4,l="\n        sumValue += dot(values, segFilter);\n    ";let u="";r%n>0&&(u="\n        if (inIdx < 0 || inIdx >= ".concat(r,") {\n          return initializationValue;\n        }\n      "));let d="";r%n>0&&(d="\n        if (inIdx < 0 || inIdx >= ".concat(r,") {\n          return -1.0;\n        }\n      ")),this.userCode="\n      const float initializationValue = ".concat("0.0",";\n\n      float getValue(int batch, int inIdx) {\n        ").concat(u,"\n        return getX(batch, inIdx);\n      }\n\n      float getSegmentIdAtIndex(int inIdx) {\n        ").concat(d,"\n        return getSegmentIds(inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = int(floor(float(outIdx) / float(\n          ").concat(o,")) * float(").concat(n,"));\n        int currentSeg = int(mod(float(outIdx), float(").concat(o,")));\n\n        float sumValue = 0.0;\n\n        for (int i = 0; i < ").concat(i,"; i += 4) {\n          int inIdx = inOffset + i;\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 3)) == currentSeg ? 1 : 0\n          );\n\n          ").concat(l,"\n        }\n\n        int inIdx = inOffset + ").concat(i,";\n        if (").concat(1===c,") {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            initializationValue,\n            initializationValue,\n            initializationValue\n          );\n\n          int inIdxSeg = int(getSegmentIdAtIndex(inIdx));\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            0,\n            0,\n            0\n          );\n\n          ").concat(l,"\n        } else if (").concat(2===c,") {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            initializationValue,\n            initializationValue\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n              0,\n              0\n          );\n\n          ").concat(l,"\n        } else if (").concat(3===c,") {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            initializationValue\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,\n            0\n          );\n\n          ").concat(l,"\n        }\n        setOutput(").concat("sumValue",");\n      }\n    ")}}const AU={kernelName:al,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r,segmentIds:o}=t,{numSegments:s}=a,i=r.shape.length,c=[];let l=0;const u=Xp([l],i);let d=r;null!=u&&(d=wL({inputs:{x:r},backend:n,attrs:{perm:u}}),c.push(d),l=Qp(1,i)[0]);const h=tb(d.shape,l,s),p=yo([d.shape[l]]),f=dL({inputs:{x:d},backend:n,attrs:{shape:[-1,p]}});c.push(f);const m=mu(r.dtype),g=(e,t,a,r,o)=>{const s=e.shape[0],i=e.shape[1],l=eb(i,o),u=new _U({windowSize:l,inSize:i,batchSize:s,numSegments:o},t),d=n.compileAndRun(u,[e,a],r);if(c.push(d),d.shape[1]===o)return d;const h=eV({backend:n,attrs:{start:0,stop:o,step:1,dtype:"float32"}}),p=xU({inputs:{x:h},backend:n,attrs:{reps:[i/l]}});c.push(h),c.push(p);return g(d,t,p,r,o)},b=dL({inputs:{x:g(f,"unsortedSegmentSum",o,m,s)},backend:n,attrs:{shape:h}});let y=b;if(null!=u){c.push(b);const e=Yp(u);y=wL({inputs:{x:y},backend:n,attrs:{perm:e}})}return c.forEach((e=>n.disposeIntermediateTensorInfo(e))),y}},FU=[NL,TL,RL,AL,DL,PL,zL,BL,jL,KL,XL,QL,ZL,eP,nP,oP,sP,lP,uP,dP,fP,vP,wP,kP,IP,RP,FP,MP,XM,zP,KP,ez,oz,iz,cz,lz,uz,hz,fz,gz,kz,Iz,Sz,Cz,Rz,Fz,Oz,Mz,Pz,zz,Wz,Vz,Gz,jz,qz,Yz,Zz,tB,rB,sB,lB,dB,fB,bB,yB,vB,IB,NB,TB,KM,EB,GP,_B,FB,DB,JM,LB,zB,BB,VB,GB,jB,qB,YB,ZB,eW,nW,rW,oW,sW,lW,uW,dW,hW,pW,mW,yW,vW,RW,uL,AW,OW,MW,PW,NP,BW,UW,GW,qW,YW,eL,QW,JW,ZW,$W,tV,TP,IW,aV,oV,iV,hL,uV,hV,mV,bV,vV,kV,SV,CV,RV,AV,OV,MV,PV,BV,VV,GV,xP,EW,jV,KV,qV,XV,YV,QV,JV,ZV,tU,nU,oU,sU,iU,lU,uU,dU,hU,CW,vL,fU,gU,bU,vU,NU,TU,kL,EU,RU,AU,VW];for(const n of FU)yl(n);class OU{constructor(e,t){this.backend=e,this.dataMover=t,this.data=new WeakMap,this.dataIdsCount=0}get(e){return this.data.has(e)||this.dataMover.moveData(this.backend,e),this.data.get(e)}set(e,t){this.dataIdsCount++,this.data.set(e,t)}has(e){return this.data.has(e)}delete(e){return this.dataIdsCount--,this.data.delete(e)}numDataIds(){return this.dataIdsCount}}class DU{refCount(e){return MU("refCount")}incRef(e){return MU("incRef")}timerAvailable(){return!0}time(e){return MU("time")}read(e){return MU("read")}readSync(e){return MU("readSync")}readToGPU(e,t){return MU("readToGPU")}numDataIds(){return MU("numDataIds")}disposeData(e,t){return MU("disposeData")}write(e,t,n){return MU("write")}move(e,t,n,a,r){return MU("move")}createTensorFromGPUData(e,t,n){return MU("createTensorFromGPUData")}memory(){return MU("memory")}floatPrecision(){return MU("floatPrecision")}epsilon(){return 32===this.floatPrecision()?1e-7:1e-4}dispose(){return MU("dispose")}}function MU(e){throw new Error("'".concat(e,"' not yet implemented or not found in the registry. ")+"This kernel may not be supported by the tfjs backend you have chosen")}function LU(e,t,n){return Math.max(e,Math.min(t,n))}function PU(e){return e%2===0?e:e+1}function zU(e,t,n){const a=e[t];e[t]=e[n],e[n]=a}function BU(e,t){if(!e)throw new Error("string"===typeof t?t:t())}function WU(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"";BU(GU(e,t),(()=>n+" Shapes ".concat(e," and ").concat(t," must match")))}function VU(e){BU(null!=e,(()=>"The input to the tensor constructor must be a non-null value."))}function UU(e){if(0===e.length)return 1;let t=e[0];for(let n=1;n<e.length;n++)t*=e[n];return t}function GU(e,t){if(e===t)return!0;if(null==e||null==t)return!1;if(e.length!==t.length)return!1;for(let n=0;n<e.length;n++)if(e[n]!==t[n])return!1;return!0}function HU(e){return e%1===0}function jU(e){const t=Math.ceil(Math.sqrt(e));return[t,Math.ceil(e/t)]}function KU(e,t){return t<=e.length?e:e+" ".repeat(t-e.length)}function qU(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:e=>0,n=arguments.length>2?arguments[2]:void 0,a=arguments.length>3?arguments[3]:void 0;return new Promise(((r,o)=>{let s=0;const i=()=>{if(e())return void r();s++;const c=t(s);null!=n&&s>=n?o():null!=a?a(i,c):setTimeout(i,c)};i()}))}function XU(e,t){let n=1,a=-1;for(let o=0;o<e.length;++o)if(e[o]>=0)n*=e[o];else if(-1===e[o]){if(-1!==a)throw Error("Shapes can only have 1 implicit size. "+"Found -1 at dim ".concat(a," and dim ").concat(o));a=o}else if(e[o]<0)throw Error("Shapes can not be < 0. Found ".concat(e[o]," at dim ").concat(o));if(-1===a){if(t>0&&t!==n)throw Error("Size(".concat(t,") must match the product of shape ").concat(e));return e}if(0===n)throw Error("Cannot infer the missing size in [".concat(e,"] when ")+"there are 0 elements");if(t%n!==0)throw Error("The implicit shape can't be a fractional number. "+"Got ".concat(t," / ").concat(n));const r=e.slice();return r[a]=t/n,r}function YU(e,t){const n=t.length;return e=null==e?t.map(((e,t)=>t)):[].concat(e),BU(e.every((e=>e>=-n&&e<n)),(()=>"All values in axis param must be in range [-".concat(n,", ").concat(n,") but ")+"got axis ".concat(e))),BU(e.every((e=>HU(e))),(()=>"All values in axis param must be integers but "+"got axis ".concat(e))),e.map((e=>e<0?n+e:e))}function QU(e,t){const n=[],a=[],r=null!=t&&Array.isArray(t)&&0===t.length,o=null==t||r?null:YU(t,e).sort();let s=0;for(let i=0;i<e.length;++i){if(null!=o){if(o[s]===i&&1!==e[i])throw new Error("Can't squeeze axis ".concat(i," since its dim '").concat(e[i],"' is not 1"));(null==o[s]||o[s]>i)&&1===e[i]&&(n.push(e[i]),a.push(i)),o[s]<=i&&s++}1!==e[i]&&(n.push(e[i]),a.push(i))}return{newShape:n,keptDims:a}}function JU(e,t){return ZU(e,t)}function ZU(e,t){let n=null;if(null==e||"float32"===e)n=new Float32Array(t);else if("int32"===e)n=new Int32Array(t);else if("bool"===e)n=new Uint8Array(t);else{if("string"!==e)throw new Error("Unknown data type ".concat(e));n=new Array(t)}return n}function $U(e,t){return"complex64"!==t&&(("float32"!==t||"complex64"===e)&&(("int32"!==t||"float32"===e||"complex64"===e)&&("bool"!==t||"bool"!==e)))}function eG(e){if("float32"===e||"int32"===e)return 4;if("complex64"===e)return 8;if("bool"===e)return 1;throw new Error("Unknown dtype ".concat(e))}function tG(e){return"string"===typeof e||e instanceof String}function nG(e){return Array.isArray(e)?nG(e[0]):e instanceof Float32Array?"float32":e instanceof Int32Array||e instanceof Uint8Array||e instanceof Uint8ClampedArray?"int32":"number"===typeof e?"float32":tG(e)?"string":function(e){return"boolean"===typeof e}(e)?"bool":"float32"}function aG(e){return!!(e&&e.constructor&&e.call&&e.apply)}function rG(e,t){for(let n=t;n<e;++n)if(e%n===0)return n;return e}function oG(e){const t=e.length;if(t<2)return[];const n=new Array(t-1);n[t-2]=e[t-1];for(let a=t-3;a>=0;--a)n[a]=n[a+1]*e[a+1];return n}function sG(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const r=new Array;if(1===t.length){const o=t[0]*(a?2:1);for(let t=0;t<o;t++)r[t]=n[e+t]}else{const o=t[0],s=t.slice(1),i=s.reduce(((e,t)=>e*t))*(a?2:1);for(let t=0;t<o;t++)r[t]=sG(e+t*i,s,n,a)}return r}function iG(e,t){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];if(0===e.length)return t[0];const a=e.reduce(((e,t)=>e*t))*(n?2:1);if(0===a)return[];if(a!==t.length)throw new Error("[".concat(e,"] does not match the input size ").concat(t.length).concat(n?" for a complex tensor":"","."));return sG(0,e,t,n)}function cG(e,t){const n=lG(e,t);for(let a=0;a<n.length;a++)n[a]=1;return n}function lG(e,t){if(null==t||"float32"===t||"complex64"===t)return new Float32Array(e);if("int32"===t)return new Int32Array(e);if("bool"===t)return new Uint8Array(e);throw new Error("Unknown data type ".concat(t))}function uG(e,t){const n=e.reduce(((e,t)=>e*t),1);if(null==t||"float32"===t)return iG(e,new Float32Array(n));if("int32"===t)return iG(e,new Int32Array(n));if("bool"===t)return iG(e,new Uint8Array(n));throw new Error("Unknown data type ".concat(t))}function dG(e){e.forEach((t=>{BU(Number.isInteger(t)&&t>=0,(()=>"Tensor must have a shape comprised of positive integers but got "+"shape [".concat(e,"].")))}))}function hG(e,t,n){if(0===t)return 0;if(1===t)return e[0];let a=e[e.length-1];for(let r=0;r<e.length-1;++r)a+=n[r]*e[r];return a}function pG(e,t,n){if(0===t)return[];if(1===t)return[e];const a=new Array(t);for(let r=0;r<a.length-1;++r)a[r]=Math.floor(e/n[r]),e-=a[r]*n[r];return a[a.length-1]=e,a}function fG(e){return e&&e.then&&"function"===typeof e.then}const mG="tfjsflags";class gG{constructor(e){this.global=e,this.flags={},this.flagRegistry={},this.urlFlags={},this.getQueryParams=bG,this.populateURLFlags()}setPlatform(e,t){null!=this.platform&&(yG().getBool("IS_TEST")||yG().getBool("PROD")||console.warn("Platform ".concat(this.platformName," has already been set. ")+"Overwriting the platform with ".concat(e,"."))),this.platformName=e,this.platform=t}registerFlag(e,t,n){if(this.flagRegistry[e]={evaluationFn:t,setHook:n},null!=this.urlFlags[e]){const t=this.urlFlags[e];yG().getBool("IS_TEST")||yG().getBool("PROD")||console.warn("Setting feature override from URL ".concat(e,": ").concat(t,".")),this.set(e,t)}}async getAsync(e){return e in this.flags||(this.flags[e]=await this.evaluateFlag(e)),this.flags[e]}get(e){if(e in this.flags)return this.flags[e];const t=this.evaluateFlag(e);if(fG(t))throw new Error("Flag ".concat(e," cannot be synchronously evaluated. ")+"Please use getAsync() instead.");return this.flags[e]=t,this.flags[e]}getNumber(e){return this.get(e)}getBool(e){return this.get(e)}getString(e){return this.get(e)}getFlags(){return this.flags}get features(){return this.flags}set(e,t){if(null==this.flagRegistry[e])throw new Error("Cannot set flag ".concat(e," as it has not been registered."));this.flags[e]=t,null!=this.flagRegistry[e].setHook&&this.flagRegistry[e].setHook(t)}evaluateFlag(e){if(null==this.flagRegistry[e])throw new Error("Cannot evaluate flag '".concat(e,"': no evaluation function found."));return this.flagRegistry[e].evaluationFn()}setFlags(e){this.flags=Object.assign({},e)}reset(){this.flags={},this.urlFlags={},this.populateURLFlags()}populateURLFlags(){if("undefined"===typeof this.global||"undefined"===typeof this.global.location||"undefined"===typeof this.global.location.search)return;const e=this.getQueryParams(this.global.location.search);if(mG in e){e[mG].split(",").forEach((e=>{const[t,n]=e.split(":");this.urlFlags[t]=function(e,t){const n=t.toLowerCase();return"true"===n||"false"===n?"true"===n:"".concat(+n)===n?+n:t}(0,n)}))}}}function bG(e){const t={};return e.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g,(function(e){for(var n=arguments.length,a=new Array(n>1?n-1:0),r=1;r<n;r++)a[r-1]=arguments[r];return function(e,t,n){e[decodeURIComponent(t)]=decodeURIComponent(n||"")}(t,a[0],a[1]),a.join("=")})),t}function yG(){return vG}let xG,vG=null;function wG(){if(null==xG){let e;if("undefined"!==typeof window)e=window;else if("undefined"!==typeof n.g)e=n.g;else if("undefined"!==typeof process)e=process;else{if("undefined"===typeof self)throw new Error("Could not find a global object");e=self}xG=e}return xG}function kG(e,t){const n=function(){const e=wG();return null==e._tfGlobals&&(e._tfGlobals=new Map),e._tfGlobals}();if(n.has(e))return n.get(e);{const a=t();return n.set(e,a),n.get(e)}}const IG="Abs",SG="Acos",NG="Acosh",CG="Add",TG="AddN",EG="All",RG="Any",_G="ArgMax",AG="ArgMin",FG="Asin",OG="Asinh",DG="Atan",MG="Atanh",LG="Atan2",PG="AvgPool",zG="AvgPoolGrad",BG="AvgPool3D",WG="AvgPool3DGrad",VG="BatchMatMul",UG="BatchToSpaceND",GG="Bincount",HG="BitwiseAnd",jG="BroadcastArgs",KG="Cast",qG="Ceil",XG="ClipByValue",YG="Complex",QG="ComplexAbs",JG="Concat",ZG="Conv2D",$G="Conv2DBackpropFilter",eH="Conv2DBackpropInput",tH="Conv3D",nH="Conv3DBackpropFilterV2",aH="Conv3DBackpropInputV2",rH="Cos",oH="Cosh",sH="Cumprod",iH="Cumsum",cH="CropAndResize",lH="DenseBincount",uH="DepthToSpace",dH="DepthwiseConv2dNative",hH="DepthwiseConv2dNativeBackpropFilter",pH="DepthwiseConv2dNativeBackpropInput",fH="Diag",mH="Dilation2D",gH="Dilation2DBackpropInput",bH="Dilation2DBackpropFilter",yH="Draw",xH="RealDiv",vH="Einsum",wH="Elu",kH="EluGrad",IH="Erf",SH="Equal",NH="Exp",CH="ExpandDims",TH="Expm1",EH="FFT",RH="Fill",_H="FlipLeftRight",AH="Floor",FH="FloorDiv",OH="FusedBatchNorm",DH="GatherV2",MH="GatherNd",LH="Greater",PH="GreaterEqual",zH="Identity",BH="IFFT",WH="Imag",VH="IsFinite",UH="IsInf",GH="IsNan",HH="LeakyRelu",jH="Less",KH="LessEqual",qH="LinSpace",XH="Log",YH="Log1p",QH="LogicalAnd",JH="LogicalNot",ZH="LogicalOr",$H="LRN",ej="LRNGrad",tj="Max",nj="Maximum",aj="MaxPool",rj="MaxPoolGrad",oj="MaxPool3D",sj="MaxPool3DGrad",ij="MaxPoolWithArgmax",cj="Mean",lj="Min",uj="Minimum",dj="MirrorPad",hj="Mod",pj="Multinomial",fj="Multiply",mj="Neg",gj="NotEqual",bj="NonMaxSuppressionV3",yj="NonMaxSuppressionV4",xj="NonMaxSuppressionV5",vj="OnesLike",wj="OneHot",kj="Pack",Ij="PadV2",Sj="Pow",Nj="Prelu",Cj="Prod",Tj="RaggedGather",Ej="RaggedRange",Rj="RaggedTensorToTensor",_j="Range",Aj="Real",Fj="Reciprocal",Oj="Relu",Dj="Reshape",Mj="ResizeNearestNeighbor",Lj="ResizeNearestNeighborGrad",Pj="ResizeBilinear",zj="ResizeBilinearGrad",Bj="Relu6",Wj="Reverse",Vj="Round",Uj="Rsqrt",Gj="ScatterNd",Hj="TensorScatterUpdate",jj="SearchSorted",Kj="Select",qj="Selu",Xj="Slice",Yj="Sin",Qj="Sinh",Jj="Sign",Zj="Sigmoid",$j="Softplus",eK="Sqrt",tK="Sum",nK="SpaceToBatchND",aK="SplitV",rK="Softmax",oK="SparseFillEmptyRows",sK="SparseReshape",iK="SparseSegmentMean",cK="SparseSegmentSum",lK="SparseToDense",uK="SquaredDifference",dK="Square",hK="StaticRegexReplace",pK="StridedSlice",fK="StringNGrams",mK="StringSplit",gK="StringToHashBucketFast",bK="Sub",yK="Tan",xK="Tanh",vK="Tile",wK="TopK",kK="Transform",IK="Transpose",SK="Unique",NK="Unpack",CK="UnsortedSegmentSum",TK="ZerosLike",EK="Step",RK="FromPixels",_K="RotateWithOffset",AK="_FusedMatMul",FK="FusedConv2D",OK="FusedDepthwiseConv2D";function DK(){yG().getBool("IS_TEST")||yG().getBool("PROD")||console.warn(...arguments)}function MK(){yG().getBool("IS_TEST")||yG().getBool("PROD")||console.log(...arguments)}const LK=kG("kernelRegistry",(()=>new Map)),PK=kG("gradRegistry",(()=>new Map));function zK(e,t){const n=UK(e,t);return LK.get(n)}function BK(e){return PK.get(e)}function WK(e){const t=LK.entries(),n=[];for(;;){const{done:a,value:r}=t.next();if(a)break;const[o,s]=r,[i]=o.split("_");i===e&&n.push(s)}return n}function VK(e){const{kernelName:t,backendName:n}=e,a=UK(t,n);LK.has(a)&&DK("The kernel '".concat(t,"' for backend ")+"'".concat(n,"' is already registered")),LK.set(a,e)}function UK(e,t){return"".concat(t,"_").concat(e)}function GK(e){return e instanceof Float32Array||e instanceof Int32Array||e instanceof Uint8Array||e instanceof Uint8ClampedArray}const HK=Il()||kl;function jK(e){return HK.fromString(e,!0,16)}const KK=jK("c3a5c85c97cb3127"),qK=jK("b492b66fbe98f273"),XK=jK("9ae16a3b2f90404f");function YK(e){return e.xor(e.shru(47))}function QK(e,t,n){const a=e.slice(t,t+n);return HK.fromBytes(Array.from(a),!0,!0)}function JK(e,t){return QK(e,t,8)}function ZK(e,t){return QK(e,t,4)}function $K(e,t){return 0===t?e:e.shru(t).or(e.shl(64-t))}function eq(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:jK("9ddfea08eb382d69"),a=e.xor(t).mul(n);a=a.xor(a.shru(47));let r=t.xor(a).mul(n);return r=r.xor(r.shru(47)),r=r.mul(n),r}function tq(e,t,n,a){return function(e,t,n,a,r,o){r=r.add(e),o=$K(o.add(r).add(a),21);const s=r;return r=(r=r.add(t)).add(n),o=o.add($K(r,44)),[r.add(a),o.add(s)]}(JK(e,t),JK(e,t+8),JK(e,t+16),JK(e,t+24),n,a)}function nq(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:e.length;const n=HK.fromNumber(81,!0);if(t<=32)return t<=16?function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:e.length;if(t>=8){const n=XK.add(2*t),a=JK(e,0).add(XK),r=JK(e,t-8);return eq($K(r,37).mul(n).add(a),$K(a,25).add(r).mul(n),n)}if(t>=4){const n=XK.add(2*t);return eq(ZK(e,0).shl(3).add(t),ZK(e,t-4),n)}if(t>0){const n=e[0]+(e[t>>1]<<8),a=t+(e[t-1]<<2);return YK(XK.mul(n).xor(KK.mul(a))).mul(XK)}return XK}(e,t):function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:e.length;const n=XK.add(2*t),a=JK(e,0).mul(qK),r=JK(e,8),o=JK(e,t-8).mul(n),s=JK(e,t-16).mul(XK);return eq($K(a.add(r),43).add($K(o,30)).add(s),a.add($K(r.add(XK),18)).add(o),n)}(e,t);if(t<=64)return function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:e.length;const n=XK.add(2*t),a=JK(e,0).mul(XK),r=JK(e,8),o=JK(e,t-8).mul(n),s=JK(e,t-16).mul(XK),i=$K(a.add(r),43).add($K(o,30)).add(s),c=eq(i,a.add($K(r.add(XK),18)).add(o),n),l=JK(e,16).mul(n),u=JK(e,24),d=i.add(JK(e,t-32)).mul(n),h=c.add(JK(e,t-24)).mul(n);return eq($K(l.add(u),43).add($K(d,30)).add(h),l.add($K(u.add(a),18)).add(d),n)}(e,t);let a=n,r=n.mul(qK).add(113),o=YK(r.mul(XK).add(113)).mul(XK),s=[HK.UZERO,HK.UZERO],i=[HK.UZERO,HK.UZERO];a=a.mul(XK).add(JK(e,0));let c=0;const l=64*(t-1>>6),u=l+(t-1&63)-63;do{a=$K(a.add(r).add(s[0]).add(JK(e,c+8)),37).mul(qK),r=$K(r.add(s[1]).add(JK(e,c+48)),42).mul(qK),a=a.xor(i[1]),r=r.add(s[0]).add(JK(e,c+40)),o=$K(o.add(i[0]),33).mul(qK),s=tq(e,c,s[1].mul(qK),a.add(i[0])),i=tq(e,c+32,o.add(i[1]),r.add(JK(e,c+16))),[o,a]=[a,o],c+=64}while(c!==l);const d=qK.add(o.and(255).shl(1));return c=u,i[0]=i[0].add(t-1&63),s[0]=s[0].add(i[0]),i[0]=i[0].add(s[0]),a=$K(a.add(r).add(s[0]).add(JK(e,c+8)),37).mul(d),r=$K(r.add(s[1]).add(JK(e,c+48)),42).mul(d),a=a.xor(i[1].mul(9)),r=r.add(s[0].mul(9).add(JK(e,c+40))),o=$K(o.add(i[0]),33).mul(d),s=tq(e,c,s[1].mul(d),a.add(i[0])),i=tq(e,c+32,o.add(i[1]),r.add(JK(e,c+16))),[o,a]=[a,o],eq(eq(s[0],i[0],d).add(YK(r).mul(KK)).add(o),eq(s[1],i[1],d).add(a),d)}function aq(e,t){return"string"===t?sq(e):rq([e],t)}function rq(e,t){if("string"===t)throw new Error("Cannot convert a string[] to a TypedArray");if(Array.isArray(e)&&(e=lq(e)),yG().getBool("DEBUG")&&function(e,t){for(let n=0;n<e.length;n++){const a=e[n];if(isNaN(a)||!isFinite(a))throw Error("A tensor of type ".concat(t," being uploaded contains ").concat(a,"."))}}(e,t),function(e,t){return e instanceof Float32Array&&"float32"===t||e instanceof Int32Array&&"int32"===t||e instanceof Uint8Array&&"bool"===t}(e,t))return e;if(null==t||"float32"===t||"complex64"===t)return new Float32Array(e);if("int32"===t)return new Int32Array(e);if("bool"===t){const t=new Uint8Array(e.length);for(let n=0;n<t.length;++n)0!==Math.round(e[n])&&(t[n]=1);return t}throw new Error("Unknown data type ".concat(t))}function oq(){return yG().platform.now()}function sq(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"utf-8";return t=t||"utf-8",yG().platform.encode(e,t)}function iq(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"utf-8";return t=t||"utf-8",yG().platform.decode(e,t)}function cq(e){return null!=yG().platform.isTypedArray?yG().platform.isTypedArray(e):GK(e)}function lq(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[],n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];if(null==t&&(t=[]),"boolean"===typeof e||"number"===typeof e||"string"===typeof e||fG(e)||null==e||cq(e)&&n)t.push(e);else if(Array.isArray(e)||cq(e))for(let a=0;a<e.length;++a)lq(e[a],t,n);else{let a=-1;for(const t of Object.keys(e))/^([1-9]+[0-9]*|0)$/.test(t)&&(a=Math.max(a,Number(t)));for(let r=0;r<=a;r++)lq(e[r],t,n)}return t}class uq{constructor(e,t){this.backendTimer=e,this.logger=t,null==t&&(this.logger=new hq)}profileKernel(e,t,n){let a;const r=()=>{a=n()};let o;const s=oq();if(this.backendTimer.timerAvailable())o=this.backendTimer.time(r);else{r();for(const e of a)e.dataSync();o=Promise.resolve({kernelMs:oq()-s})}if(yG().getBool("CHECK_COMPUTATION_FOR_ERRORS"))for(let i=0;i<a.length;i++){const t=a[i];t.data().then((n=>{dq(n,t.dtype,e)}))}return{kernelName:e,outputs:a,inputs:t,timeMs:o.then((e=>e.kernelMs)),extraInfo:o.then((e=>null!=e.getExtraProfileInfo?e.getExtraProfileInfo():""))}}logKernelProfile(e){const{kernelName:t,outputs:n,timeMs:a,inputs:r,extraInfo:o}=e;n.forEach((e=>{Promise.all([e.data(),a,o]).then((n=>{this.logger.logKernelProfile(t,e,n[0],n[1],r,n[2])}))}))}}function dq(e,t,n){if("float32"!==t)return!1;for(let a=0;a<e.length;a++){const t=e[a];if(isNaN(t)||!isFinite(t))return console.warn("Found ".concat(t," in the result of '").concat(n,"'")),!0}return!1}class hq{logKernelProfile(e,t,n,a,r,o){const s="number"===typeof a?KU("".concat(a,"ms"),9):a.error,i=KU(e,25),c=t.rank,l=t.size,u=KU(t.shape.toString(),14);let d="";for(const h in r){const e=r[h];if(null!=e){const n=e.shape||t.shape,a=n.length;d+="".concat(h,": ").concat(a,"D ").concat(a>0?n:""," ")}}console.log("%c".concat(i,"\t%c").concat(s,"\t%c").concat(c,"D ").concat(u,"\t%c").concat(l,"\t%c").concat(d,"\t%c").concat(o),"font-weight:bold","color:red","color:blue","color: orange","color: green","color: steelblue")}}const pq=20,fq=3,mq=7;function gq(e,t,n,a){const r=oG(t),o=function(e,t,n,a){const r=UU(t),o=a[a.length-1],s=new Array(o).fill(0),i=t.length,c="complex64"===n?vq(e):e;if(i>1)for(let l=0;l<r/o;l++){const e=l*o;for(let t=0;t<o;t++)s[t]=Math.max(s[t],bq(c[e+t],0,n).length)}return s}(e,t,n,r),s=t.length,i=xq(e,t,n,r,o),c=["Tensor"];return a&&(c.push("  dtype: ".concat(n)),c.push("  rank: ".concat(s)),c.push("  shape: [".concat(t,"]")),c.push("  values:")),c.push(i.map((e=>"    "+e)).join("\n")),c.join("\n")}function bq(e,t,n){let a;return a=Array.isArray(e)?"".concat(parseFloat(e[0].toFixed(mq))," + ")+"".concat(parseFloat(e[1].toFixed(mq)),"j"):tG(e)?"'".concat(e,"'"):"bool"===n?yq(e):parseFloat(e.toFixed(mq)).toString(),KU(a,t)}function yq(e){return 0===e?"false":"true"}function xq(e,t,n,a,r){let o=!(arguments.length>5&&void 0!==arguments[5])||arguments[5];const s="complex64"===n?2:1,i=t[0],c=t.length;if(0===c){if("complex64"===n){return[bq(vq(e)[0],0,n)]}return"bool"===n?[yq(e[0])]:[e[0].toString()]}if(1===c){if(i>pq){const t=fq*s;let a=Array.from(e.slice(0,t)),o=Array.from(e.slice((i-fq)*s,i*s));return"complex64"===n&&(a=vq(a),o=vq(o)),["["+a.map(((e,t)=>bq(e,r[t],n))).join(", ")+", ..., "+o.map(((e,t)=>bq(e,r[i-fq+t],n))).join(", ")+"]"]}return["["+("complex64"===n?vq(e):Array.from(e)).map(((e,t)=>bq(e,r[t],n))).join(", ")+"]"]}const l=t.slice(1),u=a.slice(1),d=a[0]*s,h=[];if(i>pq){for(let t=0;t<fq;t++){const a=t*d,o=a+d;h.push(...xq(e.slice(a,o),l,n,u,r,!1))}h.push("...");for(let t=i-fq;t<i;t++){const a=t*d,o=a+d;h.push(...xq(e.slice(a,o),l,n,u,r,t===i-1))}}else for(let m=0;m<i;m++){const t=m*d,a=t+d;h.push(...xq(e.slice(t,a),l,n,u,r,m===i-1))}const p=2===c?",":"";h[0]="["+(i>0?h[0]+p:"");for(let m=1;m<h.length-1;m++)h[m]=" "+h[m]+p;let f=",\n";for(let m=2;m<c;m++)f+="\n";return h[h.length-1]=" "+h[h.length-1]+"]"+(o?"":f),h}function vq(e){const t=[];for(let n=0;n<e.length;n+=2)t.push([e[n],e[n+1]]);return t}class wq{constructor(e,t,n){if(this.dtype=t,this.shape=e.slice(),this.size=UU(e),null!=n){const e=n.length;BU(e===this.size,(()=>"Length of values '".concat(e,"' does not match the size ")+"inferred by the shape '".concat(this.size,"'.")))}if("complex64"===t)throw new Error("complex64 dtype TensorBuffers are not supported. Please create a TensorBuffer for the real and imaginary parts separately and call tf.complex(real, imag).");this.values=n||ZU(t,this.size),this.strides=oG(e)}set(e){for(var t=arguments.length,n=new Array(t>1?t-1:0),a=1;a<t;a++)n[a-1]=arguments[a];0===n.length&&(n=[0]),BU(n.length===this.rank,(()=>"The number of provided coordinates (".concat(n.length,") must ")+"match the rank (".concat(this.rank,")")));const r=this.locToIndex(n);this.values[r]=e}get(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];0===t.length&&(t=[0]);let a=0;for(const o of t){if(o<0||o>=this.shape[a]){const e="Requested out of range element at ".concat(t,". ")+"  Buffer shape=".concat(this.shape);throw new Error(e)}a++}let r=t[t.length-1];for(let o=0;o<t.length-1;++o)r+=this.strides[o]*t[o];return this.values[r]}locToIndex(e){if(0===this.rank)return 0;if(1===this.rank)return e[0];let t=e[e.length-1];for(let n=0;n<e.length-1;++n)t+=this.strides[n]*e[n];return t}indexToLoc(e){if(0===this.rank)return[];if(1===this.rank)return[e];const t=new Array(this.shape.length);for(let n=0;n<t.length-1;++n)t[n]=Math.floor(e/this.strides[n]),e-=t[n]*this.strides[n];return t[t.length-1]=e,t}get rank(){return this.shape.length}toTensor(){return kq().makeTensor(this.values,this.shape,this.dtype)}}let kq=null,Iq=null,Sq=null;class Nq{constructor(e,t,n,a){this.kept=!1,this.isDisposedInternal=!1,this.shape=e.slice(),this.dtype=t||"float32",this.size=UU(e),this.strides=oG(e),this.dataId=n,this.id=a,this.rankType=this.rank<5?this.rank.toString():"higher"}get rank(){return this.shape.length}async buffer(){const e=await this.data();return Iq.buffer(this.shape,this.dtype,e)}bufferSync(){return Iq.buffer(this.shape,this.dtype,this.dataSync())}async array(){const e=await this.data();return iG(this.shape,e,"complex64"===this.dtype)}arraySync(){return iG(this.shape,this.dataSync(),"complex64"===this.dtype)}async data(){this.throwIfDisposed();const e=kq().read(this.dataId);if("string"===this.dtype){const n=await e;try{return n.map((e=>iq(e)))}catch(t){throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}}return e}dataToGPU(e){return this.throwIfDisposed(),kq().readToGPU(this.dataId,e)}dataSync(){this.throwIfDisposed();const e=kq().readSync(this.dataId);if("string"===this.dtype)try{return e.map((e=>iq(e)))}catch(t){throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}return e}async bytes(){this.throwIfDisposed();const e=await kq().read(this.dataId);return"string"===this.dtype?e:new Uint8Array(e.buffer)}dispose(){this.isDisposed||(this.kerasMask&&this.kerasMask.dispose(),kq().disposeTensor(this),this.isDisposedInternal=!0)}get isDisposed(){return this.isDisposedInternal}throwIfDisposed(){if(this.isDisposed)throw new Error("Tensor is disposed.")}print(){let e=arguments.length>0&&void 0!==arguments[0]&&arguments[0];return Iq.print(this,e)}clone(){return this.throwIfDisposed(),Iq.clone(this)}toString(){let e=arguments.length>0&&void 0!==arguments[0]&&arguments[0];return gq(this.dataSync(),this.shape,this.dtype,e)}cast(e){return this.throwIfDisposed(),Iq.cast(this,e)}variable(){let e=!(arguments.length>0&&void 0!==arguments[0])||arguments[0],t=arguments.length>1?arguments[1]:void 0,n=arguments.length>2?arguments[2]:void 0;return this.throwIfDisposed(),kq().makeVariable(this,e,t,n)}}function Cq(){return kG("Tensor",(()=>Nq))}Object.defineProperty(Nq,Symbol.hasInstance,{value:e=>!!e&&null!=e.data&&null!=e.dataSync&&null!=e.throwIfDisposed}),Cq();class Tq extends Nq{constructor(e,t,n,a){super(e.shape,e.dtype,e.dataId,a),this.trainable=t,this.name=n}assign(e){if(e.dtype!==this.dtype)throw new Error("dtype of the new value (".concat(e.dtype,") and ")+"previous value (".concat(this.dtype,") must match"));if(!GU(e.shape,this.shape))throw new Error("shape of the new value (".concat(e.shape,") and ")+"previous value (".concat(this.shape,") must match"));kq().disposeTensor(this),this.dataId=e.dataId,kq().incRef(this,null)}dispose(){kq().disposeVariable(this),this.isDisposedInternal=!0}}var Eq,Rq,_q,Aq,Fq;Object.defineProperty(Tq,Symbol.hasInstance,{value:e=>e instanceof Nq&&null!=e.assign&&e.assign instanceof Function}),function(e){e.R0="R0",e.R1="R1",e.R2="R2",e.R3="R3",e.R4="R4",e.R5="R5",e.R6="R6"}(Eq||(Eq={})),function(e){e.float32="float32",e.int32="int32",e.bool="int32",e.complex64="complex64"}(Rq||(Rq={})),function(e){e.float32="float32",e.int32="int32",e.bool="bool",e.complex64="complex64"}(_q||(_q={})),function(e){e.float32="float32",e.int32="float32",e.bool="float32",e.complex64="complex64"}(Aq||(Aq={})),function(e){e.float32="complex64",e.int32="complex64",e.bool="complex64",e.complex64="complex64"}(Fq||(Fq={}));const Oq={float32:Aq,int32:Rq,bool:_q,complex64:Fq};function Dq(e,t){if("string"===e||"string"===t){if("string"===e&&"string"===t)return"string";throw new Error("Can not upcast ".concat(e," with ").concat(t))}return Oq[e][t]}function Mq(e){return Dq(e,"int32")}function Lq(e){return null!=e&&"object"===typeof e&&"texture"in e&&e.texture instanceof WebGLTexture}function Pq(e){return"undefined"!==typeof GPUBuffer&&null!=e&&"object"===typeof e&&"buffer"in e&&e.buffer instanceof GPUBuffer}function zq(e,t){if(e.dtype===t.dtype)return[e,t];const n=Dq(e.dtype,t.dtype);return[e.cast(n),t.cast(n)]}function Bq(e){const t=[];return Wq(e,t,new Set),t}function Wq(e,t,n){if(null==e)return;if(e instanceof Nq)return void t.push(e);if(a=e,!Array.isArray(a)&&"object"!==typeof a)return;var a;const r=e;for(const o in r){const e=r[o];n.has(e)||(n.add(e),Wq(e,t,n))}}function Vq(e){return null!=e.kernelName}class Uq{constructor(){this.registeredVariables={},this.nextTapeNodeId=0,this.numBytes=0,this.numTensors=0,this.numStringTensors=0,this.numDataBuffers=0,this.gradientDepth=0,this.kernelDepth=0,this.scopeStack=[],this.numDataMovesStack=[],this.nextScopeId=0,this.tensorInfo=new WeakMap,this.profiling=!1,this.activeProfile={newBytes:0,newTensors:0,peakBytes:0,kernels:[],result:null,get kernelNames(){return Array.from(new Set(this.kernels.map((e=>e.name))))}}}dispose(){for(const e in this.registeredVariables)this.registeredVariables[e].dispose()}}class Gq{constructor(e){this.ENV=e,this.registry={},this.registryFactory={},this.pendingBackendInitId=0,this.state=new Uq}async ready(){if(null!=this.pendingBackendInit)return this.pendingBackendInit.then((()=>{}));if(null!=this.backendInstance)return;const e=this.getSortedBackends();for(let t=0;t<e.length;t++){const n=e[t];if(await this.initializeBackend(n).success)return void await this.setBackend(n)}throw new Error("Could not initialize any backends, all backend initializations failed.")}get backend(){if(null!=this.pendingBackendInit)throw new Error("Backend '".concat(this.backendName,"' has not yet been initialized. Make ")+"sure to await tf.ready() or await tf.setBackend() before calling other methods");if(null==this.backendInstance){const{name:e,asyncInit:t}=this.initializeBackendsAndReturnBest();if(t)throw new Error("The highest priority backend '".concat(e,"' has not yet been ")+"initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods");this.setBackend(e)}return this.backendInstance}backendNames(){return Object.keys(this.registryFactory)}findBackend(e){if(!(e in this.registry)){if(!(e in this.registryFactory))return null;{const{asyncInit:t}=this.initializeBackend(e);if(t)return null}}return this.registry[e]}findBackendFactory(e){return e in this.registryFactory?this.registryFactory[e].factory:null}registerBackend(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1;return e in this.registryFactory?(DK("".concat(e," backend was already registered. ")+"Reusing existing backend factory."),!1):(this.registryFactory[e]={factory:t,priority:n},!0)}async setBackend(e){if(null==this.registryFactory[e])throw new Error("Backend name '".concat(e,"' not found in registry"));if(this.backendName=e,null==this.registry[e]){this.backendInstance=null;const{success:t,asyncInit:n}=this.initializeBackend(e);if(!(n?await t:t))return!1}return this.backendInstance=this.registry[e],this.setupRegisteredKernels(),this.profiler=new uq(this.backendInstance),!0}setupRegisteredKernels(){WK(this.backendName).forEach((e=>{null!=e.setupFunc&&e.setupFunc(this.backendInstance)}))}disposeRegisteredKernels(e){WK(e).forEach((t=>{null!=t.disposeFunc&&t.disposeFunc(this.registry[e])}))}initializeBackend(e){const t=this.registryFactory[e];if(null==t)throw new Error("Cannot initialize backend ".concat(e,", no registration found."));try{const n=t.factory();if(!n||n instanceof DU||"function"!==typeof n.then)return this.registry[e]=n,{success:!0,asyncInit:!1};{const t=++this.pendingBackendInitId,a=n.then((n=>!(t<this.pendingBackendInitId)&&(this.registry[e]=n,this.pendingBackendInit=null,!0))).catch((n=>(t<this.pendingBackendInitId||(this.pendingBackendInit=null,DK("Initialization of backend ".concat(e," failed")),DK(n.stack||n.message)),!1)));return this.pendingBackendInit=a,{success:a,asyncInit:!0}}}catch(ade){return DK("Initialization of backend ".concat(e," failed")),DK(ade.stack||ade.message),{success:!1,asyncInit:!1}}}removeBackend(e){if(!(e in this.registryFactory))throw new Error("".concat(e," backend not found in registry"));this.backendName===e&&null!=this.pendingBackendInit&&this.pendingBackendInitId++,e in this.registry&&(this.disposeRegisteredKernels(e),this.registry[e].dispose(),delete this.registry[e]),delete this.registryFactory[e],this.backendName===e&&(this.pendingBackendInit=null,this.backendName=null,this.backendInstance=null)}getSortedBackends(){if(0===Object.keys(this.registryFactory).length)throw new Error("No backend found in registry.");return Object.keys(this.registryFactory).sort(((e,t)=>this.registryFactory[t].priority-this.registryFactory[e].priority))}initializeBackendsAndReturnBest(){const e=this.getSortedBackends();for(let t=0;t<e.length;t++){const n=e[t],{success:a,asyncInit:r}=this.initializeBackend(n);if(r||a)return{name:n,asyncInit:r}}throw new Error("Could not initialize any backends, all backend initializations failed.")}moveData(e,t){const n=this.state.tensorInfo.get(t),a=n.backend,r=this.readSync(t),o=a.refCount(t);a.disposeData(t,!0),n.backend=e,e.move(t,r,n.shape,n.dtype,o),this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack[this.state.numDataMovesStack.length-1]++}tidy(e,t){let n,a=null;if(null==t){if("function"!==typeof e)throw new Error("Please provide a function to tidy()");t=e}else{if("string"!==typeof e&&!(e instanceof String))throw new Error("When calling with two arguments, the first argument to tidy() must be a string");if("function"!==typeof t)throw new Error("When calling with two arguments, the 2nd argument to tidy() must be a function");a=e}return this.scopedRun((()=>this.startScope(a)),(()=>this.endScope(n)),(()=>(n=t(),n instanceof Promise&&console.error("Cannot return a Promise inside of tidy."),n)))}scopedRun(e,t,n){e();try{const e=n();return t(),e}catch(a){throw t(),a}}nextTensorId(){return Gq.nextTensorId++}nextVariableId(){return Gq.nextVariableId++}clone(e){const t=jq.runKernel(zH,{x:e}),n={x:e};return this.addTapeNode(this.state.activeScope.name,n,[t],(e=>({x:()=>{const t={x:e},n={dtype:"float32"};return jq.runKernel(KG,t,n)}})),[],{}),t}runKernel(e,t,n){null==this.backendName&&this.backend;if(!(null!=zK(e,this.backendName)))throw new Error("Kernel '".concat(e,"' not registered for backend '").concat(this.backendName,"'"));return this.runKernelFunc({kernelName:e,inputs:t,attrs:n})}shouldCheckForMemLeaks(){return this.ENV.getBool("IS_TEST")}checkKernelForMemLeak(e,t,n){const a=this.backend.numDataIds();let r=0;n.forEach((e=>{r+="complex64"===e.dtype?3:1}));const o=this.state.numDataMovesStack[this.state.numDataMovesStack.length-1],s=a-t-r-o;if(s>0)throw new Error("Backend '".concat(this.backendName,"' has an internal memory leak ")+"(".concat(s," data ids) after running '").concat(e,"'"))}runKernelFunc(e){let t,n=[];const a=this.isTapeOn(),r=this.state.numBytes,o=this.state.numTensors;let s,i;this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack.push(0),null==this.backendName&&this.backend;const c=Vq(e)?e.kernelName:null!=this.state.activeScope?this.state.activeScope.name:"";if(Vq(e)){const{kernelName:t,inputs:r,attrs:o}=e;null==this.backendName&&this.backend;const c=zK(t,this.backendName);BU(null!=c,(()=>"Cannot find registered kernel '".concat(t,"' for backend '").concat(this.backendName,"'"))),s=()=>{const e=this.backend.numDataIds();i=c.kernelFunc({inputs:r,attrs:o,backend:this.backend});const s=Array.isArray(i)?i:[i];this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(t,e,s);const l=s.map((e=>null!=e.rank?e:this.makeTensorFromTensorInfo(e)));if(a){const e=this.getTensorsForGradient(t,r,l);n=this.saveTensorsForBackwardMode(e)}return l}}else{const{forwardFunc:t}=e,r=e=>{a&&(n=e.map((e=>this.keep(this.clone(e)))))};s=()=>{const e=this.backend.numDataIds();i=this.tidy((()=>t(this.backend,r)));const n=Array.isArray(i)?i:[i];return this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(c,e,n),n}}const{inputs:l,attrs:u}=e,d=Vq(e)?null:e.backwardsFunc;let h;return this.scopedRun((()=>this.state.kernelDepth++),(()=>this.state.kernelDepth--),(()=>{this.ENV.getBool("DEBUG")||this.state.profiling?(h=this.profiler.profileKernel(c,l,(()=>s())),this.ENV.getBool("DEBUG")&&this.profiler.logKernelProfile(h),t=h.outputs):t=s()})),a&&this.addTapeNode(c,l,t,d,n,u),this.state.profiling&&this.state.activeProfile.kernels.push({name:c,bytesAdded:this.state.numBytes-r,totalBytesSnapshot:this.state.numBytes,tensorsAdded:this.state.numTensors-o,totalTensorsSnapshot:this.state.numTensors,inputShapes:Object.keys(l).map((e=>null!=l[e]?l[e].shape:null)),outputShapes:t.map((e=>e.shape)),kernelTimeMs:h.timeMs,extraInfo:h.extraInfo}),Array.isArray(i)?t:t[0]}saveTensorsForBackwardMode(e){return e.map((e=>this.keep(this.clone(e))))}getTensorsForGradient(e,t,n){const a=BK(e);if(null!=a){const e=a.inputsToSave||[],r=a.outputsToSave||[];let o;a.saveAllInputs?(BU(Array.isArray(t),(()=>"saveAllInputs is true, expected inputs to be an array.")),o=Object.keys(t).map((e=>t[e]))):o=e.map((e=>t[e]));const s=n.filter(((e,t)=>r[t]));return o.concat(s)}return[]}makeTensor(e,t,n,a){if(null==e)throw new Error("Values passed to engine.makeTensor() are null");n=n||"float32",a=a||this.backend;let r=e;"string"===n&&tG(e[0])&&(r=e.map((e=>sq(e))));const o=a.write(r,t,n),s=new Nq(t,n,o,this.nextTensorId());if(this.trackTensor(s,a),"string"===n){const e=this.state.tensorInfo.get(o),t=function(e){if(null==e)return 0;let t=0;return e.forEach((e=>t+=e.length)),t}(r);this.state.numBytes+=t-e.bytes,e.bytes=t}return s}makeTensorFromDataId(e,t,n,a){const r={dataId:e,shape:t,dtype:n=n||"float32"};return this.makeTensorFromTensorInfo(r,a)}makeTensorFromTensorInfo(e,t){const{dataId:n,shape:a,dtype:r}=e,o=new Nq(a,r,n,this.nextTensorId());return this.trackTensor(o,t),o}makeVariable(e){let t=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],n=arguments.length>2?arguments[2]:void 0,a=arguments.length>3?arguments[3]:void 0;n=n||this.nextVariableId().toString(),null!=a&&a!==e.dtype&&(e=e.cast(a));const r=new Tq(e,t,n,this.nextTensorId());if(null!=this.state.registeredVariables[r.name])throw new Error("Variable with name ".concat(r.name," was already registered"));return this.state.registeredVariables[r.name]=r,this.incRef(r,this.backend),r}trackTensor(e,t){this.state.numTensors++,"string"===e.dtype&&this.state.numStringTensors++;let n=0;"complex64"!==e.dtype&&"string"!==e.dtype&&(n=e.size*eG(e.dtype)),this.state.numBytes+=n,this.state.tensorInfo.has(e.dataId)||(this.state.numDataBuffers++,this.state.tensorInfo.set(e.dataId,{backend:t||this.backend,dtype:e.dtype,shape:e.shape,bytes:n})),e instanceof Tq||this.track(e)}incRef(e,t){this.trackTensor(e,t),this.backend.incRef(e.dataId)}removeDataId(e,t){this.state.tensorInfo.has(e)&&this.state.tensorInfo.get(e).backend===t&&(this.state.tensorInfo.delete(e),this.state.numDataBuffers--)}disposeTensor(e){if(!this.state.tensorInfo.has(e.dataId))return;const t=this.state.tensorInfo.get(e.dataId);if(this.state.numTensors--,"string"===e.dtype&&(this.state.numStringTensors--,this.state.numBytes-=t.bytes),"complex64"!==e.dtype&&"string"!==e.dtype){const t=e.size*eG(e.dtype);this.state.numBytes-=t}t.backend.disposeData(e.dataId)&&this.removeDataId(e.dataId,t.backend)}disposeVariables(){for(const e in this.state.registeredVariables){const t=this.state.registeredVariables[e];this.disposeVariable(t)}}disposeVariable(e){this.disposeTensor(e),null!=this.state.registeredVariables[e.name]&&delete this.state.registeredVariables[e.name]}memory(){const e=this.backend.memory();return e.numTensors=this.state.numTensors,e.numDataBuffers=this.state.numDataBuffers,e.numBytes=this.state.numBytes,this.state.numStringTensors>0&&(e.unreliable=!0,null==e.reasons&&(e.reasons=[]),e.reasons.push("Memory usage by string tensors is approximate (2 bytes per character)")),e}async profile(e){this.state.profiling=!0;const t=this.state.numBytes,n=this.state.numTensors;this.state.activeProfile.kernels=[],this.state.activeProfile.result=await e(),this.state.profiling=!1,this.state.activeProfile.peakBytes=Math.max(...this.state.activeProfile.kernels.map((e=>e.totalBytesSnapshot))),this.state.activeProfile.newBytes=this.state.numBytes-t,this.state.activeProfile.newTensors=this.state.numTensors-n;for(const a of this.state.activeProfile.kernels)a.kernelTimeMs=await a.kernelTimeMs,a.extraInfo=await a.extraInfo;return this.state.activeProfile}isTapeOn(){return this.state.gradientDepth>0&&0===this.state.kernelDepth}addTapeNode(e,t,n,a,r,o){const s={id:this.state.nextTapeNodeId++,kernelName:e,inputs:t,outputs:n,saved:r},i=BK(e);null!=i&&(a=i.gradFunc),null!=a&&(s.gradient=e=>(e=e.map(((e,t)=>{if(null==e){const e=n[t],a=lG(e.size,e.dtype);return this.makeTensor(a,e.shape,e.dtype)}return e})),a(e.length>1?e:e[0],r,o))),this.state.activeTape.push(s)}keep(e){return e.kept=!0,e}startTape(){0===this.state.gradientDepth&&(this.state.activeTape=[]),this.state.gradientDepth++}endTape(){this.state.gradientDepth--}startScope(e){const t={track:[],name:"unnamed scope",id:this.state.nextScopeId++};e&&(t.name=e),this.state.scopeStack.push(t),this.state.activeScope=t}endScope(e){const t=Bq(e),n=new Set(t.map((e=>e.id)));for(let r=0;r<this.state.activeScope.track.length;r++){const e=this.state.activeScope.track[r];e.kept||n.has(e.id)||e.dispose()}const a=this.state.scopeStack.pop();this.state.activeScope=0===this.state.scopeStack.length?null:this.state.scopeStack[this.state.scopeStack.length-1],t.forEach((e=>{e.kept||e.scopeId!==a.id||this.track(e)}))}gradients(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]&&arguments[3];if(BU(t.length>0,(()=>"gradients() received an empty list of xs.")),null!=n&&"float32"!==n.dtype)throw new Error("dy must have 'float32' dtype, but has '".concat(n.dtype,"'"));const r=this.scopedRun((()=>this.startTape()),(()=>this.endTape()),(()=>this.tidy("forward",e)));BU(r instanceof Nq,(()=>"The result y returned by f() must be a tensor."));const o=function(e,t,n){const a={},r={};for(let c=0;c<t.length;c++)a[t[c].id]=!0;for(let c=0;c<e.length;c++){const n=e[c],o=n.inputs;for(const e in o){const s=o[e];let i=!1;for(let e=0;e<t.length;e++)if(a[s.id]){n.outputs.forEach((e=>a[e.id]=!0)),i=!0,r[n.id]=!0;break}if(i)break}}const o={};o[n.id]=!0;const s={};for(let c=e.length-1;c>=0;c--){const t=e[c],n=t.inputs;for(let e=0;e<t.outputs.length;e++)if(o[t.outputs[e].id]){for(const e in n)o[n[e].id]=!0,s[t.id]=!0;break}}const i=[];for(let c=0;c<e.length;c++){const t=e[c];if(r[t.id]&&s[t.id]){const e={};for(const r in t.inputs){const n=t.inputs[r];a[n.id]&&(e[r]=n)}const n=Object.assign({},t);n.inputs=e,n.outputs=t.outputs,i.push(n)}}return i}(this.state.activeTape,t,r);if(!a&&0===o.length&&t.length>0)throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that the f you passed encloses all operations that lead from x to y.");return this.tidy("backward",(()=>{const e={};e[r.id]=null==n?function(e){const t=cG(UU(e),"float32");return jq.makeTensor(t,e,"float32")}(r.shape):n,function(e,t,n,a){for(let r=t.length-1;r>=0;r--){const o=t[r],s=[];if(o.outputs.forEach((t=>{const n=e[t.id];null!=n?s.push(n):s.push(null)})),null==o.gradient)throw new Error("Cannot compute gradient: gradient function not found "+"for ".concat(o.kernelName,"."));const i=o.gradient(s);for(const t in o.inputs){if(!(t in i))throw new Error("Cannot backprop through input ".concat(t,". ")+"Available gradients found: ".concat(Object.keys(i),"."));const r=n((()=>i[t]()));if("float32"!==r.dtype)throw new Error("Error in gradient for op ".concat(o.kernelName,". The gradient of input ")+"".concat(t," must have 'float32' dtype, but has '").concat(r.dtype,"'"));const s=o.inputs[t];if(!GU(r.shape,s.shape))throw new Error("Error in gradient for op ".concat(o.kernelName,". The gradient of input ")+"'".concat(t,"' has shape '").concat(r.shape,"', which does not match ")+"the shape of the input '".concat(s.shape,"'"));if(null==e[s.id])e[s.id]=r;else{const t=e[s.id];e[s.id]=a(t,r),t.dispose()}}}}(e,o,(e=>this.tidy(e)),Kq);const a=t.map((t=>e[t.id]));return 0===this.state.gradientDepth&&(this.state.activeTape.forEach((e=>{for(const t of e.saved)t.dispose()})),this.state.activeTape=null),{value:r,grads:a}}))}customGrad(e){var t=this;return BU(aG(e),(()=>"The f passed in customGrad(f) must be a function.")),function(){for(var n=arguments.length,a=new Array(n),r=0;r<n;r++)a[r]=arguments[r];let o;BU(a.every((e=>e instanceof Nq)),(()=>"The args passed in customGrad(f)(x1, x2,...) must all be tensors"));const s={};a.forEach(((e,t)=>{s[t]=e}));return t.runKernelFunc({forwardFunc:(t,n)=>(o=e(...a,n),BU(o.value instanceof Nq,(()=>"The function f passed in customGrad(f) must return an object where `obj.value` is a tensor")),BU(aG(o.gradFunc),(()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function.")),o.value),backwardsFunc:(e,t)=>{const n=o.gradFunc(e,t),r=Array.isArray(n)?n:[n];BU(r.length===a.length,(()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns the same number of tensors as inputs passed to f(...).")),BU(r.every((e=>e instanceof Nq)),(()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns a list of only tensors."));const s={};return r.forEach(((e,t)=>{s[t]=()=>e})),s},inputs:s})}}readSync(e){return this.state.tensorInfo.get(e).backend.readSync(e)}read(e){return this.state.tensorInfo.get(e).backend.read(e)}readToGPU(e,t){return this.state.tensorInfo.get(e).backend.readToGPU(e,t)}async time(e){const t=oq(),n=await this.backend.time(e);return n.wallMs=oq()-t,n}track(e){return null!=this.state.activeScope&&(e.scopeId=this.state.activeScope.id,this.state.activeScope.track.push(e)),e}get registeredVariables(){return this.state.registeredVariables}reset(){this.pendingBackendInitId++,this.state.dispose(),this.ENV.reset(),this.state=new Uq;for(const e in this.registry)this.disposeRegisteredKernels(e),this.registry[e].dispose(),delete this.registry[e];this.backendName=null,this.backendInstance=null,this.pendingBackendInit=null}}function Hq(){const e=wG();if(null==e._tfengine){const t=new gG(e);e._tfengine=new Gq(t)}var t;return t=e._tfengine.ENV,vG=t,function(e){kq=e}((()=>e._tfengine)),e._tfengine}Gq.nextTensorId=0,Gq.nextVariableId=0;const jq=Hq();function Kq(e,t){const n={a:e,b:t};return jq.runKernel(CG,n)}let qq;function Xq(e){if(void 0!==qq)return qq;if(e||"undefined"!==typeof navigator&&null!=navigator){if(e||(e=navigator),"ReactNative"===e.product)return!0;const t=e.userAgent||e.vendor||("undefined"!==typeof window?window.opera:"");if(!t){const t=e;return t.userAgentData&&t.userAgentData.mobile}return/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(t)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(t.substr(0,4))}return!1}function Yq(){return"undefined"!==typeof window&&null!=window.document||"undefined"!==typeof WorkerGlobalScope}const Qq=yG();function Jq(e,t){let n=e;if(cq(e))return"string"===t?[]:[e.length];if(Lq(e)){const t=e.channels||"RGBA";return[e.height,e.width*t.length]}if(Pq(e))return[e.buffer.size/(null==t?4:eG(t))];if(!Array.isArray(e))return[];const a=[];for(;Array.isArray(n)||cq(n)&&"string"!==t;)a.push(n.length),n=n[0];return Array.isArray(e)&&yG().getBool("TENSORLIKE_CHECK_SHAPE_CONSISTENCY")&&Zq(e,a,[]),a}function Zq(e,t,n){if(n=n||[],!Array.isArray(e)&&!cq(e))return void BU(0===t.length,(()=>"Element arr[".concat(n.join("]["),"] is a primitive, ")+"but should be an array/TypedArray of ".concat(t[0]," elements")));BU(t.length>0,(()=>"Element arr[".concat(n.join("]["),"] should be a primitive, ")+"but is an array of ".concat(e.length," elements"))),BU(e.length===t[0],(()=>"Element arr[".concat(n.join("]["),"] should have ").concat(t[0]," ")+"elements, but has ".concat(e.length," elements")));const a=t.slice(1);for(let r=0;r<e.length;++r)Zq(e[r],a,n.concat(r))}function $q(e,t,n,a){if("string_or_numeric"!==e){if(null==e)throw new Error("Expected dtype cannot be null.");if("numeric"!==e&&e!==t||"numeric"===e&&"string"===t)throw new Error("Argument '".concat(n,"' passed to '").concat(a,"' must ")+"be ".concat(e," tensor, but got ").concat(t," tensor"))}}function eX(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"numeric";if(e instanceof Cq())return $q(a,e.dtype,t,n),e;let r=nG(e);if("string"!==r&&["bool","int32","float32"].indexOf(a)>=0&&(r=a),$q(a,r,t,n),null==e||!cq(e)&&!Array.isArray(e)&&"number"!==typeof e&&"boolean"!==typeof e&&"string"!==typeof e){const a=null==e?"null":e.constructor.name;throw new Error("Argument '".concat(t,"' passed to '").concat(n,"' must be a ")+"Tensor or TensorLike, but got '".concat(a,"'"))}const o=Jq(e,r);cq(e)||Array.isArray(e)||(e=[e]);const s="string"!==r?rq(e,r):lq(e,[],!0);return jq.makeTensor(s,o,r)}function tX(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"numeric";if(!Array.isArray(e))throw new Error("Argument ".concat(t," passed to ").concat(n," must be a ")+"`Tensor[]` or `TensorLike[]`");return e.map(((e,r)=>eX(e,"".concat(t,"[").concat(r,"]"),n,a)))}Qq.registerFlag("DEBUG",(()=>!1),(e=>{e&&console.warn("Debugging mode is ON. The output of every math call will be downloaded to CPU and checked for NaNs. This significantly impacts performance.")})),Qq.registerFlag("IS_BROWSER",(()=>Yq())),Qq.registerFlag("IS_NODE",(()=>"undefined"!==typeof process&&"undefined"!==typeof process.versions&&"undefined"!==typeof process.versions.node)),Qq.registerFlag("IS_CHROME",(()=>"undefined"!==typeof navigator&&null!=navigator&&null!=navigator.userAgent&&/Chrome/.test(navigator.userAgent)&&/Google Inc/.test(navigator.vendor))),Qq.registerFlag("IS_SAFARI",(()=>"undefined"!==typeof navigator&&null!=navigator&&null!=navigator.userAgent&&/Safari/.test(navigator.userAgent)&&/Apple/.test(navigator.vendor))),Qq.registerFlag("PROD",(()=>!1)),Qq.registerFlag("TENSORLIKE_CHECK_SHAPE_CONSISTENCY",(()=>Qq.getBool("DEBUG"))),Qq.registerFlag("DEPRECATION_WARNINGS_ENABLED",(()=>!0)),Qq.registerFlag("IS_TEST",(()=>!1)),Qq.registerFlag("CHECK_COMPUTATION_FOR_ERRORS",(()=>Qq.getBool("DEBUG"))),Qq.registerFlag("WRAP_TO_IMAGEBITMAP",(()=>!1)),Qq.registerFlag("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU",(()=>!1)),Qq.registerFlag("USE_SETTIMEOUTCUSTOM",(()=>!1));const nX="__op";function aX(e){const t=Object.keys(e);if(1!==t.length)throw new Error("Please provide an object with a single key (operation name) mapping to a function. Got an object with "+"".concat(t.length," keys."));let n=t[0];const a=e[n];n.endsWith("_")&&(n=n.substring(0,n.length-1)),n+=nX;const r=function(){jq.startScope(n);try{const e=a(...arguments);return fG(e)&&console.error("Cannot return a Promise inside of tidy."),jq.endScope(e),e}catch(e){throw jq.endScope(null),e}};return Object.defineProperty(r,"name",{value:n,configurable:!0}),r}const rX=aX({complex_:function(e,t){const n=eX(e,"real","complex"),a=eX(t,"imag","complex");WU(n.shape,a.shape,"real and imag shapes, ".concat(n.shape," and ").concat(a.shape,", ")+"must match in call to tf.complex().");const r={real:n,imag:a};return jq.runKernel(YG,r)}});function oX(e,t,n,a){if(null==a)a=nG(e);else if("complex64"===a)throw new Error("Cannot construct a complex64 tensor directly. Please use tf.complex(real, imag).");if(Pq(e)||Lq(e)){if("float32"!==a&&"int32"!==a)throw new Error("Creating tensor from GPU data only supports "+"'float32'|'int32' dtype, while the dtype is ".concat(a,"."));return jq.backend.createTensorFromGPUData(e,t||n,a)}if(!cq(e)&&!Array.isArray(e)&&"number"!==typeof e&&"boolean"!==typeof e&&"string"!==typeof e)throw new Error("values passed to tensor(values) must be a number/boolean/string or an array of numbers/booleans/strings, or a TypedArray");if(null!=t){dG(t);const e=UU(t),a=UU(n);BU(e===a,(()=>"Based on the provided shape, [".concat(t,"], the tensor should have ")+"".concat(e," values but has ").concat(a)));for(let r=0;r<n.length;++r){const e=n[r],a=r!==n.length-1||e!==UU(t.slice(r));BU(n[r]===t[r]||!a,(()=>"Error creating a new Tensor. Inferred shape "+"(".concat(n,") does not match the provided ")+"shape (".concat(t,"). ")))}}return cq(e)||Array.isArray(e)||(e=[e]),t=t||n,e="string"!==a?rq(e,a):lq(e,[],!0),jq.makeTensor(e,t,a)}function sX(e,t,n){return oX(e,t,Jq(e,n),n)}const iX={float32:4,float16:2,int32:4,uint16:2,uint8:1,bool:1,complex64:8};class cX{static join(e){return new cX(e).slice()}constructor(e){if(this.shards=[],this.previousShardIndex=0,null==e)return;if(e instanceof Array||(e=[e]),0===(e=e.map((e=>cq(e)?e.buffer:e))).length)return;this.bufferUniformSize=e[0].byteLength;let t=0;for(let n=0;n<e.length;n++){const a=e[n];n!==e.length-1&&a.byteLength!==this.bufferUniformSize&&(this.bufferUniformSize=void 0);const r=t+a.byteLength;this.shards.push({buffer:a,start:t,end:r}),t=r}0===this.shards.length&&(this.byteLength=0),this.byteLength=this.shards[this.shards.length-1].end}slice(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:this.byteLength;if(0===this.shards.length)return new ArrayBuffer(0);if(e=isNaN(Number(e))?0:e,t=isNaN(Number(t))?0:t,e=Math.max(0,e),t=Math.min(this.byteLength,t),t<=e)return new ArrayBuffer(0);const n=this.findShardForByte(e);if(-1===n)throw new Error("Could not find start shard for byte ".concat(e));const a=new ArrayBuffer(t-e),r=new Uint8Array(a);let o=0;for(let s=n;s<this.shards.length;s++){const n=this.shards[s],a=e+o-n.start,i=o,c=Math.min(t,n.end)-n.start,l=new Uint8Array(n.buffer,a,c-a);if(r.set(l,i),o+=l.length,t<n.end)break}return a}findShardForByte(e){if(0===this.shards.length||e<0||e>=this.byteLength)return-1;if(null!=this.bufferUniformSize)return this.previousShardIndex=Math.floor(e/this.bufferUniformSize),this.previousShardIndex;function t(t){return e<t.start?-1:e>=t.end?1:0}if(0===t(this.shards[this.previousShardIndex]))return this.previousShardIndex;const n=function(e,t){let n=0,a=e.length;for(;n<=a;){const r=Math.floor((a-n)/2)+n,o=t(e[r]);if(0===o)return r;o<0?a=r:n=r+1}return-1}(this.shards,t);return-1===n?-1:(this.previousShardIndex=n,this.previousShardIndex)}}function lX(){return jq}function uX(e,t){return jq.tidy(e,t)}function dX(e){Bq(e).forEach((e=>e.dispose()))}function hX(e){return jq.keep(e)}function pX(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1;return jq.registerBackend(e,t,n)}!function(e){Sq=e}((function(e){yG().getBool("DEPRECATION_WARNINGS_ENABLED")&&console.warn(e+" You can disable deprecation warnings with tf.disableDeprecationWarnings().")}));const fX=4;async function mX(e,t){const n=[],a=[],r=Array.isArray(e)?e.map((e=>e.name)):Object.keys(e);for(let o=0;o<r.length;++o){const s=r[o],i=Array.isArray(e)?e[o].tensor:e[s];if("float32"!==i.dtype&&"int32"!==i.dtype&&"bool"!==i.dtype&&"string"!==i.dtype&&"complex64"!==i.dtype)throw new Error("Unsupported dtype in weight '".concat(s,"': ").concat(i.dtype));const c={name:s,shape:i.shape,dtype:i.dtype};if("string"===i.dtype){const e=new Promise((async e=>{const t=await i.bytes(),n=t.reduce(((e,t)=>e+t.length),0)+fX*t.length,a=new Uint8Array(n);let r=0;for(let o=0;o<t.length;o++){const e=t[o],n=new Uint8Array(new Uint32Array([e.length]).buffer);a.set(n,r),r+=fX,a.set(e,r),r+=e.length}e(a)}));a.push(e)}else a.push(i.data());null!=t&&(c.group=t),n.push(c)}return{data:kX(await Promise.all(a)),specs:n}}function gX(e,t){const n=new cX(e),a={};let r=0;for(const o of t){const e=bX(o,((e,t)=>n.slice(r+e,r+t)));a[o.name]=xX(o,n.slice(r,r+e)),r+=e}return a}function bX(e,t){const n=UU(e.shape);let a;if("quantization"in e){const t=e.quantization;a=iX[t.dtype]}else{if("string"===e.dtype){let e=0;for(let a=0;a<n;a++)e+=fX+new Uint32Array(t(e,e+fX))[0];return e}a=iX[e.dtype]}return n*a}async function yX(e,t){const n=UU(e.shape);let a;if("quantization"in e){const t=e.quantization;a=iX[t.dtype]}else{if("string"===e.dtype){let e=0;for(let a=0;a<n;a++)e+=fX+new Uint32Array(await t(e,e+fX))[0];return e}a=iX[e.dtype]}return n*a}function xX(e,t){const n=e.name,a=e.dtype,r=e.shape,o=UU(r);let s,i=0;if("quantization"in e){const r=e.quantization;if("uint8"===r.dtype||"uint16"===r.dtype){if(!("min"in r)||!("scale"in r))throw new Error("Weight ".concat(e.name," with quantization ").concat(r.dtype," ")+"doesn't have corresponding metadata min and scale.")}else{if("float16"!==r.dtype)throw new Error("Weight ".concat(e.name," has unknown ")+"quantization dtype ".concat(r.dtype,". ")+"Supported quantization dtypes are: 'uint8', 'uint16', and 'float16'.");if("float32"!==a)throw new Error("Weight ".concat(e.name," is quantized with ").concat(r.dtype," ")+"which only supports weights of type float32 not ".concat(a,"."))}const c=iX[r.dtype],l="uint8"===r.dtype?new Uint8Array(t):new Uint16Array(t);if("float32"===a)if("uint8"===r.dtype||"uint16"===r.dtype){s=new Float32Array(l.length);for(let e=0;e<l.length;e++){const t=l[e];s[e]=t*r.scale+r.min}}else{if("float16"!==r.dtype)throw new Error("Unsupported quantization type ".concat(r.dtype," ")+"for weight type float32.");{const e=function(){const e=function(){const e=e=>{let t=e<<13,n=0;for(;0===(8388608&t);)n-=8388608,t<<=1;return t&=-8388609,n+=947912704,t|n},t=new Uint32Array(2048);t[0]=0;for(let n=1;n<1024;n++)t[n]=e(n);for(let n=1024;n<2048;n++)t[n]=939524096+(n-1024<<13);return t}(),t=function(){const e=new Uint32Array(64);e[0]=0,e[31]=1199570944,e[32]=2147483648,e[63]=3347054592;for(let t=1;t<31;t++)e[t]=t<<23;for(let t=33;t<63;t++)e[t]=2147483648+(t-32<<23);return e}(),n=function(){const e=new Uint32Array(64);for(let t=0;t<64;t++)e[t]=1024;return e[0]=e[32]=0,e}();return a=>{const r=new ArrayBuffer(4*a.length),o=new Uint32Array(r);for(let s=0;s<a.length;s++){const r=a[s],i=e[n[r>>10]+(1023&r)]+t[r>>10];o[s]=i}return new Float32Array(r)}}();s=e(l)}}else{if("int32"!==a)throw new Error("Unsupported dtype in weight '".concat(n,"': ").concat(a));if("uint8"!==r.dtype&&"uint16"!==r.dtype)throw new Error("Unsupported quantization type ".concat(r.dtype," ")+"for weight type int32.");s=new Int32Array(l.length);for(let e=0;e<l.length;e++){const t=l[e];s[e]=Math.round(t*r.scale+r.min)}}i+=o*c}else if("string"===a){const n=UU(e.shape);s=[];for(let e=0;e<n;e++){const e=new Uint32Array(t.slice(i,i+fX))[0];i+=fX;const n=new Uint8Array(t.slice(i,i+e));s.push(n),i+=e}}else{const e=iX[a];if("float32"===a)s=new Float32Array(t);else if("int32"===a)s=new Int32Array(t);else{if("bool"!==a){if("complex64"===a){s=new Float32Array(t);const e=new Float32Array(s.length/2),n=new Float32Array(s.length/2);for(let t=0;t<e.length;t++)e[t]=s[2*t],n[t]=s[2*t+1];const a=sX(e,r,"float32"),o=sX(n,r,"float32"),i=rX(a,o);return a.dispose(),o.dispose(),i}throw new Error("Unsupported dtype in weight '".concat(n,"': ").concat(a))}s=new Uint8Array(t)}i+=o*e}return sX(s,r,a)}async function vX(e,t,n){let a=new Uint8Array(t);for(;a.byteLength<n;){const{done:t,value:r}=await e.read();if(t&&null==r){const e=n-a.byteLength;throw new Error("Reader is done but ".concat(e," bytes are still expected"))}const o=new Uint8Array(a.length+r.byteLength);o.set(a,0),o.set(new Uint8Array(r),a.length),a=o}return a.buffer}async function wX(e,t){const n={},a=e.getReader();let r=new ArrayBuffer(0);for(const o of t){const e=await yX(o,(async(e,t)=>(r=await vX(a,r,t),r.slice(e,t))));r=await vX(a,r,e);const t=r.slice(0,e);r=r.slice(e);const s=xX(o,t);if(n[o.name]=s,"webgpu"===jq.backendName){const e=jq.backend;"uploadToGPU"in e&&UU(s.shape)>=yG().get("WEBGPU_CPU_HANDOFF_SIZE_THRESHOLD")&&e.uploadToGPU(s.dataId)}}return n}function kX(e){if(null===e)throw new Error("Invalid input value: ".concat(JSON.stringify(e)));let t=0;const n=[];e.forEach((e=>{if(t+=e.byteLength,n.push(e.byteLength===e.buffer.byteLength?e:new e.constructor(e)),!(e instanceof Float32Array||e instanceof Int32Array||e instanceof Uint8Array))throw new Error("Unsupported TypedArray subtype: ".concat(e.constructor.name))}));const a=new Uint8Array(t);let r=0;return n.forEach((e=>{a.set(new Uint8Array(e.buffer),r),r+=e.byteLength})),a.buffer}const IX="undefined"!==typeof Buffer&&("undefined"===typeof Blob||"undefined"===typeof atob||"undefined"===typeof btoa);function SX(e){return IX?Buffer.byteLength(e,"utf8"):new Blob([e]).size}function NX(e){return cX.join(e)}function CX(e){for(e=e.trim();e.endsWith("/");)e=e.slice(0,e.length-1);const t=e.split("/");return t[t.length-1]}function TX(e,t){const n={modelTopology:e.modelTopology,format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy,weightsManifest:t};return null!=e.signature&&(n.signature=e.signature),null!=e.userDefinedMetadata&&(n.userDefinedMetadata=e.userDefinedMetadata),null!=e.modelInitializer&&(n.modelInitializer=e.modelInitializer),null!=e.initializerSignature&&(n.initializerSignature=e.initializerSignature),null!=e.trainingConfig&&(n.trainingConfig=e.trainingConfig),n}function EX(e,t,n){const a={modelTopology:e.modelTopology,format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy};if(null!=e.trainingConfig&&(a.trainingConfig=e.trainingConfig),null!=e.weightsManifest){if(!t)throw new Error("modelJSON has weightsManifest but weightSpecs is null");if(!n)throw new Error("modelJSON has weightsManifest but weightData is null");a.weightSpecs=t,a.weightData=n}return null!=e.signature&&(a.signature=e.signature),null!=e.userDefinedMetadata&&(a.userDefinedMetadata=e.userDefinedMetadata),null!=e.modelInitializer&&(a.modelInitializer=e.modelInitializer),null!=e.initializerSignature&&(a.initializerSignature=e.initializerSignature),a}async function RX(e,t){let n,a;return null!=e.weightsManifest&&([n,a]=await t(e.weightsManifest)),EX(e,n,a)}function _X(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("Expected JSON model topology, received ArrayBuffer.");return{dateSaved:new Date,modelTopologyType:"JSON",modelTopologyBytes:null==e.modelTopology?0:SX(JSON.stringify(e.modelTopology)),weightSpecsBytes:null==e.weightSpecs?0:SX(JSON.stringify(e.weightSpecs)),weightDataBytes:null==e.weightData?0:new cX(e.weightData).byteLength}}function AX(e){const t=[];for(const n of e)t.push(...n.weights);return t}class FX{constructor(){this.saveRouters=[],this.loadRouters=[]}static getInstance(){return null==FX.instance&&(FX.instance=new FX),FX.instance}static registerSaveRouter(e){FX.getInstance().saveRouters.push(e)}static registerLoadRouter(e){FX.getInstance().loadRouters.push(e)}static getSaveHandlers(e){return FX.getHandlers(e,"save")}static getLoadHandlers(e,t){return FX.getHandlers(e,"load",t)}static getHandlers(e,t,n){const a=[];return("load"===t?FX.getInstance().loadRouters:FX.getInstance().saveRouters).forEach((t=>{const r=t(e,n);null!==r&&a.push(r)})),a}}const OX=e=>FX.registerSaveRouter(e),DX=e=>FX.registerLoadRouter(e),MX=e=>FX.getSaveHandlers(e),LX=(e,t)=>FX.getLoadHandlers(e,t),PX="tensorflowjs",zX="models_store",BX="model_info_store";function WX(){if(!yG().getBool("IS_BROWSER"))throw new Error("Failed to obtain IndexedDB factory because the current environmentis not a web browser.");const e="undefined"===typeof window?self:window,t=e.indexedDB||e.mozIndexedDB||e.webkitIndexedDB||e.msIndexedDB||e.shimIndexedDB;if(null==t)throw new Error("The current browser does not appear to support IndexedDB.");return t}function VX(e){const t=e.result;t.createObjectStore(zX,{keyPath:"modelPath"}),t.createObjectStore(BX,{keyPath:"modelPath"})}class UX{constructor(e){if(this.indexedDB=WX(),null==e||!e)throw new Error("For IndexedDB, modelPath must not be null, undefined or empty.");this.modelPath=e}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");return this.databaseAction(this.modelPath,e)}async load(){return this.databaseAction(this.modelPath)}databaseAction(e,t){return new Promise(((e,n)=>{const a=this.indexedDB.open(PX,1);a.onupgradeneeded=()=>VX(a),a.onsuccess=()=>{const r=a.result;if(null==t){const t=r.transaction(zX,"readonly"),a=t.objectStore(zX).get(this.modelPath);a.onsuccess=()=>{if(null==a.result)return r.close(),n(new Error("Cannot find model with path '".concat(this.modelPath,"' ")+"in IndexedDB."));e(a.result.modelArtifacts)},a.onerror=e=>(r.close(),n(a.error)),t.oncomplete=()=>r.close()}else{t.weightData=cX.join(t.weightData);const a=_X(t),s=r.transaction(BX,"readwrite");let i,c,l=s.objectStore(BX);try{i=l.put({modelPath:this.modelPath,modelArtifactsInfo:a})}catch(o){return n(o)}i.onsuccess=()=>{c=r.transaction(zX,"readwrite");const i=c.objectStore(zX);let u;try{u=i.put({modelPath:this.modelPath,modelArtifacts:t,modelArtifactsInfo:a})}catch(o){return n(o)}u.onsuccess=()=>e({modelArtifactsInfo:a}),u.onerror=e=>{l=s.objectStore(BX);const t=l.delete(this.modelPath);t.onsuccess=()=>(r.close(),n(u.error)),t.onerror=e=>(r.close(),n(u.error))}},i.onerror=e=>(r.close(),n(i.error)),s.oncomplete=()=>{null==c?r.close():c.oncomplete=()=>r.close()}}},a.onerror=e=>n(a.error)}))}}UX.URL_SCHEME="indexeddb://";const GX=e=>{return yG().getBool("IS_BROWSER")&&!Array.isArray(e)&&e.startsWith(UX.URL_SCHEME)?(t=e.slice(UX.URL_SCHEME.length),new UX(t)):null;var t};FX.registerSaveRouter(GX),FX.registerLoadRouter(GX);class HX{constructor(){this.indexedDB=WX()}async listModels(){return new Promise(((e,t)=>{const n=this.indexedDB.open(PX,1);n.onupgradeneeded=()=>VX(n),n.onsuccess=()=>{const a=n.result,r=a.transaction(BX,"readonly"),o=r.objectStore(BX).getAll();o.onsuccess=()=>{const t={};for(const e of o.result)t[e.modelPath]=e.modelArtifactsInfo;e(t)},o.onerror=e=>(a.close(),t(o.error)),r.oncomplete=()=>a.close()},n.onerror=e=>t(n.error)}))}async removeModel(e){var t;return e=(t=e).startsWith(UX.URL_SCHEME)?t.slice(UX.URL_SCHEME.length):t,new Promise(((t,n)=>{const a=this.indexedDB.open(PX,1);a.onupgradeneeded=()=>VX(a),a.onsuccess=()=>{const r=a.result,o=r.transaction(BX,"readwrite"),s=o.objectStore(BX),i=s.get(e);let c;i.onsuccess=()=>{if(null==i.result)return r.close(),n(new Error("Cannot find model with path '".concat(e,"' ")+"in IndexedDB."));{const a=s.delete(e),o=()=>{c=r.transaction(zX,"readwrite");const a=c.objectStore(zX).delete(e);a.onsuccess=()=>t(i.result.modelArtifactsInfo),a.onerror=e=>n(i.error)};a.onsuccess=o,a.onerror=e=>(o(),r.close(),n(i.error))}},i.onerror=e=>(r.close(),n(i.error)),o.oncomplete=()=>{null==c?r.close():c.oncomplete=()=>r.close()}},a.onerror=e=>n(a.error)}))}}const jX="/",KX="tensorflowjs_models",qX="info",XX="model_topology",YX="weight_specs",QX="weight_data",JX="model_metadata";function ZX(e){return{info:[KX,e,qX].join(jX),topology:[KX,e,XX].join(jX),weightSpecs:[KX,e,YX].join(jX),weightData:[KX,e,QX].join(jX),modelMetadata:[KX,e,JX].join(jX)}}function $X(e){for(const t of Object.values(e))window.localStorage.removeItem(t)}function eY(e){const t=e.split(jX);if(t.length<3)throw new Error("Invalid key format: ".concat(e));return t.slice(1,t.length-1).join(jX)}class tY{constructor(e){if(!yG().getBool("IS_BROWSER")||"undefined"===typeof window||"undefined"===typeof window.localStorage)throw new Error("The current environment does not support local storage.");if(this.LS=window.localStorage,null==e||!e)throw new Error("For local storage, modelPath must not be null, undefined or empty.");this.modelPath=e,this.keys=ZX(this.modelPath)}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");{const t=JSON.stringify(e.modelTopology),n=JSON.stringify(e.weightSpecs),a=_X(e),r=cX.join(e.weightData);try{this.LS.setItem(this.keys.info,JSON.stringify(a)),this.LS.setItem(this.keys.topology,t),this.LS.setItem(this.keys.weightSpecs,n),this.LS.setItem(this.keys.weightData,function(e){if(IX)return Buffer.from(e).toString("base64");const t=new Uint8Array(e);let n="";for(let a=0,r=t.length;a<r;a++)n+=String.fromCharCode(t[a]);return btoa(n)}(r));const o={format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy,signature:null!=e.signature?e.signature:void 0,userDefinedMetadata:null!=e.userDefinedMetadata?e.userDefinedMetadata:void 0,modelInitializer:null!=e.modelInitializer?e.modelInitializer:void 0,initializerSignature:null!=e.initializerSignature?e.initializerSignature:void 0,trainingConfig:null!=e.trainingConfig?e.trainingConfig:void 0};return this.LS.setItem(this.keys.modelMetadata,JSON.stringify(o)),{modelArtifactsInfo:a}}catch(ade){throw $X(this.keys),new Error("Failed to save model '".concat(this.modelPath,"' to local storage: ")+"size quota being exceeded is a possible cause of this failure: "+"modelTopologyBytes=".concat(a.modelTopologyBytes,", ")+"weightSpecsBytes=".concat(a.weightSpecsBytes,", ")+"weightDataBytes=".concat(a.weightDataBytes,"."))}}}async load(){const e=JSON.parse(this.LS.getItem(this.keys.info));if(null==e)throw new Error("In local storage, there is no model with name '".concat(this.modelPath,"'"));if("JSON"!==e.modelTopologyType)throw new Error("BrowserLocalStorage does not support loading non-JSON model topology yet.");const t={},n=JSON.parse(this.LS.getItem(this.keys.topology));if(null==n)throw new Error("In local storage, the topology of model '".concat(this.modelPath,"' ")+"is missing.");t.modelTopology=n;const a=JSON.parse(this.LS.getItem(this.keys.weightSpecs));if(null==a)throw new Error("In local storage, the weight specs of model '".concat(this.modelPath,"' ")+"are missing.");t.weightSpecs=a;const r=this.LS.getItem(this.keys.modelMetadata);if(null!=r){const e=JSON.parse(r);t.format=e.format,t.generatedBy=e.generatedBy,t.convertedBy=e.convertedBy,null!=e.signature&&(t.signature=e.signature),null!=e.userDefinedMetadata&&(t.userDefinedMetadata=e.userDefinedMetadata),null!=e.modelInitializer&&(t.modelInitializer=e.modelInitializer),null!=e.initializerSignature&&(t.initializerSignature=e.initializerSignature),null!=e.trainingConfig&&(t.trainingConfig=e.trainingConfig)}const o=this.LS.getItem(this.keys.weightData);if(null==o)throw new Error("In local storage, the binary weight values of model "+"'".concat(this.modelPath,"' are missing."));return t.weightData=function(e){if(IX){const t=Buffer.from(e,"base64");return t.buffer.slice(t.byteOffset,t.byteOffset+t.byteLength)}const t=atob(e),n=new Uint8Array(t.length);for(let a=0;a<t.length;++a)n.set([t.charCodeAt(a)],a);return n.buffer}(o),t}}tY.URL_SCHEME="localstorage://";const nY=e=>{return yG().getBool("IS_BROWSER")&&!Array.isArray(e)&&e.startsWith(tY.URL_SCHEME)?(t=e.slice(tY.URL_SCHEME.length),new tY(t)):null;var t};FX.registerSaveRouter(nY),FX.registerLoadRouter(nY);class aY{constructor(){BU(yG().getBool("IS_BROWSER"),(()=>"Current environment is not a web browser")),BU("undefined"===typeof window||"undefined"!==typeof window.localStorage,(()=>"Current browser does not appear to support localStorage")),this.LS=window.localStorage}async listModels(){const e={},t=KX+jX,n=jX+qX;for(let a=0;a<this.LS.length;++a){const r=this.LS.key(a);if(r.startsWith(t)&&r.endsWith(n)){e[eY(r)]=JSON.parse(this.LS.getItem(r))}}return e}async removeModel(e){var t;const n=ZX(e=(t=e).startsWith(tY.URL_SCHEME)?t.slice(tY.URL_SCHEME.length):t);if(null==this.LS.getItem(n.info))throw new Error("Cannot find model at path '".concat(e,"'"));const a=JSON.parse(this.LS.getItem(n.info));return $X(n),a}}const rY="://";class oY{constructor(){this.managers={}}static getInstance(){return null==oY.instance&&(oY.instance=new oY),oY.instance}static registerManager(e,t){BU(null!=e,(()=>"scheme must not be undefined or null.")),e.endsWith(rY)&&(e=e.slice(0,e.indexOf(rY))),BU(e.length>0,(()=>"scheme must not be an empty string."));const n=oY.getInstance();BU(null==n.managers[e],(()=>"A model store manager is already registered for scheme '".concat(e,"'."))),n.managers[e]=t}static getManager(e){const t=oY.getInstance().managers[e];if(null==t)throw new Error("Cannot find model manager for scheme '".concat(e,"'"));return t}static getSchemes(){return Object.keys(oY.getInstance().managers)}}function sY(e){if(-1===e.indexOf(rY))throw new Error("The url string provided does not contain a scheme. Supported schemes are: "+"".concat(oY.getSchemes().join(",")));return{scheme:e.split(rY)[0],path:e.split(rY)[1]}}async function iY(e,t){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];BU(e!==t,(()=>"Old path and new path are the same: '".concat(e,"'")));const a=FX.getLoadHandlers(e);BU(a.length>0,(()=>"Copying failed because no load handler is found for source URL ".concat(e,"."))),BU(a.length<2,(()=>"Copying failed because more than one (".concat(a.length,") ")+"load handlers for source URL ".concat(e,".")));const r=a[0],o=FX.getSaveHandlers(t);BU(o.length>0,(()=>"Copying failed because no save handler is found for destination "+"URL ".concat(t,"."))),BU(o.length<2,(()=>"Copying failed because more than one (".concat(a.length,") ")+"save handlers for destination URL ".concat(t,".")));const s=o[0],i=sY(e).scheme,c=sY(e).path,l=i===sY(e).scheme,u=await r.load();n&&l&&await oY.getManager(i).removeModel(c);const d=await s.save(u);return n&&!l&&await oY.getManager(i).removeModel(c),d.modelArtifactsInfo}async function cY(){const e=oY.getSchemes(),t={};for(const n of e){const e=await oY.getManager(n).listModels();for(const a in e){t[n+rY+a]=e[a]}}return t}async function lY(e){const t=sY(e);return oY.getManager(t.scheme).removeModel(t.path)}async function uY(e,t){return iY(e,t,!1)}async function dY(e,t){return iY(e,t,!0)}class hY{constructor(){this.messageName="setTimeoutCustom",this.functionRefs=[],this.handledMessageCount=0,this.hasEventListener=!1}fetch(e,t){return fetch(e,t)}now(){return performance.now()}encode(e,t){if("utf-8"!==t&&"utf8"!==t)throw new Error("Browser's encoder only supports utf-8, but got ".concat(t));return null==this.textEncoder&&(this.textEncoder=new TextEncoder),this.textEncoder.encode(e)}decode(e,t){return new TextDecoder(t).decode(e)}setTimeoutCustom(e,t){"undefined"!==typeof window&&yG().getBool("USE_SETTIMEOUTCUSTOM")?(this.functionRefs.push(e),setTimeout((()=>{window.postMessage({name:this.messageName,index:this.functionRefs.length-1},"*")}),t),this.hasEventListener||(this.hasEventListener=!0,window.addEventListener("message",(e=>{if(e.source===window&&e.data.name===this.messageName){e.stopPropagation();(0,this.functionRefs[e.data.index])(),this.handledMessageCount++,this.handledMessageCount===this.functionRefs.length&&(this.functionRefs=[],this.handledMessageCount=0)}}),!0))):setTimeout(e,t)}isTypedArray(e){return GK(e)}}if(yG().get("IS_BROWSER")){yG().setPlatform("browser",new hY);try{oY.registerManager(tY.URL_SCHEME,new aY)}catch(ade){}try{oY.registerManager(UX.URL_SCHEME,new HX)}catch(ade){}}const pY=()=>n(817);let fY;class mY{constructor(){this.util=n(590),this.textEncoder=new this.util.TextEncoder}fetch(e,t){return null!=yG().global.fetch?yG().global.fetch(e,t):(null==fY&&(fY=pY()),fY(e,t))}now(){const e=process.hrtime();return 1e3*e[0]+e[1]/1e6}encode(e,t){if("utf-8"!==t&&"utf8"!==t)throw new Error("Node built-in encoder only supports utf-8, but got ".concat(t));return this.textEncoder.encode(e)}decode(e,t){return 0===e.length?"":new this.util.TextDecoder(t).decode(e)}isTypedArray(e){return this.util.types.isFloat32Array(e)||this.util.types.isInt32Array(e)||this.util.types.isUint8Array(e)||this.util.types.isUint8ClampedArray(e)}}function gY(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"float32",n=arguments.length>2?arguments[2]:void 0;return t=t||"float32",dG(e),new wq(e,t,n)}yG().get("IS_NODE")&&!yG().get("IS_BROWSER")&&yG().setPlatform("node",new mY);const bY=aX({cast_:function(e,t){const n=eX(e,"x","cast");if(!function(e){return"bool"===e||"complex64"===e||"float32"===e||"int32"===e||"string"===e}(t))throw new Error("Failed to cast to unknown dtype ".concat(t));if("string"===t&&"string"!==n.dtype||"string"!==t&&"string"===n.dtype)throw new Error("Only strings can be casted to strings");const a={x:n},r={dtype:t};return jq.runKernel(KG,a,r)}});const yY=aX({clone_:function(e){const t={x:eX(e,"x","clone","string_or_numeric")};return jq.runKernel(zH,t)}});function xY(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];console.log(e.toString(t))}Hq();!function(e){Iq=e}({buffer:gY,cast:bY,clone:yY,print:xY});const vY=aX({add_:function(e,t){let n=eX(e,"a","add"),a=eX(t,"b","add");[n,a]=zq(n,a);const r={a:n,b:a};return jq.runKernel(CG,r)}});const wY=aX({floorDiv_:function(e,t){let n=eX(e,"a","floorDiv"),a=eX(t,"b","floorDiv");[n,a]=zq(n,a);const r={a:n,b:a};return jq.runKernel(FH,r)}});const kY=aX({div_:function(e,t){let n=eX(e,"a","div"),a=eX(t,"b","div");if([n,a]=zq(n,a),"int32"===n.dtype&&"int32"===a.dtype)return wY(n,a);const r={a:n,b:a};return jq.runKernel(xH,r,{})}});const IY=aX({mul_:function(e,t){let n=eX(e,"a","mul"),a=eX(t,"b","mul");[n,a]=zq(n,a);const r={a:n,b:a};return jq.runKernel(fj,r)}});const SY=aX({sqrt_:function(e){const t={x:eX(e,"x","sqrt","float32")};return jq.runKernel(eK,t)}});const NY=aX({square_:function(e){const t=eX(e,"x","square");return jq.runKernel("Square",{x:t},{})}});const CY=aX({zerosLike_:function(e){const t={x:eX(e,"x","zerosLike")};return jq.runKernel(TK,t)}});function TY(e){return jq.customGrad(e)}function EY(e,t){if((cq(e)&&"string"!==t||Array.isArray(e))&&"complex64"!==t)throw new Error("Error creating a new Scalar: value must be a primitive (number|boolean|string)");if("string"===t&&cq(e)&&!(e instanceof Uint8Array))throw new Error("When making a scalar from encoded string, the value must be `Uint8Array`.");return oX(e,[],[],t)}const RY=new Map,_Y=new Map;class AY{getClassName(){return this.constructor.className}static fromConfig(e,t){return new e(t)}}class FY{constructor(){this.classNameMap={}}static getMap(){return null==FY.instance&&(FY.instance=new FY),FY.instance}static register(e){FY.getMap().classNameMap[e.className]=[e,e.fromConfig]}}function OY(e,t,n){BU(null!=e.className,(()=>"Class being registered does not have the static className property defined.")),BU("string"===typeof e.className,(()=>"className is required to be a string, but got type "+typeof e.className)),BU(e.className.length>0,(()=>"Class being registered has an empty-string as its className, which is disallowed.")),"undefined"===typeof t&&(t="Custom"),"undefined"===typeof n&&(n=e.className);const a=t+">"+n;return FY.register(e),RY.set(a,e),_Y.set(e,a),e}class DY extends AY{minimize(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1],n=arguments.length>2?arguments[2]:void 0;const{value:a,grads:r}=this.computeGradients(e,n);if(null!=n){const e=n.map((e=>({name:e.name,tensor:r[e.name]})));this.applyGradients(e)}else this.applyGradients(r);return dX(r),t?a:(a.dispose(),null)}get iterations(){return null==this.iterations_&&(this.iterations_=0),this.iterations_}incrementIterations(){this.iterations_=this.iterations+1}computeGradients(e,t){return function(e,t){BU(aG(e),(()=>"The f passed in variableGrads(f) must be a function")),BU(null==t||Array.isArray(t)&&t.every((e=>e instanceof Tq)),(()=>"The varList passed in variableGrads(f, varList) must be an array of variables"));const n=null!=t;if(!n){t=[];for(const e in jq.registeredVariables)t.push(jq.registeredVariables[e])}const a=n?t.filter((e=>!e.trainable)):null,r=t.length;t=t.filter((e=>e.trainable)),BU(t.length>0,(()=>"variableGrads() expects at least one of the input variables to "+"be trainable, but none of the ".concat(r," variables is ")+"trainable."));const{value:o,grads:s}=jq.gradients(e,t,null,!0);BU(s.some((e=>null!=e)),(()=>"Cannot find a connection between any variable and the result of the loss function y=f(x). Please make sure the operations that use variables are inside the function f passed to minimize().")),BU(0===o.rank,(()=>"The f passed in variableGrads(f) must return a scalar, but it "+"returned a rank-".concat(o.rank," tensor")));const i={};return t.forEach(((e,t)=>{null!=s[t]&&(i[e.name]=s[t])})),null!=a&&a.forEach((e=>i[e.name]=null)),{value:o,grads:i}}(e,t)}dispose(){null!=this.iterations_&&dX(this.iterations_)}async saveIterations(){return null==this.iterations_&&(this.iterations_=0),{name:"iter",tensor:EY(this.iterations_,"int32")}}async getWeights(){throw new Error("getWeights() is not implemented for this optimizer yet.")}async setWeights(e){throw new Error("setWeights() is not implemented for this optimizer class "+"".concat(this.getClassName()))}async extractIterations(e){return this.iterations_=(await e[0].tensor.data())[0],e.slice(1)}}Object.defineProperty(DY,Symbol.hasInstance,{value:e=>null!=e.minimize&&null!=e.computeGradients&&null!=e.applyGradients});function MY(e,t,n){dG(e);const a={shape:e,value:t,dtype:n=n||nG(t)};return jq.runKernel(RH,{},a)}const LY=aX({pow_:function(e,t){let n=eX(e,"base","pow"),a=eX(t,"exp","pow");[n,a]=zq(n,a);const r={a:n,b:a};return jq.runKernel(Sj,r)}});const PY=aX({sub_:function(e,t){let n=eX(e,"a","sub"),a=eX(t,"b","sub");[n,a]=zq(n,a);const r={a:n,b:a};return jq.runKernel(bK,r)}});const zY=aX({abs_:function(e){const t=eX(e,"x","abs");if("complex64"===t.dtype){const e={x:t};return jq.runKernel(QG,e)}{const e={x:t};return jq.runKernel(IG,e)}}});function BY(e,t){const n=e.length,a=[];for(let r=0;r<n;r++){const o=n-1-r,s=e[o]||1;(t[t.length-1-r]||1)>1&&1===s&&a.unshift(o)}return a}function WY(e,t){const n=[];for(let a=0;a<t.length;a++){const r=e[e.length-a-1],o=t.length-a-1,s=t[o];(null==r||1===r&&s>1)&&n.unshift(o)}return n}function VY(e,t){const n=Math.max(e.length,t.length),a=new Array(n);for(let r=0;r<n;r++){let o=e[e.length-r-1];null==o&&(o=1);let s=t[t.length-r-1];if(null==s&&(s=1),1===o)a[n-r-1]=s;else if(1===s)a[n-r-1]=o;else{if(o!==s){const n="Operands could not be broadcast together with shapes "+"".concat(e," and ").concat(t,".");throw Error(n)}a[n-r-1]=o}}return a}const UY=aX({maximum_:function(e,t){let n=eX(e,"a","maximum"),a=eX(t,"b","maximum");[n,a]=zq(n,a),"bool"===n.dtype&&(n=bY(n,"int32"),a=bY(a,"int32")),VY(n.shape,a.shape);const r={a:n,b:a};return jq.runKernel(nj,r)}});class GY extends DY{static get className(){return"SGD"}constructor(e){super(),this.learningRate=e,this.setLearningRate(e)}applyGradients(e){const t=Array.isArray(e)?e.map((e=>e.name)):Object.keys(e);t.forEach(((t,n)=>{const a=Array.isArray(e)?e[n].tensor:e[t];if(null==a)return;const r=jq.registeredVariables[t];uX((()=>{const e=vY(IY(this.c,a),r);r.assign(e)}))})),this.incrementIterations()}setLearningRate(e){this.learningRate=e,null!=this.c&&this.c.dispose(),this.c=hX(EY(-e))}dispose(){this.c.dispose()}async getWeights(){return[await this.saveIterations()]}async setWeights(e){if(0!==(e=await this.extractIterations(e)).length)throw new Error("SGD optimizer does not have settable weights.")}getConfig(){return{learningRate:this.learningRate}}static fromConfig(e,t){return new e(t.learningRate)}}const HY=[class extends DY{static get className(){return"Adadelta"}constructor(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null;super(),this.learningRate=e,this.rho=t,this.epsilon=n,this.accumulatedGrads=[],this.accumulatedUpdates=[],null==n&&(this.epsilon=jq.backend.epsilon())}applyGradients(e){(Array.isArray(e)?e.map((e=>e.name)):Object.keys(e)).forEach(((t,n)=>{const a=jq.registeredVariables[t],r=!1;null==this.accumulatedGrads[n]&&(this.accumulatedGrads[n]={originalName:"".concat(t,"/accum_grad"),variable:uX((()=>CY(a).variable(r)))}),null==this.accumulatedUpdates[n]&&(this.accumulatedUpdates[n]={originalName:"".concat(t,"/accum_var"),variable:uX((()=>CY(a).variable(r)))});const o=Array.isArray(e)?e[n].tensor:e[t];if(null==o)return;const s=this.accumulatedGrads[n].variable,i=this.accumulatedUpdates[n].variable;uX((()=>{const e=vY(IY(s,this.rho),IY(NY(o),1-this.rho)),t=IY(kY(SY(vY(i,this.epsilon)),SY(vY(s,this.epsilon))),o),n=vY(IY(i,this.rho),IY(NY(t),1-this.rho));s.assign(e),i.assign(n);const r=vY(IY(t,-this.learningRate),a);a.assign(r)}))})),this.incrementIterations()}dispose(){null!=this.accumulatedUpdates&&(dX(this.accumulatedGrads.map((e=>e.variable))),dX(this.accumulatedUpdates.map((e=>e.variable))))}async getWeights(){const e=[...this.accumulatedGrads,...this.accumulatedUpdates];return[await this.saveIterations()].concat(e.map((e=>({name:e.originalName,tensor:e.variable}))))}async setWeights(e){const t=(e=await this.extractIterations(e)).length/2,n=!1;this.accumulatedGrads=e.slice(0,t).map((e=>({originalName:e.name,variable:e.tensor.variable(n)}))),this.accumulatedUpdates=e.slice(t,2*t).map((e=>({originalName:e.name,variable:e.tensor.variable(n)})))}getConfig(){return{learningRate:this.learningRate,rho:this.rho,epsilon:this.epsilon}}static fromConfig(e,t){return new e(t.learningRate,t.rho,t.epsilon)}},class extends DY{static get className(){return"Adagrad"}constructor(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:.1;super(),this.learningRate=e,this.initialAccumulatorValue=t,this.accumulatedGrads=[]}applyGradients(e){(Array.isArray(e)?e.map((e=>e.name)):Object.keys(e)).forEach(((t,n)=>{const a=jq.registeredVariables[t];if(null==this.accumulatedGrads[n]){const e=!1;this.accumulatedGrads[n]={originalName:"".concat(t,"/accumulator"),variable:uX((()=>MY(a.shape,this.initialAccumulatorValue).variable(e)))}}const r=Array.isArray(e)?e[n].tensor:e[t];if(null==r)return;const o=this.accumulatedGrads[n].variable;uX((()=>{const e=vY(o,NY(r));o.assign(e);const t=vY(IY(kY(r,SY(vY(e,jq.backend.epsilon()))),-this.learningRate),a);a.assign(t)}))})),this.incrementIterations()}dispose(){null!=this.accumulatedGrads&&dX(this.accumulatedGrads.map((e=>e.variable)))}async getWeights(){return[await this.saveIterations()].concat(this.accumulatedGrads.map((e=>({name:e.originalName,tensor:e.variable}))))}async setWeights(e){e=await this.extractIterations(e);this.accumulatedGrads=e.map((e=>({originalName:e.name,variable:e.tensor.variable(false)})))}getConfig(){return{learningRate:this.learningRate,initialAccumulatorValue:this.initialAccumulatorValue}}static fromConfig(e,t){return new e(t.learningRate,t.initialAccumulatorValue)}},class extends DY{static get className(){return"Adam"}constructor(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:null;super(),this.learningRate=e,this.beta1=t,this.beta2=n,this.epsilon=a,this.accumulatedFirstMoment=[],this.accumulatedSecondMoment=[],uX((()=>{this.accBeta1=EY(t).variable(),this.accBeta2=EY(n).variable()})),null==a&&(this.epsilon=jq.backend.epsilon())}applyGradients(e){const t=Array.isArray(e)?e.map((e=>e.name)):Object.keys(e);uX((()=>{const n=PY(1,this.accBeta1),a=PY(1,this.accBeta2);t.forEach(((t,r)=>{const o=jq.registeredVariables[t],s=!1;null==this.accumulatedFirstMoment[r]&&(this.accumulatedFirstMoment[r]={originalName:"".concat(t,"/m"),variable:uX((()=>CY(o).variable(s)))}),null==this.accumulatedSecondMoment[r]&&(this.accumulatedSecondMoment[r]={originalName:"".concat(t,"/v"),variable:uX((()=>CY(o).variable(s)))});const i=Array.isArray(e)?e[r].tensor:e[t];if(null==i)return;const c=this.accumulatedFirstMoment[r].variable,l=this.accumulatedSecondMoment[r].variable,u=vY(IY(c,this.beta1),IY(i,1-this.beta1)),d=vY(IY(l,this.beta2),IY(NY(i),1-this.beta2)),h=kY(u,n),p=kY(d,a);c.assign(u),l.assign(d);const f=vY(IY(kY(h,vY(SY(p),this.epsilon)),-this.learningRate),o);o.assign(f)})),this.accBeta1.assign(IY(this.accBeta1,this.beta1)),this.accBeta2.assign(IY(this.accBeta2,this.beta2))})),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.accBeta2.dispose(),null!=this.accumulatedFirstMoment&&dX(this.accumulatedFirstMoment.map((e=>e.variable))),null!=this.accumulatedSecondMoment&&dX(this.accumulatedSecondMoment.map((e=>e.variable)))}async getWeights(){const e=[...this.accumulatedFirstMoment,...this.accumulatedSecondMoment];return[await this.saveIterations()].concat(e.map((e=>({name:e.originalName,tensor:e.variable}))))}async setWeights(e){e=await this.extractIterations(e),uX((()=>{this.accBeta1.assign(LY(this.beta1,this.iterations_+1)),this.accBeta2.assign(LY(this.beta2,this.iterations_+1))}));const t=e.length/2,n=!1;this.accumulatedFirstMoment=e.slice(0,t).map((e=>({originalName:e.name,variable:e.tensor.variable(n)}))),this.accumulatedSecondMoment=e.slice(t,2*t).map((e=>({originalName:e.name,variable:e.tensor.variable(n)})))}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon}}static fromConfig(e,t){return new e(t.learningRate,t.beta1,t.beta2,t.epsilon)}},class extends DY{static get className(){return"Adamax"}constructor(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:null,r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:0;super(),this.learningRate=e,this.beta1=t,this.beta2=n,this.epsilon=a,this.decay=r,this.accumulatedFirstMoment=[],this.accumulatedWeightedInfNorm=[],uX((()=>{this.iteration=EY(0).variable(),this.accBeta1=EY(t).variable()})),null==a&&(this.epsilon=jq.backend.epsilon())}applyGradients(e){const t=Array.isArray(e)?e.map((e=>e.name)):Object.keys(e);uX((()=>{const n=PY(1,this.accBeta1),a=kY(-this.learningRate,vY(IY(this.iteration,this.decay),1));t.forEach(((t,r)=>{const o=jq.registeredVariables[t],s=!1;null==this.accumulatedFirstMoment[r]&&(this.accumulatedFirstMoment[r]={originalName:"".concat(t,"/m"),variable:CY(o).variable(s)}),null==this.accumulatedWeightedInfNorm[r]&&(this.accumulatedWeightedInfNorm[r]={originalName:"".concat(t,"/v"),variable:CY(o).variable(s)});const i=Array.isArray(e)?e[r].tensor:e[t];if(null==i)return;const c=this.accumulatedFirstMoment[r].variable,l=this.accumulatedWeightedInfNorm[r].variable,u=vY(IY(c,this.beta1),IY(i,1-this.beta1)),d=IY(l,this.beta2),h=zY(i),p=UY(d,h);c.assign(u),l.assign(p);const f=vY(IY(kY(a,n),kY(u,vY(p,this.epsilon))),o);o.assign(f)})),this.iteration.assign(vY(this.iteration,1)),this.accBeta1.assign(IY(this.accBeta1,this.beta1))})),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.iteration.dispose(),null!=this.accumulatedFirstMoment&&dX(this.accumulatedFirstMoment.map((e=>e.variable))),null!=this.accumulatedWeightedInfNorm&&dX(this.accumulatedWeightedInfNorm.map((e=>e.variable)))}async getWeights(){throw new Error("getWeights() is not implemented for Adamax yet.")}async setWeights(e){throw new Error("setWeights() is not implemented for Adamax yet.")}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon,decay:this.decay}}static fromConfig(e,t){return new e(t.learningRate,t.beta1,t.beta2,t.epsilon,t.decay)}},class extends GY{static get className(){return"Momentum"}constructor(e,t){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];super(e),this.learningRate=e,this.momentum=t,this.useNesterov=n,this.accumulations=[],this.m=EY(this.momentum)}applyGradients(e){(Array.isArray(e)?e.map((e=>e.name)):Object.keys(e)).forEach(((t,n)=>{const a=jq.registeredVariables[t];if(null==this.accumulations[n]){const e=!1;this.accumulations[n]={originalName:"".concat(t,"/momentum"),variable:uX((()=>CY(a).variable(e)))}}const r=this.accumulations[n].variable,o=Array.isArray(e)?e[n].tensor:e[t];null!=o&&uX((()=>{let e;const t=vY(IY(this.m,r),o);e=this.useNesterov?vY(IY(this.c,vY(o,IY(t,this.m))),a):vY(IY(this.c,t),a),r.assign(t),a.assign(e)}))})),this.incrementIterations()}dispose(){this.m.dispose(),null!=this.accumulations&&dX(this.accumulations.map((e=>e.variable)))}setMomentum(e){this.momentum=e}async getWeights(){return[await this.saveIterations()].concat(this.accumulations.map((e=>({name:e.originalName,tensor:e.variable}))))}async setWeights(e){e=await this.extractIterations(e);this.accumulations=e.map((e=>({originalName:e.name,variable:e.tensor.variable(false)})))}getConfig(){return{learningRate:this.learningRate,momentum:this.momentum,useNesterov:this.useNesterov}}static fromConfig(e,t){return new e(t.learningRate,t.momentum,t.useNesterov)}},class extends DY{static get className(){return"RMSProp"}constructor(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:.9,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:null,r=arguments.length>4&&void 0!==arguments[4]&&arguments[4];if(super(),this.learningRate=e,this.decay=t,this.momentum=n,this.epsilon=a,this.accumulatedMeanSquares=[],this.accumulatedMoments=[],this.accumulatedMeanGrads=[],this.centered=r,null==a&&(this.epsilon=jq.backend.epsilon()),null==e)throw new Error("learningRate for RMSPropOptimizer must be defined.")}applyGradients(e){(Array.isArray(e)?e.map((e=>e.name)):Object.keys(e)).forEach(((t,n)=>{const a=jq.registeredVariables[t],r=!1;null==this.accumulatedMeanSquares[n]&&(this.accumulatedMeanSquares[n]={originalName:"".concat(t,"/rms"),variable:uX((()=>CY(a).variable(r)))}),null==this.accumulatedMoments[n]&&(this.accumulatedMoments[n]={originalName:"".concat(t,"/momentum"),variable:uX((()=>CY(a).variable(r)))}),null==this.accumulatedMeanGrads[n]&&this.centered&&(this.accumulatedMeanGrads[n]={originalName:"".concat(t,"/mg"),variable:uX((()=>CY(a).variable(r)))});const o=Array.isArray(e)?e[n].tensor:e[t];if(null==o)return;const s=this.accumulatedMeanSquares[n].variable,i=this.accumulatedMoments[n].variable;uX((()=>{const e=vY(IY(s,this.decay),IY(NY(o),1-this.decay));if(this.centered){const t=this.accumulatedMeanGrads[n].variable,r=vY(IY(t,this.decay),IY(o,1-this.decay)),c=kY(IY(o,this.learningRate),SY(PY(e,vY(NY(r),this.epsilon)))),l=vY(IY(i,this.momentum),c);s.assign(e),t.assign(r),i.assign(l);const u=PY(a,l);a.assign(u)}else{const e=vY(IY(s,this.decay),IY(NY(o),1-this.decay)),t=vY(IY(i,this.momentum),kY(IY(o,this.learningRate),SY(vY(e,this.epsilon))));s.assign(e),i.assign(t);const n=PY(a,t);a.assign(n)}}))})),this.incrementIterations()}dispose(){null!=this.accumulatedMeanSquares&&dX(this.accumulatedMeanSquares.map((e=>e.variable))),null!=this.accumulatedMeanGrads&&this.centered&&dX(this.accumulatedMeanGrads.map((e=>e.variable))),null!=this.accumulatedMoments&&dX(this.accumulatedMoments.map((e=>e.variable)))}async getWeights(){const e=[...this.accumulatedMeanSquares,...this.accumulatedMoments];return this.centered&&e.push(...this.accumulatedMeanGrads),[await this.saveIterations()].concat(e.map((e=>({name:e.originalName,tensor:e.variable}))))}async setWeights(e){e=await this.extractIterations(e);const t=this.centered?e.length/3:e.length/2,n=!1;this.accumulatedMeanSquares=e.slice(0,t).map((e=>({originalName:e.name,variable:e.tensor.variable(n)}))),this.accumulatedMoments=e.slice(t,2*t).map((e=>({originalName:e.name,variable:e.tensor.variable(n)}))),this.centered&&(this.accumulatedMeanGrads=e.slice(2*t,3*t).map((e=>({originalName:e.name,variable:e.tensor.variable(n)}))))}getConfig(){return{learningRate:this.learningRate,decay:this.decay,momentum:this.momentum,epsilon:this.epsilon,centered:this.centered}}static fromConfig(e,t){return new e(t.learningRate,t.decay,t.momentum,t.epsilon,t.centered)}},GY];function jY(e){return new Promise((e=>setTimeout(e))).then(e)}class KY{constructor(e){if(!yG().getBool("IS_BROWSER"))throw new Error("browserDownloads() cannot proceed because the current environment is not a browser.");e.startsWith(KY.URL_SCHEME)&&(e=e.slice(KY.URL_SCHEME.length)),null!=e&&0!==e.length||(e="model"),this.modelJsonFileName=e+".json",this.weightDataFileName=e+".weights.bin"}async save(e){if("undefined"===typeof document)throw new Error("Browser downloads are not supported in this environment since `document` is not present");const t=cX.join(e.weightData),n=window.URL.createObjectURL(new Blob([t],{type:"application/octet-stream"}));if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserDownloads.save() does not support saving model topology in binary formats yet.");{const t=TX(e,[{paths:["./"+this.weightDataFileName],weights:e.weightSpecs}]),a=window.URL.createObjectURL(new Blob([JSON.stringify(t)],{type:"application/json"})),r=null==this.modelJsonAnchor?document.createElement("a"):this.modelJsonAnchor;if(r.download=this.modelJsonFileName,r.href=a,await jY((()=>r.dispatchEvent(new MouseEvent("click")))),null!=e.weightData){const e=null==this.weightDataAnchor?document.createElement("a"):this.weightDataAnchor;e.download=this.weightDataFileName,e.href=n,await jY((()=>e.dispatchEvent(new MouseEvent("click"))))}return{modelArtifactsInfo:_X(e)}}}}KY.URL_SCHEME="downloads://";class qY{constructor(e){if(null==e||e.length<1)throw new Error("When calling browserFiles, at least 1 file is required, "+"but received ".concat(e));this.jsonFile=e[0],this.weightsFiles=e.slice(1)}async load(){return new Promise(((e,t)=>{const n=new FileReader;n.onload=n=>{const a=JSON.parse(n.target.result),r=a.modelTopology;if(null==r)return void t(new Error("modelTopology field is missing from file ".concat(this.jsonFile.name)));if(null==a.weightsManifest)return void t(new Error("weightManifest field is missing from file ".concat(this.jsonFile.name)));if(0===this.weightsFiles.length)return void e({modelTopology:r});const o=RX(a,(e=>this.loadWeights(e)));e(o)},n.onerror=e=>t("Failed to read model topology and weights manifest JSON "+"from file '".concat(this.jsonFile.name,"'. BrowserFiles supports loading ")+"Keras-style tf.Model artifacts only."),n.readAsText(this.jsonFile)}))}loadWeights(e){const t=[],n=[];for(const o of e)t.push(...o.weights),n.push(...o.paths);const a=this.checkManifestAndWeightFiles(e),r=n.map((e=>this.loadWeightsFile(e,a[e])));return Promise.all(r).then((e=>[t,e]))}loadWeightsFile(e,t){return new Promise(((n,a)=>{const r=new FileReader;r.onload=e=>{const t=e.target.result;n(t)},r.onerror=t=>a("Failed to weights data from file of path '".concat(e,"'.")),r.readAsArrayBuffer(t)}))}checkManifestAndWeightFiles(e){const t=[],n=this.weightsFiles.map((e=>CX(e.name))),a={};for(const r of e)r.paths.forEach((e=>{const r=CX(e);if(-1!==t.indexOf(r))throw new Error("Duplicate file basename found in weights manifest: "+"'".concat(r,"'"));if(t.push(r),-1===n.indexOf(r))throw new Error("Weight file with basename '".concat(r,"' is not provided."));a[e]=this.weightsFiles[n.indexOf(r)]}));if(t.length!==this.weightsFiles.length)throw new Error("Mismatch in the number of files in weights manifest "+"(".concat(t.length,") and the number of weight files provided ")+"(".concat(this.weightsFiles.length,")."));return a}}function XY(e){return new qY(e)}function YY(e,t,n,a){!function(e){BU(null!=e&&Array.isArray(e)&&e.length>0,(()=>"promises must be a none empty array"))}(e),function(e,t){BU(e>=0&&e<=1,(()=>"Progress fraction must be in range [0, 1], but "+"got startFraction ".concat(e))),BU(t>=0&&t<=1,(()=>"Progress fraction must be in range [0, 1], but "+"got endFraction ".concat(t))),BU(t>=e,(()=>"startFraction must be no more than endFraction, but "+"got startFraction ".concat(e," and endFraction ")+"".concat(t)))}(n=null==n?0:n,a=null==a?1:a);let r=0;return Promise.all(e.map((o=>(o.then((o=>{const s=n+ ++r/e.length*(a-n);return t(s),o})),o))))}async function QY(e,t){null==t&&(t={});const n=null==t.fetchFunc?yG().platform.fetch:t.fetchFunc,a=e.map((e=>n(e,t.requestInit,{isBinary:!0}))),r=(null==t.onProgress?await Promise.all(a):await YY(a,t.onProgress,0,.5)).map((e=>e.arrayBuffer()));return null==t.onProgress?await Promise.all(r):await YY(r,t.onProgress,.5,1)}async function JY(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"",n=arguments.length>2?arguments[2]:void 0,a=arguments.length>3?arguments[3]:void 0;return ZY((e=>QY(e,{requestInit:a})))(e,t,n)}function ZY(e){return async function(t){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"",a=arguments.length>2?arguments[2]:void 0;const r=t.map((()=>!1)),o={},s=null!=a?a.map((()=>!1)):[],i=[];if(t.forEach(((e,t)=>{let n=0;e.weights.forEach((e=>{const c="quantization"in e?e.quantization.dtype:e.dtype,l=iX[c]*UU(e.shape),u=()=>{r[t]=!0,null==o[t]&&(o[t]=[]),o[t].push({manifestEntry:e,groupOffset:n,sizeBytes:l})};null!=a?a.forEach(((t,n)=>{t===e.name&&(u(),s[n]=!0)})):u(),i.push(e.name),n+=l}))})),!s.every((e=>e))){const e=a.filter(((e,t)=>!s[t]));throw new Error("Could not find weights in manifest with names: "+"".concat(e.join(", "),". \n")+"Manifest JSON has weights with names: "+"".concat(i.join(", "),"."))}const c=r.reduce(((e,t,n)=>(t&&e.push(n),e)),[]),l=[];c.forEach((e=>{t[e].paths.forEach((e=>{const t=n+(n.endsWith("/")?"":"/")+e;l.push(t)}))}));const u=await e(l),d={};let h=0;return c.forEach((e=>{const n=t[e].paths.length,a=new cX(u.slice(h,h+n));o[e].forEach((e=>{const t=gX(a.slice(e.groupOffset,e.groupOffset+e.sizeBytes),[e.manifestEntry]);for(const n in t)d[n]=t[n]})),h+=n})),d}}FX.registerSaveRouter((e=>yG().getBool("IS_BROWSER")&&!Array.isArray(e)&&e.startsWith(KY.URL_SCHEME)?function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:"model";return new KY(e)}(e.slice(KY.URL_SCHEME.length)):null));class $Y{constructor(e,t){if(this.DEFAULT_METHOD="POST",null==t&&(t={}),this.weightPathPrefix=t.weightPathPrefix,this.weightUrlConverter=t.weightUrlConverter,null!=t.fetchFunc?(BU("function"===typeof t.fetchFunc,(()=>"Must pass a function that matches the signature of `fetch` (see https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)")),this.fetch=t.fetchFunc):this.fetch=yG().platform.fetch,BU(null!=e&&e.length>0,(()=>"URL path for http must not be null, undefined or empty.")),Array.isArray(e)&&BU(2===e.length,(()=>"URL paths for http must have a length of 2, "+"(actual length is ".concat(e.length,")."))),this.path=e,null!=t.requestInit&&null!=t.requestInit.body)throw new Error("requestInit is expected to have no pre-existing body, but has one.");this.requestInit=t.requestInit||{},this.loadOptions=t}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserHTTPRequest.save() does not support saving model topology in binary formats yet.");const t=Object.assign({method:this.DEFAULT_METHOD},this.requestInit);t.body=new FormData;const n=TX(e,[{paths:["./model.weights.bin"],weights:e.weightSpecs}]);if(t.body.append("model.json",new Blob([JSON.stringify(n)],{type:"application/json"}),"model.json"),null!=e.weightData){const n=cX.join(e.weightData);t.body.append("model.weights.bin",new Blob([n],{type:"application/octet-stream"}),"model.weights.bin")}const a=await this.fetch(this.path,t);if(a.ok)return{modelArtifactsInfo:_X(e),responses:[a]};throw new Error("BrowserHTTPRequest.save() failed due to HTTP response status "+"".concat(a.status,"."))}async loadModelJSON(){const e=await this.fetch(this.path,this.requestInit);if(!e.ok)throw new Error("Request to ".concat(this.path," failed with status code ")+"".concat(e.status,". Please verify this URL points to ")+"the model JSON of the model to load.");let t;try{t=await e.json()}catch(B){let t="Failed to parse model JSON of response from ".concat(this.path,".");throw this.path.endsWith(".pb")?t+=" Your path contains a .pb file extension. Support for .pb models have been removed in TensorFlow.js 1.0 in favor of .json models. You can re-convert your Python TensorFlow model using the TensorFlow.js 1.0 conversion scripts or you can convert your.pb models with the 'pb2json'NPM script in the tensorflow/tfjs-converter repository.":t+=" Please make sure the server is serving valid JSON for this request.",new Error(t)}const n=t.modelTopology,a=t.weightsManifest;if(null==n&&null==a)throw new Error("The JSON from HTTP path ".concat(this.path," contains neither model ")+"topology or manifest for weights.");return t}async load(){if(this.loadOptions.streamWeights)return this.loadStream();return RX(await this.loadModelJSON(),(e=>this.loadWeights(e)))}async loadStream(){const e=await this.loadModelJSON(),t=await this.getWeightUrls(e.weightsManifest),n=AX(e.weightsManifest);return Object.assign(Object.assign({},e),{weightSpecs:n,getWeightStream:()=>function(e,t){var n;const a=null==t.fetchFunc?yG().platform.fetch:t.fetchFunc;let r,o=0;return null===(n=t.onProgress)||void 0===n||n.call(t,0),new ReadableStream({pull:async n=>{for(var s;o<e.length;){if(!r){const n=(await a(e[o],t.requestInit,{isBinary:!0})).body;r=n.getReader()}const{done:i,value:c}=await r.read();if(!i)return void n.enqueue(c);o++,r=void 0,null===(s=t.onProgress)||void 0===s||s.call(t,o/e.length)}n.close()}})}(t,this.loadOptions)})}async getWeightUrls(e){const t=Array.isArray(this.path)?this.path[1]:this.path,[n,a]=function(e){const t=e.lastIndexOf("/"),n=e.lastIndexOf("?"),a=e.substring(0,t),r=n>t?e.substring(n):"";return[a+"/",r]}(t),r=this.weightPathPrefix||n,o=[],s=[];for(const i of e)for(const e of i.paths)null!=this.weightUrlConverter?s.push(this.weightUrlConverter(e)):o.push(r+e+a);return this.weightUrlConverter&&o.push(...await Promise.all(s)),o}async loadWeights(e){const t=await this.getWeightUrls(e);return[AX(e),await QY(t,this.loadOptions)]}}function eQ(e){return null!=e.match($Y.URL_SCHEME_REGEX)}$Y.URL_SCHEME_REGEX=/^https?:\/\//;const tQ=(e,t)=>{if("undefined"===typeof fetch&&(null==t||null==t.fetchFunc))return null;{let n=!0;if(n=Array.isArray(e)?e.every((e=>eQ(e))):eQ(e),n)return nQ(e,t)}return null};function nQ(e,t){return new $Y(e,t)}function aQ(e,t){return nQ(e,t)}FX.registerSaveRouter(tQ),FX.registerLoadRouter(tQ);class rQ{constructor(e){this.modelArtifacts=e}load(){return this.modelArtifacts}}class oQ{constructor(e){this.saveHandler=e}save(e){return this.saveHandler(e)}}class sQ{constructor(e){e.load&&(this.load=()=>Promise.resolve(e.load())),e.save&&(this.save=t=>Promise.resolve(e.save(t)))}}function iQ(e,t,n,a){return new sQ(cQ(...arguments))}function cQ(e,t,n,a){if(1===arguments.length){return null!=e.modelTopology||null!=e.weightSpecs?new rQ(e):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new rQ({modelTopology:e}))}return console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new rQ({modelTopology:e,weightSpecs:t,weightData:n,trainingConfig:a})}function lQ(e){return new oQ(e)}function uQ(e){return new oQ(e)}function dQ(e,t,n){if(VU(e),null!=t&&3!==t.length)throw new Error("tensor3d() requires shape to have three numbers");const a=Jq(e,n);if(3!==a.length&&1!==a.length)throw new Error("tensor3d() requires values to be number[][][] or flat/TypedArray");if(1===a.length&&null==t)throw new Error("tensor3d() requires shape to be provided when `values` are a flat array");return oX(e,t,a,n)}let hQ;function pQ(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:3;if(t>4)throw new Error("Cannot construct Tensor with more than 4 channels from pixels.");if(null==e)throw new Error("pixels passed to tf.browser.fromPixels() can not be null");let n=!1,a=!1,r=!1,o=!1,s=!1,i=!1;if(e.data instanceof Uint8Array)n=!0;else if("undefined"!==typeof ImageData&&e instanceof ImageData)a=!0;else if("undefined"!==typeof HTMLVideoElement&&e instanceof HTMLVideoElement)r=!0;else if("undefined"!==typeof HTMLImageElement&&e instanceof HTMLImageElement)o=!0;else if(null!=e.getContext)s=!0;else{if(!("undefined"!==typeof ImageBitmap&&e instanceof ImageBitmap))throw new Error("pixels passed to tf.browser.fromPixels() must be either an HTMLVideoElement, HTMLImageElement, HTMLCanvasElement, ImageData in browser, or OffscreenCanvas, ImageData in webworker or {data: Uint32Array, width: number, height: number}, "+"but was ".concat(e.constructor.name));i=!0}if(null!=zK(RK,jq.backendName)){const n={pixels:e},a={numChannels:t};return jq.runKernel(RK,n,a)}const[c,l]=r?[e.videoWidth,e.videoHeight]:[e.width,e.height];let u,d;if(s)u=e.getContext("2d").getImageData(0,0,c,l).data;else if(a||n)u=e.data;else if(o||r||i){if(null==hQ)if("undefined"===typeof document){if("undefined"===typeof OffscreenCanvas||"undefined"===typeof OffscreenCanvasRenderingContext2D)throw new Error("Cannot parse input in current context. Reason: OffscreenCanvas Context2D rendering is not supported.");hQ=new OffscreenCanvas(1,1).getContext("2d")}else hQ=document.createElement("canvas").getContext("2d",{willReadFrequently:!0});hQ.canvas.width=c,hQ.canvas.height=l,hQ.drawImage(e,0,0,c,l),u=hQ.getImageData(0,0,c,l).data}if(4===t)d=new Int32Array(u);else{const e=c*l;d=new Int32Array(e*t);for(let n=0;n<e;n++)for(let e=0;e<t;++e)d[n*t+e]=u[4*n+e]}return dQ(d,[l,c,t],"int32")}const fQ=aX({fromPixels_:pQ}),mQ=-2,gQ=-1;function bQ(e,t,n){const a=e.shape.length;BU(a===t.length,(()=>"Error in slice".concat(a,"D: Length of begin ").concat(t," must ")+"match the rank of the array (".concat(a,")."))),BU(a===n.length,(()=>"Error in slice".concat(a,"D: Length of size ").concat(n," must ")+"match the rank of the array (".concat(a,").")));for(let r=0;r<a;++r)BU(t[r]+n[r]<=e.shape[r],(()=>"Error in slice".concat(a,"D: begin[").concat(r,"] + size[").concat(r,"] ")+"(".concat(t[r]+n[r],") would overflow input.shape[").concat(r,"] (").concat(e.shape[r],")")))}function yQ(e){const t=[];let n=0;for(;e>0;)1&e&&t.push(n),e/=2,n++;return t}function xQ(e,t,n){const a=[];for(let r=0;r<e.length;r++)a[r]=Math.ceil((t[r]-e[r])/n[r]);return a}function vQ(e,t,n,a){const r=[...e];for(let o=r.length;o<a.length;o++)r.push(1);for(let o=0;o<n;o++)0===o?r[t]=1:(r.splice(t,0,1),r.pop());return r}function wQ(e,t,n){return n<=e?n:n-(t-1)}function kQ(e,t){const n=[];for(let a=0;a<e;a++)n.push(t+a);return n}function IQ(e,t,n,a,r,o,s,i,c){const l=e.length;let u=new Array(l),d=new Array(l),h=new Array(l);if(t.length&&n>0){const c=t[0],l=n+1;u=SQ(s,c,l,a,e),d=NQ(i,c,l,r,e),h=vQ(o,c,l,e)}else for(let p=0;p<l;p++)u[p]=TQ(s,a,o,e,p,c),d[p]=EQ(i,r,o,e,p,c),h[p]=CQ(o,p,c);return{begin:u,end:d,strides:h}}function SQ(e,t,n,a,r){const o=[...r],s=kQ(n,t);for(let i=0;i<o.length;i++)if(s.indexOf(i)>-1)o[i]=0;else{const r=wQ(t,n,i);let s=a[r];e&1<<r&&(s=0),o[i]=s}return o}function NQ(e,t,n,a,r){const o=[...r],s=kQ(n,t);for(let i=0;i<o.length;i++)if(s.indexOf(i)>-1)o[i]=Number.MAX_SAFE_INTEGER;else{const r=wQ(t,n,i);let s=a[r];e&1<<r&&(s=Number.MAX_SAFE_INTEGER),o[i]=s}for(let i=0;i<o.length;i++){const e=r[i];o[i]<0&&(o[i]+=e),o[i]=LU(0,o[i],r[i])}return o}function CQ(e,t,n){let a=e[t];return(n&1<<t||null==a)&&(a=1),a}function TQ(e,t,n,a,r,o){let s=t[r];const i=n[r]||1;(e&1<<r||o&1<<r||null==s)&&(s=i>0?Number.MIN_SAFE_INTEGER:Number.MAX_SAFE_INTEGER);const c=a[r];return s<0&&(s+=c),s=LU(0,s,c-1),s}function EQ(e,t,n,a,r,o){let s=t[r];const i=n[r]||1;(e&1<<r||o&1<<r||null==s)&&(s=i>0?Number.MAX_SAFE_INTEGER:Number.MIN_SAFE_INTEGER);const c=a[r];return s<0&&(s+=c),s=i>0?LU(0,s,c):LU(-1,s,c-1),s}function RQ(e,t,n){let a=n.length;for(let r=0;r<n.length;r++)if(n[r]>1){a=r;break}for(let r=a+1;r<n.length;r++)if(t[r]>0||n[r]!==e[r])return!1;return!0}function _Q(e,t){let n=e.length>0?e[e.length-1]:1;for(let a=0;a<e.length-1;a++)n+=e[a]*t[a];return n}function AQ(e,t,n){let a;const r=e.shape.length;let o;return a="number"===typeof t?[t,...new Array(r-1).fill(0)]:t.length<r?t.concat(new Array(r-t.length).fill(0)):t.slice(),a.forEach((e=>{BU(-1!==e,(()=>"slice() does not support negative begin indexing."))})),o=null==n?new Array(r).fill(-1):"number"===typeof n?[n,...new Array(r-1).fill(-1)]:n.length<r?n.concat(new Array(r-n.length).fill(-1)):n,o=o.map(((t,n)=>t>=0?t:(BU(-1===t,(()=>"Negative size values should be exactly -1 but got "+"".concat(t," for the slice() size at index ").concat(n,"."))),e.shape[n]-a[n]))),[a,o]}function FQ(e,t,n,a,r,o,s,i,c){let l;if(null==a?(l=new Array(t.length),l.fill(1)):l=a,null!=s&&0!==(s&s-1))throw new Error("Multiple ellipses in slice is not allowed.");let u=!1;const d={dims:l.length,numAddAxisAfterEllipsis:0,begin:t.slice(),end:n.slice(),strides:l.slice(),beginMask:r,endMask:o,ellipsisMask:s,newAxisMask:i,shrinkAxisMask:c};for(let x=0;x<d.dims;x++)u&&0!==(1<<x&i)&&d.numAddAxisAfterEllipsis++,1<<x&s&&(u=!0);u||(d.ellipsisMask|=1<<d.dims,d.dims++);const h={dims:e.length,beginMask:0,endMask:0,beginValid:!1,endValid:!1};!function(e,t){t.beginMask=0,t.endMask=0,t.shrinkAxisMask=0;let n=0;t.beginValid=null!=e.begin,t.endValid=null!=e.end,t.begin=new Array(t.dims),t.end=new Array(t.dims),t.strides=new Array(t.dims),t.finalShapeGatherIndices=[],t.finalShapeGatherIndicesSparse=[],t.inputShapeGatherIndicesSparse=new Array(t.dims);for(let a=0;a<e.dims;a++)if(1<<a&e.ellipsisMask){const r=Math.min(t.dims-(e.dims-a)+1+e.numAddAxisAfterEllipsis,t.dims);for(;n<r;n++)t.begin[n]=0,t.end[n]=0,t.strides[n]=1,t.beginMask|=1<<n,t.endMask|=1<<n,t.finalShapeGatherIndices.push(n),t.finalShapeGatherIndicesSparse.push(-1),t.inputShapeGatherIndicesSparse[n]=a}else if(1<<a&e.newAxisMask)t.finalShapeGatherIndices.push(mQ),t.finalShapeGatherIndicesSparse.push(-1);else{if(n===t.begin.length)throw Error("Index out of range using input dim ".concat(n,"; input ")+"has only ".concat(t.dims," dims, ").concat(t.begin.length,"."));null!=e.begin&&(t.begin[n]=e.begin[a]),null!=e.end&&(t.end[n]=e.end[a]),t.strides[n]=e.strides[a],e.beginMask&1<<a&&(t.beginMask|=1<<n),e.endMask&1<<a&&(t.endMask|=1<<n),e.shrinkAxisMask&1<<a?(t.finalShapeGatherIndices.push(gQ),t.finalShapeGatherIndicesSparse.push(-1),t.shrinkAxisMask|=1<<n):(t.finalShapeGatherIndices.push(n),t.finalShapeGatherIndicesSparse.push(a)),t.inputShapeGatherIndicesSparse[n]=a,n++}}(d,h);let p=!0,f=!0,m=!0;const g=[],b=[];for(let x=0;x<e.length;++x){if(0===h.strides[x])throw Error("strides[".concat(x,"] must be non-zero"));const t=!!(h.shrinkAxisMask&1<<x),n=e[x];if(-1===n){g.push(t?1:-1);continue}const a=[h.beginMask&1<<x,h.endMask&1<<x],r=[h.strides[x]>0?0:-1,h.strides[x]>0?n:n-1];if(t&&h.strides[x]<=0)throw Error("only stride 1 allowed on non-range indexing.");m=m&&1===h.strides[x];const o=!!(h.beginMask&1<<x&&h.endMask&1<<x);if(h.beginValid&&h.endValid){if(t){const e=h.begin[x]<0?n+h.begin[x]:h.begin[x];if(h.begin[x]=e,h.end[x]=h.begin[x]+1,e<0||e>=n)throw Error("slice index ".concat(h.begin[x]," of dimension ").concat(x," out of bounds."))}else h.begin[x]=OQ(h.begin[x],0,h.strides[x],n,a,r),h.end[x]=OQ(h.end[x],1,h.strides[x],n,a,r);const e=1===h.strides[x]&&0===h.begin[x]&&h.end[x]===n;p=p&&e,f=f&&(0===x&&1===h.strides[x]||e)}else p=p&&1===h.strides[x]&&o,f=f&&(0===x&&1===h.strides[x]||o);let s,i=!1;if(h.beginValid&&h.endValid?(s=h.end[x]-h.begin[x],i=!0):t?(s=1,i=!0):o&&n>=0&&(s=h.strides[x]<0?-n:n,i=!0),i){let e;e=0===s||s<0!==h.strides[x]<0?0:Math.trunc(s/h.strides[x])+(s%h.strides[x]!==0?1:0),g.push(e)}else g.push(-1)}for(let x=0;x<h.finalShapeGatherIndices.length;++x){const e=h.finalShapeGatherIndices[x];e>=0?b.push(g[e]):e===mQ&&b.push(1)}const y=b.filter(((e,t)=>h.finalShapeGatherIndices[t]!==mQ));return{finalShapeSparse:y,finalShape:b,isIdentity:p,sliceDim0:f,isSimpleSlice:m,begin:h.begin,end:h.end,strides:h.strides}}function OQ(e,t,n,a,r,o){if(r[t])return n>0?o[t]:o[t+1&1];{const t=e<0?a+e:e;return t<o[0]?o[0]:t>o[1]?o[1]:t}}const DQ=aX({acos_:function(e){const t={x:eX(e,"x","acos")};return jq.runKernel(SG,t)}});const MQ=aX({acosh_:function(e){const t={x:eX(e,"x","acosh")};return jq.runKernel(NG,t)}});const LQ=aX({addN_:function(e){BU(Array.isArray(e),(()=>"The argument passed to tf.addN() must be a list of tensors")),BU(e.length>=1,(()=>"Must pass at least one tensor to tf.addN(), but got "+"".concat(e.length)));const t=e.map(((e,t)=>eX(e,"tensors".concat(t),"addN"))),n=t[0];t.forEach((e=>{if(e.dtype!==n.dtype)throw new Error("All tensors passed to tf.addN() must have the same dtype")})),t.forEach((e=>{if(!GU(e.shape,n.shape))throw new Error("All tensors passed to tf.addN() must have the same shape")}));const a=t;return jq.runKernel(TG,a)}});const PQ=aX({all_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const a={x:eX(e,"x","all","bool")},r={axis:t,keepDims:n};return jq.runKernel(EG,a,r)}});const zQ=aX({any_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const a={x:eX(e,"x","any","bool")},r={axis:t,keepDims:n};return jq.runKernel(RG,a,r)}});const BQ=aX({argMax_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const n={x:eX(e,"x","argMax")},a={axis:t};return jq.runKernel(_G,n,a)}});const WQ=aX({argMin_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const n={x:eX(e,"x","argMin")},a={axis:t};return jq.runKernel(AG,n,a)}});const VQ=aX({asin_:function(e){const t={x:eX(e,"x","asin")};return jq.runKernel(FG,t)}});const UQ=aX({asinh_:function(e){const t={x:eX(e,"x","asinh")};return jq.runKernel(OG,t)}});const GQ=aX({atan_:function(e){const t={x:eX(e,"x","atan")};return jq.runKernel(DG,t)}});const HQ=aX({atan2_:function(e,t){let n=eX(e,"a","atan2"),a=eX(t,"b","atan2");[n,a]=zq(n,a);const r={a:n,b:a};return jq.runKernel(LG,r)}});const jQ=aX({atanh_:function(e){const t={x:eX(e,"x","atanh")};return jq.runKernel(MG,t)}});function KQ(e,t,n,a){let r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"NHWC",o=arguments.length>5?arguments[5]:void 0;return YQ(e,[...t,e[3]],n,o,a,null,null,oJ(r))}function qQ(e,t,n,a,r,o){let s=arguments.length>6&&void 0!==arguments[6]?arguments[6]:"channelsLast";const[i,c]=ZQ(t);let l;if("channelsLast"===s)l=[i,c,e[3],e[3]];else{if("channelsFirst"!==s)throw new Error("Unknown dataFormat ".concat(s));l=[i,c,e[1],e[1]]}return YQ(e,l,n,a,r,o,!1,s)}function XQ(e,t,n,a,r,o){let s=arguments.length>6&&void 0!==arguments[6]?arguments[6]:"NDHWC";const[i,c,l]=$Q(t);let u,d;if("NDHWC"===s)d="channelsLast",u=[i,c,l,e[4],e[4]];else{if("NCDHW"!==s)throw new Error("Unknown dataFormat ".concat(s));d="channelsFirst",u=[i,c,l,e[1],e[1]]}return QQ(e,u,n,a,r,!1,d,o)}function YQ(e,t,n,a,r,o){let s=arguments.length>6&&void 0!==arguments[6]&&arguments[6],i=arguments.length>7&&void 0!==arguments[7]?arguments[7]:"channelsLast",[c,l,u,d]=[-1,-1,-1,-1];if("channelsLast"===i)[c,l,u,d]=e;else{if("channelsFirst"!==i)throw new Error("Unknown dataFormat ".concat(i));[c,d,l,u]=e}const[h,p,,f]=t,[m,g]=ZQ(n),[b,y]=ZQ(a),x=eJ(h,b),v=eJ(p,y),{padInfo:w,outHeight:k,outWidth:I}=function(e,t,n,a,r,o,s,i,c){let l,u,d;if("number"===typeof e){l={top:e,bottom:e,left:e,right:e,type:0===e?"VALID":"NUMBER"};const r=function(e,t,n,a,r){null==a&&(a=JQ(e,t,n));const o=e[0],s=e[1],i=tJ((o-t+2*a)/n+1,r),c=tJ((s-t+2*a)/n+1,r);return[i,c]}([t,n],o,a,e,i);u=r[0],d=r[1]}else if("same"===e){u=Math.ceil(t/a),d=Math.ceil(n/r);const e=Math.max(0,(u-1)*a+o-t),i=Math.max(0,(d-1)*r+s-n),c=Math.floor(e/2),h=e-c,p=Math.floor(i/2);l={top:c,bottom:h,left:p,right:i-p,type:"SAME"}}else if("valid"===e)l={top:0,bottom:0,left:0,right:0,type:"VALID"},u=Math.ceil((t-o+1)/a),d=Math.ceil((n-s+1)/r);else{if("object"!==typeof e)throw Error("Unknown padding parameter: ".concat(e));{const h="channelsLast"===c?e[1][0]:e[2][0],p="channelsLast"===c?e[1][1]:e[2][1],f="channelsLast"===c?e[2][0]:e[3][0],m="channelsLast"===c?e[2][1]:e[3][1];l={top:h,bottom:p,left:f,right:m,type:0===h&&0===p&&0===f&&0===m?"VALID":"EXPLICIT"},u=tJ((t-o+h+p)/a+1,i),d=tJ((n-s+f+m)/r+1,i)}}return{padInfo:l,outHeight:u,outWidth:d}}(r,l,u,m,g,x,v,o,i),S=s?f*d:f;let N;return"channelsFirst"===i?N=[c,S,k,I]:"channelsLast"===i&&(N=[c,k,I,S]),{batchSize:c,dataFormat:i,inHeight:l,inWidth:u,inChannels:d,outHeight:k,outWidth:I,outChannels:S,padInfo:w,strideHeight:m,strideWidth:g,filterHeight:h,filterWidth:p,effectiveFilterHeight:x,effectiveFilterWidth:v,dilationHeight:b,dilationWidth:y,inShape:e,outShape:N,filterShape:t}}function QQ(e,t,n,a,r){let o=arguments.length>5&&void 0!==arguments[5]&&arguments[5],s=arguments.length>6&&void 0!==arguments[6]?arguments[6]:"channelsLast",i=arguments.length>7?arguments[7]:void 0,[c,l,u,d,h]=[-1,-1,-1,-1,-1];if("channelsLast"===s)[c,l,u,d,h]=e;else{if("channelsFirst"!==s)throw new Error("Unknown dataFormat ".concat(s));[c,h,l,u,d]=e}const[p,f,m,,g]=t,[b,y,x]=$Q(n),[v,w,k]=$Q(a),I=eJ(p,v),S=eJ(f,w),N=eJ(m,k),{padInfo:C,outDepth:T,outHeight:E,outWidth:R}=function(e,t,n,a,r,o,s,i,c,l,u){let d,h,p,f;"valid"===e&&(e=0);if("number"===typeof e){d={top:e,bottom:e,left:e,right:e,front:e,back:e,type:0===e?"VALID":"NUMBER"};const m=function(e,t,n,a,r,o){null==r&&(r=JQ(e,t[0],a[0]));const s=[0,0,0,n];for(let i=0;i<3;i++)e[i]+2*r>=t[i]&&(s[i]=tJ((e[i]-t[i]+2*r)/a[i]+1,o));return s}([t,n,a,1],[i,c,l],1,[r,o,s],e,u);h=m[0],p=m[1],f=m[2]}else{if("same"!==e)throw Error("Unknown padding parameter: ".concat(e));{h=Math.ceil(t/r),p=Math.ceil(n/o),f=Math.ceil(a/s);const e=(h-1)*r+i-t,u=(p-1)*o+c-n,m=(f-1)*s+l-a,g=Math.floor(e/2),b=e-g,y=Math.floor(u/2),x=u-y,v=Math.floor(m/2);d={top:y,bottom:x,left:v,right:m-v,front:g,back:b,type:"SAME"}}}return{padInfo:d,outDepth:h,outHeight:p,outWidth:f}}(r,l,u,d,b,y,x,I,S,N,i),_=o?g*h:g;let A;return"channelsFirst"===s?A=[c,_,T,E,R]:"channelsLast"===s&&(A=[c,T,E,R,_]),{batchSize:c,dataFormat:s,inDepth:l,inHeight:u,inWidth:d,inChannels:h,outDepth:T,outHeight:E,outWidth:R,outChannels:_,padInfo:C,strideDepth:b,strideHeight:y,strideWidth:x,filterDepth:p,filterHeight:f,filterWidth:m,effectiveFilterDepth:I,effectiveFilterHeight:S,effectiveFilterWidth:N,dilationDepth:v,dilationHeight:w,dilationWidth:k,inShape:e,outShape:A,filterShape:t}}function JQ(e,t,n){const a=eJ(t,arguments.length>3&&void 0!==arguments[3]?arguments[3]:1);return Math.floor((e[0]*(n-1)-n+a)/2)}function ZQ(e){return"number"===typeof e?[e,e,e]:2===e.length?[e[0],e[1],1]:e}function $Q(e){return"number"===typeof e?[e,e,e]:e}function eJ(e,t){return t<=1?e:e+(e-1)*(t-1)}function tJ(e,t){if(!t)return Math.trunc(e);switch(t){case"round":return Math.round(e);case"ceil":return Math.ceil(e);case"floor":return Math.floor(e);default:throw new Error("Unknown roundingMode ".concat(t))}}function nJ(e){const[t,n,a]=ZQ(e);return 1===t&&1===n&&1===a}function aJ(e,t){return nJ(e)||nJ(t)}function rJ(e){return ZQ(e).every((e=>e>0))}function oJ(e){if("NHWC"===e)return"channelsLast";if("NCHW"===e)return"channelsFirst";throw new Error("Unknown dataFormat ".concat(e))}function sJ(e,t,n){if(null!=n){if("string"===typeof t)throw Error("Error in ".concat(e,": pad must be an integer when using ")+"dimRoundingMode ".concat(n," but got pad ").concat(t,"."));if("number"===typeof t)BU(HU(t),(()=>"Error in ".concat(e,": pad must be an integer when using ")+"dimRoundingMode ".concat(n," but got pad ").concat(t,".")));else{if("object"!==typeof t)throw Error("Error in ".concat(e,": Unknown padding parameter: ").concat(t));t.forEach((t=>{t.forEach((t=>{BU(HU(t),(()=>"Error in ".concat(e,": pad must be an integer when using ")+"dimRoundingMode ".concat(n," but got pad ").concat(t,".")))}))}))}}}const iJ=aX({reshape_:function(e,t){const n={x:eX(e,"x","reshape","string_or_numeric")},a={shape:t};return jq.runKernel(Dj,n,a)}});const cJ=aX({avgPool_:function(e,t,n,a,r){const o=eX(e,"x","avgPool","float32");BU(aJ(n,1),(()=>"Error in avgPool: Either strides or dilations must be 1. "+"Got strides ".concat(n," and dilations '").concat(1,"'")));let s=o,i=!1;3===o.rank&&(i=!0,s=iJ(o,[1,o.shape[0],o.shape[1],o.shape[2]])),BU(4===s.rank,(()=>"Error in avgPool: x must be rank 4 but got rank ".concat(s.rank,"."))),sJ("avgPool",a,r);const c={x:s},l={filterSize:t,strides:n,pad:a,dimRoundingMode:r};let u=jq.runKernel(PG,c,l);return u=bY(u,o.dtype),i?iJ(u,[u.shape[1],u.shape[2],u.shape[3]]):u}});const lJ=aX({avgPool3d_:function(e,t,n,a,r){let o=arguments.length>5&&void 0!==arguments[5]?arguments[5]:"NDHWC";const s=eX(e,"x","avgPool3d","float32");let i=s,c=!1;4===s.rank&&(c=!0,i=iJ(s,[1,s.shape[0],s.shape[1],s.shape[2],s.shape[3]])),BU(5===i.rank,(()=>"Error in avgPool3d: x must be rank 5 but got rank ".concat(i.rank,"."))),BU("NDHWC"===o,(()=>"Error in avgPool3d: Only NDHWC is currently supported, "+"but got dataFormat of ".concat(o))),BU("number"===typeof n&&n>0||Array.isArray(n)&&n[0]>0&&n[1]>0&&n[2]>0,(()=>"Error in avgPool3d: Stride must be > 0, but got '".concat(n,"'"))),sJ("avgPool3d",a,r);const l={x:i},u={filterSize:t,strides:n,pad:a,dimRoundingMode:r,dataFormat:o};let d=jq.runKernel(BG,l,u);return d=bY(d,i.dtype),c?iJ(d,[d.shape[1],d.shape[2],d.shape[3],d.shape[4]]):d}});const uJ=aX({concat_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;BU(e.length>=1,(()=>"Pass at least one tensor to concat"));const n=tX(e,"tensors","concat","string_or_numeric");if("complex64"===n[0].dtype&&n.forEach((e=>{if("complex64"!==e.dtype)throw new Error("Cannot concatenate complex64 tensors with a tensor\n          with dtype ".concat(e.dtype,". "))})),1===n.length)return yY(n[0]);const a=n,r={axis:t};return jq.runKernel(JG,a,r)}});const dJ=aX({matMul_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],a=arguments.length>3&&void 0!==arguments[3]&&arguments[3],r=eX(e,"a","matMul"),o=eX(t,"b","matMul");[r,o]=zq(r,o);const s={a:r,b:o},i={transposeA:n,transposeB:a};return jq.runKernel(VG,s,i)}});const hJ=aX({sigmoid_:function(e){const t={x:eX(e,"x","sigmoid","float32")};return jq.runKernel(Zj,t)}});const pJ=aX({slice_:function(e,t,n){const a=eX(e,"x","slice","string_or_numeric");if(0===a.rank)throw new Error("Slicing scalar is not possible");const r={x:a},o={begin:t,size:n};return jq.runKernel(Xj,r,o)}});const fJ=aX({tanh_:function(e){const t={x:eX(e,"x","tanh","float32")};return jq.runKernel(xK,t)}});const mJ=aX({basicLSTMCell_:function(e,t,n,a,r,o){const s=eX(e,"forgetBias","basicLSTMCell"),i=eX(t,"lstmKernel","basicLSTMCell"),c=eX(n,"lstmBias","basicLSTMCell"),l=eX(a,"data","basicLSTMCell"),u=eX(r,"c","basicLSTMCell"),d=eX(o,"h","basicLSTMCell"),h=uJ([l,d],1),p=dJ(h,i),f=vY(p,c),m=f.shape[0],g=f.shape[1]/4,b=[m,g],y=pJ(f,[0,0],b),x=pJ(f,[0,g],b),v=pJ(f,[0,2*g],b),w=pJ(f,[0,3*g],b),k=vY(IY(hJ(y),fJ(x)),IY(u,hJ(vY(s,v))));return[k,IY(fJ(k),hJ(w))]}});const gJ=aX({batchToSpaceND_:function(e,t,n){const a=eX(e,"x","batchToSpaceND"),r=t.reduce(((e,t)=>e*t));BU(a.rank>=1+t.length,(()=>"input rank is ".concat(a.rank," but should be > than blockShape.length ").concat(t.length))),BU(n.length===t.length,(()=>"crops.length is ".concat(n.length," but should be equal to blockShape.length  ").concat(t.length))),BU(a.shape[0]%r===0,(()=>"input tensor batch is ".concat(a.shape[0]," but is not divisible by the product of ")+"the elements of blockShape ".concat(t.join(" * ")," === ").concat(r)));const o={x:a},s={blockShape:t,crops:n};return jq.runKernel(UG,o,s)}});const bJ=aX({batchNorm_:function(e,t,n,a,r,o){null==o&&(o=.001);const s=eX(e,"x","batchNorm"),i=eX(t,"mean","batchNorm"),c=eX(n,"variance","batchNorm");let l,u;null!=r&&(l=eX(r,"scale","batchNorm")),null!=a&&(u=eX(a,"offset","batchNorm")),BU(i.rank===c.rank,(()=>"Batch normalization gradient requires mean and variance to have equal ranks.")),BU(null==u||i.rank===u.rank,(()=>"Batch normalization gradient requires mean and offset to have equal ranks.")),BU(null==l||i.rank===l.rank,(()=>"Batch normalization gradient requires mean and scale to have equal ranks."));const d={x:function(e){let t;return t=0===e.rank||1===e.rank?iJ(e,[1,1,1,e.size]):2===e.rank?iJ(e,[1,1,e.shape[0],e.shape[1]]):3===e.rank?iJ(e,[1,e.shape[0],e.shape[1],e.shape[2]]):e,t}(s),scale:l,offset:u,mean:i,variance:c},h={varianceEpsilon:o},p=jq.runKernel(OH,d,h);return iJ(p,s.shape)}});const yJ=aX({batchNorm2d_:function(e,t,n,a,r,o){const s=eX(e,"x","batchNorm"),i=eX(t,"mean","batchNorm"),c=eX(n,"variance","batchNorm");let l,u;return null!=r&&(l=eX(r,"scale","batchNorm")),null!=a&&(u=eX(a,"offset","batchNorm")),BU(2===s.rank,(()=>"Error in batchNorm2D: x must be rank 2 but got rank "+"".concat(s.rank,"."))),BU(2===i.rank||1===i.rank,(()=>"Error in batchNorm2D: mean must be rank 2 or rank 1 but "+"got rank ".concat(i.rank,"."))),BU(2===c.rank||1===c.rank,(()=>"Error in batchNorm2D: variance must be rank 2 or rank 1 "+"but got rank ".concat(c.rank,"."))),null!=l&&BU(2===l.rank||1===l.rank,(()=>"Error in batchNorm2D: scale must be rank 2 or rank 1 "+"but got rank ".concat(l.rank,"."))),null!=u&&BU(2===u.rank||1===u.rank,(()=>"Error in batchNorm2D: offset must be rank 2 or rank 1 "+"but got rank ".concat(u.rank,"."))),bJ(s,i,c,u,l,o)}});const xJ=aX({batchNorm3d_:function(e,t,n,a,r,o){const s=eX(e,"x","batchNorm"),i=eX(t,"mean","batchNorm"),c=eX(n,"variance","batchNorm");let l,u;return null!=r&&(l=eX(r,"scale","batchNorm")),null!=a&&(u=eX(a,"offset","batchNorm")),BU(3===s.rank,(()=>"Error in batchNorm3D: x must be rank 3 but got rank "+"".concat(s.rank,"."))),BU(3===i.rank||1===i.rank,(()=>"Error in batchNorm3D: mean must be rank 3 or rank 1 but "+"got rank ".concat(i.rank,"."))),BU(3===c.rank||1===c.rank,(()=>"Error in batchNorm3D: variance must be rank 3 or rank 1 "+"but got rank ".concat(c.rank,"."))),null!=l&&BU(3===l.rank||1===l.rank,(()=>"Error in batchNorm3D: scale must be rank 3 or rank 1 "+"but got rank ".concat(l.rank,"."))),null!=u&&BU(3===u.rank||1===u.rank,(()=>"Error in batchNorm3D: offset must be rank 3 or rank 1 "+"but got rank ".concat(u.rank,"."))),bJ(s,i,c,u,l,o)}});const vJ=aX({batchNorm4d_:function(e,t,n,a,r,o){const s=eX(e,"x","batchNorm"),i=eX(t,"mean","batchNorm"),c=eX(n,"variance","batchNorm");let l,u;return null!=r&&(l=eX(r,"scale","batchNorm")),null!=a&&(u=eX(a,"offset","batchNorm")),BU(4===s.rank,(()=>"Error in batchNorm4D: x must be rank 4 but got rank "+"".concat(s.rank,"."))),BU(4===i.rank||1===i.rank,(()=>"Error in batchNorm4D: mean must be rank 4 or rank 1 but "+"got rank ".concat(i.rank,"."))),BU(4===c.rank||1===c.rank,(()=>"Error in batchNorm4D: variance must be rank 4 or rank 1 "+"but got rank ".concat(c.rank,"."))),null!=l&&BU(4===l.rank||1===l.rank,(()=>"Error in batchNorm4D: scale must be rank 4 or rank 1 "+"but got rank ".concat(l.rank,"."))),null!=u&&BU(4===u.rank||1===u.rank,(()=>"Error in batchNorm4D: offset must be rank 4 or rank 1 "+"but got rank ".concat(u.rank,"."))),bJ(s,i,c,u,l,o)}});const wJ=aX({bincount_:function(e,t,n){const a=eX(e,"x","bincount"),r=eX(t,"weights","bincount");BU("int32"===a.dtype,(()=>"Error in bincount: input "+"dtype must be int32, but got ".concat(a.dtype))),BU(n>=0,(()=>"size must be non-negative, but got ".concat(n,"."))),BU(r.size===a.size||0===r.size,(()=>"Error in bincount: weights must have the same size as input or"+"0-length, but got input shape: ".concat(a.shape,", weights shape: ")+"".concat(r.shape,".")));const o={x:a,weights:r},s={size:n};return jq.runKernel(GG,o,s)}});const kJ=aX({bitwiseAnd_:function(e,t){const n=eX(e,"x","bitwiseAnd"),a=eX(t,"y","bitwiseAnd");if(!GU(n.shape,a.shape))throw new Error("BitwiseAnd: Tensors must have the same shape. x: ".concat(n.shape,", y: ").concat(a.shape));if("int32"!==n.dtype||"int32"!==a.dtype)throw new Error("BitwiseAnd: Only supports 'int32' values in tensor, found type of x: ".concat(n.dtype," and type of y: ").concat(a.dtype));const r={a:n,b:a};return jq.runKernel(HG,r)}});const IJ=aX({broadcastArgs_:function(e,t){const n=eX(e,"s0","broadcastArgs","int32"),a=eX(t,"s1","broadcastArgs","int32");if(1!==n.rank)throw new Error("broadcastArgs(): first input must be a vector (rank=1). "+"Has rank ".concat(n.rank));if(1!==a.rank)throw new Error("broadcastArgs(): second input must be a vector (rank=1). "+"Has rank ".concat(a.rank));const r={s0:n,s1:a};return jq.runKernel(jG,r)}});const SJ=aX({broadcastTo_:function(e,t){let n=eX(e,"broadcastTo","x");const a=n.shape;if(dG(t),t.length<n.rank)throw new Error("broadcastTo(): shape.length=".concat(t.length," < input.rank=").concat(n.rank,"."));if(t.length>n.rank){const e=n.shape.slice();for(;e.length<t.length;)e.unshift(1);n=iJ(n,e)}const r=n.shape,o=Array.from(t);for(let l=t.length-1;l>=0;l--)if(r[l]===t[l])o[l]=1;else if(1!==n.shape[l])throw new Error("broadcastTo(): [".concat(a,"] cannot be broadcast to [").concat(t,"]."));const s=o.map(((e,t)=>e>1?t:-1)).filter((e=>e>=0));if(0===s.length)return yY(n);const i={x:n},c={reps:o};return jq.runKernel(vK,i,c)}});const NJ=aX({ceil_:function(e){const t={x:eX(e,"x","ceil","float32")};return jq.runKernel(qG,t)}});const CJ=aX({clipByValue_:function(e,t,n){const a=eX(e,"x","clipByValue");if(BU(t<=n,(()=>"Error in clip: min (".concat(t,") must be ")+"less than or equal to max (".concat(n,")."))),t===n)return MY(a.shape,t,a.dtype);const r={x:a},o={clipValueMin:t,clipValueMax:n};return jq.runKernel(XG,r,o)}});const TJ=aX({concat1d_:function(e){return uJ(e,0)}});const EJ=aX({concat2d_:function(e,t){return uJ(e,t)}});const RJ=aX({concat3d_:function(e,t){return uJ(e,t)}});const _J=aX({concat4d_:function(e,t){return uJ(e,t)}});const AJ=aX({conv2d_:function(e,t,n,a){let r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"NHWC",o=arguments.length>5&&void 0!==arguments[5]?arguments[5]:[1,1],s=arguments.length>6?arguments[6]:void 0;const i=eX(e,"x","conv2d","float32"),c=eX(t,"filter","conv2d","float32");let l=i,u=!1;3===i.rank&&(u=!0,l=iJ(i,[1,i.shape[0],i.shape[1],i.shape[2]])),BU(4===l.rank,(()=>"Error in conv2d: input must be rank 4, but got rank ".concat(l.rank,"."))),BU(4===c.rank,(()=>"Error in conv2d: filter must be rank 4, but got rank "+"".concat(c.rank,"."))),sJ("conv2d",a,s);const d="NHWC"===r?l.shape[3]:l.shape[1];BU(d===c.shape[2],(()=>"Error in conv2d: depth of input (".concat(d,") must match ")+"input depth for filter ".concat(c.shape[2],"."))),BU(aJ(n,o),(()=>"Error in conv2D: Either strides or dilations must be 1. "+"Got strides ".concat(n," and dilations '").concat(o,"'"))),BU(rJ(o),(()=>"Error in conv2D: Dilated rates should be larger than 0.")),BU(rJ(n),(()=>"Error in conv2D: Strides should be larger than 0."));const h={x:l,filter:c},p={strides:n,pad:a,dataFormat:r,dilations:o,dimRoundingMode:s},f=jq.runKernel(ZG,h,p);return u?iJ(f,[f.shape[1],f.shape[2],f.shape[3]]):f}});const FJ=aX({conv1d_:function(e,t,n,a){let r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"NWC",o=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,s=arguments.length>6?arguments[6]:void 0;const i=eX(e,"x","conv1d"),c=eX(t,"filter","conv1d");let l=i,u=!1;2===i.rank&&(u=!0,l=iJ(i,[1,i.shape[0],i.shape[1]])),BU(3===l.rank,(()=>"Error in conv1d: input must be rank 3, but got rank ".concat(l.rank,"."))),BU(3===c.rank,(()=>"Error in conv1d: filter must be rank 3, but got rank "+"".concat(c.rank,"."))),sJ("conv1d",a,s),BU(l.shape[2]===c.shape[1],(()=>"Error in conv1d: depth of input (".concat(l.shape[2],") must match ")+"input depth for filter ".concat(c.shape[1],"."))),BU(aJ(n,o),(()=>"Error in conv1D: Either stride or dilation must be 1. "+"Got stride ".concat(n," and dilation '").concat(o,"'"))),BU(rJ(o),(()=>"Error in conv1D: Dilated rates should be larger than 0.")),BU(rJ(n),(()=>"Error in conv1D: Stride should be larger than 0.")),BU("NWC"===r,(()=>"Error in conv1d: got dataFormat of ".concat(r," but only NWC is currently supported.")));const d=iJ(c,[1,c.shape[0],c.shape[1],c.shape[2]]),h=iJ(l,[l.shape[0],1,l.shape[1],l.shape[2]]),p=AJ(h,d,[1,n],a,"NHWC",[1,o],s);return iJ(p,u?[p.shape[2],p.shape[3]]:[p.shape[0],p.shape[2],p.shape[3]])}});const OJ=aX({conv2DBackpropInput_:function(e,t,n,a,r){let o=arguments.length>5&&void 0!==arguments[5]?arguments[5]:"NHWC",s=arguments.length>6?arguments[6]:void 0;BU(e.length===t.rank,(()=>"Length of inShape "+"(".concat(e.length,") and rank of dy (").concat(t.rank,") must match")));let i=e,c=t,l=!1;3===t.rank&&(l=!0,c=iJ(t,[1,t.shape[0],t.shape[1],t.shape[2]]),i=[1,e[0],e[1],e[2]]),BU(4===i.length,(()=>"Error in conv2dDerInput: inShape must be length 4, but got length "+"".concat(i.length,"."))),BU(4===c.rank,(()=>"Error in conv2dDerInput: dy must be rank 4, but got "+"rank ".concat(c.rank))),BU(4===n.rank,(()=>"Error in conv2dDerInput: filter must be rank 4, but got "+"rank ".concat(n.rank)));const u="NHWC"===o?i[3]:i[1],d="NHWC"===o?c.shape[3]:c.shape[1];BU(u===n.shape[2],(()=>"Error in conv2dDerInput: depth of input (".concat(u,") must ")+"match input depth for filter ".concat(n.shape[2],"."))),BU(d===n.shape[3],(()=>"Error in conv2dDerInput: depth of output (".concat(d,") must ")+"match output depth for filter ".concat(n.shape[3],"."))),sJ("conv2dDerInput",r,s);const h={dy:c,filter:n},p={strides:a,pad:r,dataFormat:o,dimRoundingMode:s,inputShape:i},f=jq.runKernel(eH,h,p);return l?iJ(f,[f.shape[1],f.shape[2],f.shape[3]]):f}});const DJ=aX({conv2dTranspose_:function(e,t,n,a,r,o){const s=eX(e,"x","conv2dTranspose"),i=eX(t,"filter","conv2dTranspose");return OJ(n,s,i,a,r,"NHWC",o)}});const MJ=aX({conv3d_:function(e,t,n,a){let r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"NDHWC",o=arguments.length>5&&void 0!==arguments[5]?arguments[5]:[1,1,1];const s=eX(e,"x","conv3d"),i=eX(t,"filter","conv3d");let c=s,l=!1;4===s.rank&&(l=!0,c=iJ(s,[1,s.shape[0],s.shape[1],s.shape[2],s.shape[3]])),BU(5===c.rank,(()=>"Error in conv3d: input must be rank 5, but got rank ".concat(c.rank,"."))),BU(5===i.rank,(()=>"Error in conv3d: filter must be rank 5, but got rank "+"".concat(i.rank,"."))),BU(c.shape[4]===i.shape[3],(()=>"Error in conv3d: depth of input (".concat(c.shape[4],") must match ")+"input depth for filter ".concat(i.shape[3],"."))),BU(aJ(n,o),(()=>"Error in conv3D: Either strides or dilations must be 1. "+"Got strides ".concat(n," and dilations '").concat(o,"'"))),BU("NDHWC"===r,(()=>"Error in conv3d: got dataFormat of ".concat(r," but only NDHWC is currently supported."))),BU(rJ(o),(()=>"Error in conv3D: Dilated rates should be larger than 0.")),BU(rJ(n),(()=>"Error in conv3D: Strides should be larger than 0."));const u={x:c,filter:i},d={strides:n,pad:a,dataFormat:r,dilations:o},h=jq.runKernel(tH,u,d);return l?iJ(h,[h.shape[1],h.shape[2],h.shape[3],h.shape[4]]):h}});const LJ=aX({conv3DBackpropInput_:function(e,t,n,a,r){BU(e.length===t.rank,(()=>"Length of inShape "+"(".concat(e.length,") and rank of dy (").concat(t.rank,") must match")));let o=e,s=t,i=!1;4===t.rank&&(i=!0,s=iJ(t,[1,t.shape[0],t.shape[1],t.shape[2],t.shape[3]]),o=[1,e[0],e[1],e[2],e[3]]);const c=o[4],l=s.shape[4];BU(5===o.length,(()=>"Error in conv3dDerInput: inShape must be length 5, but got length "+"".concat(o.length,"."))),BU(5===s.rank,(()=>"Error in conv3dDerInput: dy must be rank 5, but got "+"rank ".concat(s.rank))),BU(5===n.rank,(()=>"Error in conv3dDerInput: filter must be rank 5, but got "+"rank ".concat(n.rank))),BU(c===n.shape[3],(()=>"Error in conv3dDerInput: depth of input (".concat(c,") must ")+"match input depth for filter ".concat(n.shape[3],"."))),BU(l===n.shape[4],(()=>"Error in conv3dDerInput: depth of output (".concat(l,") must ")+"match output depth for filter ".concat(n.shape[4],".")));const u={dy:s,filter:n},d={pad:r,strides:a,inputShape:o},h=jq.runKernel(aH,u,d);return i?iJ(h,[h.shape[1],h.shape[2],h.shape[3],h.shape[4]]):h}});const PJ=aX({conv3dTranspose_:function(e,t,n,a,r){const o=eX(e,"x","conv3dTranspose"),s=eX(t,"filter","conv3dTranspose");return LJ(n,o,s,a,r)}});const zJ=aX({cos_:function(e){const t={x:eX(e,"x","cos","float32")};return jq.runKernel(rH,t)}});const BJ=aX({cosh_:function(e){const t={x:eX(e,"x","cosh","float32")};return jq.runKernel(oH,t)}});const WJ=aX({cumprod_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],a=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const r={x:eX(e,"x","cumprod")},o={axis:t,exclusive:n,reverse:a};return jq.runKernel(sH,r,o)}});const VJ=aX({cumsum_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],a=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const r={x:eX(e,"x","cumsum")},o={axis:t,exclusive:n,reverse:a};return jq.runKernel(iH,r,o)}});const UJ=aX({denseBincount_:function(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const r=eX(e,"x","denseBincount"),o=eX(t,"weights","denseBincount");BU("int32"===r.dtype,(()=>"Error in denseBincount: input "+"dtype must be int32, but got ".concat(r.dtype))),BU(r.rank<=2,(()=>"Error in denseBincount: input must be at most rank 2, but got "+"rank ".concat(r.rank,"."))),BU(n>=0,(()=>"size must be non-negative, but got ".concat(n,"."))),BU(o.size===r.size||0===o.size,(()=>"Error in denseBincount: weights must have the same shape as x or "+"0-length, but got x shape: ".concat(r.shape,", weights shape: ")+"".concat(o.shape,".")));const s={x:r,weights:o},i={size:n,binaryOutput:a};return jq.runKernel(lH,s,i)}});const GJ=aX({depthToSpace_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"NHWC";const a=eX(e,"x","depthToSpace","float32"),r="NHWC"===n?a.shape[1]:a.shape[2],o="NHWC"===n?a.shape[2]:a.shape[3],s="NHWC"===n?a.shape[3]:a.shape[1];BU(t>1,(()=>"blockSize should be > 1 for depthToSpace, but was: ".concat(t))),BU(r*t>=0,(()=>"Negative dimension size caused by overflow when multiplying\n    ".concat(r," and ").concat(t,"  for depthToSpace with input shape\n    ").concat(a.shape))),BU(o*t>=0,(()=>"Negative dimension size caused by overflow when multiplying\n    ".concat(o," and ").concat(t," for depthToSpace with input shape\n        ").concat(a.shape))),BU(s%(t*t)===0,(()=>"Dimension size must be evenly divisible by ".concat(t*t," but is ").concat(s," for depthToSpace with input shape ").concat(a.shape)));const i={x:a},c={blockSize:t,dataFormat:n};return jq.runKernel(uH,i,c)}});const HJ=aX({depthwiseConv2d_:function(e,t,n,a){let r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"NHWC",o=arguments.length>5&&void 0!==arguments[5]?arguments[5]:[1,1],s=arguments.length>6?arguments[6]:void 0;const i=eX(e,"x","depthwiseConv2d","float32"),c=eX(t,"filter","depthwiseConv2d","float32");let l=i,u=!1;3===i.rank&&(u=!0,l=iJ(i,[1,i.shape[0],i.shape[1],i.shape[2]])),BU(4===l.rank,(()=>"Error in depthwiseConv2d: input must be rank 4, but got "+"rank ".concat(l.rank,"."))),BU(4===c.rank,(()=>"Error in depthwiseConv2d: filter must be rank 4, but got rank "+"".concat(c.rank,".")));const d="NHWC"===r?l.shape[3]:l.shape[1];BU(d===c.shape[2],(()=>"Error in depthwiseConv2d: number of input channels "+"(".concat(d,") must match the inChannels dimension in ")+"filter ".concat(c.shape[2],"."))),sJ("depthwiseConv2d",a,s);const h={x:l,filter:c},p={strides:n,pad:a,dataFormat:r,dilations:o,dimRoundingMode:s},f=jq.runKernel(dH,h,p);return u?iJ(f,[f.shape[1],f.shape[2],f.shape[3]]):f}});const jJ=aX({diag_:function(e){const t={x:eX(e,"x","diag")};return jq.runKernel(fH,t)}});const KJ=aX({dilation2d_:function(e,t,n,a){let r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:[1,1],o=arguments.length>5&&void 0!==arguments[5]?arguments[5]:"NHWC";const s=eX(e,"x","dilation2d"),i=eX(t,"filter","dilation2d");BU(3===s.rank||4===s.rank,(()=>"Error in dilation2d: input must be rank 3 or 4, but got rank "+"".concat(s.rank,"."))),BU(3===i.rank,(()=>"Error in dilation2d: filter must be rank 3, but got rank "+"".concat(i.rank,"."))),BU("NHWC"===o,(()=>"Error in dilation2d: Only NHWC is currently supported, "+"but got dataFormat of ".concat(o)));let c=s,l=!1;3===s.rank&&(c=iJ(s,[1,s.shape[0],s.shape[1],s.shape[2]]),l=!0),BU(c.shape[3]===i.shape[2],(()=>"Error in dilation2d:  input and filter must have the same depth: ".concat(c.shape[3]," vs ").concat(i.shape[2])));const u={x:c,filter:i},d={strides:n,pad:a,dilations:r},h=jq.runKernel(mH,u,d);return l?iJ(h,[h.shape[1],h.shape[2],h.shape[3]]):h}});const qJ=aX({equal_:function(e,t){let n=eX(e,"a","equal","string_or_numeric"),a=eX(t,"b","equal","string_or_numeric");[n,a]=zq(n,a),VY(n.shape,a.shape);const r={a:n,b:a};return jq.runKernel(SH,r)}});const XJ=aX({where_:function(e,t,n){const a=eX(t,"a","where"),r=eX(n,"b","where"),o=eX(e,"condition","where","bool"),s=VY(VY(o.shape,a.shape),r.shape),i={condition:SJ(o,s),t:SJ(a,s),e:SJ(r,s)};return jq.runKernel(Kj,i)}});const YJ=aX({divNoNan_:function(e,t){let n=eX(e,"a","div"),a=eX(t,"b","div");[n,a]=zq(n,a);const r=kY(n,a),o=CY(r),s=qJ(a,o);return XJ(s,o,r)}});const QJ=aX({dot_:function(e,t){const n=eX(e,"t1","dot"),a=eX(t,"t2","dot");BU((1===n.rank||2===n.rank)&&(1===a.rank||2===a.rank),(()=>"Error in dot: inputs must all be rank 1 or 2, but got ranks "+"".concat(n.rank," and ").concat(a.rank,".")));const r=1===n.rank?n.size:n.shape[1],o=1===a.rank?a.size:a.shape[0];if(BU(r===o,(()=>"Error in dot: inner dimensions of inputs must match, but got "+"".concat(r," and ").concat(o,"."))),1===n.rank&&1===a.rank){const e=iJ(n,[1,-1]),t=iJ(a,[-1,1]),r=dJ(e,t);return iJ(r,[])}if(1===n.rank&&2===a.rank){const e=iJ(n,[1,-1]),t=iJ(a,[a.shape[0],a.shape[1]]),r=dJ(e,t);return iJ(r,[r.size])}if(2===n.rank&&1===a.rank){const e=iJ(a,[-1,1]),t=dJ(n,e);return iJ(t,[t.size])}{const e=iJ(a,[a.shape[0],a.shape[1]]);return dJ(n,e)}}});const JJ=aX({einsum_:function(e){for(var t=arguments.length,n=new Array(t>1?t-1:0),a=1;a<t;a++)n[a-1]=arguments[a];const r=n.map(((e,t)=>eX(e,"tensors".concat(t),"einsum"))),o={equation:e};return jq.runKernel(vH,r,o)}});const ZJ=aX({elu_:function(e){const t={x:eX(e,"x","elu","float32")};return jq.runKernel(wH,t)}});const $J=aX({ensureShape_:function(e,t){const n=eX(e,"x","ensureShape","string_or_numeric");if(!function(e,t){if(e===t)return!0;if(null==e||null==t)return!1;if(e.length!==t.length)return!1;for(let n=0;n<e.length;n++)if(null!==e[n]&&null!==t[n]&&e[n]!==t[n])return!1;return!0}(n.shape,t))throw new Error("EnsureShape: Shape of tensor ".concat(n.shape," is not compatible with expected shape ").concat(t));return e}});const eZ=aX({erf_:function(e){let t=eX(e,"x","erf");BU("int32"===t.dtype||"float32"===t.dtype,(()=>"Input dtype must be `int32` or `float32`.")),"int32"===t.dtype&&(t=bY(t,"float32"));const n={x:t};return jq.runKernel(IH,n)}});function tZ(e,t){for(let n=0;n<e.length;++n)if(e[e.length-n-1]!==t-1-n)return!1;return!0}function nZ(e,t,n){const a=e.length+t.length,r=[];let o=0,s=0;for(let i=0;i<a;i++)-1===n.indexOf(i)?r.push(e[o++]):r.push(t[s++]);return r}function aZ(e,t){const n=[],a=e.length;for(let r=0;r<a;r++)-1===t.indexOf(r)&&n.push(e[r]);return[n,t.map((t=>e[t]))]}function rZ(e,t){return nZ(e,t.map((e=>1)),t)}function oZ(e,t,n){BU(tZ(t,n),(()=>"".concat(e," supports only inner-most axes for now. ")+"Got axes ".concat(t," and rank-").concat(n," input.")))}function sZ(e,t){if(tZ(e,t))return null;const n=[];for(let a=0;a<t;++a)-1===e.indexOf(a)&&n.push(a);return e.forEach((e=>n.push(e))),n}function iZ(e){return e.map(((e,t)=>[t,e])).sort(((e,t)=>e[1]-t[1])).map((e=>e[0]))}function cZ(e,t){const n=[];for(let a=t-e;a<t;++a)n.push(a);return n}const lZ=aX({max_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const a={x:eX(e,"x","max")},r={reductionIndices:t,keepDims:n};return jq.runKernel(tj,a,r)}});const uZ=aX({min_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const a={x:eX(e,"x","min")},r={axis:t,keepDims:n};return jq.runKernel(lj,a,r)}});const dZ=aX({sum_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],a=eX(e,"x","sum");"bool"===a.dtype&&(a=bY(a,"int32"));const r={x:a},o={axis:t,keepDims:n};return jq.runKernel(tK,r,o)}});function hZ(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null;if(0===e.rank)return zY(e);if(1!==e.rank&&null===n)return hZ(iJ(e,[-1]),t,n);if(1===e.rank||"number"===typeof n||Array.isArray(n)&&1===n.length){if(1===t)return dZ(zY(e),n);if(t===1/0)return lZ(zY(e),n);if(t===-1/0)return uZ(zY(e),n);if("euclidean"===t||2===t)return SY(dZ(LY(zY(e),EY(2,"int32")),n));throw new Error("Error in norm: invalid ord value: ".concat(t))}if(Array.isArray(n)&&2===n.length){if(1===t)return lZ(dZ(zY(e),n[0]),n[1]-1);if(t===1/0)return lZ(dZ(zY(e),n[1]),n[0]);if(t===-1/0)return uZ(dZ(zY(e),n[1]),n[0]);if("fro"===t||"euclidean"===t)return SY(dZ(NY(e),n));throw new Error("Error in norm: invalid ord value: ".concat(t))}throw new Error("Error in norm: invalid axis: ".concat(n))}const pZ=aX({norm_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"euclidean",n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null,a=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const r=hZ(e=eX(e,"x","norm"),t,n);let o=r.shape;if(a){const t=YU(n,e.shape);o=rZ(r.shape,t)}return iJ(r,o)}});const fZ=aX({euclideanNorm_:function(e){return pZ(e,"euclidean",arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,arguments.length>2&&void 0!==arguments[2]&&arguments[2])}});const mZ=aX({exp_:function(e){const t={x:eX(e,"x","exp")};return jq.runKernel(NH,t)}});const gZ=aX({expandDims_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const n=eX(e,"x","expandDims","string_or_numeric");BU(t<=n.rank,(()=>"Axis must be <= rank of the tensor"));const a={input:n},r={dim:t};return jq.runKernel(CH,a,r)}});const bZ=aX({expm1_:function(e){const t={x:eX(e,"x","expm1")};return jq.runKernel(TH,t)}});const yZ=aX({tile_:function(e,t){const n=eX(e,"x","tile","string_or_numeric");BU(n.rank===t.length,(()=>"Error in transpose: rank of input ".concat(n.rank," ")+"must match length of reps ".concat(t,".")));const a={x:n},r={reps:t};return jq.runKernel(vK,a,r)}});const xZ=aX({eye_:function(e,t,n){null==t&&(t=e);const a=gY([e,t],arguments.length>3&&void 0!==arguments[3]?arguments[3]:"float32"),r=e<=t?e:t;for(let s=0;s<r;++s)a.set(1,s,s);const o=iJ(a.toTensor(),[e,t]);if(null==n)return o;if(1===n.length)return yZ(gZ(o,0),[n[0],1,1]);if(2===n.length)return yZ(gZ(gZ(o,0),0),[n[0],n[1],1,1]);if(3===n.length)return yZ(gZ(gZ(gZ(o,0),0),0),[n[0],n[1],n[2],1,1]);throw new Error("eye() currently supports only 1D and 2D "+"batchShapes, but received ".concat(n.length,"D."))}});const vZ=aX({floor_:function(e){const t={x:eX(e,"x","floor","float32")};return jq.runKernel(AH,t)}});const wZ=aX({gather_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;const r={x:eX(e,"x","gather"),indices:eX(t,"indices","gather","int32")},o={axis:n,batchDims:a};return jq.runKernel(DH,r,o)}});const kZ=aX({greater_:function(e,t){let n=eX(e,"a","greater","string_or_numeric"),a=eX(t,"b","greater","string_or_numeric");[n,a]=zq(n,a),VY(n.shape,a.shape);const r={a:n,b:a};return jq.runKernel(LH,r)}});const IZ=aX({greaterEqual_:function(e,t){let n=eX(e,"a","greaterEqual","string_or_numeric"),a=eX(t,"b","greaterEqual","string_or_numeric");[n,a]=zq(n,a),VY(n.shape,a.shape);const r={a:n,b:a};return jq.runKernel(PH,r)}});const SZ=aX({imag_:function(e){const t={input:eX(e,"input","imag")};return jq.runKernel(WH,t)}});const NZ=aX({isFinite_:function(e){const t={x:eX(e,"x","isFinite")};return jq.runKernel(VH,t)}});const CZ=aX({isInf_:function(e){const t={x:eX(e,"x","isInf")};return jq.runKernel(UH,t)}});const TZ=aX({isNaN_:function(e){const t={x:eX(e,"x","isNaN")};return jq.runKernel(GH,t)}});const EZ=aX({leakyRelu_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:.2;const n={x:eX(e,"x","leakyRelu")},a={alpha:t};return jq.runKernel(HH,n,a)}});const RZ=aX({less_:function(e,t){let n=eX(e,"a","less","string_or_numeric"),a=eX(t,"b","less","string_or_numeric");[n,a]=zq(n,a),VY(n.shape,a.shape);const r={a:n,b:a};return jq.runKernel(jH,r)}});const _Z=aX({lessEqual_:function(e,t){let n=eX(e,"a","lessEqual","string_or_numeric"),a=eX(t,"b","lessEqual","string_or_numeric");[n,a]=zq(n,a),VY(n.shape,a.shape);const r={a:n,b:a};return jq.runKernel(KH,r)}});function AZ(e,t,n){if(n<=0)throw new Error("The number of values should be positive.");const a={start:e,stop:t,num:n};return jq.runKernel(qH,{},a)}const FZ=aX({localResponseNormalization_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:5,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1,r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:.5;const o=eX(e,"x","localResponseNormalization");BU(4===o.rank||3===o.rank,(()=>"Error in localResponseNormalization: x must be rank 3 or 4 but got\n               rank ".concat(o.rank,"."))),BU(HU(t),(()=>"Error in localResponseNormalization: depthRadius must be an "+"integer but got depthRadius ".concat(t,".")));let s=o,i=!1;3===o.rank&&(i=!0,s=iJ(o,[1,o.shape[0],o.shape[1],o.shape[2]]));const c={x:s},l={depthRadius:t,bias:n,alpha:a,beta:r},u=jq.runKernel($H,c,l);return i?iJ(u,[u.shape[1],u.shape[2],u.shape[3]]):u}});const OZ=aX({log_:function(e){const t={x:eX(e,"x","log","float32")};return jq.runKernel(XH,t)}});const DZ=aX({log1p_:function(e){const t={x:eX(e,"x","log1p")};return jq.runKernel(YH,t)}});const MZ=aX({neg_:function(e){const t={x:eX(e,"x","neg")};return jq.runKernel(mj,t)}});const LZ=aX({softplus_:function(e){const t={x:eX(e,"x","softplus")};return jq.runKernel($j,t)}});const PZ=aX({logSigmoid_:function(e){const t=eX(e,"x","logSigmoid");return TY((e=>({value:MZ(LZ(MZ(e))),gradFunc:t=>IY(t,hJ(MZ(e)))})))(t)}});const zZ=aX({logSoftmax_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:-1;const n=eX(e,"logits","logSoftmax");if(-1===t&&(t=n.rank-1),t!==n.rank-1)throw Error("Log Softmax along a non-last dimension is not yet supported. "+"Logits was rank ".concat(n.rank," and axis was ").concat(t));const a=TY(((e,n)=>{const a=lZ(e,t,!0),r=PY(e,a),o=PY(bY(r,"float32"),OZ(dZ(mZ(r),t,!0)));n([o]);return{value:o,gradFunc:(e,n)=>{const[a]=n,r=mZ(a);return PY(e,IY(dZ(e,t,!0),r))}}}));return a(n)}});const BZ=aX({logSumExp_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const a=eX(e,"x","logSumExp"),r=YU(t,a.shape),o=lZ(a,r,!0),s=PY(a,o),i=mZ(s),c=dZ(i,r),l=OZ(c),u=vY(iJ(o,l.shape),l);if(n){const e=rZ(u.shape,r);return iJ(u,e)}return u}});const WZ=aX({logicalAnd_:function(e,t){const n=eX(e,"a","logicalAnd","bool"),a=eX(t,"b","logicalAnd","bool");VY(n.shape,a.shape);const r={a:n,b:a};return jq.runKernel(QH,r)}});const VZ=aX({logicalNot_:function(e){const t={x:eX(e,"x","logicalNot","bool")};return jq.runKernel(JH,t)}});const UZ=aX({logicalOr_:function(e,t){const n=eX(e,"a","logicalOr","bool"),a=eX(t,"b","logicalOr","bool");VY(n.shape,a.shape);const r={a:n,b:a};return jq.runKernel(ZH,r)}});const GZ=aX({logicalXor_:function(e,t){const n=eX(e,"a","logicalXor","bool"),a=eX(t,"b","logicalXor","bool");return VY(n.shape,a.shape),WZ(UZ(e,t),VZ(WZ(e,t)))}}),HZ=2147483648;const jZ=aX({searchSorted_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"left";const a=eX(e,"sortedSequence","searchSorted"),r=eX(t,"values","searchSorted"),o=a.shape[a.shape.length-1],s=r.shape[r.shape.length-1],i=iJ(a,[-1,o]),c=iJ(r,[-1,s]);if(i.rank<2)throw new Error("Sorted input argument must be at least 2-dimensional");if(i.shape[0]!==c.shape[0])throw new Error("Leading dimension of 'sortedSequence' and 'values' must match.");if(UU(c.shape)>=HZ)throw new Error("values tensor size must less than ".concat(HZ));if(i.shape[1]>=HZ)throw new Error("trailing dim_size must less than ".concat(HZ," for int32 output type, was ").concat(i.shape[1]));const l={sortedSequence:i,values:c},u={side:n};return jq.runKernel(jj,l,u)}});function KZ(e,t){return jZ(e,t,"left")}const qZ=aX({maxPool_:function(e,t,n,a,r){const o=eX(e,"x","maxPool");let s=o,i=!1;3===o.rank&&(i=!0,s=iJ(o,[1,o.shape[0],o.shape[1],o.shape[2]])),BU(4===s.rank,(()=>"Error in maxPool: input must be rank 4 but got rank ".concat(s.rank,"."))),BU(aJ(n,1),(()=>"Error in maxPool: Either strides or dilations must be 1. "+"Got strides ".concat(n," and dilations '").concat(1,"'"))),sJ("maxPool",a,r);const c={x:s},l={filterSize:t,strides:n,pad:a,dimRoundingMode:r},u=jq.runKernel(aj,c,l);return i?iJ(u,[u.shape[1],u.shape[2],u.shape[3]]):u}});const XZ=aX({maxPool3d_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[1,1,1],n=arguments.length>2?arguments[2]:void 0,a=arguments.length>3?arguments[3]:void 0,r=arguments.length>4?arguments[4]:void 0,o=arguments.length>5&&void 0!==arguments[5]?arguments[5]:"NDHWC";const s=eX(e,"x","maxPool3d");let i=s,c=!1;4===s.rank&&(c=!0,i=iJ(s,[1,s.shape[0],s.shape[1],s.shape[2],s.shape[3]])),BU(5===i.rank,(()=>"Error in maxPool3d: x must be rank 5 but got rank ".concat(i.rank,"."))),BU("NDHWC"===o,(()=>"Error in maxPool3d: Only NDHWC is currently supported, "+"but got dataFormat of ".concat(o))),sJ("maxPool3d",a,r);const l={x:i},u={filterSize:t,strides:n,pad:a,dimRoundingMode:r,dataFormat:o},d=jq.runKernel(oj,l,u);return c?iJ(d,[d.shape[1],d.shape[2],d.shape[3],d.shape[4]]):d}});const YZ=aX({maxPoolWithArgmax_:function(e,t,n,a){let r=arguments.length>4&&void 0!==arguments[4]&&arguments[4];const o={x:eX(e,"x","maxPoolWithArgmax")},s={filterSize:t,strides:n,pad:a,includeBatchInIndex:r},i=jq.runKernel(ij,o,s);return{result:i[0],indexes:i[1]}}});const QZ=aX({mean_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const a={x:eX(e,"x","mean")},r={axis:t,keepDims:n};return jq.runKernel(cj,a,r)}});function JZ(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"float32";if(dG(e),"complex64"===t){const t=JZ(e,"float32"),n=JZ(e,"float32");return rX(t,n)}const n=lG(UU(e),t);return jq.makeTensor(n,e,t)}function ZZ(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"float32";if(dG(e),"complex64"===t){const t=ZZ(e,"float32"),n=JZ(e,"float32");return rX(t,n)}const n=cG(UU(e),t);return jq.makeTensor(n,e,t)}function $Z(e,t){let{indexing:n="xy"}=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};if("xy"!==n&&"ij"!==n)throw new TypeError("".concat(n," is not a valid third argument to meshgrid"));if(void 0===e)return[];let a=eX(e,"x","meshgrid",e instanceof Nq?e.dtype:"float32");if(void 0===t)return[a];let r=eX(t,"y","meshgrid",t instanceof Nq?t.dtype:"float32");const o=UU(a.shape),s=UU(r.shape);return"xy"===n?(a=iJ(a,[1,-1]),r=iJ(r,[-1,1]),[dJ(ZZ([s,1],a.dtype),a),dJ(r,ZZ([1,o],r.dtype))]):(a=iJ(a,[-1,1]),r=iJ(r,[1,-1]),[dJ(a,ZZ([1,s],a.dtype)),dJ(ZZ([o,1],r.dtype),r)])}const e$=aX({minimum_:function(e,t){let n=eX(e,"a","minimum"),a=eX(t,"b","minimum");[n,a]=zq(n,a),"bool"===n.dtype&&(n=bY(n,"int32"),a=bY(a,"int32")),VY(n.shape,a.shape);const r={a:n,b:a};return jq.runKernel(uj,r)}});const t$=aX({mirrorPad_:function(e,t,n){BU("reflect"===n||"symmetric"===n,(()=>"Invalid mode. Mode must be either reflect or symmetric. "+"Got ".concat(n,".")));const a=eX(e,"x","mirrorPad");if(0===a.rank)throw new Error("mirrorPad(scalar) is not defined. Pass non-scalar to mirrorPad");BU(t.length===a.rank,(()=>"Padding doesn't match input. Must be ".concat(a.rank,". ")+"Got ".concat(t.length,".")));const r="reflect"===n?1:0;for(let i=0;i<a.rank;i++)BU(2===t[i].length,(()=>"Invalid number of paddings. Must be length of 2 each.")),BU(t[i][0]>=0&&t[i][0]<=a.shape[i]-r&&t[i][1]>=0&&t[i][1]<=a.shape[i]-r,(()=>"Padding in dimension ".concat(i," cannot be greater than or equal ")+"to ".concat(a.shape[i]-r," or less than 0 for input of ")+"shape ".concat(a.shape)));const o={paddings:t,mode:n},s={x:a};return jq.runKernel(dj,s,o)}});const n$=aX({mod_:function(e,t){let n=eX(e,"a","mod"),a=eX(t,"b","mod");[n,a]=zq(n,a);const r={a:n,b:a};return jq.runKernel(hj,r)}});const a$=aX({moments_:function(e){let t=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const n=YU(arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,(e=eX(e,"x","moments")).shape),a=QZ(e,n,t);let r=a.shape;t||(r=rZ(a.shape,n));const o=NY(PY(bY(e,"float32"),iJ(a,r)));return{mean:a,variance:QZ(o,n,t)}}});const r$=aX({multiRNNCell_:function(e,t,n,a){const r=eX(t,"data","multiRNNCell"),o=tX(n,"c","multiRNNCell"),s=tX(a,"h","multiRNNCell");let i=r;const c=[];for(let d=0;d<e.length;d++){const t=e[d](i,o[d],s[d]);c.push(t[0]),c.push(t[1]),i=t[1]}const l=[],u=[];for(let d=0;d<c.length;d+=2)l.push(c[d]),u.push(c[d+1]);return[l,u]}});const o$=aX({multinomial_:function(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const r=eX(e,"logits","multinomial"),o=r.size,s=r.rank;if(o<2)throw new Error("Error in multinomial: you need at least 2 outcomes, but got "+"".concat(o,"."));if(s>2)throw new Error("Rank of probabilities must be 1 or 2, but is ".concat(s));n=n||Math.random();const i={logits:1===s?iJ(r,[1,-1]):r},c={numSamples:t,seed:n,normalized:a},l=jq.runKernel(pj,i,c);return 1===s?iJ(l,[l.size]):l}});const s$=aX({notEqual_:function(e,t){let n=eX(e,"a","notEqual","string_or_numeric"),a=eX(t,"b","notEqual","string_or_numeric");[n,a]=zq(n,a),VY(n.shape,a.shape);const r={a:n,b:a};return jq.runKernel(gj,r)}});const i$=aX({oneHot_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0,r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"int32";if(t<2)throw new Error("Error in oneHot: depth must be >=2, but it is ".concat(t));const o={indices:eX(e,"indices","oneHot","int32")},s={dtype:r,depth:t,onValue:n,offValue:a};return jq.runKernel(wj,o,s)}});const c$=aX({onesLike_:function(e){const t={x:eX(e,"x","onesLike")};return jq.runKernel(vj,t)}});const l$=aX({outerProduct_:function(e,t){const n=eX(e,"v1","outerProduct"),a=eX(t,"v2","outerProduct");BU(1===n.rank&&1===a.rank,(()=>"Error in outerProduct: inputs must be rank 1, but got ranks "+"".concat(n.rank," and ").concat(a.rank,".")));const r=iJ(n,[-1,1]),o=iJ(a,[1,-1]);return dJ(r,o)}});const u$=aX({pad_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;const a=eX(e,"x","pad");if(0===a.rank)throw new Error("pad(scalar) is not defined. Pass non-scalar to pad");const r={paddings:t,constantValue:n},o={x:a};return jq.runKernel(Ij,o,r)}});const d$=aX({pad1d_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;return BU(2===t.length,(()=>"Invalid number of paddings. Must be length of 2.")),u$(e,[t],n)}});const h$=aX({pad2d_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;return BU(2===t.length&&2===t[0].length&&2===t[1].length,(()=>"Invalid number of paddings. Must be length of 2 each.")),u$(e,t,n)}});const p$=aX({pad3d_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;return BU(3===t.length&&2===t[0].length&&2===t[1].length&&2===t[2].length,(()=>"Invalid number of paddings. Must be length of 2 each.")),u$(e,t,n)}});const f$=aX({pad4d_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;return BU(4===t.length&&2===t[0].length&&2===t[1].length&&2===t[2].length&&2===t[3].length,(()=>"Invalid number of paddings. Must be length of 2 each.")),u$(e,t,n)}});const m$=aX({spaceToBatchND_:function(e,t,n){const a=eX(e,"x","spaceToBatchND");BU(a.rank>=1+t.length,(()=>"input rank ".concat(a.rank," should be > than [blockShape] ").concat(t.length))),BU(n.length===t.length,(()=>"paddings.shape[0] ".concat(n.length," must be equal to [blockShape] ").concat(t.length))),BU(a.shape.reduce(((e,a,r)=>r>0&&r<=t.length?e&&(a+n[r-1][0]+n[r-1][1])%t[r-1]===0:e),!0),(()=>"input spatial dimensions ".concat(a.shape.slice(1)," with paddings ").concat(n.toString()," must be divisible by blockShapes ").concat(t.toString())));const r={x:a},o={blockShape:t,paddings:n};return jq.runKernel(nK,r,o)}});const g$=aX({pool_:function(e,t,n,a,r,o,s){null==r&&(r=[1,1]),null==o&&(o=1),0===a&&(a="valid");const i=eX(e,"x","maxPool");let c=i,l=!1;3===i.rank&&(l=!0,c=iJ(i,[1,i.shape[0],i.shape[1],i.shape[2]])),BU(aJ(o,r),(()=>"Error in pool: Either strides or dilations must be 1. "+"Got strides ".concat(o," and dilations '").concat(r,"'")));const u=qQ(c.shape,t,o,r,a),d=[u.dilationHeight,u.dilationWidth];let h;h="same"===a?function(e,t){const n=e.map(((e,n)=>e+(e-1)*(t[n]-1))),a=n.map((e=>e-1)),r=a.map((e=>Math.floor(e/2))),o=a.map(((e,t)=>e-r[t]));return a.map(((e,t)=>[r[t],o[t]]))}([u.filterHeight,u.filterWidth],d):[[0,0],[0,0]];const p=1===d[0]&&1===d[1],[f,m]=function(e,t,n){const a=n.map((e=>e[0])),r=n.map((e=>e[1])),o=e.concat(a,r),s=t.map(((e,t)=>(e-o[t]%e)%e)),i=r.map(((e,t)=>e+s[t])),c=t.map(((e,t)=>[a[t],i[t]])),l=t.map(((e,t)=>[0,s[t]]));return[c,l]}([u.inHeight,u.inWidth],d,h),g=p?a:"valid",b=p?c:m$(c,d,f),y=("avg"===n?()=>cJ(b,t,o,g,s):()=>qZ(b,t,o,g,s))(),x=p?y:gJ(y,d,m);return l?iJ(x,[x.shape[1],x.shape[2],x.shape[3]]):x}});const b$=aX({prelu_:function(e,t){const n={x:eX(e,"x","prelu"),alpha:eX(t,"alpha","prelu")};return jq.runKernel(Nj,n)}});const y$=aX({prod_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],a=eX(e,"x","prod");"bool"===a.dtype&&(a=bY(a,"int32"));const r={x:a},o={axis:t,keepDims:n};return jq.runKernel(Cj,r,o)}});const x$=aX({raggedGather_:function(e,t,n,a){const r=e.map(((e,t)=>eX(e,"tensors".concat(t),"raggedGather","int32"))),o={paramsNestedSplits:r,paramsDenseValues:eX(t,"paramsDenseValues","raggedGather"),indices:eX(n,"indices","raggedGather","int32")},s={outputRaggedRank:a},i=jq.runKernel(Tj,o,s);return{outputNestedSplits:i.slice(0,i.length-1),outputDenseValues:i[i.length-1]}}});const v$=aX({raggedRange_:function(e,t,n){const a=eX(e,"starts","raggedRange"),r={starts:a,limits:eX(t,"limits","raggedRange",a.dtype),deltas:eX(n,"deltas","raggedRange",a.dtype)},o=jq.runKernel(Ej,r);return{rtNestedSplits:o[0],rtDenseValues:o[1]}}});const w$=aX({raggedTensorToTensor_:function(e,t,n,a,r){const o=eX(e,"shape","raggedTensorToTensor","int32"),s=eX(t,"values","raggedTensorToTensor"),i=eX(n,"defaultValue","raggedTensorToTensor",s.dtype),c=a.map(((e,t)=>eX(e,"tensors".concat(t),"raggedTensorToTensor","int32"))),l={shape:o,values:s,defaultValue:i,rowPartitionTensors:c},u={rowPartitionTypes:r};return jq.runKernel(Rj,l,u)}});const k$=aX({rand_:function(e,t,n){dG(e);const a=UU(e);let r=null;if(null==n||"float32"===n)r=new Float32Array(a);else if("int32"===n)r=new Int32Array(a);else{if("bool"!==n)throw new Error("Unknown data type ".concat(n));r=new Uint8Array(a)}for(let o=0;o<a;o++)r[o]=t();return jq.makeTensor(r,e,n)}});class I${constructor(e,t,n,a,r){this.mean=e,this.stdDev=t,this.dtype=n,this.nextVal=NaN,this.truncated=a,this.truncated&&(this.upper=this.mean+2*this.stdDev,this.lower=this.mean-2*this.stdDev);const o=r||Math.random();this.random=mf.alea(o.toString())}nextValue(){if(!isNaN(this.nextVal)){const e=this.nextVal;return this.nextVal=NaN,e}let e,t,n=!1;for(;!n;){let a,r,o;do{a=2*this.random()-1,r=2*this.random()-1,o=a*a+r*r}while(o>=1||0===o);const s=Math.sqrt(-2*Math.log(o)/o);e=this.mean+this.stdDev*a*s,t=this.mean+this.stdDev*r*s,this.truncated&&!this.isValidTruncated(e)||(n=!0)}return this.truncated&&!this.isValidTruncated(t)||(this.nextVal=this.convertValue(t)),this.convertValue(e)}convertValue(e){return null==this.dtype||"float32"===this.dtype?e:Math.round(e)}isValidTruncated(e){return e<=this.upper&&e>=this.lower}}class S${constructor(e,t,n,a){this.alpha=e,this.beta=1/t,this.dtype=n;const r=a||Math.random();this.randu=mf.alea(r.toString()),this.randn=new I$(0,1,n,!1,this.randu()),this.d=e<1?e+2/3:e-1/3,this.c=1/Math.sqrt(9*this.d)}nextValue(){let e,t,n,a,r,o;for(;;){do{a=this.randn.nextValue(),o=1+this.c*a}while(o<=0);if(o*=o*o,e=a*a,t=1-.331*e*e,n=.5*e+this.d*(1-o+Math.log(o)),r=this.randu(),r<t||Math.log(r)<n)break}return o=1/this.beta*this.d*o,this.alpha<1&&(o*=Math.pow(this.randu(),1/this.alpha)),this.convertValue(o)}convertValue(e){return"float32"===this.dtype?e:Math.round(e)}}class N${constructor(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,n=arguments.length>2?arguments[2]:void 0,a=arguments.length>3?arguments[3]:void 0;if(this.canReturnFloat=()=>null==this.dtype||"float32"===this.dtype,this.min=e,this.range=t-e,this.dtype=n,null==a&&(a=Math.random()),"number"===typeof a&&(a=a.toString()),!this.canReturnFloat()&&this.range<=1)throw new Error("The difference between ".concat(e," - ").concat(t," <= 1 and dtype is not float"));this.random=mf.alea(a)}convertValue(e){return this.canReturnFloat()?e:Math.round(e)}nextValue(){return this.convertValue(this.min+this.range*this.random())}}const C$=aX({randomGamma_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"float32",r=arguments.length>4?arguments[4]:void 0;if(dG(e),null==n&&(n=1),null==a&&(a="float32"),"float32"!==a&&"int32"!==a)throw new Error("Unsupported data type ".concat(a));const o=new S$(t,n,a,r),s=gY(e,a);for(let i=0;i<s.values.length;i++)s.values[i]=o.nextValue();return s.toTensor()}});const T$=aX({randomNormal_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,a=arguments.length>3?arguments[3]:void 0,r=arguments.length>4?arguments[4]:void 0;if(dG(e),null!=a&&"bool"===a)throw new Error("Unsupported data type ".concat(a));const o=new I$(t,n,a,!1,r),s=gY(e,a);for(let i=0;i<s.values.length;i++)s.values[i]=o.nextValue();return s.toTensor()}});const E$=aX({randomStandardNormal_:function(e,t,n){if(null!=t&&"bool"===t)throw new Error("Unsupported data type ".concat(t));return T$(e,0,1,t,n)}});const R$=aX({randomUniform_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"float32",r=arguments.length>4?arguments[4]:void 0;dG(e);const o=gY(e,a),s=new N$(t,n,null,r);for(let i=0;i<o.values.length;i++)o.values[i]=s.nextValue();return o.toTensor()}});const _$=aX({randomUniformInt_:function(e,t,n,a){return R$(e,t,n,"int32",a)}});function A$(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"float32";if(0===n)throw new Error("Cannot have a step of zero");const r={start:e,stop:t,step:n,dtype:a};return jq.runKernel(_j,{},r)}const F$=aX({real_:function(e){const t={input:eX(e,"input","real")};return jq.runKernel(Aj,t)}});const O$=aX({reciprocal_:function(e){const t={x:eX(e,"x","reciprocal")};return jq.runKernel(Fj,t)}});const D$=aX({relu_:function(e){const t={x:eX(e,"x","relu")};return jq.runKernel(Oj,t)}});const M$=aX({relu6_:function(e){const t={x:eX(e,"x","relu6")};return jq.runKernel(Bj,t)}});const L$=aX({reverse_:function(e,t){const n={x:eX(e,"x","reverse")},a={dims:t};return jq.runKernel(Wj,n,a)}});const P$=aX({reverse1d_:function(e){const t=eX(e,"x","reverse");return BU(1===t.rank,(()=>"Error in reverse1D: x must be rank 1 but got rank ".concat(t.rank,"."))),L$(t,0)}});const z$=aX({reverse2d_:function(e,t){const n=eX(e,"x","reverse");return BU(2===n.rank,(()=>"Error in reverse2D: x must be rank 2 but got rank ".concat(n.rank,"."))),L$(n,t)}});const B$=aX({reverse3d_:function(e,t){const n=eX(e,"x","reverse");return BU(3===n.rank,(()=>"Error in reverse3D: x must be rank 3 but got rank ".concat(n.rank,"."))),L$(n,t)}});const W$=aX({reverse4d_:function(e,t){const n=eX(e,"x","reverse");return BU(4===n.rank,(()=>"Error in reverse4D: x must be rank 4 but got rank ".concat(n.rank,"."))),L$(n,t)}});const V$=aX({round_:function(e){const t={x:eX(e,"x","round")};return jq.runKernel(Vj,t)}});const U$=aX({rsqrt_:function(e){const t={x:eX(e,"x","rsqrt","float32")};return jq.runKernel(Uj,t)}});const G$=aX({selu_:function(e){const t={x:eX(e,"x","selu")};return jq.runKernel(qj,t)}});const H$=aX({separableConv2d_:function(e,t,n,a,r){let o=arguments.length>5&&void 0!==arguments[5]?arguments[5]:[1,1],s=arguments.length>6&&void 0!==arguments[6]?arguments[6]:"NHWC";const i=eX(e,"x","separableConv2d"),c=eX(t,"depthwiseFilter","separableConv2d"),l=eX(n,"pointwiseFilter","separableConv2d");let u=i,d=!1;if(3===i.rank&&(d=!0,u=iJ(i,[1,i.shape[0],i.shape[1],i.shape[2]])),"NCHW"===s)throw new Error("separableConv2d currently does not support dataFormat NCHW; only NHWC is supported");BU(4===u.rank,(()=>"Error in separableConv2d: input must be rank 4, but got "+"rank ".concat(u.rank,"."))),BU(4===c.rank,(()=>"Error in separableConv2d: depthwise filter must be rank 4, but "+"got rank ".concat(c.rank,"."))),BU(4===l.rank,(()=>"Error in separableConv2d: pointwise filter must be rank 4, but "+"got rank ".concat(c.rank,"."))),BU(1===l.shape[0],(()=>"Error in separableConv2d: the first dimension of pointwise filter "+" must be 1, but got ".concat(l.shape[0],"."))),BU(1===l.shape[1],(()=>"Error in separableConv2d: the second dimension of pointwise "+"filter must be 1, but got ".concat(l.shape[1],".")));const h=c.shape[2],p=c.shape[3];BU(l.shape[2]===h*p,(()=>"Error in separableConv2d: the third dimension of pointwise filter "+"must be ".concat(h*p,", ")+"but got ".concat(l.shape[2],".")));const f=HJ(u,c,a,r,s,o),m=AJ(f,l,1,"valid",s);return d?iJ(m,[m.shape[1],m.shape[2],m.shape[3]]):m}});const j$=async function(e,t){const n=eX(e,"x","setdiff1d"),a=eX(t,"y","setdiff1d");BU(n.dtype===a.dtype,(()=>"x and y should have the same dtype, but got x (".concat(n.dtype,") and y (").concat(a.dtype,")."))),BU(1===n.rank,(()=>"x should be 1D tensor, but got x (".concat(n.shape,")."))),BU(1===a.rank,(()=>"y should be 1D tensor, but got y (".concat(a.shape,").")));const r=await n.data(),o=await a.data(),s=new Set(o);let i=0;for(let u=0;u<r.length;u++)s.has(r[u])||i++;const c=new wq([i],n.dtype),l=new wq([i],"int32");for(let u=0,d=0;u<r.length;u++)s.has(r[u])||(c.values[d]=r[u],l.values[d]=u,d++);return[c.toTensor(),l.toTensor()]};const K$=aX({sign_:function(e){const t={x:eX(e,"x","sign")};return jq.runKernel(Jj,t)}});const q$=aX({sin_:function(e){const t={x:eX(e,"x","sin","float32")};return jq.runKernel(Yj,t)}});const X$=aX({sinh_:function(e){const t={x:eX(e,"x","sinh")};return jq.runKernel(Qj,t)}});const Y$=aX({slice1d_:function(e,t,n){const a=eX(e,"x","slice1d");return BU(1===a.rank,(()=>"slice1d expects a rank-1 tensor, but got a rank-".concat(a.rank," tensor"))),pJ(a,[t],[n])}});const Q$=aX({slice2d_:function(e,t,n){const a=eX(e,"x","slice2d");return BU(2===a.rank,(()=>"slice2d expects a rank-2 tensor, but got a rank-".concat(a.rank," tensor"))),pJ(a,t,n)}});const J$=aX({slice3d_:function(e,t,n){const a=eX(e,"x","slice3d");return BU(3===a.rank,(()=>"slice3d expects a rank-3 tensor, but got a rank-".concat(a.rank," tensor"))),pJ(a,t,n)}});const Z$=aX({slice4d_:function(e,t,n){const a=eX(e,"x","slice4d");return BU(4===a.rank,(()=>"slice4d expects a rank-4 tensor, but got a rank-".concat(a.rank," tensor"))),pJ(a,t,n)}});const $$=aX({softmax_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:-1;const n=eX(e,"logits","softmax","float32");if(-1===t&&(t=n.rank-1),t!==n.rank-1)throw Error("Softmax along a non-last dimension is not yet supported. "+"Logits was rank ".concat(n.rank," and dim was ").concat(t));const a={logits:n},r={dim:t};return jq.runKernel(rK,a,r)}});const e0=aX({fft_:function(e){BU("complex64"===e.dtype,(()=>"The dtype for tf.spectral.fft() must be complex64 "+"but got ".concat(e.dtype,".")));const t={input:e};return jq.runKernel(EH,t)}});const t0=aX({ifft_:function(e){BU("complex64"===e.dtype,(()=>"The dtype for tf.spectral.ifft() must be complex64 "+"but got ".concat(e.dtype,".")));const t={input:e};return jq.runKernel(BH,t)}});const n0=aX({irfft_:function(e){const t=e.shape[e.shape.length-1],n=e.size/t;let a;if(t<=2){const r=iJ(e,[n,t]);a=t0(r)}else{const r=[n,2*(t-1)],o=iJ(F$(e),[n,t]),s=iJ(SZ(e),[n,t]),i=L$(pJ(o,[0,1],[n,t-2]),1),c=IY(L$(pJ(s,[0,1],[n,t-2]),1),EY(-1)),l=uJ([o,i],1),u=uJ([s,c],1),d=iJ(rX(l,u),[r[0],r[1]]);a=t0(d)}if(a=F$(a),3===e.rank&&0!==e.shape[0]){const t=a,n=e.shape[0];a=iJ(a,[n,a.shape[0]/n,a.shape[1]]),t.dispose()}return a}});const a0=aX({split_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;const a={x:eX(e,"x","split")},r={numOrSizeSplits:t,axis:n};return jq.runKernel(aK,a,r)}});const r0=aX({rfft_:function(e,t){BU("float32"===e.dtype,(()=>"The dtype for rfft() must be real value but got ".concat(e.dtype)));let n=e.shape[e.shape.length-1];const a=e.size/n;let r;if(null!=t&&t<n){const a=e.shape.map((e=>0)),o=e.shape.map((e=>e));o[e.shape.length-1]=t,r=pJ(e,a,o),n=t}else if(null!=t&&t>n){const a=e.shape.map((e=>e));a[e.shape.length-1]=t-n,r=uJ([e,JZ(a)],e.shape.length-1),n=t}else r=e;const o=CY(r),s=iJ(rX(r,o),[a,n]),i=e0(s),c=Math.floor(n/2)+1,l=F$(i),u=SZ(i),d=a0(l,[c,n-c],l.shape.length-1),h=a0(u,[c,n-c],u.shape.length-1),p=r.shape.slice();return p[r.shape.length-1]=c,iJ(rX(d[0],h[0]),p)}});const o0=aX({squaredDifference_:function(e,t){let n=eX(e,"a","squaredDifference"),a=eX(t,"b","squaredDifference");[n,a]=zq(n,a),VY(n.shape,a.shape);const r={a:n,b:a};return jq.runKernel(uK,r,{})}});const s0=aX({squeeze_:function(e,t){const n=eX(e,"x","squeeze","string_or_numeric");return iJ(n,QU(n.shape,t).newShape)}});const i0=aX({stack_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const n=tX(e,"tensors","stack","string_or_numeric");BU(n.length>=1,(()=>"Pass at least one tensor to tf.stack")),n.length>0&&BU(t<=n[0].rank,(()=>"Axis must be <= rank of the tensor"));const a=n,r={axis:t};return jq.runKernel(kj,a,r)}});const c0=aX({step_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const n={x:eX(e,"x","step")},a={alpha:t};return jq.runKernel(EK,n,a)}});const l0=aX({stridedSlice_:function(e,t,n,a){let r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:0,o=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0,s=arguments.length>6&&void 0!==arguments[6]?arguments[6]:0,i=arguments.length>7&&void 0!==arguments[7]?arguments[7]:0,c=arguments.length>8&&void 0!==arguments[8]?arguments[8]:0;const l={x:eX(e,"x","stridedSlice","string_or_numeric")},u={begin:t,end:n,strides:a,beginMask:r,endMask:o,ellipsisMask:s,newAxisMask:i,shrinkAxisMask:c};return jq.runKernel(pK,l,u)}});const u0=aX({tan_:function(e){const t={x:eX(e,"x","tan","float32")};return jq.runKernel(yK,t)}});function d0(e,t){VU(e);const n=Jq(e,t);if(1!==n.length)throw new Error("tensor1d() requires values to be a flat/TypedArray");return oX(e,null,n,t)}function h0(e,t,n){if(VU(e),null!=t&&2!==t.length)throw new Error("tensor2d() requires shape to have two numbers");const a=Jq(e,n);if(2!==a.length&&1!==a.length)throw new Error("tensor2d() requires values to be number[][] or flat/TypedArray");if(1===a.length&&null==t)throw new Error("tensor2d() requires shape to be provided when `values` are a flat/TypedArray");return oX(e,t,a,n)}function p0(e,t,n){if(VU(e),null!=t&&4!==t.length)throw new Error("tensor4d() requires shape to have four numbers");const a=Jq(e,n);if(4!==a.length&&1!==a.length)throw new Error("tensor4d() requires values to be number[][][][] or flat/TypedArray");if(1===a.length&&null==t)throw new Error("tensor4d() requires shape to be provided when `values` are a flat array");return oX(e,t,a,n)}function f0(e,t,n){if(VU(e),null!=t&&5!==t.length)throw new Error("tensor5d() requires shape to have five numbers");const a=Jq(e,n);if(5!==a.length&&1!==a.length)throw new Error("tensor5d() requires values to be number[][][][][] or flat/TypedArray");if(1===a.length&&null==t)throw new Error("tensor5d() requires shape to be provided when `values` are a flat array");return oX(e,t,a,n)}function m0(e,t,n){if(VU(e),null!=t&&6!==t.length)throw new Error("tensor6d() requires shape to have six numbers");const a=Jq(e,n);if(6!==a.length&&1!==a.length)throw new Error("tensor6d() requires values to be number[][][][][][] or flat/TypedArray");if(1===a.length&&null==t)throw new Error("tensor6d() requires shape to be provided when `values` are a flat array");return oX(e,t=t||a,a,n)}function g0(e,t,n){const a=t.rank>1?t.shape[t.rank-1]:1,r=t.rank>1?t.rank-1:1,o="Must have updates.shape = indices.shape[:batchDim] + "+"shape[sliceDim:], got updates.shape: ".concat(n.shape)+", indices.shape: ".concat(t.shape,", shape: ").concat(e)+", sliceDim: ".concat(a,", and batchDim: ").concat(r,".");if(n.rank<r)throw new Error(o+" update.rank < ".concat(r,". "));if(e.length<a+(n.rank-r))throw new Error(o+" Output shape length < ".concat(a+(n.rank-r)));if(n.rank!==r+e.length-a)throw new Error(o+" update.rank != ".concat(r+e.length-a));for(let s=0;s<r;++s)if(n.shape[s]!==t.shape[s])throw new Error(o+" updates.shape[".concat(s,"] (").concat(n.shape[s],") != indices.shape[").concat(s,"] (").concat(t.shape[s],")."));for(let s=0;s<n.rank-r;++s)if(n.shape[s+r]!==e[s+a])throw new Error(o+" updates.shape[".concat(s+r,"] (").concat(n.shape[s+r],") != shape[").concat(s+r,"] (").concat(e[s+r],")"))}function b0(e,t,n){if(t.rank<1)throw new Error("tf.scatterND() expects the indices to be rank 1 or higher,"+" but the rank was ".concat(t.rank,"."));if(e.rank<1)throw new Error("tf.scatterND() expects the updates to be rank 1 or higher,"+" but the rank was ".concat(e.rank,"."));if("int32"!==t.dtype)throw new Error("The dtype of 'indices' should be int32, but got dtype: ".concat(t.dtype));if(n.length<1)throw new Error("Output rank must be greater or equal to 1, but got shape: ".concat(n));if(0===n.length){if(0===t.size)throw new Error("Indices specified for empty output. indices shape: ".concat(t.shape));if(0===e.size)throw new Error("Updates specified for empty output. updates shape: ".concat(e.shape))}g0(n,t,e)}function y0(e,t,n){const a=t.shape.length,r=a>1?t.shape[a-1]:1,o=n.length;let s=1;for(let c=r;c<o;++c)s*=n[c];const i=r<1?1:r;return{sliceRank:r,numUpdates:UU(t.shape)/i,sliceSize:s,strides:[...oG(n.slice(0,r)),1],outputSize:UU(n)}}const x0=aX({tensorScatterUpdate_:function(e,t,n){const a=eX(e,"tensor","tensorScatterupdate"),r=eX(t,"indices","tensorScatterupdate","int32"),o=eX(n,"updates","tensorScatterupdate");if(b0(o,r,a.shape),a.dtype!==o.dtype)throw new Error("tensor and updates must have the same dtype, instead they are ".concat(a.dtype," and ").concat(o.dtype,"."));const s={tensor:a,indices:r,updates:o};return jq.runKernel(Hj,s,{})}});const v0=aX({topk_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,n=!(arguments.length>2&&void 0!==arguments[2])||arguments[2];const a=eX(e,"x","topk");if(0===a.rank)throw new Error("topk() expects the input to be of rank 1 or higher");const r=a.shape[a.shape.length-1];if(t<0)throw new Error("'k' passed to topk() must be >= 0 but got ".concat(t));if(t>r)throw new Error("'k' passed to topk() must be <= the last dimension (".concat(r,") ")+"but got ".concat(t));const o={x:a},s={k:t,sorted:n},[i,c]=jq.runKernel(wK,o,s);return{values:i,indices:c}}});const w0=aX({truncatedNormal_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,a=arguments.length>3?arguments[3]:void 0,r=arguments.length>4?arguments[4]:void 0;if(dG(e),null!=a&&"bool"===a)throw new Error("Unsupported data type $ { dtype }");const o=new I$(t,n,a,!0,r),s=gY(e,a);for(let i=0;i<s.values.length;i++)s.values[i]=o.nextValue();return s.toTensor()}});const k0=aX({unique_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const n=eX(e,"x","unique","string_or_numeric");BU(n.rank>0,(()=>"The input tensor must be at least 1D"));const a={x:n},r={axis:t},[o,s]=jq.runKernel(SK,a,r);return{values:o,indices:s}}});const I0=aX({unsortedSegmentSum_:function(e,t,n){const a=eX(e,"x","unsortedSegmentSum"),r=eX(t,"segmentIds","unsortedSegmentSum","int32");BU(HU(n),(()=>"numSegments must be of dtype int"));const o={x:a,segmentIds:r},s={numSegments:n};return jq.runKernel(CK,o,s)}});const S0=aX({unstack_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const n=eX(e,"x","unstack","string_or_numeric");BU(t>=-n.shape.length&&t<n.shape.length,(()=>"Axis = ".concat(t," is not in [-").concat(n.shape.length,", ").concat(n.shape.length,")")));const a={value:n},r={axis:t};return jq.runKernel(NK,a,r)}});function N0(e,t){return jZ(e,t,"right")}function C0(e){let t=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],n=arguments.length>2?arguments[2]:void 0,a=arguments.length>3?arguments[3]:void 0;return jq.makeVariable(e,t,n,a)}function T0(e,t){const n=[];for(let o=0;o<t.length;o++)t[o]&&n.push(o);const a=gY(e,"int32"),r=gY([n.length,e.length],"int32");for(let o=0;o<n.length;o++){const t=a.indexToLoc(n[o]),s=o*e.length;r.values.set(t,s)}return r.toTensor()}const E0=async function(e){const t=eX(e,"condition","whereAsync","bool"),n=await t.data(),a=T0(t.shape,n);return e!==t&&t.dispose(),a};const R0=async function(e,t,n){const a=eX(e,"tensor","boolMask"),r=eX(t,"mask","boolMask","bool"),o=null==n?0:n,s=r.rank,i=a.shape;BU(s>0,(()=>"mask cannot be scalar")),WU(i.slice(o,o+s),r.shape,"mask's shape must match the first K dimensions of tensor's shape,");let c=1;for(let m=o;m<o+s;m++)c*=i[m];const l=i.slice(0,o).concat([c],i.slice(o+s)),u=iJ(a,l),d=iJ(r,[-1]),h=await E0(d),p=s0(h,[1]),f=wZ(u,p,o);return e!==a&&a.dispose(),t!==r&&r.dispose(),p.dispose(),u.dispose(),d.dispose(),h.dispose(),f};const _0=aX({transpose_:function(e,t,n){const a=eX(e,"x","transpose");if(null==t&&(t=a.shape.map(((e,t)=>t)).reverse()),BU(a.rank===t.length,(()=>"Error in transpose: rank of input ".concat(a.rank," ")+"must match length of perm ".concat(t,"."))),t.forEach((e=>{BU(e>=0&&e<a.rank,(()=>"All entries in 'perm' must be between 0 and ".concat(a.rank-1)+" but got ".concat(t)))})),a.rank<=1)return a.clone();const r={x:a},o={perm:t};return"complex64"===a.dtype?uX((()=>{let e=F$(a),t=SZ(a);return e=jq.runKernel(IK,{x:e},o),t=jq.runKernel(IK,{x:t},o),n&&(t=MZ(t)),rX(e,t)})):jq.runKernel(IK,r,o)}});const A0=aX({movingAverage_:function(e,t,n,a){let r=!(arguments.length>4&&void 0!==arguments[4])||arguments[4];const o=eX(e,"v","movingAverage"),s=eX(t,"x","movingAverage"),i=eX(n,"decay","movingAverage");!function(e,t){BU(e.dtype===t.dtype,(()=>"The dtypes of the first(".concat(e.dtype,") and")+" second(".concat(t.dtype,") input must match")))}(o,s),BU(GU(o.shape,s.shape),(()=>"Shape mismatch in v and x"));const c=EY(1),l=PY(c,i);let u=IY(PY(s,o),l);if(r){BU(null!=a,(()=>"When using zeroDebias: true, step is required."));const e=eX(a,"step","movingAverage");u=kY(u,PY(c,LY(i,e)))}return vY(o,u)}});const F0=aX({scatterND_:function(e,t,n){dG(n);const a=eX(e,"indices","scatterND","int32"),r=eX(t,"updates","scatterND");b0(r,a,n);const o={indices:a,updates:r},s={shape:n};return jq.runKernel(Gj,o,s)}});const O0=aX({sparseToDense_:function(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;dG(n);const r=eX(e,"sparseIndices","sparseToDense","int32"),o=eX(t,"sparseValues","sparseToDense","string_or_numeric"),s=eX(a,"defaultValue","sparseToDense",o.dtype);!function(e,t,n,a){if("int32"!==e.dtype)throw new Error("tf.sparseToDense() expects the indices to be int32 type,"+" but the dtype was ".concat(e.dtype,"."));if(e.rank>2)throw new Error("sparseIndices should be a scalar, vector, or matrix,"+" but got shape ".concat(e.shape,"."));const r=e.rank>0?e.shape[0]:1,o=e.rank>1?e.shape[1]:1;if(n.length!==o)throw new Error("outputShape has incorrect number of elements:,"+" ".concat(n.length,", should be: ").concat(o,"."));const s=t.size;if(0!==t.rank&&(1!==t.rank||s!==r))throw new Error("sparseValues has incorrect shape "+"".concat(t.shape,", should be [] or [").concat(r,"]"));if(t.dtype!==a.dtype)throw new Error("sparseValues.dtype must match defaultValues.dtype")}(r,o,n,s);const i={sparseIndices:r,sparseValues:o,defaultValue:s},c={outputShape:n};return jq.runKernel(lK,i,c)}});const D0=aX({gatherND_:function(e,t){const n=eX(t,"indices","gatherND","int32"),a={params:eX(e,"x","gatherND","string_or_numeric"),indices:n};return jq.runKernel(MH,a)}});const M0=aX({dropout_:function(e,t,n,a){const r=eX(e,"x","dropout");if(BU("float32"===r.dtype,(()=>"x has to be a floating point tensor since it's going to be "+"scaled, but got a ".concat(r.dtype," tensor instead."))),BU(t>=0&&t<1,(()=>"rate must be a float in the range [0, 1), but got ".concat(t,"."))),0===t)return e instanceof Nq?r.clone():r;const o=function(e,t){if(null==t)return e.shape.slice();if(GU(e.shape,t))return t;if(e.shape.length===t.length){const n=[];for(let a=0;a<e.shape.length;a++)null==t[a]&&null!=e.shape[a]?n.push(e.shape[a]):n.push(t[a]);return n}return t}(r,n),s=1-t,i=kY(vZ(vY(R$(o,0,1,"float32",a),s)),s);return IY(r,i)}});function L0(e){return Math.floor(Math.pow(2,Math.ceil(Math.log(e)/Math.log(2))))}function P0(e,t,n){const a=1-e%2,r=new Float32Array(e);for(let o=0;o<e;++o){const s=2*Math.PI*o/(e+a-1);r[o]=t-n*Math.cos(s)}return d0(r,"float32")}const z0=async function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1;const a=eX(e,"predictions","inTopK"),r=eX(t,"targets","inTopK");BU(a.rank>1,(()=>"inTopK() expects the predictions to be of rank 2 or higher, "+"but got ".concat(a.rank))),BU(a.rank-1===r.rank,(()=>"predictions rank should be 1 larger than targets rank, but got predictions rank "+"".concat(a.rank," and targets rank ").concat(r.rank))),WU(a.shape.slice(0,a.shape.length-1),r.shape,"predictions's shape should be align with the targets' shape, except the last dimension.");const o=a.shape[a.shape.length-1];BU(n>0&&n<=o,(()=>"'k' passed to inTopK() must be > 0 && <= the predictions last "+"dimension (".concat(o,"), but got ").concat(n)));const s=await a.data(),i=await r.data(),[c,l]=[s.length/o,o],u=JU("bool",c);for(let d=0;d<c;d++){const e=d*l,t=s.subarray(e,e+l),a=[];for(let n=0;n<t.length;n++)a.push({value:t[n],index:n});a.sort(((e,t)=>t.value-e.value)),u[d]=0;for(let r=0;r<n;r++)if(a[r].index===i[d]){u[d]=1;break}}return e!==a&&a.dispose(),t!==r&&r.dispose(),sX(u,r.shape,"bool")};const B0=aX({conv2DBackpropFilter_:function(e,t,n,a,r){let o=arguments.length>5&&void 0!==arguments[5]?arguments[5]:"NHWC",s=arguments.length>6?arguments[6]:void 0,i=e;3===e.rank&&(i=iJ(e,[1,e.shape[0],e.shape[1],e.shape[2]]));let c=t;3===c.rank&&(c=iJ(t,[1,t.shape[0],t.shape[1],t.shape[2]])),BU(4===i.rank,(()=>"Error in conv2dDerFilter: input must be rank 4, but got shape "+"".concat(i.shape,"."))),BU(4===c.rank,(()=>"Error in conv2dDerFilter: dy must be rank 4, but got shape "+"".concat(c.shape,"."))),BU(4===n.length,(()=>"Error in conv2dDerFilter: filterShape must be length 4, but got "+"".concat(n,".")));const l="NHWC"===o?i.shape[3]:i.shape[1],u="NHWC"===o?c.shape[3]:c.shape[1];BU(l===n[2],(()=>"Error in conv2dDerFilter: depth of input ".concat(l,") must ")+"match input depth in filter (".concat(n[2],"."))),BU(u===n[3],(()=>"Error in conv2dDerFilter: depth of dy (".concat(u,") must ")+"match output depth for filter (".concat(n[3],")."))),sJ("conv2dDerFilter",r,s);const d={x:i,dy:c},h={strides:a,pad:r,dataFormat:o,dimRoundingMode:s,filterShape:n};return jq.runKernel($G,d,h)}});function W0(e,t,n){if(null==n||"linear"===n)return e;if("relu"===n)return IY(e,c0(t));throw new Error("Cannot compute gradient for fused activation ".concat(n,"."))}function V0(e,t){let n=t;const a=WY(e.shape,t.shape);return a.length>0&&(n=dZ(n,a)),iJ(n,e.shape)}function U0(e,t,n,a){if("linear"===t)return e;if("relu"===t)return D$(e);if("elu"===t)return ZJ(e);if("relu6"===t)return M$(e);if("prelu"===t)return b$(e,n);if("leakyrelu"===t)return EZ(e,a);if("sigmoid"===t)return hJ(e);throw new Error("Unknown fused activation ".concat(t,"."))}const G0=(e,t)=>!(e>0)||"linear"===t;const H0=aX({fusedConv2d_:function(e){let{x:t,filter:n,strides:a,pad:r,dataFormat:o="NHWC",dilations:s=[1,1],dimRoundingMode:i,bias:c,activation:l="linear",preluActivationWeights:u,leakyreluAlpha:d}=e;if(l=l||"linear",!1===G0(jq.state.gradientDepth,l)){BU("NHWC"===o,(()=>"Error in fused conv2d: got dataFormat of ".concat(o," but ")+"only NHWC is currently supported for the case of gradient depth is 0 and the activation is not linear."));let e=AJ(t,n,a,r,o,s,i);return null!=c&&(e=vY(e,c)),U0(e,l,u,d)}const h=eX(t,"x","conv2d","float32"),p=eX(n,"filter","conv2d","float32");let f=h,m=!1;3===h.rank&&(m=!0,f=iJ(h,[1,h.shape[0],h.shape[1],h.shape[2]])),BU(4===f.rank,(()=>"Error in fused conv2d: input must be rank 4, but got rank "+"".concat(f.rank,"."))),BU(4===p.rank,(()=>"Error in fused conv2d: filter must be rank 4, but got rank "+"".concat(p.rank,"."))),sJ("fused conv2d",r,i);const g="NHWC"===o?f.shape[3]:f.shape[1];BU(p.shape[2]===g,(()=>"Error in conv2d: depth of input (".concat(g,") must match ")+"input depth for filter ".concat(p.shape[2],"."))),BU(aJ(a,s),(()=>"Error in conv2D: Either strides or dilations must be 1. "+"Got strides ".concat(a," and dilations '").concat(s,"'")));const b=YQ(f.shape,p.shape,a,s,r,i);let y,x;if(null!=c&&(y=eX(c,"bias","fused conv2d"),[y]=zq(y,h),"NHWC"===o?VY(b.outShape,y.shape):(BU(y.shape.length<=1,(()=>"Error in fused conv2d: only supports scalar or 1-D Tensor bias for NCHW format but got the bias of "+"rank-".concat(y.shape.length,"."))),BU(0===y.shape.length||y.shape[0]===b.outChannels||1===y.shape[0],(()=>"Error in fused conv2d: bias shape (".concat(y.shape,") is not ")+"compatible with the number of output channels "+"(".concat(b.outChannels,")"))))),null!=u){const e=u.shape;if(BU(e.length<=1||3===e.length,(()=>"Error in fused conv2d: only supports scalar, 1-D Tensor or 3-D Tensor PReLU activation weights but got a tensor of "+"rank-".concat(e.length,"."))),1===e.length)BU(1===e[0]||e[0]===b.outChannels,(()=>"Error in fused conv2d: PReLU activation weights "+"(".concat(e,") is not compatible with the number of output ")+"channels (".concat(b.outChannels,").")));else if(3===e.length)try{VY(e,b.outShape)}catch(B){const n="Error in fused conv2d: PReLU activation weights (".concat(e,") ")+"is not compatible with the output shape of the conv2d "+"(".concat(b.outShape,").");throw Error(n)}x=eX(u,"prelu weights","fused conv2d")}const v=(e,t)=>{BU("NHWC"===o,(()=>"Error in gradient of fused conv2D: got dataFormat of ".concat(o," but only NHWC is currently supported.")));const[n,i,c,u]=t,d=W0(e,c,l);BU(nJ(s),(()=>"Error in gradient of fused conv2D: dilation rates greater than 1 "+"are not yet supported in gradients. Got dilations '".concat(s,"'")));const h=[OJ(i.shape,d,n,a,r),B0(i,d,n.shape,a,r)];if(null!=u){const e=V0(u,d);h.push(e)}return h},w={x:f,filter:p,bias:y,preluActivationWeights:x},k={strides:a,pad:r,dataFormat:o,dilations:s,dimRoundingMode:i,activation:l,leakyreluAlpha:d};if(null==c){const e=TY(((e,t,n)=>{let a=jq.runKernel(FK,w,k);return n([t,e,a]),m&&(a=iJ(a,[a.shape[1],a.shape[2],a.shape[3]])),{value:a,gradFunc:v}}));return e(f,p)}{const e=TY(((e,t,n,a)=>{let r=jq.runKernel(FK,w,k);return a([t,e,r,n]),m&&(r=iJ(r,[r.shape[1],r.shape[2],r.shape[3]])),{value:r,gradFunc:v}}));return e(f,p,y)}}});const j0=aX({depthwiseConv2dNativeBackpropFilter_:function(e,t,n,a,r){let o=arguments.length>5&&void 0!==arguments[5]?arguments[5]:[1,1],s=arguments.length>6?arguments[6]:void 0,i=e;3===e.rank&&(i=iJ(e,[1,e.shape[0],e.shape[1],e.shape[2]]));let c=t;3===c.rank&&(c=iJ(t,[1,t.shape[0],t.shape[1],t.shape[2]]));const l={x:i,dy:c},u={strides:a,pad:r,dimRoundingMode:s,dilations:o,filterShape:n};return jq.runKernel(hH,l,u)}});const K0=aX({depthwiseConv2dNativeBackpropInput_:function(e,t,n,a,r){let o=arguments.length>5&&void 0!==arguments[5]?arguments[5]:[1,1],s=arguments.length>6?arguments[6]:void 0,i=t,c=!1;3===t.rank&&(c=!0,i=iJ(t,[1,t.shape[0],t.shape[1],t.shape[2]]));const l={dy:i,filter:n},u={strides:a,pad:r,dimRoundingMode:s,dilations:o,inputShape:e},d=jq.runKernel(pH,l,u);return c?iJ(d,[d.shape[1],d.shape[2],d.shape[3]]):d}});const q0=aX({fusedDepthwiseConv2d_:function(e){let{x:t,filter:n,strides:a,pad:r,dataFormat:o="NHWC",dilations:s=[1,1],dimRoundingMode:i,bias:c,activation:l="linear",preluActivationWeights:u,leakyreluAlpha:d}=e;if(!1===G0(jq.state.gradientDepth,l)){let e=HJ(t,n,a,r,o,s,i);return null!=c&&(e=vY(e,c)),U0(e,l,u,d)}const h=eX(t,"x","depthwiseConv2d","float32"),p=eX(n,"filter","depthwiseConv2d","float32");let f=h,m=!1;3===h.rank&&(m=!0,f=iJ(h,[1,h.shape[0],h.shape[1],h.shape[2]])),BU(4===f.rank,(()=>"Error in fused depthwiseConv2d: input must be rank 4, but got "+"rank ".concat(f.rank,"."))),BU(4===p.rank,(()=>"Error in fused depthwiseConv2d: filter must be rank 4, "+"but got rank ".concat(p.rank,"."))),BU(f.shape[3]===p.shape[2],(()=>"Error in fused depthwiseConv2d: number of input channels "+"(".concat(f.shape[3],") must match the inChannels dimension in ")+"filter ".concat(p.shape[2],"."))),null==s&&(s=[1,1]),BU(aJ(a,s),(()=>"Error in fused depthwiseConv2d: Either strides or dilations must "+"be 1. Got strides ".concat(a," and dilations '").concat(s,"'"))),sJ("fused depthwiseConv2d",r,i);const g=YQ(f.shape,p.shape,a,s,r,i,!0);let b,y;null!=c&&(b=eX(c,"bias","fused conv2d"),[b]=zq(b,h),VY(g.outShape,b.shape)),null!=u&&(y=eX(u,"prelu weights","fused depthwiseConv2d"));const x=(e,t)=>{BU(nJ(s),(()=>"Error in gradient of fused depthwiseConv2d: dilation rates greater than 1 are not yet supported. Got dilations "+"'".concat(s,"'")));const[n,o,c,u]=t,d=W0(e,c,l),h=K0(o.shape,d,n,a,r,s,i),p=j0(o,d,n.shape,a,r,s,i);if(null!=u){return[h,p,V0(b,d)]}return[h,p]},v={x:f,filter:p,bias:b,preluActivationWeights:y},w={strides:a,pad:r,dataFormat:o,dilations:s,dimRoundingMode:i,activation:l,leakyreluAlpha:d};if(null==c){const e=TY(((e,t,n)=>{let a=jq.runKernel(OK,v,w);return n([t,e,a]),m&&(a=iJ(a,[a.shape[1],a.shape[2],a.shape[3]])),{value:a,gradFunc:x}}));return e(f,p)}{const e=TY(((e,t,n,a)=>{let r=jq.runKernel(OK,v,w);return a([t,e,r,n]),m&&(r=iJ(r,[r.shape[1],r.shape[2],r.shape[3]])),{value:r,gradFunc:x}}));return e(f,p,b)}}});const X0=aX({fusedMatMul_:function(e){let{a:t,b:n,transposeA:a=!1,transposeB:r=!1,bias:o,activation:s="linear",preluActivationWeights:i,leakyreluAlpha:c=.2}=e;if(!1===G0(jq.state.gradientDepth,s)){let e=dJ(t,n,a,r);return null!=o&&(e=vY(e,o)),U0(e,s,i,c)}let l=eX(t,"a","fused matMul"),u=eX(n,"b","fused matMul");[l,u]=zq(l,u);const d=a?l.shape[l.rank-2]:l.shape[l.rank-1],h=r?u.shape[u.rank-1]:u.shape[u.rank-2],p=a?l.shape[l.rank-1]:l.shape[l.rank-2],f=r?u.shape[u.rank-2]:u.shape[u.rank-1],m=l.shape.slice(0,-2),g=u.shape.slice(0,-2),b=UU(m),y=UU(g);BU(d===h,(()=>"Error in fused matMul: inner shapes (".concat(d,") and (")+"".concat(h,") of Tensors with shapes ").concat(l.shape," and ")+"".concat(u.shape," and transposeA=").concat(a)+" and transposeB=".concat(r," must match.")));const x=VY(l.shape.slice(0,-2),u.shape.slice(0,-2)).concat([p,f]),v=iJ(l,a?[b,d,p]:[b,p,d]),w=iJ(u,r?[y,f,h]:[y,h,f]);let k,I;null!=o&&(k=eX(o,"bias","fused matMul"),[k]=zq(k,l),VY(x,k.shape)),null!=i&&(I=eX(i,"prelu weights","fused matMul"));const S=(e,t)=>{const[n,i,c,l]=t,u=W0(iJ(e,c.shape),c,s);let d,h;if(a||r?!a&&r?(d=dJ(u,i,!1,!1),h=dJ(u,n,!0,!1)):a&&!r?(d=dJ(i,u,!1,!0),h=dJ(n,u,!1,!1)):(d=dJ(i,u,!0,!0),h=dJ(u,n,!0,!0)):(d=dJ(u,i,!1,!0),h=dJ(n,u,!0,!1)),null!=o){return[d,h,V0(l,u)]}return[d,h]},N={a:v,b:w,bias:k,preluActivationWeights:I},C={transposeA:a,transposeB:r,activation:s,leakyreluAlpha:c};if(null==o){const e=TY(((e,t,n)=>{const a=jq.runKernel(AK,N,C);return n([e,t,a]),{value:iJ(a,x),gradFunc:S}}));return e(v,w)}{const e=TY(((e,t,n,a)=>{const r=jq.runKernel(AK,N,C);return a([e,t,r,n]),{value:iJ(r,x),gradFunc:S}}));return e(v,w,k)}}});const Y0=aX({hammingWindow_:function(e){return P0(e,.54,.46)}});const Q0=aX({hannWindow_:function(e){return P0(e,.5,.5)}});const J0=aX({frame_:function(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]&&arguments[3],r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:0,o=0;const s=[];for(;o+t<=e.size;)s.push(pJ(e,o,t)),o+=n;if(a)for(;o<e.size;){const a=o+t-e.size,i=uJ([pJ(e,o,t-a),MY([a],r)]);s.push(i),o+=n}return 0===s.length?h0([],[0,t]):iJ(uJ(s),[s.length,t])}});const Z0=aX({stft_:function(e,t,n,a){let r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:Q0;null==a&&(a=L0(t));const o=J0(e,t,n),s=IY(o,r(t));return r0(s,a)}});const $0=aX({cropAndResize_:function(e,t,n,a){let r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"bilinear",o=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0;const s=eX(e,"image","cropAndResize"),i=eX(t,"boxes","cropAndResize","float32"),c=eX(n,"boxInd","cropAndResize","int32"),l=i.shape[0];BU(4===s.rank,(()=>"Error in cropAndResize: image must be rank 4,"+"but got rank ".concat(s.rank,"."))),BU(2===i.rank&&4===i.shape[1],(()=>"Error in cropAndResize: boxes must be have size [".concat(l,",4] ")+"but had shape ".concat(i.shape,"."))),BU(1===c.rank&&c.shape[0]===l,(()=>"Error in cropAndResize: boxInd must be have size [".concat(l,"] ")+"but had shape ".concat(i.shape,"."))),BU(2===a.length,(()=>"Error in cropAndResize: cropSize must be of length 2, but got "+"length ".concat(a.length,"."))),BU(a[0]>=1&&a[1]>=1,(()=>"cropSize must be atleast [1,1], but was ".concat(a))),BU("bilinear"===r||"nearest"===r,(()=>"method must be bilinear or nearest, but was ".concat(r)));const u={image:s,boxes:i,boxInd:c},d={method:r,extrapolationValue:o,cropSize:a};return jq.runKernel(cH,u,d)}});const e1=aX({flipLeftRight_:function(e){const t=eX(e,"image","flipLeftRight","float32");BU(4===t.rank,(()=>"Error in flipLeftRight: image must be rank 4,"+"but got rank ".concat(t.rank,".")));const n={image:t};return jq.runKernel(_H,n,{})}});const t1=aX({grayscaleToRGB_:function(e){const t=eX(e,"image","grayscaleToRGB"),n=t.rank-1,a=t.shape[n];BU(t.rank>=2,(()=>"Error in grayscaleToRGB: images must be at least rank 2, "+"but got rank ".concat(t.rank,"."))),BU(1===a,(()=>"Error in grayscaleToRGB: last dimension of a grayscale image "+"should be size 1, but got size ".concat(a,".")));const r=new Array(t.rank);return r.fill(1,0,n),r[n]=3,yZ(t,r)}});const n1=aX({rgbToGrayscale_:function(e){const t=eX(e,"image","RGBToGrayscale"),n=t.rank-1,a=t.shape[n];BU(t.rank>=2,(()=>"Error in RGBToGrayscale: images must be at least rank 2, "+"but got rank ".concat(t.rank,"."))),BU(3===a,(()=>"Error in RGBToGrayscale: last dimension of an RGB image "+"should be size 3, but got size ".concat(a,".")));const r=t.dtype,o=bY(t,"float32"),s=d0([.2989,.587,.114]);let i;switch(t.rank){case 2:i=JJ("ij,j->i",o,s);break;case 3:i=JJ("ijk,k->ij",o,s);break;case 4:i=JJ("ijkl,l->ijk",o,s);break;case 5:i=JJ("ijklm,m->ijkl",o,s);break;case 6:i=JJ("ijklmn,n->ijklm",o,s);break;default:throw new Error("Not a valid tensor rank.")}return i=gZ(i,-1),bY(i,r)}});const a1=aX({rotateWithOffset_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:.5;const r=eX(e,"image","rotateWithOffset","float32");BU(4===r.rank,(()=>"Error in rotateWithOffset: image must be rank 4,"+"but got rank ".concat(r.rank,".")));const o={image:r},s={radians:t,fillValue:n,center:a};return jq.runKernel(_K,o,s)}});function r1(e,t,n,a,r,o){null==a&&(a=.5),null==r&&(r=Number.NEGATIVE_INFINITY),null==o&&(o=0);const s=e.shape[0];return n=Math.min(n,s),BU(0<=a&&a<=1,(()=>"iouThreshold must be in [0, 1], but was '".concat(a,"'"))),BU(2===e.rank,(()=>"boxes must be a 2D tensor, but was of rank '".concat(e.rank,"'"))),BU(4===e.shape[1],(()=>"boxes must have 4 columns, but 2nd dimension was ".concat(e.shape[1]))),BU(1===t.rank,(()=>"scores must be a 1D tensor")),BU(t.shape[0]===s,(()=>"scores has incompatible shape with boxes. Expected ".concat(s,", ")+"but was ".concat(t.shape[0]))),BU(0<=o&&o<=1,(()=>"softNmsSigma must be in [0, 1], but was '".concat(o,"'"))),{maxOutputSize:n,iouThreshold:a,scoreThreshold:r,softNmsSigma:o}}const o1=aX({nonMaxSuppression_:function(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:.5,r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:Number.NEGATIVE_INFINITY;const o=eX(e,"boxes","nonMaxSuppression","float32"),s=eX(t,"scores","nonMaxSuppression","float32"),i=r1(o,s,n,a,r);n=i.maxOutputSize,a=i.iouThreshold,r=i.scoreThreshold;const c={maxOutputSize:n,iouThreshold:a,scoreThreshold:r};return jq.runKernel(bj,{boxes:o,scores:s},c)}});function s1(e,t,n){const a=function(e,t,n){return function(e,t,n){let a=0,r=e.length,o=0,s=!1;for(;a<r;){o=a+(r-a>>>1);const i=n(t,e[o]);i>0?a=o+1:(r=o,s=!i)}return s?a:-a-1}(e,t,n||i1)}(e,t,n),r=a<0?-(a+1):a;e.splice(r,0,t)}function i1(e,t){return e>t?1:e<t?-1:0}function c1(e,t,n,a,r){return d1(e,t,n,a,r,0)}function l1(e,t,n,a,r,o){return d1(e,t,n,a,r,0,!1,o,!0)}function u1(e,t,n,a,r,o){return d1(e,t,n,a,r,o,!0)}function d1(e,t,n,a,r,o){let s=arguments.length>6&&void 0!==arguments[6]&&arguments[6],i=arguments.length>7&&void 0!==arguments[7]&&arguments[7],c=arguments.length>8&&void 0!==arguments[8]&&arguments[8];const l=[];for(let g=0;g<t.length;g++)t[g]>r&&l.push({score:t[g],boxIndex:g,suppressBeginIndex:0});l.sort(f1);const u=o>0?-.5/o:0,d=[],h=[];for(;d.length<n&&l.length>0;){const t=l.pop(),{score:n,boxIndex:o,suppressBeginIndex:s}=t;if(n<r)break;let i=!1;for(let c=d.length-1;c>=s;--c){const n=h1(e,o,d[c]);if(n>=a){i=!0;break}if(t.score=t.score*p1(a,u,n),t.score<=r)break}t.suppressBeginIndex=d.length,i||(t.score===n?(d.push(o),h.push(t.score)):t.score>r&&s1(l,t,f1))}const p=d.length,f=n-p;i&&f>0&&(d.push(...new Array(f).fill(0)),h.push(...new Array(f).fill(0)));const m={selectedIndices:d};return s&&(m.selectedScores=h),c&&(m.validOutputs=p),m}function h1(e,t,n){const a=e.subarray(4*t,4*t+4),r=e.subarray(4*n,4*n+4),o=Math.min(a[0],a[2]),s=Math.min(a[1],a[3]),i=Math.max(a[0],a[2]),c=Math.max(a[1],a[3]),l=Math.min(r[0],r[2]),u=Math.min(r[1],r[3]),d=Math.max(r[0],r[2]),h=Math.max(r[1],r[3]),p=(i-o)*(c-s),f=(d-l)*(h-u);if(p<=0||f<=0)return 0;const m=Math.max(o,l),g=Math.max(s,u),b=Math.min(i,d),y=Math.min(c,h),x=Math.max(b-m,0)*Math.max(y-g,0);return x/(p+f-x)}function p1(e,t,n){const a=Math.exp(t*n*n);return n<=e?a:0}function f1(e,t){return e.score-t.score||e.score===t.score&&t.boxIndex-e.boxIndex}const m1=async function(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:.5,r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:Number.NEGATIVE_INFINITY;const o=eX(e,"boxes","nonMaxSuppressionAsync"),s=eX(t,"scores","nonMaxSuppressionAsync"),i=r1(o,s,n,a,r);n=i.maxOutputSize,a=i.iouThreshold,r=i.scoreThreshold;const c=await Promise.all([o.data(),s.data()]),l=c[0],u=c[1],{selectedIndices:d}=c1(l,u,n,a,r);return o!==e&&o.dispose(),s!==t&&s.dispose(),d0(d,"int32")};const g1=aX({nonMaxSuppressionWithScore_:function(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:.5,r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:Number.NEGATIVE_INFINITY,o=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0;const s=eX(e,"boxes","nonMaxSuppression"),i=eX(t,"scores","nonMaxSuppression"),c=r1(s,i,n,a,r,o);n=c.maxOutputSize,a=c.iouThreshold,r=c.scoreThreshold,o=c.softNmsSigma;const l={boxes:s,scores:i},u={maxOutputSize:n,iouThreshold:a,scoreThreshold:r,softNmsSigma:o},d=jq.runKernel(xj,l,u);return{selectedIndices:d[0],selectedScores:d[1]}}});const b1=async function(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:.5,r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:Number.NEGATIVE_INFINITY,o=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0;const s=eX(e,"boxes","nonMaxSuppressionAsync"),i=eX(t,"scores","nonMaxSuppressionAsync"),c=r1(s,i,n,a,r,o);n=c.maxOutputSize,a=c.iouThreshold,r=c.scoreThreshold,o=c.softNmsSigma;const l=await Promise.all([s.data(),i.data()]),u=l[0],d=l[1],{selectedIndices:h,selectedScores:p}=u1(u,d,n,a,r,o);return s!==e&&s.dispose(),i!==t&&i.dispose(),{selectedIndices:d0(h,"int32"),selectedScores:d0(p)}};const y1=aX({nonMaxSuppressionPadded_:function(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:.5,r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:Number.NEGATIVE_INFINITY,o=arguments.length>5&&void 0!==arguments[5]&&arguments[5];const s=eX(e,"boxes","nonMaxSuppression"),i=eX(t,"scores","nonMaxSuppression"),c=r1(s,i,n,a,r,null),l={boxes:s,scores:i},u={maxOutputSize:c.maxOutputSize,iouThreshold:c.iouThreshold,scoreThreshold:c.scoreThreshold,padToMaxOutputSize:o},d=jq.runKernel(yj,l,u);return{selectedIndices:d[0],validOutputs:d[1]}}});const x1=async function(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:.5,r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:Number.NEGATIVE_INFINITY,o=arguments.length>5&&void 0!==arguments[5]&&arguments[5];const s=eX(e,"boxes","nonMaxSuppressionAsync"),i=eX(t,"scores","nonMaxSuppressionAsync"),c=r1(s,i,n,a,r,null),l=c.maxOutputSize,u=c.iouThreshold,d=c.scoreThreshold,[h,p]=await Promise.all([s.data(),i.data()]),{selectedIndices:f,validOutputs:m}=l1(h,p,l,u,d,o);return s!==e&&s.dispose(),i!==t&&i.dispose(),{selectedIndices:d0(f,"int32"),validOutputs:EY(m,"int32")}};const v1=aX({resizeBilinear_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],a=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const r=eX(e,"images","resizeBilinear");BU(3===r.rank||4===r.rank,(()=>"Error in resizeBilinear: x must be rank 3 or 4, but got "+"rank ".concat(r.rank,"."))),BU(2===t.length,(()=>"Error in resizeBilinear: new shape must 2D, but got shape "+"".concat(t,"."))),BU(!1===a||!1===n,(()=>"Error in resizeBilinear: If halfPixelCenters is true, alignCorners must be false."));let o=r,s=!1;3===r.rank&&(s=!0,o=iJ(r,[1,r.shape[0],r.shape[1],r.shape[2]]));const[]=t,i={images:o},c={alignCorners:n,halfPixelCenters:a,size:t},l=jq.runKernel(Pj,i,c);return s?iJ(l,[l.shape[1],l.shape[2],l.shape[3]]):l}});const w1=aX({resizeNearestNeighbor_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],a=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const r=eX(e,"images","resizeNearestNeighbor");BU(3===r.rank||4===r.rank,(()=>"Error in resizeNearestNeighbor: x must be rank 3 or 4, but got "+"rank ".concat(r.rank,"."))),BU(2===t.length,(()=>"Error in resizeNearestNeighbor: new shape must 2D, but got shape "+"".concat(t,"."))),BU("float32"===r.dtype||"int32"===r.dtype,(()=>"`images` must have `int32` or `float32` as dtype")),BU(!1===a||!1===n,(()=>"Error in resizeNearestNeighbor: If halfPixelCenters is true, alignCorners must be false."));let o=r,s=!1;3===r.rank&&(s=!0,o=iJ(r,[1,r.shape[0],r.shape[1],r.shape[2]]));const[]=t,i={images:o},c={alignCorners:n,halfPixelCenters:a,size:t},l=jq.runKernel(Mj,i,c);return s?iJ(l,[l.shape[1],l.shape[2],l.shape[3]]):l}});const k1=aX({threshold_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"binary",n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:.5;const r=eX(e,"image","threshold"),o=r.shape[0]*r.shape[1];let s,i,c,l,u=IY(d0([a]),255);if(BU(3===r.rank,(()=>"Error in threshold: image must be rank 3,"+"but got rank ".concat(r.rank,"."))),BU(3===r.shape[2]||1===r.shape[2],(()=>"Error in threshold: image color channel must be equal to 3 or 1"+"but got ".concat(r.shape[2],"."))),BU("int32"===r.dtype||"float32"===r.dtype,(()=>"Error in dtype: image dtype must be int32 or float32,"+"but got dtype ".concat(r.dtype,"."))),BU("otsu"===t||"binary"===t,(()=>"Method must be binary or otsu, but was ".concat(t))),3===r.shape[2]){[s,i,c]=a0(r,[1,1,1],-1);const e=IY(s,.2989),t=IY(i,.587),n=IY(c,.114);l=vY(vY(e,t),n)}else l=e;if("otsu"===t){u=function(e,t){let n,a,r,o,s,i,c=d0([-1]),l=d0([0]),u=d0([0]);for(let d=0;d<e.size-1;d++){n=pJ(e,0,d+1),a=pJ(e,d+1),s=kY(dZ(n),t),i=kY(dZ(a),t);const h=dZ(IY(n,A$(0,n.size)));r=kY(h,dZ(n));const p=MY(a.shape,n.size),f=vY(A$(0,a.size),p),m=IY(a,f);o=kY(dZ(m),dZ(a));const g=PY(r,o),b=PY(r,o),y=IY(s,i);u=IY(IY(y,g),b);const x=kZ(u,l);l=XJ(x,u,l),c=XJ(x,d0([d]),c)}return c}(wJ(bY(V$(l),"int32"),sX([]),256),o)}const d=n?_Z(l,u):kZ(l,u);return bY(IY(d,255),"int32")}});const I1=aX({transform_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"nearest",a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"constant",r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:0,o=arguments.length>5?arguments[5]:void 0;const s=eX(e,"image","transform","float32"),i=eX(t,"transforms","transform","float32");BU(4===s.rank,(()=>"Error in transform: image must be rank 4,"+"but got rank ".concat(s.rank,"."))),BU(2===i.rank&&(i.shape[0]===s.shape[0]||1===i.shape[0])&&8===i.shape[1],(()=>"Error in transform: Input transform should be batch x 8 or 1 x 8")),BU(null==o||2===o.length,(()=>"Error in transform: outputShape must be [height, width] or null, "+"but got ".concat(o,".")));const c={image:s,transforms:i},l={interpolation:n,fillMode:a,fillValue:r,outputShape:o};return jq.runKernel(kK,c,l)}});const S1=aX({bandPart_:function(e,t,n){const a=eX(e,"a","bandPart");BU(a.rank>=2,(()=>"bandPart(): Rank must be at least 2, got ".concat(a.rank,".")));const r=a.shape,[o,s]=a.shape.slice(-2);let i,c;"number"===typeof t?(BU(t%1===0,(()=>"bandPart(): numLower must be an integer, got ".concat(t,"."))),BU(t<=o,(()=>"bandPart(): numLower (".concat(t,")")+" must not be greater than the number of rows (".concat(o,")."))),i=eX(t<0?o:t,"numLower","bandPart")):(BU("int32"===t.dtype,(()=>"bandPart(): numLower's dtype must be an int32.")),i=XJ(RZ(t,0),o,e$(t,o))),"number"===typeof n?(BU(n%1===0,(()=>"bandPart(): numUpper must be an integer, got ".concat(n,"."))),BU(n<=s,(()=>"bandPart(): numUpper (".concat(n,")")+" must not be greater than the number of columns (".concat(s,")."))),c=eX(n<0?s:n,"numUpper","bandPart")):(BU("int32"===n.dtype,(()=>"bandPart(): numUpper's dtype must be an int32.")),c=XJ(RZ(n,0),s,e$(n,s)));const l=iJ(A$(0,o,1,"int32"),[-1,1]),u=A$(0,s,1,"int32"),d=PY(l,u),h=WZ(_Z(d,i),IZ(d,MZ(c))),p=JZ([o,s],a.dtype);return iJ(i0(S0(iJ(a,[-1,o,s])).map((e=>XJ(h,e,p)))),r)}});const N1=aX({gramSchmidt_:function(e){let t;if(Array.isArray(e)){t=!1,BU(null!=e&&e.length>0,(()=>"Gram-Schmidt process: input must not be null, undefined, or empty"));const n=e[0].shape[0];for(let t=1;t<e.length;++t)BU(e[t].shape[0]===n,(()=>"Gram-Schmidt: Non-unique lengths found in the input vectors: "+"(".concat(e[t].shape[0]," vs. ").concat(n,")")))}else t=!0,e=a0(e,e.shape[0],0).map((e=>s0(e,[0])));BU(e.length<=e[0].shape[0],(()=>"Gram-Schmidt: Number of vectors (".concat(e.length,") exceeds ")+"number of dimensions (".concat(e[0].shape[0],").")));const n=[],a=e;for(let r=0;r<e.length;++r)n.push(jq.tidy((()=>{let e=a[r];if(r>0)for(let t=0;t<r;++t){const a=IY(dZ(IY(n[t],e)),n[t]);e=PY(e,a)}return kY(e,pZ(e,"euclidean"))})));return t?i0(n,0):n}});function C1(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];return jq.tidy((()=>{BU(2===e.shape.length,(()=>"qr2d() requires a 2D Tensor, but got a ".concat(e.shape.length,"D Tensor.")));const n=e.shape[0],a=e.shape[1];let r=xZ(n),o=yY(e);const s=h0([[1]],[1,1]);let i=yY(s);const c=n>=a?a:n;for(let e=0;e<c;++e){const t=o,c=i,l=r;[i,o,r]=jq.tidy((()=>{const t=pJ(o,[e,e],[n-e,1]),c=pZ(t),l=pJ(o,[e,e],[1,1]),u=XJ(kZ(l,0),h0([[-1]]),h0([[1]])),d=PY(l,IY(u,c)),h=kY(t,d);i=1===h.shape[0]?yY(s):uJ([s,pJ(h,[1,0],[h.shape[0]-1,h.shape[1]])],0);const p=MZ(kY(dJ(u,d),c)),f=pJ(o,[e,0],[n-e,a]),m=IY(p,i),g=_0(i);if(0===e)o=PY(f,dJ(m,dJ(g,f)));else{const t=PY(f,dJ(m,dJ(g,f)));o=uJ([pJ(o,[0,0],[e,a]),t],0)}const b=_0(m),y=pJ(r,[0,e],[n,r.shape[1]-e]);if(0===e)r=PY(y,dJ(dJ(y,i),b));else{const t=PY(y,dJ(dJ(y,i),b));r=uJ([pJ(r,[0,0],[n,e]),t],1)}return[i,o,r]})),dX([t,c,l])}return!t&&n>a&&(r=pJ(r,[0,0],[n,a]),o=pJ(o,[0,0],[a,a])),[r,o]}))}const T1=aX({qr_:function(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];if(BU(e.rank>=2,(()=>"qr() requires input tensor to have a rank >= 2, but got rank ".concat(e.rank))),2===e.rank)return C1(e,t);{const n=e.shape.slice(0,e.shape.length-2).reduce(((e,t)=>e*t)),a=S0(iJ(e,[n,e.shape[e.shape.length-2],e.shape[e.shape.length-1]]),0),r=[],o=[];a.forEach((e=>{const[n,a]=C1(e,t);r.push(n),o.push(a)}));return[iJ(i0(r,0),e.shape),iJ(i0(o,0),e.shape)]}}});var E1;!function(e){e[e.NONE=0]="NONE",e[e.MEAN=1]="MEAN",e[e.SUM=2]="SUM",e[e.SUM_BY_NONZERO_WEIGHTS=3]="SUM_BY_NONZERO_WEIGHTS"}(E1||(E1={}));const R1=aX({computeWeightedLoss_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:E1.SUM_BY_NONZERO_WEIGHTS;const a=eX(e,"losses","computeWeightedLoss");let r=null;null!=t&&(r=eX(t,"weights","computeWeightedLoss"));const o=null==r?a:IY(a,r);if(n===E1.NONE)return o;if(n===E1.SUM)return dZ(o);if(n===E1.MEAN){if(null==r)return QZ(o);{const e=a.size/r.size,t=kY(dZ(o),dZ(r));return e>1?kY(t,EY(e)):t}}if(n===E1.SUM_BY_NONZERO_WEIGHTS){if(null==r)return kY(dZ(o),EY(a.size));{const e=IY(r,ZZ(a.shape)),t=bY(dZ(s$(e,EY(0))),"float32");return kY(dZ(o),t)}}throw Error("Unknown reduction: ".concat(n))}});const _1=aX({absoluteDifference_:function(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:E1.SUM_BY_NONZERO_WEIGHTS;const r=eX(e,"labels","absoluteDifference"),o=eX(t,"predictions","absoluteDifference");let s=null;null!=n&&(s=eX(n,"weights","absoluteDifference")),WU(r.shape,o.shape,"Error in absoluteDifference: ");const i=zY(PY(r,o));return R1(i,s,a)}});const A1=aX({cosineDistance_:function(e,t,n,a){let r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:E1.SUM_BY_NONZERO_WEIGHTS;const o=eX(e,"labels","cosineDistance"),s=eX(t,"predictions","cosineDistance");let i=null;null!=a&&(i=eX(a,"weights","cosineDistance")),WU(o.shape,s.shape,"Error in cosineDistance: ");const c=EY(1),l=PY(c,dZ(IY(o,s),n,!0));return R1(l,i,r)}});const F1=aX({hingeLoss_:function(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:E1.SUM_BY_NONZERO_WEIGHTS,r=eX(e,"labels","hingeLoss");const o=eX(t,"predictions","hingeLoss");let s=null;null!=n&&(s=eX(n,"weights","hingeLoss")),WU(r.shape,o.shape,"Error in hingeLoss: ");const i=EY(1);r=PY(IY(EY(2),r),i);const c=D$(PY(i,IY(r,o)));return R1(c,s,a)}});const O1=aX({huberLoss_:function(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1,r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:E1.SUM_BY_NONZERO_WEIGHTS;const o=eX(e,"labels","huberLoss"),s=eX(t,"predictions","huberLoss");let i=null;null!=n&&(i=eX(n,"weights","huberLoss")),WU(o.shape,s.shape,"Error in huberLoss: ");const c=EY(a),l=zY(PY(s,o)),u=e$(l,c),d=PY(l,u),h=vY(IY(EY(.5),NY(u)),IY(c,d));return R1(h,i,r)}});const D1=aX({logLoss_:function(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1e-7,r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:E1.SUM_BY_NONZERO_WEIGHTS;const o=eX(e,"labels","logLoss"),s=eX(t,"predictions","logLoss");let i=null;null!=n&&(i=eX(n,"weights","logLoss")),WU(o.shape,s.shape,"Error in logLoss: ");const c=EY(1),l=EY(a),u=MZ(IY(o,OZ(vY(s,l)))),d=IY(PY(c,o),OZ(vY(PY(c,s),l))),h=PY(u,d);return R1(h,i,r)}});const M1=aX({meanSquaredError_:function(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:E1.SUM_BY_NONZERO_WEIGHTS;const r=eX(e,"labels","meanSquaredError"),o=eX(t,"predictions","meanSquaredError");let s=null;null!=n&&(s=eX(n,"weights","meanSquaredError")),WU(r.shape,o.shape,"Error in meanSquaredError: ");const i=o0(r,o);return R1(i,s,a)}});const L1=aX({sigmoidCrossEntropy_:function(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0,r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:E1.SUM_BY_NONZERO_WEIGHTS,o=eX(e,"multiClassLabels","sigmoidCrossEntropy");const s=eX(t,"logits","sigmoidCrossEntropy");let i=null;if(null!=n&&(i=eX(n,"weights","sigmoidCrossEntropy")),WU(o.shape,s.shape,"Error in sigmoidCrossEntropy: "),a>0){const e=EY(a),t=EY(1),n=EY(.5);o=vY(IY(o,PY(t,e)),IY(n,e))}const c=function(e,t){const n=eX(e,"labels","sigmoidCrossEntropyWithLogits"),a=eX(t,"logits","sigmoidCrossEntropyWithLogits");WU(n.shape,a.shape,"Error in sigmoidCrossEntropyWithLogits: ");const r=D$(a),o=IY(a,n),s=DZ(mZ(MZ(zY(a))));return vY(PY(r,o),s)}(o,s);return R1(c,i,r)}});const P1=aX({softmaxCrossEntropy_:function(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0,r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:E1.SUM_BY_NONZERO_WEIGHTS,o=eX(e,"onehotLabels","softmaxCrossEntropy");const s=eX(t,"logits","softmaxCrossEntropy");let i=null;if(null!=n&&(i=eX(n,"weights","softmaxCrossEntropy")),WU(o.shape,s.shape,"Error in softmaxCrossEntropy: "),a>0){const e=EY(a),t=EY(1),n=EY(o.shape[1]);o=vY(IY(o,PY(t,e)),kY(e,n))}const c=function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:-1;if(-1===n&&(n=t.rank-1),n!==t.rank-1)throw Error("Softmax cross entropy along a non-last dimension is not yet "+"supported. Labels / logits was rank ".concat(t.rank," ")+"and dim was ".concat(n));const a=TY(((e,t,a)=>{const r=BZ(t,[n],!0),o=PY(bY(t,"float32"),r);a([e,o]);const s=MZ(IY(o,e));return{value:dZ(s,[n]),gradFunc:(e,t)=>{const[a,r]=t,o=rZ(e.shape,[n]);return[IY(iJ(e,o),PY(bY(a,"float32"),mZ(r))),IY(iJ(e,o),PY(mZ(r),bY(a,"float32")))]}}}));return a(e,t)}(o,s);return R1(c,i,r)}});const z1=aX({sparseFillEmptyRows_:function(e,t,n,a){const r=eX(e,"indices","sparseFillEmptyRows","int32"),o=eX(t,"values","sparseFillEmptyRows"),s=eX(n,"denseShape","sparseFillEmptyRows","int32"),i=eX(a,"defaultValue","sparseFillEmptyRows",o.dtype);if(2!==r.rank)throw new Error("Indices should be Tensor2D but received shape\n        ".concat(r.shape));if(1!==o.rank)throw new Error("Values should be Tensor1D but received shape ".concat(o.shape));if(1!==s.rank)throw new Error("Dense shape should be Tensor1D but received shape ".concat(s.shape));if(0!==i.rank)throw new Error("Default value should be a scalar but received shape ".concat(i.shape));const c={indices:r,values:o,denseShape:s,defaultValue:i},l=jq.runKernel(oK,c);return{outputIndices:l[0],outputValues:l[1],emptyRowIndicator:l[2],reverseIndexMap:l[3]}}});const B1=aX({sparseReshape_:function(e,t,n){const a=eX(e,"inputIndices","sparseReshape","int32"),r=eX(t,"inputShape","sparseReshape","int32"),o=eX(n,"newShape","sparseReshape","int32");if(2!==a.rank)throw new Error("Input indices should be Tensor2D but received shape\n        ".concat(a.shape));if(1!==r.rank)throw new Error("Input shape should be Tensor1D but received shape ".concat(r.shape));if(1!==o.rank)throw new Error("New shape should be Tensor1D but received shape ".concat(o.shape));const s={inputIndices:a,inputShape:r,newShape:o},i=jq.runKernel(sK,s);return{outputIndices:i[0],outputShape:i[1]}}});const W1=aX({sparseSegmentMean_:function(e,t,n){const a=eX(e,"data","sparseSegmentMean"),r=eX(t,"indices","sparseSegmentMean","int32"),o=eX(n,"segmentIds","sparseSegmentMean","int32");if(a.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==r.rank)throw new Error("Indices should be Tensor1D but received shape\n          ".concat(r.shape));if(1!==o.rank)throw new Error("Segment ids should be Tensor1D but received shape\n          ".concat(o.shape));const s={data:a,indices:r,segmentIds:o};return jq.runKernel(iK,s)}});const V1=aX({sparseSegmentSum_:function(e,t,n){const a=eX(e,"data","sparseSegmentSum"),r=eX(t,"indices","sparseSegmentSum","int32"),o=eX(n,"segmentIds","sparseSegmentSum","int32");if(a.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==r.rank)throw new Error("Indices should be Tensor1D but received shape\n         ".concat(r.shape));if(1!==o.rank)throw new Error("Segment ids should be Tensor1D but received shape\n         ".concat(o.shape));const s={data:a,indices:r,segmentIds:o};return jq.runKernel(cK,s)}});const U1=aX({stringNGrams_:function(e,t,n,a,r,o,s,i){const c=eX(e,"data","stringNGrams","string");if("string"!==c.dtype)throw new Error("Data must be of datatype string");if(1!==c.shape.length)throw new Error("Data must be a vector, saw: ".concat(c.shape));const l=eX(t,"dataSplits","stringNGrams");if("int32"!==l.dtype)throw new Error("Data splits must be of datatype int32");const u={separator:n,nGramWidths:a,leftPad:r,rightPad:o,padWidth:s,preserveShortSequences:i},d={data:c,dataSplits:l},h=jq.runKernel(fK,d,u);return{nGrams:h[0],nGramsSplits:h[1]}}});const G1=aX({stringSplit_:function(e,t){let n=!(arguments.length>2&&void 0!==arguments[2])||arguments[2];const a=eX(e,"input","stringSplit","string"),r=eX(t,"delimiter","stringSplit","string");if(1!==a.rank)throw new Error("Input should be Tensor1D but received shape ".concat(a.shape));if(0!==r.rank)throw new Error("Delimiter should be a scalar but received shape ".concat(r.shape));const o={skipEmpty:n},s={input:a,delimiter:r},i=jq.runKernel(mK,s,o);return{indices:i[0],values:i[1],shape:i[2]}}});const H1=aX({stringToHashBucketFast_:function(e,t){const n=eX(e,"input","stringToHashBucketFast","string"),a={numBuckets:t};if(t<=0)throw new Error("Number of buckets must be at least 1");const r={input:n};return jq.runKernel(gK,r,a)}});const j1=aX({staticRegexReplace_:function(e,t,n){let a=!(arguments.length>3&&void 0!==arguments[3])||arguments[3];const r=eX(e,"input","staticRegexReplace","string"),o={pattern:t,rewrite:n,replaceGlobal:a};return jq.runKernel(hK,{x:r},o)}}),K1={fft:e0,ifft:t0,rfft:r0,irfft:n0},q1={hammingWindow:Y0,hannWindow:Q0,frame:J0,stft:Z0},X1={flipLeftRight:e1,grayscaleToRGB:t1,resizeNearestNeighbor:w1,resizeBilinear:v1,rgbToGrayscale:n1,rotateWithOffset:a1,cropAndResize:$0,nonMaxSuppression:o1,nonMaxSuppressionAsync:m1,nonMaxSuppressionWithScore:g1,nonMaxSuppressionWithScoreAsync:b1,nonMaxSuppressionPadded:y1,nonMaxSuppressionPaddedAsync:x1,threshold:k1,transform:I1},Y1={bandPart:S1,gramSchmidt:N1,qr:T1},Q1={absoluteDifference:_1,computeWeightedLoss:R1,cosineDistance:A1,hingeLoss:F1,huberLoss:O1,logLoss:D1,meanSquaredError:M1,sigmoidCrossEntropy:L1,softmaxCrossEntropy:P1},J1={sparseFillEmptyRows:z1,sparseReshape:B1,sparseSegmentMean:W1,sparseSegmentSum:V1},Z1={stringNGrams:U1,stringSplit:G1,stringToHashBucketFast:H1,staticRegexReplace:j1},$1="undefined"!==typeof requestAnimationFrame?requestAnimationFrame:"undefined"!==typeof setImmediate?setImmediate:e=>e();function e2(e,t){const n=e[0].length;e.forEach(((e,t)=>{BU(e.length===n,(()=>"Error in concat".concat(n,"D: rank of tensors[").concat(t,"] must be the same ")+"as the rank of the rest (".concat(n,")")))})),BU(t>=0&&t<n,(()=>"Error in concat".concat(n,"D: axis must be between 0 and ").concat(n-1,".")));const a=e[0];e.forEach(((e,r)=>{for(let o=0;o<n;o++)BU(o===t||e[o]===a[o],(()=>"Error in concat".concat(n,"D: Shape of tensors[").concat(r,"] (").concat(e,") ")+"does not match the shape of the rest (".concat(a,") ")+"along the non-concatenated axis ".concat(r,".")))}))}function t2(e,t){const n=e[0].slice();for(let a=1;a<e.length;a++)n[t]+=e[a][t];return n}var n2;function a2(e,t,n){let a=new Array;if(null==n&&null==t)return a;if(null==t)for(;a.length<e+n.length;)a.push(-1);else a=t.slice();if(null==n)return a;if(e+n.length!==a.length)throw new Error("rt input.shape and shape=".concat(t," are incompatible: rt input.rank = ").concat(e+n.length,", but shape.rank = ").concat(a.length));for(let r=1;r<n.length;++r){const o=n[r],s=a[a.length-n.length+r],i=a[s];if(o>=0)if(i>=0){if(i!==o)throw new Error("rt input.shape and shape=".concat(t," are incompatible: rt input.shape[").concat(r+e,"] = ").concat(o," but shape[").concat(r+e,"] = ").concat(i))}else a[s]=o}return a}function r2(e){const t={FIRST_DIM_SIZE:n2.FIRST_DIM_SIZE,VALUE_ROWIDS:n2.VALUE_ROWIDS,ROW_LENGTHS:n2.ROW_LENGTHS,ROW_SPLITS:n2.ROW_SPLITS,ROW_LIMITS:n2.ROW_LIMITS,ROW_STARTS:n2.ROW_STARTS},n=[];for(const a of e){if(!(a in t))break;n.push(t[a])}return n}function o2(e){return 0===e.length?0:e[0]===n2.FIRST_DIM_SIZE?e.length-1:e.length}function s2(e,t){if(null==e||null==t)return;const n=e.length,a=t.length;if(n>=a)throw new Error("defaultValue.shape=".concat(e," and ragged tensor flatValues.shape=").concat(t,", are incompatible: defaultValue.rank = ").concat(n," must be less than ragged tensor input flatValues.rank = ").concat(a,")"));for(let r=0;r<Math.min(n,a-1);++r){const n=e[r],a=t[r+1];if(n>=0&&a>=0&&1!==n&&n!==a)throw new Error("defaultValue.shape=".concat(e,", and ragged tensor input flatValues.shape=").concat(t," are incompatible: defaultValue.shape[").concat(r-e.length,"] = ").concat(n," but ragged tensor input.flatValues.shape[").concat(r-e.length,"] = ").concat(a))}}!function(e){e[e.FIRST_DIM_SIZE=0]="FIRST_DIM_SIZE",e[e.VALUE_ROWIDS=1]="VALUE_ROWIDS",e[e.ROW_LENGTHS=2]="ROW_LENGTHS",e[e.ROW_SPLITS=3]="ROW_SPLITS",e[e.ROW_LIMITS=4]="ROW_LIMITS",e[e.ROW_STARTS=5]="ROW_STARTS"}(n2||(n2={}));const i2=30;function c2(e){return e<=i2?e:rG(e,Math.floor(Math.sqrt(e)))}function l2(e,t,n){return[n*("number"===typeof e?e:e[0]),t*("number"===typeof e?e:e[1])]}function u2(e,t,n){let a=[];if(!(arguments.length>3&&void 0!==arguments[3])||arguments[3])a=a.concat(t.slice(0)),a.push(e[0]/n),a=a.concat(e.slice(1));else{a=a.concat(e[0]);const n=t.length;for(let r=0;r<n;++r)a=a.concat([e[r+1]/t[r],t[r]]);a=a.concat(e.slice(n+1))}return a}function d2(e,t){const n=[];if(!(arguments.length>2&&void 0!==arguments[2])||arguments[2]){n.push(t);for(let a=t+1;a<e;++a)a<=2*t?(n.push(a),n.push(a-(t+1))):n.push(a)}else{const a=[],r=[];for(let n=1;n<e;++n)n>=2*t+1||n%2===1?r.push(n):a.push(n);n.push(...a),n.push(0),n.push(...r)}return n}function h2(e,t,n){let a=!(arguments.length>3&&void 0!==arguments[3])||arguments[3];const r=[];a?r.push(e[0]/n):r.push(e[0]*n);for(let o=1;o<e.length;++o)o<=t.length?a?r.push(t[o-1]*e[o]):r.push(e[o]/t[o-1]):r.push(e[o]);return r}function p2(e,t){const n=[0];for(let a=0;a<t;++a)n.push(e[a][0]);return n}function f2(e,t,n){const a=e.slice(0,1);for(let r=0;r<n;++r)a.push(e[r+1]-t[r][0]-t[r][1]);return a}function m2(e,t){const n=e.shape.length,a=t.shape.length;if(n<1)throw new Error("tf.gatherND() expects the input to be rank 1 or higher,"+" but the rank was ".concat(n,"."));if(a<1)throw new Error("tf.gatherND() expects the indices to be rank 1 or higher,"+" but the rank was ".concat(a,"."));if("int32"!==t.dtype)throw new Error("tf.gatherND() expects the indices to be int32 type,"+" but the dtype was ".concat(t.dtype,"."));if(t.shape[a-1]>n)throw new Error("index innermost dimension length must be <= tensor rank; saw: "+"".concat(t.shape[a-1]," vs. ").concat(n));if(0===UU(e.shape))throw new Error("Requested more than 0 entries, but input is empty."+" Input shape: ".concat(e.shape,"."));const r=t.shape,o=r[r.length-1];let s=1;for(let d=0;d<r.length-1;++d)s*=r[d];const i=e.shape,c=r.slice();c.pop();let l=1;for(let d=o;d<n;++d)l*=i[d],c.push(i[d]);const u=[...oG(e.shape).map((e=>e/l)),1].slice(0,o);return[c,s,l,u]}const g2=1.7580993408473768,b2=1.0507009873554805,y2=.3275911,x2=.254829592,v2=-.284496736,w2=1.421413741,k2=-1.453152027,I2=1.061405429;function S2(e,t){if(e.length!==t.length)throw new Error("Cannot merge real and imag arrays of different lengths. real:"+"".concat(e.length,", imag: ").concat(t.length,"."));const n=new Float32Array(2*e.length);for(let a=0;a<n.length;a+=2)n[a]=e[a/2],n[a+1]=t[a/2];return n}function N2(e){const t=new Float32Array(e.length/2),n=new Float32Array(e.length/2);for(let a=0;a<e.length;a+=2)t[a/2]=e[a],n[a/2]=e[a+1];return{real:t,imag:n}}function C2(e){const t=Math.ceil(e.length/4),n=new Float32Array(t),a=new Float32Array(t);for(let r=0;r<e.length;r+=4)n[Math.floor(r/4)]=e[r],a[Math.floor(r/4)]=e[r+1];return{real:n,imag:a}}function T2(e){const t=Math.floor(e.length/4),n=new Float32Array(t),a=new Float32Array(t);for(let r=2;r<e.length;r+=4)n[Math.floor(r/4)]=e[r],a[Math.floor(r/4)]=e[r+1];return{real:n,imag:a}}function E2(e,t){return{real:e[2*t],imag:e[2*t+1]}}function R2(e,t,n,a){e[2*a]=t,e[2*a+1]=n}function _2(e,t){const n=new Float32Array(e/2),a=new Float32Array(e/2);for(let r=0;r<Math.ceil(e/2);r++){const o=(t?2:-2)*Math.PI*(r/e);n[r]=Math.cos(o),a[r]=Math.sin(o)}return{real:n,imag:a}}function A2(e,t,n){const a=(n?2:-2)*Math.PI*(e/t);return{real:Math.cos(a),imag:Math.sin(a)}}const F2="->",O2=/->/g,D2=",",M2="...";function L2(e,t){const n=((e=e.replace(/\s/g,"")).length-e.replace(O2,"").length)/F2.length;if(n<1)throw new Error("Equations without an arrow are not supported.");if(n>1)throw new Error('Equation must contain exactly one arrow ("'.concat(F2,'").'));const[a,r]=e.split(F2);BU(-1===a.indexOf(M2),(()=>'The ellipsis notation ("'.concat(M2,'") is not supported yet.')));const o=a.split(D2),s=o.length;if(t!==s)throw new Error("Expected ".concat(s," input tensors, received ").concat(t));if(s>2)throw new Error("Support for more than 2 input tensors is not implemented yet.");const i=[];for(let d=0;d<r.length;++d){const e=r[d];if(!o.some((t=>-1!==t.indexOf(e))))throw new Error("Output subscripts contain the label ".concat(e," ")+"not present in the input subscripts.");-1===i.indexOf(e)&&i.push(e)}for(let d=0;d<a.length;++d){const e=a[d];-1===i.indexOf(e)&&e!==D2&&i.push(e)}const c=new Array(o.length);for(let d=0;d<s;++d){if(new Set(o[d].split("")).size!==o[d].length)throw new Error("Found duplicate axes in input component ".concat(o[d],". ")+"Support for duplicate axes in input is not implemented yet.");c[d]=[];for(let e=0;e<o[d].length;++e)c[d].push(i.indexOf(o[d][e]))}const l=i.length,u=[];for(let d=r.length;d<l;++d)u.push(d);return{allDims:i,summedDims:u,idDims:c}}function P2(e,t){let n=new Array(e);n.fill(-1);for(let r=0;r<t.length;++r)n[t[r]]=r;const a=[];for(let r=0;r<e;++r)-1===n[r]&&a.push(r);return n=n.filter((e=>-1!==e)),{permutationIndices:n,expandDims:a}}function z2(e,t,n){const a=new Array(e);for(let r=0;r<n.length;++r){const e=n[r].shape;for(let n=0;n<t[r].length;++n)void 0===a[t[r][n]]?a[t[r][n]]=e[n]:BU(a[t[r][n]]===e[n],(()=>"Expected dimension ".concat(a[t[r][n]]," at axis ").concat(n," ")+"of input shaped ".concat(JSON.stringify(e),", ")+"but got dimension ".concat(e[n])))}}function B2(e,t){const n=e,a=[];let r=0;0===e.length&&n.push(-1),r=e.length+1;for(let s=0;s<r;++s)a.push([]);const o=[];for(let s=0;s<n.length;++s){const e=V2(t,n[s]);for(const t of e)-1===o.indexOf(t)&&(a[s].push(t),o.push(t))}return{path:n,steps:a}}function W2(e){return e.every(((e,t)=>e===t))}function V2(e,t){const n=[];for(let a=0;a<e.length;++a)0!==e[a].length&&-1===e[a].indexOf(t)&&-1!==t||n.push(a);return n}function U2(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,a=[];if("number"===typeof t)BU(e.shape[n]%t===0,(()=>"Number of splits must evenly divide the axis.")),a=new Array(t).fill(e.shape[n]/t);else{const r=t.reduce(((e,t)=>(-1===t&&(e+=1),e)),0);BU(r<=1,(()=>"There should be only one negative value in split array."));const o=t.indexOf(-1);if(-1!==o){const a=t.reduce(((e,t)=>t>0?e+t:e));t[o]=e.shape[n]-a}BU(e.shape[n]===t.reduce(((e,t)=>e+t)),(()=>"The sum of sizes must match the size of the axis dimension.")),a=t}return a}function G2(e){return"Received SparseTensor with denseShape[0] = 0 but\n  indices.shape[0] = ".concat(e)}function H2(e,t){return"indices(".concat(e,", 0) is invalid: ").concat(t," < 0")}function j2(e,t,n){return"indices(".concat(e,", 0) is invalid: ").concat(t," >= ").concat(n)}function K2(e,t){return"only one output dimension may be -1, not both ".concat(e," and ").concat(t)}function q2(e,t){return"size ".concat(e," must be non-negative, not ").concat(t)}function X2(){return"reshape cannot infer the missing input size for an empty tensor unless all specified input sizes are non-zero"}function Y2(e,t){const n=UU(e),a=UU(t);return"Input to reshape is a SparseTensor with ".concat(n,"\n  dense values, but the requested shape requires a multiple of ").concat(a,". inputShape=").concat(e," outputShape= ").concat(t)}function Q2(e,t){const n=UU(e),a=UU(t);return"Input to reshape is a tensor with ".concat(n," dense values, but the requested shape has ").concat(a,". inputShape=").concat(e," outputShape=").concat(t)}function J2(){return"segment ids must be >= 0"}function Z2(){return"segment ids are not increasing"}function $2(e,t){return"Segment id ".concat(e," out of range [0, ").concat(t,"), possibly because segmentIds input is not sorted.")}function e3(e,t,n){return"Bad: indices[".concat(e,"] == ").concat(t," out of range [0, ").concat(n,")")}function t3(e,t){let n,a=!1;for(e<=i2?(n=e,a=!0):n=rG(e,Math.floor(Math.sqrt(e)));!a;)n>t||n===e?a=!0:n=rG(e,n+1);return n}function n3(e,t,n){const a=[],r=e.length;for(let o=0;o<r;o++)o!==t?a.push(e[o]):a.push(n);return a}function a3(e,t,n,a){const r=t.shape.length,o=e.shape.length;if(0!==a&&(a<-r||a>r))throw new Error("Expect batchDims in the range of [-".concat(r,", ").concat(r,"], but got ").concat(a));if(a<0&&(a+=r),a>o)throw new Error("batchDims (".concat(a,") must be less than rank(x) (\n    ").concat(o,")."));if(n<a)throw new Error("batchDims (".concat(a,") must be less than or equal to axis (").concat(n,")."));for(let d=0;d<a;++d)if(e.shape[d]!==t.shape[d])throw new Error("x.shape[".concat(d,"]: ").concat(e.shape[d]," should be equal to indices.shape[").concat(d,"]: ").concat(t.shape[d],"."));const s=e.shape[n],i=[];let c=1,l=1,u=1;for(let d=0;d<a;++d)i.push(e.shape[d]),c*=e.shape[d];for(let d=a;d<n;d++)i.push(e.shape[d]),l*=e.shape[d];for(let d=a;d<r;d++)i.push(t.shape[d]);for(let d=n+1;d<o;d++)i.push(e.shape[d]),u*=e.shape[d];return{batchSize:c,sliceSize:u,outerSize:l,dimSize:s,outputShape:i}}function r3(e){try{return e.map((e=>iq(e)))}catch(ade){throw new Error("Failed to decode encoded string bytes into utf-8, error: ".concat(ade))}}function o3(e){return e.map((e=>sq(e)))}function s3(e,t){Array.isArray(e)||(e=[e]),e.forEach((e=>{null!=e&&BU("complex64"!==e.dtype,(()=>"".concat(t," does not support complex64 tensors in the CPU backend.")))}))}!function(){for(const e of HY)OY(e)}();const i3=T0;class c3 extends DU{nextDataId(){return c3.nextDataId++}constructor(){super(),this.blockSize=48,this.firstUse=!0,this.data=new OU(this,lX())}write(e,t,n){this.firstUse&&(this.firstUse=!1,yG().get("IS_NODE")&&DK("\n============================\nHi, looks like you are running TensorFlow.js in Node.js. To speed things up dramatically, install our node backend, visit https://github.com/tensorflow/tfjs-node for more details. \n============================"));const a={id:this.nextDataId()};return this.data.set(a,{values:e,dtype:n,refCount:1}),a}makeTensorInfo(e,t,n){let a;if("string"===t&&null!=n&&n.length>0&&tG(n[0])){const r=n.map((e=>sq(e)));a=this.write(r,e,t)}else a=this.write(n,e,t);return{dataId:a,shape:e,dtype:t}}refCount(e){if(this.data.has(e)){return this.data.get(e).refCount}return 0}incRef(e){this.data.get(e).refCount++}decRef(e){if(this.data.has(e)){this.data.get(e).refCount--}}move(e,t,n,a,r){this.data.set(e,{values:t,dtype:a,refCount:r})}numDataIds(){return this.data.numDataIds()}async read(e){return this.readSync(e)}readSync(e){const{dtype:t,complexTensorInfos:n}=this.data.get(e);if("complex64"===t){return S2(this.readSync(n.real.dataId),this.readSync(n.imag.dataId))}return function(e,t){if(Array.isArray(e))return e;if("float32"===t)return e instanceof Float32Array?e:new Float32Array(e);if("int32"===t)return e instanceof Int32Array?e:new Int32Array(e);if("bool"===t||"string"===t)return Uint8Array.from(new Int32Array(e));throw new Error("Unknown dtype ".concat(t))}(this.data.get(e).values,t)}bufferSync(e){const t=this.readSync(e.dataId);if("string"===e.dtype)try{const n=t.map((e=>iq(e)));return gY(e.shape,e.dtype,n)}catch(n){throw new Error("Failed to decode encoded string bytes into utf-8")}return gY(e.shape,e.dtype,t)}makeOutput(e,t,n){return lX().makeTensorFromTensorInfo(this.makeTensorInfo(t,n,e),this)}disposeData(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];if(this.data.has(e)){if(this.data.get(e).refCount--,!t&&this.data.get(e).refCount>0)return!1;const{complexTensorInfos:n}=this.data.get(e);null!=n&&(this.disposeData(n.real.dataId,!0),this.disposeData(n.imag.dataId,!0)),this.data.delete(e)}return!0}disposeIntermediateTensorInfo(e){this.disposeData(e.dataId)}async time(e){const t=oq();e();return{kernelMs:oq()-t}}memory(){return{unreliable:!0,reasons:["The reported memory is an upper bound. Due to automatic garbage collection, the true allocated memory may be less."]}}where(e){s3([e],"where");const t=this.readSync(e.dataId);return i3(e.shape,t)}dispose(){}floatPrecision(){return 32}epsilon(){return super.epsilon()}}function l3(e){return(t,n,a)=>{const r=ZU(n,t.length);for(let o=0;o<t.length;++o)r[o]=e(t[o],a);return r}}function u3(e,t,n){return d3(e,l3(t),n)}function d3(e,t,n){return a=>{let{inputs:r,attrs:o,backend:s}=a;const{x:i}=r;s3(i,e);const c=s,l=c.data.get(i.dataId).values;let u;if("string"===i.dtype){if(!Array.isArray(l))throw new Error("String tensor's value was not an instance of Array");u=r3(l)}else u=l;const d=n||i.dtype,h=t(u,d,o);return c.makeTensorInfo(i.shape,d,h)}}c3.nextDataId=0,pX("cpu",(()=>new c3),1);const h3=u3(wH,(e=>e>=0?e:Math.exp(e)-1)),p3={kernelName:wH,backendName:"cpu",kernelFunc:h3};function f3(e){const{inputs:t,backend:n}=e,{x:a}=t;return n.incRef(a.dataId),{dataId:a.dataId,shape:a.shape,dtype:a.dtype}}const m3={kernelName:zH,backendName:"cpu",kernelFunc:f3};function g3(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{alpha:o}=a;s3([r],"leakyRelu");const s=UU(r.shape),i=n.data.get(r.dataId).values,c=JU("float32",s);for(let l=0;l<i.length;l++)c[l]=i[l]<0?o*i[l]:i[l];return n.makeTensorInfo(r.shape,"float32",c)}const b3={kernelName:HH,backendName:"cpu",kernelFunc:g3};function y3(e){return(t,n,a,r,o)=>{const s=VY(t,n),i=s.length,c=oG(s),l=JU(o,UU(s)),u=t.length,d=n.length,h=oG(t),p=oG(n),f=BY(t,s),m=BY(n,s);if(f.length+m.length===0)for(let g=0;g<l.length;++g)l[g]=e(a[g%a.length],r[g%r.length]);else for(let g=0;g<l.length;++g){const t=pG(g,i,c),n=t.slice(-u);f.forEach((e=>n[e]=0));const o=hG(n,u,h),s=t.slice(-d);m.forEach((e=>s[e]=0));const b=hG(s,d,p);l[g]=e(a[o],r[b])}return[l,s]}}const x3=y3(((e,t)=>e<0?t*e:e));function v3(e){const{inputs:t,backend:n}=e,{x:a,alpha:r}=t;s3([a,r],"prelu");const o=n.data.get(a.dataId).values,s=n.data.get(r.dataId).values,[i,c]=x3(a.shape,r.shape,o,s,"float32");return n.makeTensorInfo(c,"float32",i)}const w3={kernelName:Nj,backendName:"cpu",kernelFunc:v3},k3=u3(Oj,(e=>Math.max(0,e))),I3={kernelName:Oj,backendName:"cpu",kernelFunc:k3},S3=u3(Bj,(e=>Math.min(Math.max(0,e),6))),N3={kernelName:Bj,backendName:"cpu",kernelFunc:S3},C3=l3((e=>1/(1+Math.exp(-e)))),T3=u3(Zj,(e=>1/(1+Math.exp(-e)))),E3={kernelName:Zj,backendName:"cpu",kernelFunc:T3};function R3(e,t,n,a,r){if("linear"===n)return f3({inputs:{x:t},backend:e});if("relu"===n)return k3({inputs:{x:t},backend:e});if("elu"===n)return h3({inputs:{x:t},backend:e});if("relu6"===n)return S3({inputs:{x:t},backend:e});if("prelu"===n)return v3({inputs:{x:t,alpha:a},backend:e});if("leakyrelu"===n)return g3({inputs:{x:t},backend:e,attrs:{alpha:r}});if("sigmoid"===n)return T3({inputs:{x:t},backend:e});throw new Error("Activation ".concat(n," has not been implemented for the CPU backend."))}function _3(e){const{inputs:t,backend:n}=e,{real:a,imag:r}=t,o=n.data.get(a.dataId).values,s=n.data.get(r.dataId).values,i=n.makeTensorInfo(a.shape,"complex64");return n.data.get(i.dataId).complexTensorInfos={real:n.makeTensorInfo(a.shape,"float32",o),imag:n.makeTensorInfo(r.shape,"float32",s)},i}const A3={kernelName:YG,backendName:"cpu",kernelFunc:_3};function F3(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"float32";if("complex64"===n){return _3({inputs:{real:F3(e,t,"float32"),imag:F3(e,t,"float32")},backend:e})}const a=lG(UU(t),n);return e.makeTensorInfo(t,n,a)}function O3(e){const{inputs:t,backend:n}=e,{input:a}=t,r=n.data.get(a.dataId).complexTensorInfos.real,o=n.data.get(r.dataId).values;return n.makeTensorInfo(r.shape,r.dtype,o)}const D3={kernelName:Aj,backendName:"cpu",kernelFunc:O3};function M3(e,t,n,a){if("int32"===a){return[t,"int32",Int32Array.from(e)]}if("bool"===a){const a=rq([0],n),[r,o]=y3(((e,t)=>e!==t?1:0))(t,[],e,a,"bool");return[o,"bool",r]}throw new Error("Error in Cast: failed to cast ".concat(n," to ").concat(a))}function L3(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{dtype:o}=a;if("complex64"===o){if("complex64"===r.dtype)return f3({inputs:{x:r},backend:n});const e=F3(n,r.shape,r.dtype),t=L3({inputs:{x:r},backend:n,attrs:{dtype:"float32"}}),a=_3({inputs:{real:t,imag:e},backend:n});return n.disposeIntermediateTensorInfo(e),n.disposeIntermediateTensorInfo(t),a}if("complex64"===r.dtype){const e=O3({inputs:{input:r},backend:n}),t=L3({inputs:{x:e},backend:n,attrs:{dtype:o}});return n.disposeIntermediateTensorInfo(e),t}if(!$U(r.dtype,o)){const e=f3({inputs:{x:r},backend:n});return{dataId:e.dataId,shape:e.shape,dtype:o}}const s=n.data.get(r.dataId).values,[i,c,l]=M3(s,r.shape,r.dtype,o);return n.makeTensorInfo(i,c,l)}const P3={kernelName:KG,backendName:"cpu",kernelFunc:L3};function z3(e,t,n,a){return null==n?n=>{let{inputs:r,backend:o}=n;const{a:s,b:i}=r,c=o;s3([s,i],e);const l=c.data.get(s.dataId).values,u=c.data.get(i.dataId).values,d="string"===s.dtype?r3(l):l,h="string"===s.dtype?r3(u):u,p=a||s.dtype,[f,m]=t(s.shape,i.shape,d,h,p);return c.makeTensorInfo(m,p,f)}:e=>{let{inputs:r,backend:o}=e;const{a:s,b:i}=r,c=o;if("complex64"===s.dtype||"complex64"===i.dtype){const e=L3({inputs:{x:s},backend:c,attrs:{dtype:"complex64"}}),t=c.data.get(e.dataId),a=t.complexTensorInfos.real,r=t.complexTensorInfos.imag,o=c.data.get(a.dataId).values,l=c.data.get(r.dataId).values,u=L3({inputs:{x:i},backend:c,attrs:{dtype:"complex64"}}),d=c.data.get(u.dataId),h=d.complexTensorInfos.real,p=d.complexTensorInfos.imag,f=c.data.get(h.dataId).values,m=c.data.get(p.dataId).values,[g,b,y]=n(s.shape,i.shape,o,l,f,m),x=c.makeTensorInfo(y,"float32",g),v=c.makeTensorInfo(y,"float32",b),w=_3({inputs:{real:x,imag:v},backend:c});return c.disposeIntermediateTensorInfo(e),c.disposeIntermediateTensorInfo(u),c.disposeIntermediateTensorInfo(x),c.disposeIntermediateTensorInfo(v),w}{const e=c.data.get(s.dataId).values,n=c.data.get(i.dataId).values,r=a||s.dtype,[o,l]=t(s.shape,i.shape,e,n,r);return c.makeTensorInfo(l,r,o)}}}function B3(e){return(t,n,a,r,o,s)=>{const i=VY(t,n),c=UU(i),l=i.length,u=oG(i),d=JU("float32",c),h=JU("float32",c),p=BY(t,i),f=BY(n,i),m=S2(a,r),g=S2(o,s),b=t.length,y=oG(t),x=n.length,v=oG(n);if(p.length+f.length===0)for(let w=0;w<d.length;w++){const t=w%m.length,n=w%g.length,a=e(m[2*t],m[2*t+1],g[2*n],g[2*n+1]);d[w]=a.real,h[w]=a.imag}else for(let w=0;w<d.length;w++){const t=pG(w,l,u),n=t.slice(-b);p.forEach((e=>n[e]=0));const a=hG(n,b,y),r=t.slice(-x);f.forEach((e=>r[e]=0));const o=hG(r,x,v),s=e(m[2*a],m[2*a+1],g[2*o],g[2*o+1]);d[w]=s.real,h[w]=s.imag}return[d,h,i]}}const W3=y3(((e,t)=>e+t)),V3=B3(((e,t,n,a)=>({real:e+n,imag:t+a}))),U3=z3(CG,W3,V3),G3={kernelName:CG,backendName:"cpu",kernelFunc:U3};function H3(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{shape:o}=a,s=UU(r.shape),i=XU(o,s),c=UU(i);BU(s===c,(()=>"The new shape (".concat(i,") has ").concat(c," elements and the old ")+"shape (".concat(r.shape,") has ").concat(s," elements. The new shape and old ")+"shape must have the same number of elements.")),n.incRef(r.dataId);const l=n.data.get(r.dataId);if(null!=l.complexTensorInfos){const e=l.complexTensorInfos.real,t=l.complexTensorInfos.imag;e.shape=i,t.shape=i}return{dataId:r.dataId,shape:i,dtype:r.dtype}}const j3={kernelName:Dj,backendName:"cpu",kernelFunc:H3};function K3(e){const{inputs:t,backend:n,attrs:a}=e,{a:r,b:o}=t,{transposeA:s,transposeB:i}=a;s3([r,o],"matMul");const c=r.shape.length,l=o.shape.length,u=s?r.shape[c-2]:r.shape[c-1],d=i?o.shape[l-1]:o.shape[l-2],h=s?r.shape[c-1]:r.shape[c-2],p=i?o.shape[l-2]:o.shape[l-1],f=r.shape.slice(0,-2),m=o.shape.slice(0,-2),g=UU(f),b=UU(m),y=VY(r.shape.slice(0,-2),o.shape.slice(0,-2)).concat([h,p]);BU(u===d,(()=>"Error in matMul: inner shapes (".concat(u,") and (")+"".concat(d,") of Tensors with shapes ").concat(r.shape," and ")+"".concat(o.shape," and transposeA=").concat(s)+" and transposeB=".concat(i," must match.")));const x=i?[b,p,d]:[b,d,p],v=H3({inputs:{x:r},backend:n,attrs:{shape:s?[g,u,h]:[g,h,u]}}),w=H3({inputs:{x:o},backend:n,attrs:{shape:x}}),k=s?v.shape[1]:v.shape[2],I=s?v.shape[2]:v.shape[1],S=i?w.shape[1]:w.shape[2],N=Math.max(g,b),C=n.data.get(v.dataId).values,T=n.data.get(w.dataId).values,E=oG(v.shape),R=oG(w.shape),[_,A,F]=s?[E[0],1,E[1]]:[E[0],E[1],1],[O,D,M]=i?[1,R[1],R[0]]:[R[1],1,R[0]],L=I*S,P=gY([N,I,S],v.dtype),z=P.values,B=n.blockSize;for(let W=0;W<N;W++){const e=W%g,t=W%b;for(let n=0;n<I;n+=B){const a=Math.min(n+B,I);for(let r=0;r<S;r+=B){const o=Math.min(r+B,S);for(let s=0;s<k;s+=B){const i=Math.min(s+B,k);for(let c=n;c<a;c++)for(let n=r;n<o;n++){let a=0;for(let r=s;r<i;r++){a+=C[e*_+c*A+r*F]*T[r*O+n*D+t*M]}z[W*L+(c*S+n)]+=a}}}}}return n.disposeIntermediateTensorInfo(v),n.disposeIntermediateTensorInfo(w),n.makeTensorInfo(y,P.dtype,P.values)}const q3={kernelName:VG,backendName:"cpu",kernelFunc:K3};const X3={kernelName:AK,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{a:r,b:o,bias:s,preluActivationWeights:i}=t,{transposeA:c,transposeB:l,activation:u,leakyreluAlpha:d}=a;let h,p,f;const m=[];h=K3({inputs:{a:r,b:o},attrs:{transposeA:c,transposeB:l},backend:n}),s&&(p=U3({inputs:{a:h,b:s},backend:n}),m.push(h),h=p),u&&(f=R3(n,h,u,i,d),m.push(h),h=f);for(const g of m)n.disposeIntermediateTensorInfo(g);return h}};function Y3(e){const t=new Float32Array(e.length);for(let n=0;n<e.length;++n)t[n]=Math.abs(e[n]);return t}const Q3={kernelName:IG,backendName:"cpu",kernelFunc:e=>{const{x:t}=e.inputs,n=e.backend;s3(t,"abs");let a=new Float32Array(UU(t.shape));return a=Y3(n.data.get(t.dataId).values),n.makeOutput(a,t.shape,t.dtype)}},J3=u3(SG,(e=>Math.acos(e))),Z3={kernelName:SG,backendName:"cpu",kernelFunc:J3},$3=u3(NG,(e=>Math.acosh(e))),e4={kernelName:NG,backendName:"cpu",kernelFunc:$3};const t4={kernelName:TG,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,a=t;s3(t,"addN");const r=a.map((e=>n.data.get(e.dataId).values)),o=gY(a[0].shape,a[0].dtype),s=o.values;for(let i=0;i<a.length;i++){const e=r[i];for(let t=0;t<s.length;t++)s[t]+=e[t]}return n.makeTensorInfo(o.shape,o.dtype,o.values)}};function n4(e,t,n,a,r){const o=t.length,s=UU(t),i=oG(t),c=oG(r),l=JU(n,UU(r));for(let u=0;u<s;++u){const t=pG(u,o,i),n=new Array(t.length);for(let e=0;e<n.length;e++)n[e]=t[a[e]];l[hG(n,o,c)]=e[u]}return l}function a4(e){const{inputs:t,attrs:n,backend:a}=e,{x:r}=t,{perm:o}=n;s3(r,"transpose");const s=r.shape.length,i=new Array(s);for(let l=0;l<i.length;l++)i[l]=r.shape[o[l]];const c=n4(a.data.get(r.dataId).values,r.shape,r.dtype,o,i);return{dataId:a.write(c,i,r.dtype),shape:i,dtype:r.dtype}}const r4={kernelName:IK,backendName:"cpu",kernelFunc:a4};const o4={kernelName:EG,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{axis:o,keepDims:s}=a;s3(r,"all");const i=YU(o,r.shape);let c=i;const l=sZ(c,r.shape.length);let u=r;null!=l&&(u=a4({inputs:{x:r},backend:n,attrs:{perm:l}}),c=cZ(c.length,r.shape.length)),oZ("all",c,u.shape.length);const[d,h]=aZ(u.shape,c),p=UU(h),f=lG(UU(d),u.dtype),m=n.data.get(u.dataId).values;for(let b=0;b<f.length;++b){const e=b*p;let t=m[e];for(let n=0;n<p;++n){const a=m[e+n];t=t&&a}f[b]=t}null!=l&&n.disposeIntermediateTensorInfo(u);const g=n.makeTensorInfo(d,u.dtype,f);if(s){const e=H3({inputs:{x:g},backend:n,attrs:{shape:rZ(d,i)}});return n.disposeIntermediateTensorInfo(g),e}return g}};const s4={kernelName:RG,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{axis:o,keepDims:s}=a;s3(r,"any");const i=YU(o,r.shape);let c=i;const l=sZ(c,r.shape.length);let u=r;null!=l&&(u=a4({inputs:{x:r},backend:n,attrs:{perm:l}}),c=cZ(c.length,r.shape.length)),oZ("any",c,u.shape.length);const[d,h]=aZ(u.shape,c),p=UU(h),f=lG(UU(d),u.dtype),m=n.data.get(u.dataId).values;for(let b=0;b<f.length;++b){const e=b*p;let t=m[e];for(let n=0;n<p;++n){const a=m[e+n];t=t||a}f[b]=t}null!=l&&n.disposeIntermediateTensorInfo(u);const g=n.makeTensorInfo(d,u.dtype,f);if(s){const e=H3({inputs:{x:g},backend:n,attrs:{shape:rZ(d,i)}});return n.disposeIntermediateTensorInfo(g),e}return g}};const i4={kernelName:_G,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{axis:o}=a;s3(r,"argMax");let s=YU(o,r.shape);const i=sZ(s,r.shape.length);let c=r;const l=[];null!=i&&(c=a4({inputs:{x:r},backend:n,attrs:{perm:i}}),l.push(c),s=cZ(s.length,c.shape.length)),s=[s[0]],oZ("argMax",s,c.shape.length);const[u,d]=aZ(c.shape,s),h=lG(UU(u),"int32"),p=UU(d),f=n.data.get(c.dataId).values;for(let m=0;m<h.length;++m){const e=m*p;let t=f[e],n=0;for(let a=0;a<p;++a){const r=f[e+a];r>t&&(t=r,n=a)}h[m]=n}return l.forEach((e=>n.disposeIntermediateTensorInfo(e))),n.makeTensorInfo(u,"int32",h)}};const c4={kernelName:AG,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{axis:o}=a;s3(r,"argMin");let s=YU(o,r.shape);const i=sZ(s,r.shape.length);let c=r;const l=[];null!=i&&(c=a4({inputs:{x:r},backend:n,attrs:{perm:i}}),l.push(c),s=cZ(s.length,c.shape.length)),s=[s[0]],oZ("argMin",s,c.shape.length);const[u,d]=aZ(c.shape,s),h=lG(UU(u),"int32"),p=UU(d),f=n.data.get(c.dataId).values;for(let m=0;m<h.length;++m){const e=m*p;let t=f[e],n=0;for(let a=0;a<p;++a){const r=f[e+a];r<t&&(t=r,n=a)}h[m]=n}return l.forEach((e=>n.disposeIntermediateTensorInfo(e))),n.makeTensorInfo(u,"int32",h)}},l4=u3(FG,(e=>Math.asin(e))),u4={kernelName:FG,backendName:"cpu",kernelFunc:l4},d4=u3(OG,(e=>Math.asinh(e))),h4={kernelName:OG,backendName:"cpu",kernelFunc:d4},p4=u3(DG,(e=>Math.atan(e))),f4={kernelName:DG,backendName:"cpu",kernelFunc:p4},m4=y3(((e,t)=>Math.atan2(e,t))),g4=z3(LG,m4),b4={kernelName:LG,backendName:"cpu",kernelFunc:g4},y4=u3(MG,(e=>Math.atanh(e))),x4={kernelName:MG,backendName:"cpu",kernelFunc:y4};function v4(e,t,n,a,r,o){const s=r.strideHeight,i=r.strideWidth,c=r.dilationHeight,l=r.dilationWidth,u=r.effectiveFilterHeight,d=r.effectiveFilterWidth,h=r.padInfo.top,p=r.padInfo.left,f="max"===o?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,m=gY(r.outShape,n),g=m.values,b=r.outShape[1]*r.outShape[2]*r.outShape[3],y=r.outShape[2]*r.outShape[3],x=r.outShape[3];for(let v=0;v<r.batchSize;++v){const t=v*b,n=v*a[0];for(let m=0;m<r.inChannels;++m)for(let b=0;b<r.outHeight;++b){const v=b*s-h,w=Math.max(0,v),k=Math.min(r.inHeight,u+v),I=t+b*y;for(let t=0;t<r.outWidth;++t){const s=t*i-p,u=Math.max(0,s),h=Math.min(r.inWidth,d+s);let b=f,y=0,v=0;for(let t=w;t<k;t+=c){const r=n+t*a[1];for(let t=u;t<h;t+=l){const n=e[r+t*a[2]+m];"max"===o&&n>b?b=n:"avg"===o&&(y+=n,v++)}if(isNaN(b))break}g[I+t*x+m]="avg"===o?y/v:b}}}return m}function w4(e,t,n,a){let r=arguments.length>4&&void 0!==arguments[4]&&arguments[4],o=arguments.length>5&&void 0!==arguments[5]&&arguments[5];const s=gY(a.outShape,"int32"),i=a.strideHeight,c=a.strideWidth,l=a.dilationHeight,u=a.dilationWidth,d=a.effectiveFilterHeight,h=a.effectiveFilterWidth,p=a.padInfo.top,f=a.padInfo.left,m=gY(t,n,e);for(let g=0;g<a.batchSize;++g)for(let e=0;e<a.inChannels;++e)for(let t=0;t<a.outHeight;++t){const n=t*i-p;let b=n;for(;b<0;)b+=l;const y=Math.min(a.inHeight,d+n);for(let i=0;i<a.outWidth;++i){const d=i*c-f;let p=d;for(;p<0;)p+=u;const x=Math.min(a.inWidth,h+d);let v=Number.NEGATIVE_INFINITY,w=-1;for(let t=b;t<y;t+=l){const s=t-n;for(let n=p;n<x;n+=u){const i=n-d,c=m.get(g,t,n,e);c>v&&(v=c,w=r?o?((g*a.inHeight+t)*a.inWidth+n)*a.inChannels+e:(t*a.inWidth+n)*a.inChannels+e:s*h+i)}}s.set(w,g,t,i,e)}}return s}function k4(e,t,n,a,r,o){const s=r.strideDepth,i=r.strideHeight,c=r.strideWidth,l=r.dilationDepth,u=r.dilationHeight,d=r.dilationWidth,h=r.effectiveFilterDepth,p=r.effectiveFilterHeight,f=r.effectiveFilterWidth,m=r.padInfo.front,g=r.padInfo.top,b=r.padInfo.left,y="max"===o?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,x=gY(r.outShape,n),v=x.values,w=r.outShape[1]*r.outShape[2]*r.outShape[3]*r.outShape[4],k=r.outShape[2]*r.outShape[3]*r.outShape[4],I=r.outShape[3]*r.outShape[4],S=r.outShape[4];for(let N=0;N<r.batchSize;++N){const t=N*w,n=N*a[0];for(let x=0;x<r.inChannels;++x)for(let w=0;w<r.outDepth;++w){const N=w*s-m;let C=N;for(;C<0;)C+=l;const T=Math.min(r.inDepth,h+N),E=t+w*k;for(let t=0;t<r.outHeight;++t){const s=t*i-g;let h=s;for(;h<0;)h+=u;const m=Math.min(r.inHeight,p+s),w=E+t*I;for(let t=0;t<r.outWidth;++t){const s=t*c-b;let i=s;for(;i<0;)i+=d;const p=Math.min(r.inWidth,f+s),g=w+t*S;let k=y,I=0,N=0;for(let t=C;t<T;t+=l){const r=n+t*a[1];for(let t=h;t<m;t+=u){const n=r+t*a[2];for(let t=i;t<p;t+=d){const r=e[n+t*a[3]+x];if("max"===o&&r>k?k=r:"avg"===o&&(I+=r,N++),isNaN(k))break}if(isNaN(k))break}if(isNaN(k))break}v[g+x]="avg"===o?I/Math.max(N,1):k}}}}return x}const I4={kernelName:PG,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t;s3(r,"avgPool");const{filterSize:o,strides:s,pad:i,dimRoundingMode:c}=a;BU(aJ(s,1),(()=>"Error in avgPool: Either strides or dilations must be 1. "+"Got strides ".concat(s," and dilations '").concat(1,"'")));const l=qQ(r.shape,o,s,1,i,c);let u;if(1===l.filterWidth&&1===l.filterHeight&&GU(l.inShape,l.outShape))u=f3({inputs:{x:r},backend:n});else{const e=n.data.get(r.dataId).values,t=oG(r.shape),a=v4(e,r.shape,r.dtype,t,l,"avg");u=n.makeTensorInfo(l.outShape,r.dtype,a.values)}return u}};const S4={kernelName:BG,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{filterSize:o,strides:s,pad:i,dimRoundingMode:c,dataFormat:l}=a;s3(r,"avgPool3d");const u=XQ(r.shape,o,s,1,i,c,l),d=k4(n.data.get(r.dataId).values,r.shape,r.dtype,oG(r.shape),u,"avg");return n.makeTensorInfo(d.shape,"float32",d.values)}};const N4={kernelName:WG,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{dy:r,input:o}=t,{filterSize:s,strides:i,pad:c,dimRoundingMode:l}=a;s3([r,o],"avgPool3DGrad");const u=XQ(o.shape,s,i,1,c,l),d=u.strideDepth,h=u.strideHeight,p=u.strideWidth,f=u.filterDepth,m=u.filterHeight,g=u.filterWidth,b=u.dilationDepth,y=u.dilationHeight,x=u.dilationWidth,v=u.effectiveFilterDepth,w=u.effectiveFilterHeight,k=u.effectiveFilterWidth,I=v-1-u.padInfo.front,S=k-1-u.padInfo.left,N=w-1-u.padInfo.top,C=gY(o.shape,"float32"),T=1/(f*m*g),E=n.bufferSync(r);for(let R=0;R<u.batchSize;++R)for(let e=0;e<u.inChannels;++e)for(let t=0;t<u.inDepth;++t)for(let n=0;n<u.inHeight;++n)for(let a=0;a<u.inWidth;++a){const r=t-I,o=n-N,s=a-S;let i=0;for(let t=0;t<v;t+=b){const n=(r+t)/d;if(!(n<0||n>=u.outDepth||Math.floor(n)!==n))for(let t=0;t<w;t+=y){const a=(o+t)/h;if(!(a<0||a>=u.outHeight||Math.floor(a)!==a))for(let t=0;t<k;t+=x){const r=(s+t)/p;if(r<0||r>=u.outWidth||Math.floor(r)!==r)continue;i+=E.get(R,n,a,r,e)}}}C.set(i*T,R,t,n,a,e)}return n.makeTensorInfo(C.shape,C.dtype,C.values)}};const C4={kernelName:zG,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{dy:r,input:o}=t,s=o;s3([r,o],"avgPoolGrad");const{filterSize:i,strides:c,pad:l}=a,u=qQ(s.shape,i,c,1,l),d=u.strideHeight,h=u.strideWidth,p=u.filterHeight,f=u.filterWidth,m=u.dilationHeight,g=u.dilationWidth,b=u.effectiveFilterHeight,y=u.effectiveFilterWidth,x=y-1-u.padInfo.left,v=b-1-u.padInfo.top,w=gY(s.shape,"float32"),k=1/(p*f),I=n.data.get(r.dataId).values,S=gY(r.shape,"float32",I);for(let N=0;N<u.batchSize;++N)for(let e=0;e<u.inChannels;++e)for(let t=0;t<u.inHeight;++t)for(let n=0;n<u.inWidth;++n){const a=t-v,r=n-x;let o=0;for(let t=0;t<b;t+=m){const n=(a+t)/d;if(!(n<0||n>=u.outHeight||Math.floor(n)!==n))for(let t=0;t<y;t+=g){const a=(r+t)/h;if(a<0||a>=u.outWidth||Math.floor(a)!==a)continue;o+=S.get(N,n,a,e)}}w.set(o*k,N,t,n,e)}return n.makeTensorInfo(w.shape,w.dtype,w.values)}};const T4={kernelName:OH,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r,scale:o,offset:s,mean:i,variance:c}=t;BU(i.shape.length===c.shape.length,(()=>"Batch normalization gradient requires mean and variance to have equal ranks.")),BU(null==s||i.shape.length===s.shape.length,(()=>"Batch normalization gradient requires mean and offset to have equal ranks.")),BU(null==o||i.shape.length===o.shape.length,(()=>"Batch normalization gradient requires mean and scale to have equal ranks.")),s3([r,i,c,o,s],"batchNorm");let{varianceEpsilon:l}=a;null==l&&(l=.001);const u=n.data.get(r.dataId).values,d=n.data.get(i.dataId).values,h=n.data.get(c.dataId).values,p=o?n.data.get(o.dataId).values:new Float32Array([1]),f=s?n.data.get(s.dataId).values:new Float32Array([0]),m=new Float32Array(u.length),g=f.length,b=p.length,y=h.length,x=d.length;let v=0,w=0,k=0,I=0;for(let S=0;S<u.length;++S)m[S]=f[v++]+(u[S]-d[w++])*p[k++]/Math.sqrt(h[I++]+l),v>=g&&(v=0),w>=x&&(w=0),k>=b&&(k=0),I>=y&&(I=0);return n.makeTensorInfo(r.shape,r.dtype,m)}};function E4(e,t,n,a,r){const o=RQ(a,t,n),s=UU(n),i=oG(a);if(o){const n=_Q(t,i);return"string"===r?e.slice(n,n+s):e.subarray(n,n+s)}const c=gY(a,r,"string"===r?r3(e):e),l=gY(n,r);for(let u=0;u<l.size;++u){const e=l.indexToLoc(u),n=e.map(((e,n)=>e+t[n]));l.set(c.get(...n),...e)}return"string"===r?o3(l.values):l.values}function R4(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{begin:o,size:s}=a;s3(r,"slice");const[i,c]=AQ(r,o,s);bQ(r,i,c);const l=E4(n.data.get(r.dataId).values,i,c,r.shape,r.dtype);return n.makeTensorInfo(c,r.dtype,l)}const _4={kernelName:Xj,backendName:"cpu",kernelFunc:R4};const A4={kernelName:UG,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{blockShape:o,crops:s}=a;s3([r],"batchToSpaceND");const i=o.reduce(((e,t)=>e*t)),c=u2(r.shape,o,i),l=d2(c.length,o.length),u=h2(r.shape,o,i),d=p2(s,o.length),h=f2(u,s,o.length),p=H3({inputs:{x:r},backend:n,attrs:{shape:c}}),f=a4({inputs:{x:p},backend:n,attrs:{perm:l}}),m=H3({inputs:{x:f},backend:n,attrs:{shape:u}}),g=R4({inputs:{x:m},backend:n,attrs:{begin:d,size:h}});return n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),g}};function F4(e,t,n,a,r){const o=UU(a),s=lG(r,n);for(let i=0;i<e.length;i++){const n=e[i];if(n<0)throw new Error("Input x must be non-negative!");n>=r||(s[n]+=o>0?t[i]:1)}return s}function O4(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const r=e.shape[0],o=e.shape[1],s=gY([r,n],t.dtype);for(let i=0;i<r;i++)for(let r=0;r<o;r++){const o=e.get(i,r);if(o<0)throw new Error("Input x must be non-negative!");o>=n||(a?s.set(1,i,o):t.size>0?s.set(s.get(i,o)+t.get(i,r),i,o):s.set(s.get(i,o)+1,i,o))}return s}const D4={kernelName:GG,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r,weights:o}=t,{size:s}=a,i=F4(n.data.get(r.dataId).values,n.data.get(o.dataId).values,o.dtype,o.shape,s);return n.makeTensorInfo([s],o.dtype,i)}},M4=y3(((e,t)=>e&t)),L4=z3(HG,M4),P4={kernelName:HG,backendName:"cpu",kernelFunc:L4};const z4={kernelName:jG,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{s0:a,s1:r}=t,o=n.data.get(a.dataId).values,s=n.data.get(r.dataId).values,i=VY(Array.from(o),Array.from(s));return n.makeTensorInfo([i.length],"int32",Int32Array.from(i))}},B4=l3((e=>Math.ceil(e))),W4=d3(qG,B4),V4={kernelName:qG,backendName:"cpu",kernelFunc:W4},U4=u3(XG,((e,t)=>{const n=t;return e>n.clipValueMax?n.clipValueMax:e<n.clipValueMin?n.clipValueMin:e})),G4={kernelName:XG,backendName:"cpu",kernelFunc:U4},H4={kernelName:QG,backendName:"cpu",kernelFunc:e=>{const{x:t}=e.inputs,n=e.backend,a=new Float32Array(UU(t.shape)),r=n.data.get(t.dataId),o=r.complexTensorInfos.real,s=r.complexTensorInfos.imag,i=n.data.get(o.dataId).values,c=n.data.get(s.dataId).values;for(let l=0;l<i.length;l++){const e=i[l],t=c[l];a[l]=Math.hypot(e,t)}return n.makeOutput(a,t.shape,"float32")}};function j4(e,t,n,a){const r=ZU(n,UU(t));if(a&&"string"!==n){let t=0;e.forEach((e=>{const n=UU(e.shape);r.set(e.vals,t),t+=n}))}else{let a=0;e.forEach((e=>{const o="string"===n?r3(e.vals):e.vals;let s=0;for(let n=0;n<e.shape[0];++n){const i=n*t[1]+a;for(let t=0;t<e.shape[1];++t)r[i+t]=o[s++]}a+=e.shape[1]}))}return r}function K4(e){const{inputs:t,backend:n}=e,{input:a}=t,r=n.data.get(a.dataId).complexTensorInfos.imag,o=n.data.get(r.dataId).values;return n.makeTensorInfo(r.shape,r.dtype,o)}const q4={kernelName:WH,backendName:"cpu",kernelFunc:K4};function X4(e){const{inputs:t,backend:n,attrs:a}=e,{axis:r}=a,o=YU(r,t[0].shape)[0],s=t.map((e=>e.shape));e2(s,o);let i=t2(t.map((e=>e.shape)),o);if(0===UU(i))return n.makeTensorInfo(i,t[0].dtype,[]);const c=t.filter((e=>UU(e.shape)>0));if(1===c.length)return f3({inputs:{x:c[0]},backend:n});if("complex64"===c[0].dtype){const e=c.map((e=>O3({inputs:{input:e},backend:n}))),t=c.map((e=>K4({inputs:{input:e},backend:n}))),a=X4({inputs:e,backend:n,attrs:{axis:o}}),r=X4({inputs:t,backend:n,attrs:{axis:o}}),s=_3({inputs:{real:a,imag:r},backend:n});return e.forEach((e=>n.disposeIntermediateTensorInfo(e))),t.forEach((e=>n.disposeIntermediateTensorInfo(e))),n.disposeIntermediateTensorInfo(a),n.disposeIntermediateTensorInfo(r),s}const l=c.map((e=>{const t=UU(e.shape.slice(o));return H3({inputs:{x:e},backend:n,attrs:{shape:[-1,t]}})})),u=l.map((e=>({vals:n.data.get(e.dataId).values,shape:e.shape})));i=t2(l.map((e=>e.shape)),1);const d=1===l[0].shape[0],h=j4(u,i,t[0].dtype,d),p=t2(c.map((e=>e.shape)),o),f=n.makeTensorInfo(p,t[0].dtype,h);return l.forEach((e=>n.disposeIntermediateTensorInfo(e))),f}const Y4={kernelName:JG,backendName:"cpu",kernelFunc:X4};function Q4(e){const{inputs:t,backend:n,attrs:a}=e,{x:r,filter:o}=t,{strides:s,pad:i,dataFormat:c,dilations:l,dimRoundingMode:u}=a;s3([r,o],"conv2d");const d=oJ(c),h=YQ(r.shape,o.shape,s,l,i,u,!1,d),p=h.filterHeight,f=h.filterWidth,m=h.dilationHeight,g=h.dilationWidth,b=h.padInfo.left,y=h.padInfo.top,x="channelsLast"===h.dataFormat,v=new wq(h.outShape,r.dtype),w=oG(r.shape),k=oG(o.shape),I=w[0],S=x?w[1]:w[2],N=x?w[2]:1,C=x?1:w[1],T=v.strides[0],E=x?v.strides[1]:v.strides[2],R=x?v.strides[2]:1,_=x?1:v.strides[1],A=n.data.get(r.dataId).values,F=n.data.get(o.dataId).values,O=v.values;for(let D=0;D<h.batchSize;++D){const e=D*I,t=D*T;for(let n=0;n<h.outHeight;++n){const a=t+n*E,r=n*h.strideHeight-y;for(let t=0;t<p;++t){const n=r+t*m;if(n<0||n>=h.inHeight)continue;const o=t*k[0],s=e+n*S;for(let e=0;e<h.outWidth;++e){const t=a+e*R,n=e*h.strideWidth-b;for(let e=0;e<f;++e){const a=n+e*g;if(a<0||a>=h.inWidth)continue;const r=s+a*N;let i=o+e*k[1];for(let e=0;e<h.inChannels;++e){const n=A[r+e*C];for(let e=0;e<h.outChannels;++e)O[t+e*_]+=n*F[i+e];i+=h.outChannels}}}}}}return n.makeTensorInfo(v.shape,v.dtype,O)}const J4={kernelName:ZG,backendName:"cpu",kernelFunc:Q4};const Z4={kernelName:$G,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r,dy:o}=t,{strides:s,pad:i,dataFormat:c,dimRoundingMode:l,filterShape:u}=a;s3([r,o],"conv2dBackpropFilter");const d=oJ(c),h=YQ(r.shape,u,s,1,i,l,!1,d),{strideHeight:p,strideWidth:f,filterHeight:m,filterWidth:g}=h,b="channelsLast"===h.dataFormat,y=new wq(h.filterShape,"float32"),x=h.padInfo.left,v=h.padInfo.top,w=n.data.get(r.dataId).values,k=n.data.get(o.dataId).values,I=new wq(r.shape,r.dtype,w),S=new wq(o.shape,o.dtype,k);for(let N=0;N<m;++N){const e=Math.max(0,Math.ceil((v-N)/p)),t=Math.min(h.outHeight,(h.inHeight+v-N)/p);for(let n=0;n<g;++n){const a=Math.max(0,Math.ceil((x-n)/f)),r=Math.min(h.outWidth,(h.inWidth+x-n)/f);for(let o=0;o<h.inChannels;++o)for(let s=0;s<h.outChannels;++s){let i=0;for(let c=0;c<h.batchSize;++c)for(let l=e;l<t;++l){const e=N+l*p-v;for(let t=a;t<r;++t){const a=n+t*f-x;i+=b?I.get(c,e,a,o)*S.get(c,l,t,s):I.get(c,o,e,a)*S.get(c,s,l,t)}}y.set(i,N,n,o,s)}}}return n.makeTensorInfo(y.shape,y.dtype,y.values)}};const $4={kernelName:eH,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{dy:r,filter:o}=t,{inputShape:s,strides:i,pad:c,dataFormat:l,dimRoundingMode:u}=a;s3([r,o],"conv2dBackpropInput");const d=oG(o.shape),h=oG(r.shape);let p=oJ(l);const f=YQ(s,o.shape,i,1,c,u,!1,p),m=new wq(f.inShape,"float32"),g=m.values,b=n.data.get(r.dataId).values,y=n.data.get(o.dataId).values,[x,v,w]=d,{batchSize:k,filterHeight:I,filterWidth:S,inChannels:N,inHeight:C,inWidth:T,outChannels:E,outHeight:R,outWidth:_,strideHeight:A,strideWidth:F}=f;p=f.dataFormat;const O=I-1-f.padInfo.top,D=S-1-f.padInfo.left,M="channelsLast"===p,L=m.strides[0],P=M?m.strides[1]:m.strides[2],z=M?m.strides[2]:1,B=M?1:m.strides[1],W=h[0],V=M?h[1]:h[2],U=M?h[2]:1,G=M?1:h[1];for(let H=0;H<k;++H)for(let e=0;e<N;++e)for(let t=0;t<C;++t){const n=t-O,a=Math.max(0,Math.ceil(n/A)),r=Math.min(R,(I+n)/A);for(let o=0;o<T;++o){const s=o-D,i=Math.max(0,Math.ceil(s/F)),c=Math.min(_,(S+s)/F);let l=0;for(let t=a;t<r;++t){const a=t*A-n;for(let n=i;n<c;++n){const r=W*H+V*t+U*n,o=x*(I-1-a)+v*(S-1-(n*F-s))+w*e;for(let e=0;e<E;++e){l+=b[r+G*e]*y[o+e]}}}g[L*H+P*t+z*o+B*e]=l}}return n.makeTensorInfo(m.shape,m.dtype,m.values)}};const e5={kernelName:tH,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r,filter:o}=t,{strides:s,pad:i,dilations:c}=a;s3([r,o],"conv3d");const l=QQ(r.shape,o.shape,s,c,i),{filterDepth:u,filterHeight:d,filterWidth:h,dilationDepth:p,dilationHeight:f,dilationWidth:m,padInfo:g}=l,b=g.front,y=g.left,x=g.top,v=new wq(l.outShape,r.dtype),w=n.data.get(r.dataId).values,k=n.data.get(o.dataId).values,I=v.values,S=oG(r.shape),N=oG(o.shape);for(let C=0;C<l.batchSize;++C){const e=C*S[0],t=C*v.strides[0];for(let n=0;n<l.outDepth;++n){const a=t+n*v.strides[1],r=n*l.strideDepth-b;for(let t=0;t<u;++t){const n=r+t*p;if(n<0||n>=l.inDepth)continue;const o=t*N[0],s=e+n*S[1];for(let e=0;e<l.outHeight;++e){const t=a+e*v.strides[2],n=e*l.strideHeight-x;for(let e=0;e<d;++e){const a=n+e*f;if(a<0||a>=l.inHeight)continue;const r=o+e*N[1],i=s+a*S[2];for(let e=0;e<l.outWidth;++e){const n=t+e*l.outChannels,a=e*l.strideWidth-y;for(let e=0;e<h;++e){const t=a+e*m;if(t<0||t>=l.inWidth)continue;const o=r+e*N[2],s=i+t*l.inChannels;let c=o;for(let e=0;e<l.inChannels;++e){const t=w[s+e];for(let e=0;e<l.outChannels;++e)I[n+e]+=t*k[c+e];c+=l.outChannels}}}}}}}}return n.makeTensorInfo(v.shape,v.dtype,v.values)}};const t5={kernelName:nH,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r,dy:o}=t,{strides:s,pad:i,filterShape:c}=a;s3([r,o],"conv3dBackpropFilterV2");const l=oG(r.shape),u=oG(o.shape),d=QQ(r.shape,c,s,1,i),h=d.strideDepth,p=d.strideHeight,f=d.strideWidth,m=d.filterDepth,g=d.filterHeight,b=d.filterWidth,y=new wq(d.filterShape,"float32"),x=y.values,[v,w,k,I]=y.strides,S=n.data.get(o.dataId).values,[N,C,T,E]=u,R=n.data.get(r.dataId).values,[_,A,F,O]=l,D=d.padInfo.front,M=d.padInfo.left,L=d.padInfo.top;for(let P=0;P<m;++P){const e=Math.max(0,Math.ceil((D-P)/h)),t=Math.min(d.outDepth,(d.inDepth+D-P)/h),n=P*v;for(let a=0;a<g;++a){const r=Math.max(0,Math.ceil((L-a)/p)),o=Math.min(d.outHeight,(d.inHeight+L-a)/p),s=a*w+n;for(let n=0;n<b;++n){const i=Math.max(0,Math.ceil((M-n)/f)),c=Math.min(d.outWidth,(d.inWidth+M-n)/f),l=n*k+s;for(let s=0;s<d.inChannels;++s){const u=s*I+l;for(let l=0;l<d.outChannels;++l){let m=0;for(let u=0;u<d.batchSize;++u){const d=u*_,g=u*N;for(let u=e;u<t;++u){const e=(P+u*h-D)*A+d,t=u*C+g;for(let u=r;u<o;++u){const r=(a+u*p-L)*F+e,o=u*T+t;for(let e=i;e<c;++e){const t=e*E+o;m+=R[(n+e*f-M)*O+r+s]*S[t+l]}}}}x[u+l]=m}}}}}return n.makeTensorInfo(y.shape,y.dtype,y.values)}};const n5={kernelName:aH,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{dy:r,filter:o}=t,{pad:s,strides:i,inputShape:c}=a;s3([r],"conv3dBackpropInputV2");const l=oG(r.shape),u=oG(o.shape),d=QQ(c,o.shape,i,1,s),h=new wq(d.inShape,"float32"),p=h.values,[f,m,g,b]=h.strides,y=n.data.get(r.dataId).values,[x,v,w,k]=l,I=n.data.get(o.dataId).values,[S,N,C,T]=u,{batchSize:E,filterDepth:R,filterHeight:_,filterWidth:A,inChannels:F,inDepth:O,inHeight:D,inWidth:M,outChannels:L,outDepth:P,outHeight:z,outWidth:B,strideDepth:W,strideHeight:V,strideWidth:U}=d,G=R-1-d.padInfo.front,H=_-1-d.padInfo.top,j=A-1-d.padInfo.left;for(let K=0;K<E;++K)for(let e=0;e<F;++e)for(let t=0;t<O;++t){const n=t-G,a=Math.max(0,Math.ceil(n/W)),r=Math.min(P,(R+n)/W);for(let o=0;o<D;++o){const s=o-H,i=Math.max(0,Math.ceil(s/V)),c=Math.min(z,(_+s)/V);for(let l=0;l<M;++l){const u=l-j,d=Math.max(0,Math.ceil(u/U)),h=Math.min(B,(A+u)/U);let E=0;for(let t=a;t<r;++t){const a=t*W-n;for(let n=i;n<c;++n){const r=n*V-s;for(let o=d;o<h;++o){const s=x*K+v*t+w*n+k*o,i=S*(R-1-a)+N*(_-1-r)+C*(A-1-(o*U-u))+T*e;for(let e=0;e<L;++e){E+=y[s+e]*I[i+e]}}}}p[f*K+m*t+g*o+b*l+e]=E}}}return n.makeTensorInfo(h.shape,h.dtype,h.values)}},a5=u3(rH,(e=>Math.cos(e))),r5={kernelName:rH,backendName:"cpu",kernelFunc:a5},o5=u3(oH,(e=>Math.cosh(e))),s5={kernelName:oH,backendName:"cpu",kernelFunc:o5};const i5={kernelName:cH,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{image:r,boxes:o,boxInd:s}=t,{cropSize:i,method:c,extrapolationValue:l}=a,[u,d,h,p]=r.shape,f=o.shape[0],[m,g]=i,b=gY([f,m,g,p],"float32"),y=n.data.get(o.dataId).values,x=n.data.get(s.dataId).values,v=n.data.get(r.dataId).values,w=oG(r.shape),k=oG(b.shape);for(let I=0;I<f;I++){const e=4*I,t=y[e],n=y[e+1],a=y[e+2],r=y[e+3],o=x[I];if(o>=u)continue;const s=m>1?(a-t)*(d-1)/(m-1):0,i=g>1?(r-n)*(h-1)/(g-1):0;for(let u=0;u<m;u++){const e=m>1?t*(d-1)+u*s:.5*(t+a)*(d-1);if(e<0||e>d-1)for(let t=0;t<g;t++)for(let e=0;e<p;e++){const n=e+t*k[2]+u*k[1]+I*k[0];b.values[n]=l}else if("bilinear"===c){const t=Math.floor(e),a=Math.ceil(e),s=e-t;for(let e=0;e<g;e++){const c=g>1?n*(h-1)+e*i:.5*(n+r)*(h-1);if(c<0||c>h-1){for(let t=0;t<p;t++){const n=t+e*k[2]+u*k[1]+I*k[0];b.values[n]=l}continue}const d=Math.floor(c),f=Math.ceil(c),m=c-d;for(let n=0;n<p;n++){let r=n+d*w[2]+t*w[1]+o*w[0];const i=v[r];r=n+f*w[2]+t*w[1]+o*w[0];const c=v[r];r=n+d*w[2]+a*w[1]+o*w[0];const l=v[r];r=n+f*w[2]+a*w[1]+o*w[0];const h=i+(c-i)*m,p=l+(v[r]-l)*m;r=n+e*k[2]+u*k[1]+I*k[0],b.values[r]=h+(p-h)*s}}}else for(let t=0;t<g;++t){const a=g>1?n*(h-1)+t*i:.5*(n+r)*(h-1);if(a<0||a>h-1){for(let e=0;e<p;e++){const n=e+t*k[2]+u*k[1]+I*k[0];b.values[n]=l}continue}const s=Math.round(a),c=Math.round(e);for(let e=0;e<p;e++){const n=e+s*w[2]+c*w[1]+o*w[0],a=e+t*k[2]+u*k[1]+I*k[0];b.values[a]=v[n]}}}}return n.makeTensorInfo(b.shape,b.dtype,b.values)}};const c5={kernelName:sH,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{axis:o,exclusive:s,reverse:i}=a;s3(r,"cumprod");const c=sZ([o],r.shape.length);let l=r;null!=c&&(l=a4({inputs:{x:r},backend:n,attrs:{perm:c}}));const u=cZ(1,r.shape.length)[0];if(u!==l.shape.length-1)throw new Error("backend.cumprod in CPU expects an inner-most "+"axis=".concat(l.shape.length-1," but got axis=").concat(u));const d=Dq(l.dtype,"int32"),h=cG(UU(l.shape),d),p=n.data.get(l.dataId).values,f=l.shape[l.shape.length-1],m=i?(e,t)=>e+f-t-1:(e,t)=>e+t;for(let b=0;b<p.length;b+=f)for(let e=0;e<f;e++){const t=m(b,e);if(0===e)h[t]=s?1:p[t];else{const n=m(b,e-1);h[t]=s?p[n]*h[n]:p[t]*h[n]}}const g=n.makeTensorInfo(l.shape,d,h);if(null!=c){const e=a4({inputs:{x:g},backend:n,attrs:{perm:iZ(c)}});return n.disposeIntermediateTensorInfo(g),n.disposeIntermediateTensorInfo(l),e}return g}};const l5={kernelName:iH,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{axis:o,exclusive:s,reverse:i}=a;s3(r,"cumsum");const c=sZ([o],r.shape.length);let l=r;null!=c&&(l=a4({inputs:{x:r},backend:n,attrs:{perm:c}}));const u=cZ(1,r.shape.length)[0];if(u!==l.shape.length-1)throw new Error("backend.cumsum in CPU expects an inner-most "+"axis=".concat(l.shape.length-1," but got axis=").concat(u));const d=Dq(l.dtype,"int32"),h=lG(UU(l.shape),d),p=n.data.get(l.dataId).values,f=l.shape[l.shape.length-1],m=i?(e,t)=>e+f-t-1:(e,t)=>e+t;for(let b=0;b<p.length;b+=f)for(let e=0;e<f;e++){const t=m(b,e);if(0===e)h[t]=s?0:p[t];else{const n=m(b,e-1);h[t]=s?p[n]+h[n]:p[t]+h[n]}}const g=n.makeTensorInfo(l.shape,d,h);if(null!=c){const e=a4({inputs:{x:g},backend:n,attrs:{perm:iZ(c)}});return n.disposeIntermediateTensorInfo(g),n.disposeIntermediateTensorInfo(l),e}return g}};const u5={kernelName:lH,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r,weights:o}=t,{size:s,binaryOutput:i}=a;if(1===r.shape.length){const e=F4(n.data.get(r.dataId).values,n.data.get(o.dataId).values,o.dtype,o.shape,s);return n.makeTensorInfo([s],o.dtype,e)}if(2===r.shape.length){const e=O4(n.bufferSync(r),n.bufferSync(o),s,i);return n.makeTensorInfo(e.shape,o.dtype,e.values)}throw new Error("Error in denseBincount: input must be at most rank 2, but got rank"+"".concat(r.shape.length,"."))}};const d5={kernelName:uH,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{blockSize:o,dataFormat:s}=a;BU("NHWC"===s,(()=>"Only NHWC dataFormat supported on CPU for depthToSpace. Got ".concat(s)));const i=r.shape[0],c=r.shape[1],l=r.shape[2],u=r.shape[3],d=c*o,h=l*o,p=u/(o*o),f=n.data.get(r.dataId).values,m=new Float32Array(i*d*h*p);let g=0;for(let b=0;b<i;++b)for(let e=0;e<d;++e){const t=Math.floor(e/o),n=e%o;for(let e=0;e<h;++e){const a=Math.floor(e/o),r=(n*o+e%o)*p;for(let e=0;e<p;++e){const n=e+r+u*(a+l*(t+c*b));m[g++]=f[n]}}}return n.makeTensorInfo([i,d,h,p],r.dtype,m)}};function h5(e){const{inputs:t,backend:n,attrs:a}=e,{x:r,filter:o}=t,{strides:s,pad:i,dilations:c,dimRoundingMode:l}=a;s3([r,o],"depthwiseConv2DNative");const u=oG(r.shape),d=oG(o.shape);let h=c;null==h&&(h=[1,1]),BU(aJ(s,h),(()=>"Error in depthwiseConv2d: Either strides or dilations must be "+"1. Got strides ".concat(s," and dilations '").concat(h,"'")));const p=YQ(r.shape,o.shape,s,h,i,l,!0),{filterHeight:f,filterWidth:m,dilationHeight:g,dilationWidth:b,padInfo:y}=p,x=y.left,v=y.top,w=p.outChannels/p.inChannels,k=new wq(p.outShape,r.dtype),I=n.data.get(r.dataId).values,S=n.data.get(o.dataId).values,N=k.values;for(let C=0;C<p.batchSize;++C){const e=C*u[0],t=C*k.strides[0];for(let n=0;n<p.outHeight;++n){const a=t+n*k.strides[1],r=n*p.strideHeight-v;for(let t=0;t<f;++t){const n=r+t*g;if(n<0||n>=p.inHeight)continue;const o=t*d[0],s=e+n*u[1];for(let e=0;e<p.outWidth;++e){const t=a+e*k.strides[2],n=e*p.strideWidth-x;for(let e=0;e<m;++e){const a=n+e*b;if(a<0||a>=p.inWidth)continue;const r=o+e*d[1],i=s+a*p.inChannels;let c=t,l=r;for(let e=0;e<p.inChannels;++e){const t=I[i+e];for(let e=0;e<w;++e)N[c+e]+=t*S[l+e];c+=w,l+=w}}}}}}return n.makeTensorInfo(k.shape,k.dtype,k.values)}const p5={kernelName:dH,backendName:"cpu",kernelFunc:h5};const f5={kernelName:hH,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r,dy:o}=t,{strides:s,dilations:i,pad:c,dimRoundingMode:l,filterShape:u}=a;s3([r,o],"depthwiseConv2dNativeBackpropFilter");const d=YQ(r.shape,u,s,i,c,l,!0),{strideHeight:h,strideWidth:p,filterHeight:f,filterWidth:m}=d,g=new wq(d.filterShape,"float32"),b=d.padInfo.left,y=d.padInfo.top,x=d.outChannels/d.inChannels,v=n.data.get(r.dataId).values,w=new wq(r.shape,r.dtype,v),k=n.data.get(o.dataId).values,I=new wq(o.shape,o.dtype,k);for(let S=0;S<f;++S){const e=Math.max(0,Math.ceil((y-S)/h)),t=Math.min(d.outHeight,(d.inHeight+y-S)/h);for(let n=0;n<m;++n){const a=Math.max(0,Math.ceil((b-n)/p)),r=Math.min(d.outWidth,(d.inWidth+b-n)/p);for(let o=0;o<d.outChannels;++o){const s=Math.trunc(o/x),i=o%x;let c=0;for(let l=0;l<d.batchSize;++l)for(let i=e;i<t;++i){const e=S+i*h-y;for(let t=a;t<r;++t){const a=n+t*p-b;c+=w.get(l,e,a,s)*I.get(l,i,t,o)}}g.set(c,S,n,s,i)}}}return n.makeTensorInfo(g.shape,g.dtype,g.values)}};const m5={kernelName:pH,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{dy:r,filter:o}=t,{strides:s,dilations:i,pad:c,dimRoundingMode:l,inputShape:u}=a;s3([r,o],"depthwiseConv2DNativeBackpropInput");const d=oG(r.shape),h=oG(o.shape),p=YQ(u,o.shape,s,i,c,l,!0),f=new wq(p.inShape,"float32"),m=f.values,[g,b,y]=f.strides,x=n.data.get(r.dataId).values,[v,w,k]=d,I=n.data.get(o.dataId).values,[S,N,C]=h,{batchSize:T,filterHeight:E,filterWidth:R,inChannels:_,inHeight:A,inWidth:F,outChannels:O,outHeight:D,outWidth:M,strideHeight:L,strideWidth:P}=p,z=E-1-p.padInfo.top,B=R-1-p.padInfo.left,W=O/_;for(let V=0;V<T;++V)for(let e=0;e<_;++e)for(let t=0;t<A;++t){const n=t-z,a=Math.max(0,Math.ceil(n/L)),r=Math.min(D,(E+n)/L);for(let o=0;o<F;++o){const s=o-B,i=Math.max(0,Math.ceil(s/P)),c=Math.min(M,(R+s)/P);let l=0;for(let t=a;t<r;++t){const a=t*L-n;for(let n=i;n<c;++n){const r=v*V+w*t+k*n,o=S*(E-1-a)+N*(R-1-(n*P-s))+C*e;for(let t=0;t<W;++t){l+=x[r+(e*W+t)]*I[o+t]}}}m[g*V+b*t+y*o+e]=l}}return n.makeTensorInfo(f.shape,f.dtype,f.values)}};const g5={kernelName:fH,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{x:a}=t,r=UU(a.shape),o=n.data.get(a.dataId).values,s=gY([r,r],a.dtype),i=s.values;for(let l=0;l<o.length;l++)i[l*r+l]=o[l];const c=[...a.shape,...a.shape];return n.makeTensorInfo(c,s.dtype,s.values)}},b5={kernelName:mH,backendName:"cpu",kernelFunc:e=>{let{inputs:t,backend:n,attrs:a}=e;const{x:r,filter:o}=t,{strides:s,pad:i,dilations:c}=a,l=n,u=l.data.get(r.dataId).values,d=r.shape.length,h=l.data.get(o.dataId).values,p=o.shape.length,{batchSize:f,inHeight:m,inWidth:g,inChannels:b,outHeight:y,outWidth:x,padInfo:v,strideHeight:w,strideWidth:k,filterHeight:I,filterWidth:S,dilationHeight:N,dilationWidth:C,outShape:T}=KQ(r.shape,o.shape,s,i,"NHWC",c),E=UU(T),R=T.length,_=ZU(r.dtype,E);for(let A=0;A<f;++A)for(let e=0;e<y;++e){const t=e*w-v.top;for(let n=0;n<x;++n){const a=n*k-v.left;for(let s=0;s<b;++s){let i=Number.MIN_SAFE_INTEGER;for(let e=0;e<I;++e){const n=t+e*N;if(n>=0&&n<m)for(let t=0;t<S;++t){const c=a+t*C;if(c>=0&&c<g){const a=hG([A,n,c,s],d,oG(r.shape)),l=hG([e,t,s],p,oG(o.shape)),f=u[a]+h[l];f>i&&(i=f)}}}_[hG([A,e,n,s],R,oG(T))]=i}}}return{dataId:l.write(rq(_,r.dtype),T,r.dtype),shape:T,dtype:r.dtype}}},y5={kernelName:bH,backendName:"cpu",kernelFunc:e=>{let{inputs:t,backend:n,attrs:a}=e;const{x:r,filter:o,dy:s}=t,{strides:i,pad:c,dilations:l}=a,u=n,d=iG(r.shape,u.data.get(r.dataId).values),h=iG(o.shape,u.data.get(o.dataId).values),{batchSize:p,inHeight:f,inWidth:m,inChannels:g,outHeight:b,outWidth:y,padInfo:x,strideHeight:v,strideWidth:w,filterHeight:k,filterWidth:I,dilationHeight:S,dilationWidth:N,outShape:C}=KQ(r.shape,o.shape,i,c,"NHWC",l);BU(s.rank===C.length,(()=>"Error in ".concat(bH,", dy ")+"must have the same rank as output ".concat(C.length,", but got ")+"".concat(s.rank)));const T=iG(C,u.data.get(s.dataId).values),E=uG(o.shape,o.dtype);for(let R=0;R<p;++R)for(let e=0;e<b;++e){const t=e*v-x.top;for(let n=0;n<y;++n){const a=n*w-x.left;for(let r=0;r<g;++r){let o=Number.MIN_SAFE_INTEGER,s=0,i=0;for(let e=0;e<k;++e){const n=t+e*S;if(n>=0&&n<f)for(let t=0;t<I;++t){const c=a+t*N;if(c>=0&&c<m){const a=d[R][n][c][r]+h[e][t][r];a>o&&(o=a,s=e,i=t)}}}E[s][i][r]+=T[R][e][n][r]}}}return{dataId:u.write(rq(E,r.dtype),o.shape,o.dtype),shape:o.shape,dtype:o.dtype}}},x5={kernelName:gH,backendName:"cpu",kernelFunc:e=>{let{inputs:t,backend:n,attrs:a}=e;const{x:r,filter:o,dy:s}=t,{strides:i,pad:c,dilations:l}=a,u=n,d=iG(r.shape,u.data.get(r.dataId).values),h=iG(o.shape,u.data.get(o.dataId).values),{batchSize:p,inHeight:f,inWidth:m,inChannels:g,outHeight:b,outWidth:y,padInfo:x,strideHeight:v,strideWidth:w,filterHeight:k,filterWidth:I,dilationHeight:S,dilationWidth:N,outShape:C}=KQ(r.shape,o.shape,i,c,"NHWC",l);BU(s.rank===C.length,(()=>"Error in ".concat(gH,", dy ")+"must have the same rank as output ".concat(C.length,", but got ")+"".concat(s.rank)));const T=iG(C,u.data.get(s.dataId).values),E=uG(r.shape,r.dtype);for(let R=0;R<p;++R)for(let e=0;e<b;++e){const t=e*v-x.top;for(let n=0;n<y;++n){const a=n*w-x.left;for(let r=0;r<g;++r){let o=Number.MIN_SAFE_INTEGER,s=t<0?0:t,i=a<0?0:a;for(let e=0;e<k;++e){const n=t+e*S;if(n>=0&&n<f)for(let t=0;t<I;++t){const c=a+t*N;if(c>=0&&c<m){const a=d[R][n][c][r]+h[e][t][r];a>o&&(o=a,s=n,i=c)}}}E[R][s][i][r]+=T[R][e][n][r]}}}return{dataId:u.write(rq(E,r.dtype),r.shape,r.dtype),shape:r.shape,dtype:r.dtype}}};const v5={kernelName:yH,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{image:r}=t,{canvas:o,options:s}=a,{contextOptions:i,imageOptions:c}=s||{},l=(null===c||void 0===c?void 0:c.alpha)||1,u=(null===i||void 0===i?void 0:i.contextType)||"2d";if("2d"!==u)throw new Error("Context type ".concat(i.contextType," is not supported by the CPU backend."));const d=o.getContext(u,(null===i||void 0===i?void 0:i.contextAttributes)||{});if(null==d)throw new Error("Could not get the context with ".concat(u," type."));const[h,p]=r.shape.slice(0,2),f=2===r.shape.length?1:r.shape[2],m=n.data.get(r.dataId).values,g="float32"===r.dtype?255:1,b=new Uint8ClampedArray(p*h*4);for(let x=0;x<h*p;++x){const e=[0,0,0,255*l];for(let n=0;n<f;n++){const t=m[x*f+n];if("float32"===r.dtype){if(t<0||t>1)throw new Error("Tensor values for a float32 Tensor must be in the "+"range [0 - 1] but encountered ".concat(t,"."))}else if("int32"===r.dtype&&(t<0||t>255))throw new Error("Tensor values for a int32 Tensor must be in the "+"range [0 - 255] but encountered ".concat(t,"."));1===f?(e[0]=t*g,e[1]=t*g,e[2]=t*g):e[n]=t*g}const t=4*x;b[t+0]=Math.round(e[0]),b[t+1]=Math.round(e[1]),b[t+2]=Math.round(e[2]),b[t+3]=Math.round(e[3])}o.width=p,o.height=h;const y=new ImageData(b,p,h);return d.putImageData(y,0,0),r}},w5=y3(((e,t)=>e*t)),k5=B3(((e,t,n,a)=>({real:e*n-t*a,imag:e*a+t*n}))),I5=z3(fj,w5,k5),S5={kernelName:fj,backendName:"cpu",kernelFunc:I5};function N5(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{axis:o,keepDims:s}=a;let i;s3(r,"sum"),i="bool"===r.dtype?L3({inputs:{x:r},backend:n,attrs:{dtype:"int32"}}):f3({inputs:{x:r},backend:n});const c=i.shape.length,l=YU(o,i.shape),u=sZ(l,c);let d=l,h=i;null!=u&&(h=a4({inputs:{x:i},backend:n,attrs:{perm:u}}),d=cZ(d.length,c)),oZ("sum",d,h.shape.length);const[p,f]=aZ(h.shape,d);let m=F3(n,p,Dq(h.dtype,"int32"));const g=UU(f),b=n.data.get(m.dataId).values,y=n.data.get(h.dataId).values;for(let x=0;x<b.length;++x){const e=x*g;let t=0;for(let n=0;n<g;++n)t+=y[e+n];b[x]=t}if(s){const e=m;m=H3({inputs:{x:m},backend:n,attrs:{shape:rZ(m.shape,l)}}),n.disposeIntermediateTensorInfo(e)}return n.disposeIntermediateTensorInfo(i),null!=u&&n.disposeIntermediateTensorInfo(h),m}const C5={kernelName:tK,backendName:"cpu",kernelFunc:N5};const T5={kernelName:vH,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{equation:r}=a,o=t,{allDims:s,summedDims:i,idDims:c}=L2(r,o.length);z2(s.length,c,o);const{path:l,steps:u}=B2(i,c),d=u.length;let h=null,p=s.length;const f=[];for(let m=0;m<d;++m){for(const e of u[m]){const{permutationIndices:t,expandDims:a}=P2(p,c[e]);let r;W2(t)?r=o[e]:(r=a4({inputs:{x:o[e]},backend:n,attrs:{perm:t}}),f.push(r));const s=r.shape.slice();for(let e=0;e<a.length;++e)s.splice(a[e],0,1);GU(r.shape,s)||(r=H3({inputs:{x:r},backend:n,attrs:{shape:s}}),f.push(r)),null===h?h=r:(h=I5({inputs:{a:r,b:h},backend:n}),f.push(h))}m<d-1&&(l[m]>=0&&(h=N5({inputs:{x:h},backend:n,attrs:{axis:l[m]-(s.length-p),keepDims:!1}}),f.push(h)),p--)}for(const m of f)m!==h&&n.disposeIntermediateTensorInfo(m);return h}};const E5={kernelName:kH,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{dy:a,y:r}=t;s3([a,r],"eluGrad");const o=new Float32Array(UU(r.shape)),s=n.data.get(r.dataId).values,i=n.data.get(a.dataId).values;for(let c=0;c<s.length;++c){const e=s[c];o[c]=e>=0?i[c]:i[c]*(e+1)}return n.makeTensorInfo(r.shape,"float32",o)}},R5=y3(((e,t)=>e===t?1:0)),_5=z3(SH,R5,null,"bool"),A5={kernelName:SH,backendName:"cpu",kernelFunc:_5},F5=y2,O5=x2,D5=v2,M5=w2,L5=k2,P5=I2,z5=u3(IH,(e=>{const t=Math.sign(e),n=Math.abs(e),a=1/(1+F5*n);return t*(1-((((P5*a+L5)*a+M5)*a+D5)*a+O5)*a*Math.exp(-n*n))})),B5={kernelName:IH,backendName:"cpu",kernelFunc:z5},W5=l3((e=>Math.exp(e))),V5=d3(NH,W5,"float32"),U5={kernelName:NH,backendName:"cpu",kernelFunc:V5};function G5(e){const{inputs:t,backend:n,attrs:a}=e,{input:r}=t,{dim:o}=a,s=r.shape.length,i=r.shape.slice();let c=o;return o<0&&(BU(-(s+1)<=o,(()=>"Axis must be in the interval [".concat(-(s+1),", ").concat(s,"]"))),c=s+o+1),i.splice(c,0,1),H3({inputs:{x:r},backend:n,attrs:{shape:i}})}const H5={kernelName:CH,backendName:"cpu",kernelFunc:G5},j5=l3((e=>Math.expm1(e))),K5=d3(TH,j5),q5={kernelName:TH,backendName:"cpu",kernelFunc:K5},X5=y3(((e,t)=>e/t)),Y5=z3(xH,X5),Q5={kernelName:xH,backendName:"cpu",kernelFunc:Y5},J5=y3(((e,t)=>e-t)),Z5=B3(((e,t,n,a)=>({real:e-n,imag:t-a}))),$5=z3(bK,J5,Z5),e6={kernelName:bK,backendName:"cpu",kernelFunc:$5};function t6(e,t,n){const a=e.shape,r=a[0],o=a[1],s=n.data.get(e.dataId),i=s.complexTensorInfos.real,c=s.complexTensorInfos.imag,l=[r,o],u=UU(l),d=JU("float32",u),h=JU("float32",u);for(let g=0;g<r;g++){const e=R4({inputs:{x:i},backend:n,attrs:{begin:[g,0],size:[1,o]}}),a=R4({inputs:{x:c},backend:n,attrs:{begin:[g,0],size:[1,o]}}),r=_3({inputs:{real:e,imag:a},backend:n}),{real:s,imag:l}=n6(r,t,n),u=S2(s,l);for(let t=0;t<o;t++){const e=E2(u,t);d[g*o+t]=e.real,h[g*o+t]=e.imag}n.disposeIntermediateTensorInfo(e),n.disposeIntermediateTensorInfo(a),n.disposeIntermediateTensorInfo(r)}const p=n.makeTensorInfo(l,"float32",d),f=n.makeTensorInfo(l,"float32",h),m=_3({inputs:{real:p,imag:f},backend:n});return n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(f),m}function n6(e,t,n){const a=UU(e.shape),r=n.data.get(e.dataId),o=n.data.get(r.complexTensorInfos.real.dataId).values,s=n.data.get(r.complexTensorInfos.imag.dataId).values;if(0===((i=a)&i-1)){const r=a6(o,s,a,t,n),i=[e.shape[0],e.shape[1]];if(t){const e=n.makeTensorInfo(i,"float32",r.real),t=n.makeTensorInfo(i,"float32",r.imag),o=n.makeTensorInfo([],"float32",aq(a,"float32")),s=f3({inputs:{x:o},backend:n}),c=Q5.kernelFunc({inputs:{a:e,b:o},backend:n}),l=Q5.kernelFunc({inputs:{a:t,b:s},backend:n}),u=n.data.get(c.dataId).values,d=n.data.get(l.dataId).values;return n.disposeIntermediateTensorInfo(e),n.disposeIntermediateTensorInfo(t),n.disposeIntermediateTensorInfo(o),n.disposeIntermediateTensorInfo(s),n.disposeIntermediateTensorInfo(c),n.disposeIntermediateTensorInfo(l),{real:u,imag:d}}return r}{const e=function(e,t,n){const a=new Float32Array(2*t);for(let r=0;r<t;r++){let o=0,s=0;for(let a=0;a<t;a++){const i=A2(r*a,t,n),c=E2(e,a);o+=c.real*i.real-c.imag*i.imag,s+=c.real*i.imag+c.imag*i.real}n&&(o/=t,s/=t),R2(a,o,s,r)}return a}(S2(o,s),a,t);return N2(e)}var i}function a6(e,t,n,a,r){if(1===n)return{real:e,imag:t};const o=S2(e,t),s=n/2,i=C2(o),c=i.real,l=i.imag,u=[c.length],d=r.makeTensorInfo(u,"float32",c),h=r.makeTensorInfo(u,"float32",l),p=_3({inputs:{real:d,imag:h},backend:r}),f=T2(o),m=f.real,g=f.imag,b=[m.length],y=r.makeTensorInfo(b,"float32",m),x=r.makeTensorInfo(b,"float32",g),v=_3({inputs:{real:y,imag:x},backend:r}),w=a6(c,l,s,a,r),k=w.real,I=w.imag,S=[k.length],N=r.makeTensorInfo(S,"float32",k),C=r.makeTensorInfo(S,"float32",I),T=_3({inputs:{real:N,imag:C},backend:r}),E=a6(m,g,s,a,r),R=E.real,_=E.imag,A=[R.length],F=r.makeTensorInfo(A,"float32",R),O=r.makeTensorInfo(A,"float32",_),D=_3({inputs:{real:F,imag:O},backend:r}),M=_2(n,a),L=[M.real.length],P=r.makeTensorInfo(L,"float32",M.real),z=r.makeTensorInfo(L,"float32",M.imag),B=_3({inputs:{real:P,imag:z},backend:r}),W=I5({inputs:{a:B,b:D},backend:r}),V=U3({inputs:{a:T,b:W},backend:r}),U=$5({inputs:{a:T,b:W},backend:r}),G=O3({inputs:{input:V},backend:r}),H=O3({inputs:{input:U},backend:r}),j=K4({inputs:{input:V},backend:r}),K=K4({inputs:{input:U},backend:r}),q=X4({inputs:[G,H],backend:r,attrs:{axis:0}}),X=X4({inputs:[j,K],backend:r,attrs:{axis:0}}),Y=r.data.get(q.dataId).values,Q=r.data.get(X.dataId).values;return r.disposeIntermediateTensorInfo(d),r.disposeIntermediateTensorInfo(h),r.disposeIntermediateTensorInfo(p),r.disposeIntermediateTensorInfo(y),r.disposeIntermediateTensorInfo(x),r.disposeIntermediateTensorInfo(v),r.disposeIntermediateTensorInfo(N),r.disposeIntermediateTensorInfo(C),r.disposeIntermediateTensorInfo(T),r.disposeIntermediateTensorInfo(F),r.disposeIntermediateTensorInfo(O),r.disposeIntermediateTensorInfo(D),r.disposeIntermediateTensorInfo(P),r.disposeIntermediateTensorInfo(z),r.disposeIntermediateTensorInfo(B),r.disposeIntermediateTensorInfo(W),r.disposeIntermediateTensorInfo(V),r.disposeIntermediateTensorInfo(U),r.disposeIntermediateTensorInfo(G),r.disposeIntermediateTensorInfo(j),r.disposeIntermediateTensorInfo(H),r.disposeIntermediateTensorInfo(K),r.disposeIntermediateTensorInfo(q),r.disposeIntermediateTensorInfo(X),{real:Y,imag:Q}}const r6={kernelName:EH,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{input:a}=t,r=UU(a.shape),o=a.shape[a.shape.length-1],s=H3({inputs:{x:a},backend:n,attrs:{shape:[r/o,o]}}),i=t6(s,!1,n),c=H3({inputs:{x:i},backend:n,attrs:{shape:a.shape}});return n.disposeIntermediateTensorInfo(s),n.disposeIntermediateTensorInfo(i),c}};function o6(e){const{backend:t,attrs:n}=e,{shape:a,value:r,dtype:o}=n,s=o||nG(r),i=ZU(s,UU(a));return function(e,t,n){e.fill(t)}(i,r),t.makeTensorInfo(a,s,i)}const s6={kernelName:RH,backendName:"cpu",kernelFunc:o6};const i6={kernelName:_H,backendName:"cpu",kernelFunc:e=>{let{inputs:t,attrs:n,backend:a}=e;const{image:r}=t,o=a,s=JU(r.dtype,UU(r.shape)),[i,c,l,u]=r.shape,d=o.data.get(r.dataId).values;for(let h=0;h<i;h++){const e=h*l*c*u;for(let t=0;t<c;t++){const n=t*(l*u);for(let t=0;t<l;t++){const a=t*u;for(let r=0;r<u;r++){const o=Math.round(l-t-1),i=e+n+a+r;let c=d[i];if(o>=0&&o<l){c=d[e+n+o*u+r]}s[i]=c}}}}return{dataId:o.write(s,r.shape,r.dtype),shape:r.shape,dtype:r.dtype}}},c6=l3((e=>Math.floor(e))),l6=d3(AH,c6),u6={kernelName:AH,backendName:"cpu",kernelFunc:l6},d6=y3(((e,t)=>Math.floor(e/t))),h6=z3(FH,d6,null,"int32"),p6={kernelName:FH,backendName:"cpu",kernelFunc:h6};const f6={kernelName:FK,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r,filter:o,bias:s,preluActivationWeights:i}=t,{strides:c,pad:l,dataFormat:u,dilations:d,dimRoundingMode:h,activation:p,leakyreluAlpha:f}=a;let m=Q4({inputs:{x:r,filter:o},backend:n,attrs:{strides:c,pad:l,dataFormat:u,dilations:d,dimRoundingMode:h}});if(s){const e=m;if("NCHW"===u&&1===s.shape.length&&1!==s.shape[0]){const e=H3({inputs:{x:s},backend:n,attrs:{shape:[s.shape[0],1,1]}});m=U3({inputs:{a:m,b:e},backend:n}),n.disposeIntermediateTensorInfo(e)}else m=U3({inputs:{a:m,b:s},backend:n});n.disposeIntermediateTensorInfo(e)}if(p){const e=m;if("NCHW"===u&&"prelu"===p&&1===i.shape.length&&1!==i.shape[0]){const e=H3({inputs:{x:i},backend:n,attrs:{shape:[i.shape[0],1,1]}});m=R3(n,m,p,e,f),n.disposeIntermediateTensorInfo(e)}else m=R3(n,m,p,i,f);n.disposeIntermediateTensorInfo(e)}return m}};const m6={kernelName:OK,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r,filter:o,bias:s,preluActivationWeights:i}=t,{strides:c,pad:l,dataFormat:u,dilations:d,dimRoundingMode:h,activation:p,leakyreluAlpha:f}=a;let m=h5({inputs:{x:r,filter:o},backend:n,attrs:{strides:c,pad:l,dataFormat:u,dilations:d,dimRoundingMode:h}});if(s){const e=m;m=U3({inputs:{a:m,b:s},backend:n}),n.disposeIntermediateTensorInfo(e)}if(p){const e=m;m=R3(n,m,p,i,f),n.disposeIntermediateTensorInfo(e)}return m}};function g6(e,t,n,a,r,o,s,i,c){const l=gY([a,o],n);for(let u=0;u<a;u++){const n=[];let a=0;for(let t=0;t<r;t++){const o=e[u*r+t];a+=o*s[t],n.push(o)}if(a<0||a>=c/o)throw new Error("Invalid indices: ".concat(n," does not index into ").concat(i));for(let e=0;e<o;e++)l.values[u*o+e]=t.get(...t.indexToLoc(a*o+e))}return l}const b6={kernelName:MH,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{params:a,indices:r}=t,o=UU(a.shape),s=r.shape,i=s[s.length-1],[c,l,u,d]=m2(a,r);if(0===l)return n.makeTensorInfo(c,a.dtype,[]);const h=g6(n.data.get(r.dataId).values,n.bufferSync(a),a.dtype,l,i,u,d,a.shape,o);return n.makeTensorInfo(c,a.dtype,h.values)}};function y6(e,t,n){const a=gY(n,e.dtype);for(let r=0;r<a.size;++r){const n=a.indexToLoc(r).slice(),o=n[0],s=n[2],i=t.locToIndex([o,s]);n[2]=t.values[i];const c=e.locToIndex(n);0<=c&&c<e.values.length&&(a.values[r]=e.values[c])}return a}const x6={kernelName:DH,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r,indices:o}=t,{axis:s,batchDims:i}=a;s3([r,o],"gatherV2");const c=YU(s,r.shape)[0],l=n.data.get(o.dataId).values,u=r.shape[c];for(let x=0;x<l.length;++x){const e=l[x];BU(e<=u-1&&e>=0,(()=>"GatherV2: the index value ".concat(e," is not in [0, ").concat(u-1,"]")))}let d=i;null==i&&(d=0);const h=UU(o.shape),p=a3(r,o,c,d),f=H3({inputs:{x:r},backend:n,attrs:{shape:[p.batchSize,p.outerSize,p.dimSize,p.sliceSize]}}),m=H3({inputs:{x:o},backend:n,attrs:{shape:[p.batchSize,h/p.batchSize]}}),g=[p.batchSize,p.outerSize,h/p.batchSize,p.sliceSize],b=n.bufferSync(m),y=y6(n.bufferSync(f),b,g);return n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),n.makeTensorInfo(p.outputShape,y.dtype,y.values)}},v6=y3(((e,t)=>e>t?1:0)),w6=z3(LH,v6,null,"bool"),k6={kernelName:LH,backendName:"cpu",kernelFunc:w6},I6=y3(((e,t)=>e>=t?1:0)),S6=z3(PH,I6,null,"bool"),N6={kernelName:PH,backendName:"cpu",kernelFunc:S6};const C6={kernelName:BH,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{input:a}=t,r=UU(a.shape),o=a.shape[a.shape.length-1],s=H3({inputs:{x:a},backend:n,attrs:{shape:[r/o,o]}}),i=t6(s,!0,n),c=H3({inputs:{x:i},backend:n,attrs:{shape:a.shape}});return n.disposeIntermediateTensorInfo(s),n.disposeIntermediateTensorInfo(i),c}},T6=u3(VH,(e=>Number.isFinite(e)?1:0),"bool"),E6={kernelName:VH,backendName:"cpu",kernelFunc:T6},R6=u3(UH,(e=>Math.abs(e)===1/0?1:0),"bool"),_6={kernelName:UH,backendName:"cpu",kernelFunc:R6},A6=u3(GH,(e=>Number.isNaN(e)?1:0),"bool"),F6={kernelName:GH,backendName:"cpu",kernelFunc:A6},O6=y3(((e,t)=>e<t?1:0)),D6=z3(jH,O6,null,"bool"),M6={kernelName:jH,backendName:"cpu",kernelFunc:D6},L6=y3(((e,t)=>e<=t?1:0)),P6=z3(KH,L6,null,"bool"),z6={kernelName:KH,backendName:"cpu",kernelFunc:P6};function B6(e,t,n){const a=(t-e)/(n-1),r=lG(n,"float32");r[0]=e;for(let o=1;o<r.length;o++)r[o]=r[o-1]+a;return r}const W6={kernelName:qH,backendName:"cpu",kernelFunc:function(e){const{backend:t,attrs:n}=e,{start:a,stop:r,num:o}=n,s=B6(a,r,o);return t.makeTensorInfo([s.length],"float32",s)}},V6=l3((e=>Math.log(e))),U6=d3(XH,V6),G6={kernelName:XH,backendName:"cpu",kernelFunc:U6},H6=u3(YH,(e=>Math.log1p(e))),j6={kernelName:YH,backendName:"cpu",kernelFunc:H6},K6=y3(((e,t)=>e&&t)),q6=z3(QH,K6,null,"bool"),X6={kernelName:QH,backendName:"cpu",kernelFunc:q6},Y6=u3(JH,(e=>e?0:1),"bool"),Q6={kernelName:JH,backendName:"cpu",kernelFunc:Y6},J6=y3(((e,t)=>e||t)),Z6=z3(ZH,J6,null,"bool"),$6={kernelName:ZH,backendName:"cpu",kernelFunc:Z6};const e8={kernelName:$H,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{depthRadius:o,bias:s,alpha:i,beta:c}=a;s3(r,"LRN");const l=r.shape[3],u=l-1,d=n.data.get(r.dataId).values,h=UU(r.shape),p=new Float32Array(h);function f(e){const t=e%l;let n=e-t+Math.max(0,t-o);const a=e-t+Math.min(t+o,u);let r=0;for(;n<=a;n++){const e=d[n];r+=e*e}return r}for(let m=0;m<h;m++){const e=f(m),t=d[m]*Math.pow(s+i*e,-c);p[m]=t}return n.makeTensorInfo(r.shape,r.dtype,p)}};const t8={kernelName:ej,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r,y:o,dy:s}=t,{depthRadius:i,bias:c,alpha:l,beta:u}=a;s3(s,"LRNGrad");const d=UU(s.shape),h=s.shape[3],p=n.data.get(s.dataId).values,f=n.data.get(r.dataId).values,m=n.data.get(o.dataId).values,g=new Float32Array(d),b=d;for(let y=0;y<b;y++){const e=y%h,t=y-e+Math.max(0,e-i),n=y-e+Math.min(h,e+i+1);let a=0;for(let r=t;r<n;r++)a+=Math.pow(f[r],2);a=l*a+c;for(let r=t;r<n;r++){let e=-2*l*u*f[r]*m[y]/a;y===r&&(e+=Math.pow(a,-u)),e*=p[y],g[r]+=e}}return n.makeTensorInfo(s.shape,r.dtype,g)}};function n8(e,t,n,a){const r=JU(a,UU(n));for(let o=0;o<r.length;++o){const n=o*t;let a=e[n];for(let r=0;r<t;++r){const t=e[n+r];(Number.isNaN(t)||t>a)&&(a=t)}r[o]=a}return r}function a8(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{reductionIndices:o,keepDims:s}=a,i=n;let c=r.shape;const l=c.length,u=YU(o,c);let d=u;const h=sZ(d,l);let p=i.data.get(r.dataId).values;if(null!=h){const e=new Array(l);for(let t=0;t<e.length;t++)e[t]=c[h[t]];p=n4(p,c,r.dtype,h,e),d=cZ(d.length,l),c=e}s3(r,"max"),oZ("max",d,l);const[f,m]=aZ(c,d),g=n8(p,UU(m),f,r.dtype),b=i.write(g,f,r.dtype);let y=f;if(s){y=rZ(f,u)}return{dataId:b,shape:y,dtype:r.dtype}}const r8={kernelName:tj,backendName:"cpu",kernelFunc:a8},o8=y3(((e,t)=>Math.max(e,t))),s8=z3(nj,o8),i8={kernelName:nj,backendName:"cpu",kernelFunc:s8};const c8={kernelName:aj,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t;s3(r,"maxPool");const{filterSize:o,strides:s,pad:i,dimRoundingMode:c}=a;BU(aJ(s,1),(()=>"Error in maxPool: Either strides or dilations must be 1. "+"Got strides ".concat(s," and dilations '").concat(1,"'")));const l=qQ(r.shape,o,s,1,i,c);let u;if(1===l.filterWidth&&1===l.filterHeight&&GU(l.inShape,l.outShape))u=f3({inputs:{x:r},backend:n});else{const e=n.data.get(r.dataId).values,t=oG(r.shape),a=v4(e,r.shape,r.dtype,t,l,"max");u=n.makeTensorInfo(l.outShape,r.dtype,a.values)}return u}};const l8={kernelName:oj,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{filterSize:o,strides:s,pad:i,dimRoundingMode:c,dataFormat:l}=a;s3(r,"maxPool3d");const u=XQ(r.shape,o,s,1,i,c,l),d=k4(n.data.get(r.dataId).values,r.shape,r.dtype,oG(r.shape),u,"max");return n.makeTensorInfo(d.shape,"float32",d.values)}};const u8={kernelName:sj,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{dy:r,input:o}=t,{filterSize:s,strides:i,pad:c,dimRoundingMode:l}=a;s3([r,o],"maxPool3DGrad");const u=XQ(o.shape,s,i,1,c,l),d=function(e,t){const n=gY(t.outShape,"int32"),a=t.strideDepth,r=t.strideHeight,o=t.strideWidth,s=t.dilationDepth,i=t.dilationHeight,c=t.dilationWidth,l=t.effectiveFilterDepth,u=t.effectiveFilterHeight,d=t.effectiveFilterWidth,h=t.padInfo.front,p=t.padInfo.top,f=t.padInfo.left;for(let m=0;m<t.batchSize;++m)for(let g=0;g<t.inChannels;++g)for(let b=0;b<t.outDepth;++b){const y=b*a-h;let x=y;for(;x<0;)x+=s;const v=Math.min(t.inDepth,l+y);for(let a=0;a<t.outHeight;++a){const l=a*r-p;let h=l;for(;h<0;)h+=i;const w=Math.min(t.inHeight,u+l);for(let r=0;r<t.outWidth;++r){const p=r*o-f;let k=p;for(;k<0;)k+=c;const I=Math.min(t.inWidth,d+p);let S=Number.NEGATIVE_INFINITY,N=-1;for(let t=x;t<v;t+=s){const n=t-y;for(let a=h;a<w;a+=i){const r=a-l;for(let o=k;o<I;o+=c){const s=o-p,i=e.get(m,t,a,o,g);i>=S&&(S=i,N=n*u*d+r*u+s)}}}n.set(N,m,b,a,r,g)}}}return n}(n.bufferSync(o),u),h=u.strideDepth,p=u.strideHeight,f=u.strideWidth,m=u.dilationDepth,g=u.dilationHeight,b=u.dilationWidth,y=u.effectiveFilterDepth,x=u.effectiveFilterHeight,v=u.effectiveFilterWidth,w=y-1-u.padInfo.front,k=v-1-u.padInfo.left,I=x-1-u.padInfo.top,S=gY(o.shape,"float32"),N=n.bufferSync(r);for(let C=0;C<u.batchSize;++C)for(let e=0;e<u.inChannels;++e)for(let t=0;t<u.inDepth;++t)for(let n=0;n<u.inHeight;++n)for(let a=0;a<u.inWidth;++a){const r=t-w,o=n-I,s=a-k;let i=0;for(let t=0;t<y;t+=m){const n=(r+t)/h;if(!(n<0||n>=u.outDepth||Math.floor(n)!==n))for(let a=0;a<x;a+=g){const r=(o+a)/p;if(!(r<0||r>=u.outHeight||Math.floor(r)!==r))for(let o=0;o<v;o+=b){const c=(s+o)/f;if(c<0||c>=u.outWidth||Math.floor(c)!==c)continue;const l=y*x*v-1-d.get(C,n,r,c,e)===t*x*v+a*v+o?1:0;if(0===l)continue;i+=N.get(C,n,r,c,e)*l}}}S.set(i,C,t,n,a,e)}return n.makeTensorInfo(S.shape,S.dtype,S.values)}};const d8={kernelName:rj,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{dy:r,input:o,output:s}=t,i=o;s3([o,s],"maxPoolGrad");const{filterSize:c,strides:l,pad:u,dimRoundingMode:d}=a,h=qQ(i.shape,c,l,1,u,d),p=n.data.get(i.dataId).values,f=gY(h.outShape,i.dtype,w4(p,i.shape,i.dtype,h).values),m=h.strideHeight,g=h.strideWidth,b=h.dilationHeight,y=h.dilationWidth,x=h.effectiveFilterHeight,v=h.effectiveFilterWidth,w=v-1-h.padInfo.left,k=x-1-h.padInfo.top,I=gY(i.shape,"float32"),S=n.data.get(r.dataId).values,N=gY(r.shape,"float32",S);for(let C=0;C<h.batchSize;++C)for(let e=0;e<h.inChannels;++e)for(let t=0;t<h.inHeight;++t)for(let n=0;n<h.inWidth;++n){const a=t-k,r=n-w;let o=0;for(let t=0;t<x;t+=b){const n=(a+t)/m;if(!(n<0||n>=h.outHeight||Math.floor(n)!==n))for(let a=0;a<v;a+=y){const s=(r+a)/g;if(s<0||s>=h.outWidth||Math.floor(s)!==s)continue;const i=x*v-1-f.get(C,n,s,e)===t*v+a?1:0;if(0===i)continue;o+=N.get(C,n,s,e)*i}}I.set(o,C,t,n,e)}return n.makeTensorInfo(I.shape,I.dtype,I.values)}};const h8={kernelName:ij,backendName:"cpu",kernelFunc:e=>{let{inputs:t,attrs:n,backend:a}=e;const{x:r}=t,{filterSize:o,strides:s,pad:i,includeBatchInIndex:c}=n,l=a;s3(r,"MaxPoolWithArgmax");const u=l.data.get(r.dataId).values,d=qQ(r.shape,o,s,[1,1],i),[h,p]=function(e,t,n,a,r){const o=v4(e,0,n,oG(t),r,"max"),s=w4(e,t,n,r,!0,a);return[o.values,s.values]}(u,r.shape,r.dtype,c,d),f=l.write(h,d.outShape,r.dtype),m=l.write(p,d.outShape,r.dtype);return[{dataId:f,shape:d.outShape,dtype:r.dtype},{dataId:m,shape:d.outShape,dtype:"int32"}]}};const p8={kernelName:cj,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{axis:o,keepDims:s}=a,i=YU(o,r.shape),c=UU(aZ(r.shape,i)[1]),l=[],u=n.makeTensorInfo([],"float32",new Float32Array([c]));l.push(u);const d=L3({inputs:{x:r},backend:n,attrs:{dtype:"float32"}});l.push(d);const h=Y5({inputs:{a:d,b:u},backend:n});l.push(h);const p=N5({inputs:{x:h},backend:n,attrs:{axis:o,keepDims:s}});return l.forEach((e=>n.disposeIntermediateTensorInfo(e))),p}};const f8={kernelName:lj,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{axis:o,keepDims:s}=a;s3(r,"min");const i=YU(o,r.shape);let c=i;const l=sZ(c,r.shape.length);let u=r;null!=l&&(u=a4({inputs:{x:r},backend:n,attrs:{perm:l}}),c=cZ(c.length,r.shape.length)),oZ("min",c,u.shape.length);const[d,h]=aZ(u.shape,c),p=UU(h),f=lG(UU(d),u.dtype),m=n.data.get(u.dataId).values;for(let b=0;b<f.length;++b){const e=b*p;let t=m[e];for(let n=0;n<p;++n){const a=m[e+n];(Number.isNaN(a)||a<t)&&(t=a)}f[b]=t}null!=l&&n.disposeIntermediateTensorInfo(u);const g=n.makeTensorInfo(d,u.dtype,f);if(s){const e=H3({inputs:{x:g},backend:n,attrs:{shape:rZ(d,i)}});return n.disposeIntermediateTensorInfo(g),e}return g}},m8=y3(((e,t)=>Math.min(e,t))),g8=z3(uj,m8),b8={kernelName:uj,backendName:"cpu",kernelFunc:g8};const y8={kernelName:dj,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{paddings:o,mode:s}=a;s3(r,"mirrorPad");const i=o.map(((e,t)=>e[0]+r.shape[t]+e[1])),c=o.map((e=>e[0])),l=o.map(((e,t)=>e[0]+r.shape[t])),u="reflect"===s?0:1,d=n.data.get(r.dataId).values,h=r.shape.length,p=oG(r.shape),f=UU(i),m=i.length,g=oG(i),b=JU(r.dtype,f);for(let y=0;y<f;y++){let e=pG(y,m,g);for(let n=0;n<m;n++)e[n]<c[n]?e[n]=2*c[n]-e[n]-u:e[n]>=l[n]&&(e[n]=2*(l[n]-1)-e[n]+u);e=e.map(((e,t)=>e-c[t]));const t=hG(e,h,p);b[y]=d[t]}return{dataId:n.write(b,i,r.dtype),shape:i,dtype:r.dtype}}},x8=y3(((e,t)=>{const n=e%t;return e<0&&t<0||e>=0&&t>=0?n:(n+t)%t})),v8=z3(hj,x8),w8={kernelName:hj,backendName:"cpu",kernelFunc:v8};function k8(e){const{inputs:t,backend:n,attrs:a}=e,{logits:r}=t,{dim:o}=a,s=r.shape.length;let i=o;if(-1===i&&(i=s-1),i!==s-1)throw Error("Softmax along a non-last dimension is not yet supported. "+"Logits was rank ".concat(s," and dim was ").concat(i));const c=YU([i],r.shape),l=a8({inputs:{x:r},backend:n,attrs:{reductionIndices:c,keepDims:!1}}),u=rZ(l.shape,c),d=H3({inputs:{x:l},backend:n,attrs:{shape:u}}),h=$5({inputs:{a:r,b:d},backend:n}),p=V5({inputs:{x:h},backend:n}),f=N5({inputs:{x:p},backend:n,attrs:{axis:c,keepDims:!1}}),m=H3({inputs:{x:f},backend:n,attrs:{shape:u}}),g=Y5({inputs:{a:p,b:m},backend:n});return n.disposeIntermediateTensorInfo(l),n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),g}const I8={kernelName:rK,backendName:"cpu",kernelFunc:k8};const S8={kernelName:pj,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{logits:r}=t,{numSamples:o,seed:s,normalized:i}=a;s3(r,"multinomial");const c=i?r:k8({inputs:{logits:r},backend:n,attrs:{dim:-1}}),l=c.shape[0],u=c.shape[1],d=n.data.get(c.dataId).values,h=[l,o],p=lG(UU(h),"int32");for(let f=0;f<l;++f){const e=f*u,t=new Float32Array(u-1);t[0]=d[e];for(let r=1;r<t.length;++r)t[r]=t[r-1]+d[e+r];const n=mf.alea(s.toString()),a=f*o;for(let r=0;r<o;++r){const e=n();p[a+r]=t.length;for(let n=0;n<t.length;n++)if(e<t[n]){p[a+r]=n;break}}}return i||n.disposeIntermediateTensorInfo(c),n.makeTensorInfo(h,"int32",p)}};function N8(e,t,n){const a=aq(-1,n);return w5([],t,a,e,n)}const C8={kernelName:mj,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{x:a}=t;s3(a,"neg");const r=n.data.get(a.dataId).values,[o,s]=N8(r,a.shape,a.dtype);return n.makeTensorInfo(s,a.dtype,o)}},T8=c1;const E8={kernelName:bj,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{boxes:r,scores:o}=t,{maxOutputSize:s,iouThreshold:i,scoreThreshold:c}=a;s3(r,"NonMaxSuppression");const l=n.data.get(r.dataId).values,u=n.data.get(o.dataId).values,{selectedIndices:d}=T8(l,u,s,i,c);return n.makeTensorInfo([d.length],"int32",new Int32Array(d))}},R8=l1;const _8={kernelName:yj,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{boxes:r,scores:o}=t,{maxOutputSize:s,iouThreshold:i,scoreThreshold:c,padToMaxOutputSize:l}=a;s3(r,"NonMaxSuppressionPadded");const u=n.data.get(r.dataId).values,d=n.data.get(o.dataId).values,{selectedIndices:h,validOutputs:p}=R8(u,d,s,i,c,l);return[n.makeTensorInfo([h.length],"int32",new Int32Array(h)),n.makeTensorInfo([],"int32",new Int32Array([p]))]}},A8=u1;const F8={kernelName:xj,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{boxes:r,scores:o}=t,{maxOutputSize:s,iouThreshold:i,scoreThreshold:c,softNmsSigma:l}=a;s3(r,"NonMaxSuppressionWithScore");const u=n.data.get(r.dataId).values,d=n.data.get(o.dataId).values,h=s,p=i,f=c,m=l,{selectedIndices:g,selectedScores:b}=A8(u,d,h,p,f,m);return[n.makeTensorInfo([g.length],"int32",new Int32Array(g)),n.makeTensorInfo([b.length],"float32",new Float32Array(b))]}},O8=y3(((e,t)=>e!==t?1:0)),D8=z3(gj,O8,null,"bool"),M8={kernelName:gj,backendName:"cpu",kernelFunc:D8};const L8={kernelName:wj,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{indices:r}=t,{dtype:o,depth:s,onValue:i,offValue:c}=a;s3(r,"oneHot");const l=UU(r.shape),u=new Float32Array(l*s);u.fill(c);const d=n.data.get(r.dataId).values;for(let h=0;h<l;++h)d[h]>=0&&d[h]<s&&(u[h*s+d[h]]=i);return n.makeTensorInfo([...r.shape,s],o,u)}};function P8(e){const{inputs:t,backend:n}=e,{x:a}=t;if("string"===a.dtype)throw new Error("zerosLike is not supported for string tensors");if("complex64"===a.dtype){const e=O3({inputs:{input:a},backend:n}),t=P8({inputs:{x:e},backend:n}),r=K4({inputs:{input:a},backend:n}),o=P8({inputs:{x:r},backend:n}),s=_3({inputs:{real:t,imag:o},backend:n});return n.disposeIntermediateTensorInfo(e),n.disposeIntermediateTensorInfo(t),n.disposeIntermediateTensorInfo(r),n.disposeIntermediateTensorInfo(o),s}return o6({backend:n,attrs:{shape:a.shape,value:0,dtype:a.dtype}})}const z8={kernelName:TK,backendName:"cpu",kernelFunc:P8};const B8={kernelName:vj,backendName:"cpu",kernelFunc:function e(t){const{inputs:n,backend:a}=t,{x:r}=n;if("string"===r.dtype)throw new Error("onesLike is not supported for string tensors");if("complex64"===r.dtype){const t=O3({inputs:{input:r},backend:a}),n=e({inputs:{x:t},backend:a}),o=K4({inputs:{input:r},backend:a}),s=P8({inputs:{x:o},backend:a}),i=_3({inputs:{real:n,imag:s},backend:a});return a.disposeIntermediateTensorInfo(t),a.disposeIntermediateTensorInfo(n),a.disposeIntermediateTensorInfo(o),a.disposeIntermediateTensorInfo(s),i}return o6({backend:a,attrs:{shape:r.shape,value:1,dtype:r.dtype}})}};function W8(e){const{inputs:t,backend:n,attrs:a}=e,{axis:r}=a;if(1===t.length)return G5({inputs:{input:t[0]},backend:n,attrs:{dim:r}});const o=t[0].shape,s=t[0].dtype;t.forEach((e=>{WU(o,e.shape,"All tensors passed to stack must have matching shapes"),BU(s===e.dtype,(()=>"All tensors passed to stack must have matching dtypes"))}));const i=[],c=t.map((e=>{const t=G5({inputs:{input:e},backend:n,attrs:{dim:r}});return i.push(t),t})),l=X4({inputs:c,backend:n,attrs:{axis:r}});return i.forEach((e=>n.disposeIntermediateTensorInfo(e))),l}const V8={kernelName:kj,backendName:"cpu",kernelFunc:W8};const U8={kernelName:Ij,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{paddings:o,constantValue:s}=a;s3(r,"pad");const i=o.map(((e,t)=>e[0]+r.shape[t]+e[1])),c=o.map((e=>e[0])),l=n.data.get(r.dataId).values,u=UU(r.shape),d=r.shape.length,h=oG(r.shape),p=UU(i),f=i.length,m=oG(i),g=JU(r.dtype,p);0!==s&&g.fill(s);for(let b=0;b<u;b++){const e=pG(b,d,h).map(((e,t)=>e+c[t]));g[hG(e,f,m)]=l[b]}return{dataId:n.write(g,i,r.dtype),shape:i,dtype:r.dtype}}},G8=y3(((e,t)=>Math.pow(e,t))),H8=z3(Sj,G8),j8={kernelName:Sj,backendName:"cpu",kernelFunc:H8};function K8(e,t,n,a){const[r,o]=aZ(e,a),s=Dq(t,"int32"),i=lG(UU(r),s),c=UU(o);for(let l=0;l<i.length;++l){const e=l*c;let t=1;for(let a=0;a<c;++a)t*=n[e+a];i[l]=t}return{outVals:i,outShape:r,outDtype:s}}const q8={kernelName:Cj,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{axis:o,keepDims:s}=a;s3(r,"prod");const i=r.shape.length,c=YU(o,r.shape),l=sZ(c,i);let u=c,d=r;const h=[];null!=l&&(d=a4({inputs:{x:r},backend:n,attrs:{perm:l}}),h.push(d),u=cZ(u.length,i));const p=n.data.get(d.dataId).values,{outVals:f,outShape:m,outDtype:g}=K8(d.shape,d.dtype,p,u);let b=m;return s&&(b=rZ(m,c)),h.forEach((e=>n.disposeIntermediateTensorInfo(e))),n.makeTensorInfo(b,g,f)}};function X8(e,t,n,a){const r=[];let o=0;const s=t.length-1+n.length,i=new Array(s).fill(null).map((()=>[0]));!function(e,t){for(let n=0;n<e.length;++n){const a=e[n],r=n===e.length-1?t:e[n+1].length;if(0===a.length)throw new Error("Ragged splits may not be empty");if(a[0]<0)throw new Error("Ragged splits must be non-negative");if(a[a.length-1]>r)throw new Error("Ragged splits must not point past values");for(let e=1;e<a.length;++e)if(a[e-1]>a[e])throw new Error("Ragged splits must be sorted in ascending order")}}(n,a);let c=1;for(let l=0;l<t.length-1;++l){c*=t[l];const e=t[l+1];for(let t=1;t<c+1;++t)i[l].push(t*e)}for(let l=0;l<e.length;++l){let a=e[l],s=e[l]+1;for(let e=0;e<n.length;++e){const r=n[e],o=e+t.length-1;if(o>=0){const e=i[o],t=e[e.length-1]-r[a];for(let n=a;n<s;++n)i[o].push(r[n+1]+t)}a=r[a],s=r[s]}s!==a&&(r.push([a,s]),o+=s-a)}return{outSplits:i,valueSlices:r,numValues:o}}function Y8(e,t){const n=e.slice(0,t);for(;n.length<t;)n.push(1);for(let a=t;a<e.length;a++)n[t-1]*=e[a];return n}function Q8(e,t,n,a,r){const o=t.slice();o[0]=r;const s=ZU(n,UU(o)),i=e.length;return function(e,t,n,a,r,o){const s=Y8(t,2)[1],i=Y8(o,2)[1];let c=0;for(const l of n)for(let t=l[0];t<l[1];++t){for(let n=0;n<a;++n)r[c*i+n]=e[t*s+n];++c}}(e,t,a,0===i?0:i/t[0],s,o),[s,o]}function J8(e,t,n,a,r,o,s,i){if(0===e.length)throw new Error("paramsNestedSplits must be non empty");if(0===t[0].length)throw new Error("Split tensors must not be scalars");if(function(e,t,n){e.forEach(((e,a)=>{if(e<0||e>=n){const r=pG(a,t.length,oG(t)).join(",");throw new Error("indices[".concat(r,"] = ").concat(e," is not in [0, ").concat(n,")"))}}))}(o,s,t[0][0]-1),0===a.length)throw new Error("params.rank must be nonzero");const c=a[0],{outSplits:l,valueSlices:u,numValues:d}=X8(o,s,e,c),h=function(e){const t=[];for(let n=0;n<e.length;++n){const a=ZU("int32",e[n].length);t.push(a),e[n].forEach(((e,t)=>a[t]=e))}return t}(l),p=Q8(n,a,r,u,d);return[h,p[0],p[1]]}const Z8={kernelName:Tj,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{paramsNestedSplits:r,paramsDenseValues:o,indices:s}=t,{outputRaggedRank:i}=a,c=r.map((e=>n.data.get(e.dataId).values)),l=r.map((e=>e.shape)),u=n.data.get(o.dataId).values,d=n.data.get(s.dataId).values,[h,p,f]=J8(c,l,u,o.shape,o.dtype,d,s.shape),m=h.map((e=>n.makeTensorInfo([e.length],"int32",e))),g=n.makeTensorInfo(f,o.dtype,p);return m.concat([g])}},$8=2147483647;function e7(e,t,n,a,r,o,s){if(t.length>1)throw new Error("starts must be a scalar or vector");if(r.length>1)throw new Error("limits must be a scalar or vector");if(s.length>1)throw new Error("deltas must be a scalar or vector");const i=0===t.length,c=0===r.length,l=0===s.length,u=[];i||u.push(t[0]),c||u.push(r[0]),l||u.push(s[0]);for(let m=1;m<u.length;++m)if(u[m]!==u[m-1])throw new Error("starts, limits, and deltas must have the same shape");const d=0===u.length?1:u[0],h=ZU("int32",d+1);h[0]=0;for(let m=0;m<d;++m){const t=i?e[0]:e[m],n=c?a[0]:a[m],r=l?o[0]:o[m];if(0===r)throw new Error("Requires delta != 0");let s;if(r>0&&n<t||r<0&&n>t)s=0;else if(s=Math.ceil(Math.abs((n-t)/r)),s>$8)throw new Error("Requires ((limit - start) / delta) <= ".concat($8));h[m+1]=h[m]+s}const p=ZU(n,h[d]);let f=0;for(let m=0;m<d;++m){const t=h[m+1]-h[m];let n=i?e[0]:e[m];const a=l?o[0]:o[m];for(let e=0;e<t;++e)p[f++]=n,n+=a}return[h,p]}const t7={kernelName:Ej,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{starts:a,limits:r,deltas:o}=t,s=n.data.get(a.dataId).values,i=n.data.get(r.dataId).values,c=n.data.get(o.dataId).values,[l,u]=e7(s,a.shape,a.dtype,i,r.shape,c,o.shape);return[n.makeTensorInfo([l.length],"int32",l),n.makeTensorInfo([u.length],a.dtype,u)]}};var n7=n2;class a7{constructor(e,t,n,a,r,o,s,i,c,l){this.shape=e,this.shapeShape=t,this.values=n,this.valuesShape=a,this.valuesDType=r,this.defaultValue=o,this.defaultValueShape=s,this.rowPartitionValues=i,this.rowPartitionValuesShapes=c,this.rowPartitionTypes=r2(l),this.raggedRank=o2(this.rowPartitionTypes)}getRowPartitionTypeByDimension(e){return this.rowPartitionTypes[0]===n7.FIRST_DIM_SIZE?this.rowPartitionTypes[e+1]:this.rowPartitionTypes[e]}getRowPartitionTensor(e){return this.rowPartitionTypes[0]===n7.FIRST_DIM_SIZE?this.rowPartitionValues[e+1]:this.rowPartitionValues[e]}getMaxWidth(e){const t=this.getRowPartitionTensor(e-1);switch(this.getRowPartitionTypeByDimension(e-1)){case n7.VALUE_ROWIDS:return a7.getMaxWidthValueRowID(t);case n7.ROW_SPLITS:return a7.getMaxWidthRowSplit(t);default:throw new Error("Cannot handle partition type ".concat(n7[this.getRowPartitionTypeByDimension(e-1)]))}}static getMaxWidthRowSplit(e){const t=e.length;if(0===t||1===t)return 0;let n=0;for(let a=0;a<t-1;++a){const t=e[a+1]-e[a];t>n&&(n=t)}return n}static getMaxWidthValueRowID(e){const t=e.length;if(0===t)return 0;let n=0,a=e[0],r=0;for(let o=1;o<t;++o){const t=e[o];t!==a&&(a=t,r=Math.max(o-n,r),n=o)}return Math.max(t-n,r)}tensorShapeFromTensor(e,t){let n=!(arguments.length>2&&void 0!==arguments[2])||arguments[2];if(0===t.length){if(-1===e[0])return[];throw new Error("The only valid scalar shape tensor is the fully unknown shape specified as -1.")}return o7(e,n)}calculateOutputSize(e){const t=this.valuesShape;s2(this.defaultValueShape,t);const n=this.tensorShapeFromTensor(this.shape,this.shapeShape),a=a2(this.raggedRank,n,t);a[0]<0&&(a[0]=e);for(let r=1;r<=this.raggedRank;++r)a[r]<0&&(a[r]=this.getMaxWidth(r));return a}calculateFirstParentOutputIndex(e,t,n){const a=Math.min(e,n),r=[];let o=0;for(let s=0;s<a;++s,o+=t)r.push(o);for(let s=a;s<e;++s)r.push(-1);return BU(r.length===e,(()=>"Final length of result must be equal to firstDimension.")),r}calculateOutputIndexRowSplit(e,t,n,a){const r=e.length,o=[];for(let s=0;s<r-1;++s){const r=e[s+1]-e[s];let i=Math.min(a,r),c=t[s];-1===c&&(i=0);for(let e=0;e<i;++e)o.push(c),c+=n;for(let e=0;e<r-i;++e)o.push(-1)}if(r>0&&o.length!==e[r-1])throw new Error("Invalid row split size.");return o}calculateOutputIndexValueRowID(e,t,n,a){const r=e.length,o=[];if(0===r)return[];let s=0,i=e[0];if(i>=t.length)throw new Error("Got currentValueRowId=".concat(i,", which is not less than ").concat(t.length));let c=t[i];o.push(c);for(let l=1;l<r;++l){const r=e[l];if(r===i)c>=0&&(++s,s<a?c+=n:c=-1);else{if(s=0,i=r,r>=t.length)throw new Error("Got nextValueRowId=".concat(r," which is not less than ").concat(t.length));c=t[r]}o.push(c)}if(o.length!==e.length)throw new Error("Invalid row ids.");return o}calculateOutputIndex(e,t,n,a){const r=this.getRowPartitionTensor(e),o=this.getRowPartitionTypeByDimension(e);switch(o){case n7.VALUE_ROWIDS:return this.calculateOutputIndexValueRowID(r,t,n,a);case n7.ROW_SPLITS:if(r.length-1>t.length)throw new Error("Row partition size is greater than output size: ".concat(r.length-1," > ").concat(t.length));return this.calculateOutputIndexRowSplit(r,t,n,a);default:throw new Error("Unsupported partition type: ".concat(n7[o]))}}getFirstDimensionSize(){const e=this.rowPartitionValues[0];if(0===this.rowPartitionTypes.length)throw new Error("No row_partition_types given.");const t=this.rowPartitionTypes[0];switch(t){case n7.FIRST_DIM_SIZE:return e[0];case n7.VALUE_ROWIDS:throw new Error("Cannot handle VALUE_ROWIDS in first dimension.");case n7.ROW_SPLITS:return this.rowPartitionValuesShapes[0][0]-1;default:throw new Error("Cannot handle type ".concat(n7[t]))}}compute(){if(this.rowPartitionValues[0].length<=0)throw new Error("Invalid first partition input. Tensor requires at least one element.");const e=this.getFirstDimensionSize(),t=this.calculateOutputSize(e),n=new Array(this.raggedRank+1);n[n.length-1]=1;for(let o=n.length-2;o>=0;--o)n[o]=n[o+1]*t[o+1];const a=o7(t,!1),r=ZU(this.valuesDType,UU(a));if(n[0]*t[0]>0){let o=this.calculateFirstParentOutputIndex(e,n[0],t[0]);for(let e=1;e<=this.raggedRank;++e){o=this.calculateOutputIndex(e-1,o,n[e],t[e])}this.setOutput(this.raggedRank,o,r,a)}return[a,r]}setOutput(e,t,n,a){if(0===n.length)return;const r=this.values,o=n;let s=a.slice();s=s.slice(e+1);const i=UU(s),c=t.length;let l=this.defaultValue;if(l.length!==i&&1!==l.length){const e=this.defaultValueShape;uX((()=>{const t=iJ(l,e),n=SJ(t,s);l=n.dataSync()}))}let u=0,d=0,h=0;for(let p=0;p<=c;++p){let e=p<c?t[p]:-1;if(e!==h){if(d<h){const e=r.subarray(u*i);r7(o.subarray(d*i),e,(h-d)*i)}if(p>=c){const t=n.length;e=Math.floor(t/i)}if(e>h)if(1===this.defaultValue.length)o.subarray(h*i,e*i).fill(this.defaultValue[0]),h=e;else for(;e>h;){r7(o.slice(h*i),l,i),++h}e<0?(u=p+1,d=h):(u=p,d=h,h=d+1)}else++h}}}function r7(e,t,n){for(let a=0;a<n;a++)e[a]=t[a]}function o7(e,t){const n=[];for(let a of e){if(a<0){if(!t)throw new Error("Dimension ".concat(a," must be >= 0"));if(a<-1)throw new Error("Dimension ".concat(a," must be >= -1"));a=-1}n.push(a)}return n}function s7(e,t,n,a,r,o,s,i,c,l){return new a7(e,t,n,a,r,o,s,i,c,l).compute()}const i7={kernelName:Rj,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{shape:r,values:o,defaultValue:s,rowPartitionTensors:i}=t,{rowPartitionTypes:c}=a,l=n.data.get(r.dataId).values,u=n.data.get(o.dataId).values,d=n.data.get(s.dataId).values,h=i.map((e=>n.data.get(e.dataId).values)),p=i.map((e=>e.shape)),[f,m]=s7(l,r.shape,u,o.shape,o.dtype,d,s.shape,h,p,c);return n.makeTensorInfo(f,o.dtype,m)}};function c7(e,t,n,a){if(e===t||e<t&&n<0||t<e&&n>1)return lG(0,a);const r=lG(Math.abs(Math.ceil((t-e)/n)),a);t<e&&1===n&&(n=-1),r[0]=e;for(let o=1;o<r.length;o++)r[o]=r[o-1]+n;return r}const l7={kernelName:_j,backendName:"cpu",kernelFunc:function(e){const{backend:t,attrs:n}=e,{start:a,stop:r,dtype:o,step:s}=n,i=c7(a,r,s,o);return t.makeTensorInfo([i.length],o,i)}},u7=u3(Fj,(e=>1/e)),d7={kernelName:Fj,backendName:"cpu",kernelFunc:u7};const h7={kernelName:Pj,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{images:r}=t,{alignCorners:o,halfPixelCenters:s,size:i}=a;s3(r,"resizeBilinear");const c=oG(r.shape),[l,u]=i,[d,h,p,f]=r.shape,m=n.data.get(r.dataId).values,g=new Float32Array(UU([d,l,u,f])),b=[o&&l>1?h-1:h,o&&u>1?p-1:p],y=[o&&l>1?l-1:l,o&&u>1?u-1:u];let x=0;const v=b[0]/y[0],w=b[1]/y[1];for(let k=0;k<d;k++)for(let e=0;e<l;e++){let t;t=s?v*(e+.5)-.5:v*e;const n=Math.max(0,Math.floor(t)),a=t-n,r=Math.min(h-1,Math.ceil(t)),o=k*c[0]+n*c[1],i=k*c[0]+r*c[1];for(let e=0;e<u;e++){let t;t=s?w*(e+.5)-.5:w*e;const n=Math.max(0,Math.floor(t)),r=t-n,l=Math.min(p-1,Math.ceil(t)),u=o+n*c[2],d=i+n*c[2],h=o+l*c[2],b=i+l*c[2];for(let e=0;e<f;e++){const t=m[u+e],n=m[d+e],o=t+(m[h+e]-t)*r,s=o+(n+(m[b+e]-n)*r-o)*a;g[x++]=s}}}return n.makeTensorInfo([d,l,u,f],"float32",g)}};const p7={kernelName:zj,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{images:r,dy:o}=t,{alignCorners:s}=a;s3([o,r],"resizeBilinearGrad");const i=oG(r.shape),[c,l,u,d]=r.shape,[,h,p]=o.shape,f=new Float32Array(c*l*u*d),m=[s&&h>1?l-1:l,s&&p>1?u-1:u],g=[s&&h>1?h-1:h,s&&p>1?p-1:p],b=m[0]/g[0],y=m[1]/g[1],x=n.data.get(o.dataId).values;let v=0;for(let w=0;w<c;w++){const e=w*i[0];for(let t=0;t<h;t++){const n=t*b,a=Math.floor(n),r=Math.min(Math.ceil(n),l-1),o=e+a*i[1],s=e+r*i[1],c=n-a,h=1-c;for(let e=0;e<p;e++){const t=e*y,n=Math.floor(t),a=Math.min(Math.ceil(t),u-1),r=t-n,l=1-r,p=o+n*i[2],m=o+a*i[2],g=s+n*i[2],b=s+a*i[2],w=h*l,k=h*r,I=c*l,S=c*r;for(let e=0;e<d;e++){const t=x[v++];f[p+e]+=t*w,f[m+e]+=t*k,f[g+e]+=t*I,f[b+e]+=t*S}}}}return n.makeTensorInfo([c,u,l,d],"float32",f)}};const f7={kernelName:Mj,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{images:r}=t,{alignCorners:o,halfPixelCenters:s,size:i}=a;s3(r,"resizeNearestNeighbor");const c=oG(r.shape),[l,u]=i,[d,h,p,f]=r.shape,m=n.data.get(r.dataId).values,g=new Float32Array(d*l*u*f),b=[o&&l>1?h-1:h,o&&u>1?p-1:p],y=[o&&l>1?l-1:l,o&&u>1?u-1:u],x=b[0]/y[0],v=b[1]/y[1];let w=0;for(let k=0;k<d;k++){const e=k*c[0];for(let t=0;t<l;t++){const n=s?x*(t+.5):x*t;let a=Math.min(h-1,o?Math.round(n):Math.floor(n));s&&(a=Math.max(0,a));const r=e+a*c[1];for(let e=0;e<u;e++){const t=s?v*(e+.5):v*e;let n=Math.min(p-1,o?Math.round(t):Math.floor(t));s&&(n=Math.max(0,n));const a=r+n*c[2];for(let e=0;e<f;e++){const t=m[a+e];g[w++]=t}}}}return n.makeTensorInfo([d,l,u,f],r.dtype,g)}};const m7={kernelName:Lj,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{images:r,dy:o}=t,{alignCorners:s}=a;s3([o,r],"resizeNearestNeighborGrad");const i=oG(r.shape),c=oG(o.shape),[l,u,d,h]=r.shape,[,p,f]=o.shape,m=new Float32Array(l*u*d*h),g=n.data.get(o.dataId).values,b=[s&&p>1?u-1:u,s&&f>1?d-1:d],y=[s&&p>1?p-1:p,s&&f>1?f-1:f],x=b[0]/y[0],v=b[1]/y[1],w=1/x,k=1/v,I=2*Math.ceil(w)+2,S=2*Math.ceil(k)+2;for(let N=0;N<l;N++){const e=N*i[0];for(let t=0;t<u;t++){const n=e+t*i[1],a=Math.floor(t*w),r=Math.floor(a-I/2);for(let o=0;o<d;o++){const a=n+o*i[2],l=Math.floor(o*k),b=Math.floor(l-S/2);for(let n=0;n<h;n++){let i=0;for(let a=0;a<I;a++){const l=a+r;if(l<0||l>=p)continue;const h=e+l*c[1],m=l*x;if(t===Math.min(u-1,s?Math.round(m):Math.floor(m)))for(let e=0;e<S;e++){const t=e+b;if(t<0||t>=f)continue;const a=h+t*c[2],r=t*v;o===Math.min(d-1,s?Math.round(r):Math.floor(r))&&(i+=g[a+n])}}m[a+n]=i}}}}return n.makeTensorInfo(r.shape,r.dtype,m)}};const g7={kernelName:Wj,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{dims:o}=a;s3(r,"reverse");const s=r.shape.length,i=YU(o,r.shape);if(0===s)return f3({inputs:{x:r},backend:n});const c=new wq(r.shape,r.dtype),l=n.bufferSync(r);for(let u=0;u<c.size;u++){const e=c.indexToLoc(u),t=e.slice();i.forEach((e=>t[e]=r.shape[e]-1-t[e])),c.set(l.get(...t),...e)}return n.makeTensorInfo(c.shape,c.dtype,c.values)}},b7={kernelName:_K,backendName:"cpu",kernelFunc:e=>{let{inputs:t,attrs:n,backend:a}=e;const{image:r}=t,{radians:o,fillValue:s,center:i}=n,c=a,l=JU(r.dtype,UU(r.shape)),[u,d,h,p]=r.shape,[f,m]=l2(i,d,h),g=Math.sin(o),b=Math.cos(o),y=c.data.get(r.dataId).values;for(let x=0;x<u;x++){const e=x*h*d*p;for(let t=0;t<d;t++){const n=t*(h*p);for(let a=0;a<h;a++){const r=a*p;for(let o=0;o<p;o++){const i=[u,t,a,o],c=i[2],x=i[1];let v=(c-f)*b-(x-m)*g,w=(c-f)*g+(x-m)*b;v=Math.round(v+f),w=Math.round(w+m);let k=s;if("number"!==typeof s&&(k=3===o?255:s[o]),v>=0&&v<h&&w>=0&&w<d){k=y[e+w*(h*p)+v*p+o]}l[e+n+r+o]=k}}}}return{dataId:c.write(l,r.shape,r.dtype),shape:r.shape,dtype:r.dtype}}},y7=u3(Vj,(e=>{const t=Math.floor(e);return e-t<.5?Math.floor(e):e-t>.5?Math.ceil(e):t%2===0?t:t+1})),x7={kernelName:Vj,backendName:"cpu",kernelFunc:y7},v7=l3((e=>1/Math.sqrt(e))),w7=d3(Uj,v7),k7={kernelName:Uj,backendName:"cpu",kernelFunc:w7};function I7(e,t,n,a,r,o,s,i,c,l){const u=[a/r,r],d=e.values,h=t.values;if(0===a)return gY(n,t.dtype);const p=c instanceof wq?c:gY(u,t.dtype);"string"===typeof c||"number"===typeof c?p.values.fill(c):"boolean"===typeof c&&p.values.fill(+c);for(let f=0;f<o;f++){const e=[];let o=0;for(let t=0;t<s;t++){const n=d[f*s+t];e.push(n),o+=n*i[t]}if(o<0||o>=a/r)throw new Error("Invalid indices: ".concat(e," does not index into ").concat(n));for(let n=0;n<r;n++)l?p.values[o*r+n]+=h[f*r+n]:p.values[o*r+n]=0===t.rank?h[0]:h[f*r+n]}return p}const S7={kernelName:Gj,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{indices:r,updates:o}=t,{shape:s}=a,{sliceRank:i,numUpdates:c,sliceSize:l,strides:u,outputSize:d}=y0(0,r,s),h=I7(n.bufferSync(r),n.bufferSync(o),s,d,l,c,i,u,0,!0);return n.makeTensorInfo(s,h.dtype,h.values)}};function N7(e,t){let n=0,a=e.length,r=0;for(;n<a;)r=Math.floor((n+a)/2),e[r]<t?n=r+1:a=r;return a}function C7(e,t){let n=0,a=e.length,r=0;for(;n<a;)r=Math.floor((n+a)/2),e[r]<=t?n=r+1:a=r;return a}const T7={kernelName:jj,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{sortedSequence:r,values:o}=t,{side:s}=a,i=function(e,t,n,a,r,o){const s=ZU("int32",n*r);for(let i=0;i<n;++i){const n=e.slice(i*a,(i+1)*a),c=i*r;for(let e=0;e<r;++e)s[c+e]="left"===o?N7(n,t[e+c]):C7(n,t[e+c])}return s}(n.data.get(r.dataId).values,n.data.get(o.dataId).values,r.shape[0],r.shape[1],o.shape[1],s);return n.makeTensorInfo(o.shape,"int32",i)}};const E7={kernelName:Kj,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{condition:a,t:r,e:o}=t;s3([a,r,o],"select");const s=a.shape.length,i=n.data.get(a.dataId).values,c=n.data.get(r.dataId).values,l=n.data.get(o.dataId).values,u=Dq(r.dtype,o.dtype),d=lG(UU(r.shape),u);let h=0;const p=0===s||s>1||1===r.shape.length?1:UU(r.shape.slice(1));for(let f=0;f<i.length;f++)for(let e=0;e<p;e++)1===i[f]?d[h++]=c[f]:d[h++]=l[f];return n.makeTensorInfo(r.shape,u,d)}},R7=g2,_7=b2,A7=u3(qj,(e=>e>=0?_7*e:R7*(Math.exp(e)-1))),F7={kernelName:qj,backendName:"cpu",kernelFunc:A7},O7=u3(Jj,(e=>e<0?-1:e>0?1:0)),D7={kernelName:Jj,backendName:"cpu",kernelFunc:O7},M7=u3(Yj,(e=>Math.sin(e))),L7={kernelName:Yj,backendName:"cpu",kernelFunc:M7},P7=u3(Qj,(e=>Math.sinh(e))),z7={kernelName:Qj,backendName:"cpu",kernelFunc:P7},B7=Math.log(1.1920928955078125e-7)+2,W7=u3($j,(e=>{const t=e>-B7,n=e<B7,a=Math.exp(e);let r;return r=n?a:t?e:Math.log(1+a),r})),V7={kernelName:$j,backendName:"cpu",kernelFunc:W7};const U7={kernelName:nK,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{blockShape:o,paddings:s}=a;s3([r],"spaceToBatchND");const i=UU(o),c=[[0,0]];c.push(...s);for(let g=1+o.length;g<r.shape.length;++g)c.push([0,0]);const l=U8.kernelFunc({inputs:{x:r},backend:n,attrs:{paddings:c,constantValue:0}}),u=u2(l.shape,o,i,!1),d=d2(u.length,o.length,!1),h=h2(l.shape,o,i,!1),p=H3({inputs:{x:l},backend:n,attrs:{shape:u}}),f=a4({inputs:{x:p},backend:n,attrs:{perm:d}}),m=H3({inputs:{x:f},backend:n,attrs:{shape:h}});return n.disposeIntermediateTensorInfo(l),n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(f),m}};function G7(e,t,n,a,r,o,s){const i=t[0],c=o[0],l=new Array(c),u=new Array(i),d=t[1];if(0===c){if(0!==i)throw new Error(G2(i));return[ZU(n,0),[0,d],ZU(r,0),l,u]}let h=!0,p=0;const f=new Array(c).fill(0);for(let g=0;g<i;++g){const t=e[g*d];if(t<0)throw new Error(H2(g,t));if(t>=c)throw new Error(j2(g,t,c));++f[t],h=h&&t>=p,p=t}let m=!0;for(let g=0;g<c;++g){const e=0===f[g];l[g]=e,m=m&&!e,f[g]=Math.max(f[g],1),g>0&&(f[g]+=f[g-1])}if(m&&h){const t=e,n=a;for(let e=0;e<i;++e)u[e]=e;return[t,[i,d],n,l,u]}{const t=f[c-1],o=ZU(n,t*d),h=ZU(r,t),p=new Array(c).fill(0);for(let n=0;n<i;++n){const t=e[n*d],r=p[t],s=(0===t?0:f[t-1])+r;p[t]++;for(let a=0;a<d;++a)o[s*d+a]=e[n*d+a];h[s]=a[n],u[n]=s}for(let e=0;e<c;++e){if(0===p[e]){const t=0===e?0:f[e-1];o[t*d+0]=e;for(let e=1;e<d;++e)o[t*d+e]=0;h[t]=s}}return[o,[t,d],h,l,u]}}const H7={kernelName:oK,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{indices:a,values:r,denseShape:o,defaultValue:s}=t;if(1!==o.shape.length)throw new Error("Dense shape must be a vector, saw:\n        ".concat(o.shape));if(2!==a.shape.length)throw new Error("Indices must be a matrix, saw:\n        ".concat(a.shape));if(1!==r.shape.length)throw new Error("Values must be a vector, saw:\n        ".concat(r.shape));if(0!==s.shape.length)throw new Error("Default value must be a scalar, saw:\n        ".concat(s.shape));const i=n.data.get(a.dataId).values,c=n.data.get(r.dataId).values,l=n.data.get(o.dataId).values,u=n.data.get(s.dataId).values[0],[d,h,p,f,m]=G7(i,a.shape,a.dtype,c,r.dtype,l,u);return[n.makeTensorInfo(h,a.dtype,d),n.makeTensorInfo([h[0]],r.dtype,p),n.makeTensorInfo([f.length],"bool",new Uint8Array(f.map((e=>Number(e))))),n.makeTensorInfo([m.length],a.dtype,new Int32Array(m))]}};function j7(e,t,n,a,r){const o=UU(a),s=t[0],i=r.length,c=[];let l=1,u=-1;for(let m=0;m<i;++m){const e=r[m];if(-1===e){if(-1!==u)throw new Error(K2(u,m));u=m,c.push(1)}else{if(e<0)throw new Error(q2(m,e));l*=e,c.push(e)}}if(-1!==u){if(l<=0)throw new Error("reshape cannot infer the missing input size for an empty tensor unless all specified input sizes are non-zero");const e=Math.trunc(o/l);if(l*e!==o)throw new Error(Y2(a,c));c[u]=e}if(UU(c)!==o)throw new Error(Q2(a,c));const d=a.length,h=[];if(d>0){h[d-1]=1;for(let e=d-2;e>=0;--e)h[e]=h[e+1]*a[e+1]}const p=[];if(i>0){p[i-1]=1;for(let e=i-2;e>=0;--e)p[e]=p[e+1]*c[e+1]}const f=ZU(n,s*i);for(let m=0;m<s;++m){let t=0;for(let n=0;n<d;++n)t+=e[m*d+n]*h[n];for(let e=0;e<i;++e)f[m*i+e]=Math.trunc(t/p[e]),t%=p[e]}return[f,[s,i],c]}const K7={kernelName:sK,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{inputIndices:a,inputShape:r,newShape:o}=t;if(2!==a.shape.length)throw new Error("Input indices should be a matrix but received shape\n        ".concat(a.shape));if(1!==r.shape.length)throw new Error("Input shape should be a vector but received shape\n        ".concat(r.shape));if(1!==o.shape.length)throw new Error("Target shape should be a vector but received shape ".concat(o.shape));const s=Array.from(n.data.get(r.dataId).values),i=n.data.get(a.dataId).values,c=Array.from(n.data.get(o.dataId).values),[l,u,d]=j7(i,a.shape,a.dtype,s,c);return[n.makeTensorInfo(u,a.dtype,l),n.makeTensorInfo([d.length],o.dtype,new Int32Array(d))]}};function q7(e,t,n,a,r){let o=arguments.length>5&&void 0!==arguments[5]&&arguments[5],s=arguments.length>6&&void 0!==arguments[6]?arguments[6]:0;const i=a.length,c=[t[0],e.length/t[0]],l=c[1],u=i>0?r[i-1]+1:0;if(u<0)throw new Error("segment ids must be >= 0");const d=t.slice();d[0]=u;const h=ZU(n,d.reduce(((e,t)=>e*t),1));if(0===i)return u>0&&h.fill(s),[h,d];if(u<=0)throw new Error("segment ids must be >= 0");let p=0,f=1,m=0,g=r[p];for(;;){let t=0;if(f<i){if(t=r[f],g===t){++f;continue}if(g>=t)throw new Error("segment ids are not increasing")}if(g<0||g>=u)throw new Error($2(g,u));g>m&&h.fill(s,m*l,g*l);for(let n=p;n<f;++n){const t=a[n];if(t<0||t>=c[0])throw new Error(e3(n,a[n],c[0]));for(let n=0;n<l;n++)h[g*l+n]+=e[t*l+n]}if(o)for(let e=0;e<l;e++)h[g*l+e]/=f-p;if(p=f,++f,m=g+1,g=t,f>i)break}return m<u&&h.fill(s,m*l,u*l),[h,d]}const X7={kernelName:iK,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{data:a,indices:r,segmentIds:o}=t;if(a.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==r.shape.length)throw new Error("Indices should be a vector but received shape\n          ".concat(r.shape));if(1!==o.shape.length)throw new Error("Segment ids should be a vector but received shape\n          ".concat(o.shape));if(r.shape[0]!==o.shape[0])throw new Error("segmentIds and indices should have same size.");const s=n.data.get(a.dataId).values,i=n.data.get(r.dataId).values,c=n.data.get(o.dataId).values,[l,u]=q7(s,a.shape,a.dtype,i,c,!0);return n.makeTensorInfo(u,a.dtype,l)}};const Y7={kernelName:cK,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{data:a,indices:r,segmentIds:o}=t;if(a.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==r.shape.length)throw new Error("Indices should be a vector but received shape\n         ".concat(r.shape));if(1!==o.shape.length)throw new Error("Segment ids should be a vector but received shape\n         ".concat(o.shape));if(r.shape[0]!==o.shape[0])throw new Error("segmentIds and indices should have same size.");const s=n.data.get(a.dataId).values,i=n.data.get(r.dataId).values,c=n.data.get(o.dataId).values,[l,u]=q7(s,a.shape,a.dtype,i,c);return n.makeTensorInfo(u,a.dtype,l)}};const Q7={kernelName:lK,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{sparseIndices:r,sparseValues:o,defaultValue:s}=t,{outputShape:i}=a,{sliceRank:c,numUpdates:l,sliceSize:u,strides:d,outputSize:h}=y0(0,r,i),p=!1,f=n.bufferSync(r);let m;switch(o.dtype){case"bool":m=I7(f,n.bufferSync(o),i,h,u,l,c,d,Boolean(n.data.get(s.dataId).values[0]),p);break;case"float32":m=I7(f,n.bufferSync(o),i,h,u,l,c,d,n.data.get(s.dataId).values[0],p);break;case"int32":m=I7(f,n.bufferSync(o),i,h,u,l,c,d,n.data.get(s.dataId).values[0],p);break;case"string":m=I7(f,n.bufferSync(o),i,h,u,l,c,d,iq(n.data.get(s.dataId).values[0]),p);break;default:throw new Error("Unsupported type ".concat(o.dtype))}return n.makeTensorInfo(i,m.dtype,m.values)}};const J7={kernelName:aK,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{numOrSizeSplits:o,axis:s}=a,i=YU(s,r.shape)[0],c=U2(r,o,i),l=new Array(r.shape.length).fill(0),u=r.shape.slice();return c.map((e=>{const t=[...u];t[i]=e;const a=R4({inputs:{x:r},backend:n,attrs:{begin:l,size:t}});return l[i]+=e,a}))}},Z7=l3((e=>Math.sqrt(e))),$7=u3(eK,(e=>Math.sqrt(e))),e9={kernelName:eK,backendName:"cpu",kernelFunc:$7},t9={kernelName:dK,backendName:"cpu",kernelFunc:e=>{let{inputs:t,backend:n}=e;const{x:a}=t,r=n;s3(a,"square");const o=r.data.get(a.dataId).values,s=new Float32Array(o.length);for(let i=0;i<o.length;++i){const e=o[i];s[i]=e*e}return{dataId:r.write(s,a.shape,a.dtype),shape:a.shape,dtype:a.dtype}}},n9=y3(((e,t)=>{const n=e-t;return n*n})),a9=z3(uK,n9),r9={kernelName:uK,backendName:"cpu",kernelFunc:a9},o9=l3(((e,t)=>{const{pattern:n,replaceGlobal:a,rewrite:r}=t;return e.replace(new RegExp(n,a?"g":""),r)})),s9=d3(hK,o9),i9={kernelName:hK,backendName:"cpu",kernelFunc:s9},c9=u3(EK,((e,t)=>{const n=t;return isNaN(e)?NaN:e>0?1:n.alpha})),l9={kernelName:EK,backendName:"cpu",kernelFunc:c9};function u9(e,t,n,a){const r=gY(e,t.dtype);for(let o=0;o<r.size;o++){const e=r.indexToLoc(o),s=new Array(e.length);for(let t=0;t<s.length;t++)s[t]=e[t]*n[t]+a[t];r.set(t.get(...s),...e)}return r}const d9={kernelName:pK,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{begin:o,end:s,strides:i,beginMask:c,endMask:l,ellipsisMask:u,newAxisMask:d,shrinkAxisMask:h}=a;s3(r,"stridedSlice");const{finalShapeSparse:p,finalShape:f,isIdentity:m,sliceDim0:g,isSimpleSlice:b,begin:y,end:x,strides:v}=FQ(r.shape,o,s,i,c,l,u,d,h);let w;if(m)w=H3({inputs:{x:r},backend:n,attrs:{shape:f}});else if(g||b){BU(r.shape.length>=1,(()=>"Input must have rank at least 1, got: ".concat(r.shape.length)));const e=xQ(y,x,v),t=R4({inputs:{x:r},backend:n,attrs:{begin:y,size:e}});w=H3({inputs:{x:t},backend:n,attrs:{shape:f}}),n.disposeIntermediateTensorInfo(t)}else{const e=u9(p,n.bufferSync(r),v,y);w=n.makeTensorInfo(f,e.dtype,e.values)}return w}};class h9{constructor(e,t,n,a,r,o){this.separator=sq(e),this.nGramWidths=t,this.leftPad=sq(n),this.rightPad=sq(a),this.padWidth=r,this.preserveShort=o}getPadWidth(e){return Math.min(this.padWidth<0?e-1:this.padWidth,e-1)}getNumNGrams(e,t){const n=this.getPadWidth(t);return Math.max(0,e+2*n-t+1)}createNGrams(e,t,n,a,r,o){for(let s=0;s<r;++s){const i=this.getPadWidth(o),c=Math.max(0,i-s),l=Math.max(0,i-(r-(s+1))),u=o-(c+l),d=t+(c>0?0:s-i);let h=0;h+=c*this.leftPad.length;for(let t=0;t<u;++t)h+=e[d+t].length;h+=l*this.rightPad.length;h+=(c+l+u-1)*this.separator.length,n[a+s]=new Uint8Array(h);const p=n[a+s];let f=0;const m=e=>e.forEach((e=>p[f++]=e));for(let e=0;e<c;++e)m(this.leftPad),m(this.separator);for(let t=0;t<u-1;++t)m(e[d+t]),m(this.separator);if(u>0){m(e[d+u-1]);for(let e=0;e<l;++e)m(this.separator),m(this.rightPad)}else{for(let e=0;e<l-1;++e)m(this.rightPad),m(this.separator);m(this.rightPad)}}}compute(e,t){const n=e.length,a=t.length;if(a>0){let e=t[0];if(0!==e)throw new Error("First split value must be 0, got ".concat(e));for(let r=1;r<a;++r){let a=t[r]>=e;if(a=a&&t[r]<=n,!a)throw new Error("Invalid split value ".concat(t[r],", must be in [").concat(e,", ").concat(n,"]"));e=t[r]}if(e!==n)throw new Error("Last split value must be data size. Expected ".concat(n,", got ").concat(e))}const r=a-1,o=ZU("int32",a);if(0===n||0===a){const e=new Array(n);for(let t=0;t<=r;++t)o[t]=0;return[e,o]}o[0]=0;for(let i=1;i<=r;++i){const e=t[i]-t[i-1];let n=0;this.nGramWidths.forEach((t=>{n+=this.getNumNGrams(e,t)})),this.preserveShort&&e>0&&0===n&&(n=1),o[i]=o[i-1]+n}const s=new Array(o[r]);for(let i=0;i<r;++i){const n=t[i];let a=o[i];if(this.nGramWidths.forEach((r=>{const o=t[i+1]-t[i],c=this.getNumNGrams(o,r);this.createNGrams(e,n,s,a,c,r),a+=c})),this.preserveShort&&a===o[i]){const r=t[i+1]-t[i];if(0===r)continue;const o=r+2*this.padWidth,c=1;this.createNGrams(e,n,s,a,c,o)}}return[s,o]}}function p9(e,t,n,a,r,o,s,i){return new h9(n,a,r,o,s,i).compute(e,t)}const f9={kernelName:fK,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{separator:r,nGramWidths:o,leftPad:s,rightPad:i,padWidth:c,preserveShortSequences:l}=a,{data:u,dataSplits:d}=t,h=n.data.get(u.dataId).values,p=n.data.get(d.dataId).values,[f,m]=p9(h,p,r,o,s,i,c,l);return[n.makeTensorInfo([f.length],"string",f),n.makeTensorInfo(d.shape,"int32",m)]}};function m9(e,t,n,a){if(!e.length)return;if(0===t.length){for(let t=0;t<e.length;++t)a.push(e.subarray(t,t+1));return}if(1===t.length){const r=t[0];let o=e.indexOf(r);for(;-1!==o;){const t=e.subarray(0,o);n&&0===t.length||a.push(t),o=(e=e.subarray(o+1)).indexOf(r)}return void(n&&0===e.length||a.push(e))}let r=0;for(let o=0;o<e.length+1;o++)if(o===e.length||-1!==t.indexOf(e[o])){const t=e.subarray(r,o);n&&0===t.length||a.push(t),r=o+1}}function g9(e,t,n){const a=e.length,r=[];let o=0,s=0;const i=new Array(a);for(let h=0;h<a;++h){const a=r.length;m9(e[h],t,n,r);const c=r.length-a;i[h]=c,o+=c,s=Math.max(s,c)}const c=ZU("int32",2*o),l=new Array(o),u=[a,s];let d=0;for(let h=0;h<a;++h)for(let e=0;e<i[h];++e)c[2*d]=h,c[2*d+1]=e,l[d]=r[d],++d;return[c,l,u]}const b9={kernelName:mK,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{skipEmpty:r}=a,{input:o,delimiter:s}=t;if("string"!==o.dtype)throw new Error("Input must be of datatype string");if(1!==o.shape.length)throw new Error("Input must be a vector, got shape: ".concat(o.shape));if(0!==s.shape.length)throw new Error("Delimiter must be a scalar, got shape: ".concat(s.shape));const i=n.data.get(o.dataId).values,c=n.data.get(s.dataId).values[0],[l,u,d]=g9(i,c,r),h=u.length;return[n.makeTensorInfo([h,2],"int32",l),n.makeTensorInfo([h],"string",u),n.makeTensorInfo([2],"int32",new Int32Array(d))]}};function y9(e,t){const n=ZU("int32",e.length);for(let a=0;a<e.length;++a)n[a]=nq(e[a]).modulo(t).getLowBitsUnsigned();return n}const x9={kernelName:gK,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{numBuckets:r}=a,{input:o}=t;if("string"!==o.dtype)throw new Error("Input must be of datatype string");if(r<=0)throw new Error("Number of buckets must be at least 1");const s=y9(n.data.get(o.dataId).values,r);return n.makeTensorInfo(o.shape,"int32",s)}},v9=u3(yK,(e=>Math.tan(e))),w9={kernelName:yK,backendName:"cpu",kernelFunc:v9},k9=u3(xK,(e=>Math.tanh(e)));const I9={kernelName:Hj,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{tensor:a,indices:r,updates:o}=t,{sliceRank:s,numUpdates:i,sliceSize:c,strides:l,outputSize:u}=y0(0,r,a.shape),d=n.bufferSync(r),h=n.bufferSync(o),p=n.bufferSync(a),f=I7(d,h,a.shape,u,c,i,s,l,p,!1);return n.makeTensorInfo(a.shape,f.dtype,f.values)}};function S9(e,t){const n=new Array(e.rank);for(let r=0;r<n.length;r++)n[r]=e.shape[r]*t[r];const a=gY(n,e.dtype);for(let r=0;r<a.values.length;++r){const t=a.indexToLoc(r),n=new Array(e.rank);for(let a=0;a<n.length;a++)n[a]=t[a]%e.shape[a];const o=e.locToIndex(n);a.values[r]=e.values[o]}return a}const N9={kernelName:vK,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{reps:o}=a;s3(r,"tile");const s=S9(n.bufferSync(r),o);return n.makeTensorInfo(s.shape,s.dtype,s.values)}},C9=(e,t)=>{const n=t.value-e.value;return 0===n?e.index-t.index:n};function T9(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:e.length-1;for(;a>n;){if(a-n>600){const r=a-n+1,o=t-n+1,s=Math.log(r),i=.5*Math.exp(2*s/3),c=.5*Math.sqrt(s*i*(r-i)/r)*Math.sign(o-r/2);T9(e,t,Math.max(n,Math.floor(t-o*i/r+c)),Math.min(a,Math.floor(t+(r-o)*i/r+c)))}const r=e[t];let o=n,s=a;for(zU(e,n,t),C9(e[a],r)>0&&zU(e,n,a);o<s;){for(zU(e,o,s),o++,s--;C9(e[o],r)<0;)o+=1;for(;C9(e[s],r)>0;)s-=1}0===C9(e[n],r)?zU(e,n,s):(s+=1,zU(e,s,a)),s<=t&&(n=s+1),t<=s&&(a=s-1)}}function E9(e,t,n,a,r){const o=t[t.length-1],[s,i]=[e.length/o,o],c=JU(n,s*a),l=JU("int32",s*a);for(let d=0;d<s;d++){const t=d*i,n=e.subarray(t,t+i);let o=new Array(n.length);n.forEach(((e,t)=>o[t]={value:e,index:t})),a<o.length&&(T9(o,a),o=o.slice(0,a)),r&&o.sort(C9);const s=d*a,u=c.subarray(s,s+a),h=l.subarray(s,s+a);for(let e=0;e<a;e++)u[e]=o[e].value,h[e]=o[e].index}const u=t.slice();return u[u.length-1]=a,[gY(u,n,c),gY(u,"int32",l)]}const R9={kernelName:wK,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{k:o,sorted:s}=a;s3(r,"topk");const i=n.data.get(r.dataId).values,[c,l]=E9(i,r.shape,r.dtype,o,s);return[n.makeTensorInfo(c.shape,c.dtype,c.values),n.makeTensorInfo(l.shape,l.dtype,l.values)]}};const _9={kernelName:kK,backendName:"cpu",kernelFunc:function(e){const{inputs:t,attrs:n,backend:a}=e,{image:r,transforms:o}=t,{interpolation:s,fillMode:i,fillValue:c,outputShape:l}=n,[u,d,h,p]=r.shape,[f,m]=null!=l?l:[d,h],g=[u,f,m,p],b=oG(r.shape),y=b[0],x=b[1],v=b[2],w=oG(g),k=w[0],I=w[1],S=w[2],N=JU(r.dtype,UU(g));N.fill(c);const C=a.data.get(r.dataId).values,T=a.data.get(o.dataId).values;for(let E=0;E<u;++E){const e=1===o.shape[0]?T:T.subarray(8*E,8*E+8);for(let t=0;t<f;++t)for(let n=0;n<m;++n)for(let a=0;a<p;++a){let r;const o=e[6]*n+e[7]*t+1;if(0===o)continue;const l=(e[0]*n+e[1]*t+e[2])/o,u=(e[3]*n+e[4]*t+e[5])/o,p=A9(l,h,i),f=A9(u,d,i);switch(s){case"nearest":r=O9(C,d,h,y,x,v,E,f,p,a,c);break;case"bilinear":r=D9(C,d,h,y,x,v,E,f,p,a,c);break;default:throw new Error("Error in Transform: Expect 'nearest' or "+"'bilinear', but got ".concat(s))}N[E*k+t*I+n*S+a]=r}return a.makeTensorInfo(g,r.dtype,N)}return{dataId:a.write(N,g,r.dtype),shape:r.shape,dtype:r.dtype}}};function A9(e,t,n){switch(n){case"reflect":return function(e,t){let n=e;if(n<0)if(t<=1)n=0;else{const e=2*t;n<e&&(n=e*Math.trunc(-n/e)+n),n=n<-t?n+e:-n-1}else if(n>t-1)if(t<=1)n=0;else{const e=2*t;n-=e*Math.trunc(n/e),n>=t&&(n=e-n-1)}return LU(0,n,t-1)}(e,t);case"wrap":return function(e,t){let n=e;if(n<0)if(t<=1)n=0;else{const e=t-1;n+=t*(Math.trunc(-n/e)+1)}else if(n>t-1)if(t<=1)n=0;else{const e=t-1;n-=t*Math.trunc(n/e)}return LU(0,n,t-1)}(e,t);case"nearest":return function(e,t){return LU(0,e,t-1)}(e,t);default:return function(e,t){return e}(e)}}function F9(e,t,n,a,r,o,s,i,c,l,u){return 0<=i&&i<t&&0<=c&&c<n?e[s*a+i*r+c*o+l]:u}function O9(e,t,n,a,r,o,s,i,c,l,u){return F9(e,t,n,a,r,o,s,Math.round(i),Math.round(c),l,u)}function D9(e,t,n,a,r,o,s,i,c,l,u){const d=Math.floor(i),h=Math.floor(c),p=d+1,f=h+1;return(p-i)*((f-c)*F9(e,t,n,a,r,o,s,d,h,l,u)+(c-h)*F9(e,t,n,a,r,o,s,d,f,l,u))+(i-d)*((f-c)*F9(e,t,n,a,r,o,s,p,h,l,u)+(c-h)*F9(e,t,n,a,r,o,s,p,f,l,u))}function M9(e,t,n,a){const r=YU(t,n)[0],o=[1,n[0],1];for(let f=0;f<r;f++)o[0]*=n[f];o[1]=n[r];for(let f=r+1;f<n.length;f++)o[2]*=n[f];const s=new Map,i=new Int32Array(n[r]),c=new wq(o,a,e),l=[],u=1===o[0]&&1===o[2];for(let f=0;f<n[r];f++){let t;if(u)t=e[f].toString();else{const e=[];for(let t=0;t<o[0];t++)for(let n=0;n<o[2];n++)e.push(c.get(t,f,n));t=e.join(",")}const n=s.get(t);if(null!=n)i[f]=n;else{const e=s.size;s.set(t,e),i[f]=e,l.push(f)}}const d=o.slice();d[1]=s.size;const h=new wq(d,a);l.forEach(((e,t)=>{for(let n=0;n<o[0];n++)for(let a=0;a<o[2];a++)h.set(c.get(n,e,a),n,t,a)}));const p=n.slice();return p[r]=d[1],{outputValues:h.values,outputShape:p,indices:i}}const L9={kernelName:SK,backendName:"cpu",kernelFunc:function(e){const{inputs:t,attrs:n,backend:a}=e,{axis:r}=n,{x:o}=t;s3(o,"unique");const s=a.data.get(o.dataId).values,{outputValues:i,outputShape:c,indices:l}=M9(s,r,o.shape,o.dtype);return[a.makeTensorInfo(c,o.dtype,i),a.makeTensorInfo([l.length],"int32",l)]}};const P9={kernelName:NK,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{value:r}=t;let{axis:o}=a;o<0&&(o+=r.shape.length);const s=r.shape.length,i=r.shape[o],c=new Array(s-1);let l=0;for(let p=0;p<s;p++)p!==o&&(c[l++]=r.shape[p]);const u=new Array(s).fill(0),d=r.shape.slice();d[o]=1;const h=new Array(i);for(let p=0;p<h.length;p++){u[o]=p;const e=R4({inputs:{x:r},backend:n,attrs:{begin:u,size:d}});h[p]=H3({inputs:{x:e},backend:n,attrs:{shape:c}}),n.disposeIntermediateTensorInfo(e)}return h}};const z9={kernelName:CK,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r,segmentIds:o}=t,{numSegments:s}=a;s3(r,"unsortedSegmentSum");const i=[],c=[],l=r.shape.length-o.shape.length;let u=o;for(let h=0;h<l;++h){const e=G5({inputs:{input:u},backend:n,attrs:{dim:h+1}});u=e,c.push(e)}for(let h=0;h<s;++h){const e=aq(h,"int32"),t=n.makeTensorInfo([],"int32",e),a=_5({inputs:{a:t,b:u},backend:n}),o=L3({inputs:{x:a},backend:n,attrs:{dtype:"float32"}}),s=I5({inputs:{a:o,b:r},backend:n}),l=N5({inputs:{x:s},backend:n,attrs:{axis:0,keepDims:!1}});i.push(l),c.push(t),c.push(a),c.push(o),c.push(s),c.push(l)}const d=W8({inputs:i,backend:n,attrs:{axis:0}});return c.forEach((e=>n.disposeIntermediateTensorInfo(e))),d}},B9=[X3,Q3,Z3,e4,G3,t4,o4,s4,i4,c4,u4,h4,f4,b4,x4,I4,S4,N4,C4,q3,T4,A4,D4,P4,z4,P3,V4,G4,A3,H4,Y4,J4,Z4,$4,e5,t5,n5,r5,s5,i5,c5,l5,u5,d5,p5,f5,m5,g5,b5,y5,x5,v5,T5,p3,E5,A5,B5,U5,H5,q5,r6,s6,i6,u6,p6,f6,m6,b6,x6,k6,N6,m3,C6,q4,E6,_6,F6,b3,M6,z6,W6,G6,j6,X6,Q6,$6,e8,t8,r8,i8,c8,l8,u8,d8,h8,p8,f8,b8,y8,w8,S8,S5,C8,E8,_8,F8,M8,L8,B8,V8,U8,j8,w3,q8,Z8,t7,i7,l7,D3,Q5,d7,I3,N3,j3,h7,p7,f7,m7,g7,b7,x7,k7,S7,T7,E7,F7,E3,D7,L7,z7,_4,I8,V7,U7,H7,K7,X7,Y7,Q7,J7,e9,t9,r9,i9,l9,d9,f9,b9,x9,e6,C5,w9,{kernelName:xK,backendName:"cpu",kernelFunc:k9},I9,N9,R9,_9,r4,L9,P9,z9,z8];for(const n of B9)VK(n);const W9={},V9={alpha:!1,antialias:!1,premultipliedAlpha:!1,preserveDrawingBuffer:!1,depth:!1,stencil:!1,failIfMajorPerformanceCaveat:!0};function U9(e,t){if(!(e in W9)||null!=t){const n=function(e,t){if(1!==e&&2!==e)throw new Error("Cannot get WebGL rendering context, WebGL is disabled.");const n=null==t?function(e){if(yG().getBool("IS_SAFARI")||"undefined"===typeof OffscreenCanvas||2!==e){if("undefined"!==typeof document)return document.createElement("canvas");throw new Error("Cannot create a canvas in this context")}return new OffscreenCanvas(300,150)}(e):t;n.addEventListener("webglcontextlost",(t=>{t.preventDefault(),delete W9[e]}),!1),yG().getBool("SOFTWARE_WEBGL_ENABLED")&&(V9.failIfMajorPerformanceCaveat=!1);if(1===e)return n.getContext("webgl",V9)||n.getContext("experimental-webgl",V9);return n.getContext("webgl2",V9)}(e,t);if(null===n)return console.log("Could not get context for WebGL version",e),null;W9[e]=n}const n=W9[e];return null==n||n.isContextLost()?(delete W9[e],U9(e)):(n.disable(n.DEPTH_TEST),n.disable(n.STENCIL_TEST),n.disable(n.BLEND),n.disable(n.DITHER),n.disable(n.POLYGON_OFFSET_FILL),n.disable(n.SAMPLE_COVERAGE),n.enable(n.SCISSOR_TEST),n.enable(n.CULL_FACE),n.cullFace(n.BACK),W9[e])}var G9,H9,j9;function K9(e,t){return[t,e]}function q9(e){const t=UU(e);return jU(Math.ceil(t/4))}function X9(e,t){return[Math.max(1,Math.ceil(t/2)),Math.max(1,Math.ceil(e/2))]}function Y9(e,t){const n=e;let a,r,o,s,i,c,l,u,d,h;return 2===yG().getNumber("WEBGL_VERSION")?(a=n.R32F,r=n.R16F,o=n.RGBA16F,s=n.RGBA32F,i=n.RED,l=4,u=1,d=n.HALF_FLOAT,h=n.FLOAT,c=n.RGBA8):(a=e.RGBA,r=e.RGBA,o=e.RGBA,s=n.RGBA,i=e.RGBA,l=4,u=4,d=null!=t?t.HALF_FLOAT_OES:null,h=e.FLOAT,c=e.RGBA),{internalFormatFloat:a,internalFormatHalfFloat:r,internalFormatPackedHalfFloat:o,internalFormatPackedFloat:s,textureFormatFloat:i,downloadTextureFormat:c,downloadUnpackNumChannels:l,defaultNumChannels:u,textureTypeHalfFloat:d,textureTypeFloat:h}}function Q9(e,t){const n=t();return yG().getBool("DEBUG")&&function(e){const t=e.getError();if(t!==e.NO_ERROR)throw new Error("WebGL Error: "+function(e,t){switch(t){case e.NO_ERROR:return"NO_ERROR";case e.INVALID_ENUM:return"INVALID_ENUM";case e.INVALID_VALUE:return"INVALID_VALUE";case e.INVALID_OPERATION:return"INVALID_OPERATION";case e.INVALID_FRAMEBUFFER_OPERATION:return"INVALID_FRAMEBUFFER_OPERATION";case e.OUT_OF_MEMORY:return"OUT_OF_MEMORY";case e.CONTEXT_LOST_WEBGL:return"CONTEXT_LOST_WEBGL";default:return"Unknown error code ".concat(t)}}(e,t))}(e),n}!function(e){e[e.DENSE=0]="DENSE",e[e.SHARED_BATCH=1]="SHARED_BATCH"}(G9||(G9={})),function(e){e[e.RENDER=0]="RENDER",e[e.UPLOAD=1]="UPLOAD",e[e.PIXELS=2]="PIXELS",e[e.DOWNLOAD=3]="DOWNLOAD"}(H9||(H9={})),function(e){e[e.UNPACKED_FLOAT16=0]="UNPACKED_FLOAT16",e[e.UNPACKED_FLOAT32=1]="UNPACKED_FLOAT32",e[e.PACKED_4X1_UNSIGNED_BYTE=2]="PACKED_4X1_UNSIGNED_BYTE",e[e.PACKED_2X2_FLOAT32=3]="PACKED_2X2_FLOAT32",e[e.PACKED_2X2_FLOAT16=4]="PACKED_2X2_FLOAT16"}(j9||(j9={}));function J9(e){return!!(yG().getBool("WEBGL_RENDER_FLOAT32_ENABLED")||0===e||5.96e-8<Math.abs(e)&&Math.abs(e)<65504)}function Z9(e,t){return iee(e,(()=>e.getExtension(t)),'Extension "'+t+'" not supported on this browser.')}const $9=/ERROR: [0-9]+:([0-9]+):/g;function eee(e,t){const n=$9.exec(t);if(null==n)return console.log("Couldn't parse line number in error: ".concat(t)),void console.log(e);const a=+n[1],r=e.split("\n"),o=r.length.toString().length+2,s=r.map(((e,t)=>KU((t+1).toString(),o)+e));let i=0;for(let d=0;d<s.length;d++)i=Math.max(s[d].length,i);const c=s.slice(0,a-1),l=s.slice(a-1,a),u=s.slice(a);console.log(c.join("\n")),console.log(t.split("\n")[0]),console.log("%c ".concat(KU(l[0],i)),"border:1px solid red; background-color:#e3d2d2; color:#a61717"),console.log(u.join("\n"))}function tee(e,t){if(Q9(e,(()=>e.validateProgram(t))),!1===e.getProgramParameter(t,e.VALIDATE_STATUS))throw console.log(e.getProgramInfoLog(t)),new Error("Shader program validation failed.")}function nee(e,t,n,a,r,o,s){const i=e.getAttribLocation(t,n);return-1!==i&&(Q9(e,(()=>e.bindBuffer(e.ARRAY_BUFFER,a))),Q9(e,(()=>e.vertexAttribPointer(i,r,e.FLOAT,!1,o,s))),Q9(e,(()=>e.enableVertexAttribArray(i))),!0)}function aee(e,t,n,a){Q9(e,(()=>function(e,t,n){cee(e,n),Q9(e,(()=>e.activeTexture(e.TEXTURE0+n))),Q9(e,(()=>e.bindTexture(e.TEXTURE_2D,t)))}(e,t,a))),Q9(e,(()=>e.uniform1i(n,a)))}function ree(e,t,n){Q9(e,(()=>e.bindFramebuffer(e.FRAMEBUFFER,n))),Q9(e,(()=>e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,t,0)))}function oee(e,t){Q9(e,(()=>e.bindFramebuffer(e.FRAMEBUFFER,t))),Q9(e,(()=>e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,null,0)))}function see(e){const t=e.checkFramebufferStatus(e.FRAMEBUFFER);if(t!==e.FRAMEBUFFER_COMPLETE)throw new Error("Error binding framebuffer: "+function(e,t){switch(t){case e.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_ATTACHMENT";case e.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT";case e.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:return"FRAMEBUFFER_INCOMPLETE_DIMENSIONS";case e.FRAMEBUFFER_UNSUPPORTED:return"FRAMEBUFFER_UNSUPPORTED";default:return"unknown error ".concat(t)}}(e,t))}function iee(e,t,n){const a=Q9(e,(()=>t()));if(null==a)throw new Error(n);return a}function cee(e,t){const n=e.MAX_COMBINED_TEXTURE_IMAGE_UNITS-1,a=t+e.TEXTURE0;if(a<e.TEXTURE0||a>n){const e="[gl.TEXTURE0, gl.TEXTURE".concat(n,"]");throw new Error("textureUnit must be in ".concat(e,"."))}}function lee(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:2;return UU(e.slice(0,e.length-t))}function uee(e){if(0===e.length)throw Error("Cannot get rows and columns of an empty shape array.");return[e.length>1?e[e.length-2]:1,e[e.length-1]]}function dee(e){let t=[1,1,1];return 0===e.length||1===e.length&&1===e[0]||(t=[lee(e),...uee(e)]),t}function hee(e){return e%2===0}function pee(e,t){if(GU(e=e.slice(-2),t=t.slice(-2)))return!0;if(!e.length||!t.length)return!0;if(0===e[0]||0===e[1]||0===t[0]||0===t[1])return!0;if(e.length!==t.length){const n=e[e.length-1],a=t[t.length-1];if(n===a)return!0;if(hee(n)&&hee(a)&&(1===e[0]||1===t[0]))return!0}return e[1]===t[1]&&hee(e[0])&&hee(t[0])}let fee,mee;function gee(e,t){return null!=e.getExtension(t)}function bee(e){try{if(null!=U9(e))return!0}catch(B){return console.log("Error when getting WebGL context: ",B),!1}return!1}function yee(e){if(0===e)return!1;const t=U9(e);if(1!==e){if(gee(t,"EXT_color_buffer_float"))return xee(t);const e="EXT_color_buffer_half_float";if(gee(t,e)){const n=t.getExtension(e);return function(e,t){const n=Y9(e,t),a=e.createTexture();e.bindTexture(e.TEXTURE_2D,a);const r=1,o=1;e.texImage2D(e.TEXTURE_2D,0,n.internalFormatHalfFloat,r,o,0,n.textureFormatFloat,n.textureTypeHalfFloat,null);const s=e.createFramebuffer();e.bindFramebuffer(e.FRAMEBUFFER,s),e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,a,0);const i=e.checkFramebufferStatus(e.FRAMEBUFFER)===e.FRAMEBUFFER_COMPLETE;return e.bindTexture(e.TEXTURE_2D,null),e.bindFramebuffer(e.FRAMEBUFFER,null),e.deleteTexture(a),e.deleteFramebuffer(s),i}(t,n)}return!1}if(!gee(t,"OES_texture_float"))return!1;if(!gee(t,"WEBGL_color_buffer_float"))return!1;return xee(t)}function xee(e){const t=Y9(e),n=e.createTexture();e.bindTexture(e.TEXTURE_2D,n);e.texImage2D(e.TEXTURE_2D,0,t.internalFormatFloat,1,1,0,t.textureFormatFloat,t.textureTypeFloat,null);const a=e.createFramebuffer();e.bindFramebuffer(e.FRAMEBUFFER,a),e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,n,0);const r=e.checkFramebufferStatus(e.FRAMEBUFFER)===e.FRAMEBUFFER_COMPLETE;return e.bindTexture(e.TEXTURE_2D,null),e.bindFramebuffer(e.FRAMEBUFFER,null),e.deleteTexture(n),e.deleteFramebuffer(a),r}function vee(e,t){Array.isArray(e)||(e=[e]),e.forEach((e=>{null!=e&&BU("complex64"!==e.dtype,(()=>"".concat(t," does not support complex64 tensors ")+"in the WebGL backend."))}))}const wee=yG();function kee(){let e,t,n,a,r,o,s,i,c,l;return 2===yG().getNumber("WEBGL_VERSION")?(e="#version 300 es",t="in",n="out",a="in",r="texture",o="outputColor",s="out vec4 outputColor;",i=yG().getBool("WEBGL2_ISNAN_CUSTOM")?"\n      bool isnan_custom(float val) {\n        uint floatToUint = floatBitsToUint(val);\n        return (floatToUint & 0x7fffffffu) > 0x7f800000u;\n      }\n\n      bvec4 isnan_custom(vec4 val) {\n        return bvec4(isnan_custom(val.x),\n          isnan_custom(val.y), isnan_custom(val.z), isnan_custom(val.w));\n      }\n\n      #define isnan(value) isnan_custom(value)\n    ":"",c="",l="\n      #define round(value) newRound(value)\n      int newRound(float value) {\n        return int(floor(value + 0.5));\n      }\n\n      ivec4 newRound(vec4 value) {\n        return ivec4(floor(value + vec4(0.5)));\n      }\n    "):(e="",t="attribute",n="varying",a="varying",r="texture2D",o="gl_FragColor",s="",i="\n      #define isnan(value) isnan_custom(value)\n      bool isnan_custom(float val) {\n        return (val > 0. || val < 1. || val == 0.) ? false : true;\n      }\n      bvec4 isnan_custom(vec4 val) {\n        return bvec4(isnan(val.x), isnan(val.y), isnan(val.z), isnan(val.w));\n      }\n    ",c="\n      uniform float INFINITY;\n\n      bool isinf(float val) {\n        return abs(val) == INFINITY;\n      }\n      bvec4 isinf(vec4 val) {\n        return equal(abs(val), vec4(INFINITY));\n      }\n    ",l="\n      int round(float value) {\n        return int(floor(value + 0.5));\n      }\n\n      ivec4 round(vec4 value) {\n        return ivec4(floor(value + vec4(0.5)));\n      }\n    "),{version:e,attribute:t,varyingVs:n,varyingFs:a,texture2D:r,output:o,defineOutput:s,defineSpecialNaN:i,defineSpecialInf:c,defineRound:l}}function Iee(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"index";const a=oG(t);return a.map(((t,r)=>{const o="int ".concat(e[r]," = ").concat(n," / ").concat(t),s=r===a.length-1?"int ".concat(e[r+1]," = ").concat(n," - ").concat(e[r]," * ").concat(t):"index -= ".concat(e[r]," * ").concat(t);return"".concat(o,"; ").concat(s,";")})).join("")}function See(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"index";const a=oG(t);return a.map(((t,r)=>{const o="int ".concat(e[r]," = ").concat(n," / outShapeStrides[").concat(r,"]"),s=r===a.length-1?"int ".concat(e[r+1]," = ").concat(n," - ").concat(e[r]," * outShapeStrides[").concat(r,"]"):"index -= ".concat(e[r]," * outShapeStrides[").concat(r,"]");return"".concat(o,"; ").concat(s,";")})).join("")}function Nee(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"index";const a=e.map(((e,t)=>t)),r=function(e,t){const n=e.length,a=e.map((e=>"".concat(t,"[").concat(e,"]"))),r=new Array(n-1);r[n-2]=a[n-1];for(let o=n-3;o>=0;--o)r[o]="(".concat(r[o+1]," * ").concat(a[o+1],")");return r}(a,t);return r.map(((t,a)=>{const o="int ".concat(e[a]," = ").concat(n," / ").concat(r[a]),s=a===r.length-1?"int ".concat(e[a+1]," = ").concat(n," - ").concat(e[a]," * ").concat(r[a]):"index -= ".concat(e[a]," * ").concat(r[a]);return"".concat(o,"; ").concat(s,";")})).join("")}function Cee(e){const t=oG(e).map((e=>e.toString()));return"\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * ".concat(t[0]," + coords.y * ").concat(t[1]," + coords.z;\n  }\n")}wee.registerFlag("HAS_WEBGL",(()=>wee.getNumber("WEBGL_VERSION")>0)),wee.registerFlag("WEBGL_VERSION",(()=>bee(2)?2:bee(1)?1:0)),wee.registerFlag("WEBGL_CHECK_NUMERICAL_PROBLEMS",(()=>!1)),wee.registerFlag("WEBGL_BUFFER_SUPPORTED",(()=>2===wee.get("WEBGL_VERSION"))),wee.registerFlag("WEBGL_CPU_FORWARD",(()=>!0)),wee.registerFlag("WEBGL_FORCE_F16_TEXTURES",(()=>!1)),wee.registerFlag("WEBGL_PACK",(()=>wee.getBool("HAS_WEBGL"))),wee.registerFlag("WEBGL_PACK_NORMALIZATION",(()=>wee.getBool("WEBGL_PACK"))),wee.registerFlag("WEBGL_PACK_CLIP",(()=>wee.getBool("WEBGL_PACK"))),wee.registerFlag("WEBGL_PACK_DEPTHWISECONV",(()=>wee.getBool("WEBGL_PACK"))),wee.registerFlag("WEBGL_PACK_BINARY_OPERATIONS",(()=>wee.getBool("WEBGL_PACK"))),wee.registerFlag("WEBGL_PACK_UNARY_OPERATIONS",(()=>wee.getBool("WEBGL_PACK"))),wee.registerFlag("WEBGL_PACK_ARRAY_OPERATIONS",(()=>wee.getBool("WEBGL_PACK"))),wee.registerFlag("WEBGL_PACK_IMAGE_OPERATIONS",(()=>wee.getBool("WEBGL_PACK"))),wee.registerFlag("WEBGL_PACK_REDUCE",(()=>wee.getBool("WEBGL_PACK"))),wee.registerFlag("WEBGL_LAZILY_UNPACK",(()=>wee.getBool("WEBGL_PACK"))),wee.registerFlag("WEBGL_CONV_IM2COL",(()=>wee.getBool("WEBGL_PACK"))),wee.registerFlag("WEBGL_PACK_CONV2DTRANSPOSE",(()=>wee.getBool("WEBGL_PACK"))),wee.registerFlag("WEBGL_MAX_TEXTURE_SIZE",(()=>function(e){if(null==fee){const t=U9(e);fee=t.getParameter(t.MAX_TEXTURE_SIZE)}return fee}(wee.getNumber("WEBGL_VERSION")))),wee.registerFlag("WEBGL_MAX_TEXTURES_IN_SHADER",(()=>function(e){if(null==mee){const t=U9(e);mee=t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS)}return Math.min(16,mee)}(wee.getNumber("WEBGL_VERSION")))),wee.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION",(()=>{const e=wee.getNumber("WEBGL_VERSION");return 0===e?0:function(e){if(0===e)return 0;let t;const n=U9(e);return t=gee(n,"EXT_disjoint_timer_query_webgl2")&&2===e?2:gee(n,"EXT_disjoint_timer_query")?1:0,t}(e)})),wee.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE",(()=>wee.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0&&!Xq())),wee.registerFlag("WEBGL_RENDER_FLOAT32_CAPABLE",(()=>function(e){if(0===e)return!1;const t=U9(e);if(1===e){if(!gee(t,"OES_texture_float"))return!1}else if(!gee(t,"EXT_color_buffer_float"))return!1;return xee(t)}(wee.getNumber("WEBGL_VERSION")))),wee.registerFlag("WEBGL_RENDER_FLOAT32_ENABLED",(()=>!wee.getBool("WEBGL_FORCE_F16_TEXTURES")&&wee.getBool("WEBGL_RENDER_FLOAT32_CAPABLE"))),wee.registerFlag("WEBGL_DOWNLOAD_FLOAT_ENABLED",(()=>yee(wee.getNumber("WEBGL_VERSION")))),wee.registerFlag("WEBGL_FENCE_API_ENABLED",(()=>{return 2===(e=wee.getNumber("WEBGL_VERSION"))&&null!=U9(e).fenceSync;var e})),wee.registerFlag("WEBGL_SIZE_UPLOAD_UNIFORM",(()=>wee.getBool("WEBGL_RENDER_FLOAT32_ENABLED")?4:0)),wee.registerFlag("WEBGL_DELETE_TEXTURE_THRESHOLD",(()=>-1),(e=>{if("number"!==typeof e)throw new Error("WEBGL_DELETE_TEXTURE_THRESHOLD must be a number but "+"got ".concat(e,"."));if(e<0&&-1!==e)throw new Error("WEBGL_DELETE_TEXTURE_THRESHOLD must be -1 (indicating never "+"delete) or at least 0, but got ".concat(e,"."))})),wee.registerFlag("WEBGL_FLUSH_THRESHOLD",(()=>Xq()?1:-1),(e=>{if("number"!==typeof e)throw new Error("WEBGL_FLUSH_THRESHOLD must be a number but got "+"".concat(e,"."));if(e<0&&-1!==e)throw new Error("WEBGL_FLUSH_THRESHOLD must be -1 (indicating never "+"manual flush) or at least 0, but got ".concat(e,"."))})),wee.registerFlag("CPU_HANDOFF_SIZE_THRESHOLD",(()=>128)),wee.registerFlag("WEBGL_USE_SHAPES_UNIFORMS",(()=>!1)),wee.registerFlag("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD",(()=>1e5)),wee.registerFlag("TOPK_K_CPU_HANDOFF_THRESHOLD",(()=>128)),wee.registerFlag("WEBGL_EXP_CONV",(()=>!1)),wee.registerFlag("SOFTWARE_WEBGL_ENABLED",(()=>wee.getBool("IS_TEST"))),wee.registerFlag("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE",(()=>1/0)),wee.registerFlag("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE",(()=>!1)),wee.registerFlag("WEBGL2_ISNAN_CUSTOM",(()=>!1)),wee.registerFlag("ENGINE_COMPILE_ONLY",(()=>!1));const Tee="\n  const float FLOAT_MAX = 1.70141184e38;\n  const float FLOAT_MIN = 1.17549435e-38;\n\n  lowp vec4 encode_float(highp float v) {\n    if (isnan(v)) {\n      return vec4(255, 255, 255, 255);\n    }\n\n    highp float av = abs(v);\n\n    if(av < FLOAT_MIN) {\n      return vec4(0.0, 0.0, 0.0, 0.0);\n    } else if(v > FLOAT_MAX) {\n      return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;\n    } else if(v < -FLOAT_MAX) {\n      return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;\n    }\n\n    highp vec4 c = vec4(0,0,0,0);\n\n    highp float e = floor(log2(av));\n    highp float m = exp2(fract(log2(av))) - 1.0;\n\n    c[2] = floor(128.0 * m);\n    m -= c[2] / 128.0;\n    c[1] = floor(32768.0 * m);\n    m -= c[1] / 32768.0;\n    c[0] = floor(8388608.0 * m);\n\n    highp float ebias = e + 127.0;\n    c[3] = floor(ebias / 2.0);\n    ebias -= c[3] * 2.0;\n    c[2] += floor(ebias) * 128.0;\n\n    c[3] += 128.0 * step(0.0, -v);\n\n    return c / 255.0;\n  }\n",{getBroadcastDims:Eee}=l;function Ree(e,t,n){const a=[];if(e.forEach((e=>{const t=UU(e.shapeInfo.logicalShape);if(e.shapeInfo.isUniform?a.push("uniform float ".concat(e.name).concat(t>1?"[".concat(t,"]"):"",";")):(a.push("uniform sampler2D ".concat(e.name,";")),a.push("uniform int offset".concat(e.name,";"))),n.enableShapeUniforms){const{uniformShape:t}=Bee(n.packedInputs,e.shapeInfo.logicalShape,e.shapeInfo.texShape);switch(t.length){case 1:a.push("uniform int ".concat(e.name,"Shape;"));break;case 2:a.push("uniform ivec2 ".concat(e.name,"Shape;"));break;case 3:a.push("uniform ivec3 ".concat(e.name,"Shape;"));break;case 4:a.push("uniform ivec4 ".concat(e.name,"Shape;"))}a.push("uniform ivec2 ".concat(e.name,"TexShape;"))}})),n.enableShapeUniforms){switch(t.logicalShape.length){case 1:a.push("uniform int outShape;");break;case 2:a.push("uniform ivec2 outShape;"),a.push("uniform int outShapeStrides;");break;case 3:a.push("uniform ivec3 outShape;"),a.push("uniform ivec2 outShapeStrides;");break;case 4:a.push("uniform ivec4 outShape;"),a.push("uniform ivec3 outShapeStrides;")}a.push("uniform ivec2 outTexShape;")}n.customUniforms&&n.customUniforms.forEach((e=>{a.push("uniform ".concat(e.type," ").concat(e.name).concat(e.arrayIndex?"[".concat(e.arrayIndex,"]"):"",";"))}));const r=a.join("\n"),o=e.map((e=>function(e,t){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],a=arguments.length>3?arguments[3]:void 0,r="";r+=n?Aee(e,a):_ee(e,a);const o=e.shapeInfo.logicalShape,s=t.logicalShape;o.length<=s.length&&(r+=n?function(e,t){const n=e.name,a=n.charAt(0).toUpperCase()+n.slice(1),r="get"+a+"AtOutCoords",o=e.shapeInfo.logicalShape.length,s=t.logicalShape.length,i=Eee(e.shapeInfo.logicalShape,t.logicalShape),c=zee(s),l=s-o;let u;const d=["x","y","z","w","u","v"];u=0===o?"":s<2&&i.length>=1?"coords = 0;":i.map((e=>"coords.".concat(d[e+l]," = 0;"))).join("\n");let h="";h=s<2&&o>0?"coords":e.shapeInfo.logicalShape.map(((e,t)=>"coords.".concat(d[t+l]))).join(", ");let p="return outputValue;";const f=1===UU(e.shapeInfo.logicalShape),m=UU(t.logicalShape),g=1===m;if(1!==o||f||g){if(f&&!g)p=1===s?"\n        return vec4(outputValue.x, outputValue.x, 0., 0.);\n      ":"\n        return vec4(outputValue.x);\n      ";else if(i.length){const e=o-2,t=o-1;i.indexOf(e)>-1&&i.indexOf(t)>-1?p="return vec4(outputValue.x);":i.indexOf(e)>-1?p="return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);":i.indexOf(t)>-1&&(p="return vec4(outputValue.xx, outputValue.zz);")}}else p="\n      return vec4(outputValue.xy, outputValue.xy);\n    ";return"\n    vec4 ".concat(r,"() {\n      ").concat(c," coords = getOutputCoords();\n      ").concat(u,"\n      vec4 outputValue = get").concat(a,"(").concat(h,");\n      ").concat(p,"\n    }\n  ")}(e,t):function(e,t){const n=e.name,a=n.charAt(0).toUpperCase()+n.slice(1),r="get"+a+"AtOutCoords",o=t.texShape,s=e.shapeInfo.texShape,i=e.shapeInfo.logicalShape.length,c=t.logicalShape.length;if(!e.shapeInfo.isUniform&&i===c&&null==e.shapeInfo.flatOffset&&GU(s,o))return"\n      float ".concat(r,"() {\n        return sampleTexture(").concat(n,", resultUV);\n      }\n    ");const l=zee(c),u=Eee(e.shapeInfo.logicalShape,t.logicalShape),d=c-i;let h;const p=["x","y","z","w","u","v"];h=0===i?"":c<2&&u.length>=1?"coords = 0;":u.map((e=>"coords.".concat(p[e+d]," = 0;"))).join("\n");let f="";f=c<2&&i>0?"coords":e.shapeInfo.logicalShape.map(((e,t)=>"coords.".concat(p[t+d]))).join(", ");return"\n    float ".concat(r,"() {\n      ").concat(l," coords = getOutputCoords();\n      ").concat(h,"\n      return get").concat(a,"(").concat(f,");\n    }\n  ")}(e,t));return r}(e,t,n.packedInputs,n.enableShapeUniforms))).join("\n"),s=t.texShape,i=kee(),c=function(e){return"\n    float sampleTexture(sampler2D textureSampler, vec2 uv) {\n      return ".concat(e.texture2D,"(textureSampler, uv).r;\n    }\n  ")}(i);let l,u,d=function(e){const t="".concat(e.version,"\n    precision highp float;\n    precision highp int;\n    precision highp sampler2D;\n    ").concat(e.varyingFs," vec2 resultUV;\n    ").concat(e.defineOutput,"\n    const vec2 halfCR = vec2(0.5, 0.5);\n\n    struct ivec5\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n    };\n\n    struct ivec6\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n      int v;\n    };\n\n    uniform float NAN;\n    ").concat(e.defineSpecialNaN,"\n    ").concat(e.defineSpecialInf,"\n    ").concat(e.defineRound,"\n\n    int imod(int x, int y) {\n      return x - y * (x / y);\n    }\n\n    int idiv(int a, int b, float sign) {\n      int res = a / b;\n      int mod = imod(a, b);\n      if (sign < 0. && mod != 0) {\n        res -= 1;\n      }\n      return res;\n    }\n\n    //Based on the work of Dave Hoskins\n    //https://www.shadertoy.com/view/4djSRW\n    #define HASHSCALE1 443.8975\n    float random(float seed){\n      vec2 p = resultUV * seed;\n      vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);\n      p3 += dot(p3, p3.yzx + 19.19);\n      return fract((p3.x + p3.y) * p3.z);\n    }\n\n    ").concat(Fee,"\n    ").concat(Oee,"\n    ").concat(Dee,"\n  ");return t}(i);t.isPacked?(l=function(e,t,n){switch(e.length){case 0:return"\n    int getOutputCoords() {\n      return 0;\n    }\n  ";case 1:return function(e,t,n){const a=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)];if(1===a[0])return n?"\n      int getOutputCoords() {\n        return 2 * int(resultUV.x * ceil(float(outTexShape[1]) / 2.0));\n      }\n    ":"\n      int getOutputCoords() {\n        return 2 * int(resultUV.x * ".concat(a[1],".0);\n      }\n    ");if(1===a[1])return n?"\n      int getOutputCoords() {\n        return 2 * int(resultUV.y * ceil(float(outTexShape[0]) / 2.0));\n      }\n    ":"\n      int getOutputCoords() {\n        return 2 * int(resultUV.y * ".concat(a[0],".0);\n      }\n    ");if(n)return"\n    int getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n      return 2 * (resTexRC.x * packedTexShape[1] + resTexRC.y);\n    }\n  ";return"\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(".concat(a[0],", ").concat(a[1],"));\n      return 2 * (resTexRC.x * ").concat(a[1]," + resTexRC.y);\n    }\n  ")}(0,t,n);case 2:return function(e,t,n){const a=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)];if(GU(e,t))return n?"\n      ivec2 getOutputCoords() {\n        ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n        return 2 * ivec2(resultUV.yx * vec2(packedTexShape[0], packedTexShape[1]));\n      }\n    ":"\n      ivec2 getOutputCoords() {\n        return 2 * ivec2(resultUV.yx * vec2(".concat(a[0],", ").concat(a[1],"));\n      }\n    ");const r=Math.ceil(e[1]/2);if(n)return"\n    ivec2 getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      int texelsInLogicalRow = int(ceil(float(outShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n\n      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;\n      int r = 2 * (index / texelsInLogicalRow);\n      int c = imod(index, texelsInLogicalRow) * 2;\n\n      return ivec2(r, c);\n    }\n  ";return"\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(".concat(a[0],", ").concat(a[1],"));\n\n      int index = resTexRC.x * ").concat(a[1]," + resTexRC.y;\n      int r = 2 * (index / ").concat(r,");\n      int c = imod(index, ").concat(r,") * 2;\n\n      return ivec2(r, c);\n    }\n  ")}(e,t,n);case 3:return function(e,t,n){if(n)return"\n    ivec3 getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      int texelsInLogicalRow = int(ceil(float(outShape[2]) / 2.0));\n      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;\n\n      int b = index / texelsInBatch;\n      index -= b * texelsInBatch;\n\n      int r = 2 * (index / texelsInLogicalRow);\n      int c = imod(index, texelsInLogicalRow) * 2;\n\n      return ivec3(b, r, c);\n    }\n  ";const a=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)],r=Math.ceil(e[2]/2),o=r*Math.ceil(e[1]/2);return"\n    ivec3 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(".concat(a[0],", ").concat(a[1],"));\n      int index = resTexRC.x * ").concat(a[1]," + resTexRC.y;\n\n      int b = index / ").concat(o,";\n      index -= b * ").concat(o,";\n\n      int r = 2 * (index / ").concat(r,");\n      int c = imod(index, ").concat(r,") * 2;\n\n      return ivec3(b, r, c);\n    }\n  ")}(e,t,n);default:return function(e,t,n){if(n)return"\n    ivec4 getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;\n\n      int texelsInLogicalRow = int(ceil(float(outShape[3]) / 2.0));\n      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[2]) / 2.0));\n      int texelsInBatchN = texelsInBatch * outShape[1];\n\n      int b2 = index / texelsInBatchN;\n      index -= b2 * texelsInBatchN;\n\n      int b = index / texelsInBatch;\n      index -= b * texelsInBatch;\n\n      int r = 2 * (index / texelsInLogicalRow);\n      int c = imod(index, texelsInLogicalRow) * 2;\n\n      return ivec4(b2, b, r, c);\n    }\n  ";const a=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)],r=Math.ceil(e[e.length-1]/2),o=r*Math.ceil(e[e.length-2]/2);let s=o,i="",c="b, r, c";for(let l=2;l<e.length-1;l++)s*=e[e.length-l-1],i="\n      int b".concat(l," = index / ").concat(s,";\n      index -= b").concat(l," * ").concat(s,";\n    ")+i,c="b".concat(l,", ")+c;return"\n    ivec".concat(e.length," getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(").concat(a[0],", ").concat(a[1],"));\n      int index = resTexRC.x * ").concat(a[1]," + resTexRC.y;\n\n      ").concat(i,"\n\n      int b = index / ").concat(o,";\n      index -= b * ").concat(o,";\n\n      int r = 2 * (index / ").concat(r,");\n      int c = imod(index, ").concat(r,") * 2;\n\n      return ivec").concat(e.length,"(").concat(c,");\n    }\n  ")}(e,t,n)}}(t.logicalShape,s,n.enableShapeUniforms),u=function(e){return"\n    void setOutput(vec4 val) {\n      ".concat(e.output," = val;\n    }\n  ")}(i)):(l=function(e,t,n){switch(e.length){case 0:return"\n    int getOutputCoords() {\n      return 0;\n    }\n  ";case 1:return function(e,t,n){if(1===t[0])return n?"\n      int getOutputCoords() {\n        return int(resultUV.x * float(outTexShape[1]));\n      }\n    ":"\n      int getOutputCoords() {\n        return int(resultUV.x * ".concat(t[1],".0);\n      }\n    ");if(1===t[1])return n?"\n      int getOutputCoords() {\n        return int(resultUV.y * float(outTexShape[0]));\n      }\n    ":"\n      int getOutputCoords() {\n        return int(resultUV.y * ".concat(t[0],".0);\n      }\n    ");if(n)return"\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(outTexShape[0], outTexShape[1]));\n      return resTexRC.x * outTexShape[1] + resTexRC.y;\n    }\n  ";return"\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(".concat(t[0],", ").concat(t[1],"));\n      return resTexRC.x * ").concat(t[1]," + resTexRC.y;\n    }\n  ")}(0,t,n);case 2:return function(e,t,n){if(GU(e,t))return n?"\n      ivec2 getOutputCoords() {\n        return ivec2(resultUV.yx * vec2(outTexShape[0], outTexShape[1]));\n      }\n    ":"\n      ivec2 getOutputCoords() {\n        return ivec2(resultUV.yx * vec2(".concat(t[0],", ").concat(t[1],"));\n      }\n    ");if(1===e[1])return n?"\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(outTexShape[0], outTexShape[1]));\n        int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n        return ivec2(index, 0);\n      }\n    ":"\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(".concat(t[0],", ").concat(t[1],"));\n        int index = resTexRC.x * ").concat(t[1]," + resTexRC.y;\n        return ivec2(index, 0);\n      }\n    ");if(1===e[0])return n?"\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(outTexShape[0], outTexShape[1]));\n        int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n        return ivec2(0, index);\n      }\n    ":"\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(".concat(t[0],", ").concat(t[1],"));\n        int index = resTexRC.x * ").concat(t[1]," + resTexRC.y;\n        return ivec2(0, index);\n      }\n    ");if(n)return"\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(outTexShape[0], outTexShape[1]));\n      int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n      int r = index / outShape[1];\n      int c = index - r * outShape[1];\n      return ivec2(r, c);\n    }\n  ";return"\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(".concat(t[0],", ").concat(t[1],"));\n      int index = resTexRC.x * ").concat(t[1]," + resTexRC.y;\n      int r = index / ").concat(e[1],";\n      int c = index - r * ").concat(e[1],";\n      return ivec2(r, c);\n    }\n  ")}(e,t,n);case 3:return function(e,t,n){if(n){const t=See(["r","c","d"],e);return"\n  ivec3 getOutputCoords() {\n    ivec2 resTexRC = ivec2(resultUV.yx *\n                           vec2(outTexShape[0], outTexShape[1]));\n    int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n    ".concat(t,"\n    return ivec3(r, c, d);\n  }\n")}const a=Iee(["r","c","d"],e);return"\n    ivec3 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(".concat(t[0],", ").concat(t[1],"));\n      int index = resTexRC.x * ").concat(t[1]," + resTexRC.y;\n      ").concat(a,"\n      return ivec3(r, c, d);\n    }\n  ")}(e,t,n);case 4:return function(e,t,n){if(n){const t=See(["r","c","d","d2"],e);return"\n    ivec4 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(outTexShape[0], outTexShape[1]));\n      int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n      ".concat(t,"\n      return ivec4(r, c, d, d2);\n    }\n  ")}const a=Iee(["r","c","d","d2"],e);return"\n    ivec4 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(".concat(t[0],", ").concat(t[1],"));\n      int index = resTexRC.x * ").concat(t[1]," + resTexRC.y;\n      ").concat(a,"\n      return ivec4(r, c, d, d2);\n    }\n  ")}(e,t,n);case 5:return function(e,t){const n=Iee(["r","c","d","d2","d3"],e);return"\n    ivec5 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx * vec2(".concat(t[0],",\n                             ").concat(t[1],"));\n\n      int index = resTexRC.x * ").concat(t[1]," + resTexRC.y;\n\n      ").concat(n,"\n\n      ivec5 outShape = ivec5(r, c, d, d2, d3);\n      return outShape;\n    }\n  ")}(e,t);case 6:return function(e,t){const n=Iee(["r","c","d","d2","d3","d4"],e);return"\n    ivec6 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(".concat(t[0],", ").concat(t[1],"));\n      int index = resTexRC.x * ").concat(t[1]," + resTexRC.y;\n\n      ").concat(n,"\n\n      ivec6 result = ivec6(r, c, d, d2, d3, d4);\n      return result;\n    }\n  ")}(e,t);default:throw new Error("".concat(e.length,"-D output sampling is not yet supported"))}}(t.logicalShape,s,n.enableShapeUniforms),u=function(e){return"\n    void setOutput(float val) {\n      ".concat(e.output," = vec4(val, 0, 0, 0);\n    }\n  ")}(i)),n.packedInputs&&(d+=Mee);return[d,c,u,r,l,o,n.userCode].join("\n")}function _ee(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];const n=e.shapeInfo.logicalShape;switch(n.length){case 0:return function(e,t){const n=e.name,a="get"+n.charAt(0).toUpperCase()+n.slice(1);if(e.shapeInfo.isUniform)return"float ".concat(a,"() {return ").concat(n,";}");const[r,o]=e.shapeInfo.texShape;if(1===r&&1===o)return"\n      float ".concat(a,"() {\n        return sampleTexture(").concat(n,", halfCR);\n      }\n    ");const s=Lee(n);if(t)return"\n    float ".concat(a,"() {\n      vec2 uv = uvFromFlat(").concat(n,"TexShape[0], ").concat(n,"TexShape[1], ").concat(s,");\n      return sampleTexture(").concat(n,", uv);\n    }\n  ");const[i,c]=e.shapeInfo.texShape;return"\n    float ".concat(a,"() {\n      vec2 uv = uvFromFlat(").concat(i,", ").concat(c,", ").concat(s,");\n      return sampleTexture(").concat(n,", uv);\n    }\n  ")}(e,t);case 1:return function(e,t){const n=e.name,a="get"+n.charAt(0).toUpperCase()+n.slice(1);if(e.shapeInfo.isUniform)return"\n      float ".concat(a,"(int index) {\n        ").concat(Pee(e),"\n      }\n    ");const r=e.shapeInfo.texShape,o=r[0],s=r[1];if(1===s&&1===o)return"\n      float ".concat(a,"(int index) {\n        return sampleTexture(").concat(n,", halfCR);\n      }\n    ");const i=Lee(n);if(1===s)return t?"\n      float ".concat(a,"(int index) {\n        vec2 uv = vec2(0.5, (float(index + ").concat(i,") + 0.5) / float(").concat(n,"TexShape[0]));\n        return sampleTexture(").concat(n,", uv);\n      }\n    "):"\n      float ".concat(a,"(int index) {\n        vec2 uv = vec2(0.5, (float(index + ").concat(i,") + 0.5) / ").concat(o,".0);\n        return sampleTexture(").concat(n,", uv);\n      }\n    ");if(1===o)return t?"\n      float ".concat(a,"(int index) {\n        vec2 uv = vec2((float(index + ").concat(i,") + 0.5) / float(").concat(n,"TexShape[1]), 0.5);\n        return sampleTexture(").concat(n,", uv);\n      }\n    "):"\n      float ".concat(a,"(int index) {\n        vec2 uv = vec2((float(index + ").concat(i,") + 0.5) / ").concat(s,".0, 0.5);\n        return sampleTexture(").concat(n,", uv);\n      }\n    ");if(t)return"\n    float ".concat(a,"(int index) {\n      vec2 uv = uvFromFlat(").concat(n,"TexShape[0], ").concat(n,"TexShape[1], index + ").concat(i,");\n      return sampleTexture(").concat(n,", uv);\n    }\n  ");return"\n    float ".concat(a,"(int index) {\n      vec2 uv = uvFromFlat(").concat(o,", ").concat(s,", index + ").concat(i,");\n      return sampleTexture(").concat(n,", uv);\n    }\n  ")}(e,t);case 2:return function(e,t){const n=e.shapeInfo.logicalShape,a=e.name,r="get"+a.charAt(0).toUpperCase()+a.slice(1),o=e.shapeInfo.texShape;if(null!=o&&GU(n,o)){if(t)return"\n      float ".concat(r,"(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(").concat(a,"TexShape[1], ").concat(a,"TexShape[0]);\n        return sampleTexture(").concat(a,", uv);\n      }\n    ");const e=o[0],n=o[1];return"\n    float ".concat(r,"(int row, int col) {\n      vec2 uv = (vec2(col, row) + halfCR) / vec2(").concat(n,".0, ").concat(e,".0);\n      return sampleTexture(").concat(a,", uv);\n    }\n  ")}const{newShape:s,keptDims:i}=QU(n),c=s;if(c.length<n.length){const n=Wee(e,c),a=["row","col"];return"\n      ".concat(_ee(n,t),"\n      float ").concat(r,"(int row, int col) {\n        return ").concat(r,"(").concat(Vee(a,i),");\n      }\n    ")}if(e.shapeInfo.isUniform)return"\n      float ".concat(r,"(int row, int col) {\n        int index = round(dot(vec2(row, col), vec2(").concat(n[1],", 1)));\n        ").concat(Pee(e),"\n      }\n    ");const l=o[0],u=o[1],d=Lee(a);if(1===u)return t?"\n      float ".concat(r,"(int row, int col) {\n        float index = dot(vec3(row, col, ").concat(d,"), vec3(").concat(a,"Shape[1], 1, 1));\n        vec2 uv = vec2(0.5, (index + 0.5) / float(").concat(a,"TexShape[0]));\n        return sampleTexture(").concat(a,", uv);\n      }\n    "):"\n    float ".concat(r,"(int row, int col) {\n      float index = dot(vec3(row, col, ").concat(d,"), vec3(").concat(n[1],", 1, 1));\n      vec2 uv = vec2(0.5, (index + 0.5) / ").concat(l,".0);\n      return sampleTexture(").concat(a,", uv);\n    }\n  ");if(1===l)return t?"\n      float ".concat(r,"(int row, int col) {\n        float index = dot(vec3(row, col, ").concat(d,"), vec3(").concat(a,"Shape[1], 1, 1));\n        vec2 uv = vec2((index + 0.5) / float(").concat(a,"TexShape[1]), 0.5);\n        return sampleTexture(").concat(a,", uv);\n      }\n    "):"\n    float ".concat(r,"(int row, int col) {\n      float index = dot(vec3(row, col, ").concat(d,"), vec3(").concat(n[1],", 1, 1));\n      vec2 uv = vec2((index + 0.5) / ").concat(u,".0, 0.5);\n      return sampleTexture(").concat(a,", uv);\n    }\n  ");if(t)return"\n      float ".concat(r,"(int row, int col) {\n        // Explicitly use integer operations as dot() only works on floats.\n        int index = row * ").concat(a,"Shape[1] + col + ").concat(d,";\n        vec2 uv = uvFromFlat(").concat(a,"TexShape[0], ").concat(a,"TexShape[1], index);\n        return sampleTexture(").concat(a,", uv);\n      }\n    ");return"\n  float ".concat(r,"(int row, int col) {\n    // Explicitly use integer operations as dot() only works on floats.\n    int index = row * ").concat(n[1]," + col + ").concat(d,";\n    vec2 uv = uvFromFlat(").concat(l,", ").concat(u,", index);\n    return sampleTexture(").concat(a,", uv);\n  }\n")}(e,t);case 3:return function(e,t){const n=e.shapeInfo.logicalShape,a=e.name,r="get"+a.charAt(0).toUpperCase()+a.slice(1),o=n[1]*n[2],s=n[2],{newShape:i,keptDims:c}=QU(n),l=i;if(l.length<n.length){const n=Wee(e,l),a=["row","col","depth"];return"\n        ".concat(_ee(n,t),"\n        float ").concat(r,"(int row, int col, int depth) {\n          return ").concat(r,"(").concat(Vee(a,c),");\n        }\n      ")}if(e.shapeInfo.isUniform)return"\n      float ".concat(r,"(int row, int col, int depth) {\n        int index = round(dot(vec3(row, col, depth),\n                          vec3(").concat(o,", ").concat(s,", 1)));\n        ").concat(Pee(e),"\n      }\n    ");const u=e.shapeInfo.texShape,d=u[0],h=u[1],p=e.shapeInfo.flatOffset;if(h===o&&null==p)return t?"\n      float ".concat(r,"(int row, int col, int depth) {\n        int stride1 = ").concat(a,"Shape[2];\n        float texR = float(row);\n        float texC = dot(vec2(col, depth), vec2(stride1, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(").concat(a,"TexShape[1], ").concat(a,"TexShape[0]);\n        return sampleTexture(").concat(a,", uv);\n      }\n    "):"\n        float ".concat(r,"(int row, int col, int depth) {\n          float texR = float(row);\n          float texC = dot(vec2(col, depth), vec2(").concat(s,", 1));\n          vec2 uv = (vec2(texC, texR) + halfCR) /\n                     vec2(").concat(h,".0, ").concat(d,".0);\n          return sampleTexture(").concat(a,", uv);\n        }\n      ");if(h===s&&null==p)return t?"\n      float ".concat(r,"(int row, int col, int depth) {\n        float texR = dot(vec2(row, col), vec2(").concat(a,"Shape[1], 1));\n        float texC = float(depth);\n        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(").concat(a,"TexShape[1], ").concat(a,"TexShape[0]);\n        return sampleTexture(").concat(a,", uv);\n      }\n    "):"\n    float ".concat(r,"(int row, int col, int depth) {\n      float texR = dot(vec2(row, col), vec2(").concat(n[1],", 1));\n      float texC = float(depth);\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(").concat(h,".0, ").concat(d,".0);\n      return sampleTexture(").concat(a,", uv);\n    }\n  ");const f=Lee(a);if(t)return"\n    float ".concat(r,"(int row, int col, int depth) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int stride0 = ").concat(a,"Shape[1] * ").concat(a,"Shape[2];\n      int stride1 = ").concat(a,"Shape[2];\n      int index = row * stride0 + col * stride1 + depth + ").concat(f,";\n      vec2 uv = uvFromFlat(").concat(a,"TexShape[0], ").concat(a,"TexShape[1], index);\n      return sampleTexture(").concat(a,", uv);\n    }\n    ");return"\n      float ".concat(r,"(int row, int col, int depth) {\n        // Explicitly use integer operations as dot() only works on floats.\n        int index = row * ").concat(o," + col * ").concat(s," + depth + ").concat(f,";\n        vec2 uv = uvFromFlat(").concat(d,", ").concat(h,", index);\n        return sampleTexture(").concat(a,", uv);\n      }\n  ")}(e,t);case 4:return function(e,t){const n=e.shapeInfo.logicalShape,a=e.name,r="get"+a.charAt(0).toUpperCase()+a.slice(1),o=n[3],s=n[2]*o,i=n[1]*s,{newShape:c,keptDims:l}=QU(n);if(c.length<n.length){const n=Wee(e,c),a=["row","col","depth","depth2"];return"\n      ".concat(_ee(n,t),"\n      float ").concat(r,"(int row, int col, int depth, int depth2) {\n        return ").concat(r,"(").concat(Vee(a,l),");\n      }\n    ")}if(e.shapeInfo.isUniform)return"\n      float ".concat(r,"(int row, int col, int depth, int depth2) {\n        int index = round(dot(vec4(row, col, depth, depth2),\n                          vec4(").concat(i,", ").concat(s,", ").concat(o,", 1)));\n        ").concat(Pee(e),"\n      }\n    ");const u=e.shapeInfo.flatOffset,d=e.shapeInfo.texShape,h=d[0],p=d[1],f="int stride2 = ".concat(a,"Shape[3];"),m="int stride1 = ".concat(a,"Shape[2] * stride2;"),g="int stride0 = ".concat(a,"Shape[1] * stride1;");if(p===i&&null==u)return t?"\n      float ".concat(r,"(int row, int col, int depth, int depth2) {\n        ").concat(f,"\n        ").concat(m,"\n        float texR = float(row);\n        float texC =\n            dot(vec3(col, depth, depth2),\n                vec3(stride1, stride2, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(").concat(a,"TexShape[1], ").concat(a,"TexShape[0]);\n        return sampleTexture(").concat(a,", uv);\n      }\n    "):"\n      float ".concat(r,"(int row, int col, int depth, int depth2) {\n        float texR = float(row);\n        float texC =\n            dot(vec3(col, depth, depth2),\n                vec3(").concat(s,", ").concat(o,", 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(").concat(p,".0, ").concat(h,".0);\n        return sampleTexture(").concat(a,", uv);\n      }\n    ");if(p===o&&null==u)return t?"\n      float ".concat(r,"(int row, int col, int depth, int depth2) {\n        float texR = dot(vec3(row, col, depth),\n                         vec3(").concat(a,"Shape[1] * ").concat(a,"Shape[2], ").concat(a,"Shape[2], 1));\n        float texC = float(depth2);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(").concat(a,"TexShape[1], ").concat(a,"TexShape[0]);\n        return sampleTexture(").concat(a,", uv);\n      }\n    "):"\n      float ".concat(r,"(int row, int col, int depth, int depth2) {\n        float texR = dot(vec3(row, col, depth),\n                         vec3(").concat(n[1]*n[2],", ").concat(n[2],", 1));\n        float texC = float(depth2);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(").concat(p,".0, ").concat(h,".0);\n        return sampleTexture(").concat(a,", uv);\n      }\n    ");const b=Lee(a);if(t)return"\n    float ".concat(r,"(int row, int col, int depth, int depth2) {\n      // Explicitly use integer operations as dot() only works on floats.\n      ").concat(f,"\n      ").concat(m,"\n      ").concat(g,"\n      int index = row * stride0 + col * stride1 +\n          depth * stride2 + depth2;\n      vec2 uv = uvFromFlat(").concat(a,"TexShape[0], ").concat(a,"TexShape[1], index + ").concat(b,");\n      return sampleTexture(").concat(a,", uv);\n    }\n  ");return"\n    float ".concat(r,"(int row, int col, int depth, int depth2) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ").concat(i," + col * ").concat(s," +\n          depth * ").concat(o," + depth2;\n      vec2 uv = uvFromFlat(").concat(h,", ").concat(p,", index + ").concat(b,");\n      return sampleTexture(").concat(a,", uv);\n    }\n  ")}(e,t);case 5:return function(e){const t=e.shapeInfo.logicalShape,n=e.name,a="get"+n.charAt(0).toUpperCase()+n.slice(1),r=t[4],o=t[3]*r,s=t[2]*o,i=t[1]*s,{newShape:c,keptDims:l}=QU(t);if(c.length<t.length){const t=Wee(e,c),n=["row","col","depth","depth2","depth3"];return"\n      ".concat(_ee(t),"\n      float ").concat(a,"(int row, int col, int depth, int depth2, int depth3) {\n        return ").concat(a,"(").concat(Vee(n,l),");\n      }\n    ")}if(e.shapeInfo.isUniform)return"\n      float ".concat(a,"(int row, int col, int depth, int depth2, int depth3) {\n        float index = dot(\n          vec4(row, col, depth, depth2),\n          vec4(").concat(i,", ").concat(s,", ").concat(o,", ").concat(r,")) +\n          depth3;\n        ").concat(Pee(e),"\n      }\n    ");const u=e.shapeInfo.flatOffset,d=e.shapeInfo.texShape,h=d[0],p=d[1];if(p===i&&null==u)return"\n      float ".concat(a,"(int row, int col, int depth, int depth2, int depth3) {\n        int texR = row;\n        float texC = dot(vec4(col, depth, depth2, depth3),\n                         vec4(").concat(s,", ").concat(o,", ").concat(r,", 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(").concat(p,".0, ").concat(h,".0);\n        return sampleTexture(").concat(n,", uv);\n      }\n    ");if(p===r&&null==u)return"\n      float ".concat(a,"(int row, int col, int depth, int depth2, int depth3) {\n        float texR = dot(\n          vec4(row, col, depth, depth2),\n          vec4(").concat(t[1]*t[2]*t[3],",\n               ").concat(t[2]*t[3],", ").concat(t[3],", 1));\n        int texC = depth3;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(").concat(p,".0, ").concat(h,".0);\n        return sampleTexture(").concat(n,", uv);\n      }\n    ");const f=Lee(n);return"\n    float ".concat(a,"(int row, int col, int depth, int depth2, int depth3) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ").concat(i," + col * ").concat(s," + depth * ").concat(o," +\n          depth2 * ").concat(r," + depth3 + ").concat(f,";\n      vec2 uv = uvFromFlat(").concat(h,", ").concat(p,", index);\n      return sampleTexture(").concat(n,", uv);\n    }\n  ")}(e);case 6:return function(e){const t=e.shapeInfo.logicalShape,n=e.name,a="get"+n.charAt(0).toUpperCase()+n.slice(1),{newShape:r,keptDims:o}=QU(t);if(r.length<t.length){const t=Wee(e,r),n=["row","col","depth","depth2","depth3","depth4"];return"\n      ".concat(_ee(t),"\n      float ").concat(a,"(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        return ").concat(a,"(").concat(Vee(n,o),");\n      }\n    ")}const s=t[5],i=t[4]*s,c=t[3]*i,l=t[2]*c,u=t[1]*l;if(e.shapeInfo.isUniform)return"\n      float ".concat(a,"(int row, int col, int depth,\n                  int depth2, int depth3, int depth4) {\n        int index = round(dot(\n          vec4(row, col, depth, depth2),\n          vec4(").concat(u,", ").concat(l,", ").concat(c,", ").concat(i,")) +\n          dot(\n            vec2(depth3, depth4),\n            vec2(").concat(s,", 1)));\n        ").concat(Pee(e),"\n      }\n    ");const d=e.shapeInfo.flatOffset,h=e.shapeInfo.texShape,p=h[0],f=h[1];if(f===u&&null==d)return"\n      float ".concat(a,"(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        int texR = row;\n        float texC = dot(vec4(col, depth, depth2, depth3),\n          vec4(").concat(l,", ").concat(c,", ").concat(i,", ").concat(s,")) +\n               float(depth4);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(").concat(f,".0, ").concat(p,".0);\n        return sampleTexture(").concat(n,", uv);\n      }\n    ");if(f===s&&null==d)return"\n      float ".concat(a,"(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        float texR = dot(vec4(row, col, depth, depth2),\n          vec4(").concat(t[1]*t[2]*t[3]*t[4],",\n               ").concat(t[2]*t[3]*t[4],",\n               ").concat(t[3]*t[4],",\n               ").concat(t[4],")) + float(depth3);\n        int texC = depth4;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(").concat(f,".0, ").concat(p,".0);\n        return sampleTexture(").concat(n,", uv);\n      }\n    ");const m=Lee(n);return"\n    float ".concat(a,"(int row, int col, int depth,\n                  int depth2, int depth3, int depth4) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ").concat(u," + col * ").concat(l," + depth * ").concat(c," +\n          depth2 * ").concat(i," + depth3 * ").concat(s," + depth4 + ").concat(m,";\n      vec2 uv = uvFromFlat(").concat(p,", ").concat(f,", index);\n      return sampleTexture(").concat(n,", uv);\n    }\n  ")}(e);default:throw new Error("".concat(n.length,"-D input sampling")+" is not yet supported")}}function Aee(e,t){switch(e.shapeInfo.logicalShape.length){case 0:return function(e){const t=e.name,n="get"+t.charAt(0).toUpperCase()+t.slice(1),a=kee();return"\n    vec4 ".concat(n,"() {\n      return ").concat(a.texture2D,"(").concat(t,", halfCR);\n    }\n  ")}(e);case 1:return function(e,t){const n=e.name,a="get"+n.charAt(0).toUpperCase()+n.slice(1),r=e.shapeInfo.texShape,o=kee();if(t)return"\n    vec4 ".concat(a,"(int index) {\n      ivec2 packedTexShape = ivec2(ceil(float(").concat(n,"TexShape[0]) / 2.0), ceil(float(").concat(n,"TexShape[1]) / 2.0));\n      vec2 uv = packedUVfrom1D(\n        packedTexShape[0], packedTexShape[1], index);\n      return ").concat(o.texture2D,"(").concat(n,", uv);\n    }\n  ");const s=[Math.ceil(r[0]/2),Math.ceil(r[1]/2)];return"\n    vec4 ".concat(a,"(int index) {\n      vec2 uv = packedUVfrom1D(\n        ").concat(s[0],", ").concat(s[1],", index);\n      return ").concat(o.texture2D,"(").concat(n,", uv);\n    }\n  ")}(e,t);case 2:return function(e,t){const n=e.shapeInfo.logicalShape,a=e.name,r="get"+a.charAt(0).toUpperCase()+a.slice(1),o=e.shapeInfo.texShape,s=o[0],i=o[1],c=kee();if(null!=o&&GU(n,o))return t?"\n      vec4 ".concat(r,"(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(").concat(a,"TexShape[1], ").concat(a,"TexShape[0]);\n\n        return ").concat(c.texture2D,"(").concat(a,", uv);\n      }\n    "):"\n      vec4 ".concat(r,"(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(").concat(i,".0, ").concat(s,".0);\n\n        return ").concat(c.texture2D,"(").concat(a,", uv);\n      }\n    ");if(t)return"\n    vec4 ".concat(r,"(int row, int col) {\n      ivec2 packedTexShape = ivec2(ceil(float(").concat(a,"TexShape[0]) / 2.0), ceil(float(").concat(a,"TexShape[1]) / 2.0));\n      int valuesPerRow = int(ceil(float(").concat(a,"Shape[1]) / 2.0));\n      vec2 uv = packedUVfrom2D(valuesPerRow, packedTexShape[0], packedTexShape[1], row, col);\n      return ").concat(c.texture2D,"(").concat(a,", uv);\n    }\n  ");const l=[Math.ceil(o[0]/2),Math.ceil(o[1]/2)],u=Math.ceil(n[1]/2);return"\n    vec4 ".concat(r,"(int row, int col) {\n      vec2 uv = packedUVfrom2D(").concat(u,", ").concat(l[0],", ").concat(l[1],", row, col);\n      return ").concat(c.texture2D,"(").concat(a,", uv);\n    }\n  ")}(e,t);case 3:return function(e,t){const n=e.shapeInfo.logicalShape,a=e.name,r="get"+a.charAt(0).toUpperCase()+a.slice(1),o=e.shapeInfo.texShape,s=[Math.ceil(o[0]/2),Math.ceil(o[1]/2)];if(1===n[0]){const a=[1,2],o=Wee(e,n.slice(1)),s=["b","row","col"];return"\n        ".concat(Aee(o,t),"\n        vec4 ").concat(r,"(int b, int row, int col) {\n          return ").concat(r,"(").concat(Vee(s,a),");\n        }\n      ")}const i=kee();if(t)return"\n    vec4 ".concat(r,"(int b, int row, int col) {\n      ivec2 packedTexShape = ivec2(ceil(float(").concat(a,"TexShape[0]) / 2.0), ceil(float(").concat(a,"TexShape[1]) / 2.0));\n      int valuesPerRow = int(ceil(float(").concat(a,"Shape[2]) / 2.0));\n      int texelsInBatch = valuesPerRow * int(ceil(float(").concat(a,"Shape[1]) / 2.0));\n      vec2 uv = packedUVfrom3D(\n        packedTexShape[0], packedTexShape[1], texelsInBatch, valuesPerRow, b, row, col);\n      return ").concat(i.texture2D,"(").concat(a,", uv);\n    }\n  ");const c=s[0],l=s[1],u=Math.ceil(n[2]/2),d=u*Math.ceil(n[1]/2);return"\n    vec4 ".concat(r,"(int b, int row, int col) {\n      vec2 uv = packedUVfrom3D(\n        ").concat(c,", ").concat(l,", ").concat(d,", ").concat(u,", b, row, col);\n      return ").concat(i.texture2D,"(").concat(a,", uv);\n    }\n  ")}(e,t);default:return function(e,t){const n=e.name,a="get"+n.charAt(0).toUpperCase()+n.slice(1),r=kee();if(t)return"\n    vec4 ".concat(a,"(int b2, int b, int row, int col) {\n      int valuesPerRow = int(ceil(float(").concat(n,"Shape[3]) / 2.0));\n      int texelsInBatch = valuesPerRow * int(ceil(float(").concat(n,"Shape[2]) / 2.0));\n      int index = b * texelsInBatch + (row / 2) * valuesPerRow + (col / 2);\n      texelsInBatch *= ").concat(n,"Shape[1];\n      index = b2 * texelsInBatch + index;\n      ivec2 packedTexShape = ivec2(ceil(float(").concat(n,"TexShape[0]) / 2.0), ceil(float(").concat(n,"TexShape[1]) / 2.0));\n      int texR = index / packedTexShape[1];\n      int texC = index - texR * packedTexShape[1];\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(packedTexShape[1], packedTexShape[0]); return ").concat(r.texture2D,"(").concat(n,", uv);\n    }\n  ");const o=e.shapeInfo.logicalShape,s=o.length,i=e.shapeInfo.texShape,c=[Math.ceil(i[0]/2),Math.ceil(i[1]/2)],l=c[0],u=c[1],d=Math.ceil(o[s-1]/2);let h=d*Math.ceil(o[s-2]/2),p="int b, int row, int col",f="b * ".concat(h," + (row / 2) * ").concat(d," + (col / 2)");for(let m=2;m<s-1;m++)p="int b".concat(m,", ")+p,h*=o[s-m-1],f="b".concat(m," * ").concat(h," + ")+f;return"\n    vec4 ".concat(a,"(").concat(p,") {\n      int index = ").concat(f,";\n      int texR = index / ").concat(u,";\n      int texC = index - texR * ").concat(u,";\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(").concat(u,", ").concat(l,");\n      return ").concat(r.texture2D,"(").concat(n,", uv);\n    }\n  ")}(e,t)}}const Fee="\nvec2 uvFromFlat(int texNumR, int texNumC, int index) {\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\nvec2 packedUVfrom1D(int texNumR, int texNumC, int index) {\n  int texelIndex = index / 2;\n  int texR = texelIndex / texNumC;\n  int texC = texelIndex - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",Oee="\nvec2 packedUVfrom2D(int texelsInLogicalRow, int texNumR,\n  int texNumC, int row, int col) {\n  int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);\n  int texR = texelIndex / texNumC;\n  int texC = texelIndex - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",Dee="\nvec2 packedUVfrom3D(int texNumR, int texNumC,\n    int texelsInBatch, int texelsInLogicalRow, int b,\n    int row, int col) {\n  int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",Mee="\n  float getChannel(vec4 frag, vec2 innerDims) {\n    vec2 modCoord = mod(innerDims, 2.);\n    return modCoord.x == 0. ?\n      (modCoord.y == 0. ? frag.r : frag.g) :\n      (modCoord.y == 0. ? frag.b : frag.a);\n  }\n  float getChannel(vec4 frag, int dim) {\n    float modCoord = mod(float(dim), 2.);\n    return modCoord == 0. ? frag.r : frag.g;\n  }\n";function Lee(e){return"offset".concat(e)}function Pee(e){const t=e.name,n=UU(e.shapeInfo.logicalShape);return n<2?"return ".concat(t,";"):"\n    for (int i = 0; i < ".concat(n,"; i++) {\n      if (i == index) {\n        return ").concat(t,"[i];\n      }\n    }\n  ")}function zee(e){if(e<=1)return"int";if(2===e)return"ivec2";if(3===e)return"ivec3";if(4===e)return"ivec4";if(5===e)return"ivec5";if(6===e)return"ivec6";throw Error("GPU for rank ".concat(e," is not yet supported"))}function Bee(e,t,n){const{newShape:a,keptDims:r}=QU(t),o=t.length,s=e&&3===o&&1===t[0],i=s?t.slice(1):a,c=!e&&o>1&&!GU(t,n)&&a.length<o||s;return{useSqueezeShape:c,uniformShape:c?i:t,keptDims:r}}function Wee(e,t){const n=JSON.parse(JSON.stringify(e));return n.shapeInfo.logicalShape=t,n}function Vee(e,t){return t.map((t=>e[t])).join(", ")}function Uee(e,t,n,a){const r=n.map(((e,n)=>{const a={logicalShape:e.shape,texShape:e.isUniform?null:e.texData.texShape,isUniform:e.isUniform,isPacked:!e.isUniform&&e.texData.isPacked,flatOffset:null};return null!=e.texData&&null!=e.texData.slice&&e.texData.slice.flatOffset>0&&(a.flatOffset=e.texData.slice.flatOffset),{name:t.variableNames[n],shapeInfo:a}})),o=r.map((e=>e.shapeInfo)),s={logicalShape:a.shape,texShape:a.texData.texShape,isUniform:!1,isPacked:a.texData.isPacked,flatOffset:null},i=Ree(r,s,t),c=function(e,t){const n=iee(e,(()=>e.createShader(e.FRAGMENT_SHADER)),"Unable to create fragment WebGLShader.");if(Q9(e,(()=>e.shaderSource(n,t))),Q9(e,(()=>e.compileShader(n))),yG().get("ENGINE_COMPILE_ONLY"))return n;if(!1===e.getShaderParameter(n,e.COMPILE_STATUS))throw eee(t,e.getShaderInfoLog(n)),new Error("Failed to compile fragment shader.");return n}(e.gl,i),l=e.createProgram(c);return yG().get("ENGINE_COMPILE_ONLY")?{program:t,fragmentShader:c,source:i,webGLProgram:l,inShapeInfos:o,outShapeInfo:s,variablesLocations:null,customUniformLocations:null,infLoc:null,nanLoc:null,outShapeLocation:null,outShapeStridesLocation:null,outTexShapeLocation:null}:(e.buildVao(l),Object.assign({program:t,fragmentShader:c,source:i,webGLProgram:l,inShapeInfos:o,outShapeInfo:s},Gee(e,t,l)))}function Gee(e,t,n){const a=[],r=[];let o,s,i,c=null,l=null;l=e.getUniformLocation(n,"NAN",!1),1===yG().getNumber("WEBGL_VERSION")&&(c=e.getUniformLocation(n,"INFINITY",!1));const u=!1;for(const d of t.variableNames){const r={name:d,uniform:e.getUniformLocation(n,d,u),offset:e.getUniformLocation(n,"offset".concat(d),u)};t.enableShapeUniforms&&(r.shape=e.getUniformLocation(n,"".concat(d,"Shape"),u),r.texShape=e.getUniformLocation(n,"".concat(d,"TexShape"),u)),a.push(r)}if(t.enableShapeUniforms&&(o=e.getUniformLocation(n,"outShape",u),i=e.getUniformLocation(n,"outShapeStrides",u),s=e.getUniformLocation(n,"outTexShape",u)),t.customUniforms)for(const d of t.customUniforms)r.push(e.getUniformLocation(n,d.name,u));return{variablesLocations:a,customUniformLocations:r,infLoc:c,nanLoc:l,outShapeLocation:o,outShapeStridesLocation:i,outTexShapeLocation:s}}function Hee(e,t){if(e.length!==t.length)throw Error("Binary was compiled with ".concat(e.length," inputs, but ")+"was executed with ".concat(t.length," inputs"));e.forEach(((e,n)=>{const a=e.logicalShape,r=t[n],o=r.shape;if(!GU(a,o))throw Error("Binary was compiled with different shapes than "+"the current args. Shapes ".concat(a," and ").concat(o," must match"));if(e.isUniform&&r.isUniform)return;const s=e.texShape,i=r.isUniform?null:r.texData.texShape;if(!GU(s,i))throw Error("Binary was compiled with different texture shapes than the"+" current args. Shape ".concat(s," and ").concat(i," must match"))}))}function jee(e){return yG().getBool("WEBGL_USE_SHAPES_UNIFORMS")&&e<=4}class Kee{constructor(e){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outPackingScheme=G9.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];const t=kee();this.outputShape=e,this.enableShapeUniforms=jee(this.outputShape.length),this.userCode="\n      ivec3 outCoordsFromFlatIndex(int index) {\n        ".concat(this.enableShapeUniforms?See(["r","c","d"],e):Iee(["r","c","d"],e),"\n        return ivec3(r, c, d);\n      }\n\n      void main() {\n        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));\n        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);\n\n        vec4 result = vec4(0.);\n\n        for (int i=0; i<4; i++) {\n          int flatIndex = index + i;\n          ivec3 rc = outCoordsFromFlatIndex(flatIndex);\n          result[i] = getA(rc.x, rc.y, rc.z);\n        }\n\n        ").concat(t.output," = result;\n      }\n    ")}}class qee{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outPackingScheme=G9.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];const t=kee();this.outputShape=e,this.enableShapeUniforms=jee(this.outputShape.length),this.userCode="\n      ivec3 outCoordsFromFlatIndex(int index) {\n        ".concat(this.enableShapeUniforms?See(["r","c","d"],e):Iee(["r","c","d"],e),"\n        return ivec3(r, c, d);\n      }\n\n      void main() {\n        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));\n        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);\n\n        vec4 result = vec4(0.);\n\n        for (int i=0; i<4; i++) {\n          int flatIndex = index + i;\n          ivec3 rc = outCoordsFromFlatIndex(flatIndex);\n          result[i] = getChannel(getA(rc.x, rc.y, rc.z), vec2(rc.y, rc.z));\n        }\n\n        ").concat(t.output," = result;\n      }\n    ")}}class Xee{constructor(e){this.variableNames=["A"],this.outTexUsage=H9.DOWNLOAD;const t=kee();this.outputShape=e,this.userCode="\n      ".concat(Tee,"\n\n      void main() {\n        float x = getAAtOutCoords();\n        ").concat(t.output," = encode_float(x);\n      }\n    ")}}class Yee{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outTexUsage=H9.DOWNLOAD;const t=kee();this.outputShape=e,this.userCode="\n      ".concat(Tee,"\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n        float x = getChannel(getAAtOutCoords(), vec2(coords.y, coords.z));\n        ").concat(t.output," = encode_float(x);\n      }\n    ")}}const Qee={R:0,G:1,B:2,A:3};class Jee{constructor(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1],n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"RGBA";this.variableNames=["A"],this.customUniforms=[{name:"texShape",type:"ivec2"}];const a=kee();this.outputShape=e,this.enableShapeUniforms=jee(this.outputShape.length);let r="result";t&&(r="floor(result * 255. + 0.5)");let o="";for(let s=0;s<n.length;s++){const e=n[s];o+="\n          if(offset == ".concat(s,") {\n            result = values[").concat(Qee[e],"];\n          }")}this.userCode="\n      ".concat(this.enableShapeUniforms?"\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;\n  }\n":Cee(e),"\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int flatIndex = getFlatIndex(coords);\n        float result = 0.;\n        int offset = imod(flatIndex, ").concat(n.length,");\n\n        flatIndex = idiv(flatIndex, ").concat(n.length,", 1.);\n\n        int r = flatIndex / texShape[1];\n        if (r < texShape[0]) {\n          int c = imod(flatIndex, texShape[1]);\n          vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);\n          vec4 values = ").concat(a.texture2D,"(A, uv);\n          ").concat(o,"\n        }\n        ").concat(a.output," = vec4(").concat(r,", 0., 0., 0.);\n      }\n    ")}}class Zee{constructor(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.customUniforms=[{name:"texShape",type:"ivec2"}];const n=kee();this.outputShape=e,this.enableShapeUniforms=jee(this.outputShape.length);let a="",r="result";t&&(r="floor(result * 255. + 0.5)");for(let o=0;o<=1;o++)for(let t=0;t<=1;t++){const r=2*o+t;a+="\n          localCoords = coords;\n          if(localCoords[2] + ".concat(t," < ").concat(this.enableShapeUniforms?"outShape[2]":"".concat(e[2]),") {\n          localCoords[2] += ").concat(t,";\n          if (localCoords[1] + ").concat(o," < ").concat(this.enableShapeUniforms?"outShape[1]":"".concat(e[1]),") {\n            localCoords[1] += ").concat(o,";\n\n            flatIndex = getFlatIndex(localCoords);\n            offset = imod(flatIndex, 4);\n\n            flatIndex = idiv(flatIndex, 4, 1.);\n\n            int r = flatIndex / texShape[1];\n            int c = imod(flatIndex, texShape[1]);\n            vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);\n            values = ").concat(n.texture2D,"(A, uv);\n\n            if (offset == 0) {\n              result[").concat(r,"] = values[0];\n            } else if (offset == 1) {\n              result[").concat(r,"] = values[1];\n            } else if (offset == 2) {\n              result[").concat(r,"] = values[2];\n            } else {\n              result[").concat(r,"] = values[3];\n            }\n          }\n        }\n        ")}this.userCode="\n        ".concat(this.enableShapeUniforms?"\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;\n  }\n":Cee(e),"\n\n        void main() {\n          ivec3 coords = getOutputCoords();\n\n          vec4 result = vec4(0.);\n          int flatIndex, r, c, offset;\n          ivec3 localCoords;\n          vec2 uv;\n          vec4 values;\n\n          ").concat(a,"\n\n          ").concat(n.output," = ").concat(r,";\n        }\n    ")}}function $ee(e){const t=kee();return function(e,t){const n=iee(e,(()=>e.createShader(e.VERTEX_SHADER)),"Unable to create vertex WebGLShader.");if(Q9(e,(()=>e.shaderSource(n,t))),Q9(e,(()=>e.compileShader(n))),!1===e.getShaderParameter(n,e.COMPILE_STATUS))throw console.log(e.getShaderInfoLog(n)),new Error("Failed to compile vertex shader.");return n}(e,"".concat(t.version,"\n    precision highp float;\n    ").concat(t.attribute," vec3 clipSpacePos;\n    ").concat(t.attribute," vec2 uv;\n    ").concat(t.varyingVs," vec2 resultUV;\n\n    void main() {\n      gl_Position = vec4(clipSpacePos, 1);\n      resultUV = uv;\n    }"))}function ete(e){return function(e,t){const n=iee(e,(()=>e.createBuffer()),"Unable to create WebGLBuffer");return Q9(e,(()=>e.bindBuffer(e.ARRAY_BUFFER,n))),Q9(e,(()=>e.bufferData(e.ARRAY_BUFFER,t,e.STATIC_DRAW))),n}(e,new Float32Array([-1,1,0,0,1,-1,-1,0,0,0,1,1,0,1,1,1,-1,0,1,0]))}function tte(e){return function(e,t){const n=iee(e,(()=>e.createBuffer()),"Unable to create WebGLBuffer");return Q9(e,(()=>e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,n))),Q9(e,(()=>e.bufferData(e.ELEMENT_ARRAY_BUFFER,t,e.STATIC_DRAW))),n}(e,new Uint16Array([0,1,2,2,1,3]))}function nte(e,t,n,a,r,o){!function(e,t){const n=yG().getNumber("WEBGL_MAX_TEXTURE_SIZE");if(e<=0||t<=0){const n="[".concat(e,"x").concat(t,"]");throw new Error("Requested texture size "+n+" is invalid.")}if(e>n||t>n){const a="[".concat(e,"x").concat(t,"]"),r="[".concat(n,"x").concat(n,"]");throw new Error("Requested texture size "+a+" greater than WebGL maximum on this browser / GPU "+r+".")}}(t,n);const s=function(e){return iee(e,(()=>e.createTexture()),"Unable to create WebGLTexture.")}(e),i=e.TEXTURE_2D;return Q9(e,(()=>e.bindTexture(i,s))),Q9(e,(()=>e.texParameteri(i,e.TEXTURE_WRAP_S,e.CLAMP_TO_EDGE))),Q9(e,(()=>e.texParameteri(i,e.TEXTURE_WRAP_T,e.CLAMP_TO_EDGE))),Q9(e,(()=>e.texParameteri(i,e.TEXTURE_MIN_FILTER,e.NEAREST))),Q9(e,(()=>e.texParameteri(i,e.TEXTURE_MAG_FILTER,e.NEAREST))),1===yG().getNumber("WEBGL_VERSION")?Q9(e,(()=>e.texImage2D(i,0,a,t,n,0,r,o,null))):Q9(e,(()=>e.texStorage2D(i,1,a,t,n))),Q9(e,(()=>e.bindTexture(e.TEXTURE_2D,null))),{texture:s,texShape:[n,t]}}function ate(e){return e.internalFormatFloat}function rte(e){return e.internalFormatHalfFloat}function ote(e){return e.downloadTextureFormat}function ste(e){return e.internalFormatPackedFloat}function ite(e){return e.internalFormatPackedHalfFloat}function cte(e,t,n,a,r,o,s,i){const c=e,l=new Float32Array(function(e,t){const[n,a]=X9(e,t);return n*a*4}(o,s));return c.bindBuffer(c.PIXEL_PACK_BUFFER,t),c.getBufferSubData(c.PIXEL_PACK_BUFFER,0,l),c.bindBuffer(c.PIXEL_PACK_BUFFER,null),l}class lte{constructor(e){this.outputTexture=null,this.program=null,this.disposed=!1,this.itemsToPoll=[];const t=yG().getNumber("WEBGL_VERSION");if(null!=e?(this.gl=e,function(e,t){W9[e]=t}(t,e)):this.gl=U9(t),e=this.gl,2===yG().getNumber("WEBGL_VERSION")){const t=e;this.createVertexArray=()=>Q9(t,(()=>t.createVertexArray())),this.bindVertexArray=e=>Q9(t,(()=>t.bindVertexArray(e))),this.deleteVertexArray=e=>Q9(t,(()=>t.deleteVertexArray(e))),this.getVertexArray=()=>Q9(t,(()=>t.getParameter(t.VERTEX_ARRAY_BINDING)))}else if(null!=e){const t=e.getExtension("OES_vertex_array_object");if(null==t)throw new Error("All WebGL1 implementations are expected to offer OES_vertex_array_object.");this.createVertexArray=()=>Q9(e,(()=>t.createVertexArrayOES())),this.bindVertexArray=n=>Q9(e,(()=>t.bindVertexArrayOES(n))),this.deleteVertexArray=n=>Q9(e,(()=>t.deleteVertexArrayOES(n))),this.getVertexArray=()=>Q9(e,(()=>e.getParameter(t.VERTEX_ARRAY_BINDING_OES)))}let n="WEBGL_color_buffer_float";const a="EXT_color_buffer_half_float";if(this.parallelCompilationExtension=this.gl.getExtension("KHR_parallel_shader_compile"),1===yG().getNumber("WEBGL_VERSION")){const e="OES_texture_float",t="OES_texture_half_float";if(this.textureFloatExtension=Z9(this.gl,e),gee(this.gl,t))this.textureHalfFloatExtension=Z9(this.gl,t);else if(yG().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support half float textures, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.");if(this.colorBufferFloatExtension=this.gl.getExtension(n),gee(this.gl,a))this.colorBufferHalfFloatExtension=Z9(this.gl,a);else if(yG().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support color renderable half floats, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.")}else if(n="EXT_color_buffer_float",gee(this.gl,n))this.colorBufferFloatExtension=this.gl.getExtension(n);else{if(!gee(this.gl,a))throw new Error("GL context does not support color renderable floats");this.colorBufferHalfFloatExtension=this.gl.getExtension(a)}this.vertexBuffer=ete(this.gl),this.indexBuffer=tte(this.gl),this.framebuffer=function(e){return iee(e,(()=>e.createFramebuffer()),"Unable to create WebGLFramebuffer.")}(this.gl),this.textureConfig=Y9(this.gl,this.textureHalfFloatExtension)}get debug(){return yG().getBool("DEBUG")}dispose(){if(this.disposed)return;null!=this.program&&console.warn("Disposing a GPGPUContext that still has a bound WebGLProgram. This is probably a resource leak, delete the program with GPGPUContext.deleteProgram before disposing."),null!=this.outputTexture&&console.warn("Disposing a GPGPUContext that still has a bound output matrix texture.  This is probably a resource leak, delete the output matrix texture with GPGPUContext.deleteMatrixTexture before disposing.");const e=this.gl;Q9(e,(()=>e.finish())),Q9(e,(()=>e.bindFramebuffer(e.FRAMEBUFFER,null))),Q9(e,(()=>e.deleteFramebuffer(this.framebuffer))),Q9(e,(()=>e.bindBuffer(e.ARRAY_BUFFER,null))),Q9(e,(()=>e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,null))),Q9(e,(()=>e.deleteBuffer(this.indexBuffer))),this.disposed=!0}createFloat32MatrixTexture(e,t){return this.throwIfDisposed(),function(e,t,n,a){const[r,o]=K9(t,n);return nte(e,r,o,ate(a),a.textureFormatFloat,e.FLOAT)}(this.gl,e,t,this.textureConfig)}createFloat16MatrixTexture(e,t){return this.throwIfDisposed(),function(e,t,n,a){const[r,o]=K9(t,n);return nte(e,r,o,rte(a),a.textureFormatFloat,a.textureTypeHalfFloat)}(this.gl,e,t,this.textureConfig)}createUnsignedBytesMatrixTexture(e,t){return this.throwIfDisposed(),function(e,t,n,a){const[r,o]=K9(t,n);return nte(e,r,o,ote(a),e.RGBA,e.UNSIGNED_BYTE)}(this.gl,e,t,this.textureConfig)}uploadPixelDataToTexture(e,t){this.throwIfDisposed(),function(e,t,n){Q9(e,(()=>e.bindTexture(e.TEXTURE_2D,t))),n.data instanceof Uint8Array?2===yG().getNumber("WEBGL_VERSION")?Q9(e,(()=>e.texSubImage2D(e.TEXTURE_2D,0,0,0,n.width,n.height,e.RGBA,e.UNSIGNED_BYTE,n.data))):Q9(e,(()=>e.texImage2D(e.TEXTURE_2D,0,e.RGBA,n.width,n.height,0,e.RGBA,e.UNSIGNED_BYTE,n.data))):2===yG().getNumber("WEBGL_VERSION")?Q9(e,(()=>e.texSubImage2D(e.TEXTURE_2D,0,0,0,e.RGBA,e.UNSIGNED_BYTE,n))):Q9(e,(()=>e.texImage2D(e.TEXTURE_2D,0,e.RGBA,e.RGBA,e.UNSIGNED_BYTE,n))),Q9(e,(()=>e.bindTexture(e.TEXTURE_2D,null)))}(this.gl,e,t)}uploadDenseMatrixToTexture(e,t,n,a){this.throwIfDisposed(),function(e,t,n,a,r,o){let s,i,c;Q9(e,(()=>e.bindTexture(e.TEXTURE_2D,t))),r instanceof Uint8Array?(s=new Uint8Array(n*a*4),i=e.UNSIGNED_BYTE,c=e.RGBA):(s=new Float32Array(n*a*4),i=e.FLOAT,c=o.internalFormatPackedFloat),s.set(r),2===yG().getNumber("WEBGL_VERSION")?Q9(e,(()=>e.texSubImage2D(e.TEXTURE_2D,0,0,0,n,a,e.RGBA,i,s))):Q9(e,(()=>e.texImage2D(e.TEXTURE_2D,0,c,n,a,0,e.RGBA,i,s))),Q9(e,(()=>e.bindTexture(e.TEXTURE_2D,null)))}(this.gl,e,t,n,a,this.textureConfig)}createFloat16PackedMatrixTexture(e,t){return this.throwIfDisposed(),function(e,t,n,a){const[r,o]=X9(t,n);return nte(e,r,o,ite(a),e.RGBA,a.textureTypeHalfFloat)}(this.gl,e,t,this.textureConfig)}createPackedMatrixTexture(e,t){return this.throwIfDisposed(),function(e,t,n,a){const[r,o]=X9(t,n);return nte(e,r,o,ste(a),e.RGBA,e.FLOAT)}(this.gl,e,t,this.textureConfig)}deleteMatrixTexture(e){this.throwIfDisposed(),this.outputTexture===e&&(oee(this.gl,this.framebuffer),this.outputTexture=null),Q9(this.gl,(()=>this.gl.deleteTexture(e)))}downloadByteEncodedFloatMatrixFromOutputTexture(e,t,n){return this.downloadMatrixDriver(e,(()=>function(e,t,n,a){const[r,o]=K9(t,n),s=new Uint8Array(t*n*4);return Q9(e,(()=>e.readPixels(0,0,r,o,a.downloadTextureFormat,e.UNSIGNED_BYTE,s))),new Float32Array(s.buffer)}(this.gl,t,n,this.textureConfig)))}downloadPackedMatrixFromBuffer(e,t,n,a,r,o){return cte(this.gl,e,0,0,0,r,o,this.textureConfig)}downloadFloat32MatrixFromBuffer(e,t){return function(e,t,n){const a=e,r=new Float32Array(n);return a.bindBuffer(a.PIXEL_PACK_BUFFER,t),a.getBufferSubData(a.PIXEL_PACK_BUFFER,0,r),a.bindBuffer(a.PIXEL_PACK_BUFFER,null),r}(this.gl,e,t)}createBufferFromTexture(e,t,n){this.bindTextureToFrameBuffer(e);const a=function(e,t,n,a){const r=e.createBuffer();Q9(e,(()=>e.bindBuffer(e.PIXEL_PACK_BUFFER,r)));const o=16*t*n;return Q9(e,(()=>e.bufferData(e.PIXEL_PACK_BUFFER,o,e.STREAM_READ))),Q9(e,(()=>e.readPixels(0,0,n,t,e.RGBA,e.FLOAT,0))),Q9(e,(()=>e.bindBuffer(e.PIXEL_PACK_BUFFER,null))),r}(this.gl,t,n,this.textureConfig);return this.unbindTextureToFrameBuffer(),a}createAndWaitForFence(){const e=this.createFence(this.gl);return this.pollFence(e)}createFence(e){let t,n;if(yG().getBool("WEBGL_FENCE_API_ENABLED")){const a=e,r=a.fenceSync(a.SYNC_GPU_COMMANDS_COMPLETE,0);e.flush(),n=()=>{const e=a.clientWaitSync(r,0,0);return e===a.ALREADY_SIGNALED||e===a.CONDITION_SATISFIED},t=r}else yG().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0?(t=this.beginQuery(),this.endQuery(),n=()=>this.isQueryAvailable(t,yG().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))):n=()=>!0;return{query:t,isFencePassed:n}}downloadMatrixFromPackedTexture(e,t,n){return this.downloadMatrixDriver(e,(()=>function(e,t,n){const a=new Float32Array(t*n*4);return Q9(e,(()=>e.readPixels(0,0,n,t,e.RGBA,e.FLOAT,a))),a}(this.gl,t,n)))}createProgram(e){this.throwIfDisposed();const t=this.gl;null==this.vertexShader&&(this.vertexShader=$ee(t));const n=function(e){return iee(e,(()=>e.createProgram()),"Unable to create WebGLProgram.")}(t);Q9(t,(()=>t.attachShader(n,this.vertexShader))),Q9(t,(()=>t.attachShader(n,e))),function(e,t){if(Q9(e,(()=>e.linkProgram(t))),!yG().get("ENGINE_COMPILE_ONLY")&&!1===e.getProgramParameter(t,e.LINK_STATUS))throw console.log(e.getProgramInfoLog(t)),new Error("Failed to link vertex and fragment shaders.")}(t,n);const a=Object.assign(n,{vao:this.createVertexArray()});return this.debug&&tee(t,a),a}buildVao(e){this.setProgram(e),this.bindVertexArray(e.vao);const t=this.gl;Q9(t,(()=>t.bindBuffer(t.ELEMENT_ARRAY_BUFFER,this.indexBuffer))),function(e,t,n){Q9(e,(()=>e.bindBuffer(e.ARRAY_BUFFER,n))),nee(e,t,"clipSpacePos",n,3,20,0)&&nee(e,t,"uv",n,2,20,12)}(t,e,this.vertexBuffer)}deleteProgram(e){this.throwIfDisposed(),e===this.program&&(this.program=null),null!=e&&(Q9(this.gl,(()=>this.gl.deleteProgram(e))),this.deleteVertexArray(e.vao))}setProgram(e){this.throwIfDisposed(),this.program=e,null!=this.program&&this.debug&&tee(this.gl,this.program),Q9(this.gl,(()=>this.gl.useProgram(e)))}getUniformLocation(e,t){let n=!(arguments.length>2&&void 0!==arguments[2])||arguments[2];return this.throwIfDisposed(),n?function(e,t,n){return iee(e,(()=>e.getUniformLocation(t,n)),'uniform "'+n+'" not present in program.')}(this.gl,e,t):function(e,t,n){return e.getUniformLocation(t,n)}(this.gl,e,t)}getAttributeLocation(e,t){return this.throwIfDisposed(),Q9(this.gl,(()=>this.gl.getAttribLocation(e,t)))}getUniformLocationNoThrow(e,t){return this.throwIfDisposed(),this.gl.getUniformLocation(e,t)}setInputMatrixTexture(e,t,n){this.throwIfDisposed(),this.throwIfNoProgram(),aee(this.gl,e,t,n)}setOutputMatrixTexture(e,t,n){this.setOutputMatrixTextureDriver(e,n,t)}setOutputPackedMatrixTexture(e,t,n){this.throwIfDisposed();const[a,r]=X9(t,n);this.setOutputMatrixTextureDriver(e,a,r)}setOutputMatrixWriteRegion(e,t,n,a){this.setOutputMatrixWriteRegionDriver(n,e,a,t)}setOutputPackedMatrixWriteRegion(e,t,n,a){throw new Error("setOutputPackedMatrixWriteRegion not implemented.")}debugValidate(){null!=this.program&&tee(this.gl,this.program),see(this.gl)}executeProgram(){this.throwIfDisposed(),this.throwIfNoProgram();const e=this.gl;if(this.debug){const e=this.getVertexArray();console.assert(e===this.program.vao,"VAO changed between setProgram and executeProgram!"),this.debugValidate()}Q9(e,(()=>e.drawElements(e.TRIANGLES,6,e.UNSIGNED_SHORT,0)))}blockUntilAllProgramsCompleted(){this.throwIfDisposed(),Q9(this.gl,(()=>this.gl.finish()))}getQueryTimerExtension(){return null==this.disjointQueryTimerExtension&&(this.disjointQueryTimerExtension=Z9(this.gl,2===yG().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")?"EXT_disjoint_timer_query_webgl2":"EXT_disjoint_timer_query")),this.disjointQueryTimerExtension}getQueryTimerExtensionWebGL2(){return this.getQueryTimerExtension()}getQueryTimerExtensionWebGL1(){return this.getQueryTimerExtension()}beginQuery(){if(2===yG().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")){const e=this.gl,t=this.getQueryTimerExtensionWebGL2(),n=e.createQuery();return e.beginQuery(t.TIME_ELAPSED_EXT,n),n}const e=this.getQueryTimerExtensionWebGL1(),t=e.createQueryEXT();return e.beginQueryEXT(e.TIME_ELAPSED_EXT,t),t}endQuery(){if(2===yG().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")){const e=this.gl,t=this.getQueryTimerExtensionWebGL2();return void e.endQuery(t.TIME_ELAPSED_EXT)}const e=this.getQueryTimerExtensionWebGL1();e.endQueryEXT(e.TIME_ELAPSED_EXT)}async waitForQueryAndGetTime(e){return await qU((()=>this.disposed||this.isQueryAvailable(e,yG().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")))),this.getQueryTime(e,yG().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))}getQueryTime(e,t){if(0===t)return null;if(2===t){const t=this.gl;return t.getQueryParameter(e,t.QUERY_RESULT)/1e6}{const t=this.getQueryTimerExtensionWebGL1();return t.getQueryObjectEXT(e,t.QUERY_RESULT_EXT)/1e6}}isQueryAvailable(e,t){if(0===t)return!0;if(2===t){const t=this.gl,n=this.getQueryTimerExtensionWebGL2(),a=t.getQueryParameter(e,t.QUERY_RESULT_AVAILABLE);return null==this.disjoint&&(this.disjoint=this.gl.getParameter(n.GPU_DISJOINT_EXT)),a&&!this.disjoint}{const t=this.getQueryTimerExtensionWebGL1(),n=t.getQueryObjectEXT(e,t.QUERY_RESULT_AVAILABLE_EXT);return null==this.disjoint&&(this.disjoint=this.gl.getParameter(t.GPU_DISJOINT_EXT)),n&&!this.disjoint}}pollFence(e){return new Promise((t=>{this.addItemToPoll((()=>e.isFencePassed()),(()=>t()))}))}pollItems(){const e=function(e){let t=0;for(;t<e.length;++t){if(!e[t]())break}return t-1}(this.itemsToPoll.map((e=>e.isDoneFn)));for(let t=0;t<=e;++t){const{resolveFn:e}=this.itemsToPoll[t];e()}this.itemsToPoll=this.itemsToPoll.slice(e+1)}addItemToPoll(e,t){if(this.itemsToPoll.push({isDoneFn:e,resolveFn:t}),this.itemsToPoll.length>1)return;let n;"setTimeoutCustom"in yG().platform&&(n=yG().platform.setTimeoutCustom.bind(yG().platform)),qU((()=>(this.pollItems(),0===this.itemsToPoll.length)),(()=>0),null,n)}bindTextureToFrameBuffer(e){this.throwIfDisposed(),ree(this.gl,e,this.framebuffer),this.debug&&see(this.gl)}unbindTextureToFrameBuffer(){null!=this.outputTexture?(ree(this.gl,this.outputTexture,this.framebuffer),this.debug&&see(this.gl)):oee(this.gl,this.framebuffer)}downloadMatrixDriver(e,t){this.bindTextureToFrameBuffer(e);const n=t();return this.unbindTextureToFrameBuffer(),n}setOutputMatrixTextureDriver(e,t,n){this.throwIfDisposed();const a=this.gl;ree(a,e,this.framebuffer),this.debug&&see(a),this.outputTexture=e,Q9(a,(()=>a.viewport(0,0,t,n))),Q9(a,(()=>a.scissor(0,0,t,n)))}setOutputMatrixWriteRegionDriver(e,t,n,a){this.throwIfDisposed(),Q9(this.gl,(()=>this.gl.scissor(e,t,n,a)))}throwIfDisposed(){if(this.disposed)throw new Error("Attempted to use disposed GPGPUContext.")}throwIfNoProgram(){if(null==this.program)throw new Error("No GPU program is currently set.")}}const{addImpl:ute,bincountImpl:dte,bincountReduceImpl:hte,bitwiseAndImpl:pte,castImpl:fte,ceilImpl:mte,concatImpl:gte,equalImpl:bte,expImpl:yte,expm1Impl:xte,floorImpl:vte,gatherNdImpl:wte,gatherV2Impl:kte,greaterImpl:Ite,greaterEqualImpl:Ste,lessImpl:Nte,lessEqualImpl:Cte,linSpaceImpl:Tte,logImpl:Ete,maxImpl:Rte,maximumImpl:_te,minimumImpl:Ate,multiplyImpl:Fte,negImpl:Ote,notEqualImpl:Dte,prodImpl:Mte,raggedGatherImpl:Lte,raggedRangeImpl:Pte,raggedTensorToTensorImpl:zte,rangeImpl:Bte,rsqrtImpl:Wte,scatterImpl:Vte,sigmoidImpl:Ute,simpleAbsImpl:Gte,sliceImpl:Hte,sparseFillEmptyRowsImpl:jte,sparseReshapeImpl:Kte,sparseSegmentReductionImpl:qte,sqrtImpl:Xte,staticRegexReplaceImpl:Yte,stridedSliceImpl:Qte,stringNGramsImpl:Jte,stringSplitImpl:Zte,stringToHashBucketFastImpl:$te,subImpl:ene,tileImpl:tne,topKImpl:nne,transposeImpl:ane,uniqueImpl:rne}=u;function one(e,t){return["x","y","z","w","u","v"].slice(0,t).map((t=>"".concat(e,".").concat(t)))}function sne(e,t){return 1===t?[e]:one(e,t)}class ine{constructor(e){if(this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outputShape=e,this.rank=e.length,this.enableShapeUniforms=jee(this.outputShape.length),0===this.rank)this.userCode="\n        void main() {\n          setOutput(vec4(getA(), 0., 0., 0.));\n        }\n      ";else{const e=sne("rc",this.rank),t=zee(this.rank),n=this.getOutOfBoundsCondition(e),a=this.getSetup(e),r=this.getOutput(e);this.userCode="\n        void main() {\n          ".concat(t," rc = getOutputCoords();\n\n          if(").concat(n,") {\n            setOutput(vec4(0));\n          } else {\n            ").concat(a,"\n\n            setOutput(vec4(").concat(r,"));\n          }\n        }\n      ")}}getSourceCoordsArr(e){const t=[];for(let n=0;n<=1;n++)for(let a=0;a<=1;a++){let r="".concat(0===n?"r":"rp1",", ").concat(0===a?"c":"cp1");for(let t=2;t<this.rank;t++)r="".concat(e[e.length-1-t],",")+r;t.push(r)}return t}getOutOfBoundsCondition(e){if(1===this.rank)return"rc > ".concat(this.enableShapeUniforms?"outShape":this.outputShape[0]);let t="";for(let n=this.rank-2;n<this.rank;n++)t+="".concat(e[n]," >= ").concat(this.enableShapeUniforms?"outShape[".concat(n,"]"):this.outputShape[n]),n<this.rank-1&&(t+="||");return t}getSetup(e){if(1===this.rank)return"";const t=e.slice(-2),n=this.enableShapeUniforms?"outShape[".concat(this.rank," - 1]"):this.outputShape[this.rank-1],a=this.enableShapeUniforms?"outShape[".concat(this.rank," - 2]"):this.outputShape[this.rank-2];return"\n      int r = ".concat(t[0],";\n      int c = ").concat(t[1],";\n      int rp1 = r + 1;\n      int cp1 = c + 1;\n\n      bool cEdge = cp1 >= ").concat(n,";\n      bool rEdge = rp1 >= ").concat(a,";\n    ")}getOutput(e){const t=this.getSourceCoordsArr(e);if(1===this.rank){const e=this.enableShapeUniforms?"outShape":this.outputShape[0];return"getA(rc), (rc + 1 >= ".concat(e," ? 0. : getA(rc + 1)), 0, 0")}return"getA(".concat(t[0],"),\n            cEdge ? 0. : getA(").concat(t[1],"),\n            rEdge ? 0. : getA(").concat(t[2],"),\n            rEdge || cEdge ? 0. : getA(").concat(t[3],")")}}class cne{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec3"}],this.outputShape=e,this.enableShapeUniforms=jee(this.outputShape.length);let n="";for(let a=0;a<4;a++){let e="thisRC = rc;";a%2===1&&(e+="thisRC.z += 1;"),a>1&&(e+="thisRC.y += 1;"),n+="\n        ".concat(e,"\n        ").concat(a>0?"if(thisRC.y < rows && thisRC.z < cols){":"","\n          int flatIndex = getFlatIndex(thisRC);\n\n          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flatIndex);\n          vec2 inputRCInnerDims = vec2(float(inputRC.y),float(inputRC.z));\n\n          result[").concat(a,"] =\n            getChannel(getA(inputRC.x, inputRC.y, inputRC.z), inputRCInnerDims);\n        ").concat(a>0?"}":"","\n      ")}this.userCode="\n      ".concat(function(e,t){const n=t?Nee(["r","c","d"],"inputShape"):Iee(["r","c","d"],e);return"\n    ivec3 inputCoordsFromReshapedOutCoords(int index) {\n      ".concat(n,"\n      return ivec3(r, c, d);\n    }\n  ")}(t,this.enableShapeUniforms),"\n      ").concat(this.enableShapeUniforms?"\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;\n  }\n":Cee(e),"\n\n      void main() {\n        ivec3 rc = getOutputCoords();\n\n        vec4 result = vec4(0.);\n\n        ivec3 thisRC;\n        int rows = ").concat(this.enableShapeUniforms?"outShape[1]":e[1],";\n        int cols = ").concat(this.enableShapeUniforms?"outShape[2]":e[2],";\n\n        ").concat(n,"\n\n        setOutput(result);\n      }\n    ")}}class lne{constructor(e){this.gpgpu=e,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0,this.freeTextures={},this.usedTextures={},this.logEnabled=!1}acquireTexture(e,t,n){const a=dne(t,n),r=hne(e,a,n);r in this.freeTextures||(this.freeTextures[r]=[]),r in this.usedTextures||(this.usedTextures[r]=[]);const o=une(e,a,this.gpgpu.gl,this.gpgpu.textureConfig,n);if(this.freeTextures[r].length>0){this.numFreeTextures--,this.numUsedTextures++,this._numBytesFree-=o,this.log();const e=this.freeTextures[r].pop();return this.usedTextures[r].push(e),e}let s;return a===j9.PACKED_2X2_FLOAT32?s=this.gpgpu.createPackedMatrixTexture(e[0],e[1]):a===j9.PACKED_2X2_FLOAT16?s=this.gpgpu.createFloat16PackedMatrixTexture(e[0],e[1]):a===j9.UNPACKED_FLOAT32?s=this.gpgpu.createFloat32MatrixTexture(e[0],e[1]):a===j9.UNPACKED_FLOAT16?s=this.gpgpu.createFloat16MatrixTexture(e[0],e[1]):a===j9.PACKED_4X1_UNSIGNED_BYTE&&(s=this.gpgpu.createUnsignedBytesMatrixTexture(e[0],e[1])),this.usedTextures[r].push(s),this.numUsedTextures++,this._numBytesAllocated+=o,this.log(),s}releaseTexture(e,t,n,a){if(null==this.freeTextures)return;const r=dne(n,a),o=hne(t,r,a);o in this.freeTextures||(this.freeTextures[o]=[]);const s=une(t,r,this.gpgpu.gl,this.gpgpu.textureConfig,a),i=yG().getNumber("WEBGL_DELETE_TEXTURE_THRESHOLD");-1!==i&&this._numBytesAllocated>i?(this.gpgpu.deleteMatrixTexture(e.texture),this._numBytesAllocated-=s):(this.freeTextures[o].push(e),this.numFreeTextures++,this._numBytesFree+=s),this.numUsedTextures--;const c=this.usedTextures[o],l=c&&c.indexOf(e);if(null==l||l<0)throw new Error("Cannot release a texture that was never provided by this texture manager");c[l]=c[c.length-1],c.pop(),this.log()}log(){if(!this.logEnabled)return;const e=this.numFreeTextures+this.numUsedTextures;console.log("Free/Used","".concat(this.numFreeTextures," / ").concat(this.numUsedTextures),"(".concat(e,")"));const t=this._numBytesFree/this._numBytesAllocated;console.log("Bytes allocated: ".concat(this._numBytesAllocated)),console.log("Bytes unused: ".concat(this._numBytesFree," (").concat(Math.round(100*t),"%)"))}get numBytesAllocated(){return this._numBytesAllocated}get numBytesFree(){return this._numBytesFree}getNumUsedTextures(){return this.numUsedTextures}getNumFreeTextures(){return this.numFreeTextures}dispose(){if(null!=this.freeTextures){for(const e in this.freeTextures)this.freeTextures[e].forEach((e=>{this.gpgpu.deleteMatrixTexture(e.texture)}));for(const e in this.usedTextures)this.usedTextures[e].forEach((e=>{this.gpgpu.deleteMatrixTexture(e.texture)}));this.freeTextures=null,this.usedTextures=null,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0}}}function une(e,t,n,a,r){const o=function(e,t){switch(e){case j9.PACKED_2X2_FLOAT32:return ste(t);case j9.PACKED_2X2_FLOAT16:return ite(t);case j9.UNPACKED_FLOAT32:return ate(t);case j9.UNPACKED_FLOAT16:return rte(t);case j9.PACKED_4X1_UNSIGNED_BYTE:return ote(t);default:throw new Error("Unknown physical texture type ".concat(e))}}(t,a);let s;if(r){const[t,n]=X9(e[0],e[1]);s=t*n}else{const[t,n]=K9(e[0],e[1]);s=t*n}const i=function(e,t){const n=e;if(t===n.R32F)return 4;if(t===n.R16F)return 2;if(t===n.RGBA32F)return 16;if(t===e.RGBA)return 16;if(t===n.RGBA16F)return 8;if(t===n.RGBA8)return 4;throw new Error("Unknown internal format ".concat(t))}(n,o);return s*i}function dne(e,t){if(e===H9.UPLOAD)return j9.PACKED_2X2_FLOAT32;if(e===H9.RENDER||null==e)return function(e){return yG().getBool("WEBGL_RENDER_FLOAT32_ENABLED")?e?j9.PACKED_2X2_FLOAT32:j9.UNPACKED_FLOAT32:e?j9.PACKED_2X2_FLOAT16:j9.UNPACKED_FLOAT16}(t);if(e===H9.DOWNLOAD||e===H9.PIXELS)return j9.PACKED_4X1_UNSIGNED_BYTE;throw new Error("Unknown logical texture type ".concat(e))}function hne(e,t,n){return"".concat(e[0],"_").concat(e[1],"_").concat(t,"_").concat(n)}class pne{constructor(e,t){this.variableNames=["A"],this.outputShape=e,this.enableShapeUniforms=jee(this.outputShape.length),this.userCode="\n      float unaryOperation(float x) {\n        ".concat(t,"\n      }\n\n      void main() {\n        float x = getAAtOutCoords();\n        float y = unaryOperation(x);\n\n        setOutput(y);\n      }\n    ")}}const fne="if (isnan(x)) return x;",mne="return x;",gne="return abs(x);";const bne="return (x >= 0.0) ? x : (exp(x) - 1.0);",yne=fne+"\n  return (x < 0.0) ? 0.0 : x;\n",xne=fne+"\n  return (x < 0.0) ? 0.0 : min(6.0, x);\n",vne="return x;",wne="return 1.0 / (1.0 + exp(-1.0 * x));",kne="return x;",Ine="\n  vec4 result;\n\n  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);\n  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);\n  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);\n  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);\n\n  return result;\n",Sne="\n  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n",Nne="\n  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n",Cne="return 1.0 / (1.0 + exp(-1.0 * x));";class Tne{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.enableShapeUniforms=jee(this.outputShape.length),this.userCode="\n      vec4 unaryOperation(vec4 x) {\n        ".concat(t,"\n      }\n\n      void main() {\n        vec4 x = getAAtOutCoords();\n        vec4 y = unaryOperation(x);\n\n        setOutput(y);\n      }\n    ")}}class Ene{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outputShape=e,this.enableShapeUniforms=jee(this.outputShape.length);const t=e.length,n=sne("rc",t),a=zee(t),r=function(e,t){if(1===e)return"rc";let n="";for(let a=0;a<e;a++)n+=t[a],a<e-1&&(n+=",");return n}(t,n),o=n.slice(-2),s=t<=1?"rc":"vec2(".concat(o.join(","),")");this.userCode="\n      void main() {\n        ".concat(a," rc = getOutputCoords();\n        vec4 packedInput = getA(").concat(r,");\n\n        setOutput(getChannel(packedInput, ").concat(s,"));\n      }\n    ")}}const Rne=T0,_ne={};const Ane=yG().getNumber("CPU_HANDOFF_SIZE_THRESHOLD");class Fne extends DU{nextDataId(){return Fne.nextDataId++}constructor(e){if(super(),this.pendingRead=new WeakMap,this.pendingDisposal=new WeakSet,this.dataRefCount=new WeakMap,this.numBytesInGPU=0,this.uploadWaitMs=0,this.downloadWaitMs=0,this.lastGlFlushTime=0,this.warnedAboutMemory=!1,this.pendingDeletes=0,this.disposed=!1,!yG().getBool("HAS_WEBGL"))throw new Error("WebGL is not supported on this device");let t;if(null!=e){if(e instanceof lte)t=e;else{const n=U9(yG().getNumber("WEBGL_VERSION"),e);t=new lte(n)}this.binaryCache={},this.gpgpuCreatedLocally=!1}else{const e=U9(yG().getNumber("WEBGL_VERSION"));t=new lte(e),this.binaryCache=((n=yG().getNumber("WEBGL_VERSION"))in _ne||(_ne[n]={}),_ne[n]),this.gpgpuCreatedLocally=!0}var n;this.gpgpu=t,this.canvas=this.gpgpu.gl.canvas,this.textureManager=new lne(this.gpgpu),this.numMBBeforeWarning=null==yG().global.screen?1024:yG().global.screen.height*yG().global.screen.width*window.devicePixelRatio*600/1024/1024,this.texData=new OU(this,lX())}numDataIds(){return this.texData.numDataIds()-this.pendingDeletes}writeTexture(e,t,n,a,r,o){const s=this.makeTensorInfo(t,n),i=this.texData.get(s.dataId);i.isPacked=!1,i.texture={texture:e,texShape:[a,r]},i.texShape=[a,r];const c=dee(t),l=new Jee(c,!1,o),u=this.runWebGLProgram(l,[s],n,[[a,r]]);return u.shape=t,i.texture=null,this.disposeIntermediateTensorInfo(s),u.dataId}write(e,t,n){if((yG().getBool("WEBGL_CHECK_NUMERICAL_PROBLEMS")||yG().getBool("DEBUG"))&&this.checkNumericalProblems(e),"complex64"===n&&null!=e)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");const a={id:this.nextDataId()};return this.texData.set(a,{shape:t,dtype:n,values:e,usage:H9.UPLOAD,refCount:1}),a}refCount(e){if(this.texData.has(e)){return this.texData.get(e).refCount}return 0}incRef(e){this.texData.get(e).refCount++}decRef(e){if(this.texData.has(e)){this.texData.get(e).refCount--}}move(e,t,n,a,r){if(yG().getBool("DEBUG")&&this.checkNumericalProblems(t),"complex64"===a)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");this.texData.set(e,{shape:n,dtype:a,values:t,usage:H9.UPLOAD,refCount:r})}disposeIntermediateTensorInfo(e){this.disposeData(e.dataId)}readSync(e){const t=this.texData.get(e),{values:n,dtype:a,complexTensorInfos:r,slice:o,shape:s,isPacked:i}=t;if(null!=o){let t;t=i?new Tne(s,vne):new pne(s,vne);const n=this.runWebGLProgram(t,[{dataId:e,shape:s,dtype:a}],a),r=this.readSync(n.dataId);return this.disposeIntermediateTensorInfo(n),r}if(null!=n)return this.convertAndCacheOnCPU(e);if("string"===a)return n;const c=null!=this.activeTimers;let l,u;if(c&&(l=oq()),"complex64"===a){u=S2(this.readSync(r.real.dataId),this.readSync(r.imag.dataId))}else u=this.getValuesFromTexture(e);return c&&(this.downloadWaitMs+=oq()-l),this.convertAndCacheOnCPU(e,u)}async read(e){if(this.pendingRead.has(e)){const t=this.pendingRead.get(e);return new Promise((e=>t.push(e)))}const t=this.texData.get(e),{values:n,shape:a,slice:r,dtype:o,complexTensorInfos:s,isPacked:i}=t;if(null!=r){let t;t=i?new Tne(a,vne):new pne(a,vne);const n=this.runWebGLProgram(t,[{dataId:e,shape:a,dtype:o}],o),r=this.read(n.dataId);return this.disposeIntermediateTensorInfo(n),r}if(null!=n)return this.convertAndCacheOnCPU(e);if(yG().getBool("DEBUG")&&!yG().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")&&2===yG().getNumber("WEBGL_VERSION"))throw new Error("tensor.data() with WEBGL_DOWNLOAD_FLOAT_ENABLED=false and WEBGL_VERSION=2 not yet supported.");let c,l,u=null;if("complex64"!==o&&yG().get("WEBGL_BUFFER_SUPPORTED")){c=this.decode(e);const t=this.texData.get(c.dataId);u=this.gpgpu.createBufferFromTexture(t.texture.texture,...q9(a))}if(this.pendingRead.set(e,[]),"complex64"!==o&&await this.gpgpu.createAndWaitForFence(),"complex64"===o){const e=await Promise.all([this.read(s.real.dataId),this.read(s.imag.dataId)]);l=S2(e[0],e[1])}else if(null==u)l=this.getValuesFromTexture(e);else{const e=UU(a);l=this.gpgpu.downloadFloat32MatrixFromBuffer(u,e)}if(null!=c&&this.disposeIntermediateTensorInfo(c),null!=u){const e=this.gpgpu.gl;Q9(e,(()=>e.deleteBuffer(u)))}const d=this.convertAndCacheOnCPU(e,l),h=this.pendingRead.get(e);return this.pendingRead.delete(e),h.forEach((e=>e(d))),this.pendingDisposal.has(e)&&(this.pendingDisposal.delete(e),this.disposeData(e)&&lX().removeDataId(e,this),this.pendingDeletes--),d}readToGPU(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const n=this.texData.get(e),{values:a,shape:r,slice:o,dtype:s,isPacked:i,texture:c}=n;if("complex64"===s)throw new Error("Does not support reading texture for complex64 dtype.");if(null!=o){let n;n=i?new Tne(r,vne):new pne(r,vne);const a=this.runWebGLProgram(n,[{dataId:e,shape:r,dtype:s}],s),o=this.readToGPU(a,t);return this.disposeIntermediateTensorInfo(a),o}if(null==c)throw null!=a?new Error("Data is not on GPU but on CPU."):new Error("There is no data on GPU or CPU.");const l=this.decode(e,t.customTexShape),u=lX().makeTensorFromTensorInfo(l),d=this.texData.get(l.dataId);return Object.assign({tensorRef:u},d.texture)}bufferSync(e){const t=this.readSync(e.dataId);if("string"===e.dtype)try{const n=t.map((e=>iq(e)));return gY(e.shape,e.dtype,n)}catch(n){throw new Error("Failed to decode encoded string bytes into utf-8")}return gY(e.shape,e.dtype,t)}checkNumericalProblems(e){if(null!=e)for(let t=0;t<e.length;t++){const n=e[t];if(!J9(n)){if(yG().getBool("WEBGL_RENDER_FLOAT32_CAPABLE"))throw Error("The value ".concat(n," cannot be represented with your ")+"current settings. Consider enabling float32 rendering: 'tf.env().set('WEBGL_RENDER_FLOAT32_ENABLED', true);'");throw Error("The value ".concat(n," cannot be represented on this device."))}}}getValuesFromTexture(e){const{shape:t,dtype:n,isPacked:a}=this.texData.get(e),r=UU(t);if(yG().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")){const n=this.decode(e),a=this.texData.get(n.dataId),o=this.gpgpu.downloadMatrixFromPackedTexture(a.texture.texture,...q9(t)).subarray(0,r);return this.disposeIntermediateTensorInfo(n),o}const o=yG().getBool("WEBGL_PACK")&&!0===a,s=o?dee(t):t,i=o?new Yee(s):new Xee(s),c=this.runWebGLProgram(i,[{shape:s,dtype:n,dataId:e}],"float32"),l=this.texData.get(c.dataId),u=this.gpgpu.downloadByteEncodedFloatMatrixFromOutputTexture(l.texture.texture,l.texShape[0],l.texShape[1]).subarray(0,r);return this.disposeIntermediateTensorInfo(c),u}timerAvailable(){return yG().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0}time(e){const t=this.activeTimers,n=[];let a=!1;null==this.programTimersStack?(this.programTimersStack=n,a=!0):this.activeTimers.push(n),this.activeTimers=n,e();const r=lq(this.activeTimers.map((e=>e.query))).filter((e=>null!=e)),o=lq(this.activeTimers.map((e=>e.name))).filter((e=>null!=e));this.activeTimers=t,a&&(this.programTimersStack=null);const s={uploadWaitMs:this.uploadWaitMs,downloadWaitMs:this.downloadWaitMs,kernelMs:null,wallMs:null};return(async()=>{if(yG().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0){const e=await Promise.all(r);s.kernelMs=function(e){let t=0;for(let n=0;n<e.length;n++)t+=e[n];return t}(e),s.getExtraProfileInfo=()=>e.map(((e,t)=>({name:o[t],ms:e}))).map((e=>"".concat(e.name,": ").concat(e.ms))).join(", ")}else s.kernelMs={error:"WebGL query timers are not supported in this environment."};return this.uploadWaitMs=0,this.downloadWaitMs=0,s})()}memory(){return{unreliable:!1,numBytesInGPU:this.numBytesInGPU,numBytesInGPUAllocated:this.textureManager.numBytesAllocated,numBytesInGPUFree:this.textureManager.numBytesFree}}startTimer(){return yG().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?this.gpgpu.beginQuery():{startMs:oq(),endMs:null}}endTimer(e){return yG().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?(this.gpgpu.endQuery(),e):(e.endMs=oq(),e)}async getQueryTime(e){if(yG().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0)return this.gpgpu.waitForQueryAndGetTime(e);const t=e;return t.endMs-t.startMs}disposeData(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];if(this.pendingDisposal.has(e))return!1;if(!this.texData.has(e))return!0;if(t?this.texData.get(e).refCount=0:this.texData.get(e).refCount--,!t&&this.texData.get(e).refCount>0)return!1;if(this.pendingRead.has(e))return this.pendingDisposal.add(e),this.pendingDeletes++,!1;this.releaseGPUData(e);const{complexTensorInfos:n}=this.texData.get(e);return null!=n&&(this.disposeData(n.real.dataId,t),this.disposeData(n.imag.dataId,t)),this.texData.delete(e),!0}releaseGPUData(e){const{texture:t,dtype:n,texShape:a,usage:r,isPacked:o,slice:s}=this.texData.get(e),i=s&&s.origDataId||e,c=this.dataRefCount.get(i);c>1?this.dataRefCount.set(i,c-1):(this.dataRefCount.delete(i),null!=t&&(this.numBytesInGPU-=this.computeBytes(a,n),this.textureManager.releaseTexture(t,a,r,o)));const l=this.texData.get(e);l.texture=null,l.texShape=null,l.isPacked=!1,l.slice=null}getTexture(e){return this.uploadToGPU(e),this.texData.get(e).texture.texture}getDataInfo(e){return this.texData.get(e)}shouldExecuteOnCPU(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:Ane;return yG().getBool("WEBGL_CPU_FORWARD")&&e.every((e=>null==this.texData.get(e.dataId).texture&&UU(e.shape)<t))}getGPGPUContext(){return this.gpgpu}where(e){DK("tf.where() in webgl locks the UI thread. Call tf.whereAsync() instead");const t=e.dataSync();return Rne(e.shape,t)}packedUnaryOp(e,t,n){const a=new Tne(e.shape,t),r=this.compileAndRun(a,[e],n);return lX().makeTensorFromTensorInfo(r)}abs(e){if(this.shouldExecuteOnCPU([e])&&"complex64"!==e.dtype){const t=Gte(this.texData.get(e.dataId).values);return this.makeOutput(e.shape,e.dtype,t)}if(yG().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(e,gne,e.dtype);const t=new pne(e.shape,gne),n=this.compileAndRun(t,[e]);return lX().makeTensorFromTensorInfo(n)}makeTensorInfo(e,t,n){let a;if("string"===t&&null!=n&&n.length>0&&tG(n[0])){const r=n.map((e=>sq(e)));a=this.write(r,e,t)}else a=this.write(n,e,t);return this.texData.get(a).usage=null,{dataId:a,shape:e,dtype:t}}makeOutput(e,t,n){return lX().makeTensorFromTensorInfo(this.makeTensorInfo(e,t,n),this)}unpackTensor(e){const t=new Ene(e.shape);return this.runWebGLProgram(t,[e],e.dtype)}packTensor(e){const t=new ine(e.shape);return this.runWebGLProgram(t,[e],e.dtype,null,!0)}packedReshape(e,t){const n=[lee(e.shape),...uee(e.shape)],a={dtype:e.dtype,shape:n,dataId:e.dataId},r=[lee(t),...uee(t)],o=new cne(r,n),s=[n],i=this.runWebGLProgram(o,[a],e.dtype,s,!0);return{dataId:i.dataId,shape:t,dtype:i.dtype}}decode(e,t){const n=this.texData.get(e),{isPacked:a,shape:r,dtype:o}=n;if(null!=t){BU(UU(r)<=t[0]*t[1]*4,(()=>"customTexShape is too small. Row * Column * 4 should be equal or larger than the size of the tensor data."))}const s=dee(r);let i;i=a?new qee(s):new Kee(s);const c=[null!=t?t:q9(s)];return{dtype:o,shape:r,dataId:this.runWebGLProgram(i,[{shape:s,dtype:o,dataId:e}],o,c,!0,t).dataId}}runWebGLProgram(e,t,n,a){let r=arguments.length>4&&void 0!==arguments[4]&&arguments[4],o=arguments.length>5?arguments[5]:void 0;const s=this.makeTensorInfo(e.outputShape,n),i=this.texData.get(s.dataId);if(e.packedOutput&&(i.isPacked=!0),e.outPackingScheme===G9.DENSE){const t=null!=o?o:q9(e.outputShape);i.texShape=t.map((e=>2*e))}if(null!=e.outTexUsage&&(i.usage=e.outTexUsage),0===UU(s.shape))return i.values=JU(s.dtype,0),s;const c=[],l=t.map((t=>{if("complex64"===t.dtype)throw new Error("GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.");let n=this.texData.get(t.dataId);if(null==n.texture){if(!e.packedInputs&&UU(t.shape)<=yG().getNumber("WEBGL_SIZE_UPLOAD_UNIFORM"))return{shape:t.shape,texData:null,isUniform:!0,uniformValues:n.values};e.packedInputs&&(n.isPacked=!0,n.shape=t.shape)}if(this.uploadToGPU(t.dataId),!!n.isPacked!==!!e.packedInputs)t=n.isPacked?this.unpackTensor(t):this.packTensor(t),c.push(t),n=this.texData.get(t.dataId);else if(n.isPacked&&!pee(n.shape,t.shape)){const e=t,a=t.shape;t.shape=n.shape,t=this.packedReshape(t,a),c.push(t),n=this.texData.get(t.dataId),e.shape=a}return{shape:t.shape,texData:n,isUniform:!1}}));this.uploadToGPU(s.dataId);const u={shape:s.shape,texData:i,isUniform:!1},d=function(e,t,n){let a="";t.concat(n).forEach((t=>{const r=null!=t.texData&&null!=t.texData.slice&&t.texData.slice.flatOffset>0;if(e.enableShapeUniforms&&!t.isUniform){const o=t.texData.texShape,{useSqueezeShape:s,uniformShape:i,keptDims:c}=Bee(e.packedInputs,t.shape,o);let l="",u="",d="";if(1===i.length&&e.packedInputs){const e=[Math.ceil(o[0]/2),Math.ceil(o[1]/2)];l="".concat(e[0]>1,"_").concat(e[1]>1)}else if(2!==i.length||e.packedInputs){if(i.length>2&&!e.packedInputs){const e=oG(i);d="".concat(e[0]===o[1],"_").concat(e[e.length-1]===o[1])}}else u="".concat(i[0]>1,"_").concat(i[1]>1);const h=t.shape.length,p=2===i.length&&GU(t.shape,o),f=1===UU(t.shape),m=BY(t.shape,n.shape),g=!e.packedInputs&&h===n.shape.length&&GU(o,n.texData.texShape),b=e.packedInputs||i.length>2?"":"".concat(o[0]>1,"_").concat(o[1]>1);a+="".concat(h,"_").concat(g,"_").concat(s?c:"","_").concat(i.length,"_").concat(f,"_").concat(m,"_").concat(p,"_").concat(l,"_").concat(u,"_").concat(d,"_").concat(b,"_").concat(r)}else{const e=t.isUniform?"uniform":t.texData.texShape;a+="".concat(t.shape,"_").concat(e,"_").concat(r)}}));const r=e.userCode;let o=e.constructor.name;return o+="_"+a+"_"+r+"".concat(yG().getNumber("WEBGL_VERSION")),o}(e,l,u),h=this.getAndSaveBinary(d,(()=>Uee(this.gpgpu,e,l,u))),p=null!=this.activeTimers;let f;p&&(f=this.startTimer()),yG().get("ENGINE_COMPILE_ONLY")||function(e,t,n,a,r){t.program.enableShapeUniforms||(Hee(t.inShapeInfos,n),Hee([t.outShapeInfo],[a]));const o=a.texData.texture,s=a.texData.texShape;a.texData.isPacked?e.setOutputPackedMatrixTexture(o.texture,s[0],s[1]):e.setOutputMatrixTexture(o.texture,s[0],s[1]),e.setProgram(t.webGLProgram),e.bindVertexArray(t.webGLProgram.vao),1===yG().getNumber("WEBGL_VERSION")&&null!==t.infLoc&&e.gl.uniform1f(t.infLoc,1/0),null!==t.nanLoc&&e.gl.uniform1f(t.nanLoc,NaN);for(let c=0;c<n.length;++c){const a=n[c],{uniform:r,offset:o,shape:s,texShape:i}=t.variablesLocations[c];if(s){const{uniformShape:n}=Bee(t.program.packedInputs,a.shape,a.texData.texShape);switch(n.length){case 1:e.gl.uniform1iv(s,new Int32Array(n));break;case 2:e.gl.uniform2iv(s,new Int32Array(n));break;case 3:e.gl.uniform3iv(s,new Int32Array(n));break;case 4:e.gl.uniform4iv(s,new Int32Array(n))}}if(i&&e.gl.uniform2i(i,a.texData.texShape[0],a.texData.texShape[1]),null!=r)if(a.isUniform)if(UU(a.shape)<2)e.gl.uniform1f(r,a.uniformValues[0]);else{let t=a.uniformValues;t instanceof Float32Array||(t=new Float32Array(t)),e.gl.uniform1fv(r,t)}else null!=a.texData.slice&&null!=o&&e.gl.uniform1i(o,a.texData.slice.flatOffset),e.setInputMatrixTexture(a.texData.texture.texture,r,c)}const i=t.outShapeLocation;if(i)switch(a.shape.length){case 1:e.gl.uniform1iv(i,new Int32Array(a.shape));break;case 2:e.gl.uniform2iv(i,new Int32Array(a.shape));break;case 3:e.gl.uniform3iv(i,new Int32Array(a.shape));break;case 4:e.gl.uniform4iv(i,new Int32Array(a.shape))}if(t.outShapeStridesLocation){const n=oG(a.shape);switch(a.shape.length){case 2:e.gl.uniform1iv(t.outShapeStridesLocation,new Int32Array(n));break;case 3:e.gl.uniform2iv(t.outShapeStridesLocation,new Int32Array(n));break;case 4:e.gl.uniform3iv(t.outShapeStridesLocation,new Int32Array(n))}}if(t.outTexShapeLocation&&e.gl.uniform2i(t.outTexShapeLocation,a.texData.texShape[0],a.texData.texShape[1]),t.program.customUniforms&&r)for(let c=0;c<t.program.customUniforms.length;++c){const n=t.program.customUniforms[c],a=t.customUniformLocations[c],o=r[c];if("float"===n.type)e.gl.uniform1fv(a,o);else if("vec2"===n.type)e.gl.uniform2fv(a,o);else if("vec3"===n.type)e.gl.uniform3fv(a,o);else if("vec4"===n.type)e.gl.uniform4fv(a,o);else if("int"===n.type)e.gl.uniform1iv(a,o);else if("ivec2"===n.type)e.gl.uniform2iv(a,o);else if("ivec3"===n.type)e.gl.uniform3iv(a,o);else{if("ivec4"!==n.type)throw Error("uniform type ".concat(n.type," is not supported yet."));e.gl.uniform4iv(a,o)}}e.executeProgram()}(this.gpgpu,h,l,u,a),c.forEach((e=>this.disposeIntermediateTensorInfo(e))),p&&(f=this.endTimer(f),this.activeTimers.push({name:e.constructor.name,query:this.getQueryTime(f)}));const m=yG().getNumber("WEBGL_FLUSH_THRESHOLD");if(m>0){const e=oq();e-this.lastGlFlushTime>m&&(this.gpgpu.gl.flush(),this.lastGlFlushTime=e)}if(!yG().getBool("WEBGL_LAZILY_UNPACK")&&i.isPacked&&!1===r){const e=this.unpackTensor(s);return this.disposeIntermediateTensorInfo(s),e}return s}compileAndRun(e,t,n,a){let r=arguments.length>4&&void 0!==arguments[4]&&arguments[4];n=n||t[0].dtype;return this.runWebGLProgram(e,t,n,a,r)}getAndSaveBinary(e,t){return e in this.binaryCache||(this.binaryCache[e]=t()),this.binaryCache[e]}getTextureManager(){return this.textureManager}dispose(){if(!this.disposed){if(!yG().getBool("IS_TEST")){Object.keys(this.binaryCache).forEach((e=>{this.gpgpu.deleteProgram(this.binaryCache[e].webGLProgram),delete this.binaryCache[e]}))}this.textureManager.dispose(),null!=this.canvas&&"undefined"!==typeof HTMLCanvasElement&&this.canvas instanceof HTMLCanvasElement?this.canvas.remove():this.canvas=null,this.gpgpuCreatedLocally&&(this.gpgpu.program=null,this.gpgpu.dispose()),this.disposed=!0}}floatPrecision(){return null==this.floatPrecisionValue&&(this.floatPrecisionValue=uX((()=>{if(!yG().get("WEBGL_RENDER_FLOAT32_ENABLED")){const e=yG().getBool("DEBUG");yG().set("DEBUG",!1);const t=this.abs(EY(1e-8)).dataSync()[0];if(yG().set("DEBUG",e),t>0)return 32}return 16}))),this.floatPrecisionValue}epsilon(){return 32===this.floatPrecision()?1e-7:1e-4}uploadToGPU(e){const t=this.texData.get(e),{shape:n,dtype:a,values:r,texture:o,usage:s,isPacked:i}=t;if(null!=o)return;const c=null!=this.activeTimers;let l;c&&(l=oq());let u=t.texShape;if(null==u&&(u=function(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1],n=yG().getNumber("WEBGL_MAX_TEXTURE_SIZE"),a=yG().getNumber("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE");if(a===1/0&&yG().getBool("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE")&&(a=n/2),t&&(n*=2,a*=2,e=e.map(((t,n)=>n>=e.length-2?PU(e[n]):e[n])),1===e.length&&(e=[2,e[0]])),2!==e.length){const t=QU(e);e=t.newShape}let r=UU(e),o=null;e.length<=1&&r<=n?o=[1,r]:2===e.length&&e[0]<=n&&e[1]<=n?o=e:3===e.length&&e[0]*e[1]<=n&&e[2]<=n?o=[e[0]*e[1],e[2]]:3===e.length&&e[0]<=n&&e[1]*e[2]<=n?o=[e[0],e[1]*e[2]]:4===e.length&&e[0]*e[1]*e[2]<=n&&e[3]<=n?o=[e[0]*e[1]*e[2],e[3]]:4===e.length&&e[0]<=n&&e[1]*e[2]*e[3]<=n&&(o=[e[0],e[1]*e[2]*e[3]]);const s=null!=o&&Math.max(...o)>a&&Math.min(...o)<=(t?2:1)&&Math.min(...o)>0;if(null==o||s)if(t){const t=lee(e);let n=2,a=2;e.length&&([n,a]=uee(e)),r=t*(n/2)*(a/2),o=jU(r).map((e=>2*e))}else o=jU(r);return o}(n,i),t.texShape=u),null!=r){const e=dee(n);let o,s=u[1],d=u[0];const h=r instanceof Uint8Array||r instanceof Uint8ClampedArray;!i&&h||([s,d]=X9(u[0],u[1])),o=i?new Zee(e,h):new Jee(e,h);const p=h?[d,s]:u,f=this.makeTensorInfo(p,a),m=this.texData.get(f.dataId);m.usage=h?H9.PIXELS:H9.UPLOAD,m.texShape=p,this.gpgpu.uploadDenseMatrixToTexture(this.getTexture(f.dataId),s,d,r);const g=[[d,s]],b=!0,y=this.runWebGLProgram(o,[f],a,g,b),x=this.texData.get(y.dataId);t.texShape=x.texShape,t.isPacked=x.isPacked,t.usage=x.usage,yG().get("ENGINE_COMPILE_ONLY")?this.disposeData(y.dataId):(t.texture=x.texture,t.values=null,this.texData.delete(y.dataId)),this.disposeIntermediateTensorInfo(f),c&&(this.uploadWaitMs+=oq()-l)}else{const e=this.acquireTexture(u,s,a,i);t.texture=e}}convertAndCacheOnCPU(e,t){const n=this.texData.get(e),{dtype:a}=n;return null!=t&&(n.values=function(e,t){if("float32"===t||"complex64"===t)return e;if("int32"===t||"bool"===t){const n="int32"===t?new Int32Array(e.length):new Uint8Array(e.length);for(let t=0;t<n.length;++t)n[t]=Math.round(e[t]);return n}throw new Error("Unknown dtype ".concat(t))}(t,a)),n.values}acquireTexture(e,t,n,a){if(this.numBytesInGPU+=this.computeBytes(e,n),!this.warnedAboutMemory&&this.numBytesInGPU>1024*this.numMBBeforeWarning*1024){const e=(this.numBytesInGPU/1024/1024).toFixed(2);this.warnedAboutMemory=!0,console.warn("High memory usage in GPU: ".concat(e," MB, ")+"most likely due to a memory leak")}return this.textureManager.acquireTexture(e,t,a)}computeBytes(e,t){return e[0]*e[1]*eG(t)}checkCompileCompletion(){for(const[,e]of Object.entries(this.binaryCache))this.checkCompletion_(e)}async checkCompileCompletionAsync(){const e=[];if(this.gpgpu.parallelCompilationExtension){for(const[,t]of Object.entries(this.binaryCache))e.push(this.checkCompletionAsync_(t));return Promise.all(e)}for(const[,t]of Object.entries(this.binaryCache)){const n=new Promise((e=>{try{this.checkCompletion_(t),e(!0)}catch(n){throw n}}));e.push(n)}return Promise.all(e)}async checkCompletionAsync_(e){return this.gpgpu.gl.getProgramParameter(e.webGLProgram,this.gpgpu.parallelCompilationExtension.COMPLETION_STATUS_KHR)?this.checkCompletion_(e):(await new Promise((e=>$1((()=>e())))),this.checkCompletionAsync_(e))}checkCompletion_(e){if(!1===this.gpgpu.gl.getProgramParameter(e.webGLProgram,this.gpgpu.gl.LINK_STATUS)){if(console.log(this.gpgpu.gl.getProgramInfoLog(e.webGLProgram)),!1===this.gpgpu.gl.getShaderParameter(e.fragmentShader,this.gpgpu.gl.COMPILE_STATUS))throw eee(e.source,this.gpgpu.gl.getShaderInfoLog(e.fragmentShader)),new Error("Failed to compile fragment shader.");throw new Error("Failed to link vertex and fragment shaders.")}return!0}getUniformLocations(){for(const e of Object.values(this.binaryCache)){this.gpgpu.buildVao(e.webGLProgram);const{variablesLocations:t,customUniformLocations:n,infLoc:a,nanLoc:r,outShapeLocation:o,outShapeStridesLocation:s,outTexShapeLocation:i}=Gee(this.gpgpu,e.program,e.webGLProgram);e.variablesLocations=t,e.customUniformLocations=n,e.infLoc=a,e.nanLoc=r,e.outShapeLocation=o,e.outShapeStridesLocation=s,e.outTexShapeLocation=i}}createTensorFromGPUData(e,t,n){e.channels=e.channels||"RGBA";const{texture:a,height:r,width:o,channels:s}=e,i=lX().backend;if(!i.gpgpu.gl.isTexture(a))throw new Error("The texture is invalid. Also, please make sure the texture and the TFJS WebGL backend are using the same canvas. If you want to use your own custom canvas, you have to create and use the custom TFJS WebGL backend created from the canvas through 'new tf.MathBackendWebGL(customCanvas)'.");const c=i.writeTexture(a,t,n,r,o,s);return lX().makeTensorFromDataId(c,t,n,i)}}Fne.nextDataId=0,Yq()&&pX("webgl",(()=>new Fne),2);const One="\n  if (isnan(a)) return a;\n  if (isnan(b)) return b;\n";class Dne{constructor(e,t,n){this.variableNames=["A","B"],this.outputShape=VY(t,n),this.enableShapeUniforms=jee(this.outputShape.length),this.userCode="\n      float binaryOperation(float a, float b) {\n        ".concat(e,"\n      }\n\n      void main() {\n        float a = getAAtOutCoords();\n        float b = getBAtOutCoords();\n        setOutput(binaryOperation(a, b));\n      }\n    ")}}const Mne="\n  result.r = isNaN.r ? NAN : result.r;\n  result.g = isNaN.g ? NAN : result.g;\n  result.b = isNaN.b ? NAN : result.b;\n  result.a = isNaN.a ? NAN : result.a;\n";class Lne{constructor(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]&&arguments[3];this.variableNames=["A","B"],this.supportsBroadcasting=!0,this.packedInputs=!0,this.packedOutput=!0,this.outputShape=VY(t,n);const r=this.outputShape.length;this.enableShapeUniforms=jee(r);let o="";if(a)if(0===r||1===UU(this.outputShape))o="\n          result.y = 0.;\n          result.z = 0.;\n          result.w = 0.;\n        ";else{const e=zee(r);if(o="\n          ".concat(e," coords = getOutputCoords();\n        "),1===r)this.enableShapeUniforms?o+="\n            result.y = (coords + 1) >= outShape ? 0. : result.y;\n            result.z = 0.;\n            result.w = 0.;\n          ":o+="\n            result.y = (coords + 1) >= ".concat(this.outputShape[0]," ? 0. : result.y;\n            result.z = 0.;\n            result.w = 0.;\n          ");else{const e=sne("coords",r);this.enableShapeUniforms?o+="\n            bool nextRowOutOfBounds =\n              (".concat(e[r-2]," + 1) >= outShape[").concat(r," - 2];\n            bool nextColOutOfBounds =\n              (").concat(e[r-1]," + 1) >= outShape[").concat(r," - 1];\n            result.y = nextColOutOfBounds ? 0. : result.y;\n            result.z = nextRowOutOfBounds ? 0. : result.z;\n            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;\n          "):o+="\n            bool nextRowOutOfBounds =\n              (".concat(e[r-2]," + 1) >= ").concat(this.outputShape[r-2],";\n            bool nextColOutOfBounds =\n              (").concat(e[r-1]," + 1) >= ").concat(this.outputShape[r-1],";\n            result.y = nextColOutOfBounds ? 0. : result.y;\n            result.z = nextRowOutOfBounds ? 0. : result.z;\n            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;\n          ")}}this.userCode="\n      vec4 binaryOperation(vec4 a, vec4 b) {\n        ".concat(e,"\n      }\n\n      void main() {\n        vec4 a = getAAtOutCoords();\n        vec4 b = getBAtOutCoords();\n\n        vec4 result = binaryOperation(a, b);\n        ").concat(o,"\n\n        setOutput(result);\n      }\n    ")}}function Pne(e){const{inputs:t,backend:n}=e,{x:a}=t;return n.incRef(a.dataId),{dataId:a.dataId,shape:a.shape,dtype:a.dtype}}const zne={kernelName:zH,backendName:"webgl",kernelFunc:Pne};function Bne(e){const{inputs:t,backend:n}=e,{real:a,imag:r}=t,o=n.makeTensorInfo(a.shape,"complex64"),s=n.texData.get(o.dataId),i=Pne({inputs:{x:a},backend:n}),c=Pne({inputs:{x:r},backend:n});return s.complexTensorInfos={real:i,imag:c},o}const Wne={kernelName:YG,backendName:"webgl",kernelFunc:Bne},Vne="return (a < 0.) ? b * a : a;",Une="\n  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));\n  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);\n";const Gne={kernelName:HH,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{alpha:o}=a,s=n.makeTensorInfo([],"float32",aq(o,"float32")),i=yG().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new Lne(Une,r.shape,s.shape):new Dne(Vne,r.shape,s.shape),c=n.runWebGLProgram(i,[r,s],"float32");return n.disposeIntermediateTensorInfo(s),c}},Hne="return (a < 0.) ? b * a : a;",jne="\n  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));\n  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);\n";const Kne={kernelName:Nj,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{x:a,alpha:r}=t,o=yG().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new Lne(jne,a.shape,r.shape):new Dne(Hne,a.shape,r.shape);return n.runWebGLProgram(o,[a,r],"float32")}},qne="if (isnan(x)) return x;";function Xne(e){let{opSnippet:t,packedOpSnippet:n,cpuKernelImpl:a,dtype:r}=e;return e=>{let{inputs:o,backend:s}=e;const{x:i}=o,c=s,l=r||i.dtype;if(c.shouldExecuteOnCPU([i])&&null!=a){const e=c.texData.get(i.dataId),t=a(e.values,l);return c.makeTensorInfo(i.shape,l,t)}let u;return u=yG().getBool("WEBGL_PACK_UNARY_OPERATIONS")&&null!=n?new Tne(i.shape,n):new pne(i.shape,t),c.runWebGLProgram(u,[i],l)}}function Yne(e){let{opSnippet:t,packedOpSnippet:n,checkOutOfBounds:a=!1,supportsComplex:r=!1,cpuKernelImpl:o,dtype:s}=e;return e=>{let{inputs:i,backend:c}=e;const{a:l,b:u}=i,d=c;if(r&&"complex64"===l.dtype){const e=d.texData.get(l.dataId),n=d.texData.get(u.dataId),[a,r]=[[e.complexTensorInfos.real,n.complexTensorInfos.real],[e.complexTensorInfos.imag,n.complexTensorInfos.imag]].map((e=>{const[n,a]=e,r={dataId:n.dataId,dtype:n.dtype,shape:l.shape},o={dataId:a.dataId,dtype:a.dtype,shape:u.shape},s=new Dne(t,l.shape,u.shape);return d.runWebGLProgram(s,[r,o],Dq(n.dtype,a.dtype))})),o=Bne({inputs:{real:a,imag:r},backend:d});return d.disposeIntermediateTensorInfo(a),d.disposeIntermediateTensorInfo(r),o}const h=s||Dq(l.dtype,u.dtype);if(("string"===l.dtype||"string"===u.dtype||d.shouldExecuteOnCPU([l,u]))&&null!=o){const e=d.texData.get(l.dataId).values,t=d.texData.get(u.dataId).values,n="string"===l.dtype?r3(e):e,a="string"===l.dtype?r3(t):t,[r,s]=o(l.shape,u.shape,n,a,h),i=d.makeTensorInfo(s,h);return d.texData.get(i.dataId).values=r,i}let p;return p=yG().getBool("WEBGL_PACK_BINARY_OPERATIONS")&&null!=n?new Lne(n,l.shape,u.shape,a):new Dne(t,l.shape,u.shape),d.runWebGLProgram(p,[l,u],h)}}function Qne(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];if("linear"===e)return t?kne:mne;if("relu"===e)return t?Sne:yne;if("elu"===e)return t?Ine:bne;if("relu6"===e)return t?Nne:xne;if("prelu"===e)return t?jne:Hne;if("leakyrelu"===e)return t?Une:Vne;if("sigmoid"===e)return t?Cne:wne;throw new Error("Activation ".concat(e," has not been implemented for the WebGL backend."))}class Jne{constructor(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]&&arguments[3],r=arguments.length>4&&void 0!==arguments[4]&&arguments[4],o=arguments.length>5&&void 0!==arguments[5]&&arguments[5],s=arguments.length>6&&void 0!==arguments[6]?arguments[6]:null,i=arguments.length>7&&void 0!==arguments[7]&&arguments[7],c=arguments.length>8&&void 0!==arguments[8]&&arguments[8];this.variableNames=["matrixA","matrixB"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=n,this.enableShapeUniforms=jee(this.outputShape.length);const l=a?e[1]:e[2],u=Math.ceil(l/2),d=a?"i * 2, rc.y":"rc.y, i * 2",h=r?"rc.z, i * 2":"i * 2, rc.z",p=a?["a.xxyy","a.zzww"]:["a.xxzz","a.yyww"],f=r?["b.xzxz","b.ywyw"]:["b.xyxy","b.zwzw"];let m="",g="";s&&(m=i?"vec4 activation(vec4 a) {\n          vec4 b = getPreluActivationWeightsAtOutCoords();\n          ".concat(s,"\n        }"):c?"vec4 activation(vec4 a) {\n          vec4 b = getLeakyreluAlphaAtOutCoords();\n          ".concat(s,"\n        }"):"vec4 activation(vec4 x) {\n          ".concat(s,"\n        }"),g="result = activation(result);");const b=o?"result += getBiasAtOutCoords();":"";o&&this.variableNames.push("bias"),i&&this.variableNames.push("preluActivationWeights"),c&&this.variableNames.push("leakyreluAlpha");let y="rc.x",x="rc.x";e[0]<t[0]?y="imod(rc.x, ".concat(e[0],")"):t[0]<e[0]&&(x="imod(rc.x, ".concat(t[0],")")),this.userCode="\n      ".concat(m,"\n      // Don't use uniform for sharedDimensionPacked for performance.\n      const float sharedDimension = ").concat(u,".0;\n\n      vec4 dot2x2ARowBCol(ivec3 rc) {\n        vec4 result = vec4(0);\n        int batchA = ").concat(y,";\n        int batchB = ").concat(x,";\n        for (int i = 0; i < ").concat(u,"; i++) {\n          vec4 a = getMatrixA(batchA, ").concat(d,");\n          vec4 b = getMatrixB(batchB, ").concat(h,");\n\n          // These swizzled products need to be separately added.\n          // See: https://github.com/tensorflow/tfjs/issues/1735\n          result += (").concat(p[0]," * ").concat(f[0],");\n          result += (").concat(p[1]," * ").concat(f[1],");\n        }\n        return result;\n      }\n\n      void main() {\n        ivec3 rc = getOutputCoords();\n        vec4 result = dot2x2ARowBCol(rc);\n\n        ").concat(b,"\n\n        ").concat(g,"\n\n        setOutput(result);\n      }\n    ")}}const Zne={REAL:"return areal * breal - aimag * bimag;",IMAG:"return areal * bimag + aimag * breal;"};class $ne{constructor(e,t,n){this.variableNames=["AReal","AImag","BReal","BImag"],this.outputShape=VY(t,n),this.userCode="\n      float binaryOpComplex(\n          float areal, float aimag, float breal, float bimag) {\n        ".concat(e,"\n      }\n\n      void main() {\n        float areal = getARealAtOutCoords();\n        float aimag = getAImagAtOutCoords();\n        float breal = getBRealAtOutCoords();\n        float bimag = getBImagAtOutCoords();\n        setOutput(binaryOpComplex(areal, aimag, breal, bimag));\n      }\n    ")}}const eae="return a * b;";function tae(e){const{inputs:t,backend:n}=e,{a:a,b:r}=t,o=Dq(a.dtype,r.dtype);if("complex64"===a.dtype){const e=n.texData.get(a.dataId),t=n.texData.get(r.dataId),o=new $ne(Zne.REAL,a.shape,r.shape),s=new $ne(Zne.IMAG,a.shape,r.shape),i=[{dataId:e.complexTensorInfos.real.dataId,dtype:e.complexTensorInfos.real.dtype,shape:a.shape},{dataId:e.complexTensorInfos.imag.dataId,dtype:e.complexTensorInfos.imag.dtype,shape:a.shape},{dataId:t.complexTensorInfos.real.dataId,dtype:t.complexTensorInfos.real.dtype,shape:r.shape},{dataId:t.complexTensorInfos.imag.dataId,dtype:t.complexTensorInfos.imag.dtype,shape:r.shape}],c=n.runWebGLProgram(o,i,"float32"),l=n.runWebGLProgram(s,i,"float32"),u=Bne({inputs:{real:c,imag:l},backend:n});return n.disposeIntermediateTensorInfo(c),n.disposeIntermediateTensorInfo(l),u}if(n.shouldExecuteOnCPU([a,r])){const e=n.texData.get(a.dataId),t=n.texData.get(r.dataId),[s,i]=Fte(a.shape,r.shape,e.values,t.values,o),c=n.makeTensorInfo(i,o);return n.texData.get(c.dataId).values=s,c}let s;return s=yG().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new Lne(eae,a.shape,r.shape):new Dne(eae,a.shape,r.shape),n.runWebGLProgram(s,[a,r],o)}const nae={kernelName:fj,backendName:"webgl",kernelFunc:tae};function aae(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{shape:o}=a,s=n,i=UU(r.shape),c=XU(o,i),l=UU(c);BU(i===l,(()=>"The new shape (".concat(c,") has ").concat(l," elements and the old ")+"shape (".concat(r.shape,") has ").concat(i," elements. The new shape and old ")+"shape must have the same number of elements."));const u=s.texData.get(r.dataId);return!u.isPacked||pee(r.shape,c)||null!==u.texture&&pee(u.shape,c)?(s.incRef(r.dataId),{dataId:r.dataId,shape:c,dtype:r.dtype}):function(e,t,n){const a=[lee(e.shape),...uee(e.shape)],r={dtype:e.dtype,shape:a,dataId:e.dataId},o=[lee(t),...uee(t)],s=new cne(o,a),i=[a],c=n.runWebGLProgram(s,[r],e.dtype,i,!0);return{dataId:c.dataId,shape:t,dtype:c.dtype}}(r,c,s)}const rae={kernelName:Dj,backendName:"webgl",kernelFunc:aae};class oae{constructor(e,t){this.variableNames=["x"];const{windowSize:n,batchSize:a,inSize:r,outSize:o}=e;this.outputShape=[a,o];const s=4*Math.floor(n/4),i=n%4;let c="sumValue += dot(values, ones);";if(null!=t){const e=1/t;c="sumValue += dot(values * ".concat(HU(e)?e.toPrecision(2):e,", ones);")}let l="";r%n>0&&(l="\n        if (inIdx < 0 || inIdx >= ".concat(r,") {\n          return 0.0;\n        }\n      ")),this.userCode="\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float getValue(int batch, int inIdx) {\n        ".concat(l,"\n        return getX(batch, inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ").concat(n,";\n\n        float sumValue = 0.0;\n\n        for (int i = 0; i < ").concat(s,"; i += 4) {\n          int inIdx = inOffset + i;\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          ").concat(c,"\n        }\n\n        int inIdx = inOffset + ").concat(s,";\n        if (").concat(1===i,") {\n          vec4 values = vec4(getValue(batch, inIdx), 0.0, 0.0, 0.0);\n\n          ").concat(c,"\n        } else if (").concat(2===i,") {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1), 0.0, 0.0);\n\n          ").concat(c,"\n        } else if (").concat(3===i,") {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2), 0.0);\n\n          ").concat(c,"\n        }\n        setOutput(sumValue);\n      }\n    ")}}class sae{constructor(e,t){this.variableNames=["x"];const{windowSize:n,batchSize:a,inSize:r,outSize:o}=e;this.outputShape=[a,o];let s="0.0",i="";"prod"===t?s="1.0":"min"===t?(s="1.0 / 1e-20",i="min"):"max"===t&&(s="-1.0 / 1e-20",i="max");let c="".concat(t,"(").concat(t,"(").concat(t,"(")+"minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])";"sum"===t?c="sumValue":"prod"===t?c="prodValue":"all"===t?c="allValue":"any"===t&&(c="anyValue");const l=4*Math.floor(n/4),u=n%4;let d="\n      if (".concat("sum"===t,") {\n        sumValue += dot(values, ones);\n      } else if (").concat("prod"===t,") {\n        vec2 tmp = vec2(values[0], values[1]) * vec2(values[2], values[3]);\n        prodValue *= tmp[0] * tmp[1];\n      } else {\n        minMaxValue = ").concat(i,"(values, minMaxValue);\n        if (").concat("min"===t," || ").concat("max"===t,") {\n          minMaxValue = ").concat(i,"(values, minMaxValue);\n          bvec4 isNaN = isnan(values);\n          if (isNaN.r || isNaN.g || isNaN.b || isNaN.a) {\n            minMaxValue = vec4(NAN);\n          }\n        }\n      }\n    "),h="vec4";"all"===t?(s="1.0",d="\n        bool reducedAllValue = all(values);\n        float floatedReducedAllValue = float(reducedAllValue);\n        allValue = float(allValue >= 1.0 && floatedReducedAllValue >= 1.0);\n      ",h="bvec4"):"any"===t&&(s="0.0",d="\n        bool reducedAnyValue = any(values);\n        float floatedReducedAnyValue = float(reducedAnyValue);\n        anyValue = float(anyValue >= 1.0 || floatedReducedAnyValue >= 1.0);\n      ",h="bvec4");let p="";r%n>0&&(p="\n        if (inIdx < 0 || inIdx >= ".concat(r,") {\n          return initializationValue;\n        }\n      ")),this.userCode="\n      const float initializationValue = ".concat(s,";\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float getValue(int batch, int inIdx) {\n        ").concat(p,"\n        return getX(batch, inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ").concat(n,";\n\n        vec4 minMaxValue = vec4(").concat(s,");\n        float prodValue = 1.0;\n        float sumValue = 0.0;\n        float allValue = 1.0;\n        float anyValue = 0.0;\n\n        for (int i = 0; i < ").concat(l,"; i += 4) {\n          int inIdx = inOffset + i;\n          ").concat(h," values = ").concat(h,"(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          ").concat(d,"\n        }\n\n        int inIdx = inOffset + ").concat(l,";\n        if (").concat(1===u,") {\n          ").concat(h," values = ").concat(h,"(\n            getValue(batch, inIdx),\n            initializationValue,\n            initializationValue,\n            initializationValue\n          );\n\n          ").concat(d,"\n        } else if (").concat(2===u,") {\n          ").concat(h," values = ").concat(h,"(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            initializationValue,\n            initializationValue\n          );\n\n          ").concat(d,"\n        } else if (").concat(3===u,") {\n          ").concat(h," values = ").concat(h,"(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            initializationValue\n          );\n\n          ").concat(d,"\n        }\n        setOutput(").concat(c,");\n      }\n    ")}}function iae(e,t,n,a){const r=function(e){const t=[];for(;0===t.length||1!==t[t.length-1].outSize;){const n=t.length?t[t.length-1].outSize:e[1],a=c2(n);t.push({inSize:n,windowSize:a,outSize:Math.ceil(n/a)})}return t}(e.shape);let o=e;for(let s=0;s<r.length;s++){const{inSize:i,windowSize:c,outSize:l}=r[s];let u,d;u="mean"===n?0===s?new oae({windowSize:c,inSize:i,batchSize:e.shape[0],outSize:l},i):new oae({windowSize:c,inSize:i,batchSize:e.shape[0],outSize:l}):new sae({windowSize:c,inSize:i,batchSize:e.shape[0],outSize:l},n),d=o,o=a.runWebGLProgram(u,[o],t),d.dataId!==e.dataId&&a.disposeIntermediateTensorInfo(d)}return o}class cae{constructor(e,t){this.variableNames=["A"];const n=new Array(e.length);for(let o=0;o<n.length;o++)n[o]=e[t[o]];this.outputShape=n,this.rank=n.length;const a=zee(this.rank),r=function(e){const t=e.length;if(t>6)throw Error("Transpose for rank ".concat(t," is not yet supported"));const n=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u","resRC.v"],a=new Array(t);for(let r=0;r<e.length;r++)a[e[r]]=n[r];return a.join()}(t);this.userCode="\n    void main() {\n      ".concat(a," resRC = getOutputCoords();\n      setOutput(getA(").concat(r,"));\n    }\n    ")}}class lae{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0;const n=new Array(e.length);for(let l=0;l<n.length;l++)n[l]=e[t[l]];if(this.outputShape=n,this.rank=n.length,this.rank>6)throw Error("Packed transpose for rank ".concat(this.rank," is not yet supported."));const a=zee(this.rank),r=one("rc",this.rank),o=new Array(this.rank);for(let l=0;l<t.length;l++)o[t[l]]=r[l];const s="vec2(".concat(o.slice(-2).join(),")"),i="++".concat(r[this.rank-1]," < ").concat(n[this.rank-1]),c="getChannel(getA(".concat(o.join(),"), ").concat(s,")");this.userCode="\n    void main() {\n      ".concat(a," rc = getOutputCoords();\n      vec4 result = vec4(0.);\n      result[0] = ").concat(c,";\n      if(").concat(i,") {\n        result[1] = ").concat(c,";\n      }\n      --").concat(r[this.rank-1],";\n      if(++").concat(r[this.rank-2]," < ").concat(n[this.rank-2],") {\n        result[2] = ").concat(c,";\n        if(").concat(i,") {\n          result[3] = ").concat(c,";\n        }\n      }\n      setOutput(result);\n    }\n    ")}}function uae(e,t,n){const a=yG().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new lae(e.shape,t):new cae(e.shape,t);return n.runWebGLProgram(a,[e],e.dtype)}function dae(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{axis:o,keepDims:s}=a;return function(e,t,n,a){const r=t,o=e.shape.length,s=YU(r,e.shape);let i=s;const c=sZ(i,o),l=null!=c;let u=e;l&&(u=uae(e,c,a),i=cZ(i.length,o)),oZ("sum",i,o);const[d,h]=aZ(u.shape,i);let p=d;n&&(p=rZ(d,s));const f=UU(h),m=aae({inputs:{x:u},attrs:{shape:[UU(e.shape)/f,f]},backend:a}),g=iae(m,Mq(e.dtype),"sum",a),b=aae({inputs:{x:g},attrs:{shape:p},backend:a});return a.disposeIntermediateTensorInfo(m),a.disposeIntermediateTensorInfo(g),l&&a.disposeIntermediateTensorInfo(u),b}(r,o,s,n)}const hae={kernelName:tK,backendName:"webgl",kernelFunc:dae};function pae(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{perm:o}=a,s=n,i=r.shape.length,c=new Array(i);for(let u=0;u<c.length;u++)c[u]=r.shape[o[u]];let l;if(s.shouldExecuteOnCPU([r])){const e=s.texData.get(r.dataId).values,t=ane(e,r.shape,r.dtype,o,c);l=s.makeTensorInfo(c,r.dtype);s.texData.get(l.dataId).values=t}else l=uae(r,o,s);return l}const fae={kernelName:IK,backendName:"webgl",kernelFunc:pae},mae=1e3;function gae(e){let{a:t,b:n,transposeA:a,transposeB:r,backend:o,bias:s=null,preluActivationWeights:i=null,leakyreluAlpha:c=0,activation:l=null}=e;const u=t.shape.length,d=n.shape.length,h=a?t.shape[u-2]:t.shape[u-1],p=r?n.shape[d-1]:n.shape[d-2],f=a?t.shape[u-1]:t.shape[u-2],m=r?n.shape[d-2]:n.shape[d-1],g=t.shape.slice(0,-2),b=n.shape.slice(0,-2),y=UU(g),x=UU(b),v=VY(t.shape.slice(0,-2),n.shape.slice(0,-2)).concat([f,m]);BU(h===p,(()=>"Error in matMul: inner shapes (".concat(h,") and (")+"".concat(p,") of Tensors with shapes ").concat(t.shape," and ")+"".concat(n.shape," and transposeA=").concat(a)+" and transposeB=".concat(r," must match.")));const w=a?[y,h,f]:[y,f,h],k=r?[x,m,p]:[x,p,m],I=aae({inputs:{x:t},backend:o,attrs:{shape:w}}),S=aae({inputs:{x:n},backend:o,attrs:{shape:k}}),N=[I,S],C=Math.max(y,x),T=a?I.shape[1]:I.shape[2],E=null!=s,R=null!=i,_="leakyrelu"===l,A=null!=l?Qne(l,!0):null;let F;if((1===f||1===m)&&T>mae&&!1===(E||R||_||null!=A)){let e=I,t=S;a&&(e=pae({inputs:{x:I},backend:o,attrs:{perm:[0,2,1]}}),N.push(e)),r&&(t=pae({inputs:{x:S},backend:o,attrs:{perm:[0,2,1]}}),N.push(t));const n=1===m;let s=e;1!==m&&(s=aae({inputs:{x:e},backend:o,attrs:{shape:[C,T,1]}}),N.push(s));const i=1===m?2:1;let c=t;n&&(c=aae({inputs:{x:t},backend:o,attrs:{shape:[C,1,T]}}),N.push(c));const l=tae({inputs:{a:s,b:c},backend:o});F=dae({inputs:{x:l},backend:o,attrs:{axis:i,keepDims:!0}}),N.push(l)}else{const e=Dq(t.dtype,n.dtype),l=new Jne(w,k,[C,f,m],a,r,E,A,R,_),u=[I,S];if(null!=s&&u.push(s),R&&u.push(i),_){const e=o.makeTensorInfo([],"float32",aq(c,"float32"));u.push(e),N.push(e)}F=o.runWebGLProgram(l,u,e)}const O=aae({inputs:{x:F},backend:o,attrs:{shape:v}});N.push(F);for(const D of N)o.disposeIntermediateTensorInfo(D);return O}const bae={kernelName:AK,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{a:r,b:o,bias:s,preluActivationWeights:i}=t,{transposeA:c,transposeB:l,activation:u,leakyreluAlpha:d}=a;return gae({a:r,b:o,transposeA:c,transposeB:l,backend:n,bias:s,preluActivationWeights:i,leakyreluAlpha:d,activation:u})}},yae="return abs(x);";const xae={kernelName:IG,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{x:a}=t;if(n.shouldExecuteOnCPU([a])&&"complex64"!==a.dtype){const e=n.texData.get(a.dataId),t=Gte(e.values);return n.makeTensorInfo(a.shape,a.dtype,t)}let r;return r=yG().getBool("WEBGL_PACK_UNARY_OPERATIONS")?new Tne(a.shape,yae):new pne(a.shape,yae),n.runWebGLProgram(r,[a],a.dtype)}},vae=Xne({opSnippet:fne+"\n  if (abs(x) > 1.) {\n    return NAN;\n  }\n  return acos(x);\n"}),wae={kernelName:SG,backendName:"webgl",kernelFunc:vae},kae=Xne({opSnippet:fne+"\n  if (x < 1.0) return NAN;\nreturn log(x + sqrt(x * x - 1.0));"}),Iae={kernelName:NG,backendName:"webgl",kernelFunc:kae},Sae="return a + b;",Nae=Yne({opSnippet:Sae,packedOpSnippet:Sae,supportsComplex:!0,cpuKernelImpl:ute}),Cae={kernelName:CG,backendName:"webgl",kernelFunc:Nae};class Tae{constructor(e,t){this.outputShape=[],this.outputShape=e,this.variableNames=t.map(((e,t)=>"T".concat(t)));const n=[];this.variableNames.forEach((e=>{n.push("float v".concat(e," = get").concat(e,"AtOutCoords();"))}));const a=this.variableNames.map((e=>"v".concat(e))).join(" + ");this.userCode="\n      void main() {\n        ".concat(n.join("\n        "),"\n\n        float result = ").concat(a,";\n        setOutput(result);\n      }\n    ")}}class Eae{constructor(e,t){this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.variableNames=t.map(((e,t)=>"T".concat(t)));const n=[];this.variableNames.forEach((e=>{n.push("vec4 v".concat(e," = get").concat(e,"AtOutCoords();"))}));const a=this.variableNames.map((e=>"v".concat(e))).join(" + ");this.userCode="\n      void main() {\n        ".concat(n.join("\n        "),"\n\n        vec4 result = ").concat(a,";\n        setOutput(result);\n      }\n    ")}}const Rae={kernelName:TG,backendName:"webgl",kernelFunc:function e(t){const{inputs:n,backend:a}=t,r=n;if(1===r.length)return Pne({inputs:{x:r[0]},backend:a});if(r.length>yG().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER")){const t=Math.floor(r.length/2),n=e({inputs:r.slice(0,t),backend:a}),o=e({inputs:r.slice(t),backend:a});return e({inputs:[n,o],backend:a})}const o=r.map((e=>e.dtype)).reduce(((e,t)=>Dq(e,t))),s=r.map((e=>e.shape)),i=yG().getBool("WEBGL_PACK")?new Eae(r[0].shape,s):new Tae(r[0].shape,s);return a.runWebGLProgram(i,r,o)}};const _ae={kernelName:EG,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{axis:o,keepDims:s}=a,i=r.shape.length,c=YU(o,r.shape);let l=c;const u=sZ(l,i);let d=r;null!=u&&(d=pae({inputs:{x:r},backend:n,attrs:{perm:u}}),l=cZ(l.length,i)),oZ("all",l,i);const[h,p]=aZ(d.shape,l),f=aae({inputs:{x:d},backend:n,attrs:{shape:[-1,UU(p)]}}),m=iae(f,f.dtype,"all",n);let g;if(s){g=aae({inputs:{x:m},backend:n,attrs:{shape:rZ(h,c)}})}else g=aae({inputs:{x:m},backend:n,attrs:{shape:h}});return n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),null!=u&&n.disposeIntermediateTensorInfo(d),g}};const Aae={kernelName:RG,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{axis:o,keepDims:s}=a,i=r.shape.length,c=YU(o,r.shape);let l=c;const u=sZ(l,i);let d=r;null!=u&&(d=pae({inputs:{x:r},backend:n,attrs:{perm:u}}),l=cZ(l.length,i)),oZ("any",l,i);const[h,p]=aZ(d.shape,l),f=aae({inputs:{x:d},backend:n,attrs:{shape:[-1,UU(p)]}}),m=iae(f,f.dtype,"any",n);let g;if(s){g=aae({inputs:{x:m},backend:n,attrs:{shape:rZ(h,c)}})}else g=aae({inputs:{x:m},backend:n,attrs:{shape:h}});return n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),null!=u&&n.disposeIntermediateTensorInfo(d),g}};class Fae{constructor(e,t,n){this.variableNames=["A"];const{windowSize:a,batchSize:r,outSize:o}=e;n||this.variableNames.push("bestIndicesA"),this.outputShape=[r,o];const s="max"===t?">":"<",i=n?"inOffset + i;":"round(getBestIndicesA(batch, inOffset + i));";this.userCode="\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ".concat(a,";\n\n        int bestIndex = inOffset;\n        float bestValue = getA(batch, bestIndex);\n\n        for (int i = 0; i < ").concat(a,"; i++) {\n          int inIdx = ").concat(i,";\n          float candidate = getA(batch, inIdx);\n          if (candidate ").concat(s," bestValue) {\n            bestValue = candidate;\n            bestIndex = inIdx;\n          }\n        }\n        setOutput(float(bestIndex));\n      }\n    ")}}class Oae{constructor(e,t,n,a){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,BU(e.length>2,(()=>"Packed arg".concat(n.charAt(0).toUpperCase()+n.slice(1)," supports only inputs with rank above 2.")));const r=e[e.length-1],o=Math.ceil(r/t);this.outputShape=e.slice(0,-1),o>1&&this.outputShape.push(o),a||this.variableNames.push("bestIndicesA");const s=this.outputShape,i=s.length,c=zee(i),l=sne("coords",i);let u,d;if(1===o){d=i+1;const e=zee(d);u="\n        ".concat(e," sourceLocR = ").concat(e,"(").concat(l.join(),", 0);\n        ++").concat(l[i-1],";\n        ").concat(e," sourceLocG = ").concat(e,"(").concat(l.join(),", 0);\n        ++").concat(l[i-2],";\n        ").concat(e," sourceLocA = ").concat(e,"(").concat(l.join(),", 0);\n        --").concat(l[i-1],";\n        ").concat(e," sourceLocB = ").concat(e,"(").concat(l.join(),", 0);\n        --").concat(l[i-2],";")}else d=i,u="\n        ".concat(c," sourceLocR = coords;\n        ++").concat(l[i-1],";\n        ").concat(c," sourceLocG = coords;\n        ++").concat(l[i-2],";\n        ").concat(c," sourceLocA = coords;\n        --").concat(l[i-1],";\n        ").concat(c," sourceLocB = coords;\n        --").concat(l[i-2],";");const h=["x","y","z","w","u","v"].slice(0,d),p="."+h[d-1],f=h.map((e=>"int "+e)),m=sne("sourceLocR",d-1).concat("inIdx.r"),g=sne("sourceLocG",d-1).concat("inIdx.g"),b=sne("sourceLocB",d-1).concat("inIdx.b"),y=sne("sourceLocA",d-1).concat("inIdx.a"),x="max"===n?"greaterThan":"lessThan",v=a?"":"\n          inIdx = round(vec4(getBestIndicesAChannel(".concat(m.join(),"),\n                             getBestIndicesAChannel(").concat(g.join(),"),\n                             getBestIndicesAChannel(").concat(b.join(),"),\n                             getBestIndicesAChannel(").concat(y.join(),")));"),w="vec4(\n            getAChannel(".concat(m.join(),"),\n            hasNextCol ? getAChannel(").concat(g.join(),") : 0.,\n            hasNextRow ? getAChannel(").concat(b.join(),") : 0.,\n            hasNextRow && hasNextCol ? getAChannel(").concat(y.join(),") : 0.)"),k=a?"":"\n      float getBestIndicesAChannel(".concat(f.join(),") {\n        return getChannel(getBestIndicesA(").concat(h.join(),"),\n                                          vec2(").concat(h.slice(-2).join(),"));\n      }");this.userCode="\n      float getAChannel(".concat(f.join(),") {\n        return getChannel(getA(").concat(h.join(),"),\n                               vec2(").concat(h.slice(-2).join(),"));\n      }\n      ").concat(k,"\n      void main() {\n        ").concat(c," coords = getOutputCoords();\n        bool hasNextCol = ").concat(l[i-1]," < ").concat(s[i-1]-1,";\n        bool hasNextRow = ").concat(l[i-2]," < ").concat(s[i-2]-1,";\n        ").concat(u,"\n        ivec4 srcIdx = ivec4(sourceLocR").concat(p,", sourceLocG").concat(p,",\n          sourceLocB").concat(p,", sourceLocA").concat(p,") * ").concat(t,";\n        ivec4 inIdx = srcIdx;\n        vec4 bestIndex = vec4(inIdx);\n        vec4 bestValue = ").concat(w,";\n\n        for (int i = 0; i < ").concat(t,"; i++) {\n          inIdx = srcIdx;\n          ").concat(v,"\n          vec4 candidate = ").concat(w,";\n          bvec4 nan = isnan(candidate);\n          bvec4 replace = bvec4(\n            vec4(").concat(x,"(candidate, bestValue)) * (vec4(1.0) - vec4(nan)));\n\n          bestValue = vec4(replace.x  ? candidate.x : bestValue.x,\n                           replace.y  ? candidate.y : bestValue.y,\n                           replace.z  ? candidate.z : bestValue.z,\n                           replace.w  ? candidate.w : bestValue.w);\n          bestIndex = mix(bestIndex, vec4(inIdx), vec4(replace));\n          srcIdx++;\n        }\n        setOutput(bestIndex);\n      }\n    ")}}function Dae(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:null,r=t.shape[0],o=t.shape[1];null!=a&&(r=a.shape[0],o=a.shape[1]);const s=c2(o),i={windowSize:s,inSize:o,batchSize:r,outSize:Math.ceil(o/s)},c=new Fae(i,n,null==a),l=[t];null!=a&&l.push(a);const u=e.runWebGLProgram(c,l,"int32");if(1===u.shape[1])return u;const d=Dae(e,t,n,u);return e.disposeIntermediateTensorInfo(u),d}function Mae(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:null;const r=null!=a?a.shape:t.shape,o=c2(r[r.length-1]),s=new Oae(r,o,n,null==a),i=null==a?[t]:[t,a],c=e.runWebGLProgram(s,i,"int32");if(c.shape.length===t.shape.length){const a=Mae(e,t,n,c);return e.disposeIntermediateTensorInfo(c),a}return c}function Lae(e,t,n,a){const r=[n];if(oZ("arg"+a.charAt(0).toUpperCase()+a.slice(1),r,t.shape.length),!yG().getBool("WEBGL_PACK_REDUCE")||t.shape.length<=2){const n=[],o=e.texData.get(t.dataId);let s=t;null!==o&&o.isPacked&&(s=e.unpackTensor(t),n.push(s));const[i,c]=aZ(s.shape,r),l=UU(c),u=aae({inputs:{x:s},backend:e,attrs:{shape:[-1,l]}});n.push(u);const d=Dae(e,u,a);n.push(d);const h=aae({inputs:{x:d},backend:e,attrs:{shape:i}});return n.forEach((t=>e.disposeIntermediateTensorInfo(t))),h}return Mae(e,t,a)}const Pae={kernelName:_G,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{axis:o}=a;let s=YU(o,r.shape);const i=sZ(s,r.shape.length);let c=r;const l=[];null!=i&&(c=pae({inputs:{x:r},backend:n,attrs:{perm:i}}),l.push(c),s=cZ(s.length,c.shape.length)),oZ("argMax",[s[0]],c.shape.length);const u=Lae(n,c,s[0],"max");return l.forEach((e=>n.disposeIntermediateTensorInfo(e))),u}};const zae={kernelName:AG,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{axis:o}=a;let s=YU(o,r.shape);const i=sZ(s,r.shape.length);let c=r;const l=[];null!=i&&(c=pae({inputs:{x:r},backend:n,attrs:{perm:i}}),l.push(c),s=cZ(s.length,c.shape.length)),oZ("argMin",[s[0]],c.shape.length);const u=Lae(n,c,s[0],"min");return l.forEach((e=>n.disposeIntermediateTensorInfo(e))),u}},Bae=Xne({opSnippet:fne+"\n  if (abs(x) > 1.) {\n    return NAN;\n  }\n  return asin(x);\n"}),Wae={kernelName:FG,backendName:"webgl",kernelFunc:Bae},Vae=Xne({opSnippet:fne+"return log(x + sqrt(x * x + 1.0));"}),Uae={kernelName:OG,backendName:"webgl",kernelFunc:Vae},Gae=Xne({opSnippet:fne+"\n  return atan(x);\n"}),Hae={kernelName:DG,backendName:"webgl",kernelFunc:Gae},jae=Yne({opSnippet:One+"\n  return atan(a, b);\n",packedOpSnippet:"\n  vec4 result = atan(a, b);\n  bvec4 isNaNA = isnan(a);\n  bvec4 isNaNB = isnan(b);\n  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);\n  "+Mne+"\n  return result;\n"}),Kae={kernelName:LG,backendName:"webgl",kernelFunc:jae},qae=Xne({opSnippet:fne+"\n  if ((x < -1.0) || (x > 1.0)) return NAN;\nreturn (log(1.0 + x) - log(1.0 - x)) / 2.0;"}),Xae={kernelName:MG,backendName:"webgl",kernelFunc:qae};class Yae{constructor(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]&&arguments[3],r=arguments.length>4&&void 0!==arguments[4]&&arguments[4];if(this.variableNames=["x"],"avg"===t&&n)throw new Error("Cannot compute positions for average pool.");const o=e.filterWidth,s=e.strideHeight,i=e.strideWidth,c=e.dilationHeight,l=e.dilationWidth,u=e.effectiveFilterHeight,d=e.effectiveFilterWidth,h=e.padInfo.top,p=e.padInfo.left;this.outputShape=e.outShape;const f="avg"===t,m="((batch  * ".concat(e.inHeight," + xR) * ").concat(e.inWidth," + xC) * ").concat(e.inChannels," + d"),g="(xR * ".concat(e.inWidth," + xC) * ").concat(e.inChannels," + d");let b="0.0";if(f||(b="-1.0 / 1e-20"),n){const t=">=";return void(this.userCode="\n        const ivec2 strides = ivec2(".concat(s,", ").concat(i,");\n        const ivec2 pads = ivec2(").concat(h,", ").concat(p,");\n\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int batch = coords[0];\n          int d = coords[3];\n\n          ivec2 xRCCorner = coords.yz * strides - pads;\n          int xRCorner = xRCCorner.x;\n          int xCCorner = xRCCorner.y;\n\n          // max/min x(?, ?, d) to get y(yR, yC, d).\n          // ? = to be determined\n          float minMaxValue = 0.0;\n          float minMaxValueFound = 0.0;\n          int minMaxPosition = 0;\n          float avgValue = 0.0;\n\n          for (int wR = 0; wR < ").concat(u,";\n              wR += ").concat(c,") {\n            int xR = xRCorner + wR;\n\n            if (xR < 0 || xR >= ").concat(e.inHeight,") {\n              continue;\n            }\n\n            for (int wC = 0; wC < ").concat(d,";\n                wC += ").concat(l,") {\n              int xC = xCCorner + wC;\n\n              if (xC < 0 || xC >= ").concat(e.inWidth,") {\n                continue;\n              }\n\n              float value = getX(batch, xR, xC, d);\n\n              // If a min / max value has already been found, use it. If not,\n              // use the current value.\n              float currMinMaxValue = mix(\n                  value, minMaxValue, minMaxValueFound);\n              if (value ").concat(t," currMinMaxValue) {\n                minMaxValue = value;\n                minMaxValueFound = 1.0;\n                minMaxPosition = ").concat(a?r?m:g:"wR * ".concat(d," + wC"),";\n              }\n            }\n          }\n          setOutput(float(minMaxPosition));\n        }\n      "))}let y="".concat(t,"(").concat(t,"(").concat(t,"(")+"minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])";"avg"===t&&(y="avgValue / max(count, 1.0)");const x=4*Math.floor(o/4),v=o%4,w="\n      if (".concat(f,") {\n        avgValue += dot(values, ones);\n      } else {\n        minMaxValue = ").concat("max","(values, minMaxValue);\n      }\n    ");this.userCode="\n      const ivec2 strides = ivec2(".concat(s,", ").concat(i,");\n      const ivec2 pads = ivec2(").concat(h,", ").concat(p,");\n      const float initializationValue = ").concat(b,";\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float count = 0.0;\n\n      float getValue(int batch, int xR, int xC, int d) {\n        if (xC < 0 || xC >= ").concat(e.inWidth,") {\n          return initializationValue;\n        }\n        count += 1.0;\n        return getX(batch, xR, xC, d);\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d = coords[3];\n\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // max/min x(?, ?, d) to get y(yR, yC, d).\n        // ? = to be determined\n        vec4 minMaxValue = vec4(").concat(b,");\n        float avgValue = 0.0;\n        count = 0.0;\n\n        for (int wR = 0; wR < ").concat(u,";\n            wR += ").concat(c,") {\n          int xR = xRCorner + wR;\n\n          if (xR < 0 || xR >= ").concat(e.inHeight,") {\n            continue;\n          }\n\n          for (int wC = 0; wC < ").concat(x,"; wC += 4) {\n            int xC = xCCorner + wC * ").concat(l,";\n\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ").concat(l,", d),\n              getValue(batch, xR, xC + 2 * ").concat(l,", d),\n              getValue(batch, xR, xC + 3 * ").concat(l,", d)\n            );\n\n            ").concat(w,"\n          }\n\n          int xC = xCCorner + ").concat(x,";\n          if (").concat(1===v,") {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              initializationValue,\n              initializationValue,\n              initializationValue\n            );\n\n            ").concat(w,"\n          } else if (").concat(2===v,") {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ").concat(l,", d),\n              initializationValue,\n              initializationValue\n            );\n\n            ").concat(w,"\n          } else if (").concat(3===v,") {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ").concat(l,", d),\n              getValue(batch, xR, xC + 2 * ").concat(l,", d),\n              initializationValue\n            );\n\n            ").concat(w,"\n          }\n        }\n        setOutput(").concat(y,");\n      }\n    ")}}class Qae{constructor(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]&&arguments[3],r=arguments.length>4&&void 0!==arguments[4]&&arguments[4];if(this.variableNames=["x"],"avg"===t&&n)throw new Error("Cannot compute positions for average pool.");const o=e.filterWidth,s=e.strideDepth,i=e.strideHeight,c=e.strideWidth,l=e.dilationDepth,u=e.dilationHeight,d=e.dilationWidth,h=e.effectiveFilterDepth,p=e.effectiveFilterHeight,f=e.effectiveFilterWidth,m=e.padInfo.front,g=e.padInfo.top,b=e.padInfo.left;this.outputShape=e.outShape;const y="avg"===t;let x="0.0";if(y||(x="-1.0 / 1e-20"),n){const t=">=";return void(this.userCode="\n        const ivec3 strides =\n            ivec3(".concat(s,", ").concat(i,", ").concat(c,");\n        const ivec3 pads = ivec3(").concat(m,", ").concat(g,", ").concat(b,");\n\n        void main() {\n          ivec5 coords = getOutputCoords();\n          int batch = coords.x;\n          int ch = coords.u;\n\n          ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n          int xDCorner = xCorner.x;\n          int xRCorner = xCorner.y;\n          int xCCorner = xCorner.z;\n\n          // max/min x(?, ?, ?, ch) to get y(yD, yR, yC, ch).\n          // ? = to be determined\n          float minMaxValue = 0.0;\n          float minMaxValueFound = 0.0;\n          int minMaxPosition = 0;\n\n          for (int wD = 0; wD < ").concat(h,";\n              wD += ").concat(l,") {\n            int xD = xDCorner + wD;\n\n            if (xD < 0 || xD >= ").concat(e.inDepth,") {\n              continue;\n            }\n\n            for (int wR = 0; wR < ").concat(p,";\n                wR += ").concat(u,") {\n              int xR = xRCorner + wR;\n\n              if (xR < 0 || xR >= ").concat(e.inHeight,") {\n                continue;\n              }\n\n              for (int wC = 0; wC < ").concat(f,";\n                  wC += ").concat(d,") {\n                int xC = xCCorner + wC;\n\n                if (xC < 0 || xC >= ").concat(e.inWidth,") {\n                  continue;\n                }\n\n                float value = getX(batch, xD, xR, xC, ch);\n\n                // If a min / max value has already been found, use it. If not,\n                // use the current value.\n                float currMinMaxValue = mix(\n                    value, minMaxValue, minMaxValueFound);\n                if (value ").concat(t," currMinMaxValue) {\n                  minMaxValue = value;\n                  minMaxValueFound = 1.0;\n                  minMaxPosition = ").concat(a?r?"(((batch * ".concat(e.inDepth," + xD) * ").concat(e.inHeight," + xR) * ").concat(e.inWidth," + xC) * ").concat(e.inChannels," + ch"):"((xD * ".concat(e.inHeight," + xR) * ").concat(e.inWidth," + xC) * ").concat(e.inChannels," + ch"):"wD * ".concat(p," * ").concat(f," +\n                      wR * ").concat(f," + wC"),";\n                }\n              }\n            }\n          }\n          setOutput(float(minMaxPosition));\n        }\n      "))}let v="".concat(t,"(").concat(t,"(").concat(t,"(")+"minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])";"avg"===t&&(v="avgValue / max(count, 1.0)");const w=4*Math.floor(o/4),k=o%4,I="\n      if (".concat(y,") {\n        avgValue += dot(values, ones);\n      } else {\n        minMaxValue = ").concat("max","(values, minMaxValue);\n      }\n    ");this.userCode="\n      const ivec3 strides =\n        ivec3(".concat(s,", ").concat(i,", ").concat(c,");\n      const ivec3 pads = ivec3(").concat(m,", ").concat(g,", ").concat(b,");\n      const float initializationValue = ").concat(x,";\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float count = 0.0;\n\n      float getValue(int batch, int xD, int xR, int xC, int ch) {\n        if (xC < 0 || xC >= ").concat(e.inWidth,") {\n          return initializationValue;\n        }\n        count += 1.0;\n        return getX(batch, xD, xR, xC, ch);\n      }\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n        int xDCorner = xCorner.x;\n        int xRCorner = xCorner.y;\n        int xCCorner = xCorner.z;\n\n        // max/min x(?, ?, ?, d) to get y(yD, yR, yC, ch).\n        // ? = to be determined\n        vec4 minMaxValue = vec4(").concat(x,");\n        float avgValue = 0.0;\n        count = 0.0;\n\n        for (int wD = 0; wD < ").concat(h,";\n            wD += ").concat(l,") {\n          int xD = xDCorner + wD;\n\n          if (xD < 0 || xD >= ").concat(e.inDepth,") {\n            continue;\n          }\n\n          for (int wR = 0; wR < ").concat(p,";\n            wR += ").concat(u,") {\n            int xR = xRCorner + wR;\n\n            if (xR < 0 || xR >= ").concat(e.inHeight,") {\n              continue;\n            }\n\n            for (int wC = 0; wC < ").concat(w,"; wC += 4) {\n              int xC = xCCorner + wC * ").concat(d,";\n\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ").concat(d,", ch),\n                getValue(batch, xD, xR, xC + 2 * ").concat(d,", ch),\n                getValue(batch, xD, xR, xC + 3 * ").concat(d,", ch)\n              );\n\n              ").concat(I,"\n            }\n\n            int xC = xCCorner + ").concat(w,";\n            if (").concat(1===k,") {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                initializationValue,\n                initializationValue,\n                initializationValue\n              );\n\n              ").concat(I,"\n            } else if (").concat(2===k,") {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ").concat(d,", ch),\n                initializationValue,\n                initializationValue\n              );\n\n              ").concat(I,"\n            } else if (").concat(3===k,") {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ").concat(d,", ch),\n                getValue(batch, xD, xR, xC + 2 * ").concat(d,", ch),\n                initializationValue\n              );\n\n              ").concat(I,"\n            }\n          }\n        }\n        setOutput(").concat(v,");\n      }\n    ")}}const Jae={kernelName:PG,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t;vee(r,"avgPool");const{filterSize:o,strides:s,pad:i,dimRoundingMode:c}=a;BU(aJ(s,1),(()=>"Error in avgPool: Either strides or dilations must be 1. "+"Got strides ".concat(s," and dilations '").concat(1,"'")));const l=qQ(r.shape,o,s,1,i,c);if(1===l.filterWidth&&1===l.filterHeight&&GU(l.inShape,l.outShape))return Pne({inputs:{x:r},backend:n});const u=new Yae(l,"avg",!1);return n.runWebGLProgram(u,[r],"float32")}};const Zae={kernelName:BG,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{filterSize:o,strides:s,pad:i,dimRoundingMode:c,dataFormat:l}=a,u=XQ(r.shape,o,s,[1,1,1],i,c,l),d=new Qae(u,"avg",!1);return n.runWebGLProgram(d,[r],"float32")}};class $ae{constructor(e){this.variableNames=["dy"],this.outputShape=e.inShape;const t=e.filterHeight,n=e.filterWidth,a=e.strideHeight,r=e.strideWidth,o=e.dilationHeight,s=e.dilationWidth,i=e.effectiveFilterHeight,c=e.effectiveFilterWidth,l=i-1-e.padInfo.top,u=c-1-e.padInfo.left,d=1/(t*n);this.userCode="\n      const ivec2 pads = ivec2(".concat(l,", ").concat(u,");\n      const float avgMultiplier = float(").concat(d,");\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n\n        ivec2 dyRCCorner = coords.yz - pads;\n        int dyRCorner = dyRCCorner.x;\n        int dyCCorner = dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ").concat(i,";\n            wR += ").concat(o,") {\n          float dyR = float(dyRCorner + wR) / ").concat(a,".0;\n\n          if (dyR < 0.0 || dyR >= ").concat(e.outHeight,".0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          for (int wC = 0; wC < ").concat(c,";\n            wC+= ").concat(s,") {\n            float dyC = float(dyCCorner + wC) / ").concat(r,".0;\n\n            if (dyC < 0.0 || dyC >= ").concat(e.outWidth,".0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            float dyValue = getDy(b, idyR, idyC, d);\n\n            dotProd += dyValue * avgMultiplier;\n          }\n        }\n        setOutput(dotProd);\n      }\n    ")}}class ere{constructor(e){this.variableNames=["dy"],this.outputShape=e.inShape;const t=e.filterDepth,n=e.filterHeight,a=e.filterWidth,r=e.strideDepth,o=e.strideHeight,s=e.strideWidth,i=e.dilationDepth,c=e.dilationHeight,l=e.dilationWidth,u=e.effectiveFilterDepth,d=e.effectiveFilterHeight,h=e.effectiveFilterWidth,p=u-1-e.padInfo.front,f=d-1-e.padInfo.top,m=h-1-e.padInfo.left,g=1/(t*n*a);this.userCode="\n      const ivec3 pads = ivec3(".concat(p,", ").concat(f,", ").concat(m,");\n      const float avgMultiplier = float(").concat(g,");\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyDCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        // Convolve dy(?, ?, ?, d) with pos mask(:, :, :, ch) to get\n        // dx(xD, xR, xC, ch).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int wD = 0; wD < ").concat(u,";\n            wD += ").concat(i,") {\n          float dyD = float(dyDCorner + wD) / ").concat(r,".0;\n\n          if (dyD < 0.0 || dyD >= ").concat(e.outDepth,".0 || fract(dyD) > 0.0) {\n            continue;\n          }\n          int idyD = int(dyD);\n\n          for (int wR = 0; wR < ").concat(d,";\n              wR += ").concat(c,") {\n            float dyR = float(dyRCorner + wR) / ").concat(o,".0;\n\n            if (dyR < 0.0 || dyR >= ").concat(e.outHeight,".0 ||\n                fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            for (int wC = 0; wC < ").concat(h,";\n                wC += ").concat(l,") {\n              float dyC = float(dyCCorner + wC) / ").concat(s,".0;\n\n              if (dyC < 0.0 || dyC >= ").concat(e.outWidth,".0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              float dyValue = getDy(batch, idyD, idyR, idyC, ch);\n\n              dotProd += dyValue * avgMultiplier;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    ")}}const tre={kernelName:WG,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{dy:r,input:o}=t,s=o,{filterSize:i,strides:c,pad:l,dimRoundingMode:u}=a,d=XQ(s.shape,i,c,[1,1,1],l,u),h=new ere(d);return n.runWebGLProgram(h,[r],s.dtype)}};const nre={kernelName:zG,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{dy:r,input:o}=t,s=o;vee([r,o],"avgPoolGrad");const{filterSize:i,strides:c,pad:l}=a,u=qQ(s.shape,i,c,1,l),d=new $ae(u);return n.runWebGLProgram(d,[r],s.dtype)}};const are={kernelName:VG,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{a:r,b:o}=t,{transposeA:s,transposeB:i}=a;return gae({a:r,b:o,transposeA:s,transposeB:i,backend:n})}};class rre{constructor(e,t,n,a,r,o){this.outputShape=[],this.variableNames=["x","mean","variance"],VY(e,t),VY(e,n);let s="0.0";null!=a&&(VY(e,a),this.variableNames.push("offset"),s="getOffsetAtOutCoords()");let i="1.0";null!=r&&(VY(e,r),this.variableNames.push("scale"),i="getScaleAtOutCoords()"),this.outputShape=e,this.userCode="\n      void main() {\n        float x = getXAtOutCoords();\n        float mean = getMeanAtOutCoords();\n        float variance = getVarianceAtOutCoords();\n        float offset = ".concat(s,";\n        float scale = ").concat(i,";\n        float inv = scale * inversesqrt(variance + float(").concat(o,"));\n        setOutput(dot(vec3(x, -mean, offset), vec3(inv, inv, 1)));\n      }\n    ")}}class ore{constructor(e,t,n,a,r,o){this.packedInputs=!0,this.packedOutput=!0,this.variableNames=["x","mean","variance"],VY(e,t),VY(e,n);let s="vec4(0.0)";null!=a&&(VY(e,a),this.variableNames.push("offset"),s="getOffsetAtOutCoords()");let i="vec4(1.0)";null!=r&&(VY(e,r),this.variableNames.push("scale"),i="getScaleAtOutCoords()"),this.outputShape=e,this.userCode="\n      void main() {\n        vec4 offset = ".concat(s,";\n        vec4 scale = ").concat(i,";\n\n        vec4 x = getXAtOutCoords();\n        vec4 mean = getMeanAtOutCoords();\n        vec4 variance = getVarianceAtOutCoords();\n\n        vec4 inv = scale * inversesqrt(variance + vec4(").concat(o,"));\n\n        setOutput((x - mean) * inv + offset);\n      }\n    ")}}const sre={kernelName:OH,backendName:"webgl",kernelFunc:e=>{let{inputs:t,backend:n,attrs:a}=e;const{x:r,mean:o,variance:s,offset:i,scale:c}=t;BU(o.shape.length===s.shape.length,(()=>"Batch normalization gradient requires mean and variance to have equal ranks.")),BU(null==i||o.shape.length===i.shape.length,(()=>"Batch normalization gradient requires mean and offset to have equal ranks.")),BU(null==c||o.shape.length===c.shape.length,(()=>"Batch normalization gradient requires mean and scale to have equal ranks."));let{varianceEpsilon:l}=a;null==l&&(l=.001);const u=[r,o,s];let d=null;null!=i&&(d=i.shape,u.push(i));let h=null;null!=c&&(h=c.shape,u.push(c));const p=yG().getBool("WEBGL_PACK_NORMALIZATION")?new ore(r.shape,o.shape,s.shape,d,h,l):new rre(r.shape,o.shape,s.shape,d,h,l);return n.runWebGLProgram(p,u,u[0].dtype)}};class ire{constructor(e){this.variableNames=["source"],this.outputShape=e,this.rank=e.length;const t=zee(this.rank);this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];const n=function(e){if(1===e)return"sourceLoc";if(e<=6)return cre.slice(0,e).map((e=>"sourceLoc."+e)).join(",");throw Error("Slicing for rank ".concat(e," is not yet supported"))}(this.rank);let a;const r=e.map(((e,t)=>"sourceLoc.".concat(cre[t]," = start[").concat(t,"] + coords.").concat(cre[t],";")));a="\n        ".concat(t," sourceLoc;\n        ").concat(t," coords = getOutputCoords();\n        ").concat(r.join("\n"),"\n      "),this.userCode="\n      void main() {\n        ".concat(a,"\n        setOutput(getSource(").concat(n,"));\n      }\n    ")}}const cre=["x","y","z","w","u","v"];class lre{constructor(e){this.variableNames=["source"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.rank=e.length,this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];const t=zee(this.rank),n=sne("coords",this.rank),a=sne("sourceLoc",this.rank),r=1===this.rank?"sourceLoc":"vec2(".concat(a.slice(-2).join(),")"),o="getChannel(getSource(".concat(a.join(),"), ").concat(r,")"),s="\n      result.x = ".concat(o,";\n      if (++").concat(n[this.rank-1]," < ").concat(e[this.rank-1],") {\n        ++").concat(a[this.rank-1],";\n        result.y = ").concat(o,";\n        --").concat(a[this.rank-1],";\n      }\n    "),i=1===this.rank?"":"\n      --".concat(n[this.rank-1],";\n      if (++").concat(n[this.rank-2]," < ").concat(e[this.rank-2],") {\n        ++").concat(a[this.rank-2],";\n        result.z = ").concat(o,";\n        if (++").concat(n[this.rank-1]," < ").concat(e[this.rank-1],") {\n          ++").concat(a[this.rank-1],";\n          result.w = ").concat(o,";\n        }\n      }\n    "),c=this.rank<=4?"sourceLoc = coords +\n            ".concat(t,"(").concat(e.map(((e,t)=>"start[".concat(t,"]"))).join(),");"):e.map(((e,t)=>"".concat(a[t]," = ").concat(n[t]," + start[").concat(t,"];"))).join("\n");this.userCode="\n      void main() {\n        ".concat(t," coords = getOutputCoords();\n        ").concat(t," sourceLoc;\n        ").concat(c,"\n        vec4 result = vec4(0.);\n        ").concat(s,"\n        ").concat(i,"\n        setOutput(result);\n      }\n    ")}}function ure(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{begin:o,size:s}=a,[i,c]=AQ(r,o,s);if(bQ(r,i,c),0===UU(c))return n.makeTensorInfo(c,r.dtype,[]);if(n.shouldExecuteOnCPU([r])||"string"===r.dtype){const e=n.texData.get(r.dataId),t=Hte(e.values,i,c,r.shape,r.dtype);return n.makeTensorInfo(c,r.dtype,t)}const{isPacked:l}=n.texData.get(r.dataId),u=RQ(r.shape,i,c);if(l||!u){const e=yG().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new lre(c):new ire(c),t=[i];return n.runWebGLProgram(e,[r],r.dtype,t)}return n.uploadToGPU(r.dataId),function(e,t,n,a){const r=a.texData.get(e.dataId),o=a.makeTensorInfo(n,e.dtype),s=a.texData.get(o.dataId);Object.assign(s,r),s.refCount=1,s.shape=n,s.dtype=e.dtype;let i=_Q(t,oG(e.shape));r.slice&&(i+=r.slice.flatOffset),s.slice={flatOffset:i,origDataId:r.slice&&r.slice.origDataId||e.dataId};const c=a.dataRefCount.get(s.slice.origDataId)||1;return a.dataRefCount.set(s.slice.origDataId,c+1),o}(r,i,c,n)}const dre={kernelName:Xj,backendName:"webgl",kernelFunc:ure},hre={kernelName:UG,backendName:"webgl",kernelFunc:e=>{const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{blockShape:o,crops:s}=a;BU(r.shape.length<=4,(()=>"batchToSpaceND for rank > 4 with a WebGL backend not implemented yet"));const i=o.reduce(((e,t)=>e*t)),c=u2(r.shape,o,i),l=d2(c.length,o.length),u=h2(r.shape,o,i),d=p2(s,o.length),h=f2(u,s,o.length),p=[],f=aae({inputs:{x:r},backend:n,attrs:{shape:c}}),m=pae({inputs:{x:f},backend:n,attrs:{perm:l}}),g=aae({inputs:{x:m},backend:n,attrs:{shape:u}}),b=ure({inputs:{x:g},backend:n,attrs:{begin:d,size:h}});return p.push(f),p.push(m),p.push(g),p.forEach((e=>n.disposeIntermediateTensorInfo(e))),b}};const pre={kernelName:GG,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r,weights:o}=t,{size:s}=a,i=n.readSync(r.dataId),c=n.readSync(o.dataId),l=dte(i,c,o.dtype,o.shape,s);return n.makeTensorInfo([s],o.dtype,l)}};const fre={kernelName:HG,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{a:a,b:r}=t,o=yG().getBool("WEBGL_PACK_BINARY_OPERATIONS"),s=yG().getNumber("WEBGL_VERSION");if(n.shouldExecuteOnCPU([a,r])||1===s){const e=n.texData.get(a.dataId).values,t=n.texData.get(r.dataId).values,[o,s]=pte(a.shape,r.shape,e,t,a.dtype),i=n.makeTensorInfo(s,a.dtype);return n.texData.get(i.dataId).values=o,i}let i;return i=o?new Lne("\n  int r = int(a.r) & int(b.r);\n  int g = int(a.g) & int(b.g);\n  int rb = int(a.b) & int(b.b);\n  int ra = int(a.a) & int(b.a);\n  return vec4(r, g, rb, ra);\n",a.shape,r.shape,!1):new Dne("\n  return float(int(a.r) & int(b.r));\n",a.shape,r.shape),n.runWebGLProgram(i,[a,r],a.dtype)}};const mre={kernelName:jG,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{s0:a,s1:r}=t,o=n.readSync(a.dataId),s=n.readSync(r.dataId),i=VY(Array.from(o),Array.from(s));return n.makeTensorInfo([i.length],"int32",Int32Array.from(i))}},gre=Yne({opSnippet:"return float(a != b);",cpuKernelImpl:Dte,dtype:"bool"}),bre={kernelName:gj,backendName:"webgl",kernelFunc:gre};function yre(e){const{inputs:t,backend:n}=e,{input:a}=t;return Pne({inputs:{x:n.texData.get(a.dataId).complexTensorInfos.real},backend:n})}const xre={kernelName:Aj,backendName:"webgl",kernelFunc:yre},vre="return float(int(x));";const wre={kernelName:KG,backendName:"webgl",kernelFunc:function e(t){const{inputs:n,backend:a,attrs:r}=t,{x:o}=n,{dtype:s}=r;if("complex64"===s){if("complex64"===o.dtype)return Pne({inputs:{x:o},backend:a});const t=JZ(o.shape),n=e({inputs:{x:o},backend:a,attrs:{dtype:"float32"}}),r=Bne({inputs:{real:n,imag:t},backend:a});return t.dispose(),a.disposeIntermediateTensorInfo(n),r}if("complex64"===o.dtype){const t=yre({inputs:{input:o},backend:a}),n=e({inputs:{x:t},backend:a,attrs:{dtype:s}});return a.disposeIntermediateTensorInfo(t),n}if(!$U(o.dtype,s)){const e=Pne({inputs:{x:o},backend:a});return{dataId:e.dataId,shape:e.shape,dtype:s}}if(a.shouldExecuteOnCPU([o])){const e=a.texData.get(o.dataId).values,[t,n,r]=fte(e,o.shape,o.dtype,s);return a.makeTensorInfo(t,n,r)}if("int32"===s)return function(e,t){const n=new pne(e.shape,vre),a=t.runWebGLProgram(n,[e],"int32");return{dataId:a.dataId,shape:a.shape,dtype:a.dtype}}(o,a);if("bool"===s){const e=a.makeTensorInfo([],"bool",JU("bool",1)),t=gre({inputs:{a:o,b:e},backend:a});return a.disposeIntermediateTensorInfo(e),t}throw new Error("Error in Cast: failed to cast ".concat(o.dtype," to ").concat(s))}},kre="return ceil(x);",Ire=Xne({opSnippet:kre,packedOpSnippet:kre,cpuKernelImpl:mte}),Sre={kernelName:qG,backendName:"webgl",kernelFunc:Ire};class Nre{constructor(e){this.variableNames=["A"],this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=e,this.userCode="\n\n      void main() {\n        float value = getAAtOutCoords();\n        if (isnan(value)) {\n          setOutput(value);\n          return;\n        }\n\n        setOutput(clamp(value, minVal, maxVal));\n      }\n    "}}class Cre{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=e,this.userCode="\n      void main() {\n        vec4 value = getAAtOutCoords();\n\n        if (any(isnan(value))) {\n          setOutput(value);\n          return;\n        }\n\n        setOutput(clamp(value, vec4(minVal), vec4(maxVal)));\n      }\n    "}}const Tre={kernelName:XG,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{clipValueMin:o,clipValueMax:s}=a;let i;i=yG().getBool("WEBGL_PACK_CLIP")?new Cre(r.shape):new Nre(r.shape);const c=[[o],[s]];return n.runWebGLProgram(i,[r],r.dtype,c)}};class Ere{constructor(e){this.variableNames=["real","imag"],this.outputShape=e,this.userCode="\n      void main() {\n        float re = abs(getRealAtOutCoords());\n        float im = abs(getImagAtOutCoords());\n        float mx = max(re, im);\n\n        // sadly the length function in glsl is not underflow-safe\n        // (at least not on Intel GPUs). So the safe solution is\n        // to ensure underflow-safety in all cases.\n        setOutput(\n          mx == 0.0 ? 0.0 : mx * length(vec2(1, min(re, im)/mx))\n        );\n      }\n    "}}function Rre(e,t){return{dataId:t.dataId,dtype:t.dtype,shape:e.shape}}const _re={kernelName:QG,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{x:a}=t,r=n.texData.get(a.dataId),o=new Ere(a.shape),s=[Rre(a,r.complexTensorInfos.real),Rre(a,r.complexTensorInfos.imag)];return n.runWebGLProgram(o,s,s[0].dtype)}};class Are{constructor(e){this.outputShape=[],this.outputShape=t2(e,1),this.variableNames=e.map(((e,t)=>"T".concat(t)));const t=new Array(e.length-1);t[0]=e[0][1];for(let o=1;o<t.length;o++)t[o]=t[o-1]+e[o][1];const n=["if (yC < ".concat(t[0],") setOutput(getT0(yR, yC));")];for(let o=1;o<t.length;o++){const e=t[o-1];n.push("else if (yC < ".concat(t[o],") ")+"setOutput(getT".concat(o,"(yR, yC-").concat(e,"));"))}const a=t.length,r=t[t.length-1];n.push("else setOutput(getT".concat(a,"(yR, yC-").concat(r,"));")),this.userCode="\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int yR = coords.x;\n        int yC = coords.y;\n\n        ".concat(n.join("\n        "),"\n      }\n    ")}}class Fre{constructor(e,t){this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[],this.outputShape=t2(e,t);const n=this.outputShape,a=n.length,r=zee(a),o=sne("coords",a),s=["x","y","z","w","u","v"].slice(0,a);this.variableNames=e.map(((e,t)=>"T".concat(t)));const i=new Array(e.length-1);i[0]=e[0][t];for(let f=1;f<i.length;f++)i[f]=i[f-1]+e[f][t];const c=s[t],l=s.slice(-2),u=s.join();let d="if (".concat(c," < ").concat(i[0],") {\n        return getChannel(\n            getT0(").concat(u,"), vec2(").concat(l.join(),"));\n        }");for(let f=1;f<i.length;f++){const e=i[f-1];d+="\n        if (".concat(c," < ").concat(i[f],"  && ").concat(c," >= ").concat(i[f-1],") {\n          return getChannel(\n            getT").concat(f,"(").concat(Ore(s,c,e),"),\n            vec2(").concat(Ore(l,c,e),"));\n        }")}const h=i.length,p=i[i.length-1];d+="\n        return getChannel(\n          getT".concat(h,"(").concat(Ore(s,c,p),"),\n          vec2(").concat(Ore(l,c,p),"));"),this.userCode="\n      float getValue(".concat(s.map((e=>"int "+e)),") {\n        ").concat(d,"\n      }\n\n      void main() {\n        ").concat(r," coords = getOutputCoords();\n        vec4 result = vec4(getValue(").concat(o,"), 0., 0., 0.);\n\n        ").concat(o[a-1]," = ").concat(o[a-1]," + 1;\n        if (").concat(o[a-1]," < ").concat(n[a-1],") {\n          result.g = getValue(").concat(o,");\n        }\n\n        ").concat(o[a-2]," = ").concat(o[a-2]," + 1;\n        if (").concat(o[a-2]," < ").concat(n[a-2],") {\n          result.a = getValue(").concat(o,");\n        }\n\n        ").concat(o[a-1]," = ").concat(o[a-1]," - 1;\n        if (").concat(o[a-2]," < ").concat(n[a-2]," &&\n            ").concat(o[a-1]," < ").concat(n[a-1],") {\n          result.b = getValue(").concat(o,");\n        }\n        setOutput(result);\n      }\n    ")}}function Ore(e,t,n){const a=e.indexOf(t),r=e.map(((e,t)=>t===a?"".concat(e," - ").concat(n):e));return r.join()}function Dre(e){const{inputs:t,backend:n}=e,{input:a}=t;return Pne({inputs:{x:n.texData.get(a.dataId).complexTensorInfos.imag},backend:n})}const Mre={kernelName:WH,backendName:"webgl",kernelFunc:Dre};function Lre(e,t,n){const a=e[0].dtype;if("complex64"===a){const a=e.map((e=>yre({inputs:{input:e},backend:n}))),r=e.map((e=>Dre({inputs:{input:e},backend:n}))),o=Lre(a,t,n),s=Lre(r,t,n),i=Bne({inputs:{real:o,imag:s},backend:n});return a.forEach((e=>n.disposeIntermediateTensorInfo(e))),r.forEach((e=>n.disposeIntermediateTensorInfo(e))),n.disposeIntermediateTensorInfo(o),n.disposeIntermediateTensorInfo(s),i}let r=n.shouldExecuteOnCPU(e);if("string"===a&&(r=!0),r){const r=e.map((e=>{const a=UU(e.shape.slice(t));return aae({inputs:{x:e},backend:n,attrs:{shape:[-1,a]}})})),o=r.map((e=>({vals:n.readSync(e.dataId),shape:e.shape}))),s=t2(r.map((e=>e.shape)),1),i=1===r[0].shape[0],c=gte(o,s,a,i),l=t2(e.map((e=>e.shape)),t),u=n.makeTensorInfo(l,a,c);return r.forEach((e=>n.disposeIntermediateTensorInfo(e))),u}const o=e.filter((e=>UU(e.shape)>0)),s=yG().getBool("WEBGL_PACK_ARRAY_OPERATIONS")&&o[0].shape.length>1;if(1===o.length){const t=s?new pne(e[0].shape,vne):new Tne(e[0].shape,vne);return n.runWebGLProgram(t,e,a)}const i=yG().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER");if(o.length>i){const e=[];for(let r=0;r<o.length;r+=i){const a=o.slice(r,r+i);e.push(Lre(a,t,n))}const a=Lre(e,t,n);for(const t of e)n.disposeIntermediateTensorInfo(t);return a}if(s){const e=new Fre(o.map((e=>e.shape)),t);return n.runWebGLProgram(e,o,a)}const{tensors2D:c,outShape:l}=function(e,t,n){const a=t2(e.map((e=>e.shape)),t),r=e.map((e=>aae({inputs:{x:e},attrs:{shape:[-1,UU(e.shape.slice(t))]},backend:n})));return{tensors2D:r,outShape:a}}(o,t,n),u=new Are(c.map((e=>e.shape))),d=n.runWebGLProgram(u,c,a);c.forEach((e=>n.disposeIntermediateTensorInfo(e)));const h=aae({inputs:{x:d},attrs:{shape:l},backend:n});return n.disposeIntermediateTensorInfo(d),h}function Pre(e){const{inputs:t,backend:n,attrs:a}=e,{axis:r}=a,o=YU(r,t[0].shape)[0],s=t.map((e=>e.shape));e2(s,o);const i=t2(t.map((e=>e.shape)),o);if(0===UU(i))return n.makeTensorInfo(i,t[0].dtype,[]);const c=t.filter((e=>UU(e.shape)>0));return 1===c.length?Pne({inputs:{x:c[0]},backend:n}):Lre(c,o,n)}const zre={kernelName:JG,backendName:"webgl",kernelFunc:Pre};class Bre{constructor(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1],n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null,a=arguments.length>3&&void 0!==arguments[3]&&arguments[3],r=arguments.length>4&&void 0!==arguments[4]&&arguments[4];this.variableNames=["x","W"],this.outputShape=e.outShape;const o=e.padInfo.top,s=e.padInfo.left,i=e.strideHeight,c=e.strideWidth,l=e.dilationHeight,u=e.dilationWidth,d=e.filterHeight,h=e.filterWidth,p=4*Math.floor(e.inChannels/4),f=e.inChannels%4,m="channelsLast"===e.dataFormat,g=m?1:2,b=m?2:3,y=m?3:1;let x="",v="";n&&(x=a?"float activation(float a) {\n          float b = getPreluActivationWeightsAtOutCoords();\n          ".concat(n,"\n        }"):r?"float activation(float a) {\n          float b = getLeakyreluAlphaAtOutCoords();\n          ".concat(n,"\n        }"):"\n          float activation(float x) {\n            ".concat(n,"\n          }\n        "),v="result = activation(result);");const w=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),a&&this.variableNames.push("preluActivationWeights"),r&&this.variableNames.push("leakyreluAlpha"),this.userCode="\n      ".concat(x,"\n\n      const ivec2 strides = ivec2(").concat(i,", ").concat(c,");\n      const ivec2 pads = ivec2(").concat(o,", ").concat(s,");\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d2 = coords[").concat(y,"];\n\n        ivec2 xRCCorner =\n            ivec2(coords[").concat(g,"], coords[").concat(b,"]) * strides - pads;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // Convolve x(?, ?, d1) with w(:, :, d1, d2) to get y(yR, yC, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ").concat(d,"; wR++) {\n          int xR = xRCorner + wR * ").concat(l,";\n\n          if (xR < 0 || xR >= ").concat(e.inHeight,") {\n            continue;\n          }\n\n          for (int wC = 0; wC < ").concat(h,"; wC++) {\n            int xC = xCCorner + wC * ").concat(u,";\n\n            if (xC < 0 || xC >= ").concat(e.inWidth,") {\n              continue;\n            }\n\n            for (int d1 = 0; d1 < ").concat(p,"; d1 += 4) {\n              vec4 wValues = vec4(\n                getW(wR, wC, d1, d2),\n                getW(wR, wC, d1 + 1, d2),\n                getW(wR, wC, d1 + 2, d2),\n                getW(wR, wC, d1 + 3, d2)\n              );\n\n              if (").concat(m,") {\n                vec4 xValues = vec4(\n                  getX(batch, xR, xC, d1),\n                  getX(batch, xR, xC, d1 + 1),\n                  getX(batch, xR, xC, d1 + 2),\n                  getX(batch, xR, xC, d1 + 3)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec4 xValues = vec4(\n                  getX(batch, d1, xR, xC),\n                  getX(batch, d1 + 1, xR, xC),\n                  getX(batch, d1 + 2, xR, xC),\n                  getX(batch, d1 + 3, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n            }\n\n            if (").concat(1===f,") {\n\n              if (").concat(m,") {\n                dotProd +=\n                    getX(batch, xR, xC, ").concat(p,") *\n                    getW(wR, wC, ").concat(p,", d2);\n              } else {\n                dotProd +=\n                    getX(batch, ").concat(p,", xR, xC) *\n                    getW(wR, wC, ").concat(p,", d2);\n              }\n\n            } else if (").concat(2===f,") {\n              vec2 wValues = vec2(\n                getW(wR, wC, ").concat(p,", d2),\n                getW(wR, wC, ").concat(p," + 1, d2)\n              );\n\n              if (").concat(m,") {\n                vec2 xValues = vec2(\n                  getX(batch, xR, xC, ").concat(p,"),\n                  getX(batch, xR, xC, ").concat(p," + 1)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec2 xValues = vec2(\n                  getX(batch, ").concat(p,", xR, xC),\n                  getX(batch, ").concat(p," + 1, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n\n            } else if (").concat(3===f,") {\n              vec3 wValues = vec3(\n                getW(wR, wC, ").concat(p,", d2),\n                getW(wR, wC, ").concat(p," + 1, d2),\n                getW(wR, wC, ").concat(p," + 2, d2)\n              );\n\n              if (").concat(m,") {\n                vec3 xValues = vec3(\n                  getX(batch, xR, xC, ").concat(p,"),\n                  getX(batch, xR, xC, ").concat(p," + 1),\n                  getX(batch, xR, xC, ").concat(p," + 2)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec3 xValues = vec3(\n                  getX(batch, ").concat(p,", xR, xC),\n                  getX(batch, ").concat(p," + 1, xR, xC),\n                  getX(batch, ").concat(p," + 2, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n\n            }\n          }\n        }\n\n        float result = dotProd;\n        ").concat(w,"\n        ").concat(v,"\n        setOutput(result);\n      }\n    ")}}class Wre{constructor(e){this.variableNames=["x","W"],this.outputShape=e.outShape;const t=e.padInfo.front,n=e.padInfo.top,a=e.padInfo.left,r=e.strideDepth,o=e.strideHeight,s=e.strideWidth,i=e.dilationDepth,c=e.dilationHeight,l=e.dilationWidth,u=e.filterDepth,d=e.filterHeight,h=e.filterWidth,p=4*Math.floor(e.inChannels/4),f=e.inChannels%4;this.userCode="\n      const ivec3 strides = ivec3(".concat(r,", ").concat(o,", ").concat(s,");\n      const ivec3 pads = ivec3(").concat(t,", ").concat(n,", ").concat(a,");\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int d2 = coords.u;\n\n        ivec3 xFRCCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n        int xFCorner = xFRCCorner.x;\n        int xRCorner = xFRCCorner.y;\n        int xCCorner = xFRCCorner.z;\n\n        // Convolve x(?, ?, ?, d1) with w(:, :, :, d1, d2) to get\n        // y(yF, yR, yC, d2). ? = to be determined. : = across all\n        // values in that axis.\n        float dotProd = 0.0;\n        for (int wF = 0; wF < ").concat(u,"; wF++) {\n          int xF = xFCorner + wF * ").concat(i,";\n\n          if (xF < 0 || xF >= ").concat(e.inDepth,") {\n            continue;\n          }\n\n          for (int wR = 0; wR < ").concat(d,"; wR++) {\n            int xR = xRCorner + wR * ").concat(c,";\n\n            if (xR < 0 || xR >= ").concat(e.inHeight,") {\n              continue;\n            }\n\n            for (int wC = 0; wC < ").concat(h,"; wC++) {\n              int xC = xCCorner + wC * ").concat(l,";\n\n              if (xC < 0 || xC >= ").concat(e.inWidth,") {\n                continue;\n              }\n\n              for (int d1 = 0; d1 < ").concat(p,"; d1 += 4) {\n                vec4 xValues = vec4(\n                  getX(batch, xF, xR, xC, d1),\n                  getX(batch, xF, xR, xC, d1 + 1),\n                  getX(batch, xF, xR, xC, d1 + 2),\n                  getX(batch, xF, xR, xC, d1 + 3)\n                );\n                vec4 wValues = vec4(\n                  getW(wF, wR, wC, d1, d2),\n                  getW(wF, wR, wC, d1 + 1, d2),\n                  getW(wF, wR, wC, d1 + 2, d2),\n                  getW(wF, wR, wC, d1 + 3, d2)\n                );\n\n                dotProd += dot(xValues, wValues);\n              }\n\n              if (").concat(1===f,") {\n                dotProd +=\n                  getX(batch, xF, xR, xC, ").concat(p,") *\n                  getW(wF, wR, wC, ").concat(p,", d2);\n              } else if (").concat(2===f,") {\n                vec2 xValues = vec2(\n                  getX(batch, xF, xR, xC, ").concat(p,"),\n                  getX(batch, xF, xR, xC, ").concat(p," + 1)\n                );\n                vec2 wValues = vec2(\n                  getW(wF, wR, wC, ").concat(p,", d2),\n                  getW(wF, wR, wC, ").concat(p," + 1, d2)\n                );\n                dotProd += dot(xValues, wValues);\n              } else if (").concat(3===f,") {\n                vec3 xValues = vec3(\n                  getX(batch, xF, xR, xC, ").concat(p,"),\n                  getX(batch, xF, xR, xC, ").concat(p," + 1),\n                  getX(batch, xF, xR, xC, ").concat(p," + 2)\n                );\n                vec3 wValues = vec3(\n                  getW(wF, wR, wC, ").concat(p,", d2),\n                  getW(wF, wR, wC, ").concat(p," + 1, d2),\n                  getW(wF, wR, wC, ").concat(p," + 2, d2)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    ")}}class Vre{constructor(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1],n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null,a=arguments.length>3&&void 0!==arguments[3]&&arguments[3],r=arguments.length>4&&void 0!==arguments[4]&&arguments[4];this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=jee(this.outputShape.length);const o=e.padInfo.left,s=e.strideWidth,i=e.dilationWidth,c=e.filterHeight,l=e.filterWidth,u=l;let d="\n       int xR; int xC; int xCOffset;\n       vec4 wTexel; vec4 previous; vec4 final;";for(let m=0;m<l;m++)d+="\n           vec4 xTexelC".concat(2*m,";\n           int xTexelC").concat(2*m,"Ready;\n           vec4 xTexelC").concat(2*m+1,";\n           int xTexelC").concat(2*m+1,"Ready;\n           vec4 xC").concat(m,";");d+="\n     for (int r = 0; r < ".concat(c,"; r++) {\n      for (int d1 = 0; d1 < ").concat(e.inChannels,"; d1 += 2) {\n       ");for(let m=0;m<l;m++)d+="\n           xTexelC".concat(2*m," = vec4(0.0);\n           xTexelC").concat(2*m,"Ready = 0;\n           xTexelC").concat(2*m+1," = vec4(0.0);\n           xTexelC").concat(2*m+1,"Ready = 0;\n           xC").concat(m," = vec4(0.0);");d+="\n         xR = xRCorner + r * dilations[0];\n         if (xR >=0 && xR < inDims[0]) {\n       ";for(let m=0;m<(u+1)/2;m++){const t=2*m;if(d+="\n           xC = xCCorner + ".concat(t*i,";\n           "),1===s){if(t<l&&(o%2===1?(d+="\n                 xCOffset = xC + 1;\n                 if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC".concat(t,"Ready == 0) {\n                   xTexelC").concat(t," = getX(batch, xR, xCOffset, d1);\n\n                   // Need to manually clear unused channels in case\n                   // we're reading from recycled texture.\n                   if (xCOffset + 1 >= inDims[1]) {\n                     xTexelC").concat(t,".zw = vec2(0.0);\n                   }\n                   xTexelC").concat(t,"Ready = 1;\n                 }\n               "),d+=1===i&&t>0?"\n                 xC".concat(t," = vec4(xTexelC").concat(t-2,".zw, xTexelC").concat(t,".xy);\n                 "):"\n                   xCOffset = xC + 1 - 2;\n\n                   if (xCOffset >= 0 && xCOffset < inDims[1]) {\n                     previous = getX(batch, xR, xCOffset, d1);\n\n                     // Need to manually clear unused channels in case\n                     // we're reading from recycled texture.\n                     if (xCOffset + 1 >= inDims[1]) {\n                       previous.zw = vec2(0.0);\n                     }\n\n                     xC".concat(t," = vec4(previous.zw, xTexelC").concat(t,".xy);\n                   } else {\n                     xC").concat(t," = vec4(0.0, 0.0, xTexelC").concat(t,".xy);\n                   }\n                   ")):d+="\n                 if (xC >= 0 && xC < inDims[1] && xTexelC".concat(t,"Ready == 0) {\n                   xTexelC").concat(t," = getX(batch, xR, xC, d1);\n                   if (xC + 1 >= inDims[1]) {\n                     xTexelC").concat(t,".zw = vec2(0.0);\n                   }\n                   xTexelC").concat(t,"Ready = 1;\n                 }\n\n                 xC").concat(t," = xTexelC").concat(t,";\n                 "),t+1<l)){const e=o%2===0?PU(i):i;i%2===0&&o%2===1||i%2!==0&&o%2!==1?(d+="\n                   xCOffset = xC + imod(pads[1], 2) + ".concat(e,";\n\n                   if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC").concat(t+1,"Ready == 0) {\n                     xTexelC").concat(t+1," = getX(batch, xR, xCOffset, d1);\n\n                     // Need to manually clear unused channels in case\n                     // we're reading from recycled texture.\n                     if (xCOffset + 1 >= inDims[1]) {\n                       xTexelC").concat(t+1,".zw = vec2(0.0);\n                     }\n                     xTexelC").concat(t+1,"Ready = 1;\n                   }\n                   "),d+=i>1?"\n                     xCOffset -= 2;\n                     if (xCOffset >= 0 && xCOffset < inDims[1]) {\n                      previous = getX(batch, xR, xCOffset, d1);\n                      xC".concat(t+1," = vec4(previous.zw, xTexelC").concat(t+1,".xy);\n                     } else {\n                      xC").concat(t+1," = vec4(0.0, 0.0, xTexelC").concat(t+1,".xy);\n                     }\n                     "):"\n                     xC".concat(t+1," = vec4(xTexelC").concat(t,".zw, xTexelC").concat(t+1,".xy);\n                     ")):d+=1===e?"\n                     xC".concat(t+1," = xTexelC").concat(t,";\n                     "):"\n                     xCOffset = xC + ".concat(e,";\n\n                     if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC").concat(t+1,"Ready == 0) {\n                       xTexelC").concat(t+1," = getX(batch, xR, xCOffset, d1);\n                       if (xCOffset + 1 >= inDims[1]) {\n                         xTexelC").concat(t+1,".zw = vec2(0.0);\n                       }\n                       xTexelC").concat(t+1,"Ready = 1;\n                     }\n\n                     xC").concat(t+1," = xTexelC").concat(t+1,";\n                     ")}}else t<l&&(o%2===1?(d+="\n                 xCOffset = xC + 1 - strides[1];\n                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC".concat(t,"Ready == 0) {\n                   xTexelC").concat(t," = getX(batch, xR, xCOffset, d1);\n                   // Need to manually clear unused channels in case\n                   // we're reading from recycled texture.\n                   if (xCOffset + 1 >= inDims[1]) {\n                     xTexelC").concat(t,".zw = vec2(0.0);\n                   }\n                   xTexelC").concat(t,"Ready = 1;\n                 }\n\n                 if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC").concat(t+1,"Ready == 0) {\n                   xTexelC").concat(t+1," = getX(batch, xR, xC + 1, d1);\n                   // Need to manually clear unused channels in case\n                   // we're reading from recycled texture.\n                   if (xC + 2 >= inDims[1]) {\n                     xTexelC").concat(t+1,".zw = vec2(0.0);\n                   }\n                   xTexelC").concat(t+1,"Ready = 1;\n                 }\n\n                 xC").concat(t," = vec4(xTexelC").concat(t,".zw, xTexelC").concat(t+1,".zw);\n               "),t+1<l&&(d+="\n                   final = vec4(0.0);\n                   xCOffset = xC + 1 + strides[1];\n                   if(xCOffset >= 0 && xCOffset < inDims[1]) {\n                     final = getX(batch, xR, xCOffset, d1);\n                   }\n                   xC".concat(t+1," = vec4(xTexelC").concat(t+1,".xy, final.xy);\n                 "))):(d+="\n                 if(xC >= 0 && xC < inDims[1] && xTexelC".concat(t,"Ready == 0) {\n                   xTexelC").concat(t," = getX(batch, xR, xC, d1);\n                   if (xC + 1 >= inDims[1]) {\n                     xTexelC").concat(t,".zw = vec2(0.0);\n                   }\n                   xTexelC").concat(t,"Ready = 1;\n                 }\n\n                 xCOffset = xC + strides[1];\n                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC").concat(t+1,"Ready == 0) {\n                   xTexelC").concat(t+1," = getX(batch, xR, xCOffset, d1);\n                   if (xCOffset + 1 >= inDims[1]) {\n                     xTexelC").concat(t+1,".zw = vec2(0.);\n                   }\n                   xTexelC").concat(t+1,"Ready = 1;\n                 }\n\n                 xC").concat(t," = vec4(\n                   xTexelC").concat(t,".xy, xTexelC").concat(t+1,".xy);\n               "),t+1<l&&(d+="\n                   xC".concat(t+1," = vec4(xTexelC").concat(t,".zw, xTexelC").concat(t+1,".zw);\n                 "))));t<l&&(d+="\n             wTexel = getW(r, ".concat(t,", d1, d2);\n             dotProd += xC").concat(t,".xxzz * vec4(wTexel.xy, wTexel.xy);\n             if(d1 + 1 < ").concat(e.inChannels,") {\n               dotProd += xC").concat(t,".yyww * vec4(wTexel.zw, wTexel.zw);\n             }\n           "),t+1<l&&(d+="\n               wTexel = getW(r, ".concat(t+1,", d1, d2);\n               dotProd += xC").concat(t+1,".xxzz * vec4(wTexel.xy, wTexel.xy);\n               if(d1 + 1 < ").concat(e.inChannels,") {\n                 dotProd += xC").concat(t+1,".yyww * vec4(wTexel.zw, wTexel.zw);\n               }\n             ")))}d+="\n     }\n   ",d+="\n     }\n   ",d+="\n     }\n   ";let h="",p="";n&&(h=a?"vec4 activation(vec4 a) {\n           vec4 b = getPreluActivationWeightsAtOutCoords();\n           ".concat(n,"\n         }"):r?"vec4 activation(vec4 a) {\n           vec4 b = getLeakyreluAlphaAtOutCoords();\n           ".concat(n,"\n         }"):"vec4 activation(vec4 x) {\n           ".concat(n,"\n         }"),p="result = activation(result);");const f=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),a&&this.variableNames.push("preluActivationWeights"),r&&this.variableNames.push("leakyreluAlpha"),this.userCode="\n       ".concat(h,"\n\n       void main() {\n         ivec4 coords = getOutputCoords();\n         int batch = coords.x;\n         ivec2 xRCCorner = coords.yz * strides - pads;\n         int d2 = coords.w;\n         int xRCorner = xRCCorner.x;\n         int xCCorner = xRCCorner.y;\n\n         //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.\n         vec4 dotProd = vec4(0.000000000000001);\n\n         ").concat(d,"\n\n         vec4 result = dotProd - vec4(0.000000000000001);\n         ").concat(f,"\n         ").concat(p,"\n         setOutput(result);\n       }\n     ")}}class Ure{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec4"},{name:"pad",type:"ivec2"},{name:"stride",type:"ivec2"},{name:"dilation",type:"ivec2"},{name:"inChannels",type:"int"},{name:"itemsPerBlockRow",type:"int"},{name:"outWidth",type:"int"}],this.outputShape=e,this.enableShapeUniforms=jee(this.outputShape.length);const{dataFormat:n}=t,a=kee(),r="channelsLast"===n,o=r?1:2,s=r?2:3,i=this.enableShapeUniforms?"if(blockIndex < outShape[2] && pos < outShape[1]) {":"if(blockIndex < ".concat(e[2]," && pos < ").concat(e[1],") {");let c="";for(let l=0;l<=1;l++)for(let e=0;e<=1;e++)c+="\n          blockIndex = rc.z + ".concat(e,";\n          pos = rc.y + ").concat(l,";\n\n          ").concat(i,"\n            offsetY = int(blockIndex / outWidth) * stride[0] - pad[0];\n            d0 = offsetY + dilation[0] * (pos / itemsPerBlockRow);\n\n            if(d0 < inputShape[").concat(o,"] && d0 >= 0) {\n              // Use custom imod instead mod. On Intel GPU, mod may generate\n              // unexpected value.\n              // https://github.com/tensorflow/tfjs/issues/5447\n              offsetX = imod(blockIndex, outWidth) * stride[1] - pad[1];\n              d1 = offsetX + dilation[1] * (imod(pos, itemsPerBlockRow) /\n                  inChannels);\n\n              if(d1 < inputShape[").concat(s,"] && d1 >= 0) {\n\n                ch = imod(pos, inChannels);\n\n                if (").concat(r,") {\n                  innerDims = vec2(d1, ch);\n                  result[").concat(2*l+e,"] = getChannel(\n                    getA(rc.x, d0, int(innerDims.x),\n                    int(innerDims.y)), innerDims);\n                } else {\n                  innerDims = vec2(d0, d1);\n                  result[").concat(2*l+e,"] = getChannel(\n                    getA(rc.x, ch, int(innerDims.x),\n                    int(innerDims.y)), innerDims);\n                }\n              }\n            }\n          }\n        ");this.userCode="\n      void main() {\n        ivec3 rc = getOutputCoords();\n\n        vec4 result = vec4(0);\n\n        int blockIndex, pos, offsetY, d0, offsetX, d1, ch;\n        vec2 innerDims;\n\n        ".concat(c,"\n\n        ").concat(a.output," = result;\n      }\n    ")}}function Gre(e,t){const n=e.length;return n>=3?t?[...e.slice(0,-3),e[n-3]*e[n-2],e[n-1]]:[...e.slice(0,-3),e[n-3],e[n-2]*e[n-1]]:!t&&1===n&&e[0]>1?[e[0],1]:null}function Hre(e){let{x:t,filter:n,convInfo:a,backend:r,bias:o=null,preluActivationWeights:s=null,leakyreluAlpha:i=0,activation:c=null}=e;const l=t.shape,u=r.texData.get(t.dataId),d=a.inChannels,h=l[0]*l[1]*l[2],p=a.outChannels,f="channelsLast"===a.dataFormat,m=!1;let g;const b=[];if(null!=s){const e=Gre(s.shape,f);null!=e&&(s=aae({inputs:{x:s},backend:r,attrs:{shape:e}}),b.push(s))}if(null!=o){const e=Gre(o.shape,f);null!=e&&(o=aae({inputs:{x:o},backend:r,attrs:{shape:e}}),b.push(o))}if(!((1===h||1===p)&&d>mae)&&u.isPacked&&f&&null!=u.texture&&l[2]%2!==0&&GU(u.shape.slice(-3),l.slice(-3))){const e=l[0]*l[1]*(l[2]+1),d={dataId:t.dataId,shape:[1,e,a.inChannels],dtype:t.dtype},h=u.shape;u.shape=u.shape.slice(),u.shape[u.shape.length-2]++,BU(pee(u.shape,d.shape),(()=>"packed reshape ".concat(u.shape," to ").concat(d.shape," isn't free")));const p=aae({inputs:{x:n},backend:r,attrs:{shape:[1,a.inChannels,a.outChannels]}});b.push(p);const f=gae({a:d,b:p,backend:r,transposeA:false,transposeB:m,bias:o,activation:c,preluActivationWeights:s,leakyreluAlpha:i}),y=r.texData.get(f.dataId);BU(y.isPacked,(()=>"batchMatMul result is expected to be packed")),u.shape=h,y.shape=a.outShape,g=Pne({inputs:{x:f},backend:r}),g.shape=a.outShape,b.push(f)}else{const e=a.outHeight*a.outWidth,l=aae({inputs:{x:t},backend:r,attrs:{shape:f?[a.batchSize,e,a.inChannels]:[a.batchSize,a.inChannels,e]}}),u=aae({inputs:{x:n},backend:r,attrs:{shape:[1,a.inChannels,a.outChannels]}}),d=gae({a:f?l:u,b:f?u:l,transposeA:!f,transposeB:m,backend:r,bias:o,activation:c,preluActivationWeights:s,leakyreluAlpha:i});g=aae({inputs:{x:d},backend:r,attrs:{shape:a.outShape}}),b.push(l),b.push(u),b.push(d)}for(const y of b)r.disposeIntermediateTensorInfo(y);return g}function jre(e){let{x:t,filter:n,convInfo:a,backend:r,bias:o=null,preluActivationWeights:s=null,leakyreluAlpha:i=0,activation:c=null}=e;const{filterWidth:l,filterHeight:u,inChannels:d,outWidth:h,outHeight:p,dataFormat:f}=a,m="channelsLast"===f,g=l*u*d,b=p*h,y=[a.batchSize,g,b],x=[];if(null!=s){const e=Gre(s.shape,m);null!=e&&(s=aae({inputs:{x:s},backend:r,attrs:{shape:e}}),x.push(s))}if(null!=o){const e=Gre(o.shape,m);null!=e&&(o=aae({inputs:{x:o},backend:r,attrs:{shape:e}}),x.push(o))}const v=aae({inputs:{x:n},backend:r,attrs:{shape:[1,g,UU(n.shape)/g]}});x.push(v);const w=new Ure(y,a),k=[t.shape,[a.padInfo.top,a.padInfo.left],[a.strideHeight,a.strideWidth],[a.dilationHeight,a.dilationWidth],[a.inChannels],[a.filterWidth*a.inChannels],[a.outWidth]],I=r.runWebGLProgram(w,[t],"float32",k),S=aae({inputs:{x:I},backend:r,attrs:{shape:y}});x.push(I),x.push(S);const N=null!=o,C=null!=s,T="leakyrelu"===c,E=c?Qne(c,!0):null,R=new Jne(m?S.shape:v.shape,m?v.shape:S.shape,m?[a.batchSize,b,a.outChannels]:[a.batchSize,a.outChannels,b],!0,!1,N,E,C,T),_=m?[S,v]:[v,S];if(o&&_.push(o),C&&_.push(s),T){const e=r.makeTensorInfo([],"float32",aq(i,"float32"));_.push(e),x.push(e)}const A=r.runWebGLProgram(R,_,"float32"),F=aae({inputs:{x:A},backend:r,attrs:{shape:a.outShape}});x.push(A);for(const O of x)r.disposeIntermediateTensorInfo(O);return F}const Kre={kernelName:ZG,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r,filter:o}=t,{strides:s,pad:i,dataFormat:c,dilations:l,dimRoundingMode:u}=a,d=oJ(c),h=YQ(r.shape,o.shape,s,l,i,u,!1,d);let p;if(1!==h.filterHeight||1!==h.filterWidth||1!==h.dilationHeight||1!==h.dilationWidth||1!==h.strideHeight||1!==h.strideWidth||"SAME"!==h.padInfo.type&&"VALID"!==h.padInfo.type)if(h.strideWidth<=2&&"channelsLast"===d&&yG().getBool("WEBGL_EXP_CONV")){const e=new Vre(h),t=[[h.padInfo.top,h.padInfo.left],[h.strideHeight,h.strideWidth],[h.dilationHeight,h.dilationWidth],[h.inHeight,h.inWidth]];p=n.runWebGLProgram(e,[r,o],"float32",t)}else if(yG().getBool("WEBGL_CONV_IM2COL"))p=jre({x:r,filter:o,convInfo:h,backend:n});else{const e=new Bre(h);p=n.runWebGLProgram(e,[r,o],"float32")}else p=Hre({x:r,filter:o,convInfo:h,backend:n});const f=aae({inputs:{x:p},backend:n,attrs:{shape:h.outShape}});return n.disposeIntermediateTensorInfo(p),f}};class qre{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;const t=e.strideHeight,n=e.strideWidth,a=e.padInfo.top,r=e.padInfo.left,o="channelsLast"===e.dataFormat;this.userCode="\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int wR = coords.x;\n        int wC = coords.y;\n        int d1 = coords.z;\n        int d2 = coords.w;\n\n        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int b = 0; b < ".concat(e.batchSize,"; b++) {\n          for (int yR = 0; yR < ").concat(e.outHeight,"; yR++) {\n            int xR = wR + yR * ").concat(t," - ").concat(a,";\n\n            if (xR < 0 || xR >= ").concat(e.inHeight,") {\n              continue;\n            }\n\n            for (int yC = 0; yC < ").concat(e.outWidth,"; yC++) {\n              int xC = wC + yC * ").concat(n," - ").concat(r,";\n\n              if (xC < 0 || xC >= ").concat(e.inWidth,") {\n                continue;\n              }\n\n              ").concat(o?"float dyValue = getDy(b, yR, yC, d2);\n              float xValue = getX(b, xR, xC, d1);\n              dotProd += (xValue * dyValue);":"float dyValue = getDy(b, d2, yR, yC);\n              float xValue = getX(b, d1, xR, xC);\n              dotProd += (xValue * dyValue);","\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    ")}}class Xre{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;const t=e.filterHeight,n=e.filterWidth,a=e.strideHeight,r=e.strideWidth,o="channelsLast"===e.dataFormat,s=t-1-e.padInfo.top,i=n-1-e.padInfo.left,c=o?1:2,l=o?2:3,u=o?3:1;this.userCode="\n      const ivec2 pads = ivec2(".concat(s,", ").concat(i,");\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[").concat(u,"];\n\n        ivec2 dyCorner = ivec2(coords[").concat(c,"], coords[").concat(l,"]) - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ").concat(t,"; wR++) {\n          float dyR = float(dyRCorner + wR) / ").concat(a,".0;\n\n          if (dyR < 0.0 || dyR >= ").concat(e.outHeight,".0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          int wRPerm = ").concat(t," - 1 - wR;\n\n          for (int wC = 0; wC < ").concat(n,"; wC++) {\n            float dyC = float(dyCCorner + wC) / ").concat(r,".0;\n\n            if (dyC < 0.0 || dyC >= ").concat(e.outWidth,".0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            int wCPerm = ").concat(n," - 1 - wC;\n\n            for (int d2 = 0; d2 < ").concat(e.outChannels,"; d2++) {\n\n              if (").concat(o,") {\n                float xValue = getDy(batch, idyR, idyC, d2);\n                float wValue = getW(wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              } else {\n                float xValue = getDy(batch, d2, idyR, idyC);\n                float wValue = getW(wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              }\n\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    ")}}class Yre{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;const t=e.strideDepth,n=e.strideHeight,a=e.strideWidth,r=e.padInfo.front,o=e.padInfo.top,s=e.padInfo.left;this.userCode="\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int wF = coords.x;\n        int wR = coords.y;\n        int wC = coords.z;\n        int d1 = coords.w;\n        int d2 = coords.u;\n\n        float dotProd = 0.0;\n\n        for (int b = 0; b < ".concat(e.batchSize,"; b++) {\n          for (int yF = 0; yF < ").concat(e.outDepth,"; yF++) {\n            int xF = wF + yF * ").concat(t," - ").concat(r,";\n\n            if (xF < 0 || xF >= ").concat(e.inDepth,") {\n              continue;\n            }\n\n            for (int yR = 0; yR < ").concat(e.outHeight,"; yR++) {\n              int xR = wR + yR * ").concat(n," - ").concat(o,";\n\n              if (xR < 0 || xR >= ").concat(e.inHeight,") {\n                continue;\n              }\n\n              for (int yC = 0; yC < ").concat(e.outWidth,"; yC++) {\n                int xC = wC + yC * ").concat(a," - ").concat(s,";\n\n                if (xC < 0 || xC >= ").concat(e.inWidth,") {\n                  continue;\n                }\n\n                float dyValue = getDy(b, yF, yR, yC, d2);\n                float xValue = getX(b, xF, xR, xC, d1);\n                dotProd += (xValue * dyValue);\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    ")}}class Qre{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;const t=e.filterDepth,n=e.filterHeight,a=e.filterWidth,r=e.strideDepth,o=e.strideHeight,s=e.strideWidth,i=t-1-e.padInfo.front,c=n-1-e.padInfo.top,l=a-1-e.padInfo.left;this.userCode="\n      const ivec3 pads = ivec3(".concat(i,", ").concat(c,", ").concat(l,");\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int d1 = coords.u;\n\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyFCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        float dotProd = 0.0;\n        for (int wF = 0; wF < ").concat(t,"; wF++) {\n          float dyF = float(dyFCorner + wF) / ").concat(r,".0;\n\n          if (dyF < 0.0 || dyF >= ").concat(e.outDepth,".0 || fract(dyF) > 0.0) {\n            continue;\n          }\n          int idyF = int(dyF);\n\n          int wFPerm = ").concat(t," - 1 - wF;\n\n          for (int wR = 0; wR < ").concat(n,"; wR++) {\n            float dyR = float(dyRCorner + wR) / ").concat(o,".0;\n\n            if (dyR < 0.0 || dyR >= ").concat(e.outHeight,".0 ||\n              fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            int wRPerm = ").concat(n," - 1 - wR;\n\n            for (int wC = 0; wC < ").concat(a,"; wC++) {\n              float dyC = float(dyCCorner + wC) / ").concat(s,".0;\n\n              if (dyC < 0.0 || dyC >= ").concat(e.outWidth,".0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              int wCPerm = ").concat(a," - 1 - wC;\n\n              for (int d2 = 0; d2 < ").concat(e.outChannels,"; d2++) {\n                float xValue = getDy(batch, idyF, idyR, idyC, d2);\n                float wValue = getW(wFPerm, wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    ")}}const Jre={kernelName:$G,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r,dy:o}=t,{strides:s,pad:i,dataFormat:c,dimRoundingMode:l,filterShape:u}=a,d=oJ(c),h=YQ(r.shape,u,s,1,i,l,!1,d),p=new qre(h);return n.runWebGLProgram(p,[r,o],"float32")}};class Zre{constructor(e){this.variableNames=["dy","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"strides",type:"vec2"}],this.outputShape=e.inShape,this.enableShapeUniforms=jee(this.outputShape.length);const t=e.filterHeight,n=e.filterWidth,a=t-1-e.padInfo.top,r=n-1-e.padInfo.left;this.userCode="\n      const ivec2 pads = ivec2(".concat(a,", ").concat(r,");\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[3];\n\n        ivec2 dyCorner = ivec2(coords[1], coords[2]) - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        vec4 result = vec4(0.);\n        for (int wR = 0; wR < ").concat(t,"; wR++) {\n          float dyR = float(dyRCorner + wR) / strides[0];\n          if (dyR < 0.0 || dyR >= ").concat(e.outHeight,".0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n          int wRPerm = ").concat(t," - 1 - wR;\n\n          for (int wC = 0; wC < ").concat(n,"; wC++) {\n            int wCPerm = ").concat(n," - 1 - wC;\n\n            float dyC = float(dyCCorner + wC) / strides[1];\n            bool idyCVal = (dyC >= 0.0) && (dyC < ").concat(e.outWidth,".0)\n              && (fract(dyC) == 0.0);\n            int idyC = int(dyC);\n\n            float dyC2 = float(dyCCorner + wC + 1) / strides[1];\n            bool idyCVal2 = (dyC2 >= 0.0) && (dyC2 < ").concat(e.outWidth,".0)\n              && (fract(dyC2) == 0.0);\n            int idyC2 = int(dyC2);\n\n            if (idyCVal && idyCVal2) {\n              for (int d2 = 0; d2 < ").concat(e.outChannels,"; d2 += 2) {\n                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);\n                vec4 dySample = getDy(batch, idyR, idyC, d2);\n                vec4 dySample2 = (idyC / 2 == idyC2 / 2) ?\n                  dySample : getDy(batch, idyR, idyC2, d2);\n\n                vec2 dyValue = mod(float(idyC), 2.) == 0. ?\n                  dySample.xy : dySample.zw;\n                result.xy += vec2(dot(dyValue, wValue.xy),\n                  dot(dyValue, wValue.zw));\n\n                dyValue = mod(float(idyC2), 2.) == 0. ?\n                  dySample2.xy : dySample2.zw;\n                result.zw += vec2(dot(dyValue, wValue.xy),\n                  dot(dyValue, wValue.zw));\n              }\n            } else if (idyCVal) {\n              for (int d2 = 0; d2 < ").concat(e.outChannels,"; d2 += 2) {\n                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);\n                vec4 dySample = getDy(batch, idyR, idyC, d2);\n                vec2 dyValue = mod(float(idyC), 2.) == 0. ?\n                  dySample.xy : dySample.zw;\n                result.xy += vec2(dot(dyValue, wValue.xy),\n                  dot(dyValue, wValue.zw));\n              }\n            } else if (idyCVal2) {\n              for (int d2 = 0; d2 < ").concat(e.outChannels,"; d2 += 2) {\n                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);\n                vec4 dySample = getDy(batch, idyR, idyC2, d2);\n                vec2 dyValue = mod(float(idyC2), 2.) == 0. ?\n                  dySample.xy : dySample.zw;\n                result.zw += vec2(dot(dyValue, wValue.xy),\n                  dot(dyValue, wValue.zw));\n              }\n            }\n          }\n        }\n        setOutput(result);\n      }\n    ")}}const $re={kernelName:eH,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{dy:r,filter:o}=t,{inputShape:s,strides:i,pad:c,dataFormat:l,dimRoundingMode:u}=a,d=oJ(l),h=YQ(s,o.shape,i,1,c,u,!1,d);if(yG().getBool("WEBGL_PACK_CONV2DTRANSPOSE")&&"channelsLast"===d){const e=[[h.strideHeight,h.strideWidth]],t=new Zre(h);return n.runWebGLProgram(t,[r,o],"float32",e)}{const e=new Xre(h);return n.runWebGLProgram(e,[r,o],"float32")}}};const eoe={kernelName:tH,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r,filter:o}=t,{strides:s,pad:i,dilations:c}=a,l=QQ(r.shape,o.shape,s,c,i),u=new Wre(l);return n.runWebGLProgram(u,[r,o],"float32")}};const toe={kernelName:nH,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r,dy:o}=t,{strides:s,pad:i,filterShape:c}=a,l=QQ(r.shape,c,s,1,i),u=new Yre(l);return n.runWebGLProgram(u,[r,o],"float32")}};const noe={kernelName:aH,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{dy:r,filter:o}=t,{pad:s,strides:i,inputShape:c}=a,l=QQ(c,o.shape,i,1,s),u=new Qre(l);return n.runWebGLProgram(u,[r,o],"float32")}},aoe=Xne({opSnippet:qne+"\n  return cos(x);\n",packedOpSnippet:"\n  vec4 result = cos(x);\n  bvec4 isNaN = isnan(x);\n  ".concat(Mne,"\n  return result;\n")}),roe={kernelName:rH,backendName:"webgl",kernelFunc:aoe},ooe=Xne({opSnippet:"\n  float e2x = exp(-x);\n  return (e2x + 1.0 / e2x) / 2.0;\n"}),soe={kernelName:oH,backendName:"webgl",kernelFunc:ooe};class ioe{constructor(e,t,n,a,r){this.variableNames=["Image","Boxes","BoxInd"],this.outputShape=[];const[o,s,i,c]=e,[l]=t,[u,d]=n;this.outputShape=[l,u,d,c];const h="bilinear"===a?1:0,[p,f]=["".concat(s-1,".0"),"".concat(i-1,".0")],[m,g,b]=u>1?["".concat((s-1)/(u-1)),"(y2-y1) * height_ratio","y1*".concat(p," + float(y)*(height_scale)")]:["0.0","0.0","0.5 * (y1+y2) * ".concat(p)],[y,x,v]=d>1?["".concat((i-1)/(d-1)),"(x2-x1) * width_ratio","x1*".concat(f," + float(x)*(width_scale)")]:["0.0","0.0","0.5 * (x1+x2) * ".concat(f)];this.userCode="\n      const float height_ratio = float(".concat(m,");\n      const float width_ratio = float(").concat(y,");\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int y = coords[1];\n        int x = coords[2];\n        int d = coords[3];\n\n        // get box vals\n        float y1 = getBoxes(b,0);\n        float x1 = getBoxes(b,1);\n        float y2 = getBoxes(b,2);\n        float x2 = getBoxes(b,3);\n\n        // get image in batch index\n        int bInd = round(getBoxInd(b));\n        if(bInd < 0 || bInd >= ").concat(o,") {\n          return;\n        }\n\n        float height_scale = ").concat(g,";\n        float width_scale = ").concat(x,";\n\n        float in_y = ").concat(b,";\n        if( in_y < 0.0 || in_y > ").concat(p," ) {\n          setOutput(float(").concat(r,"));\n          return;\n        }\n        float in_x = ").concat(v,";\n        if( in_x < 0.0 || in_x > ").concat(f," ) {\n          setOutput(float(").concat(r,"));\n          return;\n        }\n\n        vec2 sourceFracIndexCR = vec2(in_x,in_y);\n        if(").concat(h," == 1) {\n          // Compute the four integer indices.\n          ivec2 sourceFloorCR = ivec2(sourceFracIndexCR);\n          ivec2 sourceCeilCR = ivec2(ceil(sourceFracIndexCR));\n\n          float topLeft = getImage(b, sourceFloorCR.y, sourceFloorCR.x, d);\n          float bottomLeft = getImage(b, sourceCeilCR.y, sourceFloorCR.x, d);\n          float topRight = getImage(b, sourceFloorCR.y, sourceCeilCR.x, d);\n          float bottomRight = getImage(b, sourceCeilCR.y, sourceCeilCR.x, d);\n\n          vec2 fracCR = sourceFracIndexCR - vec2(sourceFloorCR);\n\n          float top = topLeft + (topRight - topLeft) * fracCR.x;\n          float bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;\n          float newValue = top + (bottom - top) * fracCR.y;\n          setOutput(newValue);\n        } else {\n          // Compute the coordinators of nearest neighbor point.\n          ivec2 sourceNearestCR = ivec2(floor(\n            sourceFracIndexCR + vec2(0.5,0.5)));\n          float newValue = getImage(b, sourceNearestCR.y, sourceNearestCR.x, d);\n          setOutput(newValue);\n        }\n      }\n    ")}}const coe={kernelName:cH,backendName:"webgl",kernelFunc:e=>{const{inputs:t,backend:n,attrs:a}=e,{image:r,boxes:o,boxInd:s}=t,{cropSize:i,method:c,extrapolationValue:l}=a,u=new ioe(r.shape,o.shape,i,c,l);return n.runWebGLProgram(u,[r,o,s],"float32")}};var loe;!function(e){e.Prod="*",e.Sum="+"}(loe||(loe={}));class uoe{constructor(e,t,n,a){this.op=e,this.outputShape=t,this.variableNames=["x"],this.customUniforms=[{name:"index",type:"float"}];const r=this.outputShape.length,o=this.op===loe.Prod?"1.0":"0.0",s=n?o:"getX(".concat(doe(r,"coords",this.op),")"),i=this.outputShape[this.outputShape.length-1];let c="",l="";n?(c=a?"end != ".concat(i-1):"end != 0",l=a?"end + 1":"end - 1"):(c=a?"end + pow2 < ".concat(i):"end >= pow2",l=a?"end + pow2":"end - pow2"),this.userCode="\n      void main() {\n        ".concat(zee(r)," coords = getOutputCoords();\n        int end = ").concat(hoe(r,"coords",this.op),";\n        float val = ").concat(s,";\n        int pow2 = int(pow(2.0, index));\n        if (").concat(c,") {\n          int idx = ").concat(l,";\n          ").concat(hoe(r,"coords",this.op)," = idx;\n          val ").concat(this.op,"= getX(").concat(doe(r,"coords",this.op),");\n        }\n        setOutput(val);\n      }\n    ")}}function doe(e,t,n){if(1===e)return"".concat(t);if(2===e)return"".concat(t,".x, ").concat(t,".y");if(3===e)return"".concat(t,".x, ").concat(t,".y, ").concat(t,".z");if(4===e)return"".concat(t,".x, ").concat(t,".y, ").concat(t,".z, ").concat(t,".w");throw new Error("Cumulative ".concat(n," for rank ").concat(e," is not yet supported"))}function hoe(e,t,n){if(1===e)return"".concat(t);if(2===e)return"".concat(t,".y");if(3===e)return"".concat(t,".z");if(4===e)return"".concat(t,".w");throw new Error("Cumulative ".concat(n," for rank ").concat(e," is not yet supported"))}function poe(e,t,n,a,r,o){const s=t.shape.length,i=sZ([a],s);let c=t;null!=i&&(c=pae({inputs:{x:t},backend:n,attrs:{perm:i}}));const l=cZ(1,s)[0];if(l!==s-1)throw new Error("WebGL cumprod shader expects an inner-most axis=".concat(t.shape.length-1," ")+"but got axis=".concat(a));const u=c.shape[l];let d=Pne({inputs:{x:c},backend:n});for(let h=0;h<=Math.ceil(Math.log2(u))-1;h++){const t=new uoe(e,c.shape,!1,o),a=[[h]],r=d;d=n.runWebGLProgram(t,[d],d.dtype,a),n.disposeIntermediateTensorInfo(r)}if(r){const t=new uoe(e,c.shape,r,o),a=d;d=n.runWebGLProgram(t,[d],d.dtype),n.disposeIntermediateTensorInfo(a)}if(null!=i){const e=pae({inputs:{x:d},backend:n,attrs:{perm:iZ(i)}});return n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(c),e}return d}const foe={kernelName:sH,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{axis:o,exclusive:s,reverse:i}=a;return poe(loe.Prod,r,n,o,s,i)}};const moe={kernelName:iH,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{axis:o,exclusive:s,reverse:i}=a;return poe(loe.Sum,r,n,o,s,i)}};const goe={kernelName:lH,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r,weights:o}=t,{size:s,binaryOutput:i}=a;if(1===r.shape.length){const e=n.readSync(r.dataId),t=n.readSync(o.dataId),a=dte(e,t,o.dtype,o.shape,s);return n.makeTensorInfo([s],o.dtype,a)}if(2===r.shape.length){const e=n.bufferSync(r),t=n.bufferSync(o),a=hte(e,t,s,i);return n.makeTensorInfo(a.shape,o.dtype,a.values)}throw new Error("Error in denseBincount: input must be at most rank 2, but got rank"+"".concat(r.shape.length,"."))}};class boe{constructor(e,t,n){this.variableNames=["x"],this.outputShape=[],this.outputShape=e,this.blockSize=t,this.dataFormat=n,this.userCode="\n    void main() {\n      ivec4 coords = getOutputCoords();\n      int b = coords[0];\n      int h = ".concat(this.getHeightCoordString(),";\n      int w = ").concat(this.getWidthCoordString(),";\n      int d = ").concat(this.getDepthCoordString(),";\n\n      int in_h = h / ").concat(t,";\n      int offset_h = imod(h, ").concat(t,");\n      int in_w = w / ").concat(t,";\n      int offset_w = imod(w, ").concat(t,");\n      int offset_d = (offset_h * ").concat(t," + offset_w) *\n        ").concat(this.getOutputDepthSize(),";\n      int in_d = d + offset_d;\n\n      float result = ").concat(this.getInputSamplingString(),";\n      setOutput(result);\n    }\n  ")}getHeightCoordString(){return"NHWC"===this.dataFormat?"coords[1]":"coords[2]"}getWidthCoordString(){return"NHWC"===this.dataFormat?"coords[2]":"coords[3]"}getDepthCoordString(){return"NHWC"===this.dataFormat?"coords[3]":"coords[1]"}getOutputDepthSize(){return"NHWC"===this.dataFormat?this.outputShape[3]:this.outputShape[1]}getInputSamplingString(){return"NHWC"===this.dataFormat?"getX(b, in_h, in_w, in_d)":"getX(b, in_d, in_h, in_w)"}}const yoe={kernelName:uH,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{blockSize:o,dataFormat:s}=a,i=r.shape[0],c=("NHWC"===s?r.shape[1]:r.shape[2])*o,l=("NHWC"===s?r.shape[2]:r.shape[3])*o,u=("NHWC"===s?r.shape[3]:r.shape[1])/(o*o),d=new boe("NHWC"===s?[i,c,l,u]:[i,u,c,l],o,s);return n.runWebGLProgram(d,[r],r.dtype)}};class xoe{constructor(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1],n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null,a=arguments.length>3&&void 0!==arguments[3]&&arguments[3],r=arguments.length>4&&void 0!==arguments[4]&&arguments[4];this.variableNames=["x","W"],this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=jee(this.outputShape.length);const o=e.filterHeight,s=e.filterWidth,i=e.outChannels/e.inChannels;let c="",l="";n&&(c=a?"float activation(float a) {\n          float b = getPreluActivationWeightsAtOutCoords();\n          ".concat(n,"\n        }"):r?"float activation(float a) {\n          float b = getLeakyreluAlphaAtOutCoords();\n          ".concat(n,"\n        }"):"\n          float activation(float x) {\n            ".concat(n,"\n          }\n        "),l="result = activation(result);");const u=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),a&&this.variableNames.push("preluActivationWeights"),r&&this.variableNames.push("leakyreluAlpha"),this.userCode="\n      ".concat(c,"\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int d2 = coords.w;\n        int d1 = d2 / ").concat(i,";\n        int q = d2 - d1 * ").concat(i,";\n\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // Convolve x(?, ?, d1) with w(:, :, d1, q) to get y(yR, yC, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        // TO DO(dsmilkov): Flatten the two for loops and vec4 the operations.\n        for (int wR = 0; wR < ").concat(o,"; wR++) {\n          int xR = xRCorner + wR * dilations[0];\n\n          if (xR < 0 || xR >= inDims[0]) {\n            continue;\n          }\n\n          for (int wC = 0; wC < ").concat(s,"; wC++) {\n            int xC = xCCorner + wC * dilations[1];\n\n            if (xC < 0 || xC >= inDims[1]) {\n              continue;\n            }\n\n            float xVal = getX(batch, xR, xC, d1);\n            float wVal = getW(wR, wC, d1, q);\n            dotProd += xVal * wVal;\n          }\n        }\n\n        float result = dotProd;\n        ").concat(u,"\n        ").concat(l,"\n        setOutput(result);\n      }\n    ")}}class voe{constructor(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1],n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null,a=arguments.length>3&&void 0!==arguments[3]&&arguments[3],r=arguments.length>4&&void 0!==arguments[4]&&arguments[4];this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=jee(this.outputShape.length);const o=e.outChannels/e.inChannels,s=e.padInfo.left,i=e.strideWidth,c=e.dilationWidth,l=e.filterHeight,u=e.filterWidth,d=u;let h="\n      int xR; int xC; int xCOffset;\n      vec4 wTexel; vec4 previous; vec4 final;";for(let g=0;g<u;g++)h+="\n          vec4 xTexelC".concat(2*g,";\n          int xTexelC").concat(2*g,"Ready;\n          vec4 xTexelC").concat(2*g+1,";\n          int xTexelC").concat(2*g+1,"Ready;\n          vec4 xC").concat(g,";");h+="\n    for (int r = 0; r < ".concat(l,"; r++) {\n      ");for(let g=0;g<u;g++)h+="\n          xTexelC".concat(2*g," = vec4(0.0);\n          xTexelC").concat(2*g,"Ready = 0;\n          xTexelC").concat(2*g+1," = vec4(0.0);\n          xTexelC").concat(2*g+1,"Ready = 0;\n          xC").concat(g," = vec4(0.0);");h+="\n        xR = xRCorner + r * dilations[0];\n        if (xR >=0 && xR < inDims[0]) {\n      ";for(let g=0;g<(d+1)/2;g++){const e=2*g;if(h+="\n          xC = xCCorner + ".concat(e*c,";\n          "),1===i){if(e<u&&(s%2===1?(h+="\n                xCOffset = xC + 1;\n                if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC".concat(e,"Ready == 0) {\n                  xTexelC").concat(e," = getX(batch, xR, xCOffset, d1);\n\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if (xCOffset + 1 >= inDims[1]) {\n                    xTexelC").concat(e,".zw = vec2(0.0);\n                  }\n                  xTexelC").concat(e,"Ready = 1;\n                }\n              "),h+=1===c&&e>0?"\n                xC".concat(e," = vec4(xTexelC").concat(e-2,".zw, xTexelC").concat(e,".xy);\n                "):"\n                  xCOffset = xC + 1 - 2;\n\n                  if (xCOffset >= 0 && xCOffset < inDims[1]) {\n                    previous = getX(batch, xR, xCOffset, d1);\n\n                    // Need to manually clear unused channels in case\n                    // we're reading from recycled texture.\n                    if (xCOffset + 1 >= inDims[1]) {\n                      previous.zw = vec2(0.0);\n                    }\n\n                    xC".concat(e," = vec4(previous.zw, xTexelC").concat(e,".xy);\n                  } else {\n                    xC").concat(e," = vec4(0.0, 0.0, xTexelC").concat(e,".xy);\n                  }\n                  ")):h+="\n                if (xC >= 0 && xC < inDims[1] && xTexelC".concat(e,"Ready == 0) {\n                  xTexelC").concat(e," = getX(batch, xR, xC, d1);\n                  if (xC + 1 >= inDims[1]) {\n                    xTexelC").concat(e,".zw = vec2(0.0);\n                  }\n                  xTexelC").concat(e,"Ready = 1;\n                }\n\n                xC").concat(e," = xTexelC").concat(e,";\n                "),e+1<u)){const t=s%2===0?PU(c):c;c%2===0&&s%2===1||c%2!==0&&s%2!==1?(h+="\n                  xCOffset = xC + imod(pads[1], 2) + ".concat(t,";\n\n                  if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC").concat(e+1,"Ready == 0) {\n                    xTexelC").concat(e+1," = getX(batch, xR, xCOffset, d1);\n\n                    // Need to manually clear unused channels in case\n                    // we're reading from recycled texture.\n                    if (xCOffset + 1 >= inDims[1]) {\n                      xTexelC").concat(e+1,".zw = vec2(0.0);\n                    }\n                    xTexelC").concat(e+1,"Ready = 1;\n                  }\n                  "),h+=c>1?"\n                    xCOffset -= 2;\n                    if (xCOffset >= 0 && xCOffset < inDims[1]) {\n                     previous = getX(batch, xR, xCOffset, d1);\n                     xC".concat(e+1," = vec4(previous.zw, xTexelC").concat(e+1,".xy);\n                    } else {\n                     xC").concat(e+1," = vec4(0.0, 0.0, xTexelC").concat(e+1,".xy);\n                    }\n                    "):"\n                    xC".concat(e+1," = vec4(xTexelC").concat(e,".zw, xTexelC").concat(e+1,".xy);\n                    ")):h+=1===t?"\n                    xC".concat(e+1," = xTexelC").concat(e,";\n                    "):"\n                    xCOffset = xC + ".concat(t,";\n\n                    if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC").concat(e+1,"Ready == 0) {\n                      xTexelC").concat(e+1," = getX(batch, xR, xCOffset, d1);\n                      if (xCOffset + 1 >= inDims[1]) {\n                        xTexelC").concat(e+1,".zw = vec2(0.0);\n                      }\n                      xTexelC").concat(e+1,"Ready = 1;\n                    }\n\n                    xC").concat(e+1," = xTexelC").concat(e+1,";\n                    ")}}else e<u&&(s%2===1?(h+="\n                xCOffset = xC + 1 - strides[1];\n                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC".concat(e,"Ready == 0) {\n                  xTexelC").concat(e," = getX(batch, xR, xCOffset, d1);\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if (xCOffset + 1 >= inDims[1]) {\n                    xTexelC").concat(e,".zw = vec2(0.0);\n                  }\n                  xTexelC").concat(e,"Ready = 1;\n                }\n\n                if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC").concat(e+1,"Ready == 0) {\n                  xTexelC").concat(e+1," = getX(batch, xR, xC + 1, d1);\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if (xC + 2 >= inDims[1]) {\n                    xTexelC").concat(e+1,".zw = vec2(0.0);\n                  }\n                  xTexelC").concat(e+1,"Ready = 1;\n                }\n\n                xC").concat(e," = vec4(xTexelC").concat(e,".zw, xTexelC").concat(e+1,".zw);\n              "),e+1<u&&(h+="\n                  final = vec4(0.0);\n                  xCOffset = xC + 1 + strides[1];\n                  if(xCOffset >= 0 && xCOffset < inDims[1]) {\n                    final = getX(batch, xR, xCOffset, d1);\n                  }\n                  xC".concat(e+1," = vec4(xTexelC").concat(e+1,".xy, final.xy);\n                "))):(h+="\n                if(xC >= 0 && xC < inDims[1] && xTexelC".concat(e,"Ready == 0) {\n                  xTexelC").concat(e," = getX(batch, xR, xC, d1);\n                  if (xC + 1 >= inDims[1]) {\n                    xTexelC").concat(e,".zw = vec2(0.0);\n                  }\n                  xTexelC").concat(e,"Ready = 1;\n                }\n\n                xCOffset = xC + strides[1];\n                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC").concat(e+1,"Ready == 0) {\n                  xTexelC").concat(e+1," = getX(batch, xR, xCOffset, d1);\n                  if (xCOffset + 1 >= inDims[1]) {\n                    xTexelC").concat(e+1,".zw = vec2(0.);\n                  }\n                  xTexelC").concat(e+1,"Ready = 1;\n                }\n\n                xC").concat(e," = vec4(\n                  xTexelC").concat(e,".xy, xTexelC").concat(e+1,".xy);\n              "),e+1<u&&(h+="\n                  xC".concat(e+1," = vec4(xTexelC").concat(e,".zw, xTexelC").concat(e+1,".zw);\n                "))));e<u&&(h+="\n            wTexel = getW(r, ".concat(e,", d1, q);\n            dotProd += xC").concat(e," * vec4(wTexel.xz, wTexel.xz);\n          "),e+1<u&&(h+="\n              wTexel = getW(r, ".concat(e+1,", d1, q);\n              dotProd += xC").concat(e+1," * vec4(wTexel.xz, wTexel.xz);\n            ")))}h+="\n    }\n  ",h+="\n      }\n    ";let p="",f="";n&&(p=a?"vec4 activation(vec4 a) {\n          vec4 b = getPreluActivationWeightsAtOutCoords();\n          ".concat(n,"\n        }"):r?"vec4 activation(vec4 a) {\n          vec4 b = getLeakyreluAlphaAtOutCoords();\n          ".concat(n,"\n        }"):"vec4 activation(vec4 x) {\n          ".concat(n,"\n        }"),f="result = activation(result);");const m=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),a&&this.variableNames.push("preluActivationWeights"),r&&this.variableNames.push("leakyreluAlpha"),this.userCode="\n      ".concat(p,"\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int d2 = coords.w;\n        int d1 = d2 / ").concat(o,";\n        int q = d2 - d1 * ").concat(o,";\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.\n        vec4 dotProd = vec4(0.000000000000001);\n\n        ").concat(h,"\n\n        vec4 result = dotProd - vec4(0.000000000000001);\n        ").concat(m,"\n        ").concat(f,"\n        setOutput(result);\n      }\n    ")}}const woe={kernelName:dH,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r,filter:o}=t,{strides:s,pad:i,dilations:c,dimRoundingMode:l}=a;let u=c;null==u&&(u=[1,1]),BU(aJ(s,u),(()=>"Error in depthwiseConv2d: Either strides or dilations must be "+"1. Got strides ".concat(s," and dilations '").concat(u,"'")));const d=YQ(r.shape,o.shape,s,u,i,l,!0);let h;h=yG().getBool("WEBGL_PACK_DEPTHWISECONV")&&d.strideWidth<=2&&d.outChannels/d.inChannels===1?new voe(d):new xoe(d);const p=[[d.padInfo.top,d.padInfo.left],[d.strideHeight,d.strideWidth],[d.dilationHeight,d.dilationWidth],[d.inHeight,d.inWidth]];return n.runWebGLProgram(h,[r,o],"float32",p)}};class koe{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;const t=e.strideHeight,n=e.strideWidth,a=e.padInfo.top,r=e.padInfo.left,o=e.outChannels/e.inChannels;this.userCode="\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int wR = coords.x;\n        int wC = coords.y;\n        int d1 = coords.z;\n        int dm = coords.w;\n        int d2 = d1 * ".concat(o," + dm;\n\n        float dotProd = 0.0;\n\n        // TO DO: Vec4 over the batch size\n        for (int b = 0; b < ").concat(e.batchSize,"; b++) {\n          for (int yR = 0; yR < ").concat(e.outHeight,"; yR++) {\n            int xR = wR + yR * ").concat(t," - ").concat(a,";\n\n            if (xR < 0 || xR >= ").concat(e.inHeight,") {\n              continue;\n            }\n\n            for (int yC = 0; yC < ").concat(e.outWidth,"; yC++) {\n              int xC = wC + yC * ").concat(n," - ").concat(r,";\n\n              if (xC < 0 || xC >= ").concat(e.inWidth,") {\n                continue;\n              }\n\n              float dyValue = getDy(b, yR, yC, d2);\n              float xValue = getX(b, xR, xC, d1);\n              dotProd += (xValue * dyValue);\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    ")}}class Ioe{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;const t=e.filterHeight,n=e.filterWidth,a=e.strideHeight,r=e.strideWidth,o=t-1-e.padInfo.top,s=n-1-e.padInfo.left,i=e.outChannels/e.inChannels;this.userCode="\n      const ivec2 pads = ivec2(".concat(o,", ").concat(s,");\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[3];\n        ivec2 dyCorner = coords.yz - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        float dotProd = 0.0;\n\n        for (int wR = 0; wR < ").concat(t,"; wR++) {\n          float dyR = float(dyRCorner + wR) / ").concat(a,".0;\n\n          if (dyR < 0.0 || dyR >= ").concat(e.outHeight,".0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          int wRPerm = ").concat(t," - 1 - wR;\n\n          for (int wC = 0; wC < ").concat(n,"; wC++) {\n            float dyC = float(dyCCorner + wC) / ").concat(r,".0;\n\n            if (dyC < 0.0 || dyC >= ").concat(e.outWidth,".0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            int wCPerm = ").concat(n," - 1 - wC;\n\n            // TO DO: Vec4 over the channelMul\n            for (int dm = 0; dm < ").concat(i,"; dm++) {\n              int d2 = d1 * ").concat(i," + dm;\n              float xValue = getDy(batch, idyR, idyC, d2);\n              float wValue = getW(wRPerm, wCPerm, d1, dm);\n              dotProd += xValue * wValue;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    ")}}const Soe={kernelName:hH,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r,dy:o}=t,{strides:s,dilations:i,pad:c,dimRoundingMode:l,filterShape:u}=a,d=YQ(r.shape,u,s,i,c,l,!0),h=new koe(d);return n.runWebGLProgram(h,[r,o],"float32")}};const Noe={kernelName:pH,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{dy:r,filter:o}=t,{strides:s,dilations:i,pad:c,dimRoundingMode:l,inputShape:u}=a,d=YQ(u,o.shape,s,i,c,l,!0),h=new Ioe(d);return n.runWebGLProgram(h,[r,o],"float32")}};class Coe{constructor(e){this.variableNames=["X"],this.outputShape=[e,e],this.userCode="\n      void main() {\n          ivec2 coords = getOutputCoords();\n          float val = coords[0] == coords[1] ? getX(coords[0]) : 0.0;\n          setOutput(val);\n      }\n    "}}const Toe={kernelName:fH,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{x:a}=t,r=[...a.shape,...a.shape],o=UU(a.shape),s=aae({inputs:{x:a},backend:n,attrs:{shape:[o]}}),i=new Coe(o),c=n.runWebGLProgram(i,[s],s.dtype),l=aae({inputs:{x:c},backend:n,attrs:{shape:r}});return n.disposeIntermediateTensorInfo(s),n.disposeIntermediateTensorInfo(c),l}};class Eoe{constructor(e){this.variableNames=["x","W"],this.outputShape=e.outShape;const{inHeight:t,inWidth:n,padInfo:a,strideHeight:r,strideWidth:o,filterHeight:s,filterWidth:i,dilationHeight:c,dilationWidth:l}=e,{top:u,left:d}=a;this.userCode="\n      const ivec2 strides = ivec2(".concat(r,", ").concat(o,");\n      const ivec2 pads = ivec2(").concat(u,", ").concat(d,");\n      const float neg_infinity = -3.4e38;\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        int d1 = coords.w;\n        ivec2 outTopLeftCorner =\n            coords.yz * strides - pads;\n        int hBeg = outTopLeftCorner.x;\n        int wBeg = outTopLeftCorner.y;\n\n        float curVal = neg_infinity;\n        for (int h = 0; h < ").concat(s,"; h++) {\n          int hIn = hBeg + h * ").concat(c,";\n\n          if (hIn >= 0 && hIn < ").concat(t,") {\n            for (int w = 0; w < ").concat(i,"; w++) {\n              int wIn = wBeg + w * ").concat(l,";\n\n              if (wIn >= 0 && wIn < ").concat(n,") {\n                float xVal = getX(batch, hIn, wIn, d1);\n                float wVal = getW(h, w, d1);\n\n                float val = xVal + wVal;\n                if (val > curVal) {\n                  curVal = val;\n                }\n              }\n            }\n          }\n        }\n\n        float result = curVal;\n        setOutput(result);\n      }\n    ")}}const Roe={kernelName:mH,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r,filter:o}=t,{strides:s,pad:i,dilations:c}=a,l=KQ(r.shape,o.shape,s,i,"NHWC",c);let u;const d=new Eoe(l);u=n.runWebGLProgram(d,[r,o],"float32");const h=aae({inputs:{x:u},backend:n,attrs:{shape:l.outShape}});return n.disposeIntermediateTensorInfo(u),h}};const _oe={kernelName:vH,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{equation:r}=a,o=t,{allDims:s,summedDims:i,idDims:c}=L2(r,o.length);z2(s.length,c,o);const{path:l,steps:u}=B2(i,c),d=u.length;let h=null,p=s.length;const f=[];for(let m=0;m<d;++m){for(const e of u[m]){const{permutationIndices:t,expandDims:a}=P2(p,c[e]);let r;W2(t)?r=o[e]:(r=pae({inputs:{x:o[e]},backend:n,attrs:{perm:t}}),f.push(r));const s=r.shape.slice();for(let e=0;e<a.length;++e)s.splice(a[e],0,1);GU(r.shape,s)||(r=aae({inputs:{x:r},backend:n,attrs:{shape:s}}),f.push(r)),null===h?h=r:(h=tae({inputs:{a:r,b:h},backend:n}),f.push(h))}m<d-1&&(l[m]>=0&&(h=dae({inputs:{x:h},backend:n,attrs:{axis:l[m]-(s.length-p),keepDims:!1}}),f.push(h)),p--)}for(const m of f)m!==h&&n.disposeIntermediateTensorInfo(m);return h}},Aoe=Xne({opSnippet:"return (x >= 0.0) ? x : (exp(x) - 1.0);",packedOpSnippet:"\n  vec4 result;\n\n  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);\n  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);\n  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);\n  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);\n\n  return result;\n"}),Foe={kernelName:wH,backendName:"webgl",kernelFunc:Aoe},Ooe={kernelName:kH,backendName:"webgl",kernelFunc:e=>{const{inputs:t,backend:n}=e,{dy:a,y:r}=t,o=yG().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new Lne("\n  vec4 bGTEZero = vec4(greaterThanEqual(b, vec4(0.)));\n  return (bGTEZero * a) + ((vec4(1.0) - bGTEZero) * (a * (b + vec4(1.0))));\n",a.shape,r.shape):new Dne("return (b >= 0.0) ? a : a * (b + 1.0);",a.shape,r.shape);return n.runWebGLProgram(o,[a,r],a.dtype)}},Doe=Yne({opSnippet:"return float(a == b);",packedOpSnippet:"\n  return vec4(equal(a, b));\n",dtype:"bool",cpuKernelImpl:bte}),Moe={kernelName:SH,backendName:"webgl",kernelFunc:Doe},Loe=Xne({opSnippet:'\n  // Error function is calculated approximately with elementary function.\n  // See "Handbook of Mathematical Functions with Formulas,\n  // Graphs, and Mathematical Tables", Abramowitz and Stegun.\n  float p = '.concat(y2,";\n  float a1 = ").concat(x2,";\n  float a2 = ").concat(v2,";\n  float a3 = ").concat(w2,";\n  float a4 = ").concat(k2,";\n  float a5 = ").concat(I2,";\n\n  float sign = sign(x);\n  x = abs(x);\n  float t = 1.0 / (1.0 + p * x);\n  return sign * (1.0 - (((((a5*t + a4)*t) + a3)*t + a2)*t + a1)*t*exp(-x*x));\n")}),Poe={kernelName:IH,backendName:"webgl",kernelFunc:Loe},zoe=Xne({opSnippet:qne+"\n  return exp(x);\n",packedOpSnippet:"\n  vec4 result = exp(x);\n  bvec4 isNaN = isnan(x);\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n",cpuKernelImpl:yte,dtype:"float32"}),Boe={kernelName:NH,backendName:"webgl",kernelFunc:zoe};function Woe(e){const{inputs:t,attrs:n,backend:a}=e,{dim:r}=n,{input:o}=t,s=o.shape.length,i=o.shape.slice();let c=r;return r<0&&(BU(-(s+1)<=r,(()=>"Axis must be in the interval [".concat(-(s+1),", ").concat(s,"]"))),c=s+r+1),i.splice(c,0,1),aae({inputs:{x:o},backend:a,attrs:{shape:i}})}const Voe={kernelName:CH,backendName:"webgl",kernelFunc:Woe},Uoe="return exp(x) - 1.0;",Goe=Xne({opSnippet:Uoe,packedOpSnippet:Uoe,cpuKernelImpl:xte}),Hoe={kernelName:TH,backendName:"webgl",kernelFunc:Goe};class joe{constructor(e,t,n){this.variableNames=["real","imag"];const a=t[1];this.outputShape=t;const r=n?"2.0 * ".concat(Math.PI):"-2.0 * ".concat(Math.PI),o=n?"".concat(a,".0"):"1.0";let s;if("real"===e)s="return real * expR - imag * expI;";else{if("imag"!==e)throw new Error('FFT component must be either "real" or "imag", got '.concat(e,"."));s="return real * expI + imag * expR;"}this.userCode="\n      const float exponentMultiplier = ".concat(r,";\n\n      float unaryOpComplex(float real, float expR, float imag, float expI) {\n        ").concat(s,"\n      }\n\n      float mulMatDFT(int batch, int index) {\n        float indexRatio = float(index) / float(").concat(a,");\n        float exponentMultiplierTimesIndexRatio =\n            exponentMultiplier * indexRatio;\n\n        float result = 0.0;\n\n        for (int i = 0; i < ").concat(a,"; i++) {\n          // x = (-2|2 * PI / N) * index * i;\n          float x = exponentMultiplierTimesIndexRatio * float(i);\n          float expR = cos(x);\n          float expI = sin(x);\n          float real = getReal(batch, i);\n          float imag = getImag(batch, i);\n\n          result +=\n              unaryOpComplex(real, expR, imag, expI) / ").concat(o,";\n        }\n\n        return result;\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        setOutput(mulMatDFT(coords[0], coords[1]));\n      }\n    ")}}function Koe(e,t,n){const a=n.texData.get(e.dataId),r=UU(e.shape),o=e.shape[e.shape.length-1],s=aae({inputs:{x:e},backend:n,attrs:{shape:[r/o,o]}}),i=s.shape,c=new joe("real",i,t),l=new joe("imag",i,t),u=[{dataId:a.complexTensorInfos.real.dataId,dtype:a.complexTensorInfos.real.dtype,shape:i},{dataId:a.complexTensorInfos.imag.dataId,dtype:a.complexTensorInfos.imag.dtype,shape:i}],d=n.runWebGLProgram(c,u,"float32"),h=n.runWebGLProgram(l,u,"float32"),p=Bne({inputs:{real:d,imag:h},backend:n});n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(h);const f=aae({inputs:{x:p},backend:n,attrs:{shape:e.shape}});return n.disposeIntermediateTensorInfo(s),n.disposeIntermediateTensorInfo(p),f}const qoe={kernelName:EH,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{input:a}=t;return Koe(a,!1,n)}};class Xoe{constructor(e,t){this.outputShape=[],this.customUniforms=[{name:"value",type:"float"}],this.variableNames=["x"],this.outputShape=e,this.userCode="\n      void main() {\n        // Input can be obtained from uniform value.\n        setOutput(value);\n      }\n    "}}function Yoe(e){const{backend:t,attrs:n}=e,{shape:a,value:r}=n;let{dtype:o}=n;if(o=o||nG(r),"string"===o){const e=ZU(o,UU(a));return e.fill(r),t.makeTensorInfo(a,o,e)}{const e=new Xoe(a,r),n=[[r]];return t.runWebGLProgram(e,[],o,n)}}const Qoe={kernelName:RH,backendName:"webgl",kernelFunc:Yoe};class Joe{constructor(e){this.variableNames=["Image"],this.outputShape=[];const t=e[2];this.outputShape=e,this.userCode="\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int x = coords[2];\n\n          int coordX = ".concat(t," - x - 1;\n          float outputValue;\n          if(coordX >= 0 && coordX < ").concat(t,") {\n            outputValue = getImage(coords[0], coords[1], coordX, coords[3]);\n          } else {\n            outputValue = getImage(coords[0], coords[1], coords[2], coords[3]);\n          }\n          setOutput(outputValue);\n        }\n    ")}}const Zoe={kernelName:_H,backendName:"webgl",kernelFunc:e=>{let{inputs:t,backend:n}=e;const{image:a}=t,r=n,o=new Joe(a.shape);return r.runWebGLProgram(o,[a],a.dtype)}},$oe="return floor(x);",ese=Xne({opSnippet:$oe,packedOpSnippet:$oe,cpuKernelImpl:vte}),tse={kernelName:AH,backendName:"webgl",kernelFunc:ese},nse=Yne({opSnippet:"\n  float s = sign(a) * sign(b);\n  int ia = round(a);\n  int ib = round(b);\n  if (ib != 0) {\n    // Windows (D3D) wants guaranteed non-zero int division at compile-time.\n    return float(idiv(ia, ib, s));\n  } else {\n    return NAN;\n  }\n",packedOpSnippet:"\n  ivec4 ia = round(a);\n  ivec4 ib = round(b);\n  bvec4 cond = notEqual(ib, ivec4(0));\n  ivec4 result = ivec4(0);\n  vec4 s = sign(a) * sign(b);\n\n  // Windows (D3D) wants guaranteed non-zero int division at compile-time.\n  if (cond[0]) {\n    result[0] = idiv(ia[0], ib[0], s[0]);\n  }\n  if (cond[1]) {\n    result[1] = idiv(ia[1], ib[1], s[1]);\n  }\n  if (cond[2]) {\n    result[2] = idiv(ia[2], ib[2], s[2]);\n  }\n  if (cond[3]) {\n    result[3] = idiv(ia[3], ib[3], s[3]);\n  }\n  return vec4(result);\n",dtype:"int32"}),ase={kernelName:FH,backendName:"webgl",kernelFunc:nse};class rse{constructor(e){this.variableNames=["A"];const t=kee(),[n,a]=e;this.outputShape=e,this.userCode="\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int texR = coords[0];\n        int texC = coords[1];\n        int depth = coords[2];\n        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(".concat(a,".0, ").concat(n,".0);\n\n        vec4 values = ").concat(t.texture2D,"(A, uv);\n        float value;\n        if (depth == 0) {\n          value = values.r;\n        } else if (depth == 1) {\n          value = values.g;\n        } else if (depth == 2) {\n          value = values.b;\n        } else if (depth == 3) {\n          value = values.a;\n        }\n\n        setOutput(floor(value * 255.0 + 0.5));\n      }\n    ")}}class ose{constructor(e){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0;const t=kee(),[n,a]=e;this.outputShape=e,this.userCode="\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int texR = coords[0];\n        int texC = coords[1];\n        int depth = coords[2];\n\n        vec4 result = vec4(0.);\n\n        for(int row=0; row<=1; row++) {\n          for(int col=0; col<=1; col++) {\n            texC = coords[1] + row;\n            depth = coords[2] + col;\n\n            vec2 uv = (vec2(texC, texR) + halfCR) /\n                       vec2(".concat(a,".0, ").concat(n,".0);\n            vec4 values = ").concat(t.texture2D,"(A, uv);\n            float value;\n            if (depth == 0) {\n              value = values.r;\n            } else if (depth == 1) {\n              value = values.g;\n            } else if (depth == 2) {\n              value = values.b;\n            } else if (depth == 3) {\n              value = values.a;\n            }\n\n            result[row * 2 + col] = floor(value * 255.0 + 0.5);\n          }\n        }\n\n        ").concat(t.output," = result;\n      }\n    ")}}const sse={kernelName:RK,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e;let{pixels:r}=t;const{numChannels:o}=a,s="undefined"!==typeof HTMLVideoElement&&r instanceof HTMLVideoElement,i="undefined"!==typeof HTMLImageElement&&r instanceof HTMLImageElement,[c,l]=s?[r.videoWidth,r.videoHeight]:[r.width,r.height],u=[l,c],d=[l,c,o];if(i||s){const e=yG().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");null!=ise&&e===cse||(cse=e,ise=document.createElement("canvas").getContext("2d",{willReadFrequently:cse})),ise.canvas.width=c,ise.canvas.height=l,ise.drawImage(r,0,0,c,l),r=ise.canvas}const h=n.makeTensorInfo(u,"int32");n.texData.get(h.dataId).usage=H9.PIXELS,n.gpgpu.uploadPixelDataToTexture(n.getTexture(h.dataId),r);const p=yG().getBool("WEBGL_PACK")?new ose(d):new rse(d),f=n.runWebGLProgram(p,[h],"int32");return n.disposeData(h.dataId),f}};let ise,cse=yG().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");const lse={kernelName:FK,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r,filter:o,bias:s,preluActivationWeights:i}=t,{strides:c,pad:l,dataFormat:u,dilations:d,dimRoundingMode:h,activation:p,leakyreluAlpha:f}=a,m=oJ(u),g=YQ(r.shape,o.shape,c,d,l,h,!1,m);let b;const y=[],x=null!=s,v=null!=i,w="leakyrelu"===p,k=()=>{const e=[r,o],t=(e,t)=>{if("NCHW"===t&&1===e.shape.length&&1!==e.shape[0]){const t=aae({inputs:{x:e},backend:n,attrs:{shape:[e.shape[0],1,1]}});return y.push(t),t}return e};if(x&&e.push(t(s,u)),v&&e.push(t(i,u)),w){const t=n.makeTensorInfo([],"float32",aq(f,"float32"));e.push(t),y.push(t)}return e};if(1!==g.filterHeight||1!==g.filterWidth||1!==g.dilationHeight||1!==g.dilationWidth||1!==g.strideHeight||1!==g.strideWidth||"SAME"!==g.padInfo.type&&"VALID"!==g.padInfo.type)if(g.strideWidth<=2&&"channelsLast"===m&&yG().getBool("WEBGL_EXP_CONV")){const e=p?Qne(p,!0):null,t=new Vre(g,x,e,v,w),a=[[g.padInfo.top,g.padInfo.left],[g.strideHeight,g.strideWidth],[g.dilationHeight,g.dilationWidth],[g.inHeight,g.inWidth]],r=k();b=n.runWebGLProgram(t,r,"float32",a)}else if(yG().getBool("WEBGL_CONV_IM2COL"))b=jre({x:r,filter:o,convInfo:g,backend:n,bias:s,activation:p,preluActivationWeights:i,leakyreluAlpha:f});else{const e=p?Qne(p,!1):null,t=new Bre(g,x,e,v,w),a=k();b=n.runWebGLProgram(t,a,"float32")}else b=Hre({x:r,filter:o,convInfo:g,backend:n,bias:s,activation:p,preluActivationWeights:i,leakyreluAlpha:f});const I=aae({inputs:{x:b},backend:n,attrs:{shape:g.outShape}});return y.push(b),y.forEach((e=>n.disposeIntermediateTensorInfo(e))),I}};const use={kernelName:OK,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r,filter:o,bias:s,preluActivationWeights:i}=t,{strides:c,pad:l,dilations:u,dimRoundingMode:d,activation:h,leakyreluAlpha:p}=a,f=[];let m=u;null==m&&(m=[1,1]),BU(aJ(c,m),(()=>"Error in depthwiseConv2d: Either strides or dilations must be "+"1. Got strides ".concat(c," and dilations '").concat(m,"'")));const g=YQ(r.shape,o.shape,c,m,l,d,!0),b=yG().getBool("WEBGL_PACK_DEPTHWISECONV")&&g.strideWidth<=2&&g.outChannels/g.inChannels===1,y=h?Qne(h,b):null,x=[r,o],v=null!=s,w=null!=i,k="leakyrelu"===h;if(v&&x.push(s),w&&x.push(i),k){const e=n.makeTensorInfo([],"float32",aq(p,"float32"));x.push(e),f.push(e)}let I;I=b?new voe(g,v,y,w,k):new xoe(g,v,y,w,k);const S=[[g.padInfo.top,g.padInfo.left],[g.strideHeight,g.strideWidth],[g.dilationHeight,g.dilationWidth],[g.inHeight,g.inWidth]],N=n.runWebGLProgram(I,x,"float32",S);return f.forEach((e=>n.disposeIntermediateTensorInfo(e))),N}};class dse{constructor(e,t,n,a){this.sliceDim=e,this.strides=t,this.paramsShape=a,this.variableNames=["x","indices"],this.outputShape=n;const r=zee(n.length);let o="\n    int index;";for(let s=0;s<this.sliceDim;s++)o+="\n          index = round(getIndices(coords[0], ".concat(s,"));\n          out_of_bounds = out_of_bounds || index < 0;\n          out_of_bounds = out_of_bounds || index >= ").concat(this.paramsShape[s],";\n          flattenIndex += index * ").concat(this.strides[s],";");this.userCode="\n         void main() {\n          ".concat(r," coords = getOutputCoords();\n          int flattenIndex = 0;\n          bool out_of_bounds = false;\n\n          ").concat(o,"\n\n          setOutput(out_of_bounds ? 0.0 : getX(flattenIndex, coords[1]));\n        }\n      ")}}const hse={kernelName:MH,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{params:a,indices:r}=t,o=r.shape,s=o[o.length-1],i=UU(a.shape),[c,l,u,d]=m2(a,r),h=aae({inputs:{x:r},backend:n,attrs:{shape:[l,s]}}),p=aae({inputs:{x:a},backend:n,attrs:{shape:[UU(a.shape)/u,u]}});if(n.shouldExecuteOnCPU([a,r])||"string"===a.dtype){const e=n.readSync(r.dataId),t=n.bufferSync(a),o=wte(e,t,a.dtype,l,s,u,d,a.shape,i);return n.makeTensorInfo(c,a.dtype,o.values)}const f=new dse(s,d,[l,u],a.shape),m=n.runWebGLProgram(f,[p,h],p.dtype),g=aae({inputs:{x:m},backend:n,attrs:{shape:c}});return n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(m),g}};class pse{constructor(e,t){this.variableNames=["A","indices"],this.outputShape=t,this.rank=t.length;const n=zee(this.rank),a=function(e,t){const n=["resRC.x","resRC.y","resRC.z","resRC.w"],a=[];for(let r=0;r<e.length;r++)2===r?a.push("index"):a.push("".concat(n[r]));return a.join()}(e);this.userCode="\n      void main() {\n        ".concat(n," resRC = getOutputCoords();\n        int index = int(getIndices(resRC.x, resRC.z));\n        float inBounds = (index >= 0) && (index < ").concat(e[2],") ? 1.0 : 0.0;\n        setOutput(inBounds * getA(").concat(a,"));\n      }\n    ")}}function fse(e){const{inputs:t,backend:n,attrs:a}=e,{x:r,indices:o}=t,{axis:s,batchDims:i}=a,c=YU(s,r.shape)[0];if(yG().get("DEBUG")){const e=n.readSync(o.dataId),t=r.shape[c];for(let n=0;n<e.length;++n){const a=e[n];BU(a<=t-1&&a>=0,(()=>"GatherV2: the index value ".concat(a," is not in [0, ").concat(t-1,"]")))}}const l=a3(r,o,c,i),u=UU(o.shape),d=[],h=aae({inputs:{x:r},backend:n,attrs:{shape:[l.batchSize,l.outerSize,l.dimSize,l.sliceSize]}}),p=aae({inputs:{x:o},backend:n,attrs:{shape:[l.batchSize,u/l.batchSize]}});d.push(h),d.push(p);const f=[l.batchSize,l.outerSize,u/l.batchSize,l.sliceSize];if(n.shouldExecuteOnCPU([r,o])||"string"===r.dtype){const e=n.bufferSync(p),t=n.bufferSync(h),a=kte(t,e,f);return d.forEach((e=>n.disposeIntermediateTensorInfo(e))),n.makeTensorInfo(l.outputShape,a.dtype,a.values)}const m=new pse(h.shape,f),g=n.runWebGLProgram(m,[h,p],h.dtype);d.push(g);const b=aae({inputs:{x:g},backend:n,attrs:{shape:l.outputShape}});return d.forEach((e=>n.disposeIntermediateTensorInfo(e))),b}const mse={kernelName:DH,backendName:"webgl",kernelFunc:fse},gse=Yne({opSnippet:"return float(a > b);",packedOpSnippet:"\n  return vec4(greaterThan(a, b));\n",cpuKernelImpl:Ite,dtype:"bool"}),bse={kernelName:LH,backendName:"webgl",kernelFunc:gse},yse=Yne({opSnippet:"return float(a >= b);",packedOpSnippet:"\n  return vec4(greaterThanEqual(a, b));\n",dtype:"bool",cpuKernelImpl:Ste}),xse={kernelName:PH,backendName:"webgl",kernelFunc:yse};const vse={kernelName:BH,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{input:a}=t;return Koe(a,!0,n)}},wse=Xne({opSnippet:"return float(!isnan(x) && !isinf(x));",dtype:"bool"}),kse={kernelName:VH,backendName:"webgl",kernelFunc:wse},Ise=Xne({opSnippet:"return float(isinf(x));",dtype:"bool"}),Sse={kernelName:UH,backendName:"webgl",kernelFunc:Ise},Nse=Xne({opSnippet:"return float(isnan(x));",dtype:"bool"}),Cse={kernelName:GH,backendName:"webgl",kernelFunc:Nse},Tse=Yne({opSnippet:"return float(a < b);",packedOpSnippet:"\n  return vec4(lessThan(a, b));\n",cpuKernelImpl:Nte,dtype:"bool"}),Ese={kernelName:jH,backendName:"webgl",kernelFunc:Tse},Rse=Yne({opSnippet:"return float(a <= b);",packedOpSnippet:"\n  return vec4(lessThanEqual(a, b));\n",cpuKernelImpl:Cte,dtype:"bool"}),_se={kernelName:KH,backendName:"webgl",kernelFunc:Rse};const Ase={kernelName:qH,backendName:"webgl",kernelFunc:function(e){const{backend:t,attrs:n}=e,{start:a,stop:r,num:o}=n,s=Tte(a,r,o);return t.makeTensorInfo([s.length],"float32",s)}},Fse=Xne({opSnippet:qne+"\n  return x < 0.0 ? 0./0. : log(x);\n",packedOpSnippet:"\n  vec4 result = log(x);\n  bvec4 isNaN = isnan(x);\n  result.r = isNaN.r ? x.r : (x.r < 0.0 ? 0./0. : result.r);\n  result.g = isNaN.g ? x.g : (x.g < 0.0 ? 0./0. : result.g);\n  result.b = isNaN.b ? x.b : (x.b < 0.0 ? 0./0. : result.b);\n  result.a = isNaN.a ? x.a : (x.a < 0.0 ? 0./0. : result.a);\n  return result;\n",cpuKernelImpl:Ete}),Ose={kernelName:XH,backendName:"webgl",kernelFunc:Fse},Dse=Xne({opSnippet:qne+"\n  return log(1.0 + x);\n"}),Mse={kernelName:YH,backendName:"webgl",kernelFunc:Dse},Lse=Yne({opSnippet:"return float(a >= 1.0 && b >= 1.0);",packedOpSnippet:"\n  return vec4(\n    vec4(greaterThanEqual(a, vec4(1.0))) *\n    vec4(greaterThanEqual(b, vec4(1.0))));\n",dtype:"bool"}),Pse={kernelName:QH,backendName:"webgl",kernelFunc:Lse},zse=Xne({opSnippet:"return float(!(x >= 1.0));"}),Bse={kernelName:JH,backendName:"webgl",kernelFunc:zse},Wse=Yne({opSnippet:"return float(a >= 1.0 || b >= 1.0);",packedOpSnippet:"\n  return min(\n    vec4(greaterThanEqual(a, vec4(1.0))) +\n    vec4(greaterThanEqual(b, vec4(1.0))),\n    vec4(1.0));\n",dtype:"bool"}),Vse={kernelName:ZH,backendName:"webgl",kernelFunc:Wse};class Use{constructor(e,t,n,a,r){this.variableNames=["x"],this.outputShape=[];const o=t,s=e[3]-1;let i;this.outputShape=e;const c="float(".concat(n,") + float(").concat(a,") * sum");i=.5===r?"inversesqrt(".concat(c,")"):1===r?"1.0/(".concat(c,")"):"exp(log(".concat(c,") * float(-").concat(r,"));"),this.userCode="\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int r = coords[1];\n        int c = coords[2];\n        int d = coords[3];\n        float x = getX(b, r, c, d);\n        float sum = 0.0;\n        for (int j = -".concat(o,"; j <= ").concat(o,"; j++) {\n          int idx = d + j;\n          if (idx >= 0 && idx <=  ").concat(s,") {\n            float z = getX(b, r, c, idx);\n            sum += z * z;\n          }\n        }\n        float val = x * ").concat(i,";\n        setOutput(val);\n      }\n    ")}}class Gse{constructor(e,t,n,a,r){this.variableNames=["x"],this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0;const o=t,s=e[3]-1;let i;this.outputShape=e;const c="float(".concat(n,") + float(").concat(a,") * sum");i=.5===r?"inversesqrt(".concat(c,")"):1===r?"1.0/(".concat(c,")"):"exp(log(".concat(c,") * float(-").concat(r,"));"),this.userCode="\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords.x;\n        int r = coords.y;\n        int c = coords.z;\n        int d = coords.w;\n\n        bool hasNextCol = d < ".concat(this.outputShape[3],";\n        bool hasNextRow = c < ").concat(this.outputShape[2],";\n\n        vec4 sum = vec4(0.);\n        vec4 xFragAtOutputCoords = getX(b, r, c, d);\n\n        vec4 xAtOutputCoords = vec4(\n          getChannel(xFragAtOutputCoords, vec2(c, d)),\n          hasNextCol ?\n            getChannel(xFragAtOutputCoords, vec2(c, d + 1)) : 0.0,\n          hasNextRow ?\n            getChannel(xFragAtOutputCoords , vec2(c + 1, d)) : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getChannel(xFragAtOutputCoords, vec2(c + 1, d + 1)) : 0.0\n        );\n\n        int firstChannel = d - ").concat(o,";\n        vec2 cache = vec2(0.);\n        if(firstChannel >= 0){\n          vec4 firstChannelFrag = getX(b, r, c, firstChannel);\n          cache.x = getChannel(firstChannelFrag, vec2(c, firstChannel));\n            if(hasNextRow){\n              cache.y = getChannel(firstChannelFrag, vec2(c + 1, firstChannel));\n            }\n        }\n\n        ivec2 depth = ivec2(d, d + 1);\n        for (int j = - ").concat(o,"; j <= ").concat(o,"; j++) {\n          ivec2 idx = depth + j;\n          bvec2 aboveLowerBound = greaterThanEqual(idx, ivec2(0));\n          bvec2 belowUpperBound = lessThanEqual(idx, ivec2(").concat(s,"));\n\n          bool depthInRange = aboveLowerBound.x && belowUpperBound.x;\n          bool depthPlusOneInRange = aboveLowerBound.y && belowUpperBound.y;\n\n          if(depthInRange || depthPlusOneInRange){\n            vec4 z = vec4(0.);\n            vec4 xFragAtCurrentDepth;\n            z.xz = cache.xy;\n            if(depthPlusOneInRange && hasNextCol){\n              xFragAtCurrentDepth = idx.y != d ?\n                getX(b, r, c, idx.y) : xFragAtOutputCoords;\n              z.y = getChannel(xFragAtCurrentDepth, vec2(c, idx.y));\n              if(hasNextRow){\n                z.w = getChannel(xFragAtCurrentDepth, vec2(c + 1, idx.y));\n              }\n            }\n            cache.xy = z.yw;\n            sum += z * z;\n          }\n        }\n        vec4 result = xAtOutputCoords * ").concat(i,";\n        setOutput(result);\n      }\n    ")}}const Hse={kernelName:$H,backendName:"webgl",kernelFunc:e=>{const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{depthRadius:o,bias:s,alpha:i,beta:c}=a,l=yG().getBool("WEBGL_PACK_NORMALIZATION")?new Gse(r.shape,o,s,i,c):new Use(r.shape,o,s,i,c);return n.runWebGLProgram(l,[r],r.dtype)}};class jse{constructor(e,t,n,a,r){this.variableNames=["inputImage","outputImage","dy"],this.outputShape=[],this.outputShape=e,this.depth=e[3],this.depthRadius=t,this.bias=n,this.alpha=a,this.beta=r,this.userCode="\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int r = coords[1];\n        int c = coords[2];\n\n        float result = 0.0;\n        for (int d = 0; d < ".concat(this.depth,"; ++d) {\n          int depthBegin = int(max(0.0, float(d - ").concat(t,")));\n          int depthEnd = int(min(float(").concat(this.depth,"),\n              float(d + ").concat(t," + 1)));\n\n          const int MIN_DEPTH_BEGIN = 0;\n          const int MAX_DEPTH_END = ").concat(this.depth,";\n\n          float norm = 0.0;\n          for (int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k) {\n            if (k < depthBegin){\n              continue;\n            }\n            else if (k >= depthBegin && k < depthEnd) {\n              norm += getInputImage(b, r, c, k) * getInputImage(b, r, c, k);\n            }\n            else {\n              break;\n            }\n          }\n\n          norm = float(").concat(a,") * norm + float(").concat(n,");\n\n          for(int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k){\n            if (k < depthBegin){\n              continue;\n            }\n            else if (k >= depthBegin && k < depthEnd){\n              float dyi = -2.0 * float(").concat(a,")\n                * float(").concat(r,")\n                * getInputImage(b, r, c, k) * getOutputImage(b, r, c, d)\n                / norm;\n              if (k == d) {\n                dyi += pow(norm, -1.0 * ").concat(r,");\n              }\n              if (k == coords[3]) {\n                dyi *= getDy(b, r, c, d);\n                result += dyi;\n              }\n            }\n            else {\n              break;\n            }\n          }\n      }\n      setOutput(result);\n      }\n    ")}}const Kse={kernelName:ej,backendName:"webgl",kernelFunc:e=>{const{inputs:t,backend:n,attrs:a}=e,{x:r,y:o,dy:s}=t,{depthRadius:i,bias:c,alpha:l,beta:u}=a,d=new jse(r.shape,i,c,l,u);return n.runWebGLProgram(d,[r,o,s],r.dtype)}};function qse(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{reductionIndices:o,keepDims:s}=a,i=r.shape.length,c=YU(o,r.shape);let l=c;const u=sZ(l,i),d=null!=u,h=n.shouldExecuteOnCPU([r]);let p=r;if(d){if(h){const e=n.texData.get(p.dataId).values,t=new Array(i);for(let n=0;n<t.length;n++)t[n]=r.shape[u[n]];const a=ane(e,r.shape,r.dtype,u,t);p=n.makeTensorInfo(t,r.dtype);n.texData.get(p.dataId).values=a}else p=uae(r,u,n);l=cZ(l.length,i)}oZ("max",l,i);const[f,m]=aZ(p.shape,l);let g,b=f;if(s&&(b=rZ(f,c)),h){const e=n.texData.get(p.dataId).values,t=Rte(e,UU(m),b,r.dtype);g=n.makeTensorInfo(b,r.dtype);n.texData.get(g.dataId).values=t}else g=function(e,t,n,a){const r=UU(t),o=aae({inputs:{x:e},attrs:{shape:[UU(e.shape)/r,r]},backend:a}),s=iae(o,e.dtype,"max",a),i=aae({inputs:{x:s},attrs:{shape:n},backend:a});return a.disposeIntermediateTensorInfo(o),a.disposeIntermediateTensorInfo(s),i}(p,m,b,n);return d&&n.disposeIntermediateTensorInfo(p),g}const Xse={kernelName:tj,backendName:"webgl",kernelFunc:qse},Yse=Yne({opSnippet:One+"\n  return max(a, b);\n",packedOpSnippet:"\n  vec4 result = vec4(max(a, b));\n  bvec4 isNaNA = isnan(a);\n  bvec4 isNaNB = isnan(b);\n  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);\n  "+Mne+"\n  return result;\n",cpuKernelImpl:_te}),Qse={kernelName:nj,backendName:"webgl",kernelFunc:Yse};const Jse={kernelName:aj,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t;vee(r,"maxPool");const{filterSize:o,strides:s,pad:i,dimRoundingMode:c}=a;BU(aJ(s,1),(()=>"Error in maxPool: Either strides or dilations must be 1. "+"Got strides ".concat(s," and dilations '").concat(1,"'")));const l=qQ(r.shape,o,s,1,i,c);if(1===l.filterWidth&&1===l.filterHeight&&GU(l.inShape,l.outShape))return Pne({inputs:{x:r},backend:n});const u=new Yae(l,"max",!1);return n.runWebGLProgram(u,[r],r.dtype)}};const Zse={kernelName:oj,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{filterSize:o,strides:s,pad:i,dataFormat:c,dimRoundingMode:l}=a,u=XQ(r.shape,o,s,[1,1,1],i,l,c),d=new Qae(u,"max",!1);return n.runWebGLProgram(d,[r],r.dtype)}};class $se{constructor(e){this.variableNames=["dy","maxPos"],this.outputShape=e.inShape;const t=e.strideHeight,n=e.strideWidth,a=e.dilationHeight,r=e.effectiveFilterHeight,o=e.effectiveFilterWidth,s=r-1-e.padInfo.top,i=o-1-e.padInfo.left,c=r*o-1;this.userCode="\n      const ivec2 pads = ivec2(".concat(s,", ").concat(i,");\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n\n        ivec2 dyRCCorner = coords.yz - pads;\n        int dyRCorner = dyRCCorner.x;\n        int dyCCorner = dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ").concat(r,";\n          wR += ").concat(a,") {\n          float dyR = float(dyRCorner + wR) / ").concat(t,".0;\n\n          if (dyR < 0.0 || dyR >= ").concat(e.outHeight,".0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          for (int wC = 0; wC < ").concat(o,"; wC++) {\n            float dyC = float(dyCCorner + wC) / ").concat(n,".0;\n\n            if (dyC < 0.0 || dyC >= ").concat(e.outWidth,".0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            float dyValue = getDy(b, idyR, idyC, d);\n            int maxPosValue = ").concat(c," - int(getMaxPos(b, idyR, idyC, d));\n\n            // Get the current value, check it against the value from the\n            // position matrix.\n            int curPosValue = wR * ").concat(o," + wC;\n            float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);\n\n            dotProd += dyValue * mask;\n          }\n        }\n        setOutput(dotProd);\n      }\n    ")}}class eie{constructor(e){this.variableNames=["dy","maxPos"],this.outputShape=e.inShape;const t=e.strideDepth,n=e.strideHeight,a=e.strideWidth,r=e.dilationDepth,o=e.dilationHeight,s=e.dilationWidth,i=e.effectiveFilterDepth,c=e.effectiveFilterHeight,l=e.effectiveFilterWidth,u=i-1-e.padInfo.front,d=c-1-e.padInfo.top,h=l-1-e.padInfo.left,p=i*c*l-1;this.userCode="\n      const ivec3 pads = ivec3(".concat(u,", ").concat(d,", ").concat(h,");\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyDCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        // Convolve dy(?, ?, ?, ch) with pos mask(:, :, :, d) to get\n        // dx(xD, xR, xC, ch).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int wD = 0; wD < ").concat(i,";\n           wD += ").concat(r,") {\n          float dyD = float(dyDCorner + wD) / ").concat(t,".0;\n\n          if (dyD < 0.0 || dyD >= ").concat(e.outDepth,".0 || fract(dyD) > 0.0) {\n            continue;\n          }\n          int idyD = int(dyD);\n\n          for (int wR = 0; wR < ").concat(c,";\n              wR += ").concat(o,") {\n            float dyR = float(dyRCorner + wR) / ").concat(n,".0;\n\n            if (dyR < 0.0 || dyR >= ").concat(e.outHeight,".0 ||\n                fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            for (int wC = 0; wC < ").concat(l,";\n                wC += ").concat(s,") {\n              float dyC = float(dyCCorner + wC) / ").concat(a,".0;\n\n              if (dyC < 0.0 || dyC >= ").concat(e.outWidth,".0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              float dyValue = getDy(batch, idyD, idyR, idyC, ch);\n              int maxPosValue = ").concat(p," -\n                  int(getMaxPos(batch, idyD, idyR, idyC, ch));\n\n              // Get the current value, check it against the value from the\n              // position matrix.\n              int curPosValue =\n                  wD * ").concat(c," * ").concat(l," +\n                  wR * ").concat(l," + wC;\n              float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);\n\n              dotProd += dyValue * mask;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    ")}}const tie={kernelName:sj,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{dy:r,input:o}=t,s=o,{filterSize:i,strides:c,pad:l,dimRoundingMode:u}=a,d=XQ(s.shape,i,c,[1,1,1],l,u),h=new Qae(d,"max",!0),p=n.runWebGLProgram(h,[s],s.dtype),f=new eie(d),m=n.runWebGLProgram(f,[r,p],s.dtype);return n.disposeIntermediateTensorInfo(p),m}};const nie={kernelName:rj,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{dy:r,input:o,output:s}=t,i=o;vee([o,s],"maxPoolGrad");const{filterSize:c,strides:l,pad:u,dimRoundingMode:d}=a,h=qQ(i.shape,c,l,1,u,d),p=new Yae(h,"max",!0),f=n.runWebGLProgram(p,[i],i.dtype),m=new $se(h),g=n.runWebGLProgram(m,[r,f],i.dtype);return n.disposeIntermediateTensorInfo(f),g}};const aie={kernelName:ij,backendName:"webgl",kernelFunc:e=>{let{inputs:t,attrs:n,backend:a}=e;const{x:r}=t,{filterSize:o,strides:s,pad:i,includeBatchInIndex:c}=n,l=a;BU(4===r.shape.length,(()=>"Error in maxPool: input must be rank 4 but got rank ".concat(r.shape.length,".")));const u=[1,1];BU(aJ(s,u),(()=>"Error in maxPool: Either strides or dilations must be 1. "+"Got strides ".concat(s," and dilations '").concat(u,"'")));const d=qQ(r.shape,o,s,u,i),[h,p]=function(e,t,n,a){let r=new Yae(n,"max",!1);const o=a.runWebGLProgram(r,[e],"float32");return r=new Yae(n,"max",!0,!0,t),[o,a.runWebGLProgram(r,[e],"float32")]}(r,c,d,l);return[h,p]}};const rie={kernelName:cj,backendName:"webgl",kernelFunc:e=>{let{inputs:t,attrs:n,backend:a}=e;const{x:r}=t,{keepDims:o,axis:s}=n,i=a,c=r.shape.length,l=YU(s,r.shape);let u=l;const d=sZ(u,c),h=null!=d,p=i.shouldExecuteOnCPU([r]),f=[];let m=r;if(h){if(p){const e=i.texData.get(m.dataId).values,t=new Array(c);for(let a=0;a<t.length;a++)t[a]=r.shape[d[a]];const n=ane(e,r.shape,r.dtype,d,t);m=i.makeTensorInfo(t,r.dtype);i.texData.get(m.dataId).values=n}else m=uae(r,d,i);f.push(m),u=cZ(u.length,c)}oZ("sum",u,c);const[g,b]=aZ(m.shape,u);let y=g;o&&(y=rZ(g,l));const x=function(e,t,n,a){const r=UU(t),o=aae({inputs:{x:e},attrs:{shape:[UU(e.shape)/r,r]},backend:a}),s=iae(o,"float32","mean",a),i=aae({inputs:{x:s},attrs:{shape:n},backend:a});return a.disposeIntermediateTensorInfo(o),a.disposeIntermediateTensorInfo(s),i}(m,b,y,i);for(const v of f)i.disposeIntermediateTensorInfo(v);return x}};const oie={kernelName:lj,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{axis:o,keepDims:s}=a,i=r.shape.length,c=YU(o,r.shape);let l=c;const u=sZ(l,i);let d=r;null!=u&&(d=pae({inputs:{x:r},backend:n,attrs:{perm:u}}),l=cZ(l.length,r.shape.length)),oZ("min",l,i);const[h,p]=aZ(d.shape,l),f=aae({inputs:{x:d},backend:n,attrs:{shape:[-1,UU(p)]}}),m=iae(f,f.dtype,"min",n);let g;if(s){g=aae({inputs:{x:m},backend:n,attrs:{shape:rZ(h,c)}})}else g=aae({inputs:{x:m},backend:n,attrs:{shape:h}});return n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),null!=u&&n.disposeIntermediateTensorInfo(d),g}},sie=Yne({opSnippet:One+"\n  return min(a, b);\n",packedOpSnippet:"\n  vec4 result = vec4(min(a, b));\n  bvec4 isNaNA = isnan(a);\n  bvec4 isNaNB = isnan(b);\n  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);\n  "+Mne+"\n  return result;\n",cpuKernelImpl:Ate}),iie={kernelName:uj,backendName:"webgl",kernelFunc:sie};class cie{constructor(e,t,n){this.variableNames=["x"],this.outputShape=t.map(((t,n)=>t[0]+e[n]+t[1]));const a=e.length,r=zee(a),o=t.map((e=>e[0])).join(","),s=t.map(((t,n)=>t[0]+e[n])).join(","),i=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,a),c="reflect"===n?0:1;this.userCode=1!==a?"\n      ".concat(r," start = ").concat(r,"(").concat(o,");\n      ").concat(r," end = ").concat(r,"(").concat(s,");\n\n      void main() {\n        ").concat(r," outC = getOutputCoords();\n        for (int i = 0; i < ").concat(a,"; i++) {\n          if (outC[i] < start[i]) {\n            outC[i] = start[i] * 2 - outC[i] - ").concat(c,";\n          } else if(outC[i] >= end[i]) {\n            outC[i] = (end[i] - 1) * 2 - outC[i] + ").concat(c,";\n          }\n        }\n        ").concat(r," coords = outC - start;\n        setOutput(getX(").concat(i,"));\n      }\n    "):"\n        int start = ".concat(o,";\n        int end = ").concat(s,";\n\n        void main() {\n          int outC = getOutputCoords();\n          if (outC < start) {\n            outC = start * 2 - outC - ").concat(c,";\n          } else if(outC >= end) {\n            outC = (end - 1) * 2 - outC + ").concat(c,";\n          }\n          setOutput(getX(outC - start));\n        }\n      ")}}class lie{constructor(e,t,n){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t.map(((t,n)=>t[0]+e[n]+t[1]));const a=e.length,r=zee(a),o=t.map((e=>e[0])).join(","),s=t.map(((t,n)=>t[0]+e[n])).join(","),i=sne("rc",a),c=sne("source",a),l="".concat(i[a-1]," < ").concat(this.outputShape[a-1]),u=1===a?"source":"vec2(".concat(c.slice(-2).join(),")"),d="reflect"===n?0:1;let h="";if(1===a){const e="\n        ".concat(r," source = rc;\n        if (source < start) {\n          source = start * 2 - source - ").concat(d,";\n        } else if (source >= end) {\n          source = (end - 1) * 2 - source + ").concat(d,";\n        }\n        source -= start;\n      ");h="\n        ".concat(r," rc = outputLoc;\n        ").concat(e,"\n        result[0] = getChannel(getX(").concat(c.join(),"), ").concat(u,");\n        ").concat(i[a-1]," += 1;\n        if(").concat(l,") {\n          ").concat(e,"\n          result[1] = getChannel(getX(").concat(c.join(),"), ").concat(u,");\n        }\n      ")}else{const e="\n        ".concat(r," source = rc;\n        ").concat(r," lt = ").concat(r,"(lessThan(source, start));\n        ").concat(r," gte = ").concat(r,"(greaterThanEqual(source, end));\n        ").concat(r," orig = 1 - (lt + gte);\n        source = orig * source +\n                lt * (start * 2 - source - ").concat(d,") +\n                gte * ((end - 1) * 2 - source + ").concat(d,");\n        source -= start;\n      ");h="\n        ".concat(r," rc = outputLoc;\n        ").concat(e,"\n        result[0] = getChannel(getX(").concat(c.join(),"), ").concat(u,");\n        ").concat(i[a-1]," += 1;\n        if(").concat(l,") {\n          ").concat(e,"\n          result[1] = getChannel(getX(").concat(c.join(),"), ").concat(u,");\n        }\n        rc = outputLoc;\n        ").concat(i[a-2]," += 1;\n        if(").concat(i[a-2]," < ").concat(this.outputShape[a-2],") {\n          ").concat(e,"\n          result[2] = getChannel(getX(").concat(c.join(),"), ").concat(u,");\n          ").concat(i[a-1]," += 1;\n          if(").concat(l,") {\n            ").concat(e,"\n            result[3] = getChannel(getX(").concat(c.join(),"), ").concat(u,");\n          }\n        }\n      ")}this.userCode="\n      const ".concat(r," start = ").concat(r,"(").concat(o,");\n      const ").concat(r," end = ").concat(r,"(").concat(s,");\n\n      void main() {\n        ").concat(r," outputLoc = getOutputCoords();\n        vec4 result = vec4(0.);\n        ").concat(h,"\n        setOutput(result);\n      }\n    ")}}const uie={kernelName:dj,backendName:"webgl",kernelFunc:e=>{let{inputs:t,backend:n,attrs:a}=e;const{x:r}=t,{paddings:o,mode:s}=a,i=yG().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new lie(r.shape,o,s):new cie(r.shape,o,s);return n.runWebGLProgram(i,[r],r.dtype)}},die=Yne({opSnippet:"if (b == 0.0) return NAN;\n  return mod(a, b);",packedOpSnippet:"\n  vec4 result = mod(a, b);\n  bvec4 isNaN = equal(b, vec4(0.0));\n  "+Mne+"\n  return result;\n"}),hie={kernelName:hj,backendName:"webgl",kernelFunc:die};class pie{constructor(e,t,n){this.variableNames=["probs"],this.customUniforms=[{name:"seed",type:"float"}],this.outputShape=[e,n],this.userCode="\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n\n        float r = random(seed);\n        float cdf = 0.0;\n\n        for (int i = 0; i < ".concat(t-1,"; i++) {\n          cdf += getProbs(batch, i);\n\n          if (r < cdf) {\n            setOutput(float(i));\n            return;\n          }\n        }\n\n        // If no other event happened, last event happened.\n        setOutput(float(").concat(t-1,"));\n      }\n    ")}}const fie=Yne({opSnippet:"\nif (a == b) {\n  return 1.0;\n};\nreturn a / b;",packedOpSnippet:"\n  // vec4 one = vec4(equal(a, b));\n  // return one + (vec4(1.0) - one) * a / b;\n  vec4 result = a / b;\n  if(a.x == b.x) {\n    result.x = 1.;\n  }\n  if(a.y == b.y) {\n    result.y = 1.;\n  }\n  if(a.z == b.z) {\n    result.z = 1.;\n  }\n  if(a.w == b.w) {\n    result.w = 1.;\n  }\n\n  return result;\n",checkOutOfBounds:!0}),mie={kernelName:xH,backendName:"webgl",kernelFunc:fie},gie="return a - b;",bie=Yne({opSnippet:gie,packedOpSnippet:gie,supportsComplex:!0,cpuKernelImpl:ene}),yie={kernelName:bK,backendName:"webgl",kernelFunc:bie};function xie(e){const{inputs:t,backend:n,attrs:a}=e,{logits:r}=t,{dim:o}=a,s=YU([o],r.shape),i=qse({inputs:{x:r},backend:n,attrs:{reductionIndices:s,keepDims:!1}}),c=rZ(i.shape,s),l=aae({inputs:{x:i},backend:n,attrs:{shape:c}}),u=bie({inputs:{a:r,b:l},backend:n}),d=zoe({inputs:{x:u},backend:n}),h=dae({inputs:{x:d},backend:n,attrs:{axis:s,keepDims:!1}}),p=aae({inputs:{x:h},backend:n,attrs:{shape:c}}),f=fie({inputs:{a:d,b:p},backend:n});return n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(l),n.disposeIntermediateTensorInfo(u),n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(p),f}const vie={kernelName:rK,backendName:"webgl",kernelFunc:xie};const wie={kernelName:pj,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{logits:r}=t,{numSamples:o,seed:s,normalized:i}=a,c=i?r:xie({inputs:{logits:r},backend:n,attrs:{dim:r.shape.length-1}}),l=c.shape[0],u=c.shape[1],d=new pie(l,u,o),h=[[s]],p=n.runWebGLProgram(d,[c],"int32",h);return i||n.disposeIntermediateTensorInfo(c),p}},kie=fne+"\n  return -x;\n";const Iie={kernelName:mj,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{x:a}=t;if(n.shouldExecuteOnCPU([a])){const e=n.texData.get(a.dataId),[t,r]=Ote(e.values,a.shape,a.dtype);return n.makeTensorInfo(r,a.dtype,t)}let r;return r=yG().getBool("WEBGL_PACK_UNARY_OPERATIONS")?new Tne(a.shape,"\n  vec4 result = -x;\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n"):new pne(a.shape,kie),n.runWebGLProgram(r,[a],a.dtype)}},Sie=c1;const Nie={kernelName:bj,backendName:"webgl",kernelFunc:function(e){DK("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:t,backend:n,attrs:a}=e,{boxes:r,scores:o}=t,{maxOutputSize:s,iouThreshold:i,scoreThreshold:c}=a,l=n.readSync(r.dataId),u=n.readSync(o.dataId),{selectedIndices:d}=Sie(l,u,s,i,c);return n.makeTensorInfo([d.length],"int32",new Int32Array(d))}},Cie=l1;const Tie={kernelName:yj,backendName:"webgl",kernelFunc:function(e){DK("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:t,backend:n,attrs:a}=e,{boxes:r,scores:o}=t,{maxOutputSize:s,iouThreshold:i,scoreThreshold:c,padToMaxOutputSize:l}=a,u=n.readSync(r.dataId),d=n.readSync(o.dataId),{selectedIndices:h,validOutputs:p}=Cie(u,d,s,i,c,l);return[n.makeTensorInfo([h.length],"int32",new Int32Array(h)),n.makeTensorInfo([],"int32",new Int32Array([p]))]}},Eie=u1;const Rie={kernelName:xj,backendName:"webgl",kernelFunc:function(e){DK("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:t,backend:n,attrs:a}=e,{boxes:r,scores:o}=t,{maxOutputSize:s,iouThreshold:i,scoreThreshold:c,softNmsSigma:l}=a,u=n.readSync(r.dataId),d=n.readSync(o.dataId),h=s,p=i,f=c,m=l,{selectedIndices:g,selectedScores:b}=Eie(u,d,h,p,f,m);return[n.makeTensorInfo([g.length],"int32",new Int32Array(g)),n.makeTensorInfo([b.length],"float32",new Float32Array(b))]}};class _ie{constructor(e,t,n,a){this.variableNames=["indices"],this.outputShape=[e,t],this.userCode="\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int index = round(getIndices(coords.x));\n        setOutput(mix(float(".concat(a,"), float(").concat(n,"),\n                      float(index == coords.y)));\n      }\n    ")}}const Aie={kernelName:wj,backendName:"webgl",kernelFunc:e=>{const{inputs:t,backend:n,attrs:a}=e,{indices:r}=t,{dtype:o,depth:s,onValue:i,offValue:c}=a,l=UU(r.shape),u=new _ie(l,s,i,c),d=aae({inputs:{x:r},backend:n,attrs:{shape:[l]}}),h=n.runWebGLProgram(u,[d],o);n.disposeIntermediateTensorInfo(d);const p=aae({inputs:{x:h},backend:n,attrs:{shape:[...r.shape,s]}});return n.disposeIntermediateTensorInfo(h),p}};function Fie(e){const{inputs:t,backend:n}=e,{x:a}=t;if("complex64"===a.dtype){const e=yre({inputs:{input:a},backend:n}),t=Fie({inputs:{x:e},backend:n}),r=Dre({inputs:{input:a},backend:n}),o=Fie({inputs:{x:r},backend:n}),s=Bne({inputs:{real:t,imag:o},backend:n});return n.disposeIntermediateTensorInfo(e),n.disposeIntermediateTensorInfo(t),n.disposeIntermediateTensorInfo(r),n.disposeIntermediateTensorInfo(o),s}return Yoe({attrs:{shape:a.shape,dtype:a.dtype,value:"string"===a.dtype?"":0},backend:n})}const Oie={kernelName:TK,backendName:"webgl",kernelFunc:Fie};const Die={kernelName:vj,backendName:"webgl",kernelFunc:function e(t){const{inputs:n,backend:a}=t,{x:r}=n;if("string"===r.dtype)throw new Error("onesLike is not supported under string dtype");if("complex64"===r.dtype){const t=yre({inputs:{input:r},backend:a}),n=e({inputs:{x:t},backend:a}),o=Dre({inputs:{input:r},backend:a}),s=Fie({inputs:{x:o},backend:a}),i=Bne({inputs:{real:n,imag:s},backend:a});return a.disposeIntermediateTensorInfo(t),a.disposeIntermediateTensorInfo(n),a.disposeIntermediateTensorInfo(o),a.disposeIntermediateTensorInfo(s),i}return Yoe({attrs:{shape:r.shape,dtype:r.dtype,value:1},backend:a})}};const Mie={kernelName:kj,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{axis:r}=a;if(1===t.length)return Woe({inputs:{input:t[0]},backend:n,attrs:{dim:r}});const o=t[0].shape,s=t[0].dtype;t.forEach((e=>{WU(o,e.shape,"All tensors passed to stack must have matching shapes"),BU(s===e.dtype,(()=>"All tensors passed to stack must have matching dtypes"))}));const i=[],c=t.map((e=>{const t=Woe({inputs:{input:e},backend:n,attrs:{dim:r}});return i.push(t),t})),l=Pre({inputs:c,backend:n,attrs:{axis:r}});return i.forEach((e=>n.disposeIntermediateTensorInfo(e))),l}};class Lie{constructor(e,t,n){this.variableNames=["x"],this.customUniforms=[{name:"value",type:"float"}],this.outputShape=t.map(((t,n)=>t[0]+e[n]+t[1]));const a=e.length,r=zee(a),o=t.map((e=>e[0])).join(","),s=t.map(((t,n)=>t[0]+e[n])).join(","),i=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,a);this.userCode=1!==a?"\n      ".concat(r," start = ").concat(r,"(").concat(o,");\n      ").concat(r," end = ").concat(r,"(").concat(s,");\n\n      void main() {\n        ").concat(r," outC = getOutputCoords();\n        if (any(lessThan(outC, start)) || any(greaterThanEqual(outC, end))) {\n          setOutput(value);\n        } else {\n          ").concat(r," coords = outC - start;\n          setOutput(getX(").concat(i,"));\n        }\n      }\n    "):"\n        int start = ".concat(o,";\n        int end = ").concat(s,";\n\n        void main() {\n          int outC = getOutputCoords();\n          if (outC < start || outC >= end) {\n            setOutput(value);\n          } else {\n            setOutput(getX(outC - start));\n          }\n        }\n      ")}}class Pie{constructor(e,t,n){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"value",type:"float"}],this.outputShape=t.map(((t,n)=>t[0]+e[n]+t[1]));const a=e.length,r=zee(a),o=t.map((e=>e[0])).join(","),s=t.map(((t,n)=>t[0]+e[n])).join(","),i=sne("rc",a),c=sne("source",a),l="".concat(i[a-1]," < ").concat(this.outputShape[a-1]),u=1===a?"source":"vec2(".concat(c.slice(-2).join(),")"),d=["".concat(r," rc = outputLoc;"),"".concat(i[a-1]," += 1;\n       if(").concat(l,") {\n      "),1===a?"":"}\n       rc = outputLoc;\n       ".concat(i[a-2]," += 1;\n       if(").concat(i[a-2]," < ").concat(this.outputShape[a-2],") {"),1===a?"":"  ".concat(i[a-1]," += 1;\n         if(").concat(l,") {")],h=1===a?"rc < start || rc >= end":"any(lessThan(rc, start)) || any(greaterThanEqual(rc, end))";let p="";for(let f=0,m=1===a?2:4;f<m;f++)p+="\n        ".concat(d[f],"\n        if (").concat(h,") {\n          result[").concat(f,"] = float(value);\n        } else {\n          ").concat(r," source = rc - start;\n          result[").concat(f,"] = getChannel(getX(").concat(c.join(),"), ").concat(u,");\n        }\n      ");p+=1===a?"} ":"}}",this.userCode="\n      const ".concat(r," start = ").concat(r,"(").concat(o,");\n      const ").concat(r," end = ").concat(r,"(").concat(s,");\n\n      void main() {\n        ").concat(r," outputLoc = getOutputCoords();\n        vec4 result = vec4(0.);\n        ").concat(p,"\n        setOutput(result);\n      }\n    ")}}const zie=e=>{const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{paddings:o,constantValue:s}=a;if(0===UU(r.shape)){const e=o.map(((e,t)=>e[0]+r.shape[t]+e[1]));return Yoe({backend:n,attrs:{shape:e,value:s,dtype:r.dtype}})}const i=yG().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new Pie(r.shape,o,s):new Lie(r.shape,o,s),c=[[s]];return n.runWebGLProgram(i,[r],r.dtype,c)},Bie={kernelName:Ij,backendName:"webgl",kernelFunc:zie},Wie=Yne({opSnippet:"\n  if(a < 0.0 && floor(b) < b){\n    return NAN;\n  }\n  if (b == 0.0) {\n    return 1.0;\n  }\n  return (round(mod(b, 2.0)) != 1) ?\n      pow(abs(a), b) : sign(a) * pow(abs(a), b);\n",packedOpSnippet:"\n  // isModRound1 has 1 for components with round(mod(b, 2.0)) == 1, 0 otherwise.\n  vec4 isModRound1 = vec4(equal(round(mod(b, 2.0)), ivec4(1)));\n  vec4 multiplier = sign(a) * isModRound1 + (vec4(1.0) - isModRound1);\n  vec4 result = multiplier * pow(abs(a), b);\n\n  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS\n  bvec4 isExpZero = equal(b, vec4(0.0));\n  result.r = isExpZero.r ? 1.0 : result.r;\n  result.g = isExpZero.g ? 1.0 : result.g;\n  result.b = isExpZero.b ? 1.0 : result.b;\n  result.a = isExpZero.a ? 1.0 : result.a;\n\n  bvec4 isNaN1 = lessThan(a, vec4(0.0));\n  bvec4 isNaN2 = lessThan(floor(b), b);\n  bvec4 isNaN = bvec4(isNaN1.x && isNaN2.x, isNaN1.y && isNaN2.y, isNaN1.z && isNaN2.z, isNaN1.w && isNaN2.w);\n  "+Mne+"\n  return result;\n"}),Vie={kernelName:Sj,backendName:"webgl",kernelFunc:Wie};const Uie={kernelName:Cj,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{axis:o,keepDims:s}=a,i=r.shape.length,c=[],l=YU(o,r.shape);let u=l;const d=sZ(u,i);let h,p=r;if(null!=d&&(p=pae({inputs:{x:r},backend:n,attrs:{perm:d}}),u=cZ(u.length,i),c.push(p)),oZ("prod",u,i),n.shouldExecuteOnCPU([p])){const e=n.texData.get(p.dataId).values,{outVals:t,outShape:a,outDtype:r}=Mte(p.shape,p.dtype,e,u);h=n.makeTensorInfo(a,r,t)}else{const[e,t]=aZ(p.shape,u),a=UU(t),o=aae({inputs:{x:p},backend:n,attrs:{shape:[-1,a]}}),s=iae(o,Mq(r.dtype),"prod",n);h=aae({inputs:{x:s},backend:n,attrs:{shape:e}}),c.push(o),c.push(s)}if(s){c.push(h);const e=rZ(h.shape,l);h=aae({inputs:{x:h},backend:n,attrs:{shape:e}})}return c.forEach((e=>n.disposeIntermediateTensorInfo(e))),h}};const Gie={kernelName:Tj,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{paramsNestedSplits:r,paramsDenseValues:o,indices:s}=t,{outputRaggedRank:i}=a,c=r.map((e=>n.readSync(e.dataId))),l=r.map((e=>e.shape)),u=n.readSync(o.dataId),d=n.readSync(s.dataId),[h,p,f]=Lte(c,l,u,o.shape,o.dtype,d,s.shape,i),m=h.map((e=>n.makeTensorInfo([e.length],"int32",e))),g=n.makeTensorInfo(f,o.dtype,p);return m.concat([g])}};const Hie={kernelName:Ej,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{starts:a,limits:r,deltas:o}=t,s=n.readSync(a.dataId),i=n.readSync(r.dataId),c=n.readSync(o.dataId),[l,u]=Pte(s,a.shape,a.dtype,i,r.shape,c,o.shape);return[n.makeTensorInfo([l.length],"int32",l),n.makeTensorInfo([u.length],a.dtype,u)]}};const jie={kernelName:Rj,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{shape:r,values:o,defaultValue:s,rowPartitionTensors:i}=t,{rowPartitionTypes:c}=a,l=n.readSync(r.dataId),u=n.readSync(o.dataId),d=n.readSync(s.dataId),h=i.map((e=>n.readSync(e.dataId))),p=i.map((e=>e.shape)),[f,m]=zte(l,r.shape,u,o.shape,o.dtype,d,s.shape,h,p,c);return n.makeTensorInfo(f,o.dtype,m)}},Kie=e=>{const{backend:t,attrs:n}=e,{start:a,stop:r,step:o,dtype:s}=n,i=Bte(a,r,o,s);return t.makeTensorInfo([i.length],s,i)},qie={kernelName:_j,backendName:"webgl",kernelFunc:Kie},Xie=Xne({opSnippet:"return 1.0 / x;"}),Yie={kernelName:Fj,backendName:"webgl",kernelFunc:Xie},Qie=Xne({opSnippet:fne+"\n  return (x < 0.0) ? 0.0 : x;\n",packedOpSnippet:"\n  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n"}),Jie={kernelName:Oj,backendName:"webgl",kernelFunc:Qie},Zie=Xne({opSnippet:fne+"\n  return (x < 0.0) ? 0.0 : min(6.0, x);\n",packedOpSnippet:"\n  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n"}),$ie={kernelName:Bj,backendName:"webgl",kernelFunc:Zie};class ece{constructor(e,t,n,a,r){this.variableNames=["A"],this.outputShape=[];const[o,s,i,c]=e;this.outputShape=[o,t,n,c];const l=[a&&t>1?s-1:s,a&&n>1?i-1:i],u=[a&&t>1?t-1:t,a&&n>1?n-1:n];let d;d=r?"(vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC - vec2(0.5)":"vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode="\n      const vec2 effectiveInputOverOutputRatioRC = vec2(\n          ".concat(l[0]/u[0],",\n          ").concat(l[1]/u[1],");\n      const vec2 inputShapeRC = vec2(").concat(s,".0, ").concat(i,".0);\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        ivec2 yRC = coords.yz;\n\n        // Fractional source index.\n        vec2 sourceFracIndexRC = ").concat(d,";\n\n        // Compute the four integer indices.\n        ivec2 sourceFloorRC = ivec2(max(sourceFracIndexRC, vec2(0.0)));\n        ivec2 sourceCeilRC = ivec2(\n          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));\n\n        float topLeft = getA(b, sourceFloorRC.x, sourceFloorRC.y, d);\n        float bottomLeft = getA(b, sourceCeilRC.x, sourceFloorRC.y, d);\n        float topRight = getA(b, sourceFloorRC.x, sourceCeilRC.y, d);\n        float bottomRight = getA(b, sourceCeilRC.x, sourceCeilRC.y, d);\n\n        vec2 fracRC = sourceFracIndexRC - vec2(sourceFloorRC);\n\n        float top = topLeft + (topRight - topLeft) * fracRC.y;\n        float bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;\n        float newValue = top + (bottom - top) * fracRC.x;\n\n        setOutput(newValue);\n      }\n    ")}}class tce{constructor(e,t,n,a,r){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];const[o,s,i,c]=e;this.outputShape=[o,t,n,c];const l=[a&&t>1?s-1:s,a&&n>1?i-1:i],u=[a&&t>1?t-1:t,a&&n>1?n-1:n];let d;d=r?"(vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC - vec3(0.5)":"vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode="\n      const vec3 effectiveInputOverOutputRatioRC = vec3(\n          ".concat(l[0]/u[0],",\n          ").concat(l[1]/u[1],",\n          ").concat(l[1]/u[1],");\n      const vec3 inputShapeRC = vec3(").concat(s,".0, ").concat(i,".0,\n                                     ").concat(i,".0);\n\n      float getAValue(int b, int r, int c, int d) {\n        return getChannel(getA(b, r, c, d), vec2(c, d));\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        // Calculate values for next column in yRC.z.\n        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);\n\n        // Fractional source index.\n        vec3 sourceFracIndexRC = ").concat(d,";\n\n        // Compute the four integer indices.\n        ivec3 sourceFloorRC = ivec3(max(sourceFracIndexRC, vec3(0.0)));\n        ivec3 sourceCeilRC = ivec3(\n          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));\n\n        // Should we calculate next column and row elements in 2x2 packed cell.\n        bool hasNextCol = d < ").concat(c-1,";\n        bool hasNextRow = coords.z < ").concat(n-1,";\n\n        // In parallel, construct four corners for all four components in\n        // packed 2x2 cell.\n        vec4 topLeft = vec4(\n          getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d),\n          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d + 1) : 0.0);\n\n        vec4 bottomLeft = vec4(\n          getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d),\n          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d + 1) : 0.0);\n\n        vec4 topRight = vec4(\n          getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d),\n          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d + 1) : 0.0);\n\n        vec4 bottomRight = vec4(\n          getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d),\n          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d + 1) : 0.0);\n\n        vec3 fracRC = sourceFracIndexRC - vec3(sourceFloorRC);\n\n        vec4 top = mix(topLeft, topRight, fracRC.yyzz);\n        vec4 bottom = mix(bottomLeft, bottomRight, fracRC.yyzz);\n        vec4 newValue = mix(top, bottom, fracRC.x);\n\n        setOutput(newValue);\n      }\n    ")}}const nce={kernelName:Pj,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{images:r}=t,{alignCorners:o,halfPixelCenters:s,size:i}=a,[c,l]=i,u=yG().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new tce(r.shape,c,l,o,s):new ece(r.shape,c,l,o,s);return n.runWebGLProgram(u,[r],"float32")}};class ace{constructor(e,t,n){this.variableNames=["dy"],this.outputShape=[],this.outputShape=t;const[,a,r]=t,[,o,s]=e,i=[n&&o>1?a-1:a,n&&s>1?r-1:r],c=[n&&o>1?o-1:o,n&&s>1?s-1:s],l=i[0]/c[0],u=i[1]/c[1],d=1/l,h=1/u,p=2*Math.ceil(d)+2,f=2*Math.ceil(h)+2;this.userCode="\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        int r = coords[1];\n        int c = coords[2];\n\n        float accumulator = 0.0;\n\n        const float heightScale = float(".concat(l,");\n        const float widthScale = float(").concat(u,");\n\n        const float invHeightScale = float(").concat(d,");\n        const float invWidthScale = float(").concat(h,");\n\n        const int winHeight = int(").concat(p,");\n        const int winWidth = int(").concat(f,");\n\n        // Compute bounds for where in dy we will look\n        float startRLerp = floor(float(r) * invHeightScale);\n        int startDyR = int(startRLerp - float(winHeight / 2));\n\n        float startCLerp = floor(float(c) * invWidthScale);\n        int startDyC = int(startCLerp - float(winWidth / 2));\n\n        // Loop over dy\n        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {\n          int dyR = dyROffset + startDyR;\n\n          // Guard against the window exceeding the bounds of dy\n          if (dyR < 0 || dyR >= ").concat(o,") {\n            continue;\n          }\n\n          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {\n            int dyC = dyCOffset + startDyC;\n\n            // Guard against the window exceeding the bounds of dy\n            if (dyC < 0 || dyC >= ").concat(s,") {\n              continue;\n            }\n\n            float dxR = float(dyR) * heightScale;\n            int topDxRIndex = int(floor(dxR));\n            int bottomDxRIndex = int(min(ceil(dxR), ").concat(a-1,".0));\n            float dxRLerp = dxR - float(topDxRIndex);\n            float inverseDxRLerp = 1.0 - dxRLerp;\n\n            float dxC = float(dyC) * widthScale;\n            int leftDxCIndex = int(floor(dxC));\n            int rightDxCIndex = int(min(ceil(dxC), ").concat(r-1,".0));\n            float dxCLerp = dxC - float(leftDxCIndex);\n            float inverseDxCLerp = 1.0 - dxCLerp;\n\n            if (r == topDxRIndex && c == leftDxCIndex) {\n              // topLeft\n              accumulator +=\n                getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;\n            }\n\n            if (r == topDxRIndex && c == rightDxCIndex) {\n              // topRight\n              accumulator += getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;\n            }\n\n            if (r == bottomDxRIndex && c == leftDxCIndex) {\n              // bottomLeft\n              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;\n            }\n\n            if (r == bottomDxRIndex && c == rightDxCIndex) {\n              // bottomRight\n              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;\n            }\n          }\n        }\n        // End loop over dy\n\n        setOutput(accumulator);\n      }\n    ")}}const rce={kernelName:zj,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{images:r,dy:o}=t,{alignCorners:s}=a,i=new ace(o.shape,r.shape,s);return n.runWebGLProgram(i,[o],o.dtype)}};class oce{constructor(e,t,n,a,r){this.variableNames=["A"],this.outputShape=[];const[o,s,i,c]=e;this.outputShape=[o,t,n,c];const l=[a&&t>1?s-1:s,a&&n>1?i-1:i],u=[a&&t>1?t-1:t,a&&n>1?n-1:n],d=a?"0.5":"0.0";let h;h=r?"max((vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC, vec2(0.0))":"vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode="\n      const vec2 effectiveInputOverOutputRatioRC = vec2(\n          ".concat(l[0]/u[0],",\n          ").concat(l[1]/u[1],");\n      const vec2 inputShapeRC = vec2(").concat(s,".0, ").concat(i,".0);\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        ivec2 yRC = coords.yz;\n\n        // Fractional source index.\n        vec2 sourceFracIndexRC = ").concat(h,";\n\n        // Compute the coordinators of nearest neighbor point.\n        ivec2 sourceNearestRC = ivec2(\n          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ").concat(d,")));\n        float newValue = getA(b, sourceNearestRC.x, sourceNearestRC.y, d);\n\n        setOutput(newValue);\n      }\n    ")}}class sce{constructor(e,t,n,a,r){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];const[o,s,i,c]=e;this.outputShape=[o,t,n,c];const l=[a&&t>1?s-1:s,a&&n>1?i-1:i],u=[a&&t>1?t-1:t,a&&n>1?n-1:n],d=a?"0.5":"0.0";let h;h=r?"max((vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC, vec3(0.0))":"vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode="\n      const vec3 effectiveInputOverOutputRatioRC = vec3(\n          ".concat(l[0]/u[0],",\n          ").concat(l[1]/u[1],",\n          ").concat(l[1]/u[1],");\n      const vec3 inputShapeRC = vec3(").concat(s,".0, ").concat(i,".0,\n                                     ").concat(i,".0);\n\n      float getAValue(int b, int r, int c, int d) {\n        return getChannel(getA(b, r, c, d), vec2(c, d));\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        // Calculate values for next column in yRC.z.\n        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);\n\n        // Fractional source index.\n        vec3 sourceFracIndexRC = ").concat(h,";\n\n        // Compute the coordinators of nearest neighbor point.\n        ivec3 sourceNearestRC = ivec3(\n          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ").concat(d,")));\n\n        // Should we calculate next column and row elements in 2x2 packed cell.\n        bool hasNextCol = d < ").concat(c-1,";\n        bool hasNextRow = coords.z < ").concat(n-1,";\n\n        vec4 newValue = vec4(\n          getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d),\n          hasNextCol ? getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d + 1) : 0.0);\n\n        setOutput(newValue);\n      }\n    ")}}const ice={kernelName:Mj,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{images:r}=t,{alignCorners:o,halfPixelCenters:s,size:i}=a,[c,l]=i,u=yG().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new sce(r.shape,c,l,o,s):new oce(r.shape,c,l,o,s);return n.runWebGLProgram(u,[r],r.dtype)}};class cce{constructor(e,t,n){this.variableNames=["dy"],this.outputShape=[],this.outputShape=t;const[,a,r]=t,[,o,s]=e,i=[n&&o>1?a-1:a,n&&s>1?r-1:r],c=[n&&o>1?o-1:o,n&&s>1?s-1:s],l=i[0]/c[0],u=i[1]/c[1],d=1/l,h=1/u,p=2*Math.ceil(d)+2,f=2*Math.ceil(h)+2;this.userCode="\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        int r = coords[1];\n        int c = coords[2];\n\n        float accumulator = 0.0;\n\n        const float heightScale = float(".concat(l,");\n        const float widthScale = float(").concat(u,");\n\n        const float invHeightScale = float(").concat(d,");\n        const float invWidthScale = float(").concat(h,");\n\n        const int winHeight = int(").concat(p,");\n        const int winWidth = int(").concat(f,");\n\n        // Compute bounds for where in dy we will look\n        float startRLerp = floor(float(r) * invHeightScale);\n        int startDyR = int(floor(startRLerp - float(winHeight / 2)));\n\n        float startCLerp = floor(float(c) * invWidthScale);\n        int startDyC = int(floor(startCLerp - float(winWidth / 2)));\n\n        // Loop over dy\n        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {\n          int dyR = dyROffset + startDyR;\n\n          // Guard against the window exceeding the bounds of dy\n          if (dyR < 0 || dyR >= ").concat(o,") {\n            continue;\n          }\n\n          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {\n            int dyC = dyCOffset + startDyC;\n\n            // Guard against the window exceeding the bounds of dy\n            if (dyC < 0 || dyC >= ").concat(s,") {\n              continue;\n            }\n\n            float sourceFracRow =\n              float(").concat(i[0],") *\n                (float(dyR) / float(").concat(c[0],"));\n\n            float sourceFracCol =\n                float(").concat(i[1],") *\n                  (float(dyC) / float(").concat(c[1],"));\n\n            int sourceNearestRow = int(min(\n                float(int(").concat(a,") - 1),\n                ").concat(n," ? float(round(sourceFracRow)) :\n                                  float(floor(sourceFracRow))));\n\n            int sourceNearestCol = int(min(\n                float(int(").concat(r,") - 1),\n                ").concat(n," ? float(round(sourceFracCol)) :\n                                  float(floor(sourceFracCol))));\n\n            if (r == sourceNearestRow && c == sourceNearestCol) {\n              accumulator += getDy(b, dyR, dyC, d);\n            }\n          }\n        }\n        // End loop over dy\n\n        setOutput(accumulator);\n      }\n    ")}}const lce={kernelName:Lj,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{images:r,dy:o}=t,{alignCorners:s}=a,i=new cce(o.shape,r.shape,s);return n.runWebGLProgram(i,[o],o.dtype)}};class uce{constructor(e,t){this.variableNames=["x"];const n=e.length;if(n>4)throw new Error("WebGL backend: Reverse of rank-".concat(n," tensor is not yet supported"));if(this.outputShape=e,1===n)return void(this.userCode="\n        void main() {\n          int coord = getOutputCoords();\n          setOutput(getX(".concat(e[0]," - coord - 1));\n        }\n      "));const a=e.map(((n,a)=>(n=>-1!==t.indexOf(n)&&1!==e[n]?"".concat(e[n]," - coords[").concat(n,"] - 1"):"coords[".concat(n,"]"))(a))).join(","),r=zee(n);this.userCode="\n      void main() {\n        ".concat(r," coords = getOutputCoords();\n        setOutput(getX(").concat(a,"));\n      }\n    ")}}class dce{constructor(e,t){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0;const n=e.length;if(n>4)throw new Error("WebGL backend: Reverse of rank-".concat(n," tensor is not yet supported"));this.outputShape=e;const a=sne("rc",n),r="".concat(a[n-1]," + 1 < ").concat(this.outputShape[n-1]),o="".concat(a[n-2]," + 1 < ").concat(this.outputShape[n-2]),s=zee(n);function i(n){const a=e.map(((a,r)=>function(n,a){return-1!==t.indexOf(n)&&1!==e[n]?"".concat(e[n]," - ").concat(a[n]," - 1"):"".concat(a[n])}(r,n))),r=a.join(","),o=a.slice(-2).join(",");return"getChannel(getX(".concat(r,"), vec2(").concat(o,"))")}this.userCode=1===n?"\n        void main(){\n          int rc = getOutputCoords();\n          vec4 result = vec4(0.);\n          result.r = getChannel(getX(".concat(e[0]," - rc - 1),\n            ").concat(e[0]," - rc - 1);\n          if(").concat(r,"){\n              result.g = getChannel(getX(").concat(e[0]," - (rc  + 1) - 1),\n                ").concat(e[0]," - (rc  + 1) - 1);\n          }\n          setOutput(result);\n        }\n      "):"\n        void main() {\n          ".concat(s," rc = getOutputCoords();\n          vec4 result = vec4(0.);\n          result.r = ").concat(function(e){return i(e)}(a.slice()),";\n          if(").concat(r,"){\n            result.g = ").concat(function(e){return e[n-1]="("+e[n-1]+" + 1)",i(e)}(a.slice()),";\n          }\n          if(").concat(o,") {\n            result.b = ").concat(function(e){return e[n-2]="("+e[n-2]+" + 1)",i(e)}(a.slice()),";\n            if(").concat(r,") {\n              result.a = ").concat(function(e){return e[n-1]="("+e[n-1]+" + 1)",e[n-2]="("+e[n-2]+" + 1)",i(e)}(a.slice()),";\n            }\n          }\n          setOutput(result);\n        }\n    ")}}const hce={kernelName:Wj,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{dims:o}=a,s=r.shape.length,i=YU(o,r.shape);if(0===s)return Pne({inputs:{x:r},backend:n});const c=yG().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new dce(r.shape,i):new uce(r.shape,i);return n.runWebGLProgram(c,[r],r.dtype)}};class pce{constructor(e,t){this.variableNames=["Image"],this.outputShape=[],this.customUniforms=[{name:"params",type:"vec4"}];const n=e[1],a=e[2];this.outputShape=e;let r="";r="number"===typeof t?"float outputValue = ".concat(t.toFixed(2),";"):"\n        vec3 fill = vec3(".concat(t.join(","),");\n        float outputValue = fill[coords[3]];"),this.userCode="\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int x = coords[2];\n          int y = coords[1];\n          float coordXFloat = (float(x) - params[0]) * params[3] -\n            (float(y) - params[1]) * params[2];\n          float coordYFloat = (float(x) - params[0]) * params[2] +\n            (float(y) - params[1]) * params[3];\n          int coordX = int(round(coordXFloat + params[0]));\n          int coordY = int(round(coordYFloat + params[1]));\n          ".concat(r,"\n          if(coordX >= 0 && coordX < ").concat(a," && coordY >= 0 && coordY < ").concat(n,") {\n            outputValue = getImage(coords[0], coordY, coordX, coords[3]);\n          }\n          setOutput(outputValue);\n        }\n    ")}}const fce={kernelName:_K,backendName:"webgl",kernelFunc:e=>{let{inputs:t,attrs:n,backend:a}=e;const{image:r}=t,{radians:o,fillValue:s,center:i}=n,c=a,l=new pce(r.shape,s),[u,d]=l2(i,r.shape[1],r.shape[2]),h=[[u,d,Math.sin(o),Math.cos(o)]];return c.runWebGLProgram(l,[r],r.dtype,h)}},mce=Xne({opSnippet:"\n  // OpenGL ES does not support round function.\n  // The algorithm is based on banker's rounding.\n  float base = floor(x);\n  if ((x - base) < 0.5) {\n    return floor(x);\n  } else if ((x - base) > 0.5) {\n    return ceil(x);\n  } else {\n    if (mod(base, 2.0) == 0.0) {\n      return base;\n    } else {\n      return base + 1.0;\n    }\n  }\n"}),gce={kernelName:Vj,backendName:"webgl",kernelFunc:mce},bce=Xne({opSnippet:"return inversesqrt(x);",cpuKernelImpl:Wte}),yce={kernelName:Uj,backendName:"webgl",kernelFunc:bce};class xce{constructor(e,t,n,a,r,o){let s=arguments.length>7&&void 0!==arguments[7]&&arguments[7];this.variableNames=["updates","indices","defaultValue"],this.outputShape=o;const i=zee(r.length),c=zee(o.length);let l="";1===n?l="i":2===n&&(l="i, j");const u="getIndices(".concat(l,")");let d="";1===a?d="i":2===a&&(d="i, coords[1]");const h="getUpdates(".concat(d,")");let p="";s&&(p="coords[0], coords[1]");const f="getDefaultValue(".concat(p,")"),m=t>1?"strides[j]":"strides";this.userCode="\n        ".concat(i," strides = ").concat(i,"(").concat(r,");\n\n        void main() {\n          ").concat(c," coords = getOutputCoords();\n          float sum = 0.0;\n          bool found = false;\n          for (int i = 0; i < ").concat(e,"; i++) {\n            int flattenedIndex = 0;\n            for (int j = 0; j < ").concat(t,"; j++) {\n              int index = round(").concat(u,");\n              flattenedIndex += index * ").concat(m,";\n            }\n            if (flattenedIndex == coords[0]) {\n              sum += ").concat(h,";\n              found = true;\n            }\n          }\n          setOutput(mix(").concat(f,", sum, float(found)));\n        }\n      ")}}class vce{constructor(e,t,n,a,r,o){let s=arguments.length>7&&void 0!==arguments[7]&&arguments[7];this.variableNames=["updates","indices","defaultValue"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=o;const i=zee(r.length),c=zee(o.length);let l="";1===n?l="i":2===n&&(l="i, j");const u="getIndices(".concat(l,")");let d="";1===a?d="i":2===a&&(d="i, coords[1]");const h="getUpdates(".concat(d,")");let p="";s&&(p="coords[0], coords[1]");const f="getDefaultValue(".concat(p,")"),m=t>1?"strides[j]":"strides",g=t>1?"strides[j + 1]":"strides";this.userCode="\n        ".concat(i," strides = ").concat(i,"(").concat(r,");\n\n        void main() {\n          ").concat(c," coords = getOutputCoords();\n          vec4 sum = vec4(0.);\n          vec4 found = vec4(0.);\n          for (int i = 0; i < ").concat(e,"; i+=2) {\n            ivec2 flattenedIndex = ivec2(0);\n            for (int j = 0; j < ").concat(t,"; j+=2) {\n              ivec4 index = round(").concat(u,");\n              flattenedIndex += index.xz * ").concat(m,";\n              if (j + 1 < ").concat(t,") {\n                flattenedIndex += index.yw * ").concat(g,";\n              }\n            }\n            if (flattenedIndex[0] == coords[0] || flattenedIndex[1] == coords[0] ||\n                flattenedIndex[0] == coords[0] + 1 || flattenedIndex[1] == coords[0] + 1) {\n              vec4 updVals = ").concat(h,";\n              if (flattenedIndex[0] == coords[0]) {\n                sum.xy += updVals.xy;\n                found.xy = vec2(1.);\n              } else if (flattenedIndex[0] == coords[0] + 1) {\n                sum.zw += updVals.xy;\n                found.zw = vec2(1.);\n              }\n              if (flattenedIndex[1] == coords[0]) {\n                sum.xy += updVals.zw;\n                found.xy = vec2(1.);\n              } else if (flattenedIndex[1] == coords[0] + 1) {\n                sum.zw += updVals.zw;\n                found.zw = vec2(1.);\n              }\n            }\n          }\n          setOutput(mix(").concat(f,", sum, found));\n        }\n      ")}}const wce={kernelName:Gj,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{indices:r,updates:o}=t,{shape:s}=a,{sliceRank:i,numUpdates:c,sliceSize:l,strides:u,outputSize:d}=y0(0,r,s),h=[d/l,l];if(0===d)return n.makeTensorInfo(s,r.dtype);const p=aae({inputs:{x:r},backend:n,attrs:{shape:[c,i]}}),f=aae({inputs:{x:o},backend:n,attrs:{shape:[c,l]}}),m=n.makeTensorInfo([],"float32",new Float32Array([0]));let g;g=yG().getBool("WEBGL_PACK")?new vce(c,i,p.shape.length,f.shape.length,u,h):new xce(c,i,p.shape.length,f.shape.length,u,h);const b=n.runWebGLProgram(g,[f,p,m],f.dtype),y=aae({inputs:{x:b},backend:n,attrs:{shape:s}});return n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(b),n.disposeIntermediateTensorInfo(m),y}};class kce{constructor(e,t,n,a){this.variableNames=["sortedSequence","values"],this.customUniforms=[{name:"numInputs",type:"int"}],this.outputShape=[e,n];const r="for (int i = 0; i < ".concat(Math.ceil(Math.log2(t+1)),"; ++i) { if (left >= right) break;"),o=2===yG().getNumber("WEBGL_VERSION")?"while (left < right) {":r,s="left"===a?"<":"<=";this.userCode="\n       int findBound(int batch, float value) {\n         int left = 0;\n         int right = numInputs;\n         int mid;\n         ".concat(o,"\n           mid = (left + right) / 2;\n           if (getSortedSequence(batch, mid) ").concat(s," value) {\n             left = mid + 1;\n           } else {\n             right = mid;\n           }\n         }\n         return right;\n       }\n\n       void main() {\n         ivec2 coords = getOutputCoords();\n         int batch = coords[0];\n         int valueIndex = coords[1];\n\n         float value = getValues(batch, valueIndex);\n\n         setOutput(float(findBound(batch, value)));\n       }\n     ")}}const Ice={kernelName:jj,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{sortedSequence:r,values:o}=t,{side:s}=a,i=new kce(r.shape[0],r.shape[1],o.shape[1],s),c=[[r.shape[1]]];return n.runWebGLProgram(i,[r,o],"int32",c)}};class Sce{constructor(e,t,n){let a,r;if(this.variableNames=["c","a","b"],this.outputShape=t,n>4)throw Error("Where for rank ".concat(n," is not yet supported"));if(1===n)r="resRC",a="resRC";else{const n=["resRC.x","resRC.y","resRC.z","resRC.w"],o=[],s=[];for(let a=0;a<t.length;a++)s.push("".concat(n[a])),a<e&&o.push("".concat(n[a]));a=o.join(),r=s.join()}const o=zee(n);this.userCode="\n      void main() {\n        ".concat(o," resRC = getOutputCoords();\n        float cVal = getC(").concat(a,");\n        if (cVal >= 1.0) {\n          setOutput(getA(").concat(r,"));\n        } else {\n          setOutput(getB(").concat(r,"));\n        }\n      }\n    ")}}const Nce={kernelName:Kj,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{condition:a,t:r,e:o}=t,s=new Sce(a.shape.length,r.shape,r.shape.length);return n.runWebGLProgram(s,[a,r,o],Dq(r.dtype,o.dtype))}},Cce=Xne({opSnippet:"\n  // Stable and Attracting Fixed Point (0, 1) for Normalized Weights.\n  // see: https://arxiv.org/abs/1706.02515\n  float scaleAlpha = ".concat(g2,";\n  float scale = ").concat(b2,";\n  return (x >= 0.0) ? scale * x : scaleAlpha * (exp(x) - 1.0);\n")}),Tce={kernelName:qj,backendName:"webgl",kernelFunc:Cce},Ece=Xne({opSnippet:qne+"\n  return 1.0 / (1.0 + exp(-1.0 * x));\n",packedOpSnippet:"\n  vec4 result = 1.0 / (1.0 + exp(-1.0 * x));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n",cpuKernelImpl:Ute}),Rce={kernelName:Zj,backendName:"webgl",kernelFunc:Ece},_ce=Xne({opSnippet:"\n  if (isnan(x)) { return 0.0; }\n  return sign(x);\n"}),Ace={kernelName:Jj,backendName:"webgl",kernelFunc:_ce},Fce=Xne({opSnippet:qne+"\n  return sin(x);\n",packedOpSnippet:"\n  vec4 result = sin(x);\n  bvec4 isNaN = isnan(x);\n  ".concat(Mne,"\n  return result;\n")}),Oce={kernelName:Yj,backendName:"webgl",kernelFunc:Fce},Dce=Xne({opSnippet:"\n  float e2x = exp(x);\n  return (e2x - 1.0 / e2x) / 2.0;\n"}),Mce={kernelName:Qj,backendName:"webgl",kernelFunc:Dce},Lce=Xne({opSnippet:"\n  float epsilon = 1.1920928955078125e-7;\n  float threshold = log(epsilon) + 2.0;\n\n  bool too_large = x > -threshold;\n  bool too_small = x < threshold;\n\n  float result;\n  float exp_x = exp(x);\n\n  if (too_large){\n    result = x;\n  }\n  else if (too_small){\n    result = exp_x;\n  }\n  else{\n    result = log(exp_x + 1.0);\n  }\n  return result;\n"}),Pce={kernelName:$j,backendName:"webgl",kernelFunc:Lce},zce={kernelName:nK,backendName:"webgl",kernelFunc:e=>{const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{blockShape:o,paddings:s}=a;BU(r.shape.length<=4,(()=>"spaceToBatchND for rank > 4 with a WebGL backend not implemented yet"));const i=o.reduce(((e,t)=>e*t)),c=[[0,0]];c.push(...s);for(let b=1+o.length;b<r.shape.length;++b)c.push([0,0]);const l=[],u=zie({inputs:{x:r},backend:n,attrs:{paddings:c,constantValue:0}}),d=u2(u.shape,o,i,!1),h=d2(d.length,o.length,!1),p=h2(u.shape,o,i,!1),f=aae({inputs:{x:u},backend:n,attrs:{shape:d}}),m=pae({inputs:{x:f},backend:n,attrs:{perm:h}}),g=aae({inputs:{x:m},backend:n,attrs:{shape:p}});return l.push(u),l.push(f),l.push(m),l.forEach((e=>n.disposeIntermediateTensorInfo(e))),g}};const Bce={kernelName:oK,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{indices:a,values:r,denseShape:o,defaultValue:s}=t;if(1!==o.shape.length)throw new Error("Dense shape must be a vector, saw:\n         ".concat(o.shape));if(2!==a.shape.length)throw new Error("Indices must be a matrix, saw:\n         ".concat(a.shape));if(1!==r.shape.length)throw new Error("Values must be a vector, saw:\n         ".concat(r.shape));if(0!==s.shape.length)throw new Error("Default value must be a scalar, saw:\n        ".concat(s.shape));const i=n.readSync(a.dataId),c=n.readSync(r.dataId),l=n.readSync(o.dataId),u=n.readSync(s.dataId)[0],[d,h,p,f,m]=jte(i,a.shape,a.dtype,c,r.dtype,l,u);return[n.makeTensorInfo(h,a.dtype,d),n.makeTensorInfo([h[0]],r.dtype,p),n.makeTensorInfo([f.length],"bool",new Uint8Array(f.map((e=>Number(e))))),n.makeTensorInfo([m.length],a.dtype,new Int32Array(m))]}};const Wce={kernelName:sK,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{inputIndices:a,inputShape:r,newShape:o}=t;if(2!==a.shape.length)throw new Error("Input indices should be a matrix but received shape ".concat(a.shape));if(1!==r.shape.length)throw new Error("Input shape should be a vector but received shape ".concat(r.shape));if(1!==o.shape.length)throw new Error("Target shape should be a vector but received shape ".concat(o.shape));const s=Array.from(n.readSync(r.dataId)),i=n.readSync(a.dataId),c=Array.from(n.readSync(o.dataId)),[l,u,d]=Kte(i,a.shape,a.dtype,s,c);return[n.makeTensorInfo(u,a.dtype,l),n.makeTensorInfo([d.length],o.dtype,new Int32Array(d))]}};const Vce={kernelName:iK,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{data:a,indices:r,segmentIds:o}=t;if(a.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==r.shape.length)throw new Error("Indices should be a vector but received shape\n              ".concat(r.shape));if(1!==o.shape.length)throw new Error("Segment ids should be a vector but received shape\n              ".concat(o.shape));const s=n.readSync(a.dataId),i=n.readSync(r.dataId),c=n.readSync(o.dataId),[l,u]=qte(s,a.shape,a.dtype,i,c,!0);return n.makeTensorInfo(u,a.dtype,l)}};const Uce={kernelName:cK,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{data:a,indices:r,segmentIds:o}=t;if(a.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==r.shape.length)throw new Error("Indices should be a vector but received shape\n             ".concat(r.shape));if(1!==o.shape.length)throw new Error("Segment ids should be a vector but received shape\n             ".concat(o.shape));const s=n.readSync(a.dataId),i=n.readSync(r.dataId),c=n.readSync(o.dataId),[l,u]=qte(s,a.shape,a.dtype,i,c);return n.makeTensorInfo(u,a.dtype,l)}};const Gce={kernelName:lK,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{sparseIndices:r,sparseValues:o,defaultValue:s}=t,{outputShape:i}=a,{sliceRank:c,numUpdates:l,sliceSize:u,strides:d,outputSize:h}=y0(0,r,i),p=!1;if("string"===o.dtype){const e=n.bufferSync(r),t=n.bufferSync(o),a=iq(n.readSync(s.dataId)[0]),f=Vte(e,t,i,h,u,l,c,d,a,p);return n.makeTensorInfo(i,f.dtype,f.values)}const f=new xce(l,c,r.shape.length,o.shape.length,d,[h,1],p),m=n.runWebGLProgram(f,[o,r,s],o.dtype),g=aae({inputs:{x:m},backend:n,attrs:{shape:i}});return n.disposeIntermediateTensorInfo(m),g}};const Hce={kernelName:aK,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{numOrSizeSplits:o,axis:s}=a,i=YU(s,r.shape)[0],c=U2(r,o,i),l=r.shape.length,u=new Array(l).fill(0),d=r.shape.slice();return c.map((e=>{const t=[...d];t[i]=e;const a=ure({inputs:{x:r},backend:n,attrs:{begin:u,size:t}});return u[i]+=e,a}))}},jce="return sqrt(x);",Kce=Xne({opSnippet:jce,packedOpSnippet:jce,cpuKernelImpl:Xte}),qce={kernelName:eK,backendName:"webgl",kernelFunc:Kce},Xce={kernelName:dK,backendName:"webgl",kernelFunc:Xne({opSnippet:"return x * x;"})},Yce="return (a - b) * (a - b);",Qce=Yne({opSnippet:Yce,packedOpSnippet:Yce}),Jce={kernelName:uK,backendName:"webgl",kernelFunc:Qce};const Zce={kernelName:hK,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t;if("string"!==r.dtype)throw new Error("Input must be of datatype string");const o=r3(n.readSync(r.dataId)),s=Yte(o,"string",a);return n.makeTensorInfo(r.shape,"string",s)}};const $ce={kernelName:EK,backendName:"webgl",kernelFunc:function(e){let{inputs:t,attrs:n,backend:a}=e;const{x:r}=t,o=fne+"\n    return x > 0.0 ? 1.0 : float(".concat(n.alpha,");\n  "),s=new pne(r.shape,o);return a.runWebGLProgram(s,[r],r.dtype)}};class ele{constructor(e,t,n){this.variableNames=["x"],this.outputShape=n;const a=n.length,r=zee(n.length),o=zee(n.length);let s="";if(1===a)s="coords * strides + begin";else{let e=0;s=n.map(((t,a)=>(e++,1===n.length?"coords * strides[".concat(a,"] + begin[").concat(a,"]"):"coords[".concat(e-1,"] * strides[").concat(a,"] + begin[").concat(a,"]")))).join(",")}this.userCode="\n      ".concat(r," begin = ").concat(r,"(").concat(e,");\n      ").concat(r," strides = ").concat(r,"(").concat(t,");\n\n      void main() {\n        ").concat(o," coords = getOutputCoords();\n        setOutput(getX(").concat(s,"));\n      }\n    ")}}const tle={kernelName:pK,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{begin:o,end:s,strides:i,beginMask:c,endMask:l,ellipsisMask:u,newAxisMask:d,shrinkAxisMask:h}=a,{finalShapeSparse:p,finalShape:f,isIdentity:m,sliceDim0:g,isSimpleSlice:b,begin:y,end:x,strides:v}=FQ(r.shape,o,s,i,c,l,u,d,h);let w;if(m)w=aae({inputs:{x:r},backend:n,attrs:{shape:f}});else if(g||b){BU(r.shape.length>=1,(()=>"Input must have rank at least 1, got: ".concat(r.shape.length)));const e=xQ(y,x,v),t=ure({inputs:{x:r},backend:n,attrs:{begin:y,size:e}});w=aae({inputs:{x:t},backend:n,attrs:{shape:f}}),n.disposeIntermediateTensorInfo(t)}else{if(n.shouldExecuteOnCPU([r])){const e=n.readSync(r.dataId),t=gY(r.shape,r.dtype,e),a=Qte(p,t,v,y);w=n.makeTensorInfo(f,r.dtype,a.values)}else{const e=new ele(y,v,p);w=n.runWebGLProgram(e,[r],r.dtype)}}const k=aae({inputs:{x:w},backend:n,attrs:{shape:f}});return n.disposeIntermediateTensorInfo(w),k}};const nle={kernelName:fK,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{separator:r,nGramWidths:o,leftPad:s,rightPad:i,padWidth:c,preserveShortSequences:l}=a,{data:u,dataSplits:d}=t,h=n.readSync(u.dataId),p=n.readSync(d.dataId),[f,m]=Jte(h,p,r,o,s,i,c,l);return[n.makeTensorInfo([f.length],"string",f),n.makeTensorInfo(d.shape,"int32",m)]}};const ale={kernelName:mK,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{skipEmpty:r}=a,{input:o,delimiter:s}=t;if("string"!==o.dtype)throw new Error("Input must be of datatype string");if(1!==o.shape.length)throw new Error("Input must be a vector, got shape: ".concat(o.shape));if(0!==s.shape.length)throw new Error("Delimiter must be a scalar, got shape: ".concat(s.shape));const i=n.readSync(o.dataId),c=n.readSync(s.dataId)[0],[l,u,d]=Zte(i,c,r),h=u.length;return[n.makeTensorInfo([h,2],"int32",l),n.makeTensorInfo([h],"string",u),n.makeTensorInfo([2],"int32",new Int32Array(d))]}};const rle={kernelName:gK,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{numBuckets:r}=a,{input:o}=t;if("string"!==o.dtype)throw new Error("Input must be of datatype string");if(r<=0)throw new Error("Number of buckets must be at least 1");const s=n.readSync(o.dataId),i=$te(s,r);return n.makeTensorInfo(o.shape,"int32",i)}},ole=Xne({opSnippet:"return tan(x);"}),sle={kernelName:yK,backendName:"webgl",kernelFunc:ole},ile=Xne({opSnippet:"\n  float e2x = exp(-2.0 * abs(x));\n  return sign(x) * (1.0 - e2x) / (1.0 + e2x);\n"}),cle={kernelName:xK,backendName:"webgl",kernelFunc:ile};const lle={kernelName:Hj,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{tensor:r,indices:o,updates:s}=t,{}=a,{sliceRank:i,numUpdates:c,sliceSize:l,strides:u,outputSize:d}=y0(0,o,r.shape),h=[d/l,l];if(0===d)return n.makeTensorInfo(r.shape,o.dtype);const p=aae({inputs:{x:o},backend:n,attrs:{shape:[c,i]}}),f=aae({inputs:{x:s},backend:n,attrs:{shape:[c,l]}}),m=aae({inputs:{x:r},backend:n,attrs:{shape:h}}),g=new xce(c,i,p.shape.length,f.shape.length,u,h,!1,!0),b=n.runWebGLProgram(g,[f,p,m],m.dtype),y=aae({inputs:{x:b},backend:n,attrs:{shape:r.shape}});return n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),n.disposeIntermediateTensorInfo(b),y}};class ule{constructor(e,t){this.variableNames=["A"];const n=new Array(e.length);for(let o=0;o<n.length;o++)n[o]=e[o]*t[o];this.outputShape=n,this.rank=n.length;const a=zee(this.rank),r=function(e){const t=e.length;if(t>5)throw Error("Tile for rank ".concat(t," is not yet supported"));if(1===t)return"imod(resRC, ".concat(e[0],")");const n=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u"],a=[];for(let r=0;r<e.length;r++)a.push("imod(".concat(n[r],", ").concat(e[r],")"));return a.join()}(e);this.userCode="\n      void main() {\n        ".concat(a," resRC = getOutputCoords();\n        setOutput(getA(").concat(r,"));\n      }\n    ")}}function dle(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{reps:o}=a;if("string"===r.dtype||r.shape.length>5){const e=n.readSync(r.dataId),t="string"===r.dtype?e.map((e=>iq(e))):e,a=gY(r.shape,r.dtype,t),s=tne(a,o);return n.makeTensorInfo(s.shape,s.dtype,s.values)}const s=new ule(r.shape,o);return n.runWebGLProgram(s,[r],r.dtype)}const hle={kernelName:vK,backendName:"webgl",kernelFunc:dle};class ple{constructor(e){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"negativeInf",type:"float"},{name:"dir",type:"int"},{name:"inc",type:"int"}],this.outputShape=e,this.userCode="\n       void main() {\n         ivec2 coords = getOutputCoords();\n         int batch = coords[0];\n         int elemIdx = coords[1];\n\n         // We compare elements pair-wise within a group of size 2 * inc.\n         // The comparing rule for each group alternates between ascending\n         // and descending. Within each group, we compare each pair at\n         // positions i and i+inc. To decide whether an element at position i\n         // is x0 or x1, we mod it by 2 * inc, if the result is smaller than\n         // inc, it is in the first half of the group, we denote it as x0,\n         // otherwise we denote it as x1.\n         // For example, as shown in the Bitonic top K paper referenced above,\n         // Figure5(a) shows that element[1] is in the\n         // second half of the group when group size is 2, but it is in the\n         // first half of the group when group size is 4.\n\n         bool isFirstInPair = imod(elemIdx, 2 * inc) < inc;\n         int i = isFirstInPair ? elemIdx : elemIdx - inc;\n\n         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));\n         int i1 = firstPass == 1 ? i + inc : int(getIndices(batch, i + inc));\n         float x0 = i0 < n ? getX(batch, i0) : negativeInf;\n         float x1 = i1 < n ? getX(batch, i1) : negativeInf;\n\n         // Denotes which direction indices are in (ascending or descending).\n         bool reverse = imod(elemIdx, 2 * dir) >= dir;\n         bool isGreater = x0 > x1 || (x0 == x1 && i1 > i0);\n         if (reverse == isGreater) { // Elements in opposite order of direction\n           int iTemp = i0;\n           i0 = i1;\n           i1 = iTemp;\n         }\n         if (isFirstInPair) {\n            setOutput(float(i0));\n         } else {\n            setOutput(float(i1));\n         }\n       }\n     "}}class fle{constructor(e){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"k",type:"int"}],this.outputShape=e,this.userCode="\n    void main() {\n         // Takes max of indices (0, k), (1, k + 1), (2, k + 2) ...\n         ivec2 coords = getOutputCoords();\n         int batch = coords[0];\n         int elemIdx = coords[1];\n\n         // The output size is half of the previous size.\n         // If the previous sequence is | | | | _ _ _ _  | | | |  _ _ _ _ (k=4),\n         // we only need to output the indices at positions |, the indices at\n         // positions _ can be thrown away, see Figure5(b) After Phase 2\n         // (Merge phase) in the Bitonic Top K paper referenced above.\n         // For example, the paper shows we only need to output the orange bars.\n         // The output sequence should look like this | | | | | | | |.\n         // Because the sequence is halved, to map the output index back\n         // to the previous sequence to find the corresponding value,\n         // we need to double the index. When we double the index,\n         // we basically interpolate a position, so 2i looks like\n         // | _ | _ | _ | _ | _ | _ | _. We move the | to the first k position\n         // of each 2k positions by - elemIdx % k. E.g. for output at\n         // index 4,5,6,7, we want to get the corresponding element at\n         // original index 8,9,10,11, for output at index 8,9,10,11,\n         // we want to get the corresponding element at original index\n         // 16,17,18,19, so on and so forth.\n\n         int i = elemIdx < k ? elemIdx : (elemIdx * 2 - imod(elemIdx, k));\n         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));\n         int i1 = firstPass == 1 ? i + k : int(getIndices(batch, i + k));\n\n         float x0 = getX(batch, i0);\n         float x1 = i1 < n ? getX(batch, i1) : x0;\n\n         setOutput(x0 >= x1 ? float(i0) : float(i1));\n       }\n     "}}function mle(e,t){null!==t&&e.disposeIntermediateTensorInfo(t)}function gle(e){let t=1;for(;t<e;)t*=2;return t}const ble={kernelName:wK,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{k:o,sorted:s}=a,i=yG().getNumber("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD"),c=yG().getNumber("TOPK_K_CPU_HANDOFF_THRESHOLD"),l=r.shape,u=l[l.length-1];if(n.shouldExecuteOnCPU([r])||u<i||o>c){const e=n.readSync(r.dataId),[t,a]=nne(e,l,r.dtype,o,s);return[n.makeTensorInfo(t.shape,t.dtype,t.values),n.makeTensorInfo(a.shape,a.dtype,a.values)]}if(0===o)return l[l.length-1]=0,[n.makeTensorInfo(l,r.dtype,[]),n.makeTensorInfo(l,"int32",[])];if(1===u)return[r,Yoe({attrs:{shape:l,dtype:"int32",value:0},backend:n})];const d=n.texData.get(r.dataId),h=null!==d&&d.isPacked,p=h?n.unpackTensor(r):r,f=UU(l)/u,m=aae({inputs:{x:p},attrs:{shape:[f,u]},backend:n});h&&mle(n,p);const g=gle(o),b=gle(u);let y=null;const x=()=>null===y?[m,m]:[m,y],v=(e,t,a)=>{const r=x(),o=new ple(a),s=[[u],[null===y?1:0],[Number.NEGATIVE_INFINITY],[e],[t]],i=y;y=n.runWebGLProgram(o,r,"int32",s),mle(n,i)};for(let N=1;N<g;N*=2){const e=2*N;for(let t=N;t>=1;t/=2)v(e,t,[f,b])}for(let N=b;N>g;N/=2){const e=x(),t=new fle([f,N/2]),a=[[u],[null===y?1:0],[g]],r=y;y=n.runWebGLProgram(t,e,"int32",a),mle(n,r);const o=g/2,s=2*o;for(let n=o;n>=1;n/=2)v(s,n,y.shape)}let w=y;y=ure({inputs:{x:y},backend:n,attrs:{begin:0,size:[f,o]}}),mle(n,w);let k=fse({inputs:{x:m,indices:y},backend:n,attrs:{axis:1,batchDims:1}});mle(n,m);const I=l.slice(0,-1);I.push(o),w=y,y=aae({inputs:{x:y},attrs:{shape:I},backend:n}),mle(n,w);const S=k;return k=aae({inputs:{x:k},attrs:{shape:I},backend:n}),mle(n,S),[k,y]}};class yle{constructor(e,t,n,a,r,o){this.variableNames=["Image","Transforms"],this.outputShape=o;const s="nearest"===n?1:2;let i;switch(a){case"constant":default:i=1;break;case"reflect":i=2;break;case"wrap":i=3;break;case"nearest":i=4}this.userCode="\n            float mapCoord(float outCoord, float len) {\n              float inCoord = outCoord;\n              if(".concat(i," == 2) {\n                if (inCoord < 0.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz2 = 2.0 * len;\n                    if (inCoord < sz2) {\n                      inCoord = sz2 * float(int(float(-inCoord / sz2))) +\n                      inCoord;\n                    }\n                    inCoord = inCoord < -len ? inCoord + sz2 : -inCoord - 1.0;\n                  }\n                } else if (inCoord > len - 1.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz2 = 2.0 * len;\n                    inCoord -= sz2 * float(int(float(inCoord / sz2)));\n                    if (inCoord >= len) {\n                      inCoord = sz2 - inCoord - 1.0;\n                    }\n                  }\n                }\n                return clamp(inCoord, 0.0, len - 1.0);\n              } else if (").concat(i," == 3) {\n                if (inCoord < 0.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz = len - 1.0;\n                    inCoord += len * (float(int(float(-inCoord / sz))) + 1.0);\n                  }\n                } else if (inCoord > len - 1.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz = len - 1.0;\n                    inCoord -= len * float(int(float(inCoord / sz)));\n                  }\n                }\n                return clamp(inCoord, 0.0, len - 1.0);\n              } else if (").concat(i," == 4) {\n                return clamp(outCoord, 0.0, len - 1.0);\n              } else {\n                return outCoord;\n              }\n            }\n\n            float readWithFillValue(int batch, int coordY, int coordX,\n              int channel) {\n              float outputValue;\n              if (0 <= coordY && coordY < ").concat(e," && 0 <= coordX && coordX < ").concat(t,") {\n                  outputValue = getImage(batch, coordY, coordX, channel);\n              } else {\n                outputValue = float(").concat(r,");\n              }\n              return outputValue;\n            }\n\n            void main() {\n              ivec4 coords = getOutputCoords();\n              float outputValue;\n              int batch = coords[0];\n              int x = coords[2];\n              int y = coords[1];\n              int channel = coords[3];\n              float xf = float(x);\n              float yf = float(y);\n              float a1 = getTransforms(batch, 0);\n              float a2 = getTransforms(batch, 1);\n              float a3 = getTransforms(batch, 2);\n              float b1 = getTransforms(batch, 3);\n              float b2 = getTransforms(batch, 4);\n              float b3 = getTransforms(batch, 5);\n              float c1 = getTransforms(batch, 6);\n              float c2 = getTransforms(batch, 7);\n              float projection = c1 * xf + c2 * yf + 1.0;\n              if (projection == 0.0) {\n                outputValue = float(").concat(r,");\n              } else {\n                float inX = (a1 * xf + a2 * yf + a3) / projection;\n                float inY = (b1 * xf + b2 * yf + b3) / projection;\n                float mapX = mapCoord(inX, float(").concat(t,"));\n                float mapY = mapCoord(inY, float(").concat(e,"));\n\n                if (").concat(s," == 1) {\n                  int coordY = int(round(mapY));\n                  int coordX = int(round(mapX));\n                  outputValue = readWithFillValue(batch, coordY, coordX,\n                    channel);\n                } else {\n                  float yFloor = floor(mapY);\n                  float xFloor = floor(mapX);\n                  float yCeil = yFloor + 1.0;\n                  float xCeil = xFloor + 1.0;\n                  float valueYFloor = (xCeil - mapX) *\n                  readWithFillValue(batch, int(yFloor), int(xFloor), channel) +\n                  (mapX - xFloor) *\n                  readWithFillValue(batch, int(yFloor), int(xCeil), channel);\n                  float valueYCeil = (xCeil - mapX) *\n                  readWithFillValue(batch, int(yCeil), int(xFloor), channel) +\n                  (mapX - xFloor) *\n                  readWithFillValue(batch, int(yCeil), int(xCeil), channel);\n                  outputValue = (yCeil - mapY) * valueYFloor +\n                  (mapY - yFloor) * valueYCeil;\n                }\n              }\n              setOutput(outputValue);\n            }\n        ")}}const xle={kernelName:kK,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{image:r,transforms:o}=t,{interpolation:s,fillMode:i,fillValue:c,outputShape:l}=a,[u,d,h,p]=r.shape,[f,m]=null!=l?l:[d,h],g=new yle(d,h,s,i,c,[u,f,m,p]);return n.runWebGLProgram(g,[r,o],"float32")}};const vle={kernelName:SK,backendName:"webgl",kernelFunc:function(e){const{inputs:t,attrs:n,backend:a}=e,{axis:r}=n,{x:o}=t;vee(o,"unique"),console.warn("WARNING: ","UI might be locked temporarily as data is being downloaded");const s=a.readSync(o.dataId),{outputValues:i,outputShape:c,indices:l}=rne(s,r,o.shape,o.dtype);return[a.makeTensorInfo(c,o.dtype,i),a.makeTensorInfo([l.length],"int32",l)]}};const wle={kernelName:NK,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{value:r}=t;let{axis:o}=a;o<0&&(o+=r.shape.length);const s=r,i=s.shape.length,c=r.shape[o],l=new Array(i-1);let u=0;for(let m=0;m<i;m++)m!==o&&(l[u++]=s.shape[m]);const d=[],h=new Array(i).fill(0),p=s.shape.slice();p[o]=1;const f=new Array(c);for(let m=0;m<f.length;m++){h[o]=m;const e=ure({inputs:{x:s},backend:n,attrs:{begin:h,size:p}}),t=aae({inputs:{x:e},backend:n,attrs:{shape:l}});f[m]=t,d.push(e)}return d.forEach((e=>n.disposeIntermediateTensorInfo(e))),f}};class kle{constructor(e,t){this.variableNames=["x","segmentIds"];const n=e.windowSize,a=e.batchSize,r=e.inSize,o=e.numSegments,s=o*Math.ceil(r/n);this.outputShape=[a,s];const i=4*Math.floor(n/4),c=n%4,l="\n        sumValue += dot(values, segFilter);\n    ";let u="";r%n>0&&(u="\n        if (inIdx < 0 || inIdx >= ".concat(r,") {\n          return initializationValue;\n        }\n      "));let d="";r%n>0&&(d="\n        if (inIdx < 0 || inIdx >= ".concat(r,") {\n          return -1.0;\n        }\n      ")),this.userCode="\n      const float initializationValue = ".concat("0.0",";\n\n      float getValue(int batch, int inIdx) {\n        ").concat(u,"\n        return getX(batch, inIdx);\n      }\n\n      float getSegmentIdAtIndex(int inIdx) {\n        ").concat(d,"\n        return getSegmentIds(inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = int(floor(float(outIdx) / float(\n          ").concat(o,")) * float(").concat(n,"));\n        int currentSeg = int(mod(float(outIdx), float(").concat(o,")));\n\n        float sumValue = 0.0;\n\n        for (int i = 0; i < ").concat(i,"; i += 4) {\n          int inIdx = inOffset + i;\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 3)) == currentSeg ? 1 : 0\n          );\n\n          ").concat(l,"\n        }\n\n        int inIdx = inOffset + ").concat(i,";\n        if (").concat(1===c,") {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            initializationValue,\n            initializationValue,\n            initializationValue\n          );\n\n          int inIdxSeg = int(getSegmentIdAtIndex(inIdx));\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            0,\n            0,\n            0\n          );\n\n          ").concat(l,"\n        } else if (").concat(2===c,") {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            initializationValue,\n            initializationValue\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n              0,\n              0\n          );\n\n          ").concat(l,"\n        } else if (").concat(3===c,") {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            initializationValue\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,\n            0\n          );\n\n          ").concat(l,"\n        }\n        setOutput(").concat("sumValue",");\n      }\n    ")}}const Ile={kernelName:CK,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r,segmentIds:o}=t,{numSegments:s}=a,i=r.shape.length,c=[];let l=0;const u=sZ([l],i);let d=r;null!=u&&(d=pae({inputs:{x:r},backend:n,attrs:{perm:u}}),c.push(d),l=cZ(1,i)[0]);const h=n3(d.shape,l,s),p=UU([d.shape[l]]),f=aae({inputs:{x:d},backend:n,attrs:{shape:[-1,p]}});c.push(f);const m=Mq(r.dtype),g=(e,t,a,r,o)=>{const s=e.shape[0],i=e.shape[1],l=t3(i,o),u=new kle({windowSize:l,inSize:i,batchSize:s,numSegments:o},t),d=n.compileAndRun(u,[e,a],r);if(c.push(d),d.shape[1]===o)return d;const h=Kie({backend:n,attrs:{start:0,stop:o,step:1,dtype:"float32"}}),p=dle({inputs:{x:h},backend:n,attrs:{reps:[i/l]}});c.push(h),c.push(p);return g(d,t,p,r,o)},b=aae({inputs:{x:g(f,"unsortedSegmentSum",o,m,s)},backend:n,attrs:{shape:h}});let y=b;if(null!=u){c.push(b);const e=iZ(u);y=pae({inputs:{x:y},backend:n,attrs:{perm:e}})}return c.forEach((e=>n.disposeIntermediateTensorInfo(e))),y}},Sle=[bae,xae,wae,Iae,Cae,Rae,_ae,Aae,Pae,zae,Wae,Uae,Hae,Kae,Xae,Jae,Zae,tre,nre,are,sre,hre,pre,fre,mre,wre,Sre,Tre,Wne,_re,zre,Kre,Jre,$re,eoe,toe,noe,roe,soe,coe,foe,moe,goe,yoe,woe,Soe,Noe,Toe,Roe,_oe,Foe,Ooe,Moe,Poe,Boe,Voe,Hoe,qoe,Qoe,Zoe,tse,ase,sse,lse,use,hse,mse,bse,xse,zne,vse,Mre,kse,Sse,Cse,Gne,Ese,_se,Ase,Ose,Mse,Pse,Bse,Vse,Hse,Kse,Xse,Qse,Jse,Zse,tie,nie,aie,rie,oie,iie,uie,hie,wie,nae,Iie,Nie,Tie,Rie,bre,Aie,Die,Mie,Bie,Vie,Kne,Uie,Gie,Hie,jie,qie,xre,mie,Yie,Jie,$ie,rae,nce,rce,ice,lce,hce,fce,gce,yce,wce,Ice,Nce,Tce,Rce,Ace,Oce,Mce,dre,vie,Pce,zce,Bce,Wce,Vce,Uce,Gce,Hce,qce,Xce,Jce,Zce,$ce,tle,nle,ale,rle,yie,hae,sle,cle,lle,hle,ble,xle,fae,vle,wle,Ile,Oie];for(const n of Sle)VK(n);var Nle,Cle;yG().registerFlag("KEEP_INTERMEDIATE_TENSORS",(()=>!1),(e=>{e&&console.warn("Keep intermediate tensors is ON. This will print the values of all intermediate tensors during model inference. Not all models support this mode. For details, check e2e/benchmarks/ model_config.js. This significantly impacts performance.")})),function(e){e[e.DT_INVALID=0]="DT_INVALID",e[e.DT_FLOAT=1]="DT_FLOAT",e[e.DT_DOUBLE=2]="DT_DOUBLE",e[e.DT_INT32=3]="DT_INT32",e[e.DT_UINT8=4]="DT_UINT8",e[e.DT_INT16=5]="DT_INT16",e[e.DT_INT8=6]="DT_INT8",e[e.DT_STRING=7]="DT_STRING",e[e.DT_COMPLEX64=8]="DT_COMPLEX64",e[e.DT_INT64=9]="DT_INT64",e[e.DT_BOOL=10]="DT_BOOL",e[e.DT_QINT8=11]="DT_QINT8",e[e.DT_QUINT8=12]="DT_QUINT8",e[e.DT_QINT32=13]="DT_QINT32",e[e.DT_BFLOAT16=14]="DT_BFLOAT16",e[e.DT_QINT16=15]="DT_QINT16",e[e.DT_QUINT16=16]="DT_QUINT16",e[e.DT_UINT16=17]="DT_UINT16",e[e.DT_COMPLEX128=18]="DT_COMPLEX128",e[e.DT_HALF=19]="DT_HALF",e[e.DT_RESOURCE=20]="DT_RESOURCE",e[e.DT_VARIANT=21]="DT_VARIANT",e[e.DT_UINT32=22]="DT_UINT32",e[e.DT_UINT64=23]="DT_UINT64",e[e.DT_FLOAT_REF=101]="DT_FLOAT_REF",e[e.DT_DOUBLE_REF=102]="DT_DOUBLE_REF",e[e.DT_INT32_REF=103]="DT_INT32_REF",e[e.DT_UINT8_REF=104]="DT_UINT8_REF",e[e.DT_INT16_REF=105]="DT_INT16_REF",e[e.DT_INT8_REF=106]="DT_INT8_REF",e[e.DT_STRING_REF=107]="DT_STRING_REF",e[e.DT_COMPLEX64_REF=108]="DT_COMPLEX64_REF",e[e.DT_INT64_REF=109]="DT_INT64_REF",e[e.DT_BOOL_REF=110]="DT_BOOL_REF",e[e.DT_QINT8_REF=111]="DT_QINT8_REF",e[e.DT_QUINT8_REF=112]="DT_QUINT8_REF",e[e.DT_QINT32_REF=113]="DT_QINT32_REF",e[e.DT_BFLOAT16_REF=114]="DT_BFLOAT16_REF",e[e.DT_QINT16_REF=115]="DT_QINT16_REF",e[e.DT_QUINT16_REF=116]="DT_QUINT16_REF",e[e.DT_UINT16_REF=117]="DT_UINT16_REF",e[e.DT_COMPLEX128_REF=118]="DT_COMPLEX128_REF",e[e.DT_HALF_REF=119]="DT_HALF_REF",e[e.DT_RESOURCE_REF=120]="DT_RESOURCE_REF",e[e.DT_VARIANT_REF=121]="DT_VARIANT_REF",e[e.DT_UINT32_REF=122]="DT_UINT32_REF",e[e.DT_UINT64_REF=123]="DT_UINT64_REF"}(Nle||(Nle={})),function(e){let t;!function(e){e[e.LEGACY=0]="LEGACY",e[e.V1=1]="V1",e[e.V2=2]="V2"}(t=e.CheckpointFormatVersion||(e.CheckpointFormatVersion={}))}(Cle||(Cle={}));const Tle={};function Ele(e){return Tle[e]}function Rle(e,t,n,a,r){const o=t.inputParams[e];if(o&&void 0!==o.inputIndexStart){const e=o.inputIndexStart,s=0===o.inputIndexEnd?void 0:void 0===o.inputIndexEnd?e+1:o.inputIndexEnd,i=e<0?t.inputNames.length+e:e;if("tensor"===o.type)return _le(t.inputNames[i],n,a,r);if("tensors"===o.type){const o=t.inputs.slice(e,s);return t.inputNames.slice(e,s).filter(((e,t)=>{var n;return"NoOp"!==(null===(n=o[t])||void 0===n?void 0:n.op)})).map((e=>_le(e,n,a,r)))}const c=_le(t.inputNames[i],n,a,r),l=c.dataSync();return"number"===o.type?l[0]:iG(c.shape,l)}const s=t.attrParams[e];return s&&s.value}function _le(e,t,n,a){const[r,o]=Dle(e,n);if(null!=a){const e=a.getHashTableHandleByName(r);if(null!=e)return e}const s=n.currentContextIds.find((e=>!!t[Ole(r,e)]));return void 0!==s?t[Ole(r,s)][o]:void 0}function Ale(e,t,n){return t[Ole(e,n.currentContextId)]}function Fle(e,t){const[n,a,r]=Dle(e,t);return[Ole(n,t&&t.currentContextId),a,r]}function Ole(e,t){return t?"".concat(e,"-").concat(t):e}function Dle(e,t){if(""===e)return["",0,void 0];const n=null!=t&&null!=t.parseNodeNameCache;if(n){const n=t.parseNodeNameCache.get(e);if(null!=n)return n}const a=e.split(":");let r;if(1===a.length)r=[e,0,void 0];else{const e=a[0],t=3===a.length?a[1]:void 0;r=[e,Number(a[a.length-1]),t]}return n&&t.parseNodeNameCache.set(e,r),r}function Mle(e,t,n){let a=Rle("pad",e,t,n);if("explicit"===a){a=Rle("explicitPaddings",e,t,n);const r=[[0,0],[0,0],[0,0],[0,0]];for(let e=0;e<4;e++)r[e][0]=a[2*e],r[e][1]=a[2*e+1];return r}return a}function Lle(e){return e.kept?e:yY(e)}const Ple=[{tfOpName:"Add",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddV2",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddN",category:"arithmetic",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"BiasAdd",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"Sub",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"RealDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Div",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"DivNoNan",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mul",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Maximum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Minimum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Pow",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SquaredDifference",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorMod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],zle=[{tfOpName:"Abs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan2",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Ceil",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ClipByValue",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"clipValueMin",type:"number"},{start:2,name:"clipValueMax",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Complex",category:"basic_math",inputs:[{start:0,name:"real",type:"tensor"},{start:1,name:"imag",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ComplexAbs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Elu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Exp",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Floor",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Imag",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Neg",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Real",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Prelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"alpha",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu6",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Selu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sigmoid",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Rsqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Square",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sign",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Round",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Expm1",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log1p",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Reciprocal",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Softplus",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Erf",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LeakyRelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"alpha",name:"alpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsNan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsFinite",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsInf",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],Ble=[{tfOpName:"EmptyTensorList",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"maxNumElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"LoopCond",category:"control",inputs:[{start:0,name:"pred",type:"tensor"}]},{tfOpName:"Switch",category:"control",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"pred",type:"tensor"}]},{tfOpName:"Merge",category:"control",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"Enter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"frame_name",name:"frameName",type:"string"},{tfName:"is_constant",name:"isConstant",type:"bool"}]},{tfOpName:"Exit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NextIteration",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayV3",category:"control",inputs:[{start:0,name:"size",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"dynamic_size",name:"dynamicSize",type:"bool"},{tfName:"clear_after_read",name:"clearAfterRead",type:"bool"},{tfName:"identical_element_shapes",name:"identicalElementShapes",type:"bool"},{tfName:"tensor_array_name",name:"name",type:"string"}]},{tfOpName:"TensorArrayWriteV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayReadV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayGatherV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"}]},{tfOpName:"TensorArrayScatterV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArrayConcatV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape_except0",name:"elementShapeExcept0",type:"shape",notSupported:!0}]},{tfOpName:"TensorArraySplitV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"tensor",type:"tensor"},{start:2,name:"lengths",type:"number[]"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArraySizeV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}]},{tfOpName:"TensorArrayCloseV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"}]},{tfOpName:"StatelessIf",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"If",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"StatelessWhile",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"While",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"TensorListScatter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListScatterV2",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"},{start:3,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGather",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListSetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListReserve",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListFromTensor",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListStack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"},{tfName:"num_elements",name:"numElements",type:"dtype"}]},{tfOpName:"TensorListSplit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"},{start:2,name:"lengths",type:"number[]"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcat",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcatV2",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPopBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPushBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListLength",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}]},{tfOpName:"TensorListResize",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"size",type:"number"}]}],Wle=[{tfOpName:"AvgPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[],notSupported:!0},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPoolWithArgmax",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"include_batch_in_index",name:"includeBatchInIndex",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AvgPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Conv1D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"stride",name:"stride",type:"number"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NWC"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"dilation",name:"dilation",type:"number",defaultValue:1}]},{tfOpName:"Conv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"useCudnnOnGpu",name:"useCudnnOnGpu",type:"bool"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"_FusedConv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"use_cudnn_on_gpu",name:"useCudnnOnGpu",type:"bool",defaultValue:!0},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"leakyrelu_alpha",name:"leakyreluAlpha",type:"number",defaultValue:.2}]},{tfOpName:"Conv2DBackpropInput",category:"convolution",inputs:[{start:2,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:0,name:"outputShape",type:"number[]"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]",notSupported:!0}]},{tfOpName:"DepthwiseConv2d",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"DepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"FusedDepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]}]},{tfOpName:"Conv3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"Dilation2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"rates",name:"dilations",type:"number[]"},{tfName:"padding",name:"pad",type:"string"}]}],Vle=[{tfOpName:"Fill",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"},{start:1,name:"value",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"LinSpace",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"num",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"OneHot",category:"creation",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"depth",type:"number"},{start:2,name:"onValue",type:"number",defaultValue:1},{start:3,name:"offValue",type:"number",defaultValue:0}],attrs:[{tfName:"axis",name:"axis",type:"number",notSupported:!0},{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Ones",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"OnesLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"RandomStandardNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"RandomUniform",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"minval",name:"minval",type:"number",defaultValue:0},{tfName:"maxval",name:"maxval",type:"number",defaultValue:1},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"RandomUniformInt",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"minval",name:"minval",type:"number"},{tfName:"maxval",name:"maxval",type:"number"},{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0}]},{tfOpName:"Range",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"step",type:"number",defaultValue:0}],attrs:[{tfName:"Tidx",name:"dtype",type:"dtype"}]},{tfOpName:"TruncatedNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"means",name:"mean",type:"number",defaultValue:0},{tfName:"stddev",name:"stdDev",type:"number",defaultValue:1},{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"Zeros",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"ZerosLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Multinomial",category:"creation",inputs:[{start:0,name:"logits",type:"tensor"},{start:1,name:"numSamples",type:"number"}],attrs:[{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number"},{tfName:"T",name:"dtype",type:"dtype"},{tfName:"output_dtype",name:"output_dtype",type:"dtype"}]}],Ule=[{tfOpName:"NonMaxSuppressionV2",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV3",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV4",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"T_threshold",name:"threshold",type:"dtype",notSupported:!0},{tfName:"pad_to_max_output_size",name:"padToMaxOutputSize",type:"bool"}]},{tfOpName:"NonMaxSuppressionV5",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"},{start:5,name:"softNmsSigma",type:"number"}]},{tfOpName:"Where",category:"dynamic",inputs:[{start:0,name:"condition",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ListDiff",category:"dynamic",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],Gle=[{tfOpName:"LowerBound",category:"evaluation",inputs:[{start:0,name:"sortedSequence",type:"tensor"},{start:1,name:"values",type:"tensor"}]},{tfOpName:"TopKV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"k",type:"number"}],attrs:[{tfName:"sorted",name:"sorted",type:"bool"}]},{tfOpName:"UpperBound",category:"evaluation",inputs:[{start:0,name:"sortedSequence",type:"tensor"},{start:1,name:"values",type:"tensor"}]},{tfOpName:"Unique",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"UniqueV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]}],Hle=[{tfOpName:"PlaceholderWithDefault",category:"graph",inputs:[{start:0,name:"default",type:"tensor"}],attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Placeholder",category:"graph",attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Const",category:"graph"},{tfOpName:"Identity",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IdentityN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Snapshot",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Rank",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Size",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Shape",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"ShapeN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Print",category:"graph",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"data",type:"tensors"}],attrs:[{tfName:"message",name:"message",type:"string"},{tfName:"first_n",name:"firstN",type:"number",notSupported:!0},{tfName:"summarize",name:"summarize",type:"number",defaultValue:3}]},{tfOpName:"NoOp",category:"graph",inputs:[]},{tfOpName:"StopGradient",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"FakeQuantWithMinMaxVars",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"min",name:"min",type:"number"},{tfName:"max",name:"max",type:"number"}]}],jle=[{tfOpName:"HashTable",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"HashTableV2",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"LookupTableImport",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableImportV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFind",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFindV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableSize",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]},{tfOpName:"LookupTableSizeV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]},{tfOpName:"InitializeTable",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}]},{tfOpName:"InitializeTableV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}]}],Kle=[{tfOpName:"ResizeBilinear",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ResizeNearestNeighbor",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"CropAndResize",category:"image",inputs:[{start:0,name:"image",type:"tensor"},{start:1,name:"boxes",type:"tensor"},{start:2,name:"boxInd",type:"tensor"},{start:3,name:"cropSize",type:"number[]"}],attrs:[{tfName:"method",name:"method",type:"string"},{tfName:"extrapolation_value",name:"extrapolationValue",type:"number"}]},{tfOpName:"ImageProjectiveTransformV3",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"transforms",type:"tensor"},{start:2,name:"outputShape",type:"number[]"},{start:3,name:"fillValue",type:"number"}],attrs:[{tfName:"interpolation",name:"interpolation",type:"string"},{tfName:"fill_mode",name:"fillMode",type:"string"}]}],qle=[{tfOpName:"Equal",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NotEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Greater",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"GreaterEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Less",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LessEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalAnd",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalNot",category:"logical",inputs:[{start:0,name:"a",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalOr",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Select",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SelectV2",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BitwiseAnd",category:"logical",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}]}],Xle=[{tfOpName:"_FusedMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"leakyrelu_alpha",name:"leakyreluAlpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMulV2",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Transpose",category:"matrices",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"perm",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Einsum",category:"matrices",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"equation",name:"equation",type:"string"},{tfName:"N",name:"n",type:"number",defaultValue:2},{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"MatrixBandPart",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"numLower",type:"tensor"},{start:1,name:"numUpper",type:"tensor"}]}],Yle=[{tfOpName:"EuclideanNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool",defaultValue:!1}]},{tfOpName:"FusedBatchNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV2",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV3",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"LRN",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"depth_radius",name:"radius",type:"number",defaultValue:5},{tfName:"bias",name:"bias",type:"number",defaultValue:1},{tfName:"alpha",name:"alpha",type:"number",defaultValue:1},{tfName:"beta",name:"beta",type:"number",defaultValue:.5}]},{tfOpName:"Softmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"LogSoftmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]}],Qle=[{tfOpName:"Bincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}]},{tfOpName:"DenseBincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}],attrs:[{tfName:"binary_output",name:"binaryOutput",type:"bool"}]},{tfOpName:"Max",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Mean",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Min",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Sum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"All",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Any",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"ArgMax",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"ArgMin",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"Prod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cumprod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]},{tfOpName:"Cumsum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]}],Jle=[{tfOpName:"ConcatV2",category:"slice_join",inputs:[{start:0,end:-1,name:"tensors",type:"tensors"},{start:-1,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"Concat",category:"slice_join",inputs:[{start:1,end:0,name:"tensors",type:"tensors"},{start:0,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"GatherV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"axis",type:"number",defaultValue:0}],attrs:[{tfName:"batch_dims",name:"batchDims",type:"number",defaultValue:0}]},{tfOpName:"Gather",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",notSupported:!0}]},{tfOpName:"Reverse",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"dims",type:"bool[]"}]},{tfOpName:"ReverseV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}]},{tfOpName:"Slice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"size",type:"number[]"}]},{tfOpName:"StridedSlice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"end",type:"number[]"},{start:3,name:"strides",type:"number[]"}],attrs:[{tfName:"begin_mask",name:"beginMask",type:"number",defaultValue:0},{tfName:"end_mask",name:"endMask",type:"number",defaultValue:0},{tfName:"new_axis_mask",name:"newAxisMask",type:"number",defaultValue:0},{tfName:"ellipsis_mask",name:"ellipsisMask",type:"number",defaultValue:0},{tfName:"shrink_axis_mask",name:"shrinkAxisMask",type:"number",defaultValue:0}]},{tfOpName:"Pack",category:"slice_join",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0}]},{tfOpName:"Unpack",category:"slice_join",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0},{tfName:"num",name:"num",type:"number",defaultValue:0,notSupported:!0}]},{tfOpName:"Tile",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"reps",type:"number[]"}]},{tfOpName:"Split",category:"slice_join",inputs:[{start:0,name:"axis",type:"number",defaultValue:0},{start:1,name:"x",type:"tensor"}],attrs:[{tfName:"num_split",name:"numOrSizeSplits",type:"number",defaultValue:1}]},{tfOpName:"SplitV",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"numOrSizeSplits",type:"number[]"},{start:2,name:"axis",type:"number",defaultValue:0}]},{tfOpName:"ScatterNd",category:"slice_join",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"shape",type:"number[]"}]},{tfOpName:"GatherNd",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}]},{tfOpName:"SparseToDense",category:"slice_join",inputs:[{start:0,name:"sparseIndices",type:"tensor"},{start:1,name:"outputShape",type:"number[]"},{start:2,name:"sparseValues",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",defaultValue:!1,notSupported:!0}]},{tfOpName:"TensorScatterUpdate",category:"slice_join",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"values",type:"tensor"}]}],Zle=[{tfOpName:"SparseFillEmptyRows",category:"sparse",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"denseShape",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}]},{tfOpName:"SparseReshape",category:"sparse",inputs:[{start:0,name:"inputIndices",type:"tensor"},{start:1,name:"inputShape",type:"tensor"},{start:2,name:"newShape",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SparseSegmentMean",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]},{tfOpName:"SparseSegmentSum",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]}],$le=[{tfOpName:"FFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"RFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]},{tfOpName:"IRFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]}],eue=[{tfOpName:"StaticRegexReplace",category:"string",inputs:[{start:0,name:"input",type:"tensor"}],attrs:[{tfName:"pattern",name:"pattern",type:"string"},{tfName:"rewrite",name:"rewrite",type:"string"},{tfName:"replace_global",name:"replaceGlobal",type:"bool"}]},{tfOpName:"StringNGrams",category:"string",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"dataSplits",type:"tensor"}],attrs:[{tfName:"separator",name:"separator",type:"string"},{tfName:"ngram_widths",name:"nGramWidths",type:"number[]"},{tfName:"left_pad",name:"leftPad",type:"string"},{tfName:"right_pad",name:"rightPad",type:"string"},{tfName:"pad_width",name:"padWidth",type:"number"},{tfName:"preserve_short_sequences",name:"preserveShortSequences",type:"bool"}],outputs:["ngrams","ngrams_splits"]},{tfOpName:"StringSplit",category:"string",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"delimiter",type:"tensor"}],attrs:[{tfName:"skip_empty",name:"skipEmpty",type:"bool"}],outputs:["indices","values","shape"]},{tfOpName:"StringToHashBucketFast",category:"string",inputs:[{start:0,name:"input",type:"tensor"}],attrs:[{tfName:"num_buckets",name:"numBuckets",type:"number"}]}],tue=[{tfOpName:"Cast",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"SrcT",name:"sdtype",type:"dtype",notSupported:!0},{tfName:"DstT",name:"dtype",type:"dtype"}]},{tfOpName:"ExpandDims",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"MirrorPad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"mode",name:"mode",type:"string"}]},{tfOpName:"Pad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"constant_value",name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"PadV2",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"},{start:2,name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"Reshape",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}]},{tfOpName:"EnsureShape",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}]},{tfOpName:"Squeeze",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"axis",tfDeprecatedName:"squeeze_dims",name:"axis",type:"number[]"}]},{tfOpName:"SpaceToBatchND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"paddings",type:"number[]"}]},{tfOpName:"BatchToSpaceND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"crops",type:"number[]"}]},{tfOpName:"DepthToSpace",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"block_size",name:"blockSize",type:"number"},{tfName:"data_format",name:"dataFormat",type:"string"}]},{tfOpName:"BroadcastTo",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}],attrs:[]},{tfOpName:"BroadcastArgs",category:"transformation",inputs:[{start:0,name:"s0",type:"tensor"},{start:1,name:"s1",type:"tensor"}],attrs:[]}];class nue{static get Instance(){return this._instance||(this._instance=new this)}constructor(){const e=[].concat(...[d,h,p,f,m,g,b,y,x,v,w,k,I,S,N,C,T,E,R].map((e=>e.json)));this.opMappers=e.reduce(((e,t)=>(e[t.tfOpName]=t,e)),{})}transformGraph(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const n=e.node,a=[],r=[],o=[],s=n.reduce(((e,t)=>(e[t.name]=this.mapNode(t),t.op.startsWith("Placeholder")?a.push(e[t.name]):"Const"===t.op?r.push(e[t.name]):null!=t.input&&0!==t.input.length||o.push(e[t.name]),e)),{});let i=[];const c=[];let l={},u={};null!=t&&(l=this.mapSignatureEntries(t.inputs),u=this.mapSignatureEntries(t.outputs));const d=Object.keys(s);d.forEach((e=>{const t=s[e];t.inputNames.forEach(((e,n)=>{const[a,,r]=Fle(e),o=s[a];if(null!=o.outputs){const e=o.outputs.indexOf(r);if(-1!==e){const r="".concat(a,":").concat(e);t.inputNames[n]=r}}t.inputs.push(o),o.children.push(t)}))})),0===Object.keys(u).length?d.forEach((e=>{const t=s[e];0===t.children.length&&c.push(t)})):Object.keys(u).forEach((e=>{const[t]=Fle(e),n=s[t];null!=n&&(n.signatureKey=u[e],c.push(n))})),Object.keys(l).length>0?Object.keys(l).forEach((e=>{const[t]=Fle(e),n=s[t];n&&(n.signatureKey=l[e],i.push(n))})):i=a;let h={};null!=e.library&&null!=e.library.function&&(h=e.library.function.reduce(((e,t)=>(e[t.signature.name]=this.mapFunction(t),e)),{}));const p={nodes:s,inputs:i,outputs:c,weights:r,placeholders:a,signature:t,functions:h};return o.length>0&&(p.initNodes=o),p}mapSignatureEntries(e){return Object.keys(e||{}).reduce(((t,n)=>(t[e[n].name]=n,t)),{})}mapNode(e){const t=Ele(e.op)||this.opMappers[e.op]||{};null==e.attr&&(e.attr={});const n={name:e.name,op:e.op,category:t.category,inputNames:(e.input||[]).map((e=>e.startsWith("^")?e.slice(1):e)),inputs:[],children:[],inputParams:{},attrParams:{},rawAttrs:e.attr,outputs:t.outputs};return null!=t.inputs&&(n.inputParams=t.inputs.reduce(((e,t)=>(e[t.name]={type:t.type,inputIndexStart:t.start,inputIndexEnd:t.end},e)),{})),null!=t.attrs&&(n.attrParams=t.attrs.reduce(((t,n)=>{const a=n.type;let r;switch(n.type){case"string":r=rue(e.attr,n.tfName,n.defaultValue),void 0===r&&n.tfDeprecatedName&&(r=rue(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"string[]":r=fue(e.attr,n.tfName,n.defaultValue),void 0===r&&n.tfDeprecatedName&&(r=fue(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"number":r=sue(e.attr,n.tfName,n.defaultValue||0),void 0===r&&n.tfDeprecatedName&&(r=sue(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"number[]":r=pue(e.attr,n.tfName,n.defaultValue),void 0===r&&n.tfDeprecatedName&&(r=pue(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"bool":r=oue(e.attr,n.tfName,n.defaultValue),void 0===r&&n.tfDeprecatedName&&(r=oue(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"bool[]":r=gue(e.attr,n.tfName,n.defaultValue),void 0===r&&n.tfDeprecatedName&&(r=gue(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"shape":r=hue(e.attr,n.tfName,n.defaultValue),void 0===r&&n.tfDeprecatedName&&(r=hue(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"shape[]":r=mue(e.attr,n.tfName,n.defaultValue),void 0===r&&n.tfDeprecatedName&&(r=mue(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"dtype":r=lue(e.attr,n.tfName,n.defaultValue),void 0===r&&n.tfDeprecatedName&&(r=lue(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"dtype[]":r=uue(e.attr,n.tfName,n.defaultValue),void 0===r&&n.tfDeprecatedName&&(r=uue(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"func":r=cue(e.attr,n.tfName,n.defaultValue),void 0===r&&n.tfDeprecatedName&&(r=cue(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"tensor":case"tensors":break;default:throw new Error("Unsupported param type: ".concat(n.type," for op: ").concat(e.op))}return t[n.name]={value:r,type:a},t}),{})),n}mapFunction(e){const t=e.nodeDef,n=[];let a={};null!=t&&(a=t.reduce(((e,t)=>(e[t.name]=this.mapNode(t),"Const"===t.op&&n.push(e[t.name]),e)),{}));const r=[],o=[];e.signature.inputArg.forEach((e=>{const[t]=Fle(e.name),n={name:t,op:"Placeholder",inputs:[],inputNames:[],category:"graph",inputParams:{},attrParams:{dtype:{value:iue(e.type),type:"dtype"}},children:[]};n.signatureKey=e.name,r.push(n),a[t]=n}));Object.keys(a).forEach((e=>{const t=a[e];t.inputNames.forEach(((e,n)=>{const[r,,o]=Fle(e),s=a[r];if(null!=s.outputs){const e=s.outputs.indexOf(o);if(-1!==e){const a="".concat(r,":").concat(e);t.inputNames[n]=a}}t.inputs.push(s),s.children.push(t)}))}));const s=e.ret;e.signature.outputArg.forEach((e=>{const[t,n]=Fle(s[e.name]),r=a[t];null!=r&&(r.defaultOutput=n,o.push(r))}));const i=this.mapArgsToSignature(e);return{nodes:a,inputs:r,outputs:o,weights:n,placeholders:[],signature:i}}mapArgsToSignature(e){return{methodName:e.signature.name,inputs:e.signature.inputArg.reduce(((e,t)=>(e[t.name]=this.mapArgToTensorInfo(t),e)),{}),outputs:e.signature.outputArg.reduce(((t,n)=>(t[n.name]=this.mapArgToTensorInfo(n,e.ret),t)),{})}}mapArgToTensorInfo(e,t){let n=e.name;return null!=t&&(n=t[n]),{name:n,dtype:e.type}}}function aue(e,t){const n=Array.isArray(e)?String.fromCharCode.apply(null,e):function(e){const t=yG().global;if("undefined"!==typeof t.atob)return t.atob(e);if("undefined"!==typeof Buffer)return new Buffer(e,"base64").toString();throw new Error("Unable to decode base64 in this environment. Missing built-in atob() or Buffer()")}(e);return t?n:n.toLowerCase()}function rue(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const r=e[t];return null!=r?aue(r.s,a):n}function oue(e,t,n){const a=e[t];return a?a.b:n}function sue(e,t,n){const a=e[t]||{},r=null!=a.i?a.i:null!=a.f?a.f:n;return"number"===typeof r?r:parseInt(r,10)}function iue(e){switch("string"===typeof e&&(e=Nle[e]),e){case Nle.DT_FLOAT:case Nle.DT_HALF:return"float32";case Nle.DT_INT32:case Nle.DT_INT64:case Nle.DT_INT8:case Nle.DT_UINT8:return"int32";case Nle.DT_BOOL:return"bool";case Nle.DT_DOUBLE:return"float32";case Nle.DT_STRING:return"string";case Nle.DT_COMPLEX64:case Nle.DT_COMPLEX128:return"complex64";default:return null}}function cue(e,t,n){const a=e[t];return a&&a.func?a.func.name:n}function lue(e,t,n){const a=e[t];return a&&a.type?iue(a.type):n}function uue(e,t,n){const a=e[t];return a&&a.list&&a.list.type?a.list.type.map((e=>iue(e))):n}function due(e){if(!e.unknownRank)return null!=e.dim?e.dim.map((e=>"number"===typeof e.size?e.size:parseInt(e.size,10))):[]}function hue(e,t,n){const a=e[t];return a&&a.shape?due(a.shape):n}function pue(e,t,n){const a=e[t];return a?((a.list.f&&a.list.f.length?a.list.f:a.list.i)||[]).map((e=>"number"===typeof e?e:parseInt(e,10))):n}function fue(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const r=e[t];return r&&r.list&&r.list.s?r.list.s.map((e=>aue(e,a))):n}function mue(e,t,n){const a=e[t];return a&&a.list&&a.list.shape?a.list.shape.map((e=>due(e))):n}function gue(e,t,n){const a=e[t];return a&&a.list&&a.list.b?a.list.b:n}class bue{constructor(e,t,n){this.node=e,this.tensorMap=t,this.context=n,this.inputs=[],this.attrs={},this.inputs=e.inputNames.map((e=>this.getInput(e))),null!=e.rawAttrs&&(this.attrs=Object.keys(e.rawAttrs).reduce(((e,t)=>(e[t]=this.getAttr(t),e)),{}))}getInput(e){return _le(e,this.tensorMap,this.context)}getAttr(e,t){const n=this.node.rawAttrs[e];if(null!=n.tensor)return _le(e,this.tensorMap,this.context);if(null!=n.i||null!=n.f)return sue(this.node.rawAttrs,e,t);if(null!=n.s)return rue(this.node.rawAttrs,e,t);if(null!=n.b)return oue(this.node.rawAttrs,e,t);if(null!=n.shape)return hue(this.node.rawAttrs,e,t);if(null!=n.type)return lue(this.node.rawAttrs,e,t);if(null!=n.list){if(null!=n.list.i||null!=n.list.f)return pue(this.node.rawAttrs,e,t);if(null!=n.list.s)return fue(this.node.rawAttrs,e,t);if(null!=n.list.shape)return mue(this.node.rawAttrs,e,t);if(null!=n.list.b)return gue(this.node.rawAttrs,e,t);if(null!=n.list.type)return uue(this.node.rawAttrs,e,t)}return t}}function yue(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"";if("number"!==typeof e&&"number"!==typeof t){BU(e.length===t.length,(()=>n+" Shapes ".concat(e," and ").concat(t," must match")));for(let a=0;a<e.length;a++){const r=e[a],o=t[a];BU(r<0||o<0||r===o,(()=>n+" Shapes ".concat(e," and ").concat(t," must match")))}}}function xue(e){return"number"!==typeof e&&!e.some((e=>e<0))}function vue(e,t,n){let a=wue(e,n);const r=!xue(a);if(r&&0===t.length)throw new Error("Tried to calculate elements of an empty list"+" with non-fully-defined elementShape: ".concat(a));if(r&&t.forEach((e=>{a=wue(e.shape,a)})),!xue(a))throw new Error("Non-fully-defined elementShape: ".concat(a));return a}function wue(e,t){if("number"===typeof e)return t;if("number"===typeof t)return e;if(e.length!==t.length)throw new Error("Incompatible ranks during merge: ".concat(e," vs. ").concat(t));const n=[];for(let a=0;a<e.length;++a){const r=e[a],o=t[a];if(r>=0&&o>=0&&r!==o)throw new Error("Incompatible shape during merge: ".concat(e," vs. ").concat(t));n[a]=r>=0?r:o}return n}class kue{constructor(e,t,n,a,r,o,s){this.name=e,this.dtype=t,this.maxSize=n,this.elementShape=a,this.identicalElementShapes=r,this.dynamicSize=o,this.clearAfterRead=s,this.tensors=[],this.closed_=!1,this.idTensor=EY(0),hX(this.idTensor)}get id(){return this.idTensor.id}get closed(){return this.closed_}clearAndClose(e){this.tensors.forEach((t=>{null!=e&&e.has(t.tensor.id)||t.tensor.dispose()})),this.tensors=[],this.closed_=!0,this.idTensor.dispose()}size(){return this.tensors.length}read(e){if(this.closed_)throw new Error("TensorArray ".concat(this.name," has already been closed."));if(e<0||e>=this.size())throw new Error("Tried to read from index ".concat(e,", but array size is: ").concat(this.size()));const t=this.tensors[e];if(t.cleared)throw new Error("TensorArray ".concat(this.name,": Could not read index ").concat(e," twice because it was cleared after a previous read ")+"(perhaps try setting clear_after_read = false?).");return this.clearAfterRead&&(t.cleared=!0),t.read=!0,t.tensor}readMany(e){return e.map((e=>this.read(e)))}write(e,t){if(this.closed_)throw new Error("TensorArray ".concat(this.name," has already been closed."));if(e<0||!this.dynamicSize&&e>=this.maxSize)throw new Error("Tried to write to index ".concat(e,", but array is not resizeable and size is: ").concat(this.maxSize));const n=this.tensors[e]||{};if(t.dtype!==this.dtype)throw new Error("TensorArray ".concat(this.name,": Could not write to TensorArray index ").concat(e,",\n          because the value dtype is ").concat(t.dtype,", but TensorArray dtype is ").concat(this.dtype,"."));if(0!==this.size()||null!=this.elementShape&&0!==this.elementShape.length||(this.elementShape=t.shape),yue(this.elementShape,t.shape,"TensorArray ".concat(this.name,": Could not write to TensorArray index ").concat(e,".")),n.read)throw new Error("TensorArray ".concat(this.name,": Could not write to TensorArray index ").concat(e,", because it has already been read."));if(n.written)throw new Error("TensorArray ".concat(this.name,": Could not write to TensorArray index ").concat(e,", because it has already been written."));n.tensor=t,hX(t),n.written=!0,this.tensors[e]=n}writeMany(e,t){if(e.length!==t.length)throw new Error("TensorArray ".concat(this.name,": could not write multiple tensors,")+"because the index size: ".concat(e.length," is not the same as tensors size: ").concat(t.length,"."));e.forEach(((e,n)=>this.write(e,t[n])))}gather(e,t){if(t&&t!==this.dtype)throw new Error("TensorArray dtype is ".concat(this.dtype," but gather requested dtype ").concat(t));if(e)e=e.slice(0,this.size());else{e=[];for(let t=0;t<this.size();t++)e.push(t)}if(0===e.length)return sX([],[0].concat(this.elementShape));const n=this.readMany(e);return yue(this.elementShape,n[0].shape,"TensorArray shape mismatch: "),i0(n,0)}concat(e){if(e&&e!==this.dtype)throw new Error("TensorArray dtype is ".concat(this.dtype," but concat requested dtype ").concat(e));if(0===this.size())return sX([],[0].concat(this.elementShape));const t=[];for(let a=0;a<this.size();a++)t.push(a);const n=this.readMany(t);return yue(this.elementShape,n[0].shape,"TensorArray shape mismatch: tensor array shape (".concat(this.elementShape,") vs first tensor shape (").concat(n[0].shape,")")),uJ(n,0)}scatter(e,t){if(t.dtype!==this.dtype)throw new Error("TensorArray dtype is ".concat(this.dtype," but tensor has dtype ").concat(t.dtype));if(e.length!==t.shape[0])throw new Error("Expected len(indices) == tensor.shape[0], but saw: ".concat(e.length," vs. ").concat(t.shape[0]));const n=Math.max(...e);if(!this.dynamicSize&&n>=this.maxSize)throw new Error("Max index must be < array size (".concat(n,"  vs. ").concat(this.maxSize,")"));this.writeMany(e,S0(t,0))}split(e,t){if(t.dtype!==this.dtype)throw new Error("TensorArray dtype is ".concat(this.dtype," but tensor has dtype ").concat(t.dtype));let n=0;const a=e.map((e=>(n+=e,n)));if(n!==t.shape[0])throw new Error("Expected sum of lengths to be equal to\n          tensor.shape[0], but sum of lengths is\n        ".concat(n,", and tensor's shape is: ").concat(t.shape));if(!this.dynamicSize&&e.length!==this.maxSize)throw new Error("TensorArray's size is not equal to the size of lengths (".concat(this.maxSize," vs. ").concat(e.length,"), ")+"and the TensorArray is not marked as dynamically resizeable");const r=0===n?0:t.size/n,o=[];uX((()=>{t=iJ(t,[1,n,r]);for(let n=0;n<e.length;++n){const s=[0,0===n?0:a[n-1],0],i=[1,e[n],r];o[n]=iJ(pJ(t,s,i),this.elementShape)}return o}));const s=[];for(let i=0;i<e.length;i++)s[i]=i;this.writeMany(s,o)}}class Iue{get id(){return this.idTensor.id}constructor(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:-1;this.tensors=e,this.elementShape=t,this.elementDtype=n,null!=e&&e.forEach((e=>{if(n!==e.dtype)throw new Error("Invalid data types; op elements ".concat(n,", but list elements ").concat(e.dtype));yue(t,e.shape,"TensorList shape mismatch: "),hX(e)})),this.idTensor=EY(0),this.maxNumElements=a,hX(this.idTensor)}copy(){return new Iue([...this.tensors],this.elementShape,this.elementDtype)}clearAndClose(e){this.tensors.forEach((t=>{null!=e&&e.has(t.id)||t.dispose()})),this.tensors.length=0,this.idTensor.dispose()}size(){return this.tensors.length}stack(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:-1;if(t!==this.elementDtype)throw new Error("Invalid data types; op elements ".concat(t,", but list elements ").concat(this.elementDtype));if(-1!==n&&this.tensors.length!==n)throw new Error("Operation expected a list with ".concat(n," elements but got a list with ").concat(this.tensors.length," elements."));yue(e,this.elementShape,"TensorList shape mismatch: ");const a=vue(this.elementShape,this.tensors,e);return uX((()=>{const e=this.tensors.map((e=>iJ(e,a)));return i0(e,0)}))}popBack(e,t){if(t!==this.elementDtype)throw new Error("Invalid data types; op elements ".concat(t,", but list elements ").concat(this.elementDtype));if(0===this.size())throw new Error("Trying to pop from an empty list.");const n=vue(this.elementShape,this.tensors,e),a=this.tensors.pop();return a.kept=!1,yue(a.shape,e,"TensorList shape mismatch: "),iJ(a,n)}pushBack(e){if(e.dtype!==this.elementDtype)throw new Error("Invalid data types; op elements ".concat(e.dtype,", but list elements ").concat(this.elementDtype));if(yue(e.shape,this.elementShape,"TensorList shape mismatch: "),this.maxNumElements===this.size())throw new Error("Trying to push element into a full list.");hX(e),this.tensors.push(e)}resize(e){if(e<0)throw new Error("TensorListResize expects size to be non-negative. Got: ".concat(e));if(-1!==this.maxNumElements&&e>this.maxNumElements)throw new Error("TensorListResize input size ".concat(e," is greater maxNumElement ").concat(this.maxNumElements,"."));const t=new Iue([],this.elementShape,this.elementDtype,this.maxNumElements);t.tensors.length=e;for(let n=0;n<Math.min(this.tensors.length,e);++n)t.tensors[n]=this.tensors[n];return t}getItem(e,t,n){if(n!==this.elementDtype)throw new Error("Invalid data types; op elements ".concat(n,", but list elements ").concat(this.elementDtype));if(e<0||e>this.tensors.length)throw new Error("Trying to access element ".concat(e," in a list with ").concat(this.tensors.length," elements."));if(null==this.tensors[e])throw new Error("element at index ".concat(e," is null."));yue(this.tensors[e].shape,t,"TensorList shape mismatch: ");const a=vue(this.elementShape,this.tensors,t);return iJ(this.tensors[e],a)}setItem(e,t){if(t.dtype!==this.elementDtype)throw new Error("Invalid data types; op elements ".concat(t.dtype,", but list elements ").concat(this.elementDtype));if(e<0||-1!==this.maxNumElements&&e>=this.maxNumElements)throw new Error("Trying to set element ".concat(e," in a list with max ").concat(this.maxNumElements," elements."));yue(this.elementShape,t.shape,"TensorList shape mismatch: "),hX(t),null!=this.tensors[e]&&(this.tensors[e].kept=!1),this.tensors[e]=t}gather(e,t,n){if(t!==this.elementDtype)throw new Error("Invalid data types; op elements ".concat(t,", but list elements ").concat(this.elementDtype));yue(this.elementShape,n,"TensorList shape mismatch: "),e=e.slice(0,this.size());const a=vue(this.elementShape,this.tensors,n);return 0===e.length?sX([],[0].concat(a)):uX((()=>{const t=e.map((e=>iJ(this.tensors[e],a)));return i0(t,0)}))}concat(e,t){if(e&&e!==this.elementDtype)throw new Error("TensorList dtype is ".concat(this.elementDtype," but concat requested dtype ").concat(e));yue(this.elementShape,t,"TensorList shape mismatch: ");const n=vue(this.elementShape,this.tensors,t);return 0===this.size()?sX([],[0].concat(n)):uX((()=>{const e=this.tensors.map((e=>iJ(e,n)));return uJ(e,0)}))}}const Sue=async(e,t,n)=>{switch(e.op){case"If":case"StatelessIf":{const a=Rle("thenBranch",e,t,n),r=Rle("elseBranch",e,t,n),o=Rle("cond",e,t,n),s=Rle("args",e,t,n);return(await o.data())[0]?n.functionMap[a].executeFunctionAsync(s,n.tensorArrayMap,n.tensorListMap):n.functionMap[r].executeFunctionAsync(s,n.tensorArrayMap,n.tensorListMap)}case"While":case"StatelessWhile":{const a=Rle("body",e,t,n),r=Rle("cond",e,t,n),o=Rle("args",e,t,n),s=await n.functionMap[r].executeFunctionAsync(o,n.tensorArrayMap,n.tensorListMap),i=o.map((e=>e.id));let c=await s[0].data();s.forEach((e=>{e.kept||-1!==i.indexOf(e.id)||e.dispose()}));let l=o;for(;c[0];){const e=l;l=await n.functionMap[a].executeFunctionAsync(l,n.tensorArrayMap,n.tensorListMap);const t=l.map((e=>e.id));e.forEach((e=>{e.kept||-1!==i.indexOf(e.id)||-1!==t.indexOf(e.id)||e.dispose()}));const o=await n.functionMap[r].executeFunctionAsync(l,n.tensorArrayMap,n.tensorListMap);c=await o[0].data(),o.forEach((e=>{e.kept||-1!==i.indexOf(e.id)||-1!==t.indexOf(e.id)||e.dispose()}))}return l}case"LoopCond":return[Lle(Rle("pred",e,t,n))];case"Switch":{const a=Rle("pred",e,t,n);let r=Rle("data",e,t,n);return r.kept||(r=Lle(r)),(await a.data())[0]?[void 0,r]:[r,void 0]}case"Merge":{const a=e.inputNames.find((e=>void 0!==_le(e,t,n)));if(a){return[Lle(_le(a,t,n))]}return}case"Enter":{const a=Rle("frameName",e,t,n),r=Rle("tensor",e,t,n);return n.enterFrame(a),[Lle(r)]}case"Exit":{const a=Rle("tensor",e,t,n);return n.exitFrame(),[Lle(a)]}case"NextIteration":{const a=Rle("tensor",e,t,n);return n.nextIteration(),[Lle(a)]}case"TensorArrayV3":{const a=Rle("size",e,t,n),r=Rle("dtype",e,t,n),o=Rle("elementShape",e,t,n),s=Rle("dynamicSize",e,t,n),i=Rle("clearAfterRead",e,t,n),c=Rle("identicalElementShapes",e,t,n),l=Rle("name",e,t,n),u=new kue(l,r,a,o,c,s,i);return n.addTensorArray(u),[u.idTensor,EY(1)]}case"TensorArrayWriteV3":{const a=Rle("tensorArrayId",e,t,n),r=Rle("index",e,t,n),o=Rle("tensor",e,t,n),s=n.getTensorArray(a.id);return s.write(r,o),[s.idTensor]}case"TensorArrayReadV3":{const a=Rle("tensorArrayId",e,t,n),r=Rle("index",e,t,n);return[n.getTensorArray(a.id).read(r)]}case"TensorArrayGatherV3":{const a=Rle("tensorArrayId",e,t,n),r=Rle("indices",e,t,n),o=Rle("dtype",e,t,n);return[n.getTensorArray(a.id).gather(r,o)]}case"TensorArrayScatterV3":{const a=Rle("tensorArrayId",e,t,n),r=Rle("indices",e,t,n),o=Rle("tensor",e,t,n),s=n.getTensorArray(a.id);return s.scatter(r,o),[s.idTensor]}case"TensorArrayConcatV3":{const a=Rle("tensorArrayId",e,t,n),r=n.getTensorArray(a.id),o=Rle("dtype",e,t,n);return[r.concat(o)]}case"TensorArraySplitV3":{const a=Rle("tensorArrayId",e,t,n),r=Rle("tensor",e,t,n),o=Rle("lengths",e,t,n),s=n.getTensorArray(a.id);return s.split(o,r),[s.idTensor]}case"TensorArraySizeV3":{const a=Rle("tensorArrayId",e,t,n);return[EY(n.getTensorArray(a.id).size(),"int32")]}case"TensorArrayCloseV3":{const a=Rle("tensorArrayId",e,t,n),r=n.getTensorArray(a.id);return r.clearAndClose(),[r.idTensor]}case"TensorListSetItem":{const a=Rle("tensorListId",e,t,n),r=Rle("index",e,t,n),o=Rle("tensor",e,t,n),s=n.getTensorList(a.id);return s.setItem(r,o),[s.idTensor]}case"TensorListGetItem":{const a=Rle("tensorListId",e,t,n),r=Rle("index",e,t,n),o=Rle("elementShape",e,t,n),s=Rle("elementDType",e,t,n);return[n.getTensorList(a.id).getItem(r,o,s)]}case"TensorListScatterV2":case"TensorListScatter":{const a=Rle("indices",e,t,n),r=function(e,t,n,a){if(t.length!==e.shape[0])throw new Error("Expected len(indices) == tensor.shape[0], but saw: ".concat(t.length," vs. ").concat(e.shape[0]));const r=Math.max(...t);if(null!=a&&-1!==a&&r>=a)throw new Error("Max index must be < array size (".concat(r,"  vs. ").concat(a,")"));const o=new Iue([],n,e.dtype,a),s=S0(e,0);return t.forEach(((e,t)=>{o.setItem(e,s[t])})),o}(Rle("tensor",e,t,n),a,Rle("elementShape",e,t,n),Rle("numElements",e,t,n));return n.addTensorList(r),[r.idTensor]}case"TensorListReserve":case"EmptyTensorList":{const a=Rle("elementShape",e,t,n),r=Rle("elementDType",e,t,n);let o;o="TensorListReserve"===e.op?"numElements":"maxNumElements";const s=Rle(o,e,t,n),i=function(e,t,n,a){return new Iue([],e,t,a)}(a,r,0,"TensorListReserve"===e.op?-1:s);return n.addTensorList(i),[i.idTensor]}case"TensorListGather":{const a=Rle("tensorListId",e,t,n),r=Rle("indices",e,t,n),o=Rle("elementShape",e,t,n),s=Rle("elementDType",e,t,n);return[n.getTensorList(a.id).gather(r,s,o)]}case"TensorListStack":{const a=Rle("tensorListId",e,t,n),r=Rle("elementShape",e,t,n),o=Rle("elementDType",e,t,n),s=Rle("numElements",e,t,n);return[n.getTensorList(a.id).stack(r,o,s)]}case"TensorListFromTensor":{const a=function(e,t,n){const a=e.dtype;if(e.shape.length<1)throw new Error("Tensor must be at least a vector, but saw shape: ".concat(e.shape));if(e.dtype!==n)throw new Error("Invalid data types; op elements ".concat(e.dtype,", but list elements ").concat(n));yue(e.shape.slice(1),t,"TensorList shape mismatch: ");const r=S0(e);return new Iue(r,t,a)}(Rle("tensor",e,t,n),Rle("elementShape",e,t,n),Rle("elementDType",e,t,n));return n.addTensorList(a),[a.idTensor]}case"TensorListConcat":case"TensorListConcatV2":{const a=Rle("tensorListId",e,t,n),r=n.getTensorList(a.id),o=Rle("dtype",e,t,n),s=Rle("elementShape",e,t,n);return[r.concat(o,s)]}case"TensorListPushBack":{const a=Rle("tensorListId",e,t,n),r=Rle("tensor",e,t,n),o=n.getTensorList(a.id);return o.pushBack(r),[o.idTensor]}case"TensorListPopBack":{const a=Rle("tensorListId",e,t,n),r=Rle("elementShape",e,t,n),o=Rle("elementDType",e,t,n);return[n.getTensorList(a.id).popBack(r,o)]}case"TensorListSplit":{const a=Rle("tensor",e,t,n),r=Rle("elementShape",e,t,n),o=function(e,t,n){let a=0;const r=t.map((e=>(a+=e,a)));if(a!==e.shape[0])throw new Error("Expected sum of lengths to be equal to\n          tensor.shape[0], but sum of lengths is\n        ".concat(a,", and tensor's shape is: ").concat(e.shape));const o=wue(e.shape.slice(1),n),s=0===a?0:e.size/a,i=uX((()=>{const n=[];e=iJ(e,[1,a,s]);for(let a=0;a<t.length;++a){const i=[0,0===a?0:r[a-1],0],c=[1,t[a],s];n[a]=iJ(pJ(e,i,c),o)}return e.dispose(),n})),c=new Iue([],n,e.dtype,t.length);for(let l=0;l<i.length;l++)c.setItem(l,i[l]);return c}(a,Rle("lengths",e,t,n),r);return n.addTensorList(o),[o.idTensor]}case"TensorListLength":{const a=Rle("tensorListId",e,t,n);return[EY(n.getTensorList(a.id).size(),"int32")]}case"TensorListResize":{const a=Rle("tensorListId",e,t,n),r=Rle("size",e,t,n),o=n.getTensorList(a.id).resize(r);return n.addTensorList(o),[o.idTensor]}default:throw TypeError("Node type ".concat(e.op," is not implemented"))}};function Nue(e,t,n){const[a,r]=Rle("fusedOps",e,t,n),o="biasadd"===a,s=!o,i="prelu"===r,c="fusedbatchnorm"===a,l=Rle("numArgs",e,t,n);if(o){if(i&&2!==l)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!i&&o&&1!==l)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd must have one extra argument: bias.")}if(c)throw new Error("FusedConv2d and DepthwiseConv2d with FusedBatchNorm is not supported");const u=Rle("strides",e,t,n),d=Mle(e,t,n),h=Rle("dataFormat",e,t,n).toUpperCase(),p=Rle("dilations",e,t,n);let[f,m]=Rle("args",e,t,n);s&&(m=f,f=void 0);return{stride:u,pad:d,dataFormat:h,dilations:p,biasArg:f,preluArg:m,activationFunc:r,leakyreluAlpha:Rle("leakyreluAlpha",e,t,n)}}function Cue(e,t,n){return{boxes:Rle("boxes",e,t,n),scores:Rle("scores",e,t,n),maxOutputSize:Rle("maxOutputSize",e,t,n),iouThreshold:Rle("iouThreshold",e,t,n),scoreThreshold:Rle("scoreThreshold",e,t,n),softNmsSigma:Rle("softNmsSigma",e,t,n)}}class Tue{get id(){return this.handle.id}constructor(e,t){this.keyDType=e,this.valueDType=t,this.handle=EY(0),this.tensorMap=new Map,hX(this.handle)}clearAndClose(){this.tensorMap.forEach((e=>e.dispose())),this.tensorMap.clear(),this.handle.dispose()}size(){return this.tensorMap.size}tensorSize(){return EY(this.size(),"int32")}async import(e,t){this.checkKeyAndValueTensor(e,t);const n=await e.data();return this.tensorMap.forEach((e=>e.dispose())),this.tensorMap.clear(),uX((()=>{const e=S0(t),a=n.length,r=e.length;BU(a===r,(()=>"The number of elements doesn't match, keys has "+"".concat(a," elements, the values has ").concat(r," ")+"elements."));for(let t=0;t<a;t++){const a=n[t],r=e[t];hX(r),this.tensorMap.set(a,r)}return this.handle}))}async find(e,t){this.checkKeyAndValueTensor(e,t);const n=await e.data();return uX((()=>{const e=[];for(let a=0;a<n.length;a++){const r=n[a],o=this.findWithDefault(r,t);e.push(o)}return i0(e)}))}findWithDefault(e,t){const n=this.tensorMap.get(e);return null!=n?n:t}checkKeyAndValueTensor(e,t){if(e.dtype!==this.keyDType)throw new Error("Expect key dtype ".concat(this.keyDType,", but got ")+"".concat(e.dtype));if(t.dtype!==this.valueDType)throw new Error("Expect value dtype ".concat(this.valueDType,", but got ")+"".concat(t.dtype))}}function Eue(e,t,n,a){let r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:uX;const o=((e,t,n)=>{switch(e.category){case"arithmetic":return r((()=>function(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:_;switch(e.op){case"BiasAdd":case"AddV2":case"Add":return[a.add(Rle("a",e,t,n),Rle("b",e,t,n))];case"AddN":return[a.addN(Rle("tensors",e,t,n))];case"FloorMod":case"Mod":return[a.mod(Rle("a",e,t,n),Rle("b",e,t,n))];case"Mul":return[a.mul(Rle("a",e,t,n),Rle("b",e,t,n))];case"RealDiv":case"Div":return[a.div(Rle("a",e,t,n),Rle("b",e,t,n))];case"DivNoNan":return[a.divNoNan(Rle("a",e,t,n),Rle("b",e,t,n))];case"FloorDiv":return[a.floorDiv(Rle("a",e,t,n),Rle("b",e,t,n))];case"Sub":return[a.sub(Rle("a",e,t,n),Rle("b",e,t,n))];case"Minimum":return[a.minimum(Rle("a",e,t,n),Rle("b",e,t,n))];case"Maximum":return[a.maximum(Rle("a",e,t,n),Rle("b",e,t,n))];case"Pow":return[a.pow(Rle("a",e,t,n),Rle("b",e,t,n))];case"SquaredDifference":return[a.squaredDifference(Rle("a",e,t,n),Rle("b",e,t,n))];default:throw TypeError("Node type ".concat(e.op," is not implemented"))}}(e,t,n)));case"basic_math":return r((()=>function(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:_;switch(e.op){case"Abs":case"ComplexAbs":return[a.abs(Rle("x",e,t,n))];case"Acos":return[a.acos(Rle("x",e,t,n))];case"Acosh":return[a.acosh(Rle("x",e,t,n))];case"Asin":return[a.asin(Rle("x",e,t,n))];case"Asinh":return[a.asinh(Rle("x",e,t,n))];case"Atan":return[a.atan(Rle("x",e,t,n))];case"Atan2":return[a.atan2(Rle("x",e,t,n),Rle("y",e,t,n))];case"Atanh":return[a.atanh(Rle("x",e,t,n))];case"Ceil":return[a.ceil(Rle("x",e,t,n))];case"Complex":return[a.complex(Rle("real",e,t,n),Rle("imag",e,t,n))];case"Cos":return[a.cos(Rle("x",e,t,n))];case"Cosh":return[a.cosh(Rle("x",e,t,n))];case"Elu":return[a.elu(Rle("x",e,t,n))];case"Erf":return[a.erf(Rle("x",e,t,n))];case"Exp":return[a.exp(Rle("x",e,t,n))];case"Expm1":return[a.expm1(Rle("x",e,t,n))];case"Floor":return[a.floor(Rle("x",e,t,n))];case"Log":return[a.log(Rle("x",e,t,n))];case"Log1p":return[a.log1p(Rle("x",e,t,n))];case"Imag":return[a.imag(Rle("x",e,t,n))];case"Neg":return[a.neg(Rle("x",e,t,n))];case"Reciprocal":return[a.reciprocal(Rle("x",e,t,n))];case"Real":return[a.real(Rle("x",e,t,n))];case"Relu":return[a.relu(Rle("x",e,t,n))];case"Round":return[a.round(Rle("x",e,t,n))];case"Selu":return[a.selu(Rle("x",e,t,n))];case"Sigmoid":return[a.sigmoid(Rle("x",e,t,n))];case"Sin":return[a.sin(Rle("x",e,t,n))];case"Sign":return[a.sign(Rle("x",e,t,n))];case"Sinh":return[a.sinh(Rle("x",e,t,n))];case"Softplus":return[a.softplus(Rle("x",e,t,n))];case"Sqrt":return[a.sqrt(Rle("x",e,t,n))];case"Square":return[a.square(Rle("x",e,t,n))];case"Tanh":return[a.tanh(Rle("x",e,t,n))];case"Tan":return[a.tan(Rle("x",e,t,n))];case"ClipByValue":return[a.clipByValue(Rle("x",e,t,n),Rle("clipValueMin",e,t,n),Rle("clipValueMax",e,t,n))];case"Relu6":return[a.relu6(Rle("x",e,t,n))];case"Rsqrt":return[a.rsqrt(_le(e.inputNames[0],t,n))];case"LeakyRelu":return[a.leakyRelu(Rle("x",e,t,n),Rle("alpha",e,t,n))];case"Prelu":return[a.prelu(Rle("x",e,t,n),Rle("alpha",e,t,n))];case"IsNan":return[a.isNaN(_le(e.inputNames[0],t,n))];case"IsInf":return[a.isInf(_le(e.inputNames[0],t,n))];case"IsFinite":return[a.isFinite(_le(e.inputNames[0],t,n))];default:throw TypeError("Node type ".concat(e.op," is not implemented"))}}(e,t,n)));case"control":return Sue(e,t,n);case"convolution":return r((()=>function(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:_;switch(e.op){case"Conv1D":{const r=Rle("stride",e,t,n),o=Rle("pad",e,t,n),s=Rle("dataFormat",e,t,n).toUpperCase(),i=Rle("dilation",e,t,n);return[a.conv1d(Rle("x",e,t,n),Rle("filter",e,t,n),r,o,s,i)]}case"Conv2D":{const r=Rle("strides",e,t,n),o=Mle(e,t,n),s=Rle("dataFormat",e,t,n).toUpperCase(),i=Rle("dilations",e,t,n);return[a.conv2d(Rle("x",e,t,n),Rle("filter",e,t,n),[r[1],r[2]],o,s,[i[1],i[2]])]}case"_FusedConv2D":{const{stride:r,pad:o,dataFormat:s,dilations:i,biasArg:c,preluArg:l,activationFunc:u,leakyreluAlpha:d}=Nue(e,t,n);return[a.fused.conv2d({x:Rle("x",e,t,n),filter:Rle("filter",e,t,n),strides:[r[1],r[2]],pad:o,dataFormat:s,dilations:[i[1],i[2]],bias:c,activation:u,preluActivationWeights:l,leakyreluAlpha:d})]}case"FusedDepthwiseConv2dNative":{const{stride:r,pad:o,dataFormat:s,dilations:i,biasArg:c,preluArg:l,activationFunc:u,leakyreluAlpha:d}=Nue(e,t,n);return[a.fused.depthwiseConv2d({x:Rle("x",e,t,n),filter:Rle("filter",e,t,n),strides:[r[1],r[2]],pad:o,dataFormat:s,dilations:[i[1],i[2]],bias:c,activation:u,preluActivationWeights:l,leakyreluAlpha:d})]}case"Conv2DBackpropInput":case"Conv2dTranspose":{const r=Rle("outputShape",e,t,n),o=Rle("strides",e,t,n),s=Mle(e,t,n);return[a.conv2dTranspose(Rle("x",e,t,n),Rle("filter",e,t,n),r,[o[1],o[2]],s)]}case"DepthwiseConv2dNative":case"DepthwiseConv2d":{const r=Rle("strides",e,t,n),o=Mle(e,t,n),s=Rle("dilations",e,t,n),i=Rle("dataFormat",e,t,n).toUpperCase();return[a.depthwiseConv2d(Rle("input",e,t,n),Rle("filter",e,t,n),[r[1],r[2]],o,i,[s[1],s[2]])]}case"Conv3D":{const r=Rle("strides",e,t,n),o=Rle("pad",e,t,n),s=Rle("dataFormat",e,t,n).toUpperCase(),i=Rle("dilations",e,t,n);return[a.conv3d(Rle("x",e,t,n),Rle("filter",e,t,n),[r[1],r[2],r[3]],o,s,[i[1],i[2],i[3]])]}case"AvgPool":{const r=Rle("strides",e,t,n),o=Rle("pad",e,t,n),s=Rle("kernelSize",e,t,n);return[a.avgPool(Rle("x",e,t,n),[s[1],s[2]],[r[1],r[2]],o)]}case"MaxPool":{const r=Rle("strides",e,t,n),o=Rle("pad",e,t,n),s=Rle("kernelSize",e,t,n);return[a.maxPool(Rle("x",e,t,n),[s[1],s[2]],[r[1],r[2]],o)]}case"MaxPoolWithArgmax":{const r=Rle("strides",e,t,n),o=Rle("pad",e,t,n),s=Rle("kernelSize",e,t,n),i=Rle("includeBatchInIndex",e,t,n),{result:c,indexes:l}=a.maxPoolWithArgmax(Rle("x",e,t,n),[s[1],s[2]],[r[1],r[2]],o,i);return[c,l]}case"AvgPool3D":{const r=Rle("strides",e,t,n),o=Rle("pad",e,t,n),s=Rle("kernelSize",e,t,n);return[a.avgPool3d(Rle("x",e,t,n),[s[1],s[2],s[3]],[r[1],r[2],r[3]],o)]}case"MaxPool3D":{const r=Rle("strides",e,t,n),o=Rle("pad",e,t,n),s=Rle("kernelSize",e,t,n);return[a.maxPool3d(Rle("x",e,t,n),[s[1],s[2],s[3]],[r[1],r[2],r[3]],o)]}case"Dilation2D":{const r=Rle("strides",e,t,n),o=Rle("pad",e,t,n),s=Rle("dilations",e,t,n),i=r[1],c=r[2],l=s[1],u=s[2];return[a.dilation2d(Rle("x",e,t,n),Rle("filter",e,t,n),[i,c],o,[l,u],"NHWC")]}default:throw TypeError("Node type ".concat(e.op," is not implemented"))}}(e,t,n)));case"creation":return r((()=>function(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:_;switch(e.op){case"Fill":{const r=Rle("shape",e,t,n),o=Rle("dtype",e,t,n),s=Rle("value",e,t,n);return[a.fill(r,s,o)]}case"LinSpace":{const r=Rle("start",e,t,n),o=Rle("stop",e,t,n),s=Rle("num",e,t,n);return[a.linspace(r,o,s)]}case"Multinomial":{const r=Rle("logits",e,t,n),o=Rle("numSamples",e,t,n),s=Rle("seed",e,t,n);return[a.multinomial(r,o,s)]}case"OneHot":{const r=Rle("indices",e,t,n),o=Rle("depth",e,t,n),s=Rle("onValue",e,t,n),i=Rle("offValue",e,t,n),c=Rle("dtype",e,t,n);return[a.oneHot(r,o,s,i,c)]}case"Ones":return[a.ones(Rle("shape",e,t,n),Rle("dtype",e,t,n))];case"OnesLike":return[a.onesLike(Rle("x",e,t,n))];case"RandomStandardNormal":return[a.randomStandardNormal(Rle("shape",e,t,n),Rle("dtype",e,t,n),Rle("seed",e,t,n))];case"RandomUniform":return[a.randomUniform(Rle("shape",e,t,n),Rle("minval",e,t,n),Rle("maxval",e,t,n),Rle("dtype",e,t,n))];case"RandomUniformInt":return[a.randomUniformInt(Rle("shape",e,t,n),Rle("minval",e,t,n),Rle("maxval",e,t,n),Rle("seed",e,t,n))];case"Range":{const r=Rle("start",e,t,n),o=Rle("stop",e,t,n),s=Rle("step",e,t,n);return[a.range(r,o,s,Rle("dtype",e,t,n))]}case"TruncatedNormal":{const r=Rle("shape",e,t,n),o=Rle("mean",e,t,n),s=Rle("stdDev",e,t,n),i=Rle("seed",e,t,n);return[a.truncatedNormal(r,o,s,Rle("dtype",e,t,n),i)]}case"Zeros":return[a.zeros(Rle("shape",e,t,n),Rle("dtype",e,t,n))];case"ZerosLike":return[a.zerosLike(Rle("x",e,t,n))];default:throw TypeError("Node type ".concat(e.op," is not implemented"))}}(e,t,n)));case"dynamic":return async function(e,t,n,a){let r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:_;switch(e.op){case"NonMaxSuppressionV5":{const{boxes:a,scores:o,maxOutputSize:s,iouThreshold:i,scoreThreshold:c,softNmsSigma:l}=Cue(e,t,n),u=await r.image.nonMaxSuppressionWithScoreAsync(a,o,s,i,c,l);return[u.selectedIndices,u.selectedScores]}case"NonMaxSuppressionV4":{const{boxes:a,scores:o,maxOutputSize:s,iouThreshold:i,scoreThreshold:c}=Cue(e,t,n),l=Rle("padToMaxOutputSize",e,t,n),u=await r.image.nonMaxSuppressionPaddedAsync(a,o,s,i,c,l);return[u.selectedIndices,u.validOutputs]}case"NonMaxSuppressionV3":case"NonMaxSuppressionV2":{const{boxes:a,scores:o,maxOutputSize:s,iouThreshold:i,scoreThreshold:c}=Cue(e,t,n);return[await r.image.nonMaxSuppressionAsync(a,o,s,i,c)]}case"Where":{const a=r.cast(Rle("condition",e,t,n),"bool"),o=[await r.whereAsync(a)];return a.dispose(),o}case"ListDiff":return r.setdiff1dAsync(Rle("x",e,t,n),Rle("y",e,t,n));default:throw TypeError("Node type ".concat(e.op," is not implemented"))}}(e,t,n);case"evaluation":return r((()=>function(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:_;switch(e.op){case"LowerBound":{const r=Rle("sortedSequence",e,t,n),o=Rle("values",e,t,n);return[a.lowerBound(r,o)]}case"TopKV2":{const r=Rle("x",e,t,n),o=Rle("k",e,t,n),s=Rle("sorted",e,t,n),i=a.topk(r,o,s);return[i.values,i.indices]}case"UpperBound":{const r=Rle("sortedSequence",e,t,n),o=Rle("values",e,t,n);return[a.upperBound(r,o)]}case"Unique":{const r=Rle("x",e,t,n),o=a.unique(r);return[o.values,o.indices]}case"UniqueV2":{const r=Rle("x",e,t,n),o=Rle("axis",e,t,n),s=a.unique(r,o);return[s.values,s.indices]}default:throw TypeError("Node type ".concat(e.op," is not implemented"))}}(e,t,n)));case"image":return r((()=>function(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:_;switch(e.op){case"ResizeBilinear":{const r=Rle("images",e,t,n),o=Rle("size",e,t,n),s=Rle("alignCorners",e,t,n),i=Rle("halfPixelCenters",e,t,n);return[a.image.resizeBilinear(r,[o[0],o[1]],s,i)]}case"ResizeNearestNeighbor":{const r=Rle("images",e,t,n),o=Rle("size",e,t,n),s=Rle("alignCorners",e,t,n),i=Rle("halfPixelCenters",e,t,n);return[a.image.resizeNearestNeighbor(r,[o[0],o[1]],s,i)]}case"CropAndResize":{const r=Rle("image",e,t,n),o=Rle("boxes",e,t,n),s=Rle("boxInd",e,t,n),i=Rle("cropSize",e,t,n),c=Rle("method",e,t,n),l=Rle("extrapolationValue",e,t,n);return[a.image.cropAndResize(r,o,s,i,c,l)]}case"ImageProjectiveTransformV3":{const r=Rle("images",e,t,n),o=Rle("transforms",e,t,n),s=Rle("outputShape",e,t,n),i=Rle("fillValue",e,t,n),c=Rle("interpolation",e,t,n),l=Rle("fillMode",e,t,n);return[a.image.transform(r,o,c.toLowerCase(),l.toLowerCase(),i,s)]}default:throw TypeError("Node type ".concat(e.op," is not implemented"))}}(e,t,n)));case"graph":return r((()=>function(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:_;switch(e.op){case"Const":return t[e.name];case"PlaceholderWithDefault":const r=Rle("default",e,t,n);return[_le(e.name,t,n)||r];case"Placeholder":return[_le(e.name,t,n)];case"Identity":case"StopGradient":case"FakeQuantWithMinMaxVars":case"Snapshot":return[Lle(Rle("x",e,t,n))];case"IdentityN":return Rle("x",e,t,n).map((e=>Lle(e)));case"Shape":return[a.tensor1d(Rle("x",e,t,n).shape,"int32")];case"ShapeN":return Rle("x",e,t,n).map((e=>a.tensor1d(e.shape)));case"Size":return[a.scalar(Rle("x",e,t,n).size,"int32")];case"Rank":return[a.scalar(Rle("x",e,t,n).rank,"int32")];case"NoOp":return[a.scalar(1)];case"Print":const o=Rle("x",e,t,n),s=Rle("data",e,t,n),i=Rle("message",e,t,n),c=Rle("summarize",e,t,n);console.warn("The graph has a tf.print() operation,usually used for debugging, which slows down performance."),console.log(i);for(let e=0;e<s.length;e++)console.log(Array.prototype.slice.call(s[e].dataSync()).slice(0,c));return[o];default:throw TypeError("Node type ".concat(e.op," is not implemented"))}}(e,t,n)));case"logical":return r((()=>function(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:_;switch(e.op){case"Equal":return[a.equal(Rle("a",e,t,n),Rle("b",e,t,n))];case"NotEqual":return[a.notEqual(Rle("a",e,t,n),Rle("b",e,t,n))];case"Greater":return[a.greater(Rle("a",e,t,n),Rle("b",e,t,n))];case"GreaterEqual":return[a.greaterEqual(Rle("a",e,t,n),Rle("b",e,t,n))];case"Less":return[a.less(Rle("a",e,t,n),Rle("b",e,t,n))];case"LessEqual":return[a.lessEqual(Rle("a",e,t,n),Rle("b",e,t,n))];case"LogicalAnd":return[a.logicalAnd(Rle("a",e,t,n),Rle("b",e,t,n))];case"LogicalNot":return[a.logicalNot(Rle("a",e,t,n))];case"LogicalOr":return[a.logicalOr(Rle("a",e,t,n),Rle("b",e,t,n))];case"Select":case"SelectV2":return[a.where(Rle("condition",e,t,n),Rle("a",e,t,n),Rle("b",e,t,n))];case"BitwiseAnd":return[a.bitwiseAnd(Rle("a",e,t,n),Rle("b",e,t,n))];default:throw TypeError("Node type ".concat(e.op," is not implemented"))}}(e,t,n)));case"matrices":return r((()=>function(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:_;switch(e.op){case"BatchMatMul":case"BatchMatMulV2":case"MatMul":return[a.matMul(Rle("a",e,t,n),Rle("b",e,t,n),Rle("transposeA",e,t,n),Rle("transposeB",e,t,n))];case"Einsum":return[a.einsum(Rle("equation",e,t,n),...Rle("tensors",e,t,n))];case"Transpose":return[a.transpose(Rle("x",e,t,n),Rle("perm",e,t,n))];case"_FusedMatMul":const[r,o]=Rle("fusedOps",e,t,n),s="biasadd"===r,i="prelu"===o,c=Rle("numArgs",e,t,n),l=Rle("leakyreluAlpha",e,t,n);if(s){if(i&&2!==c)throw new Error("Fused MatMul with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!i&&1!==c)throw new Error("Fused MatMul with BiasAdd must have one extra argument: bias.")}const[u,d]=Rle("args",e,t,n);return[a.fused.matMul({a:Rle("a",e,t,n),b:Rle("b",e,t,n),transposeA:Rle("transposeA",e,t,n),transposeB:Rle("transposeB",e,t,n),bias:u,activation:o,preluActivationWeights:d,leakyreluAlpha:l})];case"MatrixBandPart":return[a.linalg.bandPart(Rle("a",e,t,n),Rle("numLower",e,t,n),Rle("numUpper",e,t,n))];default:throw TypeError("Node type ".concat(e.op," is not implemented"))}}(e,t,n)));case"normalization":return r((()=>function(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:_;switch(e.op){case"EuclideanNorm":return[a.euclideanNorm(Rle("x",e,t,n),Rle("axis",e,t,n),Rle("keepDims",e,t,n))];case"FusedBatchNorm":case"FusedBatchNormV2":case"FusedBatchNormV3":return[a.batchNorm(Rle("x",e,t,n),Rle("mean",e,t,n),Rle("variance",e,t,n),Rle("offset",e,t,n),Rle("scale",e,t,n),Rle("epsilon",e,t,n))];case"LRN":return[a.localResponseNormalization(Rle("x",e,t,n),Rle("radius",e,t,n),Rle("bias",e,t,n),Rle("alpha",e,t,n),Rle("beta",e,t,n))];case"Softmax":return[a.softmax(Rle("x",e,t,n))];case"LogSoftmax":return[a.logSoftmax(Rle("x",e,t,n))];default:throw TypeError("Node type ".concat(e.op," is not implemented"))}}(e,t,n)));case"ragged":return r((()=>function(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:_;switch(e.op){case"RaggedGather":{const{outputNestedSplits:r,outputDenseValues:o}=a.raggedGather(Rle("paramsNestedSplits",e,t,n),Rle("paramsDenseValues",e,t,n),Rle("indices",e,t,n),Rle("outputRaggedRank",e,t,n));return r.concat(o)}case"RaggedRange":{const{rtNestedSplits:r,rtDenseValues:o}=a.raggedRange(Rle("starts",e,t,n),Rle("limits",e,t,n),Rle("splits",e,t,n));return[r,o]}case"RaggedTensorToTensor":return[a.raggedTensorToTensor(Rle("shape",e,t,n),Rle("values",e,t,n),Rle("defaultValue",e,t,n),Rle("rowPartitionTensors",e,t,n),Rle("rowPartitionTypes",e,t,n))];default:throw TypeError("Node type ".concat(e.op," is not implemented"))}}(e,t,n)));case"reduction":return r((()=>function(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:_;switch(e.op){case"Max":{const r=Rle("axis",e,t,n),o=Rle("keepDims",e,t,n);return[a.max(Rle("x",e,t,n),r,o)]}case"Mean":{const r=Rle("axis",e,t,n),o=Rle("keepDims",e,t,n);return[a.mean(Rle("x",e,t,n),r,o)]}case"Min":{const r=Rle("axis",e,t,n),o=Rle("keepDims",e,t,n);return[a.min(Rle("x",e,t,n),r,o)]}case"Sum":{const r=Rle("axis",e,t,n),o=Rle("keepDims",e,t,n);return[a.sum(Rle("x",e,t,n),r,o)]}case"All":{const r=Rle("axis",e,t,n),o=Rle("keepDims",e,t,n);return[a.all(Rle("x",e,t,n),r,o)]}case"Any":{const r=Rle("axis",e,t,n),o=Rle("keepDims",e,t,n);return[a.any(Rle("x",e,t,n),r,o)]}case"ArgMax":{const r=Rle("axis",e,t,n);return[a.argMax(Rle("x",e,t,n),r)]}case"ArgMin":{const r=Rle("axis",e,t,n);return[a.argMin(Rle("x",e,t,n),r)]}case"Prod":{const r=Rle("axis",e,t,n),o=Rle("keepDims",e,t,n);return[a.prod(Rle("x",e,t,n),r,o)]}case"Cumprod":{const r=Rle("axis",e,t,n),o=Rle("exclusive",e,t,n),s=Rle("reverse",e,t,n);return[a.cumprod(Rle("x",e,t,n),r,o,s)]}case"Cumsum":{const r=Rle("axis",e,t,n),o=Rle("exclusive",e,t,n),s=Rle("reverse",e,t,n);return[a.cumsum(Rle("x",e,t,n),r,o,s)]}case"Bincount":const r=Rle("x",e,t,n),o=Rle("weights",e,t,n),s=Rle("size",e,t,n);return[a.bincount(r,o,s)];case"DenseBincount":{const r=Rle("x",e,t,n),o=Rle("weights",e,t,n),s=Rle("size",e,t,n),i=Rle("binaryOutput",e,t,n);return[a.denseBincount(r,o,s,i)]}default:throw TypeError("Node type ".concat(e.op," is not implemented"))}}(e,t,n)));case"slice_join":return r((()=>function(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:_;switch(e.op){case"ConcatV2":case"Concat":{const r=Rle("n",e,t,n),o=Rle("axis",e,t,n);let s=Rle("tensors",e,t,n);return s=s.slice(0,r),[a.concat(s,o)]}case"Gather":{const r=Rle("x",e,t,n),o=Rle("indices",e,t,n);return[a.gather(r,a.cast(o,"int32"),0)]}case"GatherV2":{const r=Rle("axis",e,t,n),o=Rle("batchDims",e,t,n),s=Rle("x",e,t,n),i=Rle("indices",e,t,n);return[a.gather(s,a.cast(i,"int32"),r,o)]}case"Reverse":{const r=Rle("dims",e,t,n),o=[];for(let e=0;e<r.length;e++)r[e]&&o.push(e);const s=Rle("x",e,t,n);return[a.reverse(s,o)]}case"ReverseV2":{const r=Rle("axis",e,t,n),o=Rle("x",e,t,n);return[a.reverse(o,r)]}case"Slice":{const r=Rle("begin",e,t,n),o=Rle("size",e,t,n);return[a.slice(Rle("x",e,t,n),r,o)]}case"StridedSlice":{const r=Rle("begin",e,t,n),o=Rle("end",e,t,n),s=Rle("strides",e,t,n),i=Rle("beginMask",e,t,n),c=Rle("endMask",e,t,n),l=Rle("ellipsisMask",e,t,n),u=Rle("newAxisMask",e,t,n),d=Rle("shrinkAxisMask",e,t,n),h=Rle("x",e,t,n);return[a.stridedSlice(h,r,o,s,i,c,l,u,d)]}case"Pack":return uX((()=>{const r=Rle("axis",e,t,n),o=Rle("tensors",e,t,n),s=o[0].shape,i=a.squeeze(o[0]).shape,c=o.map((e=>{const t=GU(e.shape,s);if(!t&&!GU(a.squeeze(e).shape,i))throw new Error("the input tensors shape does not match");return t?e:a.reshape(e,s)}));return[a.stack(c,r)]}));case"Unpack":{const r=Rle("axis",e,t,n),o=Rle("tensor",e,t,n);return a.unstack(o,r)}case"Tile":{const r=Rle("reps",e,t,n);return[a.tile(Rle("x",e,t,n),r)]}case"Split":case"SplitV":{const r=Rle("axis",e,t,n),o=Rle("numOrSizeSplits",e,t,n),s=Rle("x",e,t,n);return a.split(s,o,r)}case"ScatterNd":{const r=Rle("indices",e,t,n),o=Rle("values",e,t,n),s=Rle("shape",e,t,n);return[a.scatterND(r,o,s)]}case"GatherNd":{const r=Rle("x",e,t,n),o=Rle("indices",e,t,n);return[a.gatherND(r,o)]}case"SparseToDense":{const r=Rle("sparseIndices",e,t,n),o=Rle("outputShape",e,t,n),s=Rle("sparseValues",e,t,n),i=Rle("defaultValue",e,t,n);return[a.sparseToDense(r,s,o,s.dtype===i.dtype?i:a.cast(i,s.dtype))]}case"TensorScatterUpdate":{const r=Rle("indices",e,t,n),o=Rle("values",e,t,n),s=Rle("tensor",e,t,n);return[a.tensorScatterUpdate(s,r,o)]}default:throw TypeError("Node type ".concat(e.op," is not implemented"))}}(e,t,n)));case"sparse":return r((()=>function(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:_;switch(e.op){case"SparseFillEmptyRows":{const{outputIndices:r,outputValues:o,emptyRowIndicator:s,reverseIndexMap:i}=a.sparse.sparseFillEmptyRows(Rle("indices",e,t,n),Rle("values",e,t,n),Rle("denseShape",e,t,n),Rle("defaultValue",e,t,n));return[r,o,s,i]}case"SparseReshape":{const{outputIndices:r,outputShape:o}=a.sparse.sparseReshape(Rle("inputIndices",e,t,n),Rle("inputShape",e,t,n),Rle("newShape",e,t,n));return[r,o]}case"SparseSegmentMean":return[a.sparse.sparseSegmentMean(Rle("data",e,t,n),Rle("indices",e,t,n),Rle("segmentIds",e,t,n))];case"SparseSegmentSum":return[a.sparse.sparseSegmentSum(Rle("data",e,t,n),Rle("indices",e,t,n),Rle("segmentIds",e,t,n))];default:throw TypeError("Node type ".concat(e.op," is not implemented"))}}(e,t,n)));case"spectral":return r((()=>function(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:_;switch(e.op){case"FFT":return[a.fft(Rle("x",e,t,n))];case"IFFT":return[a.ifft(Rle("x",e,t,n))];case"RFFT":return[a.rfft(Rle("x",e,t,n))];case"IRFFT":return[a.irfft(Rle("x",e,t,n))];default:throw TypeError("Node type ".concat(e.op," is not implemented"))}}(e,t,n)));case"string":return r((()=>function(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:_;switch(e.op){case"StaticRegexReplace":return[a.string.staticRegexReplace(Rle("input",e,t,n),Rle("pattern",e,t,n),Rle("rewrite",e,t,n),Rle("replaceGlobal",e,t,n))];case"StringNGrams":{const{nGrams:r,nGramsSplits:o}=a.string.stringNGrams(Rle("data",e,t,n),Rle("dataSplits",e,t,n),Rle("separator",e,t,n),Rle("nGramWidths",e,t,n),Rle("leftPad",e,t,n),Rle("rightPad",e,t,n),Rle("padWidth",e,t,n),Rle("preserveShortSequences",e,t,n));return[r,o]}case"StringSplit":{const{indices:r,values:o,shape:s}=a.string.stringSplit(Rle("input",e,t,n),Rle("delimiter",e,t,n),Rle("skipEmpty",e,t,n));return[r,o,s]}case"StringToHashBucketFast":return[a.string.stringToHashBucketFast(Rle("input",e,t,n),Rle("numBuckets",e,t,n))];default:throw TypeError("Node type ".concat(e.op," is not implemented"))}}(e,t,n)));case"transformation":return r((()=>function(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:_;switch(e.op){case"Cast":return[a.cast(Rle("x",e,t,n),Rle("dtype",e,t,n))];case"ExpandDims":{const r=Rle("axis",e,t,n);return[a.expandDims(Rle("x",e,t,n),r)]}case"Squeeze":{const r=Rle("axis",e,t,n);return[a.squeeze(Rle("x",e,t,n),r)]}case"Reshape":return[a.reshape(Rle("x",e,t,n),Rle("shape",e,t,n))];case"EnsureShape":return[a.ensureShape(Rle("x",e,t,n),Rle("shape",e,t,n))];case"MirrorPad":return[a.mirrorPad(Rle("x",e,t,n),Rle("padding",e,t,n),Rle("mode",e,t,n))];case"PadV2":case"Pad":return[a.pad(Rle("x",e,t,n),Rle("padding",e,t,n),Rle("constantValue",e,t,n))];case"SpaceToBatchND":{const r=Rle("blockShape",e,t,n),o=Rle("paddings",e,t,n);return[a.spaceToBatchND(Rle("x",e,t,n),r,o)]}case"BatchToSpaceND":{const r=Rle("blockShape",e,t,n),o=Rle("crops",e,t,n);return[a.batchToSpaceND(Rle("x",e,t,n),r,o)]}case"DepthToSpace":{const r=Rle("blockSize",e,t,n),o=Rle("dataFormat",e,t,n).toUpperCase();return[a.depthToSpace(Rle("x",e,t,n),r,o)]}case"BroadcastTo":return[a.broadcastTo(Rle("x",e,t,n),Rle("shape",e,t,n))];case"BroadcastArgs":return[a.broadcastArgs(Rle("s0",e,t,n),Rle("s1",e,t,n))];default:throw TypeError("Node type ".concat(e.op," is not implemented"))}}(e,t,n)));case"hash_table":return(async(e,t,n,a)=>{switch(e.op){case"HashTable":case"HashTableV2":{const r=a.getHashTableHandleByName(e.name);if(null!=r)return[r];{const r=Rle("keyDType",e,t,n),o=Rle("valueDType",e,t,n),s=new Tue(r,o);return a.addHashTable(e.name,s),[s.handle]}}case"InitializeTable":case"InitializeTableV2":case"LookupTableImport":case"LookupTableImportV2":{const r=Rle("tableHandle",e,t,n,a),o=Rle("keys",e,t,n),s=Rle("values",e,t,n),i=a.getHashTableById(r.id);return[await i.import(o,s)]}case"LookupTableFind":case"LookupTableFindV2":{const r=Rle("tableHandle",e,t,n,a),o=Rle("keys",e,t,n),s=Rle("defaultValue",e,t,n),i=a.getHashTableById(r.id);return[await i.find(o,s)]}case"LookupTableSize":case"LookupTableSizeV2":{const r=Rle("tableHandle",e,t,n,a);return[a.getHashTableById(r.id).tensorSize()]}default:throw TypeError("Node type ".concat(e.op," is not implemented"))}})(e,t,n,a);case"custom":const o=Ele(e.op);if(o&&o.customExecutor)return o.customExecutor(new bue(e,t,n));throw TypeError("Custom op ".concat(e.op," is not registered."));default:throw TypeError("Unknown op '".concat(e.op,"'. File an issue at ")+"https://github.com/tensorflow/tfjs/issues so we can add it, or register a custom execution with tf.registerOp()")}})(e,t,n);return fG(o)?o.then((e=>[].concat(e))):[].concat(o)}class Rue{constructor(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{},a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{},r=arguments.length>4?arguments[4]:void 0;this.weightMap=e,this.tensorArrayMap=t,this.tensorListMap=n,this.functionMap=a,this.parseNodeNameCache=r,this.rootContext={id:0,frameName:"",iterationId:0},this.contexts=[this.rootContext],this.lastId=0,this.generateCurrentContextIds()}newFrame(e,t){return{id:e,frameName:t,iterationId:0}}set currentContext(e){this.contexts!==e&&(this.contexts=e,this.generateCurrentContextIds())}get currentContext(){return this.contexts}get currentContextId(){return this._currentContextIds[0]}get currentContextIds(){return this._currentContextIds}generateCurrentContextIds(){const e=[];for(let t=0;t<this.contexts.length-1;t++){const n=this.contexts.slice(0,this.contexts.length-t);e.push(this.contextIdforContexts(n))}e.push(""),this._currentContextIds=e}contextIdforContexts(e){return e?e.map((e=>0===e.id&&0===e.iterationId?"":"".concat(e.frameName,"-").concat(e.iterationId))).join("/"):""}enterFrame(e){this.contexts&&(this.lastId++,this.contexts=this.contexts.slice(),this.contexts.push(this.newFrame(this.lastId,e)),this._currentContextIds.unshift(this.contextIdforContexts(this.contexts)))}exitFrame(){if(!(this.contexts&&this.contexts.length>1))throw new Error("Cannot exit frame, the context is empty");this.contexts=this.contexts.slice(),this.contexts.splice(-1),this.currentContextIds.shift()}nextIteration(){if(!(this.contexts&&this.contexts.length>0))throw new Error("Cannot increase frame iteration, the context is empty");{this.contexts=this.contexts.slice(),this.lastId++;const e=Object.assign({},this.contexts[this.contexts.length-1]);e.iterationId+=1,e.id=this.lastId,this.contexts.splice(-1,1,e),this._currentContextIds.splice(0,1,this.contextIdforContexts(this.contexts))}}getWeight(e){return this.weightMap[e]}addTensorArray(e){this.tensorArrayMap[e.id]=e}getTensorArray(e){return this.tensorArrayMap[e]}addTensorList(e){this.tensorListMap[e.id]=e}getTensorList(e){return this.tensorListMap[e]}dispose(e){for(const t in this.tensorArrayMap)this.tensorArrayMap[t].clearAndClose(e);for(const t in this.tensorListMap)this.tensorListMap[t].clearAndClose(e)}}function _ue(e,t,n,a){const r=new Set,o=[];let s=null,i=null;const c=new Set,l=new Set(Object.keys(e).map((e=>Dle(e)[0])));a=a||[];const u=new Set(a.map((e=>Dle(e.name)[0]))),d=[...t];for(;d.length>0;){const e=d.pop();(Lue(e)||Pue(e)||zue(e))&&null==s&&(s=e,i=s.children.map((e=>e.name)).filter((e=>r.has(e)))),r.add(e.name),null==n[e.name]&&(l.has(e.name)||u.has(e.name)||(0!==e.inputs.length?e.inputs.forEach((e=>{c.has(e.name)||(c.add(e.name),d.push(e))})):o.push(e.name)))}return{inputs:e,outputs:t,usedNodes:r,missingInputs:o,dynamicNode:s,syncInputs:i}}function Aue(e,t){const{usedNodes:n,inputs:a}=t,r=Object.keys(a).map((e=>Dle(e)[0])).map((t=>e.nodes[t])),o=e.initNodes||[],s=e=>n.has("string"===typeof e?e:e.name);function i(e){return[...new Map(e.map((e=>[e.name,e]))).values()]}const c=i([...r,...e.weights,...o]).filter(s),l=i([...c,...Object.values(e.nodes)]).filter(s),u=new Map(l.map((e=>[e.name,e]))),d={};for(const m of l){d[m.name]=d[m.name]||0;for(const e of m.children)s(e)||(d[e.name]=Number.POSITIVE_INFINITY),d[e.name]=(d[e.name]||0)+1}const h=Object.entries(d).filter((e=>{let[,t]=e;return 0===t})).map((e=>{let[t]=e;return t})),p=[...h];for(;h.length>0;){const e=h.pop(),t=u.get(e);for(const n of t.children.filter(s))0===--d[n.name]&&(p.push(n.name),h.push(n.name))}const f=function(e,t){const n=new Map(e.map((e=>[e.name,e]))),a=t.map((e=>e.name)),r=new Set(a);for(;a.length>0;){const e=a.pop(),t=n.get(e);for(const o of t.children)n.has(o.name)&&!r.has(o.name)&&(r.add(o.name),a.push(o.name))}const o=e.filter((e=>r.has(e.name)));return o}(p.map((e=>u.get(e))),c);return function(e,t){const n=new Map(e.map(((e,t)=>[e.name,t]))),a=new Set(t.map((e=>e.name))),r=e=>a.has("string"===typeof e?e:e.name),o=new Set(e.map((e=>e.name))),s=e=>o.has("string"===typeof e?e:e.name);for(const i of e){for(const e of i.children.filter(s)){if(!n.has(e.name))throw new Fue("Child ".concat(e.name," of node ").concat(i.name," is unreachable."));if(n.get(i.name)>n.get(e.name))throw new Fue("Node ".concat(i.name," is scheduled to run after its child ").concat(e.name,"."))}if(!r(i))for(const e of i.inputs){if(!n.has(e.name))throw new Fue("Input ".concat(e.name," of node ").concat(i.name," is unreachable."));if(n.get(e.name)>n.get(i.name))throw new Fue("Node ".concat(i.name," is scheduled to run before its input ").concat(e.name,"."))}}}(f,c),f}class Fue extends Error{constructor(e){super("NodesExecutionOrderError: ".concat(e))}}const Oue=new Set(["Switch","Merge","Enter","Exit","NextIteration","StatelessIf","StatelessWhile","if","While"]),Due=new Set(["NonMaxSuppressionV2","NonMaxSuppressionV3","NonMaxSuppressionV5","Where"]),Mue=new Set(["HashTable","HashTableV2","LookupTableImport","LookupTableImportV2","LookupTableFind","LookupTableFindV2","LookupTableSize","LookupTableSizeV2"]);function Lue(e){return Oue.has(e.op)}function Pue(e){return Due.has(e.op)}function zue(e){return Mue.has(e.op)}class Bue{get weightIds(){return this.parent?this.parent.weightIds:this._weightIds}get functionExecutorMap(){return this.parent?this.parent.functionExecutorMap:this._functionExecutorMap}get weightMap(){return this.parent?this.parent.weightMap:this._weightMap}set weightMap(e){const t=Object.keys(e).map((t=>e[t].map((e=>e.id))));this._weightIds=[].concat(...t),this._weightMap=e}set resourceManager(e){this._resourceManager=e}get inputs(){return this._inputs.map((e=>({name:e.name,shape:e.attrParams.shape?e.attrParams.shape.value:void 0,dtype:e.attrParams.dtype?e.attrParams.dtype.value:void 0})))}get outputs(){return this._outputs.map((e=>({name:e.name,shape:e.attrParams.shape?e.attrParams.shape.value:void 0,dtype:e.attrParams.dtype?e.attrParams.dtype.value:void 0})))}get inputNodes(){return this._inputs.map((e=>e.signatureKey||e.name))}get outputNodes(){return this._outputs.map((e=>{const t=e.signatureKey||e.name;return e.defaultOutput?"".concat(t,":").concat(e.defaultOutput):t}))}get functions(){return Object.keys(this._functions).reduce(((e,t)=>(e[t]=this._functions[t].signature,e)),{})}constructor(e,t){this.graph=e,this.parent=t,this.compiledMap=new Map,this.parseNodeNameCache=new Map,this._weightMap={},this.SEPARATOR=",",this._functions={},this._functionExecutorMap={},this.keepIntermediateTensors=!1,this._outputs=e.outputs,this._inputs=e.inputs,this._initNodes=e.initNodes,this._signature=e.signature,this._functions=e.functions,null!=e.functions&&Object.keys(e.functions).forEach((t=>{this._functionExecutorMap[t]=new Bue(e.functions[t],this)}))}getCompilationKey(e,t){const n=e.map((e=>e.name)).sort(),a=t.map((e=>e.name)).sort();return n.join(this.SEPARATOR)+"--"+a.join(this.SEPARATOR)}compile(e,t){const n=_ue(e,t,this.weightMap,this._initNodes),{missingInputs:a,dynamicNode:r,syncInputs:o}=n;if(null!=r)throw new Error("This execution contains the node '".concat(r.name,"', which has ")+"the dynamic op '".concat(r.op,"'. Please use ")+"model.executeAsync() instead. Alternatively, to avoid the "+"dynamic ops, specify the inputs [".concat(o,"]"));if(a.length>0){const n=t.map((e=>e.name)),r=Object.keys(e);throw new Error("Cannot compute the outputs [".concat(n,"] from the provided inputs ")+"[".concat(r,"]. Missing the following inputs: [").concat(a,"]"))}const s=Aue(this.graph,n),i=function(e){const t=new Map(e.map(((e,t)=>[e.name,t]))),n=Number.MAX_SAFE_INTEGER,a=e.map(((e,t)=>Lue(e)?n:t)),r=e=>{const n=a[t.get(e.name)];return null==n?-1:n},o=e.map(((e,t)=>e.children.map(r).reduce(((e,t)=>Math.max(e,t)),a[t]))),s=new Map;for(let i=0;i<e.length;++i){const t=o[i];if(t===n)continue;const a=e[i],r=e[t];s.has(r.name)||s.set(r.name,[]),s.get(r.name).push(a)}return s}(s);return{orderedNodes:s,nodeLiveUntilMap:i}}cloneAndKeepTensor(e){if(null==e)return null;const t=e.clone();return hX(t),t}cloneTensorList(e){if(!e)return null;return e.map((e=>this.cloneAndKeepTensor(e)))}cloneTensorMap(e){return Object.fromEntries(Object.entries(e).map((e=>{let[t,n]=e;return[t,this.cloneTensorList(n)]})))}execute(e,t){this.disposeIntermediateTensors(),e=this.mapInputs(e);const n=Object.keys(e).sort();this.checkInputs(e),this.checkInputShapeAndType(e),t=this.mapOutputs(t),this.checkOutputs(t);const a=n.map((e=>this.graph.nodes[Dle(e)[0]])),r=t.map((e=>Dle(e)[0])),o=new Set(r);let s=r.map((e=>this.graph.nodes[e]));0===s.length&&(s=this._outputs);const i=this.getCompilationKey(a,s);let c=this.compiledMap.get(i);null==c&&(c=this.compile(e,s),this.compiledMap.set(i,c));try{this.keepIntermediateTensors=yG().getBool("KEEP_INTERMEDIATE_TENSORS")}catch(B){this.keepIntermediateTensors=!1,console.warn(B.message)}const l={},u={};return uX((()=>{const n=new Rue(this.weightMap,l,u,this.functionExecutorMap,this.parseNodeNameCache),a=Object.assign({},this.weightMap);this.keepIntermediateTensors&&(this.clonedTensorsMap=this.cloneTensorMap(this.weightMap)),Object.keys(e).forEach((t=>{const[r,o]=Dle(t,n),s=[];s[o]=e[t],a[r]=s,this.keepIntermediateTensors&&(this.clonedTensorsMap[r]=this.cloneTensorList(s))}));const r=this.getFrozenTensorIds(a),{orderedNodes:s,nodeLiveUntilMap:i}=c;for(const e of s){if(a[e.name])continue;const t=Eue(e,a,n,this._resourceManager);if(fG(t))throw new Error("The execution of the op '".concat(e.op,"' returned a promise. ")+"Please use model.executeAsync() instead.");a[e.name]=t,this.keepIntermediateTensors&&(this.clonedTensorsMap[e.name]=this.cloneTensorList(t)),this.checkTensorForDisposalWithNodeLiveUntilInfo(e,a,n,r,o,i.get(e.name))}return null==this.parent&&n.dispose(r),t.map((e=>_le(e,a,n)))}))}getFrozenTensorIds(e){const t=[].concat.apply([],Object.keys(e).map((t=>e[t])).map((e=>e.map((e=>e.id)))));return new Set(t)}checkTensorForDisposal(e,t,n,a,r,o,s){if(!Lue(t)&&!o.has(e)){for(const a of n[e])null!=a&&(s[a.id]=(s[a.id]||0)+t.children.length);for(const e of t.inputs){if(Lue(e))continue;const t=Ale(e.name,n,a);if(null!=t)for(const e of t){if(!e||e.kept||r.has(e.id))continue;const t=s[e.id];1===t?(e.dispose(),delete s[e.id]):null!=t&&s[e.id]--}}}}checkTensorForDisposalWithNodeLiveUntilInfo(e,t,n,a,r,o){function s(e){return Lue(e)||r.has(e.name)}if(!Lue(e)&&null!=o)for(const i of o){if(s(i))continue;const e=Ale(i.name,t,n);for(const t of e)!t||t.kept||a.has(t.id)||t.dispose()}}async executeAsync(e,t){return this._executeAsync(e,t)}disposeIntermediateTensors(){this.clonedTensorsMap&&(Object.values(this.clonedTensorsMap).forEach((e=>{for(const t of e)t&&!t.isDisposed&&t.dispose()})),this.clonedTensorsMap=null)}getIntermediateTensors(){return this.clonedTensorsMap}async _executeAsync(e,t){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{},r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:{};this.disposeIntermediateTensors(),n||(e=this.mapInputs(e),this.checkInputs(e),this.checkInputShapeAndType(e),t=this.mapOutputs(t),this.checkOutputs(t));try{this.keepIntermediateTensors=yG().getBool("KEEP_INTERMEDIATE_TENSORS")}catch(B){this.keepIntermediateTensors=!1,console.warn(B.message)}const o=new Rue(this.weightMap,a,r,this.functionExecutorMap,this.parseNodeNameCache);this.keepIntermediateTensors&&(this.clonedTensorsMap=this.cloneTensorMap(this.weightMap));const s=await this.executeWithControlFlow(e,o,t,n),i=t.map((e=>_le(e,s,o))),c=i.map((e=>e.id)),l=Object.keys(e).map((t=>e[t].id)),u=new Set([...c,...l,...this.weightIds]);return Object.values(s).forEach((e=>{e.forEach((e=>{!e||e.isDisposed||u.has(e.id)||e.dispose()}))})),null==this.parent&&o.dispose(u),i}async executeFunctionAsync(e,t,n){const a=e.reduce(((e,t,n)=>(e[this.inputs[n].name]=t,e)),{});return this._executeAsync(a,this.outputNodes,!0,t,n)}async executeWithControlFlow(e,t,n,a){const r=Object.keys(e),o=r.map((e=>this.graph.nodes[Dle(e)[0]])),s=n.map((e=>Dle(e)[0])),i=new Set(s);let c=s.map((e=>this.graph.nodes[e]));0===c.length&&(c=this._outputs);const{usedNodes:l,missingInputs:u,dynamicNode:d,syncInputs:h}=_ue(e,c,this.weightMap,this._initNodes),p=[...o,...this.graph.weights,...this._initNodes||[]].map((e=>({node:e,contexts:t.currentContext}))),f=Object.assign({},this.weightMap);Object.keys(e).forEach((t=>{const[n,a]=Dle(t),r=[];r[a]=e[t],f[n]=r}));const m={},g=this.getFrozenTensorIds(f),b={};for(;p.length>0;){const e=this.processStack(o,p,t,f,b,g,i,m,l);await Promise.all(e)}null!=d||a||console.warn("This model execution did not contain any nodes with control flow or dynamic output shapes. You can use model.execute() instead.");const y=c.filter((e=>!Lue(e)&&!_le(e.name,f,t))).map((e=>e.name));if(y.length>0){let e="";throw null!=d&&(e="Alternatively, to avoid the dynamic ops, use model.execute() "+"and specify the inputs [".concat(h,"]")),new Error("Cannot compute the outputs [".concat(y,"] from the provided ")+"inputs [".concat(r,"]. Consider providing the following inputs: ")+"[".concat(u,"]. ").concat(e))}return f}processStack(e,t,n,a,r,o,s,i,c){const l=[];for(;t.length>0;){const e=t.pop();n.currentContext=e.contexts;let u="";if("Enter"===e.node.op&&Rle("isConstant",e.node,a,n)&&([u]=Fle(e.node.name,n)),null==a[e.node.name]){const d=Eue(e.node,a,n,this._resourceManager);u||([u]=Fle(e.node.name,n));const h=n.currentContext;fG(d)?l.push(d.then((l=>(a[u]=l,this.keepIntermediateTensors&&(this.clonedTensorsMap[u]=this.cloneTensorList(l)),n.currentContext=h,this.checkTensorForDisposal(u,e.node,a,n,o,s,i),this.processChildNodes(e.node,t,n,a,r,c),l)))):(a[u]=d,this.keepIntermediateTensors&&(this.clonedTensorsMap[u]=this.cloneTensorList(d)),this.checkTensorForDisposal(u,e.node,a,n,o,s,i),this.processChildNodes(e.node,t,n,a,r,c))}else this.processChildNodes(e.node,t,n,a,r,c)}return l}processChildNodes(e,t,n,a,r,o){e.children.forEach((e=>{const[s]=Fle(e.name,n);!r[s]&&o.has(e.name)&&("Merge"===e.op?e.inputNames.some((e=>!!_le(e,a,n)))&&(r[s]=!0,t.push({contexts:n.currentContext,node:e})):e.inputNames.every((e=>!!_le(e,a,n)))&&(r[s]=!0,t.push({contexts:n.currentContext,node:e})))}))}dispose(){Object.keys(this.weightMap).forEach((e=>this.weightMap[e].forEach((e=>e.dispose()))))}checkInputShapeAndType(e){Object.keys(e).forEach((t=>{const n=e[t],[a]=Dle(t),r=this.graph.nodes[a];if(r.attrParams.shape&&r.attrParams.shape.value){const e=r.attrParams.shape.value;BU(e.length===n.shape.length&&n.shape.every(((t,n)=>-1===e[n]||e[n]===t)),(()=>"The shape of dict['".concat(r.name,"'] provided in ")+"model.execute(dict) must be [".concat(e,"], but was ")+"[".concat(n.shape,"]")))}r.attrParams.dtype&&r.attrParams.dtype.value&&BU(n.dtype===r.attrParams.dtype.value,(()=>"The dtype of dict['".concat(r.name,"'] provided in ")+"model.execute(dict) must be "+"".concat(r.attrParams.dtype.value,", but was ").concat(n.dtype)))}))}mapInputs(e){var t,n;const a={};for(const r in e){const o=null===(n=null===(t=this._signature)||void 0===t?void 0:t.inputs)||void 0===n?void 0:n[r];null!=o?a[o.name]=e[r]:a[r]=e[r]}return a}checkInputs(e){const t=Object.keys(e).filter((e=>{const[t]=Dle(e);return null==this.graph.nodes[t]}));if(t.length>0)throw new Error("The dict provided in model.execute(dict) has "+"keys: [".concat(t,"] that are not part of graph"))}mapOutputs(e){return e.map((e=>{var t,n;const a=null===(n=null===(t=this._signature)||void 0===t?void 0:t.outputs)||void 0===n?void 0:n[e];return null!=a?a.name:e}),{})}checkOutputs(e){e.forEach((e=>{const[t]=Dle(e);if(!this.graph.nodes[t])throw new Error("The output '".concat(e,"' is not found in the graph"))}))}}class Wue{constructor(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};this.hashTableNameToHandle=e,this.hashTableMap=t}addHashTable(e,t){this.hashTableNameToHandle[e]=t.handle,this.hashTableMap[t.id]=t}getHashTableHandleByName(e){return this.hashTableNameToHandle[e]}getHashTableById(e){return this.hashTableMap[e]}dispose(){for(const e in this.hashTableMap)this.hashTableMap[e].clearAndClose(),delete this.hashTableMap[e];for(const e in this.hashTableNameToHandle)this.hashTableNameToHandle[e].dispose(),delete this.hashTableNameToHandle[e]}}const Vue="?tfjs-format=file",Uue="model.json";class Gue{get modelVersion(){return this.version}get inputNodes(){return this.executor.inputNodes}get outputNodes(){return this.executor.outputNodes}get inputs(){return this.executor.inputs}get outputs(){return this.executor.outputs}get weights(){return this.executor.weightMap}get metadata(){return this.artifacts.userDefinedMetadata}get modelSignature(){return this.signature}get modelStructuredOutputKeys(){return this.structuredOutputKeys}constructor(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:o;this.modelUrl=e,this.loadOptions=t,this.version="n/a",this.io=n,null==t&&(this.loadOptions={}),this.resourceManager=new Wue}findIOHandler(){const e=this.modelUrl;if(null!=e.load)this.handler=e;else if(null!=this.loadOptions.requestInit)this.handler=this.io.browserHTTPRequest(e,this.loadOptions);else{const t=this.io.getLoadHandlers(e,this.loadOptions);if(0===t.length)t.push(this.io.browserHTTPRequest(e,this.loadOptions));else if(t.length>1)throw new Error("Found more than one (".concat(t.length,") load handlers for ")+"URL '".concat([e],"'"));this.handler=t[0]}}load(){if(this.findIOHandler(),null==this.handler.load)throw new Error("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");const e=this.handler.load();return fG(e)?e.then((e=>null==e.getWeightStream?this.loadSync(e):this.loadStreaming(e))):this.loadSync(e)}loadSync(e){const t=this.io.decodeWeights(e.weightData,e.weightSpecs);return this.loadWithWeightMap(e,t)}async loadStreaming(e){if(null==e.getWeightStream)throw new Error("Model artifacts missing streamWeights function");const t=await wX(e.getWeightStream(),e.weightSpecs);return this.loadWithWeightMap(e,t)}loadWithWeightMap(e,t){this.artifacts=e;const n=this.artifacts.modelTopology;let a=this.artifacts.signature;if(null!=this.artifacts.userDefinedMetadata){const e=this.artifacts.userDefinedMetadata;null!=e.signature&&(a=e.signature),null!=e.structuredOutputKeys&&(this.structuredOutputKeys=e.structuredOutputKeys)}if(this.signature=a,this.version="".concat(n.versions.producer,".").concat(n.versions.minConsumer),this.executor=new Bue(nue.Instance.transformGraph(n,this.signature)),this.executor.weightMap=this.convertTensorMapToTensorsMap(t),this.executor.resourceManager=this.resourceManager,null!=e.modelInitializer&&null!=e.modelInitializer.node){const t=nue.Instance.transformGraph(e.modelInitializer);this.initializer=new Bue(t),this.initializer.weightMap=this.executor.weightMap,this.initializer.resourceManager=this.resourceManager,this.initializerSignature=e.initializerSignature}return!0}async save(e,t){if("string"===typeof e){const t=this.io.getSaveHandlers(e);if(0===t.length)throw new Error("Cannot find any save handlers for URL '".concat(e,"'"));if(t.length>1)throw new Error("Found more than one (".concat(t.length,") save handlers for ")+"URL '".concat(e,"'"));e=t[0]}if(null==e.save)throw new Error("GraphModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");return e.save(this.artifacts)}addStructuredOutputNames(e){if(this.structuredOutputKeys){const t={};return(e instanceof Nq?[e]:e).forEach(((e,n)=>t[this.structuredOutputKeys[n]]=e)),t}return e}predict(e,t){const n=this.execute(e,this.outputNodes);return this.addStructuredOutputNames(n)}async predictAsync(e,t){const n=await this.executeAsync(e,this.outputNodes);return this.addStructuredOutputNames(n)}normalizeInputs(e){var t;if(!(e instanceof Nq)&&!Array.isArray(e)){const n=null===(t=this.signature)||void 0===t?void 0:t.inputs;if(null!=n)for(const t in n){const a=n[t];null!=a.resourceId&&(e[t]=this.resourceIdToCapturedInput[a.resourceId])}return e}e=Array.isArray(e)?e:[e];const n=Object.keys(this.resourceIdToCapturedInput).length;if(e.length+n!==this.inputNodes.length)throw new Error("Input tensor count mismatch, the graph model has ".concat(this.inputNodes.length-n," non-resource placeholders, while there are ").concat(e.length," input tensors provided."));let a=0;return this.inputNodes.reduce(((t,n)=>{var r,o,s;const i=null===(s=null===(o=null===(r=this.signature)||void 0===r?void 0:r.inputs)||void 0===o?void 0:o[n])||void 0===s?void 0:s.resourceId;return t[n]=null!=i?this.resourceIdToCapturedInput[i]:e[a++],t}),{})}normalizeOutputs(e){return e=e||this.outputNodes,Array.isArray(e)?e:[e]}executeInitializerGraph(){return null==this.initializer?[]:null==this.initializerSignature?this.initializer.execute({},[]):this.initializer.execute({},Object.keys(this.initializerSignature.outputs))}async executeInitializerGraphAsync(){return null==this.initializer?[]:null==this.initializerSignature?this.initializer.executeAsync({},[]):this.initializer.executeAsync({},Object.keys(this.initializerSignature.outputs))}setResourceIdToCapturedInput(e){if(this.resourceIdToCapturedInput={},this.initializerSignature){const t=this.initializerSignature.outputs,n=Object.keys(t);for(let a=0;a<n.length;a++){const r=t[n[a]];this.resourceIdToCapturedInput[r.resourceId]=e[a]}}}execute(e,t){null==this.resourceIdToCapturedInput&&this.setResourceIdToCapturedInput(this.executeInitializerGraph()),e=this.normalizeInputs(e),t=this.normalizeOutputs(t);const n=this.executor.execute(e,t);return n.length>1?n:n[0]}async executeAsync(e,t){null==this.resourceIdToCapturedInput&&this.setResourceIdToCapturedInput(await this.executeInitializerGraphAsync()),e=this.normalizeInputs(e),t=this.normalizeOutputs(t);const n=await this.executor.executeAsync(e,t);return n.length>1?n:n[0]}getIntermediateTensors(){return this.executor.getIntermediateTensors()}disposeIntermediateTensors(){this.executor.disposeIntermediateTensors()}convertTensorMapToTensorsMap(e){return Object.keys(e).reduce(((t,n)=>(t[n]=[e[n]],t)),{})}dispose(){this.executor.dispose(),this.initializer&&(this.initializer.dispose(),this.resourceIdToCapturedInput&&dX(this.resourceIdToCapturedInput)),this.resourceManager.dispose()}}async function Hue(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:o;if(null==e)throw new Error("modelUrl in loadGraphModel() cannot be null. Please provide a url or an IOHandler that loads the model");null==t&&(t={}),t.fromTFHub&&"string"===typeof e&&(e=function(e){e.endsWith("/")||(e+="/");return"".concat(e).concat(Uue).concat(Vue)}(e));const a=new Gue(e,t,n);return await a.load(),a}function jue(e,t,n,a){return new(n||(n=Promise))((function(r,o){function s(e){try{c(a.next(e))}catch(B){o(B)}}function i(e){try{c(a.throw(e))}catch(B){o(B)}}function c(e){var t;e.done?r(e.value):(t=e.value,t instanceof n?t:new n((function(e){e(t)}))).then(s,i)}c((a=a.apply(e,t||[])).next())}))}function Kue(e,t){var n,a,r,o,s={label:0,sent:function(){if(1&r[0])throw r[1];return r[1]},trys:[],ops:[]};return o={next:i(0),throw:i(1),return:i(2)},"function"===typeof Symbol&&(o[Symbol.iterator]=function(){return this}),o;function i(o){return function(i){return function(o){if(n)throw new TypeError("Generator is already executing.");for(;s;)try{if(n=1,a&&(r=2&o[0]?a.return:o[0]?a.throw||((r=a.return)&&r.call(a),0):a.next)&&!(r=r.call(a,o[1])).done)return r;switch(a=0,r&&(o=[2&o[0],r.value]),o[0]){case 0:case 1:r=o;break;case 4:return s.label++,{value:o[1],done:!1};case 5:s.label++,a=o[1],o=[0];continue;case 7:o=s.ops.pop(),s.trys.pop();continue;default:if(!(r=(r=s.trys).length>0&&r[r.length-1])&&(6===o[0]||2===o[0])){s=0;continue}if(3===o[0]&&(!r||o[1]>r[0]&&o[1]<r[3])){s.label=o[1];break}if(6===o[0]&&s.label<r[1]){s.label=r[1],r=o;break}if(r&&s.label<r[2]){s.label=r[2],s.ops.push(o);break}r[2]&&s.ops.pop(),s.trys.pop();continue}o=t.call(e,s)}catch(B){o=[6,B],a=0}finally{n=r=0}if(5&o[0])throw o[1];return{value:o[0]?o[1]:void 0,done:!0}}([o,i])}}}var que=function(e){return{startEndTensor:e,startPoint:pJ(e,[0,0],[-1,2]),endPoint:pJ(e,[0,2],[-1,2])}},Xue={strides:[8,16],anchors:[2,6]};function Yue(e,t){var n,a,r;if(e.topLeft instanceof Nq&&e.bottomRight instanceof Nq){var o=uX((function(){return[uJ([pJ(PY(t-1,e.topLeft),0,1),pJ(e.topLeft,1,1)]),uJ([PY(t-1,pJ(e.bottomRight,0,1)),pJ(e.bottomRight,1,1)])]}));n=o[0],a=o[1],null!=e.landmarks&&(r=uX((function(){var n=PY(d0([t-1,0]),e.landmarks),a=d0([1,-1]);return IY(n,a)})))}else{var s=e.topLeft,i=s[0],c=s[1],l=e.bottomRight,u=l[0],d=l[1];n=[t-1-i,c],a=[t-1-u,d],null!=e.landmarks&&(r=e.landmarks.map((function(e){return[t-1-e[0],e[1]]})))}var h={topLeft:n,bottomRight:a};return null!=r&&(h.landmarks=r),null!=e.probability&&(h.probability=e.probability instanceof Nq?e.probability.clone():e.probability),h}function Que(e,t){return uX((function(){var n;return n=e.hasOwnProperty("box")?e.box:e,s0(function(e,t){var n=IY(e.startPoint,t),a=IY(e.endPoint,t),r=EJ([n,a],1);return que(r)}(n,t).startEndTensor)}))}var Jue=function(){function e(e,t,n,a,r,o){this.blazeFaceModel=e,this.width=t,this.height=n,this.maxFaces=a,this.anchorsData=function(e,t,n){for(var a=[],r=0;r<n.strides.length;r++)for(var o=n.strides[r],s=Math.floor((t+o-1)/o),i=Math.floor((e+o-1)/o),c=n.anchors[r],l=0;l<s;l++)for(var u=o*(l+.5),d=0;d<i;d++)for(var h=o*(d+.5),p=0;p<c;p++)a.push([h,u]);return a}(t,n,Xue),this.anchors=h0(this.anchorsData),this.inputSizeData=[t,n],this.inputSize=d0([t,n]),this.iouThreshold=r,this.scoreThreshold=o}return e.prototype.getBoundingBoxes=function(e,t,n){return void 0===n&&(n=!0),jue(this,void 0,void 0,(function(){var a,r,o,s,i,c,l,u,d,h,p,f,m,g,b=this;return Kue(this,(function(y){switch(y.label){case 0:return a=uX((function(){var t=X1.resizeBilinear(e,[b.width,b.height]),n=IY(PY(kY(t,255),.5),2),a=b.blazeFaceModel.predict(n),r=s0(a),o=function(e,t,n){var a=pJ(e,[0,1],[-1,2]),r=vY(a,t),o=pJ(e,[0,3],[-1,2]),s=kY(o,n),i=kY(r,n),c=kY(s,2),l=PY(i,c),u=vY(i,c),d=IY(l,n),h=IY(u,n);return EJ([d,h],1)}(r,b.anchors,b.inputSize),s=pJ(r,[0,0],[-1,1]);return[r,o,s0(hJ(s))]})),r=a[0],o=a[1],s=a[2],i=console.warn,console.warn=function(){},c=X1.nonMaxSuppression(o,s,this.maxFaces,this.iouThreshold,this.scoreThreshold),console.warn=i,[4,c.array()];case 1:return l=y.sent(),c.dispose(),u=l.map((function(e){return pJ(o,[e,0],[1,-1])})),t?[3,3]:[4,Promise.all(u.map((function(e){return jue(b,void 0,void 0,(function(){var t;return Kue(this,(function(n){switch(n.label){case 0:return[4,e.array()];case 1:return t=n.sent(),e.dispose(),[2,t]}}))}))})))];case 2:u=y.sent(),y.label=3;case 3:for(d=e.shape[1],h=e.shape[2],p=t?kY([h,d],this.inputSize):[h/this.inputSizeData[0],d/this.inputSizeData[1]],f=[],m=function(e){var a=u[e],o=uX((function(){var o=que(a instanceof Nq?a:h0(a));if(!n)return o;var i,c=l[e];return i=t?pJ(b.anchors,[c,0],[1,2]):b.anchorsData[c],{box:o,landmarks:iJ(s0(pJ(r,[c,5],[1,-1])),[6,-1]),probability:pJ(s,[c],[1]),anchor:i}}));f.push(o)},g=0;g<u.length;g++)m(g);return o.dispose(),s.dispose(),r.dispose(),[2,{boxes:f,scaleFactor:p}]}}))}))},e.prototype.estimateFaces=function(e,t,n,a){return void 0===t&&(t=!1),void 0===n&&(n=!1),void 0===a&&(a=!0),jue(this,void 0,void 0,(function(){var r,o,s,i,c,l,u=this;return Kue(this,(function(d){switch(d.label){case 0:return r=function(e){return e instanceof Nq?[e.shape[0],e.shape[1]]:[e.height,e.width]}(e),o=r[1],s=uX((function(){return e instanceof Nq||(e=fQ(e)),gZ(bY(e,"float32"),0)})),[4,this.getBoundingBoxes(s,t,a)];case 1:return i=d.sent(),c=i.boxes,l=i.scaleFactor,s.dispose(),t?[2,c.map((function(e){var t=Que(e,l),r={topLeft:pJ(t,[0],[2]),bottomRight:pJ(t,[2],[2])};if(a){var s=e,i=s.landmarks,c=s.probability,u=s.anchor,d=IY(vY(i,u),l);r.landmarks=d,r.probability=c}return n&&(r=Yue(r,o)),r}))]:[2,Promise.all(c.map((function(e){return jue(u,void 0,void 0,(function(){var t,r,s,i,c,u,d,h,p,f,m,g=this;return Kue(this,(function(b){switch(b.label){case 0:return t=Que(e,l),a?[3,2]:[4,t.array()];case 1:return c=b.sent(),r={topLeft:c.slice(0,2),bottomRight:c.slice(2)},[3,4];case 2:return[4,Promise.all([e.landmarks,t,e.probability].map((function(e){return jue(g,void 0,void 0,(function(){return Kue(this,(function(t){return[2,e.array()]}))}))})))];case 3:s=b.sent(),i=s[0],c=s[1],u=s[2],d=e.anchor,p=(h=l)[0],f=h[1],m=i.map((function(e){return[(e[0]+d[0])*p,(e[1]+d[1])*f]})),r={topLeft:c.slice(0,2),bottomRight:c.slice(2),landmarks:m,probability:u},(y=e.box).startEndTensor.dispose(),y.startPoint.dispose(),y.endPoint.dispose(),e.landmarks.dispose(),e.probability.dispose(),b.label=4;case 4:return t.dispose(),n&&(r=Yue(r,o)),[2,r]}var y}))}))})))]}}))}))},e.prototype.dispose=function(){this.blazeFaceModel.dispose(),this.anchors.dispose(),this.inputSize.dispose()},e}();const Zue=(0,A.forwardRef)(((e,t)=>{let{videoId:n,canvasId:a,onFacesDetected:r,frameColor:o,receivePedictions:s,setInfo:i}=e;const c=(0,A.useRef)(null),l=(0,A.useRef)(null),u=(0,A.useRef)(),[d,h]=(0,A.useState)(null);(0,A.useImperativeHandle)(t,(()=>({stopFaceRecognition:b,startFaceRecognition:y})));const p=async()=>{await f();const e=await function(e){var t=void 0===e?{}:e,n=t.maxFaces,a=void 0===n?10:n,r=t.inputWidth,o=void 0===r?128:r,s=t.inputHeight,i=void 0===s?128:s,c=t.iouThreshold,l=void 0===c?.3:c,u=t.scoreThreshold,d=void 0===u?.75:u,h=t.modelUrl;return jue(this,void 0,void 0,(function(){var e;return Kue(this,(function(t){switch(t.label){case 0:return null==h?[3,2]:[4,Hue(h)];case 1:return e=t.sent(),[3,4];case 2:return[4,Hue("https://tfhub.dev/tensorflow/tfjs-model/blazeface/1/default/1",{fromTFHub:!0})];case 3:e=t.sent(),t.label=4;case 4:return[2,new Jue(e,o,i,a,l,d)]}}))}))}();m(e)},f=async()=>{try{await qu("webgl")}catch(e){await qu("cpu")}await Cu.ready()},m=async e=>{if(c.current&&c.current.readyState>=2){const t=c.current,n=await e.estimateFaces(t);h(n),r&&r(n),g(n)}u.current=requestAnimationFrame((()=>m(e)))},g=e=>{const t=l.current.getContext("2d");t.clearRect(0,0,l.current.width,l.current.height),t.drawImage(c.current,0,0,l.current.width,l.current.height),e.forEach((e=>{const[n,a,r,s]=e.topLeft.concat(e.bottomRight);t.strokeStyle=o,t.lineWidth=2,t.strokeRect(n,a,r-n,s-a)}))},b=()=>{if(c.current.srcObject){c.current.srcObject.getTracks().forEach((e=>e.stop()))}return u.current&&cancelAnimationFrame(u.current),d},y=async()=>{await(async()=>{const e=await navigator.mediaDevices.getUserMedia({video:{facingMode:"user"}});c.current.srcObject=e,c.current.onloadedmetadata=()=>{c.current.play(),l.current.width=c.current.videoWidth,l.current.height=c.current.videoHeight}})(),await p()};return(0,A.useEffect)((()=>()=>{u.current&&cancelAnimationFrame(u.current),b()}),[]),(0,Mn.jsxs)(Mn.Fragment,{children:[(0,Mn.jsx)("video",{ref:c,id:n,autoPlay:!0,muted:!0,className:"absolute inset-0 h-full w-full object-contain"}),(0,Mn.jsx)("canvas",{ref:l,id:a,className:"absolute inset-0 h-full w-full object-contain"})]})})),$ue=Zue;const ede=function(){const e=so(),{theme:t}=Xr((e=>e.main)),n=(0,A.useRef)(),a=(0,A.useRef)(),[r,o]=(0,A.useState)(!0),[s,i]=(0,A.useState)(!0),[c,l]=(0,A.useState)(null),[u,d]=(0,A.useState)(null),h=(e,t,n,a)=>{if(e.current)if(t)e.current.startFaceRecognition(),n(!1);else{const t=e.current.stopFaceRecognition();console.log(t),console.log(JSON.stringify(t)),a(t),n(!0)}},p=(e,t)=>{e.length},f=(e,t)=>{if(null===e||void 0===e||!e.length||null===t||void 0===t||!t.length)return 0;const n=e=>{const t=e.bottomRight[0]-e.topLeft[0],n=e.bottomRight[1]-e.topLeft[1];return{width:t,height:n,centerX:e.topLeft[0]+t/2,centerY:e.topLeft[1]+n/2}},a=n(e[0]),r=n(t[0]),o=Math.min(a.width/r.width,r.width/a.width)*Math.min(a.height/r.height,r.height/a.height),s=Math.abs(a.centerX-r.centerX),i=Math.abs(a.centerY-r.centerY),c=Math.sqrt(Math.pow(Math.max(a.width,r.width),2)+Math.pow(Math.max(a.height,r.height),2)),l=o*(1-Math.sqrt(Math.pow(s,2)+Math.pow(i,2))/c)*100;return l<80?0:l};(0,A.useEffect)((()=>{const e=async(e,t,n)=>{if(e.current)try{await e.current.startFaceRecognition(),t(!1)}catch(a){console.error("Failed to start ".concat(n," recognition"),a),_e.error("Unable to access the camera. Please allow permissions.")}};e(n,o,"first"),e(a,i,"second")}),[]),(0,A.useEffect)((()=>{"undefined"!==typeof window&&"undefined"!==typeof document&&(document.documentElement.classList.toggle("dark","dark"===t),window.localStorage.setItem("theme",t))}),[t]);const m="inline-flex items-center justify-center gap-2 rounded-full bg-indigo-600 px-5 py-2.5 text-sm font-semibold text-white shadow-sm shadow-indigo-500/30 transition hover:-translate-y-0.5 hover:bg-indigo-500 hover:shadow-indigo-500/40 focus-visible:outline focus-visible:outline-2 focus-visible:outline-offset-2 focus-visible:outline-indigo-500 active:translate-y-0 disabled:cursor-not-allowed disabled:opacity-60 dark:bg-indigo-500 dark:hover:bg-indigo-400",g="relative aspect-video w-full max-w-md overflow-hidden rounded-2xl border border-slate-200/70 bg-white/80 shadow-sm shadow-slate-200/70 backdrop-blur-sm dark:border-slate-700 dark:bg-slate-800/60 dark:shadow-none";return(0,Mn.jsx)(Mn.Fragment,{children:(0,Mn.jsxs)("div",{className:"flex min-h-screen flex-col bg-slate-50 text-slate-900 dark:bg-slate-900 dark:text-slate-100",children:[(0,Mn.jsx)($e,{position:"top-right"}),(0,Mn.jsx)(zn,{title:"Face Recognitions Demos",handleThemeChange:()=>{e(Er("light"===t?"dark":"light"))},theme:t}),(0,Mn.jsxs)("div",{className:"flex flex-col items-center gap-3 px-4 py-6 text-center",children:[(0,Mn.jsxs)("div",{className:"max-w-3xl space-y-3 text-sm leading-relaxed text-slate-600 dark:text-slate-300",children:[(0,Mn.jsx)("p",{children:"This app is a playground for experimenting with TensorFlow-based face recognition, showing how live video streams are analyzed and translated into detection data in real time."}),(0,Mn.jsx)("p",{children:"It is intentionally set up for rapid iteration, with the idea of expanding beyond faces into voice recognition and other biometric signals as the next step."})]}),(0,Mn.jsx)("button",{className:m,onClick:async()=>{if(!c||!u)return void _e.error("Finish both detections first, then press Stop Recognition on each video to capture results.");const e=await _e.promise(Promise.resolve(f(c,u)),{loading:"Comparing face frames...",success:"Comparison complete.",error:"Comparison failed. Please try again."}),t=Number(e).toFixed(1),n=e>=80?"Strong match: ".concat(t,"% similarity."):"Low match: ".concat(t,"% similarity.");_e(n,{icon:e>=80?"\u2705":"\u2139\ufe0f"})},children:"Compare Faces"})]}),(0,Mn.jsxs)("div",{className:"flex flex-1 flex-col gap-6 px-4 pb-8 lg:flex-row",children:[(0,Mn.jsxs)("div",{className:"flex w-full flex-col items-center gap-4 lg:w-1/2",children:[(0,Mn.jsx)("div",{className:"flex w-full flex-col gap-2 sm:flex-row sm:justify-center",children:(0,Mn.jsxs)("button",{className:"".concat(m," w-full sm:w-auto"),onClick:()=>h(n,r,o,l),children:[r?"Start":"Stop"," Recognition 1"]})}),(0,Mn.jsx)("div",{className:"".concat(g," mx-auto"),children:(0,Mn.jsx)($ue,{ref:n,videoId:"video1",canvasId:"canvas1",frameColor:"aqua",receivePedictions:p,setInfo:l})})]}),(0,Mn.jsxs)("div",{className:"flex w-full flex-col items-center gap-4 lg:w-1/2",children:[(0,Mn.jsx)("div",{className:"flex w-full flex-col gap-2 sm:flex-row sm:justify-center",children:(0,Mn.jsxs)("button",{className:"".concat(m," w-full sm:w-auto"),onClick:()=>h(a,s,i,d),children:[s?"Start":"Stop"," Recognition 2"]})}),(0,Mn.jsx)("div",{className:"".concat(g," mx-auto"),children:(0,Mn.jsx)($ue,{ref:a,videoId:"video2",canvasId:"canvas2",frameColor:"red",receivePedictions:p,setInfo:d})})]})]})]})})},tde=e=>{e&&e instanceof Function&&n.e(453).then(n.bind(n,453)).then((t=>{let{getCLS:n,getFID:a,getFCP:r,getLCP:o,getTTFB:s}=t;n(e),a(e),r(e),o(e),s(e)}))},nde=function(e){const t=function(e){const{thunk:t=!0,immutableCheck:n=!0,serializableCheck:a=!0,actionCreatorCheck:r=!0}=null!==e&&void 0!==e?e:{};let o=new er;return t&&("boolean"===typeof t?o.push(Ya):o.push(Qa(t.extraArgument))),o},{reducer:n,middleware:a,devTools:r=!0,preloadedState:o,enhancers:s}=e||{};let i,c;if("function"===typeof n)i=n;else{if(!Ha(n))throw new Error(Nr(1));i=Ka(n)}c="function"===typeof a?a(t):t();let l=qa;r&&(l=Za(z({trace:!1},"object"===typeof r&&r)));const u=function(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];return e=>(n,a)=>{const r=e(n,a);let o=()=>{throw new Error(Wa(15))};const s={getState:r.getState,dispatch:function(e){for(var t=arguments.length,n=new Array(t>1?t-1:0),a=1;a<t;a++)n[a-1]=arguments[a];return o(e,...n)}},i=t.map((e=>e(s)));return o=qa(...i)(r.dispatch),z(z({},r),{},{dispatch:o})}}(...c),d=sr(u);let h="function"===typeof s?s(d):d();return ja(i,o,l(...h))}({reducer:{main:Mr},devTools:!1});F.createRoot(document.getElementById("root")).render((0,Mn.jsx)(A.StrictMode,{children:(0,Mn.jsx)(to,{store:nde,children:(0,Mn.jsx)(ede,{})})})),tde()})()})();
//# sourceMappingURL=main.bc4848aa.js.map