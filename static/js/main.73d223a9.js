/*! For license information please see main.73d223a9.js.LICENSE.txt */
(()=>{var e={353:e=>{e.exports=n;var t=null;try{t=new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0,97,115,109,1,0,0,0,1,13,2,96,0,1,127,96,4,127,127,127,127,1,127,3,7,6,0,1,1,1,1,1,6,6,1,127,1,65,0,11,7,50,6,3,109,117,108,0,1,5,100,105,118,95,115,0,2,5,100,105,118,95,117,0,3,5,114,101,109,95,115,0,4,5,114,101,109,95,117,0,5,8,103,101,116,95,104,105,103,104,0,0,10,191,1,6,4,0,35,0,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,126,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,127,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,128,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,129,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,130,34,4,66,32,135,167,36,0,32,4,167,11])),{}).exports}catch(N){}function n(e,t,n){this.low=0|e,this.high=0|t,this.unsigned=!!n}function a(e){return!0===(e&&e.__isLong__)}n.prototype.__isLong__,Object.defineProperty(n.prototype,"__isLong__",{value:!0}),n.isLong=a;var r={},o={};function s(e,t){var n,a,s;return t?(s=0<=(e>>>=0)&&e<256)&&(a=o[e])?a:(n=c(e,(0|e)<0?-1:0,!0),s&&(o[e]=n),n):(s=-128<=(e|=0)&&e<128)&&(a=r[e])?a:(n=c(e,e<0?-1:0,!1),s&&(r[e]=n),n)}function i(e,t){if(isNaN(e))return t?b:g;if(t){if(e<0)return b;if(e>=p)return k}else{if(e<=-f)return I;if(e+1>=f)return w}return e<0?i(-e,t).neg():c(e%h|0,e/h|0,t)}function c(e,t,a){return new n(e,t,a)}n.fromInt=s,n.fromNumber=i,n.fromBits=c;var l=Math.pow;function u(e,t,n){if(0===e.length)throw Error("empty string");if("NaN"===e||"Infinity"===e||"+Infinity"===e||"-Infinity"===e)return g;if("number"===typeof t?(n=t,t=!1):t=!!t,(n=n||10)<2||36<n)throw RangeError("radix");var a;if((a=e.indexOf("-"))>0)throw Error("interior hyphen");if(0===a)return u(e.substring(1),t,n).neg();for(var r=i(l(n,8)),o=g,s=0;s<e.length;s+=8){var c=Math.min(8,e.length-s),d=parseInt(e.substring(s,s+c),n);if(c<8){var h=i(l(n,c));o=o.mul(h).add(i(d))}else o=(o=o.mul(r)).add(i(d))}return o.unsigned=t,o}function d(e,t){return"number"===typeof e?i(e,t):"string"===typeof e?u(e,t):c(e.low,e.high,"boolean"===typeof t?t:e.unsigned)}n.fromString=u,n.fromValue=d;var h=4294967296,p=h*h,f=p/2,m=s(1<<24),g=s(0);n.ZERO=g;var b=s(0,!0);n.UZERO=b;var y=s(1);n.ONE=y;var x=s(1,!0);n.UONE=x;var v=s(-1);n.NEG_ONE=v;var w=c(-1,2147483647,!1);n.MAX_VALUE=w;var k=c(-1,-1,!0);n.MAX_UNSIGNED_VALUE=k;var I=c(0,-2147483648,!1);n.MIN_VALUE=I;var S=n.prototype;S.toInt=function(){return this.unsigned?this.low>>>0:this.low},S.toNumber=function(){return this.unsigned?(this.high>>>0)*h+(this.low>>>0):this.high*h+(this.low>>>0)},S.toString=function(e){if((e=e||10)<2||36<e)throw RangeError("radix");if(this.isZero())return"0";if(this.isNegative()){if(this.eq(I)){var t=i(e),n=this.div(t),a=n.mul(t).sub(this);return n.toString(e)+a.toInt().toString(e)}return"-"+this.neg().toString(e)}for(var r=i(l(e,6),this.unsigned),o=this,s="";;){var c=o.div(r),u=(o.sub(c.mul(r)).toInt()>>>0).toString(e);if((o=c).isZero())return u+s;for(;u.length<6;)u="0"+u;s=""+u+s}},S.getHighBits=function(){return this.high},S.getHighBitsUnsigned=function(){return this.high>>>0},S.getLowBits=function(){return this.low},S.getLowBitsUnsigned=function(){return this.low>>>0},S.getNumBitsAbs=function(){if(this.isNegative())return this.eq(I)?64:this.neg().getNumBitsAbs();for(var e=0!=this.high?this.high:this.low,t=31;t>0&&0==(e&1<<t);t--);return 0!=this.high?t+33:t+1},S.isZero=function(){return 0===this.high&&0===this.low},S.eqz=S.isZero,S.isNegative=function(){return!this.unsigned&&this.high<0},S.isPositive=function(){return this.unsigned||this.high>=0},S.isOdd=function(){return 1===(1&this.low)},S.isEven=function(){return 0===(1&this.low)},S.equals=function(e){return a(e)||(e=d(e)),(this.unsigned===e.unsigned||this.high>>>31!==1||e.high>>>31!==1)&&(this.high===e.high&&this.low===e.low)},S.eq=S.equals,S.notEquals=function(e){return!this.eq(e)},S.neq=S.notEquals,S.ne=S.notEquals,S.lessThan=function(e){return this.comp(e)<0},S.lt=S.lessThan,S.lessThanOrEqual=function(e){return this.comp(e)<=0},S.lte=S.lessThanOrEqual,S.le=S.lessThanOrEqual,S.greaterThan=function(e){return this.comp(e)>0},S.gt=S.greaterThan,S.greaterThanOrEqual=function(e){return this.comp(e)>=0},S.gte=S.greaterThanOrEqual,S.ge=S.greaterThanOrEqual,S.compare=function(e){if(a(e)||(e=d(e)),this.eq(e))return 0;var t=this.isNegative(),n=e.isNegative();return t&&!n?-1:!t&&n?1:this.unsigned?e.high>>>0>this.high>>>0||e.high===this.high&&e.low>>>0>this.low>>>0?-1:1:this.sub(e).isNegative()?-1:1},S.comp=S.compare,S.negate=function(){return!this.unsigned&&this.eq(I)?I:this.not().add(y)},S.neg=S.negate,S.add=function(e){a(e)||(e=d(e));var t=this.high>>>16,n=65535&this.high,r=this.low>>>16,o=65535&this.low,s=e.high>>>16,i=65535&e.high,l=e.low>>>16,u=0,h=0,p=0,f=0;return p+=(f+=o+(65535&e.low))>>>16,h+=(p+=r+l)>>>16,u+=(h+=n+i)>>>16,u+=t+s,c((p&=65535)<<16|(f&=65535),(u&=65535)<<16|(h&=65535),this.unsigned)},S.subtract=function(e){return a(e)||(e=d(e)),this.add(e.neg())},S.sub=S.subtract,S.multiply=function(e){if(this.isZero())return g;if(a(e)||(e=d(e)),t)return c(t.mul(this.low,this.high,e.low,e.high),t.get_high(),this.unsigned);if(e.isZero())return g;if(this.eq(I))return e.isOdd()?I:g;if(e.eq(I))return this.isOdd()?I:g;if(this.isNegative())return e.isNegative()?this.neg().mul(e.neg()):this.neg().mul(e).neg();if(e.isNegative())return this.mul(e.neg()).neg();if(this.lt(m)&&e.lt(m))return i(this.toNumber()*e.toNumber(),this.unsigned);var n=this.high>>>16,r=65535&this.high,o=this.low>>>16,s=65535&this.low,l=e.high>>>16,u=65535&e.high,h=e.low>>>16,p=65535&e.low,f=0,b=0,y=0,x=0;return y+=(x+=s*p)>>>16,b+=(y+=o*p)>>>16,y&=65535,b+=(y+=s*h)>>>16,f+=(b+=r*p)>>>16,b&=65535,f+=(b+=o*h)>>>16,b&=65535,f+=(b+=s*u)>>>16,f+=n*p+r*h+o*u+s*l,c((y&=65535)<<16|(x&=65535),(f&=65535)<<16|(b&=65535),this.unsigned)},S.mul=S.multiply,S.divide=function(e){if(a(e)||(e=d(e)),e.isZero())throw Error("division by zero");var n,r,o;if(t)return this.unsigned||-2147483648!==this.high||-1!==e.low||-1!==e.high?c((this.unsigned?t.div_u:t.div_s)(this.low,this.high,e.low,e.high),t.get_high(),this.unsigned):this;if(this.isZero())return this.unsigned?b:g;if(this.unsigned){if(e.unsigned||(e=e.toUnsigned()),e.gt(this))return b;if(e.gt(this.shru(1)))return x;o=b}else{if(this.eq(I))return e.eq(y)||e.eq(v)?I:e.eq(I)?y:(n=this.shr(1).div(e).shl(1)).eq(g)?e.isNegative()?y:v:(r=this.sub(e.mul(n)),o=n.add(r.div(e)));if(e.eq(I))return this.unsigned?b:g;if(this.isNegative())return e.isNegative()?this.neg().div(e.neg()):this.neg().div(e).neg();if(e.isNegative())return this.div(e.neg()).neg();o=g}for(r=this;r.gte(e);){n=Math.max(1,Math.floor(r.toNumber()/e.toNumber()));for(var s=Math.ceil(Math.log(n)/Math.LN2),u=s<=48?1:l(2,s-48),h=i(n),p=h.mul(e);p.isNegative()||p.gt(r);)p=(h=i(n-=u,this.unsigned)).mul(e);h.isZero()&&(h=y),o=o.add(h),r=r.sub(p)}return o},S.div=S.divide,S.modulo=function(e){return a(e)||(e=d(e)),t?c((this.unsigned?t.rem_u:t.rem_s)(this.low,this.high,e.low,e.high),t.get_high(),this.unsigned):this.sub(this.div(e).mul(e))},S.mod=S.modulo,S.rem=S.modulo,S.not=function(){return c(~this.low,~this.high,this.unsigned)},S.and=function(e){return a(e)||(e=d(e)),c(this.low&e.low,this.high&e.high,this.unsigned)},S.or=function(e){return a(e)||(e=d(e)),c(this.low|e.low,this.high|e.high,this.unsigned)},S.xor=function(e){return a(e)||(e=d(e)),c(this.low^e.low,this.high^e.high,this.unsigned)},S.shiftLeft=function(e){return a(e)&&(e=e.toInt()),0===(e&=63)?this:e<32?c(this.low<<e,this.high<<e|this.low>>>32-e,this.unsigned):c(0,this.low<<e-32,this.unsigned)},S.shl=S.shiftLeft,S.shiftRight=function(e){return a(e)&&(e=e.toInt()),0===(e&=63)?this:e<32?c(this.low>>>e|this.high<<32-e,this.high>>e,this.unsigned):c(this.high>>e-32,this.high>=0?0:-1,this.unsigned)},S.shr=S.shiftRight,S.shiftRightUnsigned=function(e){if(a(e)&&(e=e.toInt()),0===(e&=63))return this;var t=this.high;return e<32?c(this.low>>>e|t<<32-e,t>>>e,this.unsigned):c(32===e?t:t>>>e-32,0,this.unsigned)},S.shru=S.shiftRightUnsigned,S.shr_u=S.shiftRightUnsigned,S.toSigned=function(){return this.unsigned?c(this.low,this.high,!1):this},S.toUnsigned=function(){return this.unsigned?this:c(this.low,this.high,!0)},S.toBytes=function(e){return e?this.toBytesLE():this.toBytesBE()},S.toBytesLE=function(){var e=this.high,t=this.low;return[255&t,t>>>8&255,t>>>16&255,t>>>24,255&e,e>>>8&255,e>>>16&255,e>>>24]},S.toBytesBE=function(){var e=this.high,t=this.low;return[e>>>24,e>>>16&255,e>>>8&255,255&e,t>>>24,t>>>16&255,t>>>8&255,255&t]},n.fromBytes=function(e,t,a){return a?n.fromBytesLE(e,t):n.fromBytesBE(e,t)},n.fromBytesLE=function(e,t){return new n(e[0]|e[1]<<8|e[2]<<16|e[3]<<24,e[4]|e[5]<<8|e[6]<<16|e[7]<<24,t)},n.fromBytesBE=function(e,t){return new n(e[4]<<24|e[5]<<16|e[6]<<8|e[7],e[0]<<24|e[1]<<16|e[2]<<8|e[3],t)}},730:(e,t,n)=>{"use strict";var a=n(43),r=n(853);function o(e){for(var t="https://reactjs.org/docs/error-decoder.html?invariant="+e,n=1;n<arguments.length;n++)t+="&args[]="+encodeURIComponent(arguments[n]);return"Minified React error #"+e+"; visit "+t+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}var s=new Set,i={};function c(e,t){l(e,t),l(e+"Capture",t)}function l(e,t){for(i[e]=t,e=0;e<t.length;e++)s.add(t[e])}var u=!("undefined"===typeof window||"undefined"===typeof window.document||"undefined"===typeof window.document.createElement),d=Object.prototype.hasOwnProperty,h=/^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/,p={},f={};function m(e,t,n,a,r,o,s){this.acceptsBooleans=2===t||3===t||4===t,this.attributeName=a,this.attributeNamespace=r,this.mustUseProperty=n,this.propertyName=e,this.type=t,this.sanitizeURL=o,this.removeEmptyString=s}var g={};"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach((function(e){g[e]=new m(e,0,!1,e,null,!1,!1)})),[["acceptCharset","accept-charset"],["className","class"],["htmlFor","for"],["httpEquiv","http-equiv"]].forEach((function(e){var t=e[0];g[t]=new m(t,1,!1,e[1],null,!1,!1)})),["contentEditable","draggable","spellCheck","value"].forEach((function(e){g[e]=new m(e,2,!1,e.toLowerCase(),null,!1,!1)})),["autoReverse","externalResourcesRequired","focusable","preserveAlpha"].forEach((function(e){g[e]=new m(e,2,!1,e,null,!1,!1)})),"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach((function(e){g[e]=new m(e,3,!1,e.toLowerCase(),null,!1,!1)})),["checked","multiple","muted","selected"].forEach((function(e){g[e]=new m(e,3,!0,e,null,!1,!1)})),["capture","download"].forEach((function(e){g[e]=new m(e,4,!1,e,null,!1,!1)})),["cols","rows","size","span"].forEach((function(e){g[e]=new m(e,6,!1,e,null,!1,!1)})),["rowSpan","start"].forEach((function(e){g[e]=new m(e,5,!1,e.toLowerCase(),null,!1,!1)}));var b=/[\-:]([a-z])/g;function y(e){return e[1].toUpperCase()}function x(e,t,n,a){var r=g.hasOwnProperty(t)?g[t]:null;(null!==r?0!==r.type:a||!(2<t.length)||"o"!==t[0]&&"O"!==t[0]||"n"!==t[1]&&"N"!==t[1])&&(function(e,t,n,a){if(null===t||"undefined"===typeof t||function(e,t,n,a){if(null!==n&&0===n.type)return!1;switch(typeof t){case"function":case"symbol":return!0;case"boolean":return!a&&(null!==n?!n.acceptsBooleans:"data-"!==(e=e.toLowerCase().slice(0,5))&&"aria-"!==e);default:return!1}}(e,t,n,a))return!0;if(a)return!1;if(null!==n)switch(n.type){case 3:return!t;case 4:return!1===t;case 5:return isNaN(t);case 6:return isNaN(t)||1>t}return!1}(t,n,r,a)&&(n=null),a||null===r?function(e){return!!d.call(f,e)||!d.call(p,e)&&(h.test(e)?f[e]=!0:(p[e]=!0,!1))}(t)&&(null===n?e.removeAttribute(t):e.setAttribute(t,""+n)):r.mustUseProperty?e[r.propertyName]=null===n?3!==r.type&&"":n:(t=r.attributeName,a=r.attributeNamespace,null===n?e.removeAttribute(t):(n=3===(r=r.type)||4===r&&!0===n?"":""+n,a?e.setAttributeNS(a,t,n):e.setAttribute(t,n))))}"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach((function(e){var t=e.replace(b,y);g[t]=new m(t,1,!1,e,null,!1,!1)})),"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach((function(e){var t=e.replace(b,y);g[t]=new m(t,1,!1,e,"http://www.w3.org/1999/xlink",!1,!1)})),["xml:base","xml:lang","xml:space"].forEach((function(e){var t=e.replace(b,y);g[t]=new m(t,1,!1,e,"http://www.w3.org/XML/1998/namespace",!1,!1)})),["tabIndex","crossOrigin"].forEach((function(e){g[e]=new m(e,1,!1,e.toLowerCase(),null,!1,!1)})),g.xlinkHref=new m("xlinkHref",1,!1,"xlink:href","http://www.w3.org/1999/xlink",!0,!1),["src","href","action","formAction"].forEach((function(e){g[e]=new m(e,1,!1,e.toLowerCase(),null,!0,!0)}));var v=a.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED,w=Symbol.for("react.element"),k=Symbol.for("react.portal"),I=Symbol.for("react.fragment"),S=Symbol.for("react.strict_mode"),N=Symbol.for("react.profiler"),C=Symbol.for("react.provider"),T=Symbol.for("react.context"),E=Symbol.for("react.forward_ref"),R=Symbol.for("react.suspense"),_=Symbol.for("react.suspense_list"),A=Symbol.for("react.memo"),F=Symbol.for("react.lazy");Symbol.for("react.scope"),Symbol.for("react.debug_trace_mode");var O=Symbol.for("react.offscreen");Symbol.for("react.legacy_hidden"),Symbol.for("react.cache"),Symbol.for("react.tracing_marker");var D=Symbol.iterator;function M(e){return null===e||"object"!==typeof e?null:"function"===typeof(e=D&&e[D]||e["@@iterator"])?e:null}var L,P=Object.assign;function z(e){if(void 0===L)try{throw Error()}catch(n){var t=n.stack.trim().match(/\n( *(at )?)/);L=t&&t[1]||""}return"\n"+L+e}var B=!1;function W(e,t){if(!e||B)return"";B=!0;var n=Error.prepareStackTrace;Error.prepareStackTrace=void 0;try{if(t)if(t=function(){throw Error()},Object.defineProperty(t.prototype,"props",{set:function(){throw Error()}}),"object"===typeof Reflect&&Reflect.construct){try{Reflect.construct(t,[])}catch(l){var a=l}Reflect.construct(e,[],t)}else{try{t.call()}catch(l){a=l}e.call(t.prototype)}else{try{throw Error()}catch(l){a=l}e()}}catch(l){if(l&&a&&"string"===typeof l.stack){for(var r=l.stack.split("\n"),o=a.stack.split("\n"),s=r.length-1,i=o.length-1;1<=s&&0<=i&&r[s]!==o[i];)i--;for(;1<=s&&0<=i;s--,i--)if(r[s]!==o[i]){if(1!==s||1!==i)do{if(s--,0>--i||r[s]!==o[i]){var c="\n"+r[s].replace(" at new "," at ");return e.displayName&&c.includes("<anonymous>")&&(c=c.replace("<anonymous>",e.displayName)),c}}while(1<=s&&0<=i);break}}}finally{B=!1,Error.prepareStackTrace=n}return(e=e?e.displayName||e.name:"")?z(e):""}function V(e){switch(e.tag){case 5:return z(e.type);case 16:return z("Lazy");case 13:return z("Suspense");case 19:return z("SuspenseList");case 0:case 2:case 15:return e=W(e.type,!1);case 11:return e=W(e.type.render,!1);case 1:return e=W(e.type,!0);default:return""}}function U(e){if(null==e)return null;if("function"===typeof e)return e.displayName||e.name||null;if("string"===typeof e)return e;switch(e){case I:return"Fragment";case k:return"Portal";case N:return"Profiler";case S:return"StrictMode";case R:return"Suspense";case _:return"SuspenseList"}if("object"===typeof e)switch(e.$$typeof){case T:return(e.displayName||"Context")+".Consumer";case C:return(e._context.displayName||"Context")+".Provider";case E:var t=e.render;return(e=e.displayName)||(e=""!==(e=t.displayName||t.name||"")?"ForwardRef("+e+")":"ForwardRef"),e;case A:return null!==(t=e.displayName||null)?t:U(e.type)||"Memo";case F:t=e._payload,e=e._init;try{return U(e(t))}catch(n){}}return null}function G(e){var t=e.type;switch(e.tag){case 24:return"Cache";case 9:return(t.displayName||"Context")+".Consumer";case 10:return(t._context.displayName||"Context")+".Provider";case 18:return"DehydratedFragment";case 11:return e=(e=t.render).displayName||e.name||"",t.displayName||(""!==e?"ForwardRef("+e+")":"ForwardRef");case 7:return"Fragment";case 5:return t;case 4:return"Portal";case 3:return"Root";case 6:return"Text";case 16:return U(t);case 8:return t===S?"StrictMode":"Mode";case 22:return"Offscreen";case 12:return"Profiler";case 21:return"Scope";case 13:return"Suspense";case 19:return"SuspenseList";case 25:return"TracingMarker";case 1:case 0:case 17:case 2:case 14:case 15:if("function"===typeof t)return t.displayName||t.name||null;if("string"===typeof t)return t}return null}function H(e){switch(typeof e){case"boolean":case"number":case"string":case"undefined":case"object":return e;default:return""}}function j(e){var t=e.type;return(e=e.nodeName)&&"input"===e.toLowerCase()&&("checkbox"===t||"radio"===t)}function K(e){e._valueTracker||(e._valueTracker=function(e){var t=j(e)?"checked":"value",n=Object.getOwnPropertyDescriptor(e.constructor.prototype,t),a=""+e[t];if(!e.hasOwnProperty(t)&&"undefined"!==typeof n&&"function"===typeof n.get&&"function"===typeof n.set){var r=n.get,o=n.set;return Object.defineProperty(e,t,{configurable:!0,get:function(){return r.call(this)},set:function(e){a=""+e,o.call(this,e)}}),Object.defineProperty(e,t,{enumerable:n.enumerable}),{getValue:function(){return a},setValue:function(e){a=""+e},stopTracking:function(){e._valueTracker=null,delete e[t]}}}}(e))}function q(e){if(!e)return!1;var t=e._valueTracker;if(!t)return!0;var n=t.getValue(),a="";return e&&(a=j(e)?e.checked?"true":"false":e.value),(e=a)!==n&&(t.setValue(e),!0)}function X(e){if("undefined"===typeof(e=e||("undefined"!==typeof document?document:void 0)))return null;try{return e.activeElement||e.body}catch(t){return e.body}}function Y(e,t){var n=t.checked;return P({},t,{defaultChecked:void 0,defaultValue:void 0,value:void 0,checked:null!=n?n:e._wrapperState.initialChecked})}function Q(e,t){var n=null==t.defaultValue?"":t.defaultValue,a=null!=t.checked?t.checked:t.defaultChecked;n=H(null!=t.value?t.value:n),e._wrapperState={initialChecked:a,initialValue:n,controlled:"checkbox"===t.type||"radio"===t.type?null!=t.checked:null!=t.value}}function J(e,t){null!=(t=t.checked)&&x(e,"checked",t,!1)}function Z(e,t){J(e,t);var n=H(t.value),a=t.type;if(null!=n)"number"===a?(0===n&&""===e.value||e.value!=n)&&(e.value=""+n):e.value!==""+n&&(e.value=""+n);else if("submit"===a||"reset"===a)return void e.removeAttribute("value");t.hasOwnProperty("value")?ee(e,t.type,n):t.hasOwnProperty("defaultValue")&&ee(e,t.type,H(t.defaultValue)),null==t.checked&&null!=t.defaultChecked&&(e.defaultChecked=!!t.defaultChecked)}function $(e,t,n){if(t.hasOwnProperty("value")||t.hasOwnProperty("defaultValue")){var a=t.type;if(!("submit"!==a&&"reset"!==a||void 0!==t.value&&null!==t.value))return;t=""+e._wrapperState.initialValue,n||t===e.value||(e.value=t),e.defaultValue=t}""!==(n=e.name)&&(e.name=""),e.defaultChecked=!!e._wrapperState.initialChecked,""!==n&&(e.name=n)}function ee(e,t,n){"number"===t&&X(e.ownerDocument)===e||(null==n?e.defaultValue=""+e._wrapperState.initialValue:e.defaultValue!==""+n&&(e.defaultValue=""+n))}var te=Array.isArray;function ne(e,t,n,a){if(e=e.options,t){t={};for(var r=0;r<n.length;r++)t["$"+n[r]]=!0;for(n=0;n<e.length;n++)r=t.hasOwnProperty("$"+e[n].value),e[n].selected!==r&&(e[n].selected=r),r&&a&&(e[n].defaultSelected=!0)}else{for(n=""+H(n),t=null,r=0;r<e.length;r++){if(e[r].value===n)return e[r].selected=!0,void(a&&(e[r].defaultSelected=!0));null!==t||e[r].disabled||(t=e[r])}null!==t&&(t.selected=!0)}}function ae(e,t){if(null!=t.dangerouslySetInnerHTML)throw Error(o(91));return P({},t,{value:void 0,defaultValue:void 0,children:""+e._wrapperState.initialValue})}function re(e,t){var n=t.value;if(null==n){if(n=t.children,t=t.defaultValue,null!=n){if(null!=t)throw Error(o(92));if(te(n)){if(1<n.length)throw Error(o(93));n=n[0]}t=n}null==t&&(t=""),n=t}e._wrapperState={initialValue:H(n)}}function oe(e,t){var n=H(t.value),a=H(t.defaultValue);null!=n&&((n=""+n)!==e.value&&(e.value=n),null==t.defaultValue&&e.defaultValue!==n&&(e.defaultValue=n)),null!=a&&(e.defaultValue=""+a)}function se(e){var t=e.textContent;t===e._wrapperState.initialValue&&""!==t&&null!==t&&(e.value=t)}function ie(e){switch(e){case"svg":return"http://www.w3.org/2000/svg";case"math":return"http://www.w3.org/1998/Math/MathML";default:return"http://www.w3.org/1999/xhtml"}}function ce(e,t){return null==e||"http://www.w3.org/1999/xhtml"===e?ie(t):"http://www.w3.org/2000/svg"===e&&"foreignObject"===t?"http://www.w3.org/1999/xhtml":e}var le,ue,de=(ue=function(e,t){if("http://www.w3.org/2000/svg"!==e.namespaceURI||"innerHTML"in e)e.innerHTML=t;else{for((le=le||document.createElement("div")).innerHTML="<svg>"+t.valueOf().toString()+"</svg>",t=le.firstChild;e.firstChild;)e.removeChild(e.firstChild);for(;t.firstChild;)e.appendChild(t.firstChild)}},"undefined"!==typeof MSApp&&MSApp.execUnsafeLocalFunction?function(e,t,n,a){MSApp.execUnsafeLocalFunction((function(){return ue(e,t)}))}:ue);function he(e,t){if(t){var n=e.firstChild;if(n&&n===e.lastChild&&3===n.nodeType)return void(n.nodeValue=t)}e.textContent=t}var pe={animationIterationCount:!0,aspectRatio:!0,borderImageOutset:!0,borderImageSlice:!0,borderImageWidth:!0,boxFlex:!0,boxFlexGroup:!0,boxOrdinalGroup:!0,columnCount:!0,columns:!0,flex:!0,flexGrow:!0,flexPositive:!0,flexShrink:!0,flexNegative:!0,flexOrder:!0,gridArea:!0,gridRow:!0,gridRowEnd:!0,gridRowSpan:!0,gridRowStart:!0,gridColumn:!0,gridColumnEnd:!0,gridColumnSpan:!0,gridColumnStart:!0,fontWeight:!0,lineClamp:!0,lineHeight:!0,opacity:!0,order:!0,orphans:!0,tabSize:!0,widows:!0,zIndex:!0,zoom:!0,fillOpacity:!0,floodOpacity:!0,stopOpacity:!0,strokeDasharray:!0,strokeDashoffset:!0,strokeMiterlimit:!0,strokeOpacity:!0,strokeWidth:!0},fe=["Webkit","ms","Moz","O"];function me(e,t,n){return null==t||"boolean"===typeof t||""===t?"":n||"number"!==typeof t||0===t||pe.hasOwnProperty(e)&&pe[e]?(""+t).trim():t+"px"}function ge(e,t){for(var n in e=e.style,t)if(t.hasOwnProperty(n)){var a=0===n.indexOf("--"),r=me(n,t[n],a);"float"===n&&(n="cssFloat"),a?e.setProperty(n,r):e[n]=r}}Object.keys(pe).forEach((function(e){fe.forEach((function(t){t=t+e.charAt(0).toUpperCase()+e.substring(1),pe[t]=pe[e]}))}));var be=P({menuitem:!0},{area:!0,base:!0,br:!0,col:!0,embed:!0,hr:!0,img:!0,input:!0,keygen:!0,link:!0,meta:!0,param:!0,source:!0,track:!0,wbr:!0});function ye(e,t){if(t){if(be[e]&&(null!=t.children||null!=t.dangerouslySetInnerHTML))throw Error(o(137,e));if(null!=t.dangerouslySetInnerHTML){if(null!=t.children)throw Error(o(60));if("object"!==typeof t.dangerouslySetInnerHTML||!("__html"in t.dangerouslySetInnerHTML))throw Error(o(61))}if(null!=t.style&&"object"!==typeof t.style)throw Error(o(62))}}function xe(e,t){if(-1===e.indexOf("-"))return"string"===typeof t.is;switch(e){case"annotation-xml":case"color-profile":case"font-face":case"font-face-src":case"font-face-uri":case"font-face-format":case"font-face-name":case"missing-glyph":return!1;default:return!0}}var ve=null;function we(e){return(e=e.target||e.srcElement||window).correspondingUseElement&&(e=e.correspondingUseElement),3===e.nodeType?e.parentNode:e}var ke=null,Ie=null,Se=null;function Ne(e){if(e=xr(e)){if("function"!==typeof ke)throw Error(o(280));var t=e.stateNode;t&&(t=wr(t),ke(e.stateNode,e.type,t))}}function Ce(e){Ie?Se?Se.push(e):Se=[e]:Ie=e}function Te(){if(Ie){var e=Ie,t=Se;if(Se=Ie=null,Ne(e),t)for(e=0;e<t.length;e++)Ne(t[e])}}function Ee(e,t){return e(t)}function Re(){}var _e=!1;function Ae(e,t,n){if(_e)return e(t,n);_e=!0;try{return Ee(e,t,n)}finally{_e=!1,(null!==Ie||null!==Se)&&(Re(),Te())}}function Fe(e,t){var n=e.stateNode;if(null===n)return null;var a=wr(n);if(null===a)return null;n=a[t];e:switch(t){case"onClick":case"onClickCapture":case"onDoubleClick":case"onDoubleClickCapture":case"onMouseDown":case"onMouseDownCapture":case"onMouseMove":case"onMouseMoveCapture":case"onMouseUp":case"onMouseUpCapture":case"onMouseEnter":(a=!a.disabled)||(a=!("button"===(e=e.type)||"input"===e||"select"===e||"textarea"===e)),e=!a;break e;default:e=!1}if(e)return null;if(n&&"function"!==typeof n)throw Error(o(231,t,typeof n));return n}var Oe=!1;if(u)try{var De={};Object.defineProperty(De,"passive",{get:function(){Oe=!0}}),window.addEventListener("test",De,De),window.removeEventListener("test",De,De)}catch(ue){Oe=!1}function Me(e,t,n,a,r,o,s,i,c){var l=Array.prototype.slice.call(arguments,3);try{t.apply(n,l)}catch(u){this.onError(u)}}var Le=!1,Pe=null,ze=!1,Be=null,We={onError:function(e){Le=!0,Pe=e}};function Ve(e,t,n,a,r,o,s,i,c){Le=!1,Pe=null,Me.apply(We,arguments)}function Ue(e){var t=e,n=e;if(e.alternate)for(;t.return;)t=t.return;else{e=t;do{0!==(4098&(t=e).flags)&&(n=t.return),e=t.return}while(e)}return 3===t.tag?n:null}function Ge(e){if(13===e.tag){var t=e.memoizedState;if(null===t&&(null!==(e=e.alternate)&&(t=e.memoizedState)),null!==t)return t.dehydrated}return null}function He(e){if(Ue(e)!==e)throw Error(o(188))}function je(e){return null!==(e=function(e){var t=e.alternate;if(!t){if(null===(t=Ue(e)))throw Error(o(188));return t!==e?null:e}for(var n=e,a=t;;){var r=n.return;if(null===r)break;var s=r.alternate;if(null===s){if(null!==(a=r.return)){n=a;continue}break}if(r.child===s.child){for(s=r.child;s;){if(s===n)return He(r),e;if(s===a)return He(r),t;s=s.sibling}throw Error(o(188))}if(n.return!==a.return)n=r,a=s;else{for(var i=!1,c=r.child;c;){if(c===n){i=!0,n=r,a=s;break}if(c===a){i=!0,a=r,n=s;break}c=c.sibling}if(!i){for(c=s.child;c;){if(c===n){i=!0,n=s,a=r;break}if(c===a){i=!0,a=s,n=r;break}c=c.sibling}if(!i)throw Error(o(189))}}if(n.alternate!==a)throw Error(o(190))}if(3!==n.tag)throw Error(o(188));return n.stateNode.current===n?e:t}(e))?Ke(e):null}function Ke(e){if(5===e.tag||6===e.tag)return e;for(e=e.child;null!==e;){var t=Ke(e);if(null!==t)return t;e=e.sibling}return null}var qe=r.unstable_scheduleCallback,Xe=r.unstable_cancelCallback,Ye=r.unstable_shouldYield,Qe=r.unstable_requestPaint,Je=r.unstable_now,Ze=r.unstable_getCurrentPriorityLevel,$e=r.unstable_ImmediatePriority,et=r.unstable_UserBlockingPriority,tt=r.unstable_NormalPriority,nt=r.unstable_LowPriority,at=r.unstable_IdlePriority,rt=null,ot=null;var st=Math.clz32?Math.clz32:function(e){return e>>>=0,0===e?32:31-(it(e)/ct|0)|0},it=Math.log,ct=Math.LN2;var lt=64,ut=4194304;function dt(e){switch(e&-e){case 1:return 1;case 2:return 2;case 4:return 4;case 8:return 8;case 16:return 16;case 32:return 32;case 64:case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:return 4194240&e;case 4194304:case 8388608:case 16777216:case 33554432:case 67108864:return 130023424&e;case 134217728:return 134217728;case 268435456:return 268435456;case 536870912:return 536870912;case 1073741824:return 1073741824;default:return e}}function ht(e,t){var n=e.pendingLanes;if(0===n)return 0;var a=0,r=e.suspendedLanes,o=e.pingedLanes,s=268435455&n;if(0!==s){var i=s&~r;0!==i?a=dt(i):0!==(o&=s)&&(a=dt(o))}else 0!==(s=n&~r)?a=dt(s):0!==o&&(a=dt(o));if(0===a)return 0;if(0!==t&&t!==a&&0===(t&r)&&((r=a&-a)>=(o=t&-t)||16===r&&0!==(4194240&o)))return t;if(0!==(4&a)&&(a|=16&n),0!==(t=e.entangledLanes))for(e=e.entanglements,t&=a;0<t;)r=1<<(n=31-st(t)),a|=e[n],t&=~r;return a}function pt(e,t){switch(e){case 1:case 2:case 4:return t+250;case 8:case 16:case 32:case 64:case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:return t+5e3;default:return-1}}function ft(e){return 0!==(e=-1073741825&e.pendingLanes)?e:1073741824&e?1073741824:0}function mt(){var e=lt;return 0===(4194240&(lt<<=1))&&(lt=64),e}function gt(e){for(var t=[],n=0;31>n;n++)t.push(e);return t}function bt(e,t,n){e.pendingLanes|=t,536870912!==t&&(e.suspendedLanes=0,e.pingedLanes=0),(e=e.eventTimes)[t=31-st(t)]=n}function yt(e,t){var n=e.entangledLanes|=t;for(e=e.entanglements;n;){var a=31-st(n),r=1<<a;r&t|e[a]&t&&(e[a]|=t),n&=~r}}var xt=0;function vt(e){return 1<(e&=-e)?4<e?0!==(268435455&e)?16:536870912:4:1}var wt,kt,It,St,Nt,Ct=!1,Tt=[],Et=null,Rt=null,_t=null,At=new Map,Ft=new Map,Ot=[],Dt="mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" ");function Mt(e,t){switch(e){case"focusin":case"focusout":Et=null;break;case"dragenter":case"dragleave":Rt=null;break;case"mouseover":case"mouseout":_t=null;break;case"pointerover":case"pointerout":At.delete(t.pointerId);break;case"gotpointercapture":case"lostpointercapture":Ft.delete(t.pointerId)}}function Lt(e,t,n,a,r,o){return null===e||e.nativeEvent!==o?(e={blockedOn:t,domEventName:n,eventSystemFlags:a,nativeEvent:o,targetContainers:[r]},null!==t&&(null!==(t=xr(t))&&kt(t)),e):(e.eventSystemFlags|=a,t=e.targetContainers,null!==r&&-1===t.indexOf(r)&&t.push(r),e)}function Pt(e){var t=yr(e.target);if(null!==t){var n=Ue(t);if(null!==n)if(13===(t=n.tag)){if(null!==(t=Ge(n)))return e.blockedOn=t,void Nt(e.priority,(function(){It(n)}))}else if(3===t&&n.stateNode.current.memoizedState.isDehydrated)return void(e.blockedOn=3===n.tag?n.stateNode.containerInfo:null)}e.blockedOn=null}function zt(e){if(null!==e.blockedOn)return!1;for(var t=e.targetContainers;0<t.length;){var n=Yt(e.domEventName,e.eventSystemFlags,t[0],e.nativeEvent);if(null!==n)return null!==(t=xr(n))&&kt(t),e.blockedOn=n,!1;var a=new(n=e.nativeEvent).constructor(n.type,n);ve=a,n.target.dispatchEvent(a),ve=null,t.shift()}return!0}function Bt(e,t,n){zt(e)&&n.delete(t)}function Wt(){Ct=!1,null!==Et&&zt(Et)&&(Et=null),null!==Rt&&zt(Rt)&&(Rt=null),null!==_t&&zt(_t)&&(_t=null),At.forEach(Bt),Ft.forEach(Bt)}function Vt(e,t){e.blockedOn===t&&(e.blockedOn=null,Ct||(Ct=!0,r.unstable_scheduleCallback(r.unstable_NormalPriority,Wt)))}function Ut(e){function t(t){return Vt(t,e)}if(0<Tt.length){Vt(Tt[0],e);for(var n=1;n<Tt.length;n++){var a=Tt[n];a.blockedOn===e&&(a.blockedOn=null)}}for(null!==Et&&Vt(Et,e),null!==Rt&&Vt(Rt,e),null!==_t&&Vt(_t,e),At.forEach(t),Ft.forEach(t),n=0;n<Ot.length;n++)(a=Ot[n]).blockedOn===e&&(a.blockedOn=null);for(;0<Ot.length&&null===(n=Ot[0]).blockedOn;)Pt(n),null===n.blockedOn&&Ot.shift()}var Gt=v.ReactCurrentBatchConfig,Ht=!0;function jt(e,t,n,a){var r=xt,o=Gt.transition;Gt.transition=null;try{xt=1,qt(e,t,n,a)}finally{xt=r,Gt.transition=o}}function Kt(e,t,n,a){var r=xt,o=Gt.transition;Gt.transition=null;try{xt=4,qt(e,t,n,a)}finally{xt=r,Gt.transition=o}}function qt(e,t,n,a){if(Ht){var r=Yt(e,t,n,a);if(null===r)Ha(e,t,a,Xt,n),Mt(e,a);else if(function(e,t,n,a,r){switch(t){case"focusin":return Et=Lt(Et,e,t,n,a,r),!0;case"dragenter":return Rt=Lt(Rt,e,t,n,a,r),!0;case"mouseover":return _t=Lt(_t,e,t,n,a,r),!0;case"pointerover":var o=r.pointerId;return At.set(o,Lt(At.get(o)||null,e,t,n,a,r)),!0;case"gotpointercapture":return o=r.pointerId,Ft.set(o,Lt(Ft.get(o)||null,e,t,n,a,r)),!0}return!1}(r,e,t,n,a))a.stopPropagation();else if(Mt(e,a),4&t&&-1<Dt.indexOf(e)){for(;null!==r;){var o=xr(r);if(null!==o&&wt(o),null===(o=Yt(e,t,n,a))&&Ha(e,t,a,Xt,n),o===r)break;r=o}null!==r&&a.stopPropagation()}else Ha(e,t,a,null,n)}}var Xt=null;function Yt(e,t,n,a){if(Xt=null,null!==(e=yr(e=we(a))))if(null===(t=Ue(e)))e=null;else if(13===(n=t.tag)){if(null!==(e=Ge(t)))return e;e=null}else if(3===n){if(t.stateNode.current.memoizedState.isDehydrated)return 3===t.tag?t.stateNode.containerInfo:null;e=null}else t!==e&&(e=null);return Xt=e,null}function Qt(e){switch(e){case"cancel":case"click":case"close":case"contextmenu":case"copy":case"cut":case"auxclick":case"dblclick":case"dragend":case"dragstart":case"drop":case"focusin":case"focusout":case"input":case"invalid":case"keydown":case"keypress":case"keyup":case"mousedown":case"mouseup":case"paste":case"pause":case"play":case"pointercancel":case"pointerdown":case"pointerup":case"ratechange":case"reset":case"resize":case"seeked":case"submit":case"touchcancel":case"touchend":case"touchstart":case"volumechange":case"change":case"selectionchange":case"textInput":case"compositionstart":case"compositionend":case"compositionupdate":case"beforeblur":case"afterblur":case"beforeinput":case"blur":case"fullscreenchange":case"focus":case"hashchange":case"popstate":case"select":case"selectstart":return 1;case"drag":case"dragenter":case"dragexit":case"dragleave":case"dragover":case"mousemove":case"mouseout":case"mouseover":case"pointermove":case"pointerout":case"pointerover":case"scroll":case"toggle":case"touchmove":case"wheel":case"mouseenter":case"mouseleave":case"pointerenter":case"pointerleave":return 4;case"message":switch(Ze()){case $e:return 1;case et:return 4;case tt:case nt:return 16;case at:return 536870912;default:return 16}default:return 16}}var Jt=null,Zt=null,$t=null;function en(){if($t)return $t;var e,t,n=Zt,a=n.length,r="value"in Jt?Jt.value:Jt.textContent,o=r.length;for(e=0;e<a&&n[e]===r[e];e++);var s=a-e;for(t=1;t<=s&&n[a-t]===r[o-t];t++);return $t=r.slice(e,1<t?1-t:void 0)}function tn(e){var t=e.keyCode;return"charCode"in e?0===(e=e.charCode)&&13===t&&(e=13):e=t,10===e&&(e=13),32<=e||13===e?e:0}function nn(){return!0}function an(){return!1}function rn(e){function t(t,n,a,r,o){for(var s in this._reactName=t,this._targetInst=a,this.type=n,this.nativeEvent=r,this.target=o,this.currentTarget=null,e)e.hasOwnProperty(s)&&(t=e[s],this[s]=t?t(r):r[s]);return this.isDefaultPrevented=(null!=r.defaultPrevented?r.defaultPrevented:!1===r.returnValue)?nn:an,this.isPropagationStopped=an,this}return P(t.prototype,{preventDefault:function(){this.defaultPrevented=!0;var e=this.nativeEvent;e&&(e.preventDefault?e.preventDefault():"unknown"!==typeof e.returnValue&&(e.returnValue=!1),this.isDefaultPrevented=nn)},stopPropagation:function(){var e=this.nativeEvent;e&&(e.stopPropagation?e.stopPropagation():"unknown"!==typeof e.cancelBubble&&(e.cancelBubble=!0),this.isPropagationStopped=nn)},persist:function(){},isPersistent:nn}),t}var on,sn,cn,ln={eventPhase:0,bubbles:0,cancelable:0,timeStamp:function(e){return e.timeStamp||Date.now()},defaultPrevented:0,isTrusted:0},un=rn(ln),dn=P({},ln,{view:0,detail:0}),hn=rn(dn),pn=P({},dn,{screenX:0,screenY:0,clientX:0,clientY:0,pageX:0,pageY:0,ctrlKey:0,shiftKey:0,altKey:0,metaKey:0,getModifierState:Nn,button:0,buttons:0,relatedTarget:function(e){return void 0===e.relatedTarget?e.fromElement===e.srcElement?e.toElement:e.fromElement:e.relatedTarget},movementX:function(e){return"movementX"in e?e.movementX:(e!==cn&&(cn&&"mousemove"===e.type?(on=e.screenX-cn.screenX,sn=e.screenY-cn.screenY):sn=on=0,cn=e),on)},movementY:function(e){return"movementY"in e?e.movementY:sn}}),fn=rn(pn),mn=rn(P({},pn,{dataTransfer:0})),gn=rn(P({},dn,{relatedTarget:0})),bn=rn(P({},ln,{animationName:0,elapsedTime:0,pseudoElement:0})),yn=P({},ln,{clipboardData:function(e){return"clipboardData"in e?e.clipboardData:window.clipboardData}}),xn=rn(yn),vn=rn(P({},ln,{data:0})),wn={Esc:"Escape",Spacebar:" ",Left:"ArrowLeft",Up:"ArrowUp",Right:"ArrowRight",Down:"ArrowDown",Del:"Delete",Win:"OS",Menu:"ContextMenu",Apps:"ContextMenu",Scroll:"ScrollLock",MozPrintableKey:"Unidentified"},kn={8:"Backspace",9:"Tab",12:"Clear",13:"Enter",16:"Shift",17:"Control",18:"Alt",19:"Pause",20:"CapsLock",27:"Escape",32:" ",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"ArrowLeft",38:"ArrowUp",39:"ArrowRight",40:"ArrowDown",45:"Insert",46:"Delete",112:"F1",113:"F2",114:"F3",115:"F4",116:"F5",117:"F6",118:"F7",119:"F8",120:"F9",121:"F10",122:"F11",123:"F12",144:"NumLock",145:"ScrollLock",224:"Meta"},In={Alt:"altKey",Control:"ctrlKey",Meta:"metaKey",Shift:"shiftKey"};function Sn(e){var t=this.nativeEvent;return t.getModifierState?t.getModifierState(e):!!(e=In[e])&&!!t[e]}function Nn(){return Sn}var Cn=P({},dn,{key:function(e){if(e.key){var t=wn[e.key]||e.key;if("Unidentified"!==t)return t}return"keypress"===e.type?13===(e=tn(e))?"Enter":String.fromCharCode(e):"keydown"===e.type||"keyup"===e.type?kn[e.keyCode]||"Unidentified":""},code:0,location:0,ctrlKey:0,shiftKey:0,altKey:0,metaKey:0,repeat:0,locale:0,getModifierState:Nn,charCode:function(e){return"keypress"===e.type?tn(e):0},keyCode:function(e){return"keydown"===e.type||"keyup"===e.type?e.keyCode:0},which:function(e){return"keypress"===e.type?tn(e):"keydown"===e.type||"keyup"===e.type?e.keyCode:0}}),Tn=rn(Cn),En=rn(P({},pn,{pointerId:0,width:0,height:0,pressure:0,tangentialPressure:0,tiltX:0,tiltY:0,twist:0,pointerType:0,isPrimary:0})),Rn=rn(P({},dn,{touches:0,targetTouches:0,changedTouches:0,altKey:0,metaKey:0,ctrlKey:0,shiftKey:0,getModifierState:Nn})),_n=rn(P({},ln,{propertyName:0,elapsedTime:0,pseudoElement:0})),An=P({},pn,{deltaX:function(e){return"deltaX"in e?e.deltaX:"wheelDeltaX"in e?-e.wheelDeltaX:0},deltaY:function(e){return"deltaY"in e?e.deltaY:"wheelDeltaY"in e?-e.wheelDeltaY:"wheelDelta"in e?-e.wheelDelta:0},deltaZ:0,deltaMode:0}),Fn=rn(An),On=[9,13,27,32],Dn=u&&"CompositionEvent"in window,Mn=null;u&&"documentMode"in document&&(Mn=document.documentMode);var Ln=u&&"TextEvent"in window&&!Mn,Pn=u&&(!Dn||Mn&&8<Mn&&11>=Mn),zn=String.fromCharCode(32),Bn=!1;function Wn(e,t){switch(e){case"keyup":return-1!==On.indexOf(t.keyCode);case"keydown":return 229!==t.keyCode;case"keypress":case"mousedown":case"focusout":return!0;default:return!1}}function Vn(e){return"object"===typeof(e=e.detail)&&"data"in e?e.data:null}var Un=!1;var Gn={color:!0,date:!0,datetime:!0,"datetime-local":!0,email:!0,month:!0,number:!0,password:!0,range:!0,search:!0,tel:!0,text:!0,time:!0,url:!0,week:!0};function Hn(e){var t=e&&e.nodeName&&e.nodeName.toLowerCase();return"input"===t?!!Gn[e.type]:"textarea"===t}function jn(e,t,n,a){Ce(a),0<(t=Ka(t,"onChange")).length&&(n=new un("onChange","change",null,n,a),e.push({event:n,listeners:t}))}var Kn=null,qn=null;function Xn(e){za(e,0)}function Yn(e){if(q(vr(e)))return e}function Qn(e,t){if("change"===e)return t}var Jn=!1;if(u){var Zn;if(u){var $n="oninput"in document;if(!$n){var ea=document.createElement("div");ea.setAttribute("oninput","return;"),$n="function"===typeof ea.oninput}Zn=$n}else Zn=!1;Jn=Zn&&(!document.documentMode||9<document.documentMode)}function ta(){Kn&&(Kn.detachEvent("onpropertychange",na),qn=Kn=null)}function na(e){if("value"===e.propertyName&&Yn(qn)){var t=[];jn(t,qn,e,we(e)),Ae(Xn,t)}}function aa(e,t,n){"focusin"===e?(ta(),qn=n,(Kn=t).attachEvent("onpropertychange",na)):"focusout"===e&&ta()}function ra(e){if("selectionchange"===e||"keyup"===e||"keydown"===e)return Yn(qn)}function oa(e,t){if("click"===e)return Yn(t)}function sa(e,t){if("input"===e||"change"===e)return Yn(t)}var ia="function"===typeof Object.is?Object.is:function(e,t){return e===t&&(0!==e||1/e===1/t)||e!==e&&t!==t};function ca(e,t){if(ia(e,t))return!0;if("object"!==typeof e||null===e||"object"!==typeof t||null===t)return!1;var n=Object.keys(e),a=Object.keys(t);if(n.length!==a.length)return!1;for(a=0;a<n.length;a++){var r=n[a];if(!d.call(t,r)||!ia(e[r],t[r]))return!1}return!0}function la(e){for(;e&&e.firstChild;)e=e.firstChild;return e}function ua(e,t){var n,a=la(e);for(e=0;a;){if(3===a.nodeType){if(n=e+a.textContent.length,e<=t&&n>=t)return{node:a,offset:t-e};e=n}e:{for(;a;){if(a.nextSibling){a=a.nextSibling;break e}a=a.parentNode}a=void 0}a=la(a)}}function da(e,t){return!(!e||!t)&&(e===t||(!e||3!==e.nodeType)&&(t&&3===t.nodeType?da(e,t.parentNode):"contains"in e?e.contains(t):!!e.compareDocumentPosition&&!!(16&e.compareDocumentPosition(t))))}function ha(){for(var e=window,t=X();t instanceof e.HTMLIFrameElement;){try{var n="string"===typeof t.contentWindow.location.href}catch(a){n=!1}if(!n)break;t=X((e=t.contentWindow).document)}return t}function pa(e){var t=e&&e.nodeName&&e.nodeName.toLowerCase();return t&&("input"===t&&("text"===e.type||"search"===e.type||"tel"===e.type||"url"===e.type||"password"===e.type)||"textarea"===t||"true"===e.contentEditable)}function fa(e){var t=ha(),n=e.focusedElem,a=e.selectionRange;if(t!==n&&n&&n.ownerDocument&&da(n.ownerDocument.documentElement,n)){if(null!==a&&pa(n))if(t=a.start,void 0===(e=a.end)&&(e=t),"selectionStart"in n)n.selectionStart=t,n.selectionEnd=Math.min(e,n.value.length);else if((e=(t=n.ownerDocument||document)&&t.defaultView||window).getSelection){e=e.getSelection();var r=n.textContent.length,o=Math.min(a.start,r);a=void 0===a.end?o:Math.min(a.end,r),!e.extend&&o>a&&(r=a,a=o,o=r),r=ua(n,o);var s=ua(n,a);r&&s&&(1!==e.rangeCount||e.anchorNode!==r.node||e.anchorOffset!==r.offset||e.focusNode!==s.node||e.focusOffset!==s.offset)&&((t=t.createRange()).setStart(r.node,r.offset),e.removeAllRanges(),o>a?(e.addRange(t),e.extend(s.node,s.offset)):(t.setEnd(s.node,s.offset),e.addRange(t)))}for(t=[],e=n;e=e.parentNode;)1===e.nodeType&&t.push({element:e,left:e.scrollLeft,top:e.scrollTop});for("function"===typeof n.focus&&n.focus(),n=0;n<t.length;n++)(e=t[n]).element.scrollLeft=e.left,e.element.scrollTop=e.top}}var ma=u&&"documentMode"in document&&11>=document.documentMode,ga=null,ba=null,ya=null,xa=!1;function va(e,t,n){var a=n.window===n?n.document:9===n.nodeType?n:n.ownerDocument;xa||null==ga||ga!==X(a)||("selectionStart"in(a=ga)&&pa(a)?a={start:a.selectionStart,end:a.selectionEnd}:a={anchorNode:(a=(a.ownerDocument&&a.ownerDocument.defaultView||window).getSelection()).anchorNode,anchorOffset:a.anchorOffset,focusNode:a.focusNode,focusOffset:a.focusOffset},ya&&ca(ya,a)||(ya=a,0<(a=Ka(ba,"onSelect")).length&&(t=new un("onSelect","select",null,t,n),e.push({event:t,listeners:a}),t.target=ga)))}function wa(e,t){var n={};return n[e.toLowerCase()]=t.toLowerCase(),n["Webkit"+e]="webkit"+t,n["Moz"+e]="moz"+t,n}var ka={animationend:wa("Animation","AnimationEnd"),animationiteration:wa("Animation","AnimationIteration"),animationstart:wa("Animation","AnimationStart"),transitionend:wa("Transition","TransitionEnd")},Ia={},Sa={};function Na(e){if(Ia[e])return Ia[e];if(!ka[e])return e;var t,n=ka[e];for(t in n)if(n.hasOwnProperty(t)&&t in Sa)return Ia[e]=n[t];return e}u&&(Sa=document.createElement("div").style,"AnimationEvent"in window||(delete ka.animationend.animation,delete ka.animationiteration.animation,delete ka.animationstart.animation),"TransitionEvent"in window||delete ka.transitionend.transition);var Ca=Na("animationend"),Ta=Na("animationiteration"),Ea=Na("animationstart"),Ra=Na("transitionend"),_a=new Map,Aa="abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");function Fa(e,t){_a.set(e,t),c(t,[e])}for(var Oa=0;Oa<Aa.length;Oa++){var Da=Aa[Oa];Fa(Da.toLowerCase(),"on"+(Da[0].toUpperCase()+Da.slice(1)))}Fa(Ca,"onAnimationEnd"),Fa(Ta,"onAnimationIteration"),Fa(Ea,"onAnimationStart"),Fa("dblclick","onDoubleClick"),Fa("focusin","onFocus"),Fa("focusout","onBlur"),Fa(Ra,"onTransitionEnd"),l("onMouseEnter",["mouseout","mouseover"]),l("onMouseLeave",["mouseout","mouseover"]),l("onPointerEnter",["pointerout","pointerover"]),l("onPointerLeave",["pointerout","pointerover"]),c("onChange","change click focusin focusout input keydown keyup selectionchange".split(" ")),c("onSelect","focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" ")),c("onBeforeInput",["compositionend","keypress","textInput","paste"]),c("onCompositionEnd","compositionend focusout keydown keypress keyup mousedown".split(" ")),c("onCompositionStart","compositionstart focusout keydown keypress keyup mousedown".split(" ")),c("onCompositionUpdate","compositionupdate focusout keydown keypress keyup mousedown".split(" "));var Ma="abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "),La=new Set("cancel close invalid load scroll toggle".split(" ").concat(Ma));function Pa(e,t,n){var a=e.type||"unknown-event";e.currentTarget=n,function(e,t,n,a,r,s,i,c,l){if(Ve.apply(this,arguments),Le){if(!Le)throw Error(o(198));var u=Pe;Le=!1,Pe=null,ze||(ze=!0,Be=u)}}(a,t,void 0,e),e.currentTarget=null}function za(e,t){t=0!==(4&t);for(var n=0;n<e.length;n++){var a=e[n],r=a.event;a=a.listeners;e:{var o=void 0;if(t)for(var s=a.length-1;0<=s;s--){var i=a[s],c=i.instance,l=i.currentTarget;if(i=i.listener,c!==o&&r.isPropagationStopped())break e;Pa(r,i,l),o=c}else for(s=0;s<a.length;s++){if(c=(i=a[s]).instance,l=i.currentTarget,i=i.listener,c!==o&&r.isPropagationStopped())break e;Pa(r,i,l),o=c}}}if(ze)throw e=Be,ze=!1,Be=null,e}function Ba(e,t){var n=t[mr];void 0===n&&(n=t[mr]=new Set);var a=e+"__bubble";n.has(a)||(Ga(t,e,2,!1),n.add(a))}function Wa(e,t,n){var a=0;t&&(a|=4),Ga(n,e,a,t)}var Va="_reactListening"+Math.random().toString(36).slice(2);function Ua(e){if(!e[Va]){e[Va]=!0,s.forEach((function(t){"selectionchange"!==t&&(La.has(t)||Wa(t,!1,e),Wa(t,!0,e))}));var t=9===e.nodeType?e:e.ownerDocument;null===t||t[Va]||(t[Va]=!0,Wa("selectionchange",!1,t))}}function Ga(e,t,n,a){switch(Qt(t)){case 1:var r=jt;break;case 4:r=Kt;break;default:r=qt}n=r.bind(null,t,n,e),r=void 0,!Oe||"touchstart"!==t&&"touchmove"!==t&&"wheel"!==t||(r=!0),a?void 0!==r?e.addEventListener(t,n,{capture:!0,passive:r}):e.addEventListener(t,n,!0):void 0!==r?e.addEventListener(t,n,{passive:r}):e.addEventListener(t,n,!1)}function Ha(e,t,n,a,r){var o=a;if(0===(1&t)&&0===(2&t)&&null!==a)e:for(;;){if(null===a)return;var s=a.tag;if(3===s||4===s){var i=a.stateNode.containerInfo;if(i===r||8===i.nodeType&&i.parentNode===r)break;if(4===s)for(s=a.return;null!==s;){var c=s.tag;if((3===c||4===c)&&((c=s.stateNode.containerInfo)===r||8===c.nodeType&&c.parentNode===r))return;s=s.return}for(;null!==i;){if(null===(s=yr(i)))return;if(5===(c=s.tag)||6===c){a=o=s;continue e}i=i.parentNode}}a=a.return}Ae((function(){var a=o,r=we(n),s=[];e:{var i=_a.get(e);if(void 0!==i){var c=un,l=e;switch(e){case"keypress":if(0===tn(n))break e;case"keydown":case"keyup":c=Tn;break;case"focusin":l="focus",c=gn;break;case"focusout":l="blur",c=gn;break;case"beforeblur":case"afterblur":c=gn;break;case"click":if(2===n.button)break e;case"auxclick":case"dblclick":case"mousedown":case"mousemove":case"mouseup":case"mouseout":case"mouseover":case"contextmenu":c=fn;break;case"drag":case"dragend":case"dragenter":case"dragexit":case"dragleave":case"dragover":case"dragstart":case"drop":c=mn;break;case"touchcancel":case"touchend":case"touchmove":case"touchstart":c=Rn;break;case Ca:case Ta:case Ea:c=bn;break;case Ra:c=_n;break;case"scroll":c=hn;break;case"wheel":c=Fn;break;case"copy":case"cut":case"paste":c=xn;break;case"gotpointercapture":case"lostpointercapture":case"pointercancel":case"pointerdown":case"pointermove":case"pointerout":case"pointerover":case"pointerup":c=En}var u=0!==(4&t),d=!u&&"scroll"===e,h=u?null!==i?i+"Capture":null:i;u=[];for(var p,f=a;null!==f;){var m=(p=f).stateNode;if(5===p.tag&&null!==m&&(p=m,null!==h&&(null!=(m=Fe(f,h))&&u.push(ja(f,m,p)))),d)break;f=f.return}0<u.length&&(i=new c(i,l,null,n,r),s.push({event:i,listeners:u}))}}if(0===(7&t)){if(c="mouseout"===e||"pointerout"===e,(!(i="mouseover"===e||"pointerover"===e)||n===ve||!(l=n.relatedTarget||n.fromElement)||!yr(l)&&!l[fr])&&(c||i)&&(i=r.window===r?r:(i=r.ownerDocument)?i.defaultView||i.parentWindow:window,c?(c=a,null!==(l=(l=n.relatedTarget||n.toElement)?yr(l):null)&&(l!==(d=Ue(l))||5!==l.tag&&6!==l.tag)&&(l=null)):(c=null,l=a),c!==l)){if(u=fn,m="onMouseLeave",h="onMouseEnter",f="mouse","pointerout"!==e&&"pointerover"!==e||(u=En,m="onPointerLeave",h="onPointerEnter",f="pointer"),d=null==c?i:vr(c),p=null==l?i:vr(l),(i=new u(m,f+"leave",c,n,r)).target=d,i.relatedTarget=p,m=null,yr(r)===a&&((u=new u(h,f+"enter",l,n,r)).target=p,u.relatedTarget=d,m=u),d=m,c&&l)e:{for(h=l,f=0,p=u=c;p;p=qa(p))f++;for(p=0,m=h;m;m=qa(m))p++;for(;0<f-p;)u=qa(u),f--;for(;0<p-f;)h=qa(h),p--;for(;f--;){if(u===h||null!==h&&u===h.alternate)break e;u=qa(u),h=qa(h)}u=null}else u=null;null!==c&&Xa(s,i,c,u,!1),null!==l&&null!==d&&Xa(s,d,l,u,!0)}if("select"===(c=(i=a?vr(a):window).nodeName&&i.nodeName.toLowerCase())||"input"===c&&"file"===i.type)var g=Qn;else if(Hn(i))if(Jn)g=sa;else{g=ra;var b=aa}else(c=i.nodeName)&&"input"===c.toLowerCase()&&("checkbox"===i.type||"radio"===i.type)&&(g=oa);switch(g&&(g=g(e,a))?jn(s,g,n,r):(b&&b(e,i,a),"focusout"===e&&(b=i._wrapperState)&&b.controlled&&"number"===i.type&&ee(i,"number",i.value)),b=a?vr(a):window,e){case"focusin":(Hn(b)||"true"===b.contentEditable)&&(ga=b,ba=a,ya=null);break;case"focusout":ya=ba=ga=null;break;case"mousedown":xa=!0;break;case"contextmenu":case"mouseup":case"dragend":xa=!1,va(s,n,r);break;case"selectionchange":if(ma)break;case"keydown":case"keyup":va(s,n,r)}var y;if(Dn)e:{switch(e){case"compositionstart":var x="onCompositionStart";break e;case"compositionend":x="onCompositionEnd";break e;case"compositionupdate":x="onCompositionUpdate";break e}x=void 0}else Un?Wn(e,n)&&(x="onCompositionEnd"):"keydown"===e&&229===n.keyCode&&(x="onCompositionStart");x&&(Pn&&"ko"!==n.locale&&(Un||"onCompositionStart"!==x?"onCompositionEnd"===x&&Un&&(y=en()):(Zt="value"in(Jt=r)?Jt.value:Jt.textContent,Un=!0)),0<(b=Ka(a,x)).length&&(x=new vn(x,e,null,n,r),s.push({event:x,listeners:b}),y?x.data=y:null!==(y=Vn(n))&&(x.data=y))),(y=Ln?function(e,t){switch(e){case"compositionend":return Vn(t);case"keypress":return 32!==t.which?null:(Bn=!0,zn);case"textInput":return(e=t.data)===zn&&Bn?null:e;default:return null}}(e,n):function(e,t){if(Un)return"compositionend"===e||!Dn&&Wn(e,t)?(e=en(),$t=Zt=Jt=null,Un=!1,e):null;switch(e){case"paste":default:return null;case"keypress":if(!(t.ctrlKey||t.altKey||t.metaKey)||t.ctrlKey&&t.altKey){if(t.char&&1<t.char.length)return t.char;if(t.which)return String.fromCharCode(t.which)}return null;case"compositionend":return Pn&&"ko"!==t.locale?null:t.data}}(e,n))&&(0<(a=Ka(a,"onBeforeInput")).length&&(r=new vn("onBeforeInput","beforeinput",null,n,r),s.push({event:r,listeners:a}),r.data=y))}za(s,t)}))}function ja(e,t,n){return{instance:e,listener:t,currentTarget:n}}function Ka(e,t){for(var n=t+"Capture",a=[];null!==e;){var r=e,o=r.stateNode;5===r.tag&&null!==o&&(r=o,null!=(o=Fe(e,n))&&a.unshift(ja(e,o,r)),null!=(o=Fe(e,t))&&a.push(ja(e,o,r))),e=e.return}return a}function qa(e){if(null===e)return null;do{e=e.return}while(e&&5!==e.tag);return e||null}function Xa(e,t,n,a,r){for(var o=t._reactName,s=[];null!==n&&n!==a;){var i=n,c=i.alternate,l=i.stateNode;if(null!==c&&c===a)break;5===i.tag&&null!==l&&(i=l,r?null!=(c=Fe(n,o))&&s.unshift(ja(n,c,i)):r||null!=(c=Fe(n,o))&&s.push(ja(n,c,i))),n=n.return}0!==s.length&&e.push({event:t,listeners:s})}var Ya=/\r\n?/g,Qa=/\u0000|\uFFFD/g;function Ja(e){return("string"===typeof e?e:""+e).replace(Ya,"\n").replace(Qa,"")}function Za(e,t,n){if(t=Ja(t),Ja(e)!==t&&n)throw Error(o(425))}function $a(){}var er=null,tr=null;function nr(e,t){return"textarea"===e||"noscript"===e||"string"===typeof t.children||"number"===typeof t.children||"object"===typeof t.dangerouslySetInnerHTML&&null!==t.dangerouslySetInnerHTML&&null!=t.dangerouslySetInnerHTML.__html}var ar="function"===typeof setTimeout?setTimeout:void 0,rr="function"===typeof clearTimeout?clearTimeout:void 0,or="function"===typeof Promise?Promise:void 0,sr="function"===typeof queueMicrotask?queueMicrotask:"undefined"!==typeof or?function(e){return or.resolve(null).then(e).catch(ir)}:ar;function ir(e){setTimeout((function(){throw e}))}function cr(e,t){var n=t,a=0;do{var r=n.nextSibling;if(e.removeChild(n),r&&8===r.nodeType)if("/$"===(n=r.data)){if(0===a)return e.removeChild(r),void Ut(t);a--}else"$"!==n&&"$?"!==n&&"$!"!==n||a++;n=r}while(n);Ut(t)}function lr(e){for(;null!=e;e=e.nextSibling){var t=e.nodeType;if(1===t||3===t)break;if(8===t){if("$"===(t=e.data)||"$!"===t||"$?"===t)break;if("/$"===t)return null}}return e}function ur(e){e=e.previousSibling;for(var t=0;e;){if(8===e.nodeType){var n=e.data;if("$"===n||"$!"===n||"$?"===n){if(0===t)return e;t--}else"/$"===n&&t++}e=e.previousSibling}return null}var dr=Math.random().toString(36).slice(2),hr="__reactFiber$"+dr,pr="__reactProps$"+dr,fr="__reactContainer$"+dr,mr="__reactEvents$"+dr,gr="__reactListeners$"+dr,br="__reactHandles$"+dr;function yr(e){var t=e[hr];if(t)return t;for(var n=e.parentNode;n;){if(t=n[fr]||n[hr]){if(n=t.alternate,null!==t.child||null!==n&&null!==n.child)for(e=ur(e);null!==e;){if(n=e[hr])return n;e=ur(e)}return t}n=(e=n).parentNode}return null}function xr(e){return!(e=e[hr]||e[fr])||5!==e.tag&&6!==e.tag&&13!==e.tag&&3!==e.tag?null:e}function vr(e){if(5===e.tag||6===e.tag)return e.stateNode;throw Error(o(33))}function wr(e){return e[pr]||null}var kr=[],Ir=-1;function Sr(e){return{current:e}}function Nr(e){0>Ir||(e.current=kr[Ir],kr[Ir]=null,Ir--)}function Cr(e,t){Ir++,kr[Ir]=e.current,e.current=t}var Tr={},Er=Sr(Tr),Rr=Sr(!1),_r=Tr;function Ar(e,t){var n=e.type.contextTypes;if(!n)return Tr;var a=e.stateNode;if(a&&a.__reactInternalMemoizedUnmaskedChildContext===t)return a.__reactInternalMemoizedMaskedChildContext;var r,o={};for(r in n)o[r]=t[r];return a&&((e=e.stateNode).__reactInternalMemoizedUnmaskedChildContext=t,e.__reactInternalMemoizedMaskedChildContext=o),o}function Fr(e){return null!==(e=e.childContextTypes)&&void 0!==e}function Or(){Nr(Rr),Nr(Er)}function Dr(e,t,n){if(Er.current!==Tr)throw Error(o(168));Cr(Er,t),Cr(Rr,n)}function Mr(e,t,n){var a=e.stateNode;if(t=t.childContextTypes,"function"!==typeof a.getChildContext)return n;for(var r in a=a.getChildContext())if(!(r in t))throw Error(o(108,G(e)||"Unknown",r));return P({},n,a)}function Lr(e){return e=(e=e.stateNode)&&e.__reactInternalMemoizedMergedChildContext||Tr,_r=Er.current,Cr(Er,e),Cr(Rr,Rr.current),!0}function Pr(e,t,n){var a=e.stateNode;if(!a)throw Error(o(169));n?(e=Mr(e,t,_r),a.__reactInternalMemoizedMergedChildContext=e,Nr(Rr),Nr(Er),Cr(Er,e)):Nr(Rr),Cr(Rr,n)}var zr=null,Br=!1,Wr=!1;function Vr(e){null===zr?zr=[e]:zr.push(e)}function Ur(){if(!Wr&&null!==zr){Wr=!0;var e=0,t=xt;try{var n=zr;for(xt=1;e<n.length;e++){var a=n[e];do{a=a(!0)}while(null!==a)}zr=null,Br=!1}catch(r){throw null!==zr&&(zr=zr.slice(e+1)),qe($e,Ur),r}finally{xt=t,Wr=!1}}return null}var Gr=[],Hr=0,jr=null,Kr=0,qr=[],Xr=0,Yr=null,Qr=1,Jr="";function Zr(e,t){Gr[Hr++]=Kr,Gr[Hr++]=jr,jr=e,Kr=t}function $r(e,t,n){qr[Xr++]=Qr,qr[Xr++]=Jr,qr[Xr++]=Yr,Yr=e;var a=Qr;e=Jr;var r=32-st(a)-1;a&=~(1<<r),n+=1;var o=32-st(t)+r;if(30<o){var s=r-r%5;o=(a&(1<<s)-1).toString(32),a>>=s,r-=s,Qr=1<<32-st(t)+r|n<<r|a,Jr=o+e}else Qr=1<<o|n<<r|a,Jr=e}function eo(e){null!==e.return&&(Zr(e,1),$r(e,1,0))}function to(e){for(;e===jr;)jr=Gr[--Hr],Gr[Hr]=null,Kr=Gr[--Hr],Gr[Hr]=null;for(;e===Yr;)Yr=qr[--Xr],qr[Xr]=null,Jr=qr[--Xr],qr[Xr]=null,Qr=qr[--Xr],qr[Xr]=null}var no=null,ao=null,ro=!1,oo=null;function so(e,t){var n=Al(5,null,null,0);n.elementType="DELETED",n.stateNode=t,n.return=e,null===(t=e.deletions)?(e.deletions=[n],e.flags|=16):t.push(n)}function io(e,t){switch(e.tag){case 5:var n=e.type;return null!==(t=1!==t.nodeType||n.toLowerCase()!==t.nodeName.toLowerCase()?null:t)&&(e.stateNode=t,no=e,ao=lr(t.firstChild),!0);case 6:return null!==(t=""===e.pendingProps||3!==t.nodeType?null:t)&&(e.stateNode=t,no=e,ao=null,!0);case 13:return null!==(t=8!==t.nodeType?null:t)&&(n=null!==Yr?{id:Qr,overflow:Jr}:null,e.memoizedState={dehydrated:t,treeContext:n,retryLane:1073741824},(n=Al(18,null,null,0)).stateNode=t,n.return=e,e.child=n,no=e,ao=null,!0);default:return!1}}function co(e){return 0!==(1&e.mode)&&0===(128&e.flags)}function lo(e){if(ro){var t=ao;if(t){var n=t;if(!io(e,t)){if(co(e))throw Error(o(418));t=lr(n.nextSibling);var a=no;t&&io(e,t)?so(a,n):(e.flags=-4097&e.flags|2,ro=!1,no=e)}}else{if(co(e))throw Error(o(418));e.flags=-4097&e.flags|2,ro=!1,no=e}}}function uo(e){for(e=e.return;null!==e&&5!==e.tag&&3!==e.tag&&13!==e.tag;)e=e.return;no=e}function ho(e){if(e!==no)return!1;if(!ro)return uo(e),ro=!0,!1;var t;if((t=3!==e.tag)&&!(t=5!==e.tag)&&(t="head"!==(t=e.type)&&"body"!==t&&!nr(e.type,e.memoizedProps)),t&&(t=ao)){if(co(e))throw po(),Error(o(418));for(;t;)so(e,t),t=lr(t.nextSibling)}if(uo(e),13===e.tag){if(!(e=null!==(e=e.memoizedState)?e.dehydrated:null))throw Error(o(317));e:{for(e=e.nextSibling,t=0;e;){if(8===e.nodeType){var n=e.data;if("/$"===n){if(0===t){ao=lr(e.nextSibling);break e}t--}else"$"!==n&&"$!"!==n&&"$?"!==n||t++}e=e.nextSibling}ao=null}}else ao=no?lr(e.stateNode.nextSibling):null;return!0}function po(){for(var e=ao;e;)e=lr(e.nextSibling)}function fo(){ao=no=null,ro=!1}function mo(e){null===oo?oo=[e]:oo.push(e)}var go=v.ReactCurrentBatchConfig;function bo(e,t,n){if(null!==(e=n.ref)&&"function"!==typeof e&&"object"!==typeof e){if(n._owner){if(n=n._owner){if(1!==n.tag)throw Error(o(309));var a=n.stateNode}if(!a)throw Error(o(147,e));var r=a,s=""+e;return null!==t&&null!==t.ref&&"function"===typeof t.ref&&t.ref._stringRef===s?t.ref:(t=function(e){var t=r.refs;null===e?delete t[s]:t[s]=e},t._stringRef=s,t)}if("string"!==typeof e)throw Error(o(284));if(!n._owner)throw Error(o(290,e))}return e}function yo(e,t){throw e=Object.prototype.toString.call(t),Error(o(31,"[object Object]"===e?"object with keys {"+Object.keys(t).join(", ")+"}":e))}function xo(e){return(0,e._init)(e._payload)}function vo(e){function t(t,n){if(e){var a=t.deletions;null===a?(t.deletions=[n],t.flags|=16):a.push(n)}}function n(n,a){if(!e)return null;for(;null!==a;)t(n,a),a=a.sibling;return null}function a(e,t){for(e=new Map;null!==t;)null!==t.key?e.set(t.key,t):e.set(t.index,t),t=t.sibling;return e}function r(e,t){return(e=Ol(e,t)).index=0,e.sibling=null,e}function s(t,n,a){return t.index=a,e?null!==(a=t.alternate)?(a=a.index)<n?(t.flags|=2,n):a:(t.flags|=2,n):(t.flags|=1048576,n)}function i(t){return e&&null===t.alternate&&(t.flags|=2),t}function c(e,t,n,a){return null===t||6!==t.tag?((t=Pl(n,e.mode,a)).return=e,t):((t=r(t,n)).return=e,t)}function l(e,t,n,a){var o=n.type;return o===I?d(e,t,n.props.children,a,n.key):null!==t&&(t.elementType===o||"object"===typeof o&&null!==o&&o.$$typeof===F&&xo(o)===t.type)?((a=r(t,n.props)).ref=bo(e,t,n),a.return=e,a):((a=Dl(n.type,n.key,n.props,null,e.mode,a)).ref=bo(e,t,n),a.return=e,a)}function u(e,t,n,a){return null===t||4!==t.tag||t.stateNode.containerInfo!==n.containerInfo||t.stateNode.implementation!==n.implementation?((t=zl(n,e.mode,a)).return=e,t):((t=r(t,n.children||[])).return=e,t)}function d(e,t,n,a,o){return null===t||7!==t.tag?((t=Ml(n,e.mode,a,o)).return=e,t):((t=r(t,n)).return=e,t)}function h(e,t,n){if("string"===typeof t&&""!==t||"number"===typeof t)return(t=Pl(""+t,e.mode,n)).return=e,t;if("object"===typeof t&&null!==t){switch(t.$$typeof){case w:return(n=Dl(t.type,t.key,t.props,null,e.mode,n)).ref=bo(e,null,t),n.return=e,n;case k:return(t=zl(t,e.mode,n)).return=e,t;case F:return h(e,(0,t._init)(t._payload),n)}if(te(t)||M(t))return(t=Ml(t,e.mode,n,null)).return=e,t;yo(e,t)}return null}function p(e,t,n,a){var r=null!==t?t.key:null;if("string"===typeof n&&""!==n||"number"===typeof n)return null!==r?null:c(e,t,""+n,a);if("object"===typeof n&&null!==n){switch(n.$$typeof){case w:return n.key===r?l(e,t,n,a):null;case k:return n.key===r?u(e,t,n,a):null;case F:return p(e,t,(r=n._init)(n._payload),a)}if(te(n)||M(n))return null!==r?null:d(e,t,n,a,null);yo(e,n)}return null}function f(e,t,n,a,r){if("string"===typeof a&&""!==a||"number"===typeof a)return c(t,e=e.get(n)||null,""+a,r);if("object"===typeof a&&null!==a){switch(a.$$typeof){case w:return l(t,e=e.get(null===a.key?n:a.key)||null,a,r);case k:return u(t,e=e.get(null===a.key?n:a.key)||null,a,r);case F:return f(e,t,n,(0,a._init)(a._payload),r)}if(te(a)||M(a))return d(t,e=e.get(n)||null,a,r,null);yo(t,a)}return null}function m(r,o,i,c){for(var l=null,u=null,d=o,m=o=0,g=null;null!==d&&m<i.length;m++){d.index>m?(g=d,d=null):g=d.sibling;var b=p(r,d,i[m],c);if(null===b){null===d&&(d=g);break}e&&d&&null===b.alternate&&t(r,d),o=s(b,o,m),null===u?l=b:u.sibling=b,u=b,d=g}if(m===i.length)return n(r,d),ro&&Zr(r,m),l;if(null===d){for(;m<i.length;m++)null!==(d=h(r,i[m],c))&&(o=s(d,o,m),null===u?l=d:u.sibling=d,u=d);return ro&&Zr(r,m),l}for(d=a(r,d);m<i.length;m++)null!==(g=f(d,r,m,i[m],c))&&(e&&null!==g.alternate&&d.delete(null===g.key?m:g.key),o=s(g,o,m),null===u?l=g:u.sibling=g,u=g);return e&&d.forEach((function(e){return t(r,e)})),ro&&Zr(r,m),l}function g(r,i,c,l){var u=M(c);if("function"!==typeof u)throw Error(o(150));if(null==(c=u.call(c)))throw Error(o(151));for(var d=u=null,m=i,g=i=0,b=null,y=c.next();null!==m&&!y.done;g++,y=c.next()){m.index>g?(b=m,m=null):b=m.sibling;var x=p(r,m,y.value,l);if(null===x){null===m&&(m=b);break}e&&m&&null===x.alternate&&t(r,m),i=s(x,i,g),null===d?u=x:d.sibling=x,d=x,m=b}if(y.done)return n(r,m),ro&&Zr(r,g),u;if(null===m){for(;!y.done;g++,y=c.next())null!==(y=h(r,y.value,l))&&(i=s(y,i,g),null===d?u=y:d.sibling=y,d=y);return ro&&Zr(r,g),u}for(m=a(r,m);!y.done;g++,y=c.next())null!==(y=f(m,r,g,y.value,l))&&(e&&null!==y.alternate&&m.delete(null===y.key?g:y.key),i=s(y,i,g),null===d?u=y:d.sibling=y,d=y);return e&&m.forEach((function(e){return t(r,e)})),ro&&Zr(r,g),u}return function e(a,o,s,c){if("object"===typeof s&&null!==s&&s.type===I&&null===s.key&&(s=s.props.children),"object"===typeof s&&null!==s){switch(s.$$typeof){case w:e:{for(var l=s.key,u=o;null!==u;){if(u.key===l){if((l=s.type)===I){if(7===u.tag){n(a,u.sibling),(o=r(u,s.props.children)).return=a,a=o;break e}}else if(u.elementType===l||"object"===typeof l&&null!==l&&l.$$typeof===F&&xo(l)===u.type){n(a,u.sibling),(o=r(u,s.props)).ref=bo(a,u,s),o.return=a,a=o;break e}n(a,u);break}t(a,u),u=u.sibling}s.type===I?((o=Ml(s.props.children,a.mode,c,s.key)).return=a,a=o):((c=Dl(s.type,s.key,s.props,null,a.mode,c)).ref=bo(a,o,s),c.return=a,a=c)}return i(a);case k:e:{for(u=s.key;null!==o;){if(o.key===u){if(4===o.tag&&o.stateNode.containerInfo===s.containerInfo&&o.stateNode.implementation===s.implementation){n(a,o.sibling),(o=r(o,s.children||[])).return=a,a=o;break e}n(a,o);break}t(a,o),o=o.sibling}(o=zl(s,a.mode,c)).return=a,a=o}return i(a);case F:return e(a,o,(u=s._init)(s._payload),c)}if(te(s))return m(a,o,s,c);if(M(s))return g(a,o,s,c);yo(a,s)}return"string"===typeof s&&""!==s||"number"===typeof s?(s=""+s,null!==o&&6===o.tag?(n(a,o.sibling),(o=r(o,s)).return=a,a=o):(n(a,o),(o=Pl(s,a.mode,c)).return=a,a=o),i(a)):n(a,o)}}var wo=vo(!0),ko=vo(!1),Io=Sr(null),So=null,No=null,Co=null;function To(){Co=No=So=null}function Eo(e){var t=Io.current;Nr(Io),e._currentValue=t}function Ro(e,t,n){for(;null!==e;){var a=e.alternate;if((e.childLanes&t)!==t?(e.childLanes|=t,null!==a&&(a.childLanes|=t)):null!==a&&(a.childLanes&t)!==t&&(a.childLanes|=t),e===n)break;e=e.return}}function _o(e,t){So=e,Co=No=null,null!==(e=e.dependencies)&&null!==e.firstContext&&(0!==(e.lanes&t)&&(xi=!0),e.firstContext=null)}function Ao(e){var t=e._currentValue;if(Co!==e)if(e={context:e,memoizedValue:t,next:null},null===No){if(null===So)throw Error(o(308));No=e,So.dependencies={lanes:0,firstContext:e}}else No=No.next=e;return t}var Fo=null;function Oo(e){null===Fo?Fo=[e]:Fo.push(e)}function Do(e,t,n,a){var r=t.interleaved;return null===r?(n.next=n,Oo(t)):(n.next=r.next,r.next=n),t.interleaved=n,Mo(e,a)}function Mo(e,t){e.lanes|=t;var n=e.alternate;for(null!==n&&(n.lanes|=t),n=e,e=e.return;null!==e;)e.childLanes|=t,null!==(n=e.alternate)&&(n.childLanes|=t),n=e,e=e.return;return 3===n.tag?n.stateNode:null}var Lo=!1;function Po(e){e.updateQueue={baseState:e.memoizedState,firstBaseUpdate:null,lastBaseUpdate:null,shared:{pending:null,interleaved:null,lanes:0},effects:null}}function zo(e,t){e=e.updateQueue,t.updateQueue===e&&(t.updateQueue={baseState:e.baseState,firstBaseUpdate:e.firstBaseUpdate,lastBaseUpdate:e.lastBaseUpdate,shared:e.shared,effects:e.effects})}function Bo(e,t){return{eventTime:e,lane:t,tag:0,payload:null,callback:null,next:null}}function Wo(e,t,n){var a=e.updateQueue;if(null===a)return null;if(a=a.shared,0!==(2&Ec)){var r=a.pending;return null===r?t.next=t:(t.next=r.next,r.next=t),a.pending=t,Mo(e,n)}return null===(r=a.interleaved)?(t.next=t,Oo(a)):(t.next=r.next,r.next=t),a.interleaved=t,Mo(e,n)}function Vo(e,t,n){if(null!==(t=t.updateQueue)&&(t=t.shared,0!==(4194240&n))){var a=t.lanes;n|=a&=e.pendingLanes,t.lanes=n,yt(e,n)}}function Uo(e,t){var n=e.updateQueue,a=e.alternate;if(null!==a&&n===(a=a.updateQueue)){var r=null,o=null;if(null!==(n=n.firstBaseUpdate)){do{var s={eventTime:n.eventTime,lane:n.lane,tag:n.tag,payload:n.payload,callback:n.callback,next:null};null===o?r=o=s:o=o.next=s,n=n.next}while(null!==n);null===o?r=o=t:o=o.next=t}else r=o=t;return n={baseState:a.baseState,firstBaseUpdate:r,lastBaseUpdate:o,shared:a.shared,effects:a.effects},void(e.updateQueue=n)}null===(e=n.lastBaseUpdate)?n.firstBaseUpdate=t:e.next=t,n.lastBaseUpdate=t}function Go(e,t,n,a){var r=e.updateQueue;Lo=!1;var o=r.firstBaseUpdate,s=r.lastBaseUpdate,i=r.shared.pending;if(null!==i){r.shared.pending=null;var c=i,l=c.next;c.next=null,null===s?o=l:s.next=l,s=c;var u=e.alternate;null!==u&&((i=(u=u.updateQueue).lastBaseUpdate)!==s&&(null===i?u.firstBaseUpdate=l:i.next=l,u.lastBaseUpdate=c))}if(null!==o){var d=r.baseState;for(s=0,u=l=c=null,i=o;;){var h=i.lane,p=i.eventTime;if((a&h)===h){null!==u&&(u=u.next={eventTime:p,lane:0,tag:i.tag,payload:i.payload,callback:i.callback,next:null});e:{var f=e,m=i;switch(h=t,p=n,m.tag){case 1:if("function"===typeof(f=m.payload)){d=f.call(p,d,h);break e}d=f;break e;case 3:f.flags=-65537&f.flags|128;case 0:if(null===(h="function"===typeof(f=m.payload)?f.call(p,d,h):f)||void 0===h)break e;d=P({},d,h);break e;case 2:Lo=!0}}null!==i.callback&&0!==i.lane&&(e.flags|=64,null===(h=r.effects)?r.effects=[i]:h.push(i))}else p={eventTime:p,lane:h,tag:i.tag,payload:i.payload,callback:i.callback,next:null},null===u?(l=u=p,c=d):u=u.next=p,s|=h;if(null===(i=i.next)){if(null===(i=r.shared.pending))break;i=(h=i).next,h.next=null,r.lastBaseUpdate=h,r.shared.pending=null}}if(null===u&&(c=d),r.baseState=c,r.firstBaseUpdate=l,r.lastBaseUpdate=u,null!==(t=r.shared.interleaved)){r=t;do{s|=r.lane,r=r.next}while(r!==t)}else null===o&&(r.shared.lanes=0);Lc|=s,e.lanes=s,e.memoizedState=d}}function Ho(e,t,n){if(e=t.effects,t.effects=null,null!==e)for(t=0;t<e.length;t++){var a=e[t],r=a.callback;if(null!==r){if(a.callback=null,a=n,"function"!==typeof r)throw Error(o(191,r));r.call(a)}}}var jo={},Ko=Sr(jo),qo=Sr(jo),Xo=Sr(jo);function Yo(e){if(e===jo)throw Error(o(174));return e}function Qo(e,t){switch(Cr(Xo,t),Cr(qo,e),Cr(Ko,jo),e=t.nodeType){case 9:case 11:t=(t=t.documentElement)?t.namespaceURI:ce(null,"");break;default:t=ce(t=(e=8===e?t.parentNode:t).namespaceURI||null,e=e.tagName)}Nr(Ko),Cr(Ko,t)}function Jo(){Nr(Ko),Nr(qo),Nr(Xo)}function Zo(e){Yo(Xo.current);var t=Yo(Ko.current),n=ce(t,e.type);t!==n&&(Cr(qo,e),Cr(Ko,n))}function $o(e){qo.current===e&&(Nr(Ko),Nr(qo))}var es=Sr(0);function ts(e){for(var t=e;null!==t;){if(13===t.tag){var n=t.memoizedState;if(null!==n&&(null===(n=n.dehydrated)||"$?"===n.data||"$!"===n.data))return t}else if(19===t.tag&&void 0!==t.memoizedProps.revealOrder){if(0!==(128&t.flags))return t}else if(null!==t.child){t.child.return=t,t=t.child;continue}if(t===e)break;for(;null===t.sibling;){if(null===t.return||t.return===e)return null;t=t.return}t.sibling.return=t.return,t=t.sibling}return null}var ns=[];function as(){for(var e=0;e<ns.length;e++)ns[e]._workInProgressVersionPrimary=null;ns.length=0}var rs=v.ReactCurrentDispatcher,os=v.ReactCurrentBatchConfig,ss=0,is=null,cs=null,ls=null,us=!1,ds=!1,hs=0,ps=0;function fs(){throw Error(o(321))}function ms(e,t){if(null===t)return!1;for(var n=0;n<t.length&&n<e.length;n++)if(!ia(e[n],t[n]))return!1;return!0}function gs(e,t,n,a,r,s){if(ss=s,is=t,t.memoizedState=null,t.updateQueue=null,t.lanes=0,rs.current=null===e||null===e.memoizedState?$s:ei,e=n(a,r),ds){s=0;do{if(ds=!1,hs=0,25<=s)throw Error(o(301));s+=1,ls=cs=null,t.updateQueue=null,rs.current=ti,e=n(a,r)}while(ds)}if(rs.current=Zs,t=null!==cs&&null!==cs.next,ss=0,ls=cs=is=null,us=!1,t)throw Error(o(300));return e}function bs(){var e=0!==hs;return hs=0,e}function ys(){var e={memoizedState:null,baseState:null,baseQueue:null,queue:null,next:null};return null===ls?is.memoizedState=ls=e:ls=ls.next=e,ls}function xs(){if(null===cs){var e=is.alternate;e=null!==e?e.memoizedState:null}else e=cs.next;var t=null===ls?is.memoizedState:ls.next;if(null!==t)ls=t,cs=e;else{if(null===e)throw Error(o(310));e={memoizedState:(cs=e).memoizedState,baseState:cs.baseState,baseQueue:cs.baseQueue,queue:cs.queue,next:null},null===ls?is.memoizedState=ls=e:ls=ls.next=e}return ls}function vs(e,t){return"function"===typeof t?t(e):t}function ws(e){var t=xs(),n=t.queue;if(null===n)throw Error(o(311));n.lastRenderedReducer=e;var a=cs,r=a.baseQueue,s=n.pending;if(null!==s){if(null!==r){var i=r.next;r.next=s.next,s.next=i}a.baseQueue=r=s,n.pending=null}if(null!==r){s=r.next,a=a.baseState;var c=i=null,l=null,u=s;do{var d=u.lane;if((ss&d)===d)null!==l&&(l=l.next={lane:0,action:u.action,hasEagerState:u.hasEagerState,eagerState:u.eagerState,next:null}),a=u.hasEagerState?u.eagerState:e(a,u.action);else{var h={lane:d,action:u.action,hasEagerState:u.hasEagerState,eagerState:u.eagerState,next:null};null===l?(c=l=h,i=a):l=l.next=h,is.lanes|=d,Lc|=d}u=u.next}while(null!==u&&u!==s);null===l?i=a:l.next=c,ia(a,t.memoizedState)||(xi=!0),t.memoizedState=a,t.baseState=i,t.baseQueue=l,n.lastRenderedState=a}if(null!==(e=n.interleaved)){r=e;do{s=r.lane,is.lanes|=s,Lc|=s,r=r.next}while(r!==e)}else null===r&&(n.lanes=0);return[t.memoizedState,n.dispatch]}function ks(e){var t=xs(),n=t.queue;if(null===n)throw Error(o(311));n.lastRenderedReducer=e;var a=n.dispatch,r=n.pending,s=t.memoizedState;if(null!==r){n.pending=null;var i=r=r.next;do{s=e(s,i.action),i=i.next}while(i!==r);ia(s,t.memoizedState)||(xi=!0),t.memoizedState=s,null===t.baseQueue&&(t.baseState=s),n.lastRenderedState=s}return[s,a]}function Is(){}function Ss(e,t){var n=is,a=xs(),r=t(),s=!ia(a.memoizedState,r);if(s&&(a.memoizedState=r,xi=!0),a=a.queue,Ls(Ts.bind(null,n,a,e),[e]),a.getSnapshot!==t||s||null!==ls&&1&ls.memoizedState.tag){if(n.flags|=2048,As(9,Cs.bind(null,n,a,r,t),void 0,null),null===Rc)throw Error(o(349));0!==(30&ss)||Ns(n,t,r)}return r}function Ns(e,t,n){e.flags|=16384,e={getSnapshot:t,value:n},null===(t=is.updateQueue)?(t={lastEffect:null,stores:null},is.updateQueue=t,t.stores=[e]):null===(n=t.stores)?t.stores=[e]:n.push(e)}function Cs(e,t,n,a){t.value=n,t.getSnapshot=a,Es(t)&&Rs(e)}function Ts(e,t,n){return n((function(){Es(t)&&Rs(e)}))}function Es(e){var t=e.getSnapshot;e=e.value;try{var n=t();return!ia(e,n)}catch(a){return!0}}function Rs(e){var t=Mo(e,1);null!==t&&nl(t,e,1,-1)}function _s(e){var t=ys();return"function"===typeof e&&(e=e()),t.memoizedState=t.baseState=e,e={pending:null,interleaved:null,lanes:0,dispatch:null,lastRenderedReducer:vs,lastRenderedState:e},t.queue=e,e=e.dispatch=Xs.bind(null,is,e),[t.memoizedState,e]}function As(e,t,n,a){return e={tag:e,create:t,destroy:n,deps:a,next:null},null===(t=is.updateQueue)?(t={lastEffect:null,stores:null},is.updateQueue=t,t.lastEffect=e.next=e):null===(n=t.lastEffect)?t.lastEffect=e.next=e:(a=n.next,n.next=e,e.next=a,t.lastEffect=e),e}function Fs(){return xs().memoizedState}function Os(e,t,n,a){var r=ys();is.flags|=e,r.memoizedState=As(1|t,n,void 0,void 0===a?null:a)}function Ds(e,t,n,a){var r=xs();a=void 0===a?null:a;var o=void 0;if(null!==cs){var s=cs.memoizedState;if(o=s.destroy,null!==a&&ms(a,s.deps))return void(r.memoizedState=As(t,n,o,a))}is.flags|=e,r.memoizedState=As(1|t,n,o,a)}function Ms(e,t){return Os(8390656,8,e,t)}function Ls(e,t){return Ds(2048,8,e,t)}function Ps(e,t){return Ds(4,2,e,t)}function zs(e,t){return Ds(4,4,e,t)}function Bs(e,t){return"function"===typeof t?(e=e(),t(e),function(){t(null)}):null!==t&&void 0!==t?(e=e(),t.current=e,function(){t.current=null}):void 0}function Ws(e,t,n){return n=null!==n&&void 0!==n?n.concat([e]):null,Ds(4,4,Bs.bind(null,t,e),n)}function Vs(){}function Us(e,t){var n=xs();t=void 0===t?null:t;var a=n.memoizedState;return null!==a&&null!==t&&ms(t,a[1])?a[0]:(n.memoizedState=[e,t],e)}function Gs(e,t){var n=xs();t=void 0===t?null:t;var a=n.memoizedState;return null!==a&&null!==t&&ms(t,a[1])?a[0]:(e=e(),n.memoizedState=[e,t],e)}function Hs(e,t,n){return 0===(21&ss)?(e.baseState&&(e.baseState=!1,xi=!0),e.memoizedState=n):(ia(n,t)||(n=mt(),is.lanes|=n,Lc|=n,e.baseState=!0),t)}function js(e,t){var n=xt;xt=0!==n&&4>n?n:4,e(!0);var a=os.transition;os.transition={};try{e(!1),t()}finally{xt=n,os.transition=a}}function Ks(){return xs().memoizedState}function qs(e,t,n){var a=tl(e);if(n={lane:a,action:n,hasEagerState:!1,eagerState:null,next:null},Ys(e))Qs(t,n);else if(null!==(n=Do(e,t,n,a))){nl(n,e,a,el()),Js(n,t,a)}}function Xs(e,t,n){var a=tl(e),r={lane:a,action:n,hasEagerState:!1,eagerState:null,next:null};if(Ys(e))Qs(t,r);else{var o=e.alternate;if(0===e.lanes&&(null===o||0===o.lanes)&&null!==(o=t.lastRenderedReducer))try{var s=t.lastRenderedState,i=o(s,n);if(r.hasEagerState=!0,r.eagerState=i,ia(i,s)){var c=t.interleaved;return null===c?(r.next=r,Oo(t)):(r.next=c.next,c.next=r),void(t.interleaved=r)}}catch(l){}null!==(n=Do(e,t,r,a))&&(nl(n,e,a,r=el()),Js(n,t,a))}}function Ys(e){var t=e.alternate;return e===is||null!==t&&t===is}function Qs(e,t){ds=us=!0;var n=e.pending;null===n?t.next=t:(t.next=n.next,n.next=t),e.pending=t}function Js(e,t,n){if(0!==(4194240&n)){var a=t.lanes;n|=a&=e.pendingLanes,t.lanes=n,yt(e,n)}}var Zs={readContext:Ao,useCallback:fs,useContext:fs,useEffect:fs,useImperativeHandle:fs,useInsertionEffect:fs,useLayoutEffect:fs,useMemo:fs,useReducer:fs,useRef:fs,useState:fs,useDebugValue:fs,useDeferredValue:fs,useTransition:fs,useMutableSource:fs,useSyncExternalStore:fs,useId:fs,unstable_isNewReconciler:!1},$s={readContext:Ao,useCallback:function(e,t){return ys().memoizedState=[e,void 0===t?null:t],e},useContext:Ao,useEffect:Ms,useImperativeHandle:function(e,t,n){return n=null!==n&&void 0!==n?n.concat([e]):null,Os(4194308,4,Bs.bind(null,t,e),n)},useLayoutEffect:function(e,t){return Os(4194308,4,e,t)},useInsertionEffect:function(e,t){return Os(4,2,e,t)},useMemo:function(e,t){var n=ys();return t=void 0===t?null:t,e=e(),n.memoizedState=[e,t],e},useReducer:function(e,t,n){var a=ys();return t=void 0!==n?n(t):t,a.memoizedState=a.baseState=t,e={pending:null,interleaved:null,lanes:0,dispatch:null,lastRenderedReducer:e,lastRenderedState:t},a.queue=e,e=e.dispatch=qs.bind(null,is,e),[a.memoizedState,e]},useRef:function(e){return e={current:e},ys().memoizedState=e},useState:_s,useDebugValue:Vs,useDeferredValue:function(e){return ys().memoizedState=e},useTransition:function(){var e=_s(!1),t=e[0];return e=js.bind(null,e[1]),ys().memoizedState=e,[t,e]},useMutableSource:function(){},useSyncExternalStore:function(e,t,n){var a=is,r=ys();if(ro){if(void 0===n)throw Error(o(407));n=n()}else{if(n=t(),null===Rc)throw Error(o(349));0!==(30&ss)||Ns(a,t,n)}r.memoizedState=n;var s={value:n,getSnapshot:t};return r.queue=s,Ms(Ts.bind(null,a,s,e),[e]),a.flags|=2048,As(9,Cs.bind(null,a,s,n,t),void 0,null),n},useId:function(){var e=ys(),t=Rc.identifierPrefix;if(ro){var n=Jr;t=":"+t+"R"+(n=(Qr&~(1<<32-st(Qr)-1)).toString(32)+n),0<(n=hs++)&&(t+="H"+n.toString(32)),t+=":"}else t=":"+t+"r"+(n=ps++).toString(32)+":";return e.memoizedState=t},unstable_isNewReconciler:!1},ei={readContext:Ao,useCallback:Us,useContext:Ao,useEffect:Ls,useImperativeHandle:Ws,useInsertionEffect:Ps,useLayoutEffect:zs,useMemo:Gs,useReducer:ws,useRef:Fs,useState:function(){return ws(vs)},useDebugValue:Vs,useDeferredValue:function(e){return Hs(xs(),cs.memoizedState,e)},useTransition:function(){return[ws(vs)[0],xs().memoizedState]},useMutableSource:Is,useSyncExternalStore:Ss,useId:Ks,unstable_isNewReconciler:!1},ti={readContext:Ao,useCallback:Us,useContext:Ao,useEffect:Ls,useImperativeHandle:Ws,useInsertionEffect:Ps,useLayoutEffect:zs,useMemo:Gs,useReducer:ks,useRef:Fs,useState:function(){return ks(vs)},useDebugValue:Vs,useDeferredValue:function(e){var t=xs();return null===cs?t.memoizedState=e:Hs(t,cs.memoizedState,e)},useTransition:function(){return[ks(vs)[0],xs().memoizedState]},useMutableSource:Is,useSyncExternalStore:Ss,useId:Ks,unstable_isNewReconciler:!1};function ni(e,t){if(e&&e.defaultProps){for(var n in t=P({},t),e=e.defaultProps)void 0===t[n]&&(t[n]=e[n]);return t}return t}function ai(e,t,n,a){n=null===(n=n(a,t=e.memoizedState))||void 0===n?t:P({},t,n),e.memoizedState=n,0===e.lanes&&(e.updateQueue.baseState=n)}var ri={isMounted:function(e){return!!(e=e._reactInternals)&&Ue(e)===e},enqueueSetState:function(e,t,n){e=e._reactInternals;var a=el(),r=tl(e),o=Bo(a,r);o.payload=t,void 0!==n&&null!==n&&(o.callback=n),null!==(t=Wo(e,o,r))&&(nl(t,e,r,a),Vo(t,e,r))},enqueueReplaceState:function(e,t,n){e=e._reactInternals;var a=el(),r=tl(e),o=Bo(a,r);o.tag=1,o.payload=t,void 0!==n&&null!==n&&(o.callback=n),null!==(t=Wo(e,o,r))&&(nl(t,e,r,a),Vo(t,e,r))},enqueueForceUpdate:function(e,t){e=e._reactInternals;var n=el(),a=tl(e),r=Bo(n,a);r.tag=2,void 0!==t&&null!==t&&(r.callback=t),null!==(t=Wo(e,r,a))&&(nl(t,e,a,n),Vo(t,e,a))}};function oi(e,t,n,a,r,o,s){return"function"===typeof(e=e.stateNode).shouldComponentUpdate?e.shouldComponentUpdate(a,o,s):!t.prototype||!t.prototype.isPureReactComponent||(!ca(n,a)||!ca(r,o))}function si(e,t,n){var a=!1,r=Tr,o=t.contextType;return"object"===typeof o&&null!==o?o=Ao(o):(r=Fr(t)?_r:Er.current,o=(a=null!==(a=t.contextTypes)&&void 0!==a)?Ar(e,r):Tr),t=new t(n,o),e.memoizedState=null!==t.state&&void 0!==t.state?t.state:null,t.updater=ri,e.stateNode=t,t._reactInternals=e,a&&((e=e.stateNode).__reactInternalMemoizedUnmaskedChildContext=r,e.__reactInternalMemoizedMaskedChildContext=o),t}function ii(e,t,n,a){e=t.state,"function"===typeof t.componentWillReceiveProps&&t.componentWillReceiveProps(n,a),"function"===typeof t.UNSAFE_componentWillReceiveProps&&t.UNSAFE_componentWillReceiveProps(n,a),t.state!==e&&ri.enqueueReplaceState(t,t.state,null)}function ci(e,t,n,a){var r=e.stateNode;r.props=n,r.state=e.memoizedState,r.refs={},Po(e);var o=t.contextType;"object"===typeof o&&null!==o?r.context=Ao(o):(o=Fr(t)?_r:Er.current,r.context=Ar(e,o)),r.state=e.memoizedState,"function"===typeof(o=t.getDerivedStateFromProps)&&(ai(e,t,o,n),r.state=e.memoizedState),"function"===typeof t.getDerivedStateFromProps||"function"===typeof r.getSnapshotBeforeUpdate||"function"!==typeof r.UNSAFE_componentWillMount&&"function"!==typeof r.componentWillMount||(t=r.state,"function"===typeof r.componentWillMount&&r.componentWillMount(),"function"===typeof r.UNSAFE_componentWillMount&&r.UNSAFE_componentWillMount(),t!==r.state&&ri.enqueueReplaceState(r,r.state,null),Go(e,n,r,a),r.state=e.memoizedState),"function"===typeof r.componentDidMount&&(e.flags|=4194308)}function li(e,t){try{var n="",a=t;do{n+=V(a),a=a.return}while(a);var r=n}catch(o){r="\nError generating stack: "+o.message+"\n"+o.stack}return{value:e,source:t,stack:r,digest:null}}function ui(e,t,n){return{value:e,source:null,stack:null!=n?n:null,digest:null!=t?t:null}}function di(e,t){try{console.error(t.value)}catch(n){setTimeout((function(){throw n}))}}var hi="function"===typeof WeakMap?WeakMap:Map;function pi(e,t,n){(n=Bo(-1,n)).tag=3,n.payload={element:null};var a=t.value;return n.callback=function(){Hc||(Hc=!0,jc=a),di(0,t)},n}function fi(e,t,n){(n=Bo(-1,n)).tag=3;var a=e.type.getDerivedStateFromError;if("function"===typeof a){var r=t.value;n.payload=function(){return a(r)},n.callback=function(){di(0,t)}}var o=e.stateNode;return null!==o&&"function"===typeof o.componentDidCatch&&(n.callback=function(){di(0,t),"function"!==typeof a&&(null===Kc?Kc=new Set([this]):Kc.add(this));var e=t.stack;this.componentDidCatch(t.value,{componentStack:null!==e?e:""})}),n}function mi(e,t,n){var a=e.pingCache;if(null===a){a=e.pingCache=new hi;var r=new Set;a.set(t,r)}else void 0===(r=a.get(t))&&(r=new Set,a.set(t,r));r.has(n)||(r.add(n),e=Nl.bind(null,e,t,n),t.then(e,e))}function gi(e){do{var t;if((t=13===e.tag)&&(t=null===(t=e.memoizedState)||null!==t.dehydrated),t)return e;e=e.return}while(null!==e);return null}function bi(e,t,n,a,r){return 0===(1&e.mode)?(e===t?e.flags|=65536:(e.flags|=128,n.flags|=131072,n.flags&=-52805,1===n.tag&&(null===n.alternate?n.tag=17:((t=Bo(-1,1)).tag=2,Wo(n,t,1))),n.lanes|=1),e):(e.flags|=65536,e.lanes=r,e)}var yi=v.ReactCurrentOwner,xi=!1;function vi(e,t,n,a){t.child=null===e?ko(t,null,n,a):wo(t,e.child,n,a)}function wi(e,t,n,a,r){n=n.render;var o=t.ref;return _o(t,r),a=gs(e,t,n,a,o,r),n=bs(),null===e||xi?(ro&&n&&eo(t),t.flags|=1,vi(e,t,a,r),t.child):(t.updateQueue=e.updateQueue,t.flags&=-2053,e.lanes&=~r,Hi(e,t,r))}function ki(e,t,n,a,r){if(null===e){var o=n.type;return"function"!==typeof o||Fl(o)||void 0!==o.defaultProps||null!==n.compare||void 0!==n.defaultProps?((e=Dl(n.type,null,a,t,t.mode,r)).ref=t.ref,e.return=t,t.child=e):(t.tag=15,t.type=o,Ii(e,t,o,a,r))}if(o=e.child,0===(e.lanes&r)){var s=o.memoizedProps;if((n=null!==(n=n.compare)?n:ca)(s,a)&&e.ref===t.ref)return Hi(e,t,r)}return t.flags|=1,(e=Ol(o,a)).ref=t.ref,e.return=t,t.child=e}function Ii(e,t,n,a,r){if(null!==e){var o=e.memoizedProps;if(ca(o,a)&&e.ref===t.ref){if(xi=!1,t.pendingProps=a=o,0===(e.lanes&r))return t.lanes=e.lanes,Hi(e,t,r);0!==(131072&e.flags)&&(xi=!0)}}return Ci(e,t,n,a,r)}function Si(e,t,n){var a=t.pendingProps,r=a.children,o=null!==e?e.memoizedState:null;if("hidden"===a.mode)if(0===(1&t.mode))t.memoizedState={baseLanes:0,cachePool:null,transitions:null},Cr(Oc,Fc),Fc|=n;else{if(0===(1073741824&n))return e=null!==o?o.baseLanes|n:n,t.lanes=t.childLanes=1073741824,t.memoizedState={baseLanes:e,cachePool:null,transitions:null},t.updateQueue=null,Cr(Oc,Fc),Fc|=e,null;t.memoizedState={baseLanes:0,cachePool:null,transitions:null},a=null!==o?o.baseLanes:n,Cr(Oc,Fc),Fc|=a}else null!==o?(a=o.baseLanes|n,t.memoizedState=null):a=n,Cr(Oc,Fc),Fc|=a;return vi(e,t,r,n),t.child}function Ni(e,t){var n=t.ref;(null===e&&null!==n||null!==e&&e.ref!==n)&&(t.flags|=512,t.flags|=2097152)}function Ci(e,t,n,a,r){var o=Fr(n)?_r:Er.current;return o=Ar(t,o),_o(t,r),n=gs(e,t,n,a,o,r),a=bs(),null===e||xi?(ro&&a&&eo(t),t.flags|=1,vi(e,t,n,r),t.child):(t.updateQueue=e.updateQueue,t.flags&=-2053,e.lanes&=~r,Hi(e,t,r))}function Ti(e,t,n,a,r){if(Fr(n)){var o=!0;Lr(t)}else o=!1;if(_o(t,r),null===t.stateNode)Gi(e,t),si(t,n,a),ci(t,n,a,r),a=!0;else if(null===e){var s=t.stateNode,i=t.memoizedProps;s.props=i;var c=s.context,l=n.contextType;"object"===typeof l&&null!==l?l=Ao(l):l=Ar(t,l=Fr(n)?_r:Er.current);var u=n.getDerivedStateFromProps,d="function"===typeof u||"function"===typeof s.getSnapshotBeforeUpdate;d||"function"!==typeof s.UNSAFE_componentWillReceiveProps&&"function"!==typeof s.componentWillReceiveProps||(i!==a||c!==l)&&ii(t,s,a,l),Lo=!1;var h=t.memoizedState;s.state=h,Go(t,a,s,r),c=t.memoizedState,i!==a||h!==c||Rr.current||Lo?("function"===typeof u&&(ai(t,n,u,a),c=t.memoizedState),(i=Lo||oi(t,n,i,a,h,c,l))?(d||"function"!==typeof s.UNSAFE_componentWillMount&&"function"!==typeof s.componentWillMount||("function"===typeof s.componentWillMount&&s.componentWillMount(),"function"===typeof s.UNSAFE_componentWillMount&&s.UNSAFE_componentWillMount()),"function"===typeof s.componentDidMount&&(t.flags|=4194308)):("function"===typeof s.componentDidMount&&(t.flags|=4194308),t.memoizedProps=a,t.memoizedState=c),s.props=a,s.state=c,s.context=l,a=i):("function"===typeof s.componentDidMount&&(t.flags|=4194308),a=!1)}else{s=t.stateNode,zo(e,t),i=t.memoizedProps,l=t.type===t.elementType?i:ni(t.type,i),s.props=l,d=t.pendingProps,h=s.context,"object"===typeof(c=n.contextType)&&null!==c?c=Ao(c):c=Ar(t,c=Fr(n)?_r:Er.current);var p=n.getDerivedStateFromProps;(u="function"===typeof p||"function"===typeof s.getSnapshotBeforeUpdate)||"function"!==typeof s.UNSAFE_componentWillReceiveProps&&"function"!==typeof s.componentWillReceiveProps||(i!==d||h!==c)&&ii(t,s,a,c),Lo=!1,h=t.memoizedState,s.state=h,Go(t,a,s,r);var f=t.memoizedState;i!==d||h!==f||Rr.current||Lo?("function"===typeof p&&(ai(t,n,p,a),f=t.memoizedState),(l=Lo||oi(t,n,l,a,h,f,c)||!1)?(u||"function"!==typeof s.UNSAFE_componentWillUpdate&&"function"!==typeof s.componentWillUpdate||("function"===typeof s.componentWillUpdate&&s.componentWillUpdate(a,f,c),"function"===typeof s.UNSAFE_componentWillUpdate&&s.UNSAFE_componentWillUpdate(a,f,c)),"function"===typeof s.componentDidUpdate&&(t.flags|=4),"function"===typeof s.getSnapshotBeforeUpdate&&(t.flags|=1024)):("function"!==typeof s.componentDidUpdate||i===e.memoizedProps&&h===e.memoizedState||(t.flags|=4),"function"!==typeof s.getSnapshotBeforeUpdate||i===e.memoizedProps&&h===e.memoizedState||(t.flags|=1024),t.memoizedProps=a,t.memoizedState=f),s.props=a,s.state=f,s.context=c,a=l):("function"!==typeof s.componentDidUpdate||i===e.memoizedProps&&h===e.memoizedState||(t.flags|=4),"function"!==typeof s.getSnapshotBeforeUpdate||i===e.memoizedProps&&h===e.memoizedState||(t.flags|=1024),a=!1)}return Ei(e,t,n,a,o,r)}function Ei(e,t,n,a,r,o){Ni(e,t);var s=0!==(128&t.flags);if(!a&&!s)return r&&Pr(t,n,!1),Hi(e,t,o);a=t.stateNode,yi.current=t;var i=s&&"function"!==typeof n.getDerivedStateFromError?null:a.render();return t.flags|=1,null!==e&&s?(t.child=wo(t,e.child,null,o),t.child=wo(t,null,i,o)):vi(e,t,i,o),t.memoizedState=a.state,r&&Pr(t,n,!0),t.child}function Ri(e){var t=e.stateNode;t.pendingContext?Dr(0,t.pendingContext,t.pendingContext!==t.context):t.context&&Dr(0,t.context,!1),Qo(e,t.containerInfo)}function _i(e,t,n,a,r){return fo(),mo(r),t.flags|=256,vi(e,t,n,a),t.child}var Ai,Fi,Oi,Di,Mi={dehydrated:null,treeContext:null,retryLane:0};function Li(e){return{baseLanes:e,cachePool:null,transitions:null}}function Pi(e,t,n){var a,r=t.pendingProps,s=es.current,i=!1,c=0!==(128&t.flags);if((a=c)||(a=(null===e||null!==e.memoizedState)&&0!==(2&s)),a?(i=!0,t.flags&=-129):null!==e&&null===e.memoizedState||(s|=1),Cr(es,1&s),null===e)return lo(t),null!==(e=t.memoizedState)&&null!==(e=e.dehydrated)?(0===(1&t.mode)?t.lanes=1:"$!"===e.data?t.lanes=8:t.lanes=1073741824,null):(c=r.children,e=r.fallback,i?(r=t.mode,i=t.child,c={mode:"hidden",children:c},0===(1&r)&&null!==i?(i.childLanes=0,i.pendingProps=c):i=Ll(c,r,0,null),e=Ml(e,r,n,null),i.return=t,e.return=t,i.sibling=e,t.child=i,t.child.memoizedState=Li(n),t.memoizedState=Mi,e):zi(t,c));if(null!==(s=e.memoizedState)&&null!==(a=s.dehydrated))return function(e,t,n,a,r,s,i){if(n)return 256&t.flags?(t.flags&=-257,Bi(e,t,i,a=ui(Error(o(422))))):null!==t.memoizedState?(t.child=e.child,t.flags|=128,null):(s=a.fallback,r=t.mode,a=Ll({mode:"visible",children:a.children},r,0,null),(s=Ml(s,r,i,null)).flags|=2,a.return=t,s.return=t,a.sibling=s,t.child=a,0!==(1&t.mode)&&wo(t,e.child,null,i),t.child.memoizedState=Li(i),t.memoizedState=Mi,s);if(0===(1&t.mode))return Bi(e,t,i,null);if("$!"===r.data){if(a=r.nextSibling&&r.nextSibling.dataset)var c=a.dgst;return a=c,Bi(e,t,i,a=ui(s=Error(o(419)),a,void 0))}if(c=0!==(i&e.childLanes),xi||c){if(null!==(a=Rc)){switch(i&-i){case 4:r=2;break;case 16:r=8;break;case 64:case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:case 4194304:case 8388608:case 16777216:case 33554432:case 67108864:r=32;break;case 536870912:r=268435456;break;default:r=0}0!==(r=0!==(r&(a.suspendedLanes|i))?0:r)&&r!==s.retryLane&&(s.retryLane=r,Mo(e,r),nl(a,e,r,-1))}return ml(),Bi(e,t,i,a=ui(Error(o(421))))}return"$?"===r.data?(t.flags|=128,t.child=e.child,t=Tl.bind(null,e),r._reactRetry=t,null):(e=s.treeContext,ao=lr(r.nextSibling),no=t,ro=!0,oo=null,null!==e&&(qr[Xr++]=Qr,qr[Xr++]=Jr,qr[Xr++]=Yr,Qr=e.id,Jr=e.overflow,Yr=t),t=zi(t,a.children),t.flags|=4096,t)}(e,t,c,r,a,s,n);if(i){i=r.fallback,c=t.mode,a=(s=e.child).sibling;var l={mode:"hidden",children:r.children};return 0===(1&c)&&t.child!==s?((r=t.child).childLanes=0,r.pendingProps=l,t.deletions=null):(r=Ol(s,l)).subtreeFlags=14680064&s.subtreeFlags,null!==a?i=Ol(a,i):(i=Ml(i,c,n,null)).flags|=2,i.return=t,r.return=t,r.sibling=i,t.child=r,r=i,i=t.child,c=null===(c=e.child.memoizedState)?Li(n):{baseLanes:c.baseLanes|n,cachePool:null,transitions:c.transitions},i.memoizedState=c,i.childLanes=e.childLanes&~n,t.memoizedState=Mi,r}return e=(i=e.child).sibling,r=Ol(i,{mode:"visible",children:r.children}),0===(1&t.mode)&&(r.lanes=n),r.return=t,r.sibling=null,null!==e&&(null===(n=t.deletions)?(t.deletions=[e],t.flags|=16):n.push(e)),t.child=r,t.memoizedState=null,r}function zi(e,t){return(t=Ll({mode:"visible",children:t},e.mode,0,null)).return=e,e.child=t}function Bi(e,t,n,a){return null!==a&&mo(a),wo(t,e.child,null,n),(e=zi(t,t.pendingProps.children)).flags|=2,t.memoizedState=null,e}function Wi(e,t,n){e.lanes|=t;var a=e.alternate;null!==a&&(a.lanes|=t),Ro(e.return,t,n)}function Vi(e,t,n,a,r){var o=e.memoizedState;null===o?e.memoizedState={isBackwards:t,rendering:null,renderingStartTime:0,last:a,tail:n,tailMode:r}:(o.isBackwards=t,o.rendering=null,o.renderingStartTime=0,o.last=a,o.tail=n,o.tailMode=r)}function Ui(e,t,n){var a=t.pendingProps,r=a.revealOrder,o=a.tail;if(vi(e,t,a.children,n),0!==(2&(a=es.current)))a=1&a|2,t.flags|=128;else{if(null!==e&&0!==(128&e.flags))e:for(e=t.child;null!==e;){if(13===e.tag)null!==e.memoizedState&&Wi(e,n,t);else if(19===e.tag)Wi(e,n,t);else if(null!==e.child){e.child.return=e,e=e.child;continue}if(e===t)break e;for(;null===e.sibling;){if(null===e.return||e.return===t)break e;e=e.return}e.sibling.return=e.return,e=e.sibling}a&=1}if(Cr(es,a),0===(1&t.mode))t.memoizedState=null;else switch(r){case"forwards":for(n=t.child,r=null;null!==n;)null!==(e=n.alternate)&&null===ts(e)&&(r=n),n=n.sibling;null===(n=r)?(r=t.child,t.child=null):(r=n.sibling,n.sibling=null),Vi(t,!1,r,n,o);break;case"backwards":for(n=null,r=t.child,t.child=null;null!==r;){if(null!==(e=r.alternate)&&null===ts(e)){t.child=r;break}e=r.sibling,r.sibling=n,n=r,r=e}Vi(t,!0,n,null,o);break;case"together":Vi(t,!1,null,null,void 0);break;default:t.memoizedState=null}return t.child}function Gi(e,t){0===(1&t.mode)&&null!==e&&(e.alternate=null,t.alternate=null,t.flags|=2)}function Hi(e,t,n){if(null!==e&&(t.dependencies=e.dependencies),Lc|=t.lanes,0===(n&t.childLanes))return null;if(null!==e&&t.child!==e.child)throw Error(o(153));if(null!==t.child){for(n=Ol(e=t.child,e.pendingProps),t.child=n,n.return=t;null!==e.sibling;)e=e.sibling,(n=n.sibling=Ol(e,e.pendingProps)).return=t;n.sibling=null}return t.child}function ji(e,t){if(!ro)switch(e.tailMode){case"hidden":t=e.tail;for(var n=null;null!==t;)null!==t.alternate&&(n=t),t=t.sibling;null===n?e.tail=null:n.sibling=null;break;case"collapsed":n=e.tail;for(var a=null;null!==n;)null!==n.alternate&&(a=n),n=n.sibling;null===a?t||null===e.tail?e.tail=null:e.tail.sibling=null:a.sibling=null}}function Ki(e){var t=null!==e.alternate&&e.alternate.child===e.child,n=0,a=0;if(t)for(var r=e.child;null!==r;)n|=r.lanes|r.childLanes,a|=14680064&r.subtreeFlags,a|=14680064&r.flags,r.return=e,r=r.sibling;else for(r=e.child;null!==r;)n|=r.lanes|r.childLanes,a|=r.subtreeFlags,a|=r.flags,r.return=e,r=r.sibling;return e.subtreeFlags|=a,e.childLanes=n,t}function qi(e,t,n){var a=t.pendingProps;switch(to(t),t.tag){case 2:case 16:case 15:case 0:case 11:case 7:case 8:case 12:case 9:case 14:return Ki(t),null;case 1:case 17:return Fr(t.type)&&Or(),Ki(t),null;case 3:return a=t.stateNode,Jo(),Nr(Rr),Nr(Er),as(),a.pendingContext&&(a.context=a.pendingContext,a.pendingContext=null),null!==e&&null!==e.child||(ho(t)?t.flags|=4:null===e||e.memoizedState.isDehydrated&&0===(256&t.flags)||(t.flags|=1024,null!==oo&&(sl(oo),oo=null))),Fi(e,t),Ki(t),null;case 5:$o(t);var r=Yo(Xo.current);if(n=t.type,null!==e&&null!=t.stateNode)Oi(e,t,n,a,r),e.ref!==t.ref&&(t.flags|=512,t.flags|=2097152);else{if(!a){if(null===t.stateNode)throw Error(o(166));return Ki(t),null}if(e=Yo(Ko.current),ho(t)){a=t.stateNode,n=t.type;var s=t.memoizedProps;switch(a[hr]=t,a[pr]=s,e=0!==(1&t.mode),n){case"dialog":Ba("cancel",a),Ba("close",a);break;case"iframe":case"object":case"embed":Ba("load",a);break;case"video":case"audio":for(r=0;r<Ma.length;r++)Ba(Ma[r],a);break;case"source":Ba("error",a);break;case"img":case"image":case"link":Ba("error",a),Ba("load",a);break;case"details":Ba("toggle",a);break;case"input":Q(a,s),Ba("invalid",a);break;case"select":a._wrapperState={wasMultiple:!!s.multiple},Ba("invalid",a);break;case"textarea":re(a,s),Ba("invalid",a)}for(var c in ye(n,s),r=null,s)if(s.hasOwnProperty(c)){var l=s[c];"children"===c?"string"===typeof l?a.textContent!==l&&(!0!==s.suppressHydrationWarning&&Za(a.textContent,l,e),r=["children",l]):"number"===typeof l&&a.textContent!==""+l&&(!0!==s.suppressHydrationWarning&&Za(a.textContent,l,e),r=["children",""+l]):i.hasOwnProperty(c)&&null!=l&&"onScroll"===c&&Ba("scroll",a)}switch(n){case"input":K(a),$(a,s,!0);break;case"textarea":K(a),se(a);break;case"select":case"option":break;default:"function"===typeof s.onClick&&(a.onclick=$a)}a=r,t.updateQueue=a,null!==a&&(t.flags|=4)}else{c=9===r.nodeType?r:r.ownerDocument,"http://www.w3.org/1999/xhtml"===e&&(e=ie(n)),"http://www.w3.org/1999/xhtml"===e?"script"===n?((e=c.createElement("div")).innerHTML="<script><\/script>",e=e.removeChild(e.firstChild)):"string"===typeof a.is?e=c.createElement(n,{is:a.is}):(e=c.createElement(n),"select"===n&&(c=e,a.multiple?c.multiple=!0:a.size&&(c.size=a.size))):e=c.createElementNS(e,n),e[hr]=t,e[pr]=a,Ai(e,t,!1,!1),t.stateNode=e;e:{switch(c=xe(n,a),n){case"dialog":Ba("cancel",e),Ba("close",e),r=a;break;case"iframe":case"object":case"embed":Ba("load",e),r=a;break;case"video":case"audio":for(r=0;r<Ma.length;r++)Ba(Ma[r],e);r=a;break;case"source":Ba("error",e),r=a;break;case"img":case"image":case"link":Ba("error",e),Ba("load",e),r=a;break;case"details":Ba("toggle",e),r=a;break;case"input":Q(e,a),r=Y(e,a),Ba("invalid",e);break;case"option":default:r=a;break;case"select":e._wrapperState={wasMultiple:!!a.multiple},r=P({},a,{value:void 0}),Ba("invalid",e);break;case"textarea":re(e,a),r=ae(e,a),Ba("invalid",e)}for(s in ye(n,r),l=r)if(l.hasOwnProperty(s)){var u=l[s];"style"===s?ge(e,u):"dangerouslySetInnerHTML"===s?null!=(u=u?u.__html:void 0)&&de(e,u):"children"===s?"string"===typeof u?("textarea"!==n||""!==u)&&he(e,u):"number"===typeof u&&he(e,""+u):"suppressContentEditableWarning"!==s&&"suppressHydrationWarning"!==s&&"autoFocus"!==s&&(i.hasOwnProperty(s)?null!=u&&"onScroll"===s&&Ba("scroll",e):null!=u&&x(e,s,u,c))}switch(n){case"input":K(e),$(e,a,!1);break;case"textarea":K(e),se(e);break;case"option":null!=a.value&&e.setAttribute("value",""+H(a.value));break;case"select":e.multiple=!!a.multiple,null!=(s=a.value)?ne(e,!!a.multiple,s,!1):null!=a.defaultValue&&ne(e,!!a.multiple,a.defaultValue,!0);break;default:"function"===typeof r.onClick&&(e.onclick=$a)}switch(n){case"button":case"input":case"select":case"textarea":a=!!a.autoFocus;break e;case"img":a=!0;break e;default:a=!1}}a&&(t.flags|=4)}null!==t.ref&&(t.flags|=512,t.flags|=2097152)}return Ki(t),null;case 6:if(e&&null!=t.stateNode)Di(e,t,e.memoizedProps,a);else{if("string"!==typeof a&&null===t.stateNode)throw Error(o(166));if(n=Yo(Xo.current),Yo(Ko.current),ho(t)){if(a=t.stateNode,n=t.memoizedProps,a[hr]=t,(s=a.nodeValue!==n)&&null!==(e=no))switch(e.tag){case 3:Za(a.nodeValue,n,0!==(1&e.mode));break;case 5:!0!==e.memoizedProps.suppressHydrationWarning&&Za(a.nodeValue,n,0!==(1&e.mode))}s&&(t.flags|=4)}else(a=(9===n.nodeType?n:n.ownerDocument).createTextNode(a))[hr]=t,t.stateNode=a}return Ki(t),null;case 13:if(Nr(es),a=t.memoizedState,null===e||null!==e.memoizedState&&null!==e.memoizedState.dehydrated){if(ro&&null!==ao&&0!==(1&t.mode)&&0===(128&t.flags))po(),fo(),t.flags|=98560,s=!1;else if(s=ho(t),null!==a&&null!==a.dehydrated){if(null===e){if(!s)throw Error(o(318));if(!(s=null!==(s=t.memoizedState)?s.dehydrated:null))throw Error(o(317));s[hr]=t}else fo(),0===(128&t.flags)&&(t.memoizedState=null),t.flags|=4;Ki(t),s=!1}else null!==oo&&(sl(oo),oo=null),s=!0;if(!s)return 65536&t.flags?t:null}return 0!==(128&t.flags)?(t.lanes=n,t):((a=null!==a)!==(null!==e&&null!==e.memoizedState)&&a&&(t.child.flags|=8192,0!==(1&t.mode)&&(null===e||0!==(1&es.current)?0===Dc&&(Dc=3):ml())),null!==t.updateQueue&&(t.flags|=4),Ki(t),null);case 4:return Jo(),Fi(e,t),null===e&&Ua(t.stateNode.containerInfo),Ki(t),null;case 10:return Eo(t.type._context),Ki(t),null;case 19:if(Nr(es),null===(s=t.memoizedState))return Ki(t),null;if(a=0!==(128&t.flags),null===(c=s.rendering))if(a)ji(s,!1);else{if(0!==Dc||null!==e&&0!==(128&e.flags))for(e=t.child;null!==e;){if(null!==(c=ts(e))){for(t.flags|=128,ji(s,!1),null!==(a=c.updateQueue)&&(t.updateQueue=a,t.flags|=4),t.subtreeFlags=0,a=n,n=t.child;null!==n;)e=a,(s=n).flags&=14680066,null===(c=s.alternate)?(s.childLanes=0,s.lanes=e,s.child=null,s.subtreeFlags=0,s.memoizedProps=null,s.memoizedState=null,s.updateQueue=null,s.dependencies=null,s.stateNode=null):(s.childLanes=c.childLanes,s.lanes=c.lanes,s.child=c.child,s.subtreeFlags=0,s.deletions=null,s.memoizedProps=c.memoizedProps,s.memoizedState=c.memoizedState,s.updateQueue=c.updateQueue,s.type=c.type,e=c.dependencies,s.dependencies=null===e?null:{lanes:e.lanes,firstContext:e.firstContext}),n=n.sibling;return Cr(es,1&es.current|2),t.child}e=e.sibling}null!==s.tail&&Je()>Uc&&(t.flags|=128,a=!0,ji(s,!1),t.lanes=4194304)}else{if(!a)if(null!==(e=ts(c))){if(t.flags|=128,a=!0,null!==(n=e.updateQueue)&&(t.updateQueue=n,t.flags|=4),ji(s,!0),null===s.tail&&"hidden"===s.tailMode&&!c.alternate&&!ro)return Ki(t),null}else 2*Je()-s.renderingStartTime>Uc&&1073741824!==n&&(t.flags|=128,a=!0,ji(s,!1),t.lanes=4194304);s.isBackwards?(c.sibling=t.child,t.child=c):(null!==(n=s.last)?n.sibling=c:t.child=c,s.last=c)}return null!==s.tail?(t=s.tail,s.rendering=t,s.tail=t.sibling,s.renderingStartTime=Je(),t.sibling=null,n=es.current,Cr(es,a?1&n|2:1&n),t):(Ki(t),null);case 22:case 23:return dl(),a=null!==t.memoizedState,null!==e&&null!==e.memoizedState!==a&&(t.flags|=8192),a&&0!==(1&t.mode)?0!==(1073741824&Fc)&&(Ki(t),6&t.subtreeFlags&&(t.flags|=8192)):Ki(t),null;case 24:case 25:return null}throw Error(o(156,t.tag))}function Xi(e,t){switch(to(t),t.tag){case 1:return Fr(t.type)&&Or(),65536&(e=t.flags)?(t.flags=-65537&e|128,t):null;case 3:return Jo(),Nr(Rr),Nr(Er),as(),0!==(65536&(e=t.flags))&&0===(128&e)?(t.flags=-65537&e|128,t):null;case 5:return $o(t),null;case 13:if(Nr(es),null!==(e=t.memoizedState)&&null!==e.dehydrated){if(null===t.alternate)throw Error(o(340));fo()}return 65536&(e=t.flags)?(t.flags=-65537&e|128,t):null;case 19:return Nr(es),null;case 4:return Jo(),null;case 10:return Eo(t.type._context),null;case 22:case 23:return dl(),null;default:return null}}Ai=function(e,t){for(var n=t.child;null!==n;){if(5===n.tag||6===n.tag)e.appendChild(n.stateNode);else if(4!==n.tag&&null!==n.child){n.child.return=n,n=n.child;continue}if(n===t)break;for(;null===n.sibling;){if(null===n.return||n.return===t)return;n=n.return}n.sibling.return=n.return,n=n.sibling}},Fi=function(){},Oi=function(e,t,n,a){var r=e.memoizedProps;if(r!==a){e=t.stateNode,Yo(Ko.current);var o,s=null;switch(n){case"input":r=Y(e,r),a=Y(e,a),s=[];break;case"select":r=P({},r,{value:void 0}),a=P({},a,{value:void 0}),s=[];break;case"textarea":r=ae(e,r),a=ae(e,a),s=[];break;default:"function"!==typeof r.onClick&&"function"===typeof a.onClick&&(e.onclick=$a)}for(u in ye(n,a),n=null,r)if(!a.hasOwnProperty(u)&&r.hasOwnProperty(u)&&null!=r[u])if("style"===u){var c=r[u];for(o in c)c.hasOwnProperty(o)&&(n||(n={}),n[o]="")}else"dangerouslySetInnerHTML"!==u&&"children"!==u&&"suppressContentEditableWarning"!==u&&"suppressHydrationWarning"!==u&&"autoFocus"!==u&&(i.hasOwnProperty(u)?s||(s=[]):(s=s||[]).push(u,null));for(u in a){var l=a[u];if(c=null!=r?r[u]:void 0,a.hasOwnProperty(u)&&l!==c&&(null!=l||null!=c))if("style"===u)if(c){for(o in c)!c.hasOwnProperty(o)||l&&l.hasOwnProperty(o)||(n||(n={}),n[o]="");for(o in l)l.hasOwnProperty(o)&&c[o]!==l[o]&&(n||(n={}),n[o]=l[o])}else n||(s||(s=[]),s.push(u,n)),n=l;else"dangerouslySetInnerHTML"===u?(l=l?l.__html:void 0,c=c?c.__html:void 0,null!=l&&c!==l&&(s=s||[]).push(u,l)):"children"===u?"string"!==typeof l&&"number"!==typeof l||(s=s||[]).push(u,""+l):"suppressContentEditableWarning"!==u&&"suppressHydrationWarning"!==u&&(i.hasOwnProperty(u)?(null!=l&&"onScroll"===u&&Ba("scroll",e),s||c===l||(s=[])):(s=s||[]).push(u,l))}n&&(s=s||[]).push("style",n);var u=s;(t.updateQueue=u)&&(t.flags|=4)}},Di=function(e,t,n,a){n!==a&&(t.flags|=4)};var Yi=!1,Qi=!1,Ji="function"===typeof WeakSet?WeakSet:Set,Zi=null;function $i(e,t){var n=e.ref;if(null!==n)if("function"===typeof n)try{n(null)}catch(a){Sl(e,t,a)}else n.current=null}function ec(e,t,n){try{n()}catch(a){Sl(e,t,a)}}var tc=!1;function nc(e,t,n){var a=t.updateQueue;if(null!==(a=null!==a?a.lastEffect:null)){var r=a=a.next;do{if((r.tag&e)===e){var o=r.destroy;r.destroy=void 0,void 0!==o&&ec(t,n,o)}r=r.next}while(r!==a)}}function ac(e,t){if(null!==(t=null!==(t=t.updateQueue)?t.lastEffect:null)){var n=t=t.next;do{if((n.tag&e)===e){var a=n.create;n.destroy=a()}n=n.next}while(n!==t)}}function rc(e){var t=e.ref;if(null!==t){var n=e.stateNode;e.tag,e=n,"function"===typeof t?t(e):t.current=e}}function oc(e){var t=e.alternate;null!==t&&(e.alternate=null,oc(t)),e.child=null,e.deletions=null,e.sibling=null,5===e.tag&&(null!==(t=e.stateNode)&&(delete t[hr],delete t[pr],delete t[mr],delete t[gr],delete t[br])),e.stateNode=null,e.return=null,e.dependencies=null,e.memoizedProps=null,e.memoizedState=null,e.pendingProps=null,e.stateNode=null,e.updateQueue=null}function sc(e){return 5===e.tag||3===e.tag||4===e.tag}function ic(e){e:for(;;){for(;null===e.sibling;){if(null===e.return||sc(e.return))return null;e=e.return}for(e.sibling.return=e.return,e=e.sibling;5!==e.tag&&6!==e.tag&&18!==e.tag;){if(2&e.flags)continue e;if(null===e.child||4===e.tag)continue e;e.child.return=e,e=e.child}if(!(2&e.flags))return e.stateNode}}function cc(e,t,n){var a=e.tag;if(5===a||6===a)e=e.stateNode,t?8===n.nodeType?n.parentNode.insertBefore(e,t):n.insertBefore(e,t):(8===n.nodeType?(t=n.parentNode).insertBefore(e,n):(t=n).appendChild(e),null!==(n=n._reactRootContainer)&&void 0!==n||null!==t.onclick||(t.onclick=$a));else if(4!==a&&null!==(e=e.child))for(cc(e,t,n),e=e.sibling;null!==e;)cc(e,t,n),e=e.sibling}function lc(e,t,n){var a=e.tag;if(5===a||6===a)e=e.stateNode,t?n.insertBefore(e,t):n.appendChild(e);else if(4!==a&&null!==(e=e.child))for(lc(e,t,n),e=e.sibling;null!==e;)lc(e,t,n),e=e.sibling}var uc=null,dc=!1;function hc(e,t,n){for(n=n.child;null!==n;)pc(e,t,n),n=n.sibling}function pc(e,t,n){if(ot&&"function"===typeof ot.onCommitFiberUnmount)try{ot.onCommitFiberUnmount(rt,n)}catch(i){}switch(n.tag){case 5:Qi||$i(n,t);case 6:var a=uc,r=dc;uc=null,hc(e,t,n),dc=r,null!==(uc=a)&&(dc?(e=uc,n=n.stateNode,8===e.nodeType?e.parentNode.removeChild(n):e.removeChild(n)):uc.removeChild(n.stateNode));break;case 18:null!==uc&&(dc?(e=uc,n=n.stateNode,8===e.nodeType?cr(e.parentNode,n):1===e.nodeType&&cr(e,n),Ut(e)):cr(uc,n.stateNode));break;case 4:a=uc,r=dc,uc=n.stateNode.containerInfo,dc=!0,hc(e,t,n),uc=a,dc=r;break;case 0:case 11:case 14:case 15:if(!Qi&&(null!==(a=n.updateQueue)&&null!==(a=a.lastEffect))){r=a=a.next;do{var o=r,s=o.destroy;o=o.tag,void 0!==s&&(0!==(2&o)||0!==(4&o))&&ec(n,t,s),r=r.next}while(r!==a)}hc(e,t,n);break;case 1:if(!Qi&&($i(n,t),"function"===typeof(a=n.stateNode).componentWillUnmount))try{a.props=n.memoizedProps,a.state=n.memoizedState,a.componentWillUnmount()}catch(i){Sl(n,t,i)}hc(e,t,n);break;case 21:hc(e,t,n);break;case 22:1&n.mode?(Qi=(a=Qi)||null!==n.memoizedState,hc(e,t,n),Qi=a):hc(e,t,n);break;default:hc(e,t,n)}}function fc(e){var t=e.updateQueue;if(null!==t){e.updateQueue=null;var n=e.stateNode;null===n&&(n=e.stateNode=new Ji),t.forEach((function(t){var a=El.bind(null,e,t);n.has(t)||(n.add(t),t.then(a,a))}))}}function mc(e,t){var n=t.deletions;if(null!==n)for(var a=0;a<n.length;a++){var r=n[a];try{var s=e,i=t,c=i;e:for(;null!==c;){switch(c.tag){case 5:uc=c.stateNode,dc=!1;break e;case 3:case 4:uc=c.stateNode.containerInfo,dc=!0;break e}c=c.return}if(null===uc)throw Error(o(160));pc(s,i,r),uc=null,dc=!1;var l=r.alternate;null!==l&&(l.return=null),r.return=null}catch(u){Sl(r,t,u)}}if(12854&t.subtreeFlags)for(t=t.child;null!==t;)gc(t,e),t=t.sibling}function gc(e,t){var n=e.alternate,a=e.flags;switch(e.tag){case 0:case 11:case 14:case 15:if(mc(t,e),bc(e),4&a){try{nc(3,e,e.return),ac(3,e)}catch(g){Sl(e,e.return,g)}try{nc(5,e,e.return)}catch(g){Sl(e,e.return,g)}}break;case 1:mc(t,e),bc(e),512&a&&null!==n&&$i(n,n.return);break;case 5:if(mc(t,e),bc(e),512&a&&null!==n&&$i(n,n.return),32&e.flags){var r=e.stateNode;try{he(r,"")}catch(g){Sl(e,e.return,g)}}if(4&a&&null!=(r=e.stateNode)){var s=e.memoizedProps,i=null!==n?n.memoizedProps:s,c=e.type,l=e.updateQueue;if(e.updateQueue=null,null!==l)try{"input"===c&&"radio"===s.type&&null!=s.name&&J(r,s),xe(c,i);var u=xe(c,s);for(i=0;i<l.length;i+=2){var d=l[i],h=l[i+1];"style"===d?ge(r,h):"dangerouslySetInnerHTML"===d?de(r,h):"children"===d?he(r,h):x(r,d,h,u)}switch(c){case"input":Z(r,s);break;case"textarea":oe(r,s);break;case"select":var p=r._wrapperState.wasMultiple;r._wrapperState.wasMultiple=!!s.multiple;var f=s.value;null!=f?ne(r,!!s.multiple,f,!1):p!==!!s.multiple&&(null!=s.defaultValue?ne(r,!!s.multiple,s.defaultValue,!0):ne(r,!!s.multiple,s.multiple?[]:"",!1))}r[pr]=s}catch(g){Sl(e,e.return,g)}}break;case 6:if(mc(t,e),bc(e),4&a){if(null===e.stateNode)throw Error(o(162));r=e.stateNode,s=e.memoizedProps;try{r.nodeValue=s}catch(g){Sl(e,e.return,g)}}break;case 3:if(mc(t,e),bc(e),4&a&&null!==n&&n.memoizedState.isDehydrated)try{Ut(t.containerInfo)}catch(g){Sl(e,e.return,g)}break;case 4:default:mc(t,e),bc(e);break;case 13:mc(t,e),bc(e),8192&(r=e.child).flags&&(s=null!==r.memoizedState,r.stateNode.isHidden=s,!s||null!==r.alternate&&null!==r.alternate.memoizedState||(Vc=Je())),4&a&&fc(e);break;case 22:if(d=null!==n&&null!==n.memoizedState,1&e.mode?(Qi=(u=Qi)||d,mc(t,e),Qi=u):mc(t,e),bc(e),8192&a){if(u=null!==e.memoizedState,(e.stateNode.isHidden=u)&&!d&&0!==(1&e.mode))for(Zi=e,d=e.child;null!==d;){for(h=Zi=d;null!==Zi;){switch(f=(p=Zi).child,p.tag){case 0:case 11:case 14:case 15:nc(4,p,p.return);break;case 1:$i(p,p.return);var m=p.stateNode;if("function"===typeof m.componentWillUnmount){a=p,n=p.return;try{t=a,m.props=t.memoizedProps,m.state=t.memoizedState,m.componentWillUnmount()}catch(g){Sl(a,n,g)}}break;case 5:$i(p,p.return);break;case 22:if(null!==p.memoizedState){wc(h);continue}}null!==f?(f.return=p,Zi=f):wc(h)}d=d.sibling}e:for(d=null,h=e;;){if(5===h.tag){if(null===d){d=h;try{r=h.stateNode,u?"function"===typeof(s=r.style).setProperty?s.setProperty("display","none","important"):s.display="none":(c=h.stateNode,i=void 0!==(l=h.memoizedProps.style)&&null!==l&&l.hasOwnProperty("display")?l.display:null,c.style.display=me("display",i))}catch(g){Sl(e,e.return,g)}}}else if(6===h.tag){if(null===d)try{h.stateNode.nodeValue=u?"":h.memoizedProps}catch(g){Sl(e,e.return,g)}}else if((22!==h.tag&&23!==h.tag||null===h.memoizedState||h===e)&&null!==h.child){h.child.return=h,h=h.child;continue}if(h===e)break e;for(;null===h.sibling;){if(null===h.return||h.return===e)break e;d===h&&(d=null),h=h.return}d===h&&(d=null),h.sibling.return=h.return,h=h.sibling}}break;case 19:mc(t,e),bc(e),4&a&&fc(e);case 21:}}function bc(e){var t=e.flags;if(2&t){try{e:{for(var n=e.return;null!==n;){if(sc(n)){var a=n;break e}n=n.return}throw Error(o(160))}switch(a.tag){case 5:var r=a.stateNode;32&a.flags&&(he(r,""),a.flags&=-33),lc(e,ic(e),r);break;case 3:case 4:var s=a.stateNode.containerInfo;cc(e,ic(e),s);break;default:throw Error(o(161))}}catch(i){Sl(e,e.return,i)}e.flags&=-3}4096&t&&(e.flags&=-4097)}function yc(e,t,n){Zi=e,xc(e,t,n)}function xc(e,t,n){for(var a=0!==(1&e.mode);null!==Zi;){var r=Zi,o=r.child;if(22===r.tag&&a){var s=null!==r.memoizedState||Yi;if(!s){var i=r.alternate,c=null!==i&&null!==i.memoizedState||Qi;i=Yi;var l=Qi;if(Yi=s,(Qi=c)&&!l)for(Zi=r;null!==Zi;)c=(s=Zi).child,22===s.tag&&null!==s.memoizedState?kc(r):null!==c?(c.return=s,Zi=c):kc(r);for(;null!==o;)Zi=o,xc(o,t,n),o=o.sibling;Zi=r,Yi=i,Qi=l}vc(e)}else 0!==(8772&r.subtreeFlags)&&null!==o?(o.return=r,Zi=o):vc(e)}}function vc(e){for(;null!==Zi;){var t=Zi;if(0!==(8772&t.flags)){var n=t.alternate;try{if(0!==(8772&t.flags))switch(t.tag){case 0:case 11:case 15:Qi||ac(5,t);break;case 1:var a=t.stateNode;if(4&t.flags&&!Qi)if(null===n)a.componentDidMount();else{var r=t.elementType===t.type?n.memoizedProps:ni(t.type,n.memoizedProps);a.componentDidUpdate(r,n.memoizedState,a.__reactInternalSnapshotBeforeUpdate)}var s=t.updateQueue;null!==s&&Ho(t,s,a);break;case 3:var i=t.updateQueue;if(null!==i){if(n=null,null!==t.child)switch(t.child.tag){case 5:case 1:n=t.child.stateNode}Ho(t,i,n)}break;case 5:var c=t.stateNode;if(null===n&&4&t.flags){n=c;var l=t.memoizedProps;switch(t.type){case"button":case"input":case"select":case"textarea":l.autoFocus&&n.focus();break;case"img":l.src&&(n.src=l.src)}}break;case 6:case 4:case 12:case 19:case 17:case 21:case 22:case 23:case 25:break;case 13:if(null===t.memoizedState){var u=t.alternate;if(null!==u){var d=u.memoizedState;if(null!==d){var h=d.dehydrated;null!==h&&Ut(h)}}}break;default:throw Error(o(163))}Qi||512&t.flags&&rc(t)}catch(p){Sl(t,t.return,p)}}if(t===e){Zi=null;break}if(null!==(n=t.sibling)){n.return=t.return,Zi=n;break}Zi=t.return}}function wc(e){for(;null!==Zi;){var t=Zi;if(t===e){Zi=null;break}var n=t.sibling;if(null!==n){n.return=t.return,Zi=n;break}Zi=t.return}}function kc(e){for(;null!==Zi;){var t=Zi;try{switch(t.tag){case 0:case 11:case 15:var n=t.return;try{ac(4,t)}catch(c){Sl(t,n,c)}break;case 1:var a=t.stateNode;if("function"===typeof a.componentDidMount){var r=t.return;try{a.componentDidMount()}catch(c){Sl(t,r,c)}}var o=t.return;try{rc(t)}catch(c){Sl(t,o,c)}break;case 5:var s=t.return;try{rc(t)}catch(c){Sl(t,s,c)}}}catch(c){Sl(t,t.return,c)}if(t===e){Zi=null;break}var i=t.sibling;if(null!==i){i.return=t.return,Zi=i;break}Zi=t.return}}var Ic,Sc=Math.ceil,Nc=v.ReactCurrentDispatcher,Cc=v.ReactCurrentOwner,Tc=v.ReactCurrentBatchConfig,Ec=0,Rc=null,_c=null,Ac=0,Fc=0,Oc=Sr(0),Dc=0,Mc=null,Lc=0,Pc=0,zc=0,Bc=null,Wc=null,Vc=0,Uc=1/0,Gc=null,Hc=!1,jc=null,Kc=null,qc=!1,Xc=null,Yc=0,Qc=0,Jc=null,Zc=-1,$c=0;function el(){return 0!==(6&Ec)?Je():-1!==Zc?Zc:Zc=Je()}function tl(e){return 0===(1&e.mode)?1:0!==(2&Ec)&&0!==Ac?Ac&-Ac:null!==go.transition?(0===$c&&($c=mt()),$c):0!==(e=xt)?e:e=void 0===(e=window.event)?16:Qt(e.type)}function nl(e,t,n,a){if(50<Qc)throw Qc=0,Jc=null,Error(o(185));bt(e,n,a),0!==(2&Ec)&&e===Rc||(e===Rc&&(0===(2&Ec)&&(Pc|=n),4===Dc&&il(e,Ac)),al(e,a),1===n&&0===Ec&&0===(1&t.mode)&&(Uc=Je()+500,Br&&Ur()))}function al(e,t){var n=e.callbackNode;!function(e,t){for(var n=e.suspendedLanes,a=e.pingedLanes,r=e.expirationTimes,o=e.pendingLanes;0<o;){var s=31-st(o),i=1<<s,c=r[s];-1===c?0!==(i&n)&&0===(i&a)||(r[s]=pt(i,t)):c<=t&&(e.expiredLanes|=i),o&=~i}}(e,t);var a=ht(e,e===Rc?Ac:0);if(0===a)null!==n&&Xe(n),e.callbackNode=null,e.callbackPriority=0;else if(t=a&-a,e.callbackPriority!==t){if(null!=n&&Xe(n),1===t)0===e.tag?function(e){Br=!0,Vr(e)}(cl.bind(null,e)):Vr(cl.bind(null,e)),sr((function(){0===(6&Ec)&&Ur()})),n=null;else{switch(vt(a)){case 1:n=$e;break;case 4:n=et;break;case 16:default:n=tt;break;case 536870912:n=at}n=Rl(n,rl.bind(null,e))}e.callbackPriority=t,e.callbackNode=n}}function rl(e,t){if(Zc=-1,$c=0,0!==(6&Ec))throw Error(o(327));var n=e.callbackNode;if(kl()&&e.callbackNode!==n)return null;var a=ht(e,e===Rc?Ac:0);if(0===a)return null;if(0!==(30&a)||0!==(a&e.expiredLanes)||t)t=gl(e,a);else{t=a;var r=Ec;Ec|=2;var s=fl();for(Rc===e&&Ac===t||(Gc=null,Uc=Je()+500,hl(e,t));;)try{yl();break}catch(c){pl(e,c)}To(),Nc.current=s,Ec=r,null!==_c?t=0:(Rc=null,Ac=0,t=Dc)}if(0!==t){if(2===t&&(0!==(r=ft(e))&&(a=r,t=ol(e,r))),1===t)throw n=Mc,hl(e,0),il(e,a),al(e,Je()),n;if(6===t)il(e,a);else{if(r=e.current.alternate,0===(30&a)&&!function(e){for(var t=e;;){if(16384&t.flags){var n=t.updateQueue;if(null!==n&&null!==(n=n.stores))for(var a=0;a<n.length;a++){var r=n[a],o=r.getSnapshot;r=r.value;try{if(!ia(o(),r))return!1}catch(i){return!1}}}if(n=t.child,16384&t.subtreeFlags&&null!==n)n.return=t,t=n;else{if(t===e)break;for(;null===t.sibling;){if(null===t.return||t.return===e)return!0;t=t.return}t.sibling.return=t.return,t=t.sibling}}return!0}(r)&&(2===(t=gl(e,a))&&(0!==(s=ft(e))&&(a=s,t=ol(e,s))),1===t))throw n=Mc,hl(e,0),il(e,a),al(e,Je()),n;switch(e.finishedWork=r,e.finishedLanes=a,t){case 0:case 1:throw Error(o(345));case 2:case 5:wl(e,Wc,Gc);break;case 3:if(il(e,a),(130023424&a)===a&&10<(t=Vc+500-Je())){if(0!==ht(e,0))break;if(((r=e.suspendedLanes)&a)!==a){el(),e.pingedLanes|=e.suspendedLanes&r;break}e.timeoutHandle=ar(wl.bind(null,e,Wc,Gc),t);break}wl(e,Wc,Gc);break;case 4:if(il(e,a),(4194240&a)===a)break;for(t=e.eventTimes,r=-1;0<a;){var i=31-st(a);s=1<<i,(i=t[i])>r&&(r=i),a&=~s}if(a=r,10<(a=(120>(a=Je()-a)?120:480>a?480:1080>a?1080:1920>a?1920:3e3>a?3e3:4320>a?4320:1960*Sc(a/1960))-a)){e.timeoutHandle=ar(wl.bind(null,e,Wc,Gc),a);break}wl(e,Wc,Gc);break;default:throw Error(o(329))}}}return al(e,Je()),e.callbackNode===n?rl.bind(null,e):null}function ol(e,t){var n=Bc;return e.current.memoizedState.isDehydrated&&(hl(e,t).flags|=256),2!==(e=gl(e,t))&&(t=Wc,Wc=n,null!==t&&sl(t)),e}function sl(e){null===Wc?Wc=e:Wc.push.apply(Wc,e)}function il(e,t){for(t&=~zc,t&=~Pc,e.suspendedLanes|=t,e.pingedLanes&=~t,e=e.expirationTimes;0<t;){var n=31-st(t),a=1<<n;e[n]=-1,t&=~a}}function cl(e){if(0!==(6&Ec))throw Error(o(327));kl();var t=ht(e,0);if(0===(1&t))return al(e,Je()),null;var n=gl(e,t);if(0!==e.tag&&2===n){var a=ft(e);0!==a&&(t=a,n=ol(e,a))}if(1===n)throw n=Mc,hl(e,0),il(e,t),al(e,Je()),n;if(6===n)throw Error(o(345));return e.finishedWork=e.current.alternate,e.finishedLanes=t,wl(e,Wc,Gc),al(e,Je()),null}function ll(e,t){var n=Ec;Ec|=1;try{return e(t)}finally{0===(Ec=n)&&(Uc=Je()+500,Br&&Ur())}}function ul(e){null!==Xc&&0===Xc.tag&&0===(6&Ec)&&kl();var t=Ec;Ec|=1;var n=Tc.transition,a=xt;try{if(Tc.transition=null,xt=1,e)return e()}finally{xt=a,Tc.transition=n,0===(6&(Ec=t))&&Ur()}}function dl(){Fc=Oc.current,Nr(Oc)}function hl(e,t){e.finishedWork=null,e.finishedLanes=0;var n=e.timeoutHandle;if(-1!==n&&(e.timeoutHandle=-1,rr(n)),null!==_c)for(n=_c.return;null!==n;){var a=n;switch(to(a),a.tag){case 1:null!==(a=a.type.childContextTypes)&&void 0!==a&&Or();break;case 3:Jo(),Nr(Rr),Nr(Er),as();break;case 5:$o(a);break;case 4:Jo();break;case 13:case 19:Nr(es);break;case 10:Eo(a.type._context);break;case 22:case 23:dl()}n=n.return}if(Rc=e,_c=e=Ol(e.current,null),Ac=Fc=t,Dc=0,Mc=null,zc=Pc=Lc=0,Wc=Bc=null,null!==Fo){for(t=0;t<Fo.length;t++)if(null!==(a=(n=Fo[t]).interleaved)){n.interleaved=null;var r=a.next,o=n.pending;if(null!==o){var s=o.next;o.next=r,a.next=s}n.pending=a}Fo=null}return e}function pl(e,t){for(;;){var n=_c;try{if(To(),rs.current=Zs,us){for(var a=is.memoizedState;null!==a;){var r=a.queue;null!==r&&(r.pending=null),a=a.next}us=!1}if(ss=0,ls=cs=is=null,ds=!1,hs=0,Cc.current=null,null===n||null===n.return){Dc=1,Mc=t,_c=null;break}e:{var s=e,i=n.return,c=n,l=t;if(t=Ac,c.flags|=32768,null!==l&&"object"===typeof l&&"function"===typeof l.then){var u=l,d=c,h=d.tag;if(0===(1&d.mode)&&(0===h||11===h||15===h)){var p=d.alternate;p?(d.updateQueue=p.updateQueue,d.memoizedState=p.memoizedState,d.lanes=p.lanes):(d.updateQueue=null,d.memoizedState=null)}var f=gi(i);if(null!==f){f.flags&=-257,bi(f,i,c,0,t),1&f.mode&&mi(s,u,t),l=u;var m=(t=f).updateQueue;if(null===m){var g=new Set;g.add(l),t.updateQueue=g}else m.add(l);break e}if(0===(1&t)){mi(s,u,t),ml();break e}l=Error(o(426))}else if(ro&&1&c.mode){var b=gi(i);if(null!==b){0===(65536&b.flags)&&(b.flags|=256),bi(b,i,c,0,t),mo(li(l,c));break e}}s=l=li(l,c),4!==Dc&&(Dc=2),null===Bc?Bc=[s]:Bc.push(s),s=i;do{switch(s.tag){case 3:s.flags|=65536,t&=-t,s.lanes|=t,Uo(s,pi(0,l,t));break e;case 1:c=l;var y=s.type,x=s.stateNode;if(0===(128&s.flags)&&("function"===typeof y.getDerivedStateFromError||null!==x&&"function"===typeof x.componentDidCatch&&(null===Kc||!Kc.has(x)))){s.flags|=65536,t&=-t,s.lanes|=t,Uo(s,fi(s,c,t));break e}}s=s.return}while(null!==s)}vl(n)}catch(v){t=v,_c===n&&null!==n&&(_c=n=n.return);continue}break}}function fl(){var e=Nc.current;return Nc.current=Zs,null===e?Zs:e}function ml(){0!==Dc&&3!==Dc&&2!==Dc||(Dc=4),null===Rc||0===(268435455&Lc)&&0===(268435455&Pc)||il(Rc,Ac)}function gl(e,t){var n=Ec;Ec|=2;var a=fl();for(Rc===e&&Ac===t||(Gc=null,hl(e,t));;)try{bl();break}catch(r){pl(e,r)}if(To(),Ec=n,Nc.current=a,null!==_c)throw Error(o(261));return Rc=null,Ac=0,Dc}function bl(){for(;null!==_c;)xl(_c)}function yl(){for(;null!==_c&&!Ye();)xl(_c)}function xl(e){var t=Ic(e.alternate,e,Fc);e.memoizedProps=e.pendingProps,null===t?vl(e):_c=t,Cc.current=null}function vl(e){var t=e;do{var n=t.alternate;if(e=t.return,0===(32768&t.flags)){if(null!==(n=qi(n,t,Fc)))return void(_c=n)}else{if(null!==(n=Xi(n,t)))return n.flags&=32767,void(_c=n);if(null===e)return Dc=6,void(_c=null);e.flags|=32768,e.subtreeFlags=0,e.deletions=null}if(null!==(t=t.sibling))return void(_c=t);_c=t=e}while(null!==t);0===Dc&&(Dc=5)}function wl(e,t,n){var a=xt,r=Tc.transition;try{Tc.transition=null,xt=1,function(e,t,n,a){do{kl()}while(null!==Xc);if(0!==(6&Ec))throw Error(o(327));n=e.finishedWork;var r=e.finishedLanes;if(null===n)return null;if(e.finishedWork=null,e.finishedLanes=0,n===e.current)throw Error(o(177));e.callbackNode=null,e.callbackPriority=0;var s=n.lanes|n.childLanes;if(function(e,t){var n=e.pendingLanes&~t;e.pendingLanes=t,e.suspendedLanes=0,e.pingedLanes=0,e.expiredLanes&=t,e.mutableReadLanes&=t,e.entangledLanes&=t,t=e.entanglements;var a=e.eventTimes;for(e=e.expirationTimes;0<n;){var r=31-st(n),o=1<<r;t[r]=0,a[r]=-1,e[r]=-1,n&=~o}}(e,s),e===Rc&&(_c=Rc=null,Ac=0),0===(2064&n.subtreeFlags)&&0===(2064&n.flags)||qc||(qc=!0,Rl(tt,(function(){return kl(),null}))),s=0!==(15990&n.flags),0!==(15990&n.subtreeFlags)||s){s=Tc.transition,Tc.transition=null;var i=xt;xt=1;var c=Ec;Ec|=4,Cc.current=null,function(e,t){if(er=Ht,pa(e=ha())){if("selectionStart"in e)var n={start:e.selectionStart,end:e.selectionEnd};else e:{var a=(n=(n=e.ownerDocument)&&n.defaultView||window).getSelection&&n.getSelection();if(a&&0!==a.rangeCount){n=a.anchorNode;var r=a.anchorOffset,s=a.focusNode;a=a.focusOffset;try{n.nodeType,s.nodeType}catch(w){n=null;break e}var i=0,c=-1,l=-1,u=0,d=0,h=e,p=null;t:for(;;){for(var f;h!==n||0!==r&&3!==h.nodeType||(c=i+r),h!==s||0!==a&&3!==h.nodeType||(l=i+a),3===h.nodeType&&(i+=h.nodeValue.length),null!==(f=h.firstChild);)p=h,h=f;for(;;){if(h===e)break t;if(p===n&&++u===r&&(c=i),p===s&&++d===a&&(l=i),null!==(f=h.nextSibling))break;p=(h=p).parentNode}h=f}n=-1===c||-1===l?null:{start:c,end:l}}else n=null}n=n||{start:0,end:0}}else n=null;for(tr={focusedElem:e,selectionRange:n},Ht=!1,Zi=t;null!==Zi;)if(e=(t=Zi).child,0!==(1028&t.subtreeFlags)&&null!==e)e.return=t,Zi=e;else for(;null!==Zi;){t=Zi;try{var m=t.alternate;if(0!==(1024&t.flags))switch(t.tag){case 0:case 11:case 15:case 5:case 6:case 4:case 17:break;case 1:if(null!==m){var g=m.memoizedProps,b=m.memoizedState,y=t.stateNode,x=y.getSnapshotBeforeUpdate(t.elementType===t.type?g:ni(t.type,g),b);y.__reactInternalSnapshotBeforeUpdate=x}break;case 3:var v=t.stateNode.containerInfo;1===v.nodeType?v.textContent="":9===v.nodeType&&v.documentElement&&v.removeChild(v.documentElement);break;default:throw Error(o(163))}}catch(w){Sl(t,t.return,w)}if(null!==(e=t.sibling)){e.return=t.return,Zi=e;break}Zi=t.return}m=tc,tc=!1}(e,n),gc(n,e),fa(tr),Ht=!!er,tr=er=null,e.current=n,yc(n,e,r),Qe(),Ec=c,xt=i,Tc.transition=s}else e.current=n;if(qc&&(qc=!1,Xc=e,Yc=r),s=e.pendingLanes,0===s&&(Kc=null),function(e){if(ot&&"function"===typeof ot.onCommitFiberRoot)try{ot.onCommitFiberRoot(rt,e,void 0,128===(128&e.current.flags))}catch(t){}}(n.stateNode),al(e,Je()),null!==t)for(a=e.onRecoverableError,n=0;n<t.length;n++)r=t[n],a(r.value,{componentStack:r.stack,digest:r.digest});if(Hc)throw Hc=!1,e=jc,jc=null,e;0!==(1&Yc)&&0!==e.tag&&kl(),s=e.pendingLanes,0!==(1&s)?e===Jc?Qc++:(Qc=0,Jc=e):Qc=0,Ur()}(e,t,n,a)}finally{Tc.transition=r,xt=a}return null}function kl(){if(null!==Xc){var e=vt(Yc),t=Tc.transition,n=xt;try{if(Tc.transition=null,xt=16>e?16:e,null===Xc)var a=!1;else{if(e=Xc,Xc=null,Yc=0,0!==(6&Ec))throw Error(o(331));var r=Ec;for(Ec|=4,Zi=e.current;null!==Zi;){var s=Zi,i=s.child;if(0!==(16&Zi.flags)){var c=s.deletions;if(null!==c){for(var l=0;l<c.length;l++){var u=c[l];for(Zi=u;null!==Zi;){var d=Zi;switch(d.tag){case 0:case 11:case 15:nc(8,d,s)}var h=d.child;if(null!==h)h.return=d,Zi=h;else for(;null!==Zi;){var p=(d=Zi).sibling,f=d.return;if(oc(d),d===u){Zi=null;break}if(null!==p){p.return=f,Zi=p;break}Zi=f}}}var m=s.alternate;if(null!==m){var g=m.child;if(null!==g){m.child=null;do{var b=g.sibling;g.sibling=null,g=b}while(null!==g)}}Zi=s}}if(0!==(2064&s.subtreeFlags)&&null!==i)i.return=s,Zi=i;else e:for(;null!==Zi;){if(0!==(2048&(s=Zi).flags))switch(s.tag){case 0:case 11:case 15:nc(9,s,s.return)}var y=s.sibling;if(null!==y){y.return=s.return,Zi=y;break e}Zi=s.return}}var x=e.current;for(Zi=x;null!==Zi;){var v=(i=Zi).child;if(0!==(2064&i.subtreeFlags)&&null!==v)v.return=i,Zi=v;else e:for(i=x;null!==Zi;){if(0!==(2048&(c=Zi).flags))try{switch(c.tag){case 0:case 11:case 15:ac(9,c)}}catch(k){Sl(c,c.return,k)}if(c===i){Zi=null;break e}var w=c.sibling;if(null!==w){w.return=c.return,Zi=w;break e}Zi=c.return}}if(Ec=r,Ur(),ot&&"function"===typeof ot.onPostCommitFiberRoot)try{ot.onPostCommitFiberRoot(rt,e)}catch(k){}a=!0}return a}finally{xt=n,Tc.transition=t}}return!1}function Il(e,t,n){e=Wo(e,t=pi(0,t=li(n,t),1),1),t=el(),null!==e&&(bt(e,1,t),al(e,t))}function Sl(e,t,n){if(3===e.tag)Il(e,e,n);else for(;null!==t;){if(3===t.tag){Il(t,e,n);break}if(1===t.tag){var a=t.stateNode;if("function"===typeof t.type.getDerivedStateFromError||"function"===typeof a.componentDidCatch&&(null===Kc||!Kc.has(a))){t=Wo(t,e=fi(t,e=li(n,e),1),1),e=el(),null!==t&&(bt(t,1,e),al(t,e));break}}t=t.return}}function Nl(e,t,n){var a=e.pingCache;null!==a&&a.delete(t),t=el(),e.pingedLanes|=e.suspendedLanes&n,Rc===e&&(Ac&n)===n&&(4===Dc||3===Dc&&(130023424&Ac)===Ac&&500>Je()-Vc?hl(e,0):zc|=n),al(e,t)}function Cl(e,t){0===t&&(0===(1&e.mode)?t=1:(t=ut,0===(130023424&(ut<<=1))&&(ut=4194304)));var n=el();null!==(e=Mo(e,t))&&(bt(e,t,n),al(e,n))}function Tl(e){var t=e.memoizedState,n=0;null!==t&&(n=t.retryLane),Cl(e,n)}function El(e,t){var n=0;switch(e.tag){case 13:var a=e.stateNode,r=e.memoizedState;null!==r&&(n=r.retryLane);break;case 19:a=e.stateNode;break;default:throw Error(o(314))}null!==a&&a.delete(t),Cl(e,n)}function Rl(e,t){return qe(e,t)}function _l(e,t,n,a){this.tag=e,this.key=n,this.sibling=this.child=this.return=this.stateNode=this.type=this.elementType=null,this.index=0,this.ref=null,this.pendingProps=t,this.dependencies=this.memoizedState=this.updateQueue=this.memoizedProps=null,this.mode=a,this.subtreeFlags=this.flags=0,this.deletions=null,this.childLanes=this.lanes=0,this.alternate=null}function Al(e,t,n,a){return new _l(e,t,n,a)}function Fl(e){return!(!(e=e.prototype)||!e.isReactComponent)}function Ol(e,t){var n=e.alternate;return null===n?((n=Al(e.tag,t,e.key,e.mode)).elementType=e.elementType,n.type=e.type,n.stateNode=e.stateNode,n.alternate=e,e.alternate=n):(n.pendingProps=t,n.type=e.type,n.flags=0,n.subtreeFlags=0,n.deletions=null),n.flags=14680064&e.flags,n.childLanes=e.childLanes,n.lanes=e.lanes,n.child=e.child,n.memoizedProps=e.memoizedProps,n.memoizedState=e.memoizedState,n.updateQueue=e.updateQueue,t=e.dependencies,n.dependencies=null===t?null:{lanes:t.lanes,firstContext:t.firstContext},n.sibling=e.sibling,n.index=e.index,n.ref=e.ref,n}function Dl(e,t,n,a,r,s){var i=2;if(a=e,"function"===typeof e)Fl(e)&&(i=1);else if("string"===typeof e)i=5;else e:switch(e){case I:return Ml(n.children,r,s,t);case S:i=8,r|=8;break;case N:return(e=Al(12,n,t,2|r)).elementType=N,e.lanes=s,e;case R:return(e=Al(13,n,t,r)).elementType=R,e.lanes=s,e;case _:return(e=Al(19,n,t,r)).elementType=_,e.lanes=s,e;case O:return Ll(n,r,s,t);default:if("object"===typeof e&&null!==e)switch(e.$$typeof){case C:i=10;break e;case T:i=9;break e;case E:i=11;break e;case A:i=14;break e;case F:i=16,a=null;break e}throw Error(o(130,null==e?e:typeof e,""))}return(t=Al(i,n,t,r)).elementType=e,t.type=a,t.lanes=s,t}function Ml(e,t,n,a){return(e=Al(7,e,a,t)).lanes=n,e}function Ll(e,t,n,a){return(e=Al(22,e,a,t)).elementType=O,e.lanes=n,e.stateNode={isHidden:!1},e}function Pl(e,t,n){return(e=Al(6,e,null,t)).lanes=n,e}function zl(e,t,n){return(t=Al(4,null!==e.children?e.children:[],e.key,t)).lanes=n,t.stateNode={containerInfo:e.containerInfo,pendingChildren:null,implementation:e.implementation},t}function Bl(e,t,n,a,r){this.tag=t,this.containerInfo=e,this.finishedWork=this.pingCache=this.current=this.pendingChildren=null,this.timeoutHandle=-1,this.callbackNode=this.pendingContext=this.context=null,this.callbackPriority=0,this.eventTimes=gt(0),this.expirationTimes=gt(-1),this.entangledLanes=this.finishedLanes=this.mutableReadLanes=this.expiredLanes=this.pingedLanes=this.suspendedLanes=this.pendingLanes=0,this.entanglements=gt(0),this.identifierPrefix=a,this.onRecoverableError=r,this.mutableSourceEagerHydrationData=null}function Wl(e,t,n,a,r,o,s,i,c){return e=new Bl(e,t,n,i,c),1===t?(t=1,!0===o&&(t|=8)):t=0,o=Al(3,null,null,t),e.current=o,o.stateNode=e,o.memoizedState={element:a,isDehydrated:n,cache:null,transitions:null,pendingSuspenseBoundaries:null},Po(o),e}function Vl(e){if(!e)return Tr;e:{if(Ue(e=e._reactInternals)!==e||1!==e.tag)throw Error(o(170));var t=e;do{switch(t.tag){case 3:t=t.stateNode.context;break e;case 1:if(Fr(t.type)){t=t.stateNode.__reactInternalMemoizedMergedChildContext;break e}}t=t.return}while(null!==t);throw Error(o(171))}if(1===e.tag){var n=e.type;if(Fr(n))return Mr(e,n,t)}return t}function Ul(e,t,n,a,r,o,s,i,c){return(e=Wl(n,a,!0,e,0,o,0,i,c)).context=Vl(null),n=e.current,(o=Bo(a=el(),r=tl(n))).callback=void 0!==t&&null!==t?t:null,Wo(n,o,r),e.current.lanes=r,bt(e,r,a),al(e,a),e}function Gl(e,t,n,a){var r=t.current,o=el(),s=tl(r);return n=Vl(n),null===t.context?t.context=n:t.pendingContext=n,(t=Bo(o,s)).payload={element:e},null!==(a=void 0===a?null:a)&&(t.callback=a),null!==(e=Wo(r,t,s))&&(nl(e,r,s,o),Vo(e,r,s)),s}function Hl(e){return(e=e.current).child?(e.child.tag,e.child.stateNode):null}function jl(e,t){if(null!==(e=e.memoizedState)&&null!==e.dehydrated){var n=e.retryLane;e.retryLane=0!==n&&n<t?n:t}}function Kl(e,t){jl(e,t),(e=e.alternate)&&jl(e,t)}Ic=function(e,t,n){if(null!==e)if(e.memoizedProps!==t.pendingProps||Rr.current)xi=!0;else{if(0===(e.lanes&n)&&0===(128&t.flags))return xi=!1,function(e,t,n){switch(t.tag){case 3:Ri(t),fo();break;case 5:Zo(t);break;case 1:Fr(t.type)&&Lr(t);break;case 4:Qo(t,t.stateNode.containerInfo);break;case 10:var a=t.type._context,r=t.memoizedProps.value;Cr(Io,a._currentValue),a._currentValue=r;break;case 13:if(null!==(a=t.memoizedState))return null!==a.dehydrated?(Cr(es,1&es.current),t.flags|=128,null):0!==(n&t.child.childLanes)?Pi(e,t,n):(Cr(es,1&es.current),null!==(e=Hi(e,t,n))?e.sibling:null);Cr(es,1&es.current);break;case 19:if(a=0!==(n&t.childLanes),0!==(128&e.flags)){if(a)return Ui(e,t,n);t.flags|=128}if(null!==(r=t.memoizedState)&&(r.rendering=null,r.tail=null,r.lastEffect=null),Cr(es,es.current),a)break;return null;case 22:case 23:return t.lanes=0,Si(e,t,n)}return Hi(e,t,n)}(e,t,n);xi=0!==(131072&e.flags)}else xi=!1,ro&&0!==(1048576&t.flags)&&$r(t,Kr,t.index);switch(t.lanes=0,t.tag){case 2:var a=t.type;Gi(e,t),e=t.pendingProps;var r=Ar(t,Er.current);_o(t,n),r=gs(null,t,a,e,r,n);var s=bs();return t.flags|=1,"object"===typeof r&&null!==r&&"function"===typeof r.render&&void 0===r.$$typeof?(t.tag=1,t.memoizedState=null,t.updateQueue=null,Fr(a)?(s=!0,Lr(t)):s=!1,t.memoizedState=null!==r.state&&void 0!==r.state?r.state:null,Po(t),r.updater=ri,t.stateNode=r,r._reactInternals=t,ci(t,a,e,n),t=Ei(null,t,a,!0,s,n)):(t.tag=0,ro&&s&&eo(t),vi(null,t,r,n),t=t.child),t;case 16:a=t.elementType;e:{switch(Gi(e,t),e=t.pendingProps,a=(r=a._init)(a._payload),t.type=a,r=t.tag=function(e){if("function"===typeof e)return Fl(e)?1:0;if(void 0!==e&&null!==e){if((e=e.$$typeof)===E)return 11;if(e===A)return 14}return 2}(a),e=ni(a,e),r){case 0:t=Ci(null,t,a,e,n);break e;case 1:t=Ti(null,t,a,e,n);break e;case 11:t=wi(null,t,a,e,n);break e;case 14:t=ki(null,t,a,ni(a.type,e),n);break e}throw Error(o(306,a,""))}return t;case 0:return a=t.type,r=t.pendingProps,Ci(e,t,a,r=t.elementType===a?r:ni(a,r),n);case 1:return a=t.type,r=t.pendingProps,Ti(e,t,a,r=t.elementType===a?r:ni(a,r),n);case 3:e:{if(Ri(t),null===e)throw Error(o(387));a=t.pendingProps,r=(s=t.memoizedState).element,zo(e,t),Go(t,a,null,n);var i=t.memoizedState;if(a=i.element,s.isDehydrated){if(s={element:a,isDehydrated:!1,cache:i.cache,pendingSuspenseBoundaries:i.pendingSuspenseBoundaries,transitions:i.transitions},t.updateQueue.baseState=s,t.memoizedState=s,256&t.flags){t=_i(e,t,a,n,r=li(Error(o(423)),t));break e}if(a!==r){t=_i(e,t,a,n,r=li(Error(o(424)),t));break e}for(ao=lr(t.stateNode.containerInfo.firstChild),no=t,ro=!0,oo=null,n=ko(t,null,a,n),t.child=n;n;)n.flags=-3&n.flags|4096,n=n.sibling}else{if(fo(),a===r){t=Hi(e,t,n);break e}vi(e,t,a,n)}t=t.child}return t;case 5:return Zo(t),null===e&&lo(t),a=t.type,r=t.pendingProps,s=null!==e?e.memoizedProps:null,i=r.children,nr(a,r)?i=null:null!==s&&nr(a,s)&&(t.flags|=32),Ni(e,t),vi(e,t,i,n),t.child;case 6:return null===e&&lo(t),null;case 13:return Pi(e,t,n);case 4:return Qo(t,t.stateNode.containerInfo),a=t.pendingProps,null===e?t.child=wo(t,null,a,n):vi(e,t,a,n),t.child;case 11:return a=t.type,r=t.pendingProps,wi(e,t,a,r=t.elementType===a?r:ni(a,r),n);case 7:return vi(e,t,t.pendingProps,n),t.child;case 8:case 12:return vi(e,t,t.pendingProps.children,n),t.child;case 10:e:{if(a=t.type._context,r=t.pendingProps,s=t.memoizedProps,i=r.value,Cr(Io,a._currentValue),a._currentValue=i,null!==s)if(ia(s.value,i)){if(s.children===r.children&&!Rr.current){t=Hi(e,t,n);break e}}else for(null!==(s=t.child)&&(s.return=t);null!==s;){var c=s.dependencies;if(null!==c){i=s.child;for(var l=c.firstContext;null!==l;){if(l.context===a){if(1===s.tag){(l=Bo(-1,n&-n)).tag=2;var u=s.updateQueue;if(null!==u){var d=(u=u.shared).pending;null===d?l.next=l:(l.next=d.next,d.next=l),u.pending=l}}s.lanes|=n,null!==(l=s.alternate)&&(l.lanes|=n),Ro(s.return,n,t),c.lanes|=n;break}l=l.next}}else if(10===s.tag)i=s.type===t.type?null:s.child;else if(18===s.tag){if(null===(i=s.return))throw Error(o(341));i.lanes|=n,null!==(c=i.alternate)&&(c.lanes|=n),Ro(i,n,t),i=s.sibling}else i=s.child;if(null!==i)i.return=s;else for(i=s;null!==i;){if(i===t){i=null;break}if(null!==(s=i.sibling)){s.return=i.return,i=s;break}i=i.return}s=i}vi(e,t,r.children,n),t=t.child}return t;case 9:return r=t.type,a=t.pendingProps.children,_o(t,n),a=a(r=Ao(r)),t.flags|=1,vi(e,t,a,n),t.child;case 14:return r=ni(a=t.type,t.pendingProps),ki(e,t,a,r=ni(a.type,r),n);case 15:return Ii(e,t,t.type,t.pendingProps,n);case 17:return a=t.type,r=t.pendingProps,r=t.elementType===a?r:ni(a,r),Gi(e,t),t.tag=1,Fr(a)?(e=!0,Lr(t)):e=!1,_o(t,n),si(t,a,r),ci(t,a,r,n),Ei(null,t,a,!0,e,n);case 19:return Ui(e,t,n);case 22:return Si(e,t,n)}throw Error(o(156,t.tag))};var ql="function"===typeof reportError?reportError:function(e){console.error(e)};function Xl(e){this._internalRoot=e}function Yl(e){this._internalRoot=e}function Ql(e){return!(!e||1!==e.nodeType&&9!==e.nodeType&&11!==e.nodeType)}function Jl(e){return!(!e||1!==e.nodeType&&9!==e.nodeType&&11!==e.nodeType&&(8!==e.nodeType||" react-mount-point-unstable "!==e.nodeValue))}function Zl(){}function $l(e,t,n,a,r){var o=n._reactRootContainer;if(o){var s=o;if("function"===typeof r){var i=r;r=function(){var e=Hl(s);i.call(e)}}Gl(t,s,e,r)}else s=function(e,t,n,a,r){if(r){if("function"===typeof a){var o=a;a=function(){var e=Hl(s);o.call(e)}}var s=Ul(t,a,e,0,null,!1,0,"",Zl);return e._reactRootContainer=s,e[fr]=s.current,Ua(8===e.nodeType?e.parentNode:e),ul(),s}for(;r=e.lastChild;)e.removeChild(r);if("function"===typeof a){var i=a;a=function(){var e=Hl(c);i.call(e)}}var c=Wl(e,0,!1,null,0,!1,0,"",Zl);return e._reactRootContainer=c,e[fr]=c.current,Ua(8===e.nodeType?e.parentNode:e),ul((function(){Gl(t,c,n,a)})),c}(n,t,e,r,a);return Hl(s)}Yl.prototype.render=Xl.prototype.render=function(e){var t=this._internalRoot;if(null===t)throw Error(o(409));Gl(e,t,null,null)},Yl.prototype.unmount=Xl.prototype.unmount=function(){var e=this._internalRoot;if(null!==e){this._internalRoot=null;var t=e.containerInfo;ul((function(){Gl(null,e,null,null)})),t[fr]=null}},Yl.prototype.unstable_scheduleHydration=function(e){if(e){var t=St();e={blockedOn:null,target:e,priority:t};for(var n=0;n<Ot.length&&0!==t&&t<Ot[n].priority;n++);Ot.splice(n,0,e),0===n&&Pt(e)}},wt=function(e){switch(e.tag){case 3:var t=e.stateNode;if(t.current.memoizedState.isDehydrated){var n=dt(t.pendingLanes);0!==n&&(yt(t,1|n),al(t,Je()),0===(6&Ec)&&(Uc=Je()+500,Ur()))}break;case 13:ul((function(){var t=Mo(e,1);if(null!==t){var n=el();nl(t,e,1,n)}})),Kl(e,1)}},kt=function(e){if(13===e.tag){var t=Mo(e,134217728);if(null!==t)nl(t,e,134217728,el());Kl(e,134217728)}},It=function(e){if(13===e.tag){var t=tl(e),n=Mo(e,t);if(null!==n)nl(n,e,t,el());Kl(e,t)}},St=function(){return xt},Nt=function(e,t){var n=xt;try{return xt=e,t()}finally{xt=n}},ke=function(e,t,n){switch(t){case"input":if(Z(e,n),t=n.name,"radio"===n.type&&null!=t){for(n=e;n.parentNode;)n=n.parentNode;for(n=n.querySelectorAll("input[name="+JSON.stringify(""+t)+'][type="radio"]'),t=0;t<n.length;t++){var a=n[t];if(a!==e&&a.form===e.form){var r=wr(a);if(!r)throw Error(o(90));q(a),Z(a,r)}}}break;case"textarea":oe(e,n);break;case"select":null!=(t=n.value)&&ne(e,!!n.multiple,t,!1)}},Ee=ll,Re=ul;var eu={usingClientEntryPoint:!1,Events:[xr,vr,wr,Ce,Te,ll]},tu={findFiberByHostInstance:yr,bundleType:0,version:"18.3.1",rendererPackageName:"react-dom"},nu={bundleType:tu.bundleType,version:tu.version,rendererPackageName:tu.rendererPackageName,rendererConfig:tu.rendererConfig,overrideHookState:null,overrideHookStateDeletePath:null,overrideHookStateRenamePath:null,overrideProps:null,overridePropsDeletePath:null,overridePropsRenamePath:null,setErrorHandler:null,setSuspenseHandler:null,scheduleUpdate:null,currentDispatcherRef:v.ReactCurrentDispatcher,findHostInstanceByFiber:function(e){return null===(e=je(e))?null:e.stateNode},findFiberByHostInstance:tu.findFiberByHostInstance||function(){return null},findHostInstancesForRefresh:null,scheduleRefresh:null,scheduleRoot:null,setRefreshHandler:null,getCurrentFiber:null,reconcilerVersion:"18.3.1-next-f1338f8080-20240426"};if("undefined"!==typeof __REACT_DEVTOOLS_GLOBAL_HOOK__){var au=__REACT_DEVTOOLS_GLOBAL_HOOK__;if(!au.isDisabled&&au.supportsFiber)try{rt=au.inject(nu),ot=au}catch(ue){}}t.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=eu,t.createPortal=function(e,t){var n=2<arguments.length&&void 0!==arguments[2]?arguments[2]:null;if(!Ql(t))throw Error(o(200));return function(e,t,n){var a=3<arguments.length&&void 0!==arguments[3]?arguments[3]:null;return{$$typeof:k,key:null==a?null:""+a,children:e,containerInfo:t,implementation:n}}(e,t,null,n)},t.createRoot=function(e,t){if(!Ql(e))throw Error(o(299));var n=!1,a="",r=ql;return null!==t&&void 0!==t&&(!0===t.unstable_strictMode&&(n=!0),void 0!==t.identifierPrefix&&(a=t.identifierPrefix),void 0!==t.onRecoverableError&&(r=t.onRecoverableError)),t=Wl(e,1,!1,null,0,n,0,a,r),e[fr]=t.current,Ua(8===e.nodeType?e.parentNode:e),new Xl(t)},t.findDOMNode=function(e){if(null==e)return null;if(1===e.nodeType)return e;var t=e._reactInternals;if(void 0===t){if("function"===typeof e.render)throw Error(o(188));throw e=Object.keys(e).join(","),Error(o(268,e))}return e=null===(e=je(t))?null:e.stateNode},t.flushSync=function(e){return ul(e)},t.hydrate=function(e,t,n){if(!Jl(t))throw Error(o(200));return $l(null,e,t,!0,n)},t.hydrateRoot=function(e,t,n){if(!Ql(e))throw Error(o(405));var a=null!=n&&n.hydratedSources||null,r=!1,s="",i=ql;if(null!==n&&void 0!==n&&(!0===n.unstable_strictMode&&(r=!0),void 0!==n.identifierPrefix&&(s=n.identifierPrefix),void 0!==n.onRecoverableError&&(i=n.onRecoverableError)),t=Ul(t,null,e,1,null!=n?n:null,r,0,s,i),e[fr]=t.current,Ua(e),a)for(e=0;e<a.length;e++)r=(r=(n=a[e])._getVersion)(n._source),null==t.mutableSourceEagerHydrationData?t.mutableSourceEagerHydrationData=[n,r]:t.mutableSourceEagerHydrationData.push(n,r);return new Yl(t)},t.render=function(e,t,n){if(!Jl(t))throw Error(o(200));return $l(null,e,t,!1,n)},t.unmountComponentAtNode=function(e){if(!Jl(e))throw Error(o(40));return!!e._reactRootContainer&&(ul((function(){$l(null,null,e,!1,(function(){e._reactRootContainer=null,e[fr]=null}))})),!0)},t.unstable_batchedUpdates=ll,t.unstable_renderSubtreeIntoContainer=function(e,t,n,a){if(!Jl(n))throw Error(o(200));if(null==e||void 0===e._reactInternals)throw Error(o(38));return $l(e,t,n,!1,a)},t.version="18.3.1-next-f1338f8080-20240426"},391:(e,t,n)=>{"use strict";var a=n(950);t.createRoot=a.createRoot,t.hydrateRoot=a.hydrateRoot},950:(e,t,n)=>{"use strict";!function e(){if("undefined"!==typeof __REACT_DEVTOOLS_GLOBAL_HOOK__&&"function"===typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE)try{__REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(e)}catch(t){console.error(t)}}(),e.exports=n(730)},153:(e,t,n)=>{"use strict";var a=n(43),r=Symbol.for("react.element"),o=Symbol.for("react.fragment"),s=Object.prototype.hasOwnProperty,i=a.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner,c={key:!0,ref:!0,__self:!0,__source:!0};function l(e,t,n){var a,o={},l=null,u=null;for(a in void 0!==n&&(l=""+n),void 0!==t.key&&(l=""+t.key),void 0!==t.ref&&(u=t.ref),t)s.call(t,a)&&!c.hasOwnProperty(a)&&(o[a]=t[a]);if(e&&e.defaultProps)for(a in t=e.defaultProps)void 0===o[a]&&(o[a]=t[a]);return{$$typeof:r,type:e,key:l,ref:u,props:o,_owner:i.current}}t.Fragment=o,t.jsx=l,t.jsxs=l},202:(e,t)=>{"use strict";var n=Symbol.for("react.element"),a=Symbol.for("react.portal"),r=Symbol.for("react.fragment"),o=Symbol.for("react.strict_mode"),s=Symbol.for("react.profiler"),i=Symbol.for("react.provider"),c=Symbol.for("react.context"),l=Symbol.for("react.forward_ref"),u=Symbol.for("react.suspense"),d=Symbol.for("react.memo"),h=Symbol.for("react.lazy"),p=Symbol.iterator;var f={isMounted:function(){return!1},enqueueForceUpdate:function(){},enqueueReplaceState:function(){},enqueueSetState:function(){}},m=Object.assign,g={};function b(e,t,n){this.props=e,this.context=t,this.refs=g,this.updater=n||f}function y(){}function x(e,t,n){this.props=e,this.context=t,this.refs=g,this.updater=n||f}b.prototype.isReactComponent={},b.prototype.setState=function(e,t){if("object"!==typeof e&&"function"!==typeof e&&null!=e)throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");this.updater.enqueueSetState(this,e,t,"setState")},b.prototype.forceUpdate=function(e){this.updater.enqueueForceUpdate(this,e,"forceUpdate")},y.prototype=b.prototype;var v=x.prototype=new y;v.constructor=x,m(v,b.prototype),v.isPureReactComponent=!0;var w=Array.isArray,k=Object.prototype.hasOwnProperty,I={current:null},S={key:!0,ref:!0,__self:!0,__source:!0};function N(e,t,a){var r,o={},s=null,i=null;if(null!=t)for(r in void 0!==t.ref&&(i=t.ref),void 0!==t.key&&(s=""+t.key),t)k.call(t,r)&&!S.hasOwnProperty(r)&&(o[r]=t[r]);var c=arguments.length-2;if(1===c)o.children=a;else if(1<c){for(var l=Array(c),u=0;u<c;u++)l[u]=arguments[u+2];o.children=l}if(e&&e.defaultProps)for(r in c=e.defaultProps)void 0===o[r]&&(o[r]=c[r]);return{$$typeof:n,type:e,key:s,ref:i,props:o,_owner:I.current}}function C(e){return"object"===typeof e&&null!==e&&e.$$typeof===n}var T=/\/+/g;function E(e,t){return"object"===typeof e&&null!==e&&null!=e.key?function(e){var t={"=":"=0",":":"=2"};return"$"+e.replace(/[=:]/g,(function(e){return t[e]}))}(""+e.key):t.toString(36)}function R(e,t,r,o,s){var i=typeof e;"undefined"!==i&&"boolean"!==i||(e=null);var c=!1;if(null===e)c=!0;else switch(i){case"string":case"number":c=!0;break;case"object":switch(e.$$typeof){case n:case a:c=!0}}if(c)return s=s(c=e),e=""===o?"."+E(c,0):o,w(s)?(r="",null!=e&&(r=e.replace(T,"$&/")+"/"),R(s,t,r,"",(function(e){return e}))):null!=s&&(C(s)&&(s=function(e,t){return{$$typeof:n,type:e.type,key:t,ref:e.ref,props:e.props,_owner:e._owner}}(s,r+(!s.key||c&&c.key===s.key?"":(""+s.key).replace(T,"$&/")+"/")+e)),t.push(s)),1;if(c=0,o=""===o?".":o+":",w(e))for(var l=0;l<e.length;l++){var u=o+E(i=e[l],l);c+=R(i,t,r,u,s)}else if(u=function(e){return null===e||"object"!==typeof e?null:"function"===typeof(e=p&&e[p]||e["@@iterator"])?e:null}(e),"function"===typeof u)for(e=u.call(e),l=0;!(i=e.next()).done;)c+=R(i=i.value,t,r,u=o+E(i,l++),s);else if("object"===i)throw t=String(e),Error("Objects are not valid as a React child (found: "+("[object Object]"===t?"object with keys {"+Object.keys(e).join(", ")+"}":t)+"). If you meant to render a collection of children, use an array instead.");return c}function _(e,t,n){if(null==e)return e;var a=[],r=0;return R(e,a,"","",(function(e){return t.call(n,e,r++)})),a}function A(e){if(-1===e._status){var t=e._result;(t=t()).then((function(t){0!==e._status&&-1!==e._status||(e._status=1,e._result=t)}),(function(t){0!==e._status&&-1!==e._status||(e._status=2,e._result=t)})),-1===e._status&&(e._status=0,e._result=t)}if(1===e._status)return e._result.default;throw e._result}var F={current:null},O={transition:null},D={ReactCurrentDispatcher:F,ReactCurrentBatchConfig:O,ReactCurrentOwner:I};function M(){throw Error("act(...) is not supported in production builds of React.")}t.Children={map:_,forEach:function(e,t,n){_(e,(function(){t.apply(this,arguments)}),n)},count:function(e){var t=0;return _(e,(function(){t++})),t},toArray:function(e){return _(e,(function(e){return e}))||[]},only:function(e){if(!C(e))throw Error("React.Children.only expected to receive a single React element child.");return e}},t.Component=b,t.Fragment=r,t.Profiler=s,t.PureComponent=x,t.StrictMode=o,t.Suspense=u,t.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=D,t.act=M,t.cloneElement=function(e,t,a){if(null===e||void 0===e)throw Error("React.cloneElement(...): The argument must be a React element, but you passed "+e+".");var r=m({},e.props),o=e.key,s=e.ref,i=e._owner;if(null!=t){if(void 0!==t.ref&&(s=t.ref,i=I.current),void 0!==t.key&&(o=""+t.key),e.type&&e.type.defaultProps)var c=e.type.defaultProps;for(l in t)k.call(t,l)&&!S.hasOwnProperty(l)&&(r[l]=void 0===t[l]&&void 0!==c?c[l]:t[l])}var l=arguments.length-2;if(1===l)r.children=a;else if(1<l){c=Array(l);for(var u=0;u<l;u++)c[u]=arguments[u+2];r.children=c}return{$$typeof:n,type:e.type,key:o,ref:s,props:r,_owner:i}},t.createContext=function(e){return(e={$$typeof:c,_currentValue:e,_currentValue2:e,_threadCount:0,Provider:null,Consumer:null,_defaultValue:null,_globalName:null}).Provider={$$typeof:i,_context:e},e.Consumer=e},t.createElement=N,t.createFactory=function(e){var t=N.bind(null,e);return t.type=e,t},t.createRef=function(){return{current:null}},t.forwardRef=function(e){return{$$typeof:l,render:e}},t.isValidElement=C,t.lazy=function(e){return{$$typeof:h,_payload:{_status:-1,_result:e},_init:A}},t.memo=function(e,t){return{$$typeof:d,type:e,compare:void 0===t?null:t}},t.startTransition=function(e){var t=O.transition;O.transition={};try{e()}finally{O.transition=t}},t.unstable_act=M,t.useCallback=function(e,t){return F.current.useCallback(e,t)},t.useContext=function(e){return F.current.useContext(e)},t.useDebugValue=function(){},t.useDeferredValue=function(e){return F.current.useDeferredValue(e)},t.useEffect=function(e,t){return F.current.useEffect(e,t)},t.useId=function(){return F.current.useId()},t.useImperativeHandle=function(e,t,n){return F.current.useImperativeHandle(e,t,n)},t.useInsertionEffect=function(e,t){return F.current.useInsertionEffect(e,t)},t.useLayoutEffect=function(e,t){return F.current.useLayoutEffect(e,t)},t.useMemo=function(e,t){return F.current.useMemo(e,t)},t.useReducer=function(e,t,n){return F.current.useReducer(e,t,n)},t.useRef=function(e){return F.current.useRef(e)},t.useState=function(e){return F.current.useState(e)},t.useSyncExternalStore=function(e,t,n){return F.current.useSyncExternalStore(e,t,n)},t.useTransition=function(){return F.current.useTransition()},t.version="18.3.1"},43:(e,t,n)=>{"use strict";e.exports=n(202)},579:(e,t,n)=>{"use strict";e.exports=n(153)},234:(e,t)=>{"use strict";function n(e,t){var n=e.length;e.push(t);e:for(;0<n;){var a=n-1>>>1,r=e[a];if(!(0<o(r,t)))break e;e[a]=t,e[n]=r,n=a}}function a(e){return 0===e.length?null:e[0]}function r(e){if(0===e.length)return null;var t=e[0],n=e.pop();if(n!==t){e[0]=n;e:for(var a=0,r=e.length,s=r>>>1;a<s;){var i=2*(a+1)-1,c=e[i],l=i+1,u=e[l];if(0>o(c,n))l<r&&0>o(u,c)?(e[a]=u,e[l]=n,a=l):(e[a]=c,e[i]=n,a=i);else{if(!(l<r&&0>o(u,n)))break e;e[a]=u,e[l]=n,a=l}}}return t}function o(e,t){var n=e.sortIndex-t.sortIndex;return 0!==n?n:e.id-t.id}if("object"===typeof performance&&"function"===typeof performance.now){var s=performance;t.unstable_now=function(){return s.now()}}else{var i=Date,c=i.now();t.unstable_now=function(){return i.now()-c}}var l=[],u=[],d=1,h=null,p=3,f=!1,m=!1,g=!1,b="function"===typeof setTimeout?setTimeout:null,y="function"===typeof clearTimeout?clearTimeout:null,x="undefined"!==typeof setImmediate?setImmediate:null;function v(e){for(var t=a(u);null!==t;){if(null===t.callback)r(u);else{if(!(t.startTime<=e))break;r(u),t.sortIndex=t.expirationTime,n(l,t)}t=a(u)}}function w(e){if(g=!1,v(e),!m)if(null!==a(l))m=!0,O(k);else{var t=a(u);null!==t&&D(w,t.startTime-e)}}function k(e,n){m=!1,g&&(g=!1,y(C),C=-1),f=!0;var o=p;try{for(v(n),h=a(l);null!==h&&(!(h.expirationTime>n)||e&&!R());){var s=h.callback;if("function"===typeof s){h.callback=null,p=h.priorityLevel;var i=s(h.expirationTime<=n);n=t.unstable_now(),"function"===typeof i?h.callback=i:h===a(l)&&r(l),v(n)}else r(l);h=a(l)}if(null!==h)var c=!0;else{var d=a(u);null!==d&&D(w,d.startTime-n),c=!1}return c}finally{h=null,p=o,f=!1}}"undefined"!==typeof navigator&&void 0!==navigator.scheduling&&void 0!==navigator.scheduling.isInputPending&&navigator.scheduling.isInputPending.bind(navigator.scheduling);var I,S=!1,N=null,C=-1,T=5,E=-1;function R(){return!(t.unstable_now()-E<T)}function _(){if(null!==N){var e=t.unstable_now();E=e;var n=!0;try{n=N(!0,e)}finally{n?I():(S=!1,N=null)}}else S=!1}if("function"===typeof x)I=function(){x(_)};else if("undefined"!==typeof MessageChannel){var A=new MessageChannel,F=A.port2;A.port1.onmessage=_,I=function(){F.postMessage(null)}}else I=function(){b(_,0)};function O(e){N=e,S||(S=!0,I())}function D(e,n){C=b((function(){e(t.unstable_now())}),n)}t.unstable_IdlePriority=5,t.unstable_ImmediatePriority=1,t.unstable_LowPriority=4,t.unstable_NormalPriority=3,t.unstable_Profiling=null,t.unstable_UserBlockingPriority=2,t.unstable_cancelCallback=function(e){e.callback=null},t.unstable_continueExecution=function(){m||f||(m=!0,O(k))},t.unstable_forceFrameRate=function(e){0>e||125<e?console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported"):T=0<e?Math.floor(1e3/e):5},t.unstable_getCurrentPriorityLevel=function(){return p},t.unstable_getFirstCallbackNode=function(){return a(l)},t.unstable_next=function(e){switch(p){case 1:case 2:case 3:var t=3;break;default:t=p}var n=p;p=t;try{return e()}finally{p=n}},t.unstable_pauseExecution=function(){},t.unstable_requestPaint=function(){},t.unstable_runWithPriority=function(e,t){switch(e){case 1:case 2:case 3:case 4:case 5:break;default:e=3}var n=p;p=e;try{return t()}finally{p=n}},t.unstable_scheduleCallback=function(e,r,o){var s=t.unstable_now();switch("object"===typeof o&&null!==o?o="number"===typeof(o=o.delay)&&0<o?s+o:s:o=s,e){case 1:var i=-1;break;case 2:i=250;break;case 5:i=1073741823;break;case 4:i=1e4;break;default:i=5e3}return e={id:d++,callback:r,priorityLevel:e,startTime:o,expirationTime:i=o+i,sortIndex:-1},o>s?(e.sortIndex=o,n(u,e),null===a(l)&&e===a(u)&&(g?(y(C),C=-1):g=!0,D(w,o-s))):(e.sortIndex=i,n(l,e),m||f||(m=!0,O(k))),e},t.unstable_shouldYield=R,t.unstable_wrapCallback=function(e){var t=p;return function(){var n=p;p=t;try{return e.apply(this,arguments)}finally{p=n}}}},853:(e,t,n)=>{"use strict";e.exports=n(234)},334:(e,t,n)=>{var a=n(359),r=n(66),o=n(16),s=n(538),i=n(288),c=n(262),l=n(430);l.alea=a,l.xor128=r,l.xorwow=o,l.xorshift7=s,l.xor4096=i,l.tychei=c,e.exports=l},359:function(e,t,n){var a;!function(e,r,o){function s(e){var t=this,n=function(){var e=4022871197,t=function(t){t=String(t);for(var n=0;n<t.length;n++){var a=.02519603282416938*(e+=t.charCodeAt(n));a-=e=a>>>0,e=(a*=e)>>>0,e+=4294967296*(a-=e)}return 2.3283064365386963e-10*(e>>>0)};return t}();t.next=function(){var e=2091639*t.s0+2.3283064365386963e-10*t.c;return t.s0=t.s1,t.s1=t.s2,t.s2=e-(t.c=0|e)},t.c=1,t.s0=n(" "),t.s1=n(" "),t.s2=n(" "),t.s0-=n(e),t.s0<0&&(t.s0+=1),t.s1-=n(e),t.s1<0&&(t.s1+=1),t.s2-=n(e),t.s2<0&&(t.s2+=1),n=null}function i(e,t){return t.c=e.c,t.s0=e.s0,t.s1=e.s1,t.s2=e.s2,t}function c(e,t){var n=new s(e),a=t&&t.state,r=n.next;return r.int32=function(){return 4294967296*n.next()|0},r.double=function(){return r()+11102230246251565e-32*(2097152*r()|0)},r.quick=r,a&&("object"==typeof a&&i(a,n),r.state=function(){return i(n,{})}),r}r&&r.exports?r.exports=c:n.amdD&&n.amdO?void 0===(a=function(){return c}.call(t,n,t,r))||(r.exports=a):this.alea=c}(0,e=n.nmd(e),n.amdD)},262:function(e,t,n){var a;!function(e,r,o){function s(e){var t=this,n="";t.next=function(){var e=t.b,n=t.c,a=t.d,r=t.a;return e=e<<25^e>>>7^n,n=n-a|0,a=a<<24^a>>>8^r,r=r-e|0,t.b=e=e<<20^e>>>12^n,t.c=n=n-a|0,t.d=a<<16^n>>>16^r,t.a=r-e|0},t.a=0,t.b=0,t.c=-1640531527,t.d=1367130551,e===Math.floor(e)?(t.a=e/4294967296|0,t.b=0|e):n+=e;for(var a=0;a<n.length+20;a++)t.b^=0|n.charCodeAt(a),t.next()}function i(e,t){return t.a=e.a,t.b=e.b,t.c=e.c,t.d=e.d,t}function c(e,t){var n=new s(e),a=t&&t.state,r=function(){return(n.next()>>>0)/4294967296};return r.double=function(){do{var e=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},r.int32=n.next,r.quick=r,a&&("object"==typeof a&&i(a,n),r.state=function(){return i(n,{})}),r}r&&r.exports?r.exports=c:n.amdD&&n.amdO?void 0===(a=function(){return c}.call(t,n,t,r))||(r.exports=a):this.tychei=c}(0,e=n.nmd(e),n.amdD)},66:function(e,t,n){var a;!function(e,r,o){function s(e){var t=this,n="";t.x=0,t.y=0,t.z=0,t.w=0,t.next=function(){var e=t.x^t.x<<11;return t.x=t.y,t.y=t.z,t.z=t.w,t.w^=t.w>>>19^e^e>>>8},e===(0|e)?t.x=e:n+=e;for(var a=0;a<n.length+64;a++)t.x^=0|n.charCodeAt(a),t.next()}function i(e,t){return t.x=e.x,t.y=e.y,t.z=e.z,t.w=e.w,t}function c(e,t){var n=new s(e),a=t&&t.state,r=function(){return(n.next()>>>0)/4294967296};return r.double=function(){do{var e=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},r.int32=n.next,r.quick=r,a&&("object"==typeof a&&i(a,n),r.state=function(){return i(n,{})}),r}r&&r.exports?r.exports=c:n.amdD&&n.amdO?void 0===(a=function(){return c}.call(t,n,t,r))||(r.exports=a):this.xor128=c}(0,e=n.nmd(e),n.amdD)},288:function(e,t,n){var a;!function(e,r,o){function s(e){var t=this;t.next=function(){var e,n,a=t.w,r=t.X,o=t.i;return t.w=a=a+1640531527|0,n=r[o+34&127],e=r[o=o+1&127],n^=n<<13,e^=e<<17,n^=n>>>15,e^=e>>>12,n=r[o]=n^e,t.i=o,n+(a^a>>>16)|0},function(e,t){var n,a,r,o,s,i=[],c=128;for(t===(0|t)?(a=t,t=null):(t+="\0",a=0,c=Math.max(c,t.length)),r=0,o=-32;o<c;++o)t&&(a^=t.charCodeAt((o+32)%t.length)),0===o&&(s=a),a^=a<<10,a^=a>>>15,a^=a<<4,a^=a>>>13,o>=0&&(s=s+1640531527|0,r=0==(n=i[127&o]^=a+s)?r+1:0);for(r>=128&&(i[127&(t&&t.length||0)]=-1),r=127,o=512;o>0;--o)a=i[r+34&127],n=i[r=r+1&127],a^=a<<13,n^=n<<17,a^=a>>>15,n^=n>>>12,i[r]=a^n;e.w=s,e.X=i,e.i=r}(t,e)}function i(e,t){return t.i=e.i,t.w=e.w,t.X=e.X.slice(),t}function c(e,t){null==e&&(e=+new Date);var n=new s(e),a=t&&t.state,r=function(){return(n.next()>>>0)/4294967296};return r.double=function(){do{var e=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},r.int32=n.next,r.quick=r,a&&(a.X&&i(a,n),r.state=function(){return i(n,{})}),r}r&&r.exports?r.exports=c:n.amdD&&n.amdO?void 0===(a=function(){return c}.call(t,n,t,r))||(r.exports=a):this.xor4096=c}(0,e=n.nmd(e),n.amdD)},538:function(e,t,n){var a;!function(e,r,o){function s(e){var t=this;t.next=function(){var e,n,a=t.x,r=t.i;return e=a[r],n=(e^=e>>>7)^e<<24,n^=(e=a[r+1&7])^e>>>10,n^=(e=a[r+3&7])^e>>>3,n^=(e=a[r+4&7])^e<<7,e=a[r+7&7],n^=(e^=e<<13)^e<<9,a[r]=n,t.i=r+1&7,n},function(e,t){var n,a=[];if(t===(0|t))a[0]=t;else for(t=""+t,n=0;n<t.length;++n)a[7&n]=a[7&n]<<15^t.charCodeAt(n)+a[n+1&7]<<13;for(;a.length<8;)a.push(0);for(n=0;n<8&&0===a[n];++n);for(8==n?a[7]=-1:a[n],e.x=a,e.i=0,n=256;n>0;--n)e.next()}(t,e)}function i(e,t){return t.x=e.x.slice(),t.i=e.i,t}function c(e,t){null==e&&(e=+new Date);var n=new s(e),a=t&&t.state,r=function(){return(n.next()>>>0)/4294967296};return r.double=function(){do{var e=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},r.int32=n.next,r.quick=r,a&&(a.x&&i(a,n),r.state=function(){return i(n,{})}),r}r&&r.exports?r.exports=c:n.amdD&&n.amdO?void 0===(a=function(){return c}.call(t,n,t,r))||(r.exports=a):this.xorshift7=c}(0,e=n.nmd(e),n.amdD)},16:function(e,t,n){var a;!function(e,r,o){function s(e){var t=this,n="";t.next=function(){var e=t.x^t.x>>>2;return t.x=t.y,t.y=t.z,t.z=t.w,t.w=t.v,(t.d=t.d+362437|0)+(t.v=t.v^t.v<<4^e^e<<1)|0},t.x=0,t.y=0,t.z=0,t.w=0,t.v=0,e===(0|e)?t.x=e:n+=e;for(var a=0;a<n.length+64;a++)t.x^=0|n.charCodeAt(a),a==n.length&&(t.d=t.x<<10^t.x>>>4),t.next()}function i(e,t){return t.x=e.x,t.y=e.y,t.z=e.z,t.w=e.w,t.v=e.v,t.d=e.d,t}function c(e,t){var n=new s(e),a=t&&t.state,r=function(){return(n.next()>>>0)/4294967296};return r.double=function(){do{var e=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},r.int32=n.next,r.quick=r,a&&("object"==typeof a&&i(a,n),r.state=function(){return i(n,{})}),r}r&&r.exports?r.exports=c:n.amdD&&n.amdO?void 0===(a=function(){return c}.call(t,n,t,r))||(r.exports=a):this.xorwow=c}(0,e=n.nmd(e),n.amdD)},430:function(e,t,n){var a;!function(r,o,s){var i,c=256,l=s.pow(c,6),u=s.pow(2,52),d=2*u,h=c-1;function p(e,t,n){var a=[],h=b(g((t=1==t?{entropy:!0}:t||{}).entropy?[e,y(o)]:null==e?function(){try{var e;return i&&(e=i.randomBytes)?e=e(c):(e=new Uint8Array(c),(r.crypto||r.msCrypto).getRandomValues(e)),y(e)}catch(a){var t=r.navigator,n=t&&t.plugins;return[+new Date,r,n,r.screen,y(o)]}}():e,3),a),p=new f(a),x=function(){for(var e=p.g(6),t=l,n=0;e<u;)e=(e+n)*c,t*=c,n=p.g(1);for(;e>=d;)e/=2,t/=2,n>>>=1;return(e+n)/t};return x.int32=function(){return 0|p.g(4)},x.quick=function(){return p.g(4)/4294967296},x.double=x,b(y(p.S),o),(t.pass||n||function(e,t,n,a){return a&&(a.S&&m(a,p),e.state=function(){return m(p,{})}),n?(s.random=e,t):e})(x,h,"global"in t?t.global:this==s,t.state)}function f(e){var t,n=e.length,a=this,r=0,o=a.i=a.j=0,s=a.S=[];for(n||(e=[n++]);r<c;)s[r]=r++;for(r=0;r<c;r++)s[r]=s[o=h&o+e[r%n]+(t=s[r])],s[o]=t;(a.g=function(e){for(var t,n=0,r=a.i,o=a.j,s=a.S;e--;)t=s[r=h&r+1],n=n*c+s[h&(s[r]=s[o=h&o+t])+(s[o]=t)];return a.i=r,a.j=o,n})(c)}function m(e,t){return t.i=e.i,t.j=e.j,t.S=e.S.slice(),t}function g(e,t){var n,a=[],r=typeof e;if(t&&"object"==r)for(n in e)try{a.push(g(e[n],t-1))}catch(o){}return a.length?a:"string"==r?e:e+"\0"}function b(e,t){for(var n,a=e+"",r=0;r<a.length;)t[h&r]=h&(n^=19*t[h&r])+a.charCodeAt(r++);return y(t)}function y(e){return String.fromCharCode.apply(0,e)}if(b(s.random(),o),e.exports){e.exports=p;try{i=n(996)}catch(x){}}else void 0===(a=function(){return p}.call(t,n,t,e))||(e.exports=a)}("undefined"!==typeof self?self:this,[],Math)},895:(e,t,n)=>{"use strict";var a=n(43);var r="function"===typeof Object.is?Object.is:function(e,t){return e===t&&(0!==e||1/e===1/t)||e!==e&&t!==t},o=a.useSyncExternalStore,s=a.useRef,i=a.useEffect,c=a.useMemo,l=a.useDebugValue;t.useSyncExternalStoreWithSelector=function(e,t,n,a,u){var d=s(null);if(null===d.current){var h={hasValue:!1,value:null};d.current=h}else h=d.current;d=c((function(){function e(e){if(!i){if(i=!0,o=e,e=a(e),void 0!==u&&h.hasValue){var t=h.value;if(u(t,e))return s=t}return s=e}if(t=s,r(o,e))return t;var n=a(e);return void 0!==u&&u(t,n)?t:(o=e,s=n)}var o,s,i=!1,c=void 0===n?null:n;return[function(){return e(t())},null===c?void 0:function(){return e(c())}]}),[t,n,a,u]);var p=o(e,d[0],d[1]);return i((function(){h.hasValue=!0,h.value=p}),[p]),l(p),p}},237:(e,t,n)=>{"use strict";e.exports=n(895)},817:()=>{},590:()=>{},78:()=>{},905:()=>{},637:()=>{},279:()=>{},222:()=>{},996:()=>{}},t={};function n(a){var r=t[a];if(void 0!==r)return r.exports;var o=t[a]={id:a,loaded:!1,exports:{}};return e[a].call(o.exports,o,o.exports,n),o.loaded=!0,o.exports}n.m=e,n.amdD=function(){throw new Error("define cannot be used indirect")},n.amdO={},n.n=e=>{var t=e&&e.__esModule?()=>e.default:()=>e;return n.d(t,{a:t}),t},(()=>{var e,t=Object.getPrototypeOf?e=>Object.getPrototypeOf(e):e=>e.__proto__;n.t=function(a,r){if(1&r&&(a=this(a)),8&r)return a;if("object"===typeof a&&a){if(4&r&&a.__esModule)return a;if(16&r&&"function"===typeof a.then)return a}var o=Object.create(null);n.r(o);var s={};e=e||[null,t({}),t([]),t(t)];for(var i=2&r&&a;"object"==typeof i&&!~e.indexOf(i);i=t(i))Object.getOwnPropertyNames(i).forEach((e=>s[e]=()=>a[e]));return s.default=()=>a,n.d(o,s),o}})(),n.d=(e,t)=>{for(var a in t)n.o(t,a)&&!n.o(e,a)&&Object.defineProperty(e,a,{enumerable:!0,get:t[a]})},n.f={},n.e=e=>Promise.all(Object.keys(n.f).reduce(((t,a)=>(n.f[a](e,t),t)),[])),n.u=e=>"static/js/"+e+".ffa2c32b.chunk.js",n.miniCssF=e=>{},n.g=function(){if("object"===typeof globalThis)return globalThis;try{return this||new Function("return this")()}catch(e){if("object"===typeof window)return window}}(),n.o=(e,t)=>Object.prototype.hasOwnProperty.call(e,t),(()=>{var e={},t="face-recognition-app:";n.l=(a,r,o,s)=>{if(e[a])e[a].push(r);else{var i,c;if(void 0!==o)for(var l=document.getElementsByTagName("script"),u=0;u<l.length;u++){var d=l[u];if(d.getAttribute("src")==a||d.getAttribute("data-webpack")==t+o){i=d;break}}i||(c=!0,(i=document.createElement("script")).charset="utf-8",i.timeout=120,n.nc&&i.setAttribute("nonce",n.nc),i.setAttribute("data-webpack",t+o),i.src=a),e[a]=[r];var h=(t,n)=>{i.onerror=i.onload=null,clearTimeout(p);var r=e[a];if(delete e[a],i.parentNode&&i.parentNode.removeChild(i),r&&r.forEach((e=>e(n))),t)return t(n)},p=setTimeout(h.bind(null,void 0,{type:"timeout",target:i}),12e4);i.onerror=h.bind(null,i.onerror),i.onload=h.bind(null,i.onload),c&&document.head.appendChild(i)}}})(),n.r=e=>{"undefined"!==typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},n.nmd=e=>(e.paths=[],e.children||(e.children=[]),e),n.p="/face-recognition-app/",(()=>{var e={792:0};n.f.j=(t,a)=>{var r=n.o(e,t)?e[t]:void 0;if(0!==r)if(r)a.push(r[2]);else{var o=new Promise(((n,a)=>r=e[t]=[n,a]));a.push(r[2]=o);var s=n.p+n.u(t),i=new Error;n.l(s,(a=>{if(n.o(e,t)&&(0!==(r=e[t])&&(e[t]=void 0),r)){var o=a&&("load"===a.type?"missing":a.type),s=a&&a.target&&a.target.src;i.message="Loading chunk "+t+" failed.\n("+o+": "+s+")",i.name="ChunkLoadError",i.type=o,i.request=s,r[1](i)}}),"chunk-"+t,t)}};var t=(t,a)=>{var r,o,s=a[0],i=a[1],c=a[2],l=0;if(s.some((t=>0!==e[t]))){for(r in i)n.o(i,r)&&(n.m[r]=i[r]);if(c)c(n)}for(t&&t(a);l<s.length;l++)o=s[l],n.o(e,o)&&e[o]&&e[o][0](),e[o]=0},a=self.webpackChunkface_recognition_app=self.webpackChunkface_recognition_app||[];a.forEach(t.bind(null,0)),a.push=t.bind(null,a.push.bind(a))})(),(()=>{"use strict";var e={};n.r(e),n.d(e,{assertParamsValid:()=>mh,computeFlatOffset:()=>Eh,computeOutShape:()=>bh,getNormalizedAxes:()=>wh,isSliceContinous:()=>Th,maskToAxes:()=>gh,parseSliceParams:()=>Rh,sliceInfo:()=>_h,startForAxis:()=>Nh,startIndicesWithElidedDims:()=>kh,stopForAxis:()=>Ch,stopIndicesWithElidedDims:()=>Ih,stridesForAxis:()=>Sh,stridesWithElidedDims:()=>yh});var t={};n.r(t),n.d(t,{collectGatherOpShapeInfo:()=>Xg,computeOutShape:()=>qg,segOpComputeOptimalWindowSize:()=>Kg});var a={};n.r(a),n.d(a,{ERF_A1:()=>ug,ERF_A2:()=>dg,ERF_A3:()=>hg,ERF_A4:()=>pg,ERF_A5:()=>fg,ERF_P:()=>lg,PARALLELIZE_THRESHOLD:()=>Ym,RowPartitionType:()=>Hm,SELU_SCALE:()=>cg,SELU_SCALEALPHA:()=>ig,applyActivation:()=>qf,assertAndGetBroadcastShape:()=>Zd,assertAxesAreInnerMostDims:()=>Bp,assertParamsConsistent:()=>Um,assignToTypedArray:()=>vg,axesAreInnerMostDims:()=>Mp,calculateShapes:()=>sg,checkEinsumDimSizes:()=>Rg,checkPadOnDimRoundingMode:()=>Yh,combineLocations:()=>Lp,combineRaggedTensorToTensorShapes:()=>jm,complexWithEvenIndex:()=>bg,complexWithOddIndex:()=>yg,computeConv2DInfo:()=>zh,computeConv3DInfo:()=>Bh,computeDefaultPad:()=>Wh,computeDilation2DInfo:()=>Mh,computeOptimalWindowSize:()=>Qm,computeOutAndReduceShapes:()=>Pp,computeOutShape:()=>Gm,computePool2DInfo:()=>Lh,computePool3DInfo:()=>Ph,convertConv2DDataFormat:()=>Xh,decodeEinsumEquation:()=>Tg,eitherStridesOrDilationsAreOne:()=>Kh,expandShapeToKeepDim:()=>zp,exponent:()=>kg,exponents:()=>wg,fromStringArrayToUint8:()=>Qg,fromUint8ToStringArray:()=>Yg,getAxesPermutation:()=>Wp,getBroadcastDims:()=>Qd,getComplexWithIndex:()=>xg,getEinsumComputePath:()=>_g,getEinsumPermutation:()=>Eg,getFusedBiasGradient:()=>Kf,getFusedDyActivation:()=>jf,getImageCenter:()=>Jm,getInnerMostAxes:()=>Up,getPermuted:()=>$m,getRaggedRank:()=>qm,getReductionAxes:()=>Jd,getReshaped:()=>Zm,getReshapedPermuted:()=>eg,getRowPartitionTypesHelper:()=>Km,getSliceBeginCoords:()=>tg,getSliceSize:()=>ng,getSparseFillEmptyRowsIndicesDenseShapeMismatch:()=>Dg,getSparseFillEmptyRowsNegativeIndexErrorMessage:()=>Mg,getSparseFillEmptyRowsOutOfRangeIndexErrorMessage:()=>Lg,getSparseReshapeEmptyTensorZeroOutputDimErrorMessage:()=>Bg,getSparseReshapeInputOutputMismatchErrorMessage:()=>Vg,getSparseReshapeInputOutputMultipleErrorMessage:()=>Wg,getSparseReshapeMultipleNegativeOneOutputDimErrorMessage:()=>Pg,getSparseReshapeNegativeOutputDimErrorMessage:()=>zg,getSparseSegmentReductionIndicesOutOfRangeErrorMessage:()=>jg,getSparseSegmentReductionNegativeSegmentIdsErrorMessage:()=>Ug,getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage:()=>Gg,getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage:()=>Hg,getUndoAxesPermutation:()=>Vp,isIdentityPermutation:()=>Ag,log:()=>rl,mergeRealAndImagArrays:()=>mg,prepareAndValidate:()=>ag,prepareSplitSize:()=>Og,segment_util:()=>t,shouldFuse:()=>Xf,slice_util:()=>e,splitRealAndImagArrays:()=>gg,stridesOrDilationsArePositive:()=>qh,tupleValuesAreOne:()=>jh,upcastType:()=>su,validateDefaultValueShape:()=>Xm,validateInput:()=>og,validateUpdateShape:()=>rg,warn:()=>al});var r={};n.r(r),n.d(r,{addImpl:()=>VC,bincountImpl:()=>OT,bincountReduceImpl:()=>DT,bitwiseAndImpl:()=>LT,castImpl:()=>LC,ceilImpl:()=>BT,concatImpl:()=>jT,equalImpl:()=>RE,expImpl:()=>WE,expm1Impl:()=>jE,floorImpl:()=>cR,gatherNdImpl:()=>gR,gatherV2Impl:()=>yR,greaterEqualImpl:()=>IR,greaterImpl:()=>vR,lessEqualImpl:()=>LR,lessImpl:()=>OR,linSpaceImpl:()=>BR,logImpl:()=>VR,maxImpl:()=>n_,maximumImpl:()=>o_,minimumImpl:()=>m_,multiplyImpl:()=>wE,negImpl:()=>N_,notEqualImpl:()=>O_,prodImpl:()=>K_,raggedGatherImpl:()=>J_,raggedRangeImpl:()=>eA,raggedTensorToTensorImpl:()=>sA,rangeImpl:()=>cA,rsqrtImpl:()=>vA,scatterImpl:()=>IA,sigmoidImpl:()=>TC,simpleAbsImpl:()=>QC,sliceImpl:()=>RT,sparseFillEmptyRowsImpl:()=>GA,sparseReshapeImpl:()=>jA,sparseSegmentReductionImpl:()=>qA,sqrtImpl:()=>ZA,staticRegexReplaceImpl:()=>oF,stridedSliceImpl:()=>uF,stringNGramsImpl:()=>pF,stringSplitImpl:()=>gF,stringToHashBucketFastImpl:()=>yF,subImpl:()=>JE,tileImpl:()=>SF,topKImpl:()=>EF,transposeImpl:()=>aT,uniqueImpl:()=>MF});var o={};n.r(o),n.d(o,{CompositeArrayBuffer:()=>eX,browserFiles:()=>WY,browserHTTPRequest:()=>YY,concatenateArrayBuffers:()=>bX,copyModel:()=>nY,decodeWeights:()=>cX,decodeWeightsStream:()=>pX,encodeWeights:()=>iX,fromMemory:()=>$Y,fromMemorySync:()=>eQ,getLoadHandlers:()=>EX,getModelArtifactsForJSON:()=>wX,getModelArtifactsForJSONSync:()=>vX,getModelArtifactsInfoForJSON:()=>kX,getSaveHandlers:()=>TX,getWeightSpecs:()=>IX,http:()=>XY,isHTTPScheme:()=>KY,listModels:()=>eY,loadWeights:()=>GY,moveModel:()=>aY,registerLoadRouter:()=>CX,registerSaveRouter:()=>NX,removeModel:()=>tY,weightsLoaderFactory:()=>HY,withSaveHandler:()=>tQ,withSaveHandlerSync:()=>nQ});var s={};n.r(s),n.d(s,{assertParamsValid:()=>lQ,computeFlatOffset:()=>kQ,computeOutShape:()=>dQ,getNormalizedAxes:()=>mQ,isSliceContinous:()=>wQ,maskToAxes:()=>uQ,parseSliceParams:()=>IQ,sliceInfo:()=>SQ,startForAxis:()=>xQ,startIndicesWithElidedDims:()=>gQ,stopForAxis:()=>vQ,stopIndicesWithElidedDims:()=>bQ,stridesForAxis:()=>yQ,stridesWithElidedDims:()=>hQ});var i={};n.r(i),n.d(i,{conv2d:()=>L0,depthwiseConv2d:()=>B0,matMul:()=>W0});var c={};n.r(c),n.d(c,{collectGatherOpShapeInfo:()=>Y2,computeOutShape:()=>X2,segOpComputeOptimalWindowSize:()=>q2});var l={};n.r(l),n.d(l,{ERF_A1:()=>d2,ERF_A2:()=>h2,ERF_A3:()=>p2,ERF_A4:()=>f2,ERF_A5:()=>m2,ERF_P:()=>u2,PARALLELIZE_THRESHOLD:()=>$1,RowPartitionType:()=>X1,SELU_SCALE:()=>l2,SELU_SCALEALPHA:()=>c2,applyActivation:()=>D0,assertAndGetBroadcastShape:()=>OY,assertAxesAreInnerMostDims:()=>JJ,assertParamsConsistent:()=>K1,assignToTypedArray:()=>w2,axesAreInnerMostDims:()=>qJ,calculateShapes:()=>u0,checkEinsumDimSizes:()=>_2,checkPadOnDimRoundingMode:()=>ZQ,combineLocations:()=>XJ,combineRaggedTensorToTensorShapes:()=>Y1,complexWithEvenIndex:()=>y2,complexWithOddIndex:()=>x2,computeConv2DInfo:()=>VQ,computeConv3DInfo:()=>UQ,computeDefaultPad:()=>GQ,computeDilation2DInfo:()=>zQ,computeOptimalWindowSize:()=>e2,computeOutAndReduceShapes:()=>YJ,computeOutShape:()=>q1,computePool2DInfo:()=>BQ,computePool3DInfo:()=>WQ,convertConv2DDataFormat:()=>JQ,decodeEinsumEquation:()=>E2,eitherStridesOrDilationsAreOne:()=>YQ,expandShapeToKeepDim:()=>QJ,exponent:()=>I2,exponents:()=>k2,fromStringArrayToUint8:()=>J2,fromUint8ToStringArray:()=>Q2,getAxesPermutation:()=>ZJ,getBroadcastDims:()=>AY,getComplexWithIndex:()=>v2,getEinsumComputePath:()=>A2,getEinsumPermutation:()=>R2,getFusedBiasGradient:()=>O0,getFusedDyActivation:()=>F0,getImageCenter:()=>t2,getInnerMostAxes:()=>eZ,getPermuted:()=>a2,getRaggedRank:()=>J1,getReductionAxes:()=>FY,getReshaped:()=>n2,getReshapedPermuted:()=>r2,getRowPartitionTypesHelper:()=>Q1,getSliceBeginCoords:()=>o2,getSliceSize:()=>s2,getSparseFillEmptyRowsIndicesDenseShapeMismatch:()=>M2,getSparseFillEmptyRowsNegativeIndexErrorMessage:()=>L2,getSparseFillEmptyRowsOutOfRangeIndexErrorMessage:()=>P2,getSparseReshapeEmptyTensorZeroOutputDimErrorMessage:()=>W2,getSparseReshapeInputOutputMismatchErrorMessage:()=>U2,getSparseReshapeInputOutputMultipleErrorMessage:()=>V2,getSparseReshapeMultipleNegativeOneOutputDimErrorMessage:()=>z2,getSparseReshapeNegativeOutputDimErrorMessage:()=>B2,getSparseSegmentReductionIndicesOutOfRangeErrorMessage:()=>K2,getSparseSegmentReductionNegativeSegmentIdsErrorMessage:()=>G2,getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage:()=>H2,getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage:()=>j2,getUndoAxesPermutation:()=>$J,isIdentityPermutation:()=>F2,log:()=>TK,mergeRealAndImagArrays:()=>g2,prepareAndValidate:()=>i2,prepareSplitSize:()=>D2,segment_util:()=>c,shouldFuse:()=>M0,slice_util:()=>s,splitRealAndImagArrays:()=>b2,stridesOrDilationsArePositive:()=>QQ,tupleValuesAreOne:()=>XQ,upcastType:()=>Cq,validateDefaultValueShape:()=>Z1,validateInput:()=>l0,validateUpdateShape:()=>c0,warn:()=>CK});var u={};n.r(u),n.d(u,{addImpl:()=>F3,bincountImpl:()=>S4,bincountReduceImpl:()=>N4,bitwiseAndImpl:()=>T4,castImpl:()=>T3,ceilImpl:()=>A4,concatImpl:()=>P4,equalImpl:()=>w5,expImpl:()=>F5,expm1Impl:()=>P5,floorImpl:()=>e6,gatherNdImpl:()=>c6,gatherV2Impl:()=>u6,greaterEqualImpl:()=>m6,greaterImpl:()=>h6,lessEqualImpl:()=>E6,lessImpl:()=>N6,linSpaceImpl:()=>A6,logImpl:()=>O6,maxImpl:()=>X6,maximumImpl:()=>J6,minimumImpl:()=>i8,multiplyImpl:()=>p5,negImpl:()=>b8,notEqualImpl:()=>N8,prodImpl:()=>z8,raggedGatherImpl:()=>G8,raggedRangeImpl:()=>K8,raggedTensorToTensorImpl:()=>Z8,rangeImpl:()=>e7,rsqrtImpl:()=>h7,scatterImpl:()=>m7,sigmoidImpl:()=>y3,simpleAbsImpl:()=>V3,sliceImpl:()=>v4,sparseFillEmptyRowsImpl:()=>M7,sparseReshapeImpl:()=>P7,sparseSegmentReductionImpl:()=>B7,sqrtImpl:()=>H7,staticRegexReplaceImpl:()=>J7,stridedSliceImpl:()=>n9,stringNGramsImpl:()=>o9,stringSplitImpl:()=>c9,stringToHashBucketFastImpl:()=>u9,subImpl:()=>G5,tileImpl:()=>g9,topKImpl:()=>v9,transposeImpl:()=>X3,uniqueImpl:()=>T9});var d={};n.r(d),n.d(d,{json:()=>Rle});var h={};n.r(h),n.d(h,{json:()=>_le});var p={};n.r(p),n.d(p,{json:()=>Ale});var f={};n.r(f),n.d(f,{json:()=>Fle});var m={};n.r(m),n.d(m,{json:()=>Ole});var g={};n.r(g),n.d(g,{json:()=>Dle});var b={};n.r(b),n.d(b,{json:()=>Mle});var y={};n.r(y),n.d(y,{json:()=>Lle});var x={};n.r(x),n.d(x,{json:()=>Ple});var v={};n.r(v),n.d(v,{json:()=>zle});var w={};n.r(w),n.d(w,{json:()=>Ble});var k={};n.r(k),n.d(k,{json:()=>Wle});var I={};n.r(I),n.d(I,{json:()=>Vle});var S={};n.r(S),n.d(S,{json:()=>Ule});var N={};n.r(N),n.d(N,{json:()=>Gle});var C={};n.r(C),n.d(C,{json:()=>Hle});var T={};n.r(T),n.d(T,{json:()=>jle});var E={};n.r(E),n.d(E,{json:()=>Kle});var R={};n.r(R),n.d(R,{json:()=>qle});var _={};n.r(_),n.d(_,{OP_SCOPE_SUFFIX:()=>Xq,abs:()=>_Y,acos:()=>CQ,acosh:()=>TQ,add:()=>hY,addN:()=>EQ,all:()=>RQ,any:()=>_Q,argMax:()=>AQ,argMin:()=>FQ,asin:()=>OQ,asinh:()=>DQ,atan:()=>MQ,atan2:()=>LQ,atanh:()=>PQ,avgPool:()=>eJ,avgPool3d:()=>tJ,basicLSTMCell:()=>iJ,batchNorm:()=>lJ,batchNorm2d:()=>uJ,batchNorm3d:()=>dJ,batchNorm4d:()=>hJ,batchToSpaceND:()=>cJ,bincount:()=>pJ,bitwiseAnd:()=>fJ,booleanMaskAsync:()=>w0,broadcastArgs:()=>mJ,broadcastTo:()=>gJ,buffer:()=>cY,cast:()=>lY,ceil:()=>bJ,clipByValue:()=>yJ,clone:()=>uY,complex:()=>Qq,concat:()=>nJ,concat1d:()=>xJ,concat2d:()=>vJ,concat3d:()=>wJ,concat4d:()=>kJ,conv1d:()=>SJ,conv2d:()=>IJ,conv2dTranspose:()=>CJ,conv3d:()=>TJ,conv3dTranspose:()=>RJ,cos:()=>_J,cosh:()=>AJ,cosineWindow:()=>R0,cumprod:()=>FJ,cumsum:()=>OJ,denseBincount:()=>DJ,depthToSpace:()=>MJ,depthwiseConv2d:()=>LJ,diag:()=>PJ,dilation2d:()=>zJ,div:()=>fY,divNoNan:()=>VJ,dot:()=>UJ,dropout:()=>T0,einsum:()=>GJ,elu:()=>HJ,enclosingPowerOfTwo:()=>E0,ensureShape:()=>jJ,equal:()=>BJ,erf:()=>KJ,euclideanNorm:()=>sZ,exp:()=>iZ,expandDims:()=>cZ,expm1:()=>lZ,eye:()=>dZ,fft:()=>K$,fill:()=>TY,floor:()=>hZ,floorDiv:()=>pY,fused:()=>i,gather:()=>pZ,gatherND:()=>C0,greater:()=>fZ,greaterEqual:()=>mZ,ifft:()=>q$,imag:()=>gZ,image:()=>W1,inTopKAsync:()=>_0,irfft:()=>X$,isFinite:()=>bZ,isInf:()=>yZ,isNaN:()=>xZ,leakyRelu:()=>vZ,less:()=>wZ,lessEqual:()=>kZ,linalg:()=>V1,linspace:()=>IZ,localResponseNormalization:()=>SZ,log:()=>NZ,log1p:()=>CZ,logSigmoid:()=>RZ,logSoftmax:()=>_Z,logSumExp:()=>AZ,logicalAnd:()=>FZ,logicalNot:()=>OZ,logicalOr:()=>DZ,logicalXor:()=>MZ,losses:()=>U1,lowerBound:()=>zZ,matMul:()=>aJ,max:()=>tZ,maxPool:()=>BZ,maxPool3d:()=>WZ,maxPoolWithArgmax:()=>VZ,maximum:()=>DY,mean:()=>UZ,meshgrid:()=>jZ,min:()=>nZ,minimum:()=>KZ,mirrorPad:()=>qZ,mod:()=>XZ,moments:()=>YZ,movingAverage:()=>I0,mul:()=>mY,multiRNNCell:()=>QZ,multinomial:()=>JZ,neg:()=>TZ,norm:()=>oZ,notEqual:()=>ZZ,oneHot:()=>$Z,ones:()=>HZ,onesLike:()=>e$,op:()=>Yq,outerProduct:()=>t$,pad:()=>n$,pad1d:()=>a$,pad2d:()=>r$,pad3d:()=>o$,pad4d:()=>s$,pool:()=>c$,pow:()=>EY,prelu:()=>l$,print:()=>dY,prod:()=>u$,raggedGather:()=>d$,raggedRange:()=>h$,raggedTensorToTensor:()=>p$,rand:()=>f$,randomGamma:()=>y$,randomNormal:()=>x$,randomStandardNormal:()=>v$,randomUniform:()=>w$,randomUniformInt:()=>k$,range:()=>I$,real:()=>S$,reciprocal:()=>N$,relu:()=>C$,relu6:()=>T$,reshape:()=>$Q,reverse:()=>E$,reverse1d:()=>R$,reverse2d:()=>_$,reverse3d:()=>A$,reverse4d:()=>F$,rfft:()=>Q$,round:()=>O$,rsqrt:()=>D$,scalar:()=>vY,scatterND:()=>S0,searchSorted:()=>PZ,selu:()=>M$,separableConv2d:()=>L$,setdiff1dAsync:()=>P$,sigmoid:()=>rJ,sign:()=>z$,signal:()=>B1,sin:()=>B$,sinh:()=>W$,slice:()=>oJ,slice1d:()=>V$,slice2d:()=>U$,slice3d:()=>G$,slice4d:()=>H$,softmax:()=>j$,softplus:()=>EZ,spaceToBatchND:()=>i$,sparse:()=>G1,sparseToDense:()=>N0,spectral:()=>z1,split:()=>Y$,sqrt:()=>gY,square:()=>bY,squaredDifference:()=>J$,squeeze:()=>Z$,stack:()=>$$,step:()=>e0,stridedSlice:()=>t0,string:()=>H1,sub:()=>RY,sum:()=>aZ,tan:()=>n0,tanh:()=>sJ,tensor:()=>Zq,tensor1d:()=>a0,tensor2d:()=>r0,tensor3d:()=>aQ,tensor4d:()=>o0,tensor5d:()=>s0,tensor6d:()=>i0,tensorScatterUpdate:()=>d0,tile:()=>uZ,topk:()=>h0,transpose:()=>k0,truncatedNormal:()=>p0,unique:()=>f0,unsortedSegmentSum:()=>m0,unstack:()=>g0,upperBound:()=>b0,variable:()=>y0,where:()=>WJ,whereAsync:()=>v0,zeros:()=>GZ,zerosLike:()=>yY});var A=n(43),F=n(391);function O(e,t){return t||(t=e.slice(0)),Object.freeze(Object.defineProperties(e,{raw:{value:Object.freeze(t)}}))}let D={data:""},M=e=>{if("object"==typeof window){let t=(e?e.querySelector("#_goober"):window._goober)||Object.assign(document.createElement("style"),{innerHTML:" ",id:"_goober"});return t.nonce=window.__nonce__,t.parentNode||(e||document.head).appendChild(t),t.firstChild}return e||D},L=/(?:([\u0080-\uFFFF\w-%@]+) *:? *([^{;]+?);|([^;}{]*?) *{)|(}\s*)/g,P=/\/\*[^]*?\*\/|  +/g,z=/\n+/g,B=(e,t)=>{let n="",a="",r="";for(let o in e){let s=e[o];"@"==o[0]?"i"==o[1]?n=o+" "+s+";":a+="f"==o[1]?B(s,o):o+"{"+B(s,"k"==o[1]?"":t)+"}":"object"==typeof s?a+=B(s,t?t.replace(/([^,])+/g,(e=>o.replace(/([^,]*:\S+\([^)]*\))|([^,])+/g,(t=>/&/.test(t)?t.replace(/&/g,e):e?e+" "+t:t)))):o):null!=s&&(o=/^--/.test(o)?o:o.replace(/[A-Z]/g,"-$&").toLowerCase(),r+=B.p?B.p(o,s):o+":"+s+";")}return n+(t&&r?t+"{"+r+"}":r)+a},W={},V=e=>{if("object"==typeof e){let t="";for(let n in e)t+=n+V(e[n]);return t}return e},U=(e,t,n,a,r)=>{let o=V(e),s=W[o]||(W[o]=(e=>{let t=0,n=11;for(;t<e.length;)n=101*n+e.charCodeAt(t++)>>>0;return"go"+n})(o));if(!W[s]){let t=o!==e?e:(e=>{let t,n,a=[{}];for(;t=L.exec(e.replace(P,""));)t[4]?a.shift():t[3]?(n=t[3].replace(z," ").trim(),a.unshift(a[0][n]=a[0][n]||{})):a[0][t[1]]=t[2].replace(z," ").trim();return a[0]})(e);W[s]=B(r?{["@keyframes "+s]:t}:t,n?"":"."+s)}let i=n&&W.g?W.g:null;return n&&(W.g=W[s]),((e,t,n,a)=>{a?t.data=t.data.replace(a,e):-1===t.data.indexOf(e)&&(t.data=n?e+t.data:t.data+e)})(W[s],t,a,i),s},G=(e,t,n)=>e.reduce(((e,a,r)=>{let o=t[r];if(o&&o.call){let e=o(n),t=e&&e.props&&e.props.className||/^go/.test(e)&&e;o=t?"."+t:e&&"object"==typeof e?e.props?"":B(e,""):!1===e?"":e}return e+a+(null==o?"":o)}),"");function H(e){let t=this||{},n=e.call?e(t.p):e;return U(n.unshift?n.raw?G(n,[].slice.call(arguments,1),t.p):n.reduce(((e,n)=>Object.assign(e,n&&n.call?n(t.p):n)),{}):n,M(t.target),t.g,t.o,t.k)}H.bind({g:1});let j,K,q,X=H.bind({k:1});function Y(e,t){let n=this||{};return function(){let a=arguments;function r(o,s){let i=Object.assign({},o),c=i.className||r.className;n.p=Object.assign({theme:K&&K()},i),n.o=/ *go\d+/.test(c),i.className=H.apply(n,a)+(c?" "+c:""),t&&(i.ref=s);let l=e;return e[0]&&(l=i.as||e,delete i.as),q&&l[0]&&q(i),j(l,i)}return t?t(r):r}}var Q,J,Z,$,ee,te,ne,ae,re,oe,se,ie,ce,le,ue,de,he=(e,t)=>(e=>"function"==typeof e)(e)?e(t):e,pe=(()=>{let e=0;return()=>(++e).toString()})(),fe=(()=>{let e;return()=>{if(void 0===e&&typeof window<"u"){let t=matchMedia("(prefers-reduced-motion: reduce)");e=!t||t.matches}return e}})(),me="default",ge=(e,t)=>{let{toastLimit:n}=e.settings;switch(t.type){case 0:return{...e,toasts:[t.toast,...e.toasts].slice(0,n)};case 1:return{...e,toasts:e.toasts.map((e=>e.id===t.toast.id?{...e,...t.toast}:e))};case 2:let{toast:a}=t;return ge(e,{type:e.toasts.find((e=>e.id===a.id))?1:0,toast:a});case 3:let{toastId:r}=t;return{...e,toasts:e.toasts.map((e=>e.id===r||void 0===r?{...e,dismissed:!0,visible:!1}:e))};case 4:return void 0===t.toastId?{...e,toasts:[]}:{...e,toasts:e.toasts.filter((e=>e.id!==t.toastId))};case 5:return{...e,pausedAt:t.time};case 6:let o=t.time-(e.pausedAt||0);return{...e,pausedAt:void 0,toasts:e.toasts.map((e=>({...e,pauseDuration:e.pauseDuration+o})))}}},be=[],ye={toasts:[],pausedAt:void 0,settings:{toastLimit:20}},xe={},ve=function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:me;xe[t]=ge(xe[t]||ye,e),be.forEach((e=>{let[n,a]=e;n===t&&a(xe[t])}))},we=e=>Object.keys(xe).forEach((t=>ve(e,t))),ke=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:me;return t=>{ve(t,e)}},Ie={blank:4e3,error:4e3,success:2e3,loading:1/0,custom:4e3},Se=e=>(t,n)=>{let a=function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"blank",n=arguments.length>2?arguments[2]:void 0;return{createdAt:Date.now(),visible:!0,dismissed:!1,type:t,ariaProps:{role:"status","aria-live":"polite"},message:e,pauseDuration:0,...n,id:(null==n?void 0:n.id)||pe()}}(t,e,n);return ke(a.toasterId||(e=>Object.keys(xe).find((t=>xe[t].toasts.some((t=>t.id===e)))))(a.id))({type:2,toast:a}),a.id},Ne=(e,t)=>Se("blank")(e,t);Ne.error=Se("error"),Ne.success=Se("success"),Ne.loading=Se("loading"),Ne.custom=Se("custom"),Ne.dismiss=(e,t)=>{let n={type:3,toastId:e};t?ke(t)(n):we(n)},Ne.dismissAll=e=>Ne.dismiss(void 0,e),Ne.remove=(e,t)=>{let n={type:4,toastId:e};t?ke(t)(n):we(n)},Ne.removeAll=e=>Ne.remove(void 0,e),Ne.promise=(e,t,n)=>{let a=Ne.loading(t.loading,{...n,...null==n?void 0:n.loading});return"function"==typeof e&&(e=e()),e.then((e=>{let r=t.success?he(t.success,e):void 0;return r?Ne.success(r,{id:a,...n,...null==n?void 0:n.success}):Ne.dismiss(a),e})).catch((e=>{let r=t.error?he(t.error,e):void 0;r?Ne.error(r,{id:a,...n,...null==n?void 0:n.error}):Ne.dismiss(a)})),e};var Ce=function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"default",{toasts:n,pausedAt:a}=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:me,[n,a]=(0,A.useState)(xe[t]||ye),r=(0,A.useRef)(xe[t]);(0,A.useEffect)((()=>(r.current!==xe[t]&&a(xe[t]),be.push([t,a]),()=>{let e=be.findIndex((e=>{let[n]=e;return n===t}));e>-1&&be.splice(e,1)})),[t]);let o=n.toasts.map((t=>{var n,a,r;return{...e,...e[t.type],...t,removeDelay:t.removeDelay||(null==(n=e[t.type])?void 0:n.removeDelay)||(null==e?void 0:e.removeDelay),duration:t.duration||(null==(a=e[t.type])?void 0:a.duration)||(null==e?void 0:e.duration)||Ie[t.type],style:{...e.style,...null==(r=e[t.type])?void 0:r.style,...t.style}}}));return{...n,toasts:o}}(e,t),r=(0,A.useRef)(new Map).current,o=(0,A.useCallback)((function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1e3;if(r.has(e))return;let n=setTimeout((()=>{r.delete(e),s({type:4,toastId:e})}),t);r.set(e,n)}),[]);(0,A.useEffect)((()=>{if(a)return;let e=Date.now(),r=n.map((n=>{if(n.duration===1/0)return;let a=(n.duration||0)+n.pauseDuration-(e-n.createdAt);if(!(a<0))return setTimeout((()=>Ne.dismiss(n.id,t)),a);n.visible&&Ne.dismiss(n.id)}));return()=>{r.forEach((e=>e&&clearTimeout(e)))}}),[n,a,t]);let s=(0,A.useCallback)(ke(t),[t]),i=(0,A.useCallback)((()=>{s({type:5,time:Date.now()})}),[s]),c=(0,A.useCallback)(((e,t)=>{s({type:1,toast:{id:e,height:t}})}),[s]),l=(0,A.useCallback)((()=>{a&&s({type:6,time:Date.now()})}),[a,s]),u=(0,A.useCallback)(((e,t)=>{let{reverseOrder:a=!1,gutter:r=8,defaultPosition:o}=t||{},s=n.filter((t=>(t.position||o)===(e.position||o)&&t.height)),i=s.findIndex((t=>t.id===e.id)),c=s.filter(((e,t)=>t<i&&e.visible)).length;return s.filter((e=>e.visible)).slice(...a?[c+1]:[0,c]).reduce(((e,t)=>e+(t.height||0)+r),0)}),[n]);return(0,A.useEffect)((()=>{n.forEach((e=>{if(e.dismissed)o(e.id,e.removeDelay);else{let t=r.get(e.id);t&&(clearTimeout(t),r.delete(e.id))}}))}),[n,o]),{toasts:n,handlers:{updateHeight:c,startPause:i,endPause:l,calculateOffset:u}}},Te=X(Q||(Q=O(["\nfrom {\n  transform: scale(0) rotate(45deg);\n\topacity: 0;\n}\nto {\n transform: scale(1) rotate(45deg);\n  opacity: 1;\n}"]))),Ee=X(J||(J=O(["\nfrom {\n  transform: scale(0);\n  opacity: 0;\n}\nto {\n  transform: scale(1);\n  opacity: 1;\n}"]))),Re=X(Z||(Z=O(["\nfrom {\n  transform: scale(0) rotate(90deg);\n\topacity: 0;\n}\nto {\n  transform: scale(1) rotate(90deg);\n\topacity: 1;\n}"]))),_e=Y("div")($||($=O(["\n  width: 20px;\n  opacity: 0;\n  height: 20px;\n  border-radius: 10px;\n  background: ",";\n  position: relative;\n  transform: rotate(45deg);\n\n  animation: "," 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275)\n    forwards;\n  animation-delay: 100ms;\n\n  &:after,\n  &:before {\n    content: '';\n    animation: "," 0.15s ease-out forwards;\n    animation-delay: 150ms;\n    position: absolute;\n    border-radius: 3px;\n    opacity: 0;\n    background: ",";\n    bottom: 9px;\n    left: 4px;\n    height: 2px;\n    width: 12px;\n  }\n\n  &:before {\n    animation: "," 0.15s ease-out forwards;\n    animation-delay: 180ms;\n    transform: rotate(90deg);\n  }\n"])),(e=>e.primary||"#ff4b4b"),Te,Ee,(e=>e.secondary||"#fff"),Re),Ae=X(ee||(ee=O(["\n  from {\n    transform: rotate(0deg);\n  }\n  to {\n    transform: rotate(360deg);\n  }\n"]))),Fe=Y("div")(te||(te=O(["\n  width: 12px;\n  height: 12px;\n  box-sizing: border-box;\n  border: 2px solid;\n  border-radius: 100%;\n  border-color: ",";\n  border-right-color: ",";\n  animation: "," 1s linear infinite;\n"])),(e=>e.secondary||"#e0e0e0"),(e=>e.primary||"#616161"),Ae),Oe=X(ne||(ne=O(["\nfrom {\n  transform: scale(0) rotate(45deg);\n\topacity: 0;\n}\nto {\n  transform: scale(1) rotate(45deg);\n\topacity: 1;\n}"]))),De=X(ae||(ae=O(["\n0% {\n\theight: 0;\n\twidth: 0;\n\topacity: 0;\n}\n40% {\n  height: 0;\n\twidth: 6px;\n\topacity: 1;\n}\n100% {\n  opacity: 1;\n  height: 10px;\n}"]))),Me=Y("div")(re||(re=O(["\n  width: 20px;\n  opacity: 0;\n  height: 20px;\n  border-radius: 10px;\n  background: ",";\n  position: relative;\n  transform: rotate(45deg);\n\n  animation: "," 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275)\n    forwards;\n  animation-delay: 100ms;\n  &:after {\n    content: '';\n    box-sizing: border-box;\n    animation: "," 0.2s ease-out forwards;\n    opacity: 0;\n    animation-delay: 200ms;\n    position: absolute;\n    border-right: 2px solid;\n    border-bottom: 2px solid;\n    border-color: ",";\n    bottom: 6px;\n    left: 6px;\n    height: 10px;\n    width: 6px;\n  }\n"])),(e=>e.primary||"#61d345"),Oe,De,(e=>e.secondary||"#fff")),Le=Y("div")(oe||(oe=O(["\n  position: absolute;\n"]))),Pe=Y("div")(se||(se=O(["\n  position: relative;\n  display: flex;\n  justify-content: center;\n  align-items: center;\n  min-width: 20px;\n  min-height: 20px;\n"]))),ze=X(ie||(ie=O(["\nfrom {\n  transform: scale(0.6);\n  opacity: 0.4;\n}\nto {\n  transform: scale(1);\n  opacity: 1;\n}"]))),Be=Y("div")(ce||(ce=O(["\n  position: relative;\n  transform: scale(0.6);\n  opacity: 0.4;\n  min-width: 20px;\n  animation: "," 0.3s 0.12s cubic-bezier(0.175, 0.885, 0.32, 1.275)\n    forwards;\n"])),ze),We=e=>{let{toast:t}=e,{icon:n,type:a,iconTheme:r}=t;return void 0!==n?"string"==typeof n?A.createElement(Be,null,n):n:"blank"===a?null:A.createElement(Pe,null,A.createElement(Fe,{...r}),"loading"!==a&&A.createElement(Le,null,"error"===a?A.createElement(_e,{...r}):A.createElement(Me,{...r})))},Ve=e=>"\n0% {transform: translate3d(0,".concat(-200*e,"%,0) scale(.6); opacity:.5;}\n100% {transform: translate3d(0,0,0) scale(1); opacity:1;}\n"),Ue=e=>"\n0% {transform: translate3d(0,0,-1px) scale(1); opacity:1;}\n100% {transform: translate3d(0,".concat(-150*e,"%,-1px) scale(.6); opacity:0;}\n"),Ge=Y("div")(le||(le=O(["\n  display: flex;\n  align-items: center;\n  background: #fff;\n  color: #363636;\n  line-height: 1.3;\n  will-change: transform;\n  box-shadow: 0 3px 10px rgba(0, 0, 0, 0.1), 0 3px 3px rgba(0, 0, 0, 0.05);\n  max-width: 350px;\n  pointer-events: auto;\n  padding: 8px 10px;\n  border-radius: 8px;\n"]))),He=Y("div")(ue||(ue=O(["\n  display: flex;\n  justify-content: center;\n  margin: 4px 10px;\n  color: inherit;\n  flex: 1 1 auto;\n  white-space: pre-line;\n"]))),je=A.memo((e=>{let{toast:t,position:n,style:a,children:r}=e,o=t.height?((e,t)=>{let n=e.includes("top")?1:-1,[a,r]=fe()?["0%{opacity:0;} 100%{opacity:1;}","0%{opacity:1;} 100%{opacity:0;}"]:[Ve(n),Ue(n)];return{animation:t?"".concat(X(a)," 0.35s cubic-bezier(.21,1.02,.73,1) forwards"):"".concat(X(r)," 0.4s forwards cubic-bezier(.06,.71,.55,1)")}})(t.position||n||"top-center",t.visible):{opacity:0},s=A.createElement(We,{toast:t}),i=A.createElement(He,{...t.ariaProps},he(t.message,t));return A.createElement(Ge,{className:t.className,style:{...o,...a,...t.style}},"function"==typeof r?r({icon:s,message:i}):A.createElement(A.Fragment,null,s,i))}));!function(e,t,n,a){B.p=t,j=e,K=n,q=a}(A.createElement);var Ke=e=>{let{id:t,className:n,style:a,onHeightUpdate:r,children:o}=e,s=A.useCallback((e=>{if(e){let n=()=>{let n=e.getBoundingClientRect().height;r(t,n)};n(),new MutationObserver(n).observe(e,{subtree:!0,childList:!0,characterData:!0})}}),[t,r]);return A.createElement("div",{ref:s,className:n,style:a},o)},qe=H(de||(de=O(["\n  z-index: 9999;\n  > * {\n    pointer-events: auto;\n  }\n"]))),Xe=e=>{let{reverseOrder:t,position:n="top-center",toastOptions:a,gutter:r,children:o,toasterId:s,containerStyle:i,containerClassName:c}=e,{toasts:l,handlers:u}=Ce(a,s);return A.createElement("div",{"data-rht-toaster":s||"",style:{position:"fixed",zIndex:9999,top:16,left:16,right:16,bottom:16,pointerEvents:"none",...i},className:c,onMouseEnter:u.startPause,onMouseLeave:u.endPause},l.map((e=>{let a=e.position||n,s=((e,t)=>{let n=e.includes("top"),a=n?{top:0}:{bottom:0},r=e.includes("center")?{justifyContent:"center"}:e.includes("right")?{justifyContent:"flex-end"}:{};return{left:0,right:0,display:"flex",position:"absolute",transition:fe()?void 0:"all 230ms cubic-bezier(.21,1.02,.73,1)",transform:"translateY(".concat(t*(n?1:-1),"px)"),...a,...r}})(a,u.calculateOffset(e,{reverseOrder:t,gutter:r,defaultPosition:n}));return A.createElement(Ke,{id:e.id,key:e.id,onHeightUpdate:u.updateHeight,className:e.visible?qe:"",style:s},"custom"===e.type?he(e.message,e):o?o(e):A.createElement(je,{toast:e,position:a}))})))};const Ye=/^[a-z0-9]+(-[a-z0-9]+)*$/,Qe=function(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"";const r=e.split(":");if("@"===e.slice(0,1)){if(r.length<2||r.length>3)return null;a=r.shift().slice(1)}if(r.length>3||!r.length)return null;if(r.length>1){const e=r.pop(),n=r.pop(),o={provider:r.length>0?r[0]:a,prefix:n,name:e};return t&&!Je(o)?null:o}const o=r[0],s=o.split("-");if(s.length>1){const e={provider:a,prefix:s.shift(),name:s.join("-")};return t&&!Je(e)?null:e}if(n&&""===a){const e={provider:a,prefix:"",name:o};return t&&!Je(e,n)?null:e}return null},Je=(e,t)=>!!e&&!(""!==e.provider&&!e.provider.match(Ye)||!(t&&""===e.prefix||e.prefix.match(Ye))||!e.name.match(Ye)),Ze=Object.freeze({left:0,top:0,width:16,height:16}),$e=Object.freeze({rotate:0,vFlip:!1,hFlip:!1}),et=Object.freeze({...Ze,...$e}),tt=Object.freeze({...et,body:"",hidden:!1});function nt(e,t){const n=function(e,t){const n={};!e.hFlip!==!t.hFlip&&(n.hFlip=!0),!e.vFlip!==!t.vFlip&&(n.vFlip=!0);const a=((e.rotate||0)+(t.rotate||0))%4;return a&&(n.rotate=a),n}(e,t);for(const a in tt)a in $e?a in e&&!(a in n)&&(n[a]=$e[a]):a in t?n[a]=t[a]:a in e&&(n[a]=e[a]);return n}function at(e,t,n){const a=e.icons,r=e.aliases||Object.create(null);let o={};function s(e){o=nt(a[e]||r[e],o)}return s(t),n.forEach(s),nt(e,o)}function rt(e,t){const n=[];if("object"!==typeof e||"object"!==typeof e.icons)return n;e.not_found instanceof Array&&e.not_found.forEach((e=>{t(e,null),n.push(e)}));const a=function(e,t){const n=e.icons,a=e.aliases||Object.create(null),r=Object.create(null);return(t||Object.keys(n).concat(Object.keys(a))).forEach((function e(t){if(n[t])return r[t]=[];if(!(t in r)){r[t]=null;const n=a[t]&&a[t].parent,o=n&&e(n);o&&(r[t]=[n].concat(o))}return r[t]})),r}(e);for(const r in a){const o=a[r];o&&(t(r,at(e,r,o)),n.push(r))}return n}const ot={provider:"",aliases:{},not_found:{},...Ze};function st(e,t){for(const n in t)if(n in e&&typeof e[n]!==typeof t[n])return!1;return!0}function it(e){if("object"!==typeof e||null===e)return null;const t=e;if("string"!==typeof t.prefix||!e.icons||"object"!==typeof e.icons)return null;if(!st(e,ot))return null;const n=t.icons;for(const r in n){const e=n[r];if(!r.match(Ye)||"string"!==typeof e.body||!st(e,tt))return null}const a=t.aliases||Object.create(null);for(const r in a){const e=a[r],t=e.parent;if(!r.match(Ye)||"string"!==typeof t||!n[t]&&!a[t]||!st(e,tt))return null}return t}const ct=Object.create(null);function lt(e,t){const n=ct[e]||(ct[e]=Object.create(null));return n[t]||(n[t]=function(e,t){return{provider:e,prefix:t,icons:Object.create(null),missing:new Set}}(e,t))}function ut(e,t){return it(t)?rt(t,((t,n)=>{n?e.icons[t]=n:e.missing.add(t)})):[]}let dt=!1;function ht(e){return"boolean"===typeof e&&(dt=e),dt}function pt(e){const t="string"===typeof e?Qe(e,!0,dt):e;if(t){const e=lt(t.provider,t.prefix),n=t.name;return e.icons[n]||(e.missing.has(n)?null:void 0)}}function ft(e,t){if("object"!==typeof e)return!1;if("string"!==typeof t&&(t=e.provider||""),dt&&!t&&!e.prefix){let t=!1;return it(e)&&(e.prefix="",rt(e,((e,n)=>{n&&function(e,t){const n=Qe(e,!0,dt);return!!n&&function(e,t,n){try{if("string"===typeof n.body)return e.icons[t]={...n},!0}catch(a){}return!1}(lt(n.provider,n.prefix),n.name,t)}(e,n)&&(t=!0)}))),t}const n=e.prefix;if(!Je({provider:t,prefix:n,name:"a"}))return!1;return!!ut(lt(t,n),e)}const mt=Object.freeze({width:null,height:null}),gt=Object.freeze({...mt,...$e}),bt=/(-?[0-9.]*[0-9]+[0-9.]*)/g,yt=/^-?[0-9.]*[0-9]+[0-9.]*$/g;function xt(e,t,n){if(1===t)return e;if(n=n||100,"number"===typeof e)return Math.ceil(e*t*n)/n;if("string"!==typeof e)return e;const a=e.split(bt);if(null===a||!a.length)return e;const r=[];let o=a.shift(),s=yt.test(o);for(;;){if(s){const e=parseFloat(o);isNaN(e)?r.push(o):r.push(Math.ceil(e*t*n)/n)}else r.push(o);if(o=a.shift(),void 0===o)return r.join("");s=!s}}const vt=/\sid="(\S+)"/g,wt="IconifyId"+Date.now().toString(16)+(16777216*Math.random()|0).toString(16);let kt=0;function It(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:wt;const n=[];let a;for(;a=vt.exec(e);)n.push(a[1]);if(!n.length)return e;const r="suffix"+(16777216*Math.random()|Date.now()).toString(16);return n.forEach((n=>{const a="function"===typeof t?t(n):t+(kt++).toString(),o=n.replace(/[.*+?^${}()|[\]\\]/g,"\\$&");e=e.replace(new RegExp('([#;"])('+o+')([")]|\\.[a-z])',"g"),"$1"+a+r+"$3")})),e=e.replace(new RegExp(r,"g"),"")}const St=Object.create(null);function Nt(e,t){St[e]=t}function Ct(e){return St[e]||St[""]}function Tt(e){let t;if("string"===typeof e.resources)t=[e.resources];else if(t=e.resources,!(t instanceof Array)||!t.length)return null;return{resources:t,path:e.path||"/",maxURL:e.maxURL||500,rotate:e.rotate||750,timeout:e.timeout||5e3,random:!0===e.random,index:e.index||0,dataAfterTimeout:!1!==e.dataAfterTimeout}}const Et=Object.create(null),Rt=["https://api.simplesvg.com","https://api.unisvg.com"],_t=[];for(;Rt.length>0;)1===Rt.length||Math.random()>.5?_t.push(Rt.shift()):_t.push(Rt.pop());function At(e,t){const n=Tt(t);return null!==n&&(Et[e]=n,!0)}function Ft(e){return Et[e]}Et[""]=Tt({resources:["https://api.iconify.design"].concat(_t)});let Ot=(()=>{let e;try{if(e=fetch,"function"===typeof e)return e}catch(t){}})();const Dt={prepare:(e,t,n)=>{const a=[],r=function(e,t){const n=Ft(e);if(!n)return 0;let a;if(n.maxURL){let e=0;n.resources.forEach((t=>{const n=t;e=Math.max(e,n.length)}));const r=t+".json?icons=";a=n.maxURL-e-n.path.length-r.length}else a=0;return a}(e,t),o="icons";let s={type:o,provider:e,prefix:t,icons:[]},i=0;return n.forEach(((n,c)=>{i+=n.length+1,i>=r&&c>0&&(a.push(s),s={type:o,provider:e,prefix:t,icons:[]},i=n.length),s.icons.push(n)})),a.push(s),a},send:(e,t,n)=>{if(!Ot)return void n("abort",424);let a=function(e){if("string"===typeof e){const t=Ft(e);if(t)return t.path}return"/"}(t.provider);switch(t.type){case"icons":{const e=t.prefix,n=t.icons.join(",");a+=e+".json?"+new URLSearchParams({icons:n}).toString();break}case"custom":{const e=t.uri;a+="/"===e.slice(0,1)?e.slice(1):e;break}default:return void n("abort",400)}let r=503;Ot(e+a).then((e=>{const t=e.status;if(200===t)return r=501,e.json();setTimeout((()=>{n(function(e){return 404===e}(t)?"abort":"next",t)}))})).then((e=>{"object"===typeof e&&null!==e?setTimeout((()=>{n("success",e)})):setTimeout((()=>{404===e?n("abort",e):n("next",r)}))})).catch((()=>{n("next",r)}))}};function Mt(e,t){e.forEach((e=>{const n=e.loaderCallbacks;n&&(e.loaderCallbacks=n.filter((e=>e.id!==t)))}))}let Lt=0;var Pt={resources:[],index:0,timeout:2e3,rotate:750,random:!1,dataAfterTimeout:!1};function zt(e,t,n,a){const r=e.resources.length,o=e.random?Math.floor(Math.random()*r):e.index;let s;if(e.random){let t=e.resources.slice(0);for(s=[];t.length>1;){const e=Math.floor(Math.random()*t.length);s.push(t[e]),t=t.slice(0,e).concat(t.slice(e+1))}s=s.concat(t)}else s=e.resources.slice(o).concat(e.resources.slice(0,o));const i=Date.now();let c,l="pending",u=0,d=null,h=[],p=[];function f(){d&&(clearTimeout(d),d=null)}function m(){"pending"===l&&(l="aborted"),f(),h.forEach((e=>{"pending"===e.status&&(e.status="aborted")})),h=[]}function g(e,t){t&&(p=[]),"function"===typeof e&&p.push(e)}function b(){l="failed",p.forEach((e=>{e(void 0,c)}))}function y(){h.forEach((e=>{"pending"===e.status&&(e.status="aborted")})),h=[]}function x(){if("pending"!==l)return;f();const a=s.shift();if(void 0===a)return h.length?void(d=setTimeout((()=>{f(),"pending"===l&&(y(),b())}),e.timeout)):void b();const r={status:"pending",resource:a,callback:(t,n)=>{!function(t,n,a){const r="success"!==n;switch(h=h.filter((e=>e!==t)),l){case"pending":break;case"failed":if(r||!e.dataAfterTimeout)return;break;default:return}if("abort"===n)return c=a,void b();if(r)return c=a,void(h.length||(s.length?x():b()));if(f(),y(),!e.random){const n=e.resources.indexOf(t.resource);-1!==n&&n!==e.index&&(e.index=n)}l="completed",p.forEach((e=>{e(a)}))}(r,t,n)}};h.push(r),u++,d=setTimeout(x,e.rotate),n(a,t,r.callback)}return"function"===typeof a&&p.push(a),setTimeout(x),function(){return{startTime:i,payload:t,status:l,queriesSent:u,queriesPending:h.length,subscribe:g,abort:m}}}function Bt(e){const t={...Pt,...e};let n=[];function a(){n=n.filter((e=>"pending"===e().status))}return{query:function(e,r,o){const s=zt(t,e,r,((e,t)=>{a(),o&&o(e,t)}));return n.push(s),s},find:function(e){return n.find((t=>e(t)))||null},setIndex:e=>{t.index=e},getIndex:()=>t.index,cleanup:a}}function Wt(){}const Vt=Object.create(null);function Ut(e,t,n){let a,r;if("string"===typeof e){const t=Ct(e);if(!t)return n(void 0,424),Wt;r=t.send;const o=function(e){if(!Vt[e]){const t=Ft(e);if(!t)return;const n={config:t,redundancy:Bt(t)};Vt[e]=n}return Vt[e]}(e);o&&(a=o.redundancy)}else{const t=Tt(e);if(t){a=Bt(t);const n=Ct(e.resources?e.resources[0]:"");n&&(r=n.send)}}return a&&r?a.query(t,r,n)().abort:(n(void 0,424),Wt)}const Gt="iconify2",Ht="iconify",jt=Ht+"-count",Kt=Ht+"-version",qt=36e5,Xt=168;function Yt(e,t){try{return e.getItem(t)}catch(n){}}function Qt(e,t,n){try{return e.setItem(t,n),!0}catch(a){}}function Jt(e,t){try{e.removeItem(t)}catch(n){}}function Zt(e,t){return Qt(e,jt,t.toString())}function $t(e){return parseInt(Yt(e,jt))||0}const en={local:!0,session:!0},tn={local:new Set,session:new Set};let nn=!1;let an="undefined"===typeof window?{}:window;function rn(e){const t=e+"Storage";try{if(an&&an[t]&&"number"===typeof an[t].length)return an[t]}catch(n){}en[e]=!1}function on(e,t){const n=rn(e);if(!n)return;const a=Yt(n,Kt);if(a!==Gt){if(a){const e=$t(n);for(let t=0;t<e;t++)Jt(n,Ht+t.toString())}return Qt(n,Kt,Gt),void Zt(n,0)}const r=Math.floor(Date.now()/qt)-Xt,o=e=>{const a=Ht+e.toString(),o=Yt(n,a);if("string"===typeof o){try{const n=JSON.parse(o);if("object"===typeof n&&"number"===typeof n.cached&&n.cached>r&&"string"===typeof n.provider&&"object"===typeof n.data&&"string"===typeof n.data.prefix&&t(n,e))return!0}catch(s){}Jt(n,a)}};let s=$t(n);for(let i=s-1;i>=0;i--)o(i)||(i===s-1?(s--,Zt(n,s)):tn[e].add(i))}function sn(){if(!nn){nn=!0;for(const e in en)on(e,(e=>{const t=e.data,n=lt(e.provider,t.prefix);if(!ut(n,t).length)return!1;const a=t.lastModified||-1;return n.lastModifiedCached=n.lastModifiedCached?Math.min(n.lastModifiedCached,a):a,!0}))}}function cn(e,t){function n(n){let a;if(!en[n]||!(a=rn(n)))return;const r=tn[n];let o;if(r.size)r.delete(o=Array.from(r).shift());else if(o=$t(a),!Zt(a,o+1))return;const s={cached:Math.floor(Date.now()/qt),provider:e.provider,data:t};return Qt(a,Ht+o.toString(),JSON.stringify(s))}nn||sn(),t.lastModified&&!function(e,t){const n=e.lastModifiedCached;if(n&&n>=t)return n===t;if(e.lastModifiedCached=t,n)for(const a in en)on(a,(n=>{const a=n.data;return n.provider!==e.provider||a.prefix!==e.prefix||a.lastModified===t}));return!0}(e,t.lastModified)||Object.keys(t.icons).length&&(t.not_found&&delete(t=Object.assign({},t)).not_found,n("local")||n("session"))}function ln(){}function un(e){e.iconsLoaderFlag||(e.iconsLoaderFlag=!0,setTimeout((()=>{e.iconsLoaderFlag=!1,function(e){e.pendingCallbacksFlag||(e.pendingCallbacksFlag=!0,setTimeout((()=>{e.pendingCallbacksFlag=!1;const t=e.loaderCallbacks?e.loaderCallbacks.slice(0):[];if(!t.length)return;let n=!1;const a=e.provider,r=e.prefix;t.forEach((t=>{const o=t.icons,s=o.pending.length;o.pending=o.pending.filter((t=>{if(t.prefix!==r)return!0;const s=t.name;if(e.icons[s])o.loaded.push({provider:a,prefix:r,name:s});else{if(!e.missing.has(s))return n=!0,!0;o.missing.push({provider:a,prefix:r,name:s})}return!1})),o.pending.length!==s&&(n||Mt([e],t.id),t.callback(o.loaded.slice(0),o.missing.slice(0),o.pending.slice(0),t.abort))}))})))}(e)})))}const dn=(e,t)=>{const n=function(e){let t=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const a=[];return e.forEach((e=>{const r="string"===typeof e?Qe(e,t,n):e;r&&a.push(r)})),a}(e,!0,ht()),a=function(e){const t={loaded:[],missing:[],pending:[]},n=Object.create(null);e.sort(((e,t)=>e.provider!==t.provider?e.provider.localeCompare(t.provider):e.prefix!==t.prefix?e.prefix.localeCompare(t.prefix):e.name.localeCompare(t.name)));let a={provider:"",prefix:"",name:""};return e.forEach((e=>{if(a.name===e.name&&a.prefix===e.prefix&&a.provider===e.provider)return;a=e;const r=e.provider,o=e.prefix,s=e.name,i=n[r]||(n[r]=Object.create(null)),c=i[o]||(i[o]=lt(r,o));let l;l=s in c.icons?t.loaded:""===o||c.missing.has(s)?t.missing:t.pending;const u={provider:r,prefix:o,name:s};l.push(u)})),t}(n);if(!a.pending.length){let e=!0;return t&&setTimeout((()=>{e&&t(a.loaded,a.missing,a.pending,ln)})),()=>{e=!1}}const r=Object.create(null),o=[];let s,i;return a.pending.forEach((e=>{const{provider:t,prefix:n}=e;if(n===i&&t===s)return;s=t,i=n,o.push(lt(t,n));const a=r[t]||(r[t]=Object.create(null));a[n]||(a[n]=[])})),a.pending.forEach((e=>{const{provider:t,prefix:n,name:a}=e,o=lt(t,n),s=o.pendingIcons||(o.pendingIcons=new Set);s.has(a)||(s.add(a),r[t][n].push(a))})),o.forEach((e=>{const{provider:t,prefix:n}=e;r[t][n].length&&function(e,t){e.iconsToLoad?e.iconsToLoad=e.iconsToLoad.concat(t).sort():e.iconsToLoad=t,e.iconsQueueFlag||(e.iconsQueueFlag=!0,setTimeout((()=>{e.iconsQueueFlag=!1;const{provider:t,prefix:n}=e,a=e.iconsToLoad;let r;delete e.iconsToLoad,a&&(r=Ct(t))&&r.prepare(t,n,a).forEach((n=>{Ut(t,n,(t=>{if("object"!==typeof t)n.icons.forEach((t=>{e.missing.add(t)}));else try{const n=ut(e,t);if(!n.length)return;const a=e.pendingIcons;a&&n.forEach((e=>{a.delete(e)})),cn(e,t)}catch(a){console.error(a)}un(e)}))}))})))}(e,r[t][n])})),t?function(e,t,n){const a=Lt++,r=Mt.bind(null,n,a);if(!t.pending.length)return r;const o={id:a,icons:t,callback:e,abort:r};return n.forEach((e=>{(e.loaderCallbacks||(e.loaderCallbacks=[])).push(o)})),r}(t,a,o):ln};const hn=/[\s,]+/;function pn(e,t){t.split(hn).forEach((t=>{switch(t.trim()){case"horizontal":e.hFlip=!0;break;case"vertical":e.vFlip=!0}}))}function fn(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const n=e.replace(/^-?[0-9.]*/,"");function a(e){for(;e<0;)e+=4;return e%4}if(""===n){const t=parseInt(e);return isNaN(t)?0:a(t)}if(n!==e){let t=0;switch(n){case"%":t=25;break;case"deg":t=90}if(t){let r=parseFloat(e.slice(0,e.length-n.length));return isNaN(r)?0:(r/=t,r%1===0?a(r):0)}}return t}let mn;function gn(e){return void 0===mn&&function(){try{mn=window.trustedTypes.createPolicy("iconify",{createHTML:e=>e})}catch(e){mn=null}}(),mn?mn.createHTML(e):e}const bn={...gt,inline:!1},yn={xmlns:"http://www.w3.org/2000/svg",xmlnsXlink:"http://www.w3.org/1999/xlink","aria-hidden":!0,role:"img"},xn={display:"inline-block"},vn={backgroundColor:"currentColor"},wn={backgroundColor:"transparent"},kn={Image:"var(--svg)",Repeat:"no-repeat",Size:"100% 100%"},In={WebkitMask:vn,mask:vn,background:wn};for(const n in In){const e=In[n];for(const t in kn)e[n+t]=kn[t]}const Sn={...bn,inline:!0};function Nn(e){return e+(e.match(/^[-0-9.]+$/)?"px":"")}const Cn=(e,t,n,a)=>{const r=n?Sn:bn,o=function(e,t){const n={...e};for(const a in t){const e=t[a],r=typeof e;a in mt?(null===e||e&&("string"===r||"number"===r))&&(n[a]=e):r===typeof n[a]&&(n[a]="rotate"===a?e%4:e)}return n}(r,t),s=t.mode||"svg",i={},c=t.style||{},l={..."svg"===s?yn:{},ref:a};for(let y in t){const e=t[y];if(void 0!==e)switch(y){case"icon":case"style":case"children":case"onLoad":case"mode":case"_ref":case"_inline":break;case"inline":case"hFlip":case"vFlip":o[y]=!0===e||"true"===e||1===e;break;case"flip":"string"===typeof e&&pn(o,e);break;case"color":i.color=e;break;case"rotate":"string"===typeof e?o[y]=fn(e):"number"===typeof e&&(o[y]=e);break;case"ariaHidden":case"aria-hidden":!0!==e&&"true"!==e&&delete l["aria-hidden"];break;default:void 0===r[y]&&(l[y]=e)}}const u=function(e,t){const n={...et,...e},a={...gt,...t},r={left:n.left,top:n.top,width:n.width,height:n.height};let o=n.body;[n,a].forEach((e=>{const t=[],n=e.hFlip,a=e.vFlip;let s,i=e.rotate;switch(n?a?i+=2:(t.push("translate("+(r.width+r.left).toString()+" "+(0-r.top).toString()+")"),t.push("scale(-1 1)"),r.top=r.left=0):a&&(t.push("translate("+(0-r.left).toString()+" "+(r.height+r.top).toString()+")"),t.push("scale(1 -1)"),r.top=r.left=0),i<0&&(i-=4*Math.floor(i/4)),i%=4,i){case 1:s=r.height/2+r.top,t.unshift("rotate(90 "+s.toString()+" "+s.toString()+")");break;case 2:t.unshift("rotate(180 "+(r.width/2+r.left).toString()+" "+(r.height/2+r.top).toString()+")");break;case 3:s=r.width/2+r.left,t.unshift("rotate(-90 "+s.toString()+" "+s.toString()+")")}i%2===1&&(r.left!==r.top&&(s=r.left,r.left=r.top,r.top=s),r.width!==r.height&&(s=r.width,r.width=r.height,r.height=s)),t.length&&(o='<g transform="'+t.join(" ")+'">'+o+"</g>")}));const s=a.width,i=a.height,c=r.width,l=r.height;let u,d;null===s?(d=null===i?"1em":"auto"===i?l:i,u=xt(d,c/l)):(u="auto"===s?c:s,d=null===i?xt(u,l/c):"auto"===i?l:i);const h={},p=(e,t)=>{(e=>"unset"===e||"undefined"===e||"none"===e)(t)||(h[e]=t.toString())};return p("width",u),p("height",d),h.viewBox=r.left.toString()+" "+r.top.toString()+" "+c.toString()+" "+l.toString(),{attributes:h,body:o}}(e,o),d=u.attributes;if(o.inline&&(i.verticalAlign="-0.125em"),"svg"===s){l.style={...i,...c},Object.assign(l,d);let e=0,n=t.id;return"string"===typeof n&&(n=n.replace(/-/g,"_")),l.dangerouslySetInnerHTML={__html:gn(It(u.body,n?()=>n+"ID"+e++:"iconifyReact"))},A.createElement("svg",l)}const{body:h,width:p,height:f}=e,m="mask"===s||"bg"!==s&&-1!==h.indexOf("currentColor"),g=function(e,t){let n=-1===e.indexOf("xlink:")?"":' xmlns:xlink="http://www.w3.org/1999/xlink"';for(const a in t)n+=" "+a+'="'+t[a]+'"';return'<svg xmlns="http://www.w3.org/2000/svg"'+n+">"+e+"</svg>"}(h,{...d,width:p+"",height:f+""});var b;return l.style={...i,"--svg":(b=g,'url("'+function(e){return"data:image/svg+xml,"+function(e){return e.replace(/"/g,"'").replace(/%/g,"%25").replace(/#/g,"%23").replace(/</g,"%3C").replace(/>/g,"%3E").replace(/\s+/g," ")}(e)}(b)+'")'),width:Nn(d.width),height:Nn(d.height),...xn,...m?vn:wn,...c},A.createElement("span",l)};if(ht(!0),Nt("",Dt),"undefined"!==typeof document&&"undefined"!==typeof window){sn();const e=window;if(void 0!==e.IconifyPreload){const t=e.IconifyPreload,n="Invalid IconifyPreload syntax.";"object"===typeof t&&null!==t&&(t instanceof Array?t:[t]).forEach((e=>{try{("object"!==typeof e||null===e||e instanceof Array||"object"!==typeof e.icons||"string"!==typeof e.prefix||!ft(e))&&console.error(n)}catch(D){console.error(n)}}))}if(void 0!==e.IconifyProviders){const t=e.IconifyProviders;if("object"===typeof t&&null!==t)for(let e in t){const n="IconifyProviders["+e+"] is invalid.";try{const a=t[e];if("object"!==typeof a||!a||void 0===a.resources)continue;At(e,a)||console.error(n)}catch(D){console.error(n)}}}}class Tn extends A.Component{constructor(e){super(e),this.state={icon:null}}_abortLoading(){this._loading&&(this._loading.abort(),this._loading=null)}_setData(e){this.state.icon!==e&&this.setState({icon:e})}_checkIcon(e){const t=this.state,n=this.props.icon;if("object"===typeof n&&null!==n&&"string"===typeof n.body)return this._icon="",this._abortLoading(),void((e||null===t.icon)&&this._setData({data:n}));let a;if("string"!==typeof n||null===(a=Qe(n,!1,!0)))return this._abortLoading(),void this._setData(null);const r=pt(a);if(r){if(this._icon!==n||null===t.icon){this._abortLoading(),this._icon=n;const e=["iconify"];""!==a.prefix&&e.push("iconify--"+a.prefix),""!==a.provider&&e.push("iconify--"+a.provider),this._setData({data:r,classes:e}),this.props.onLoad&&this.props.onLoad(n)}}else this._loading&&this._loading.name===n||(this._abortLoading(),this._icon="",this._setData(null),null!==r&&(this._loading={name:n,abort:dn([a],this._checkIcon.bind(this,!1))}))}componentDidMount(){this._checkIcon(!1)}componentDidUpdate(e){e.icon!==this.props.icon&&this._checkIcon(!0)}componentWillUnmount(){this._abortLoading()}render(){const e=this.props,t=this.state.icon;if(null===t)return e.children?e.children:A.createElement("span",{});let n=e;return t.classes&&(n={...e,className:("string"===typeof e.className?e.className+" ":"")+t.classes.join(" ")}),Cn({...et,...t.data},n,e._inline,e._ref)}}const En=A.forwardRef((function(e,t){const n={...e,_ref:t,_inline:!1};return A.createElement(Tn,n)}));A.forwardRef((function(e,t){const n={...e,_ref:t,_inline:!0};return A.createElement(Tn,n)}));var Rn=n(579);const _n=e=>{let{className:t,size:n,icon:a,iconClasses:r,...o}=e;return(0,Rn.jsx)("span",{className:"\n\t\t\t\tinline-block align-middle\n\t\t\t\t".concat(null!==t&&void 0!==t?t:"","\n\t\t\t\t").concat(null!==n&&void 0!==n?n:"","\n\t\t\t"),children:(0,Rn.jsx)(En,{icon:a,className:"\n\t\t\t\t\t".concat(null!==r&&void 0!==r?r:"","\n\t\t\t\t\t").concat(null!==n&&void 0!==n?n:"","\n\t\t\t\t"),...o})})},An=e=>{let{title:t,handleThemeChange:n,theme:a}=e;const[r,o]=(0,A.useState)(!1),s="bg-white text-slate-900 shadow-sm dark:bg-slate-900 dark:text-slate-100",i="transform top-0 left-0 w-64 ".concat(s," h-full fixed overflow-auto ease-in-out transition-all duration-300 z-30 ").concat(r?"translate-x-0":"-translate-x-full"),c="text-slate-900 dark:text-slate-100";return(0,Rn.jsx)(Rn.Fragment,{children:(0,Rn.jsxs)("div",{className:"".concat(s),children:[(0,Rn.jsxs)("nav",{className:"".concat(s," px-4 py-3 flex justify-between items-center"),children:[(0,Rn.jsx)("div",{className:"text-base font-semibold sm:text-lg",children:t}),(0,Rn.jsx)("button",{className:"md:hidden ".concat(c),onClick:()=>o(!r),"aria-label":"Toggle navigation menu",children:(0,Rn.jsx)("svg",{className:"w-6 h-6",fill:"none",strokeLinecap:"round",strokeLinejoin:"round",strokeWidth:"2",viewBox:"0 0 24 24",stroke:"currentColor",children:(0,Rn.jsx)("path",{d:"M4 6h16M4 12h16M4 18h7"})})}),(0,Rn.jsxs)("div",{className:"hidden items-center gap-3 md:flex",children:[(0,Rn.jsx)("a",{href:"#",className:"rounded px-2 py-1 text-sm font-medium text-slate-600 transition hover:text-slate-900 dark:text-slate-300 dark:hover:text-white",children:"In progress"}),(0,Rn.jsx)("button",{type:"button",className:"inline-flex items-center justify-center rounded-md p-2 transition hover:bg-slate-100 dark:hover:bg-slate-800",onClick:n,"aria-label":"Toggle color theme",children:"light"!==a?(0,Rn.jsx)(_n,{icon:"heroicons:sun",size:"h-6 w-6",className:c}):(0,Rn.jsx)(_n,{icon:"heroicons:moon",size:"h-6 w-6",className:c})})]})]}),(0,Rn.jsxs)("div",{className:i,children:[(0,Rn.jsx)("button",{className:"p-2 text-slate-600 hover:text-slate-900 dark:text-slate-300 dark:hover:text-white",onClick:()=>o(!1),"aria-label":"Close navigation menu",children:"\u2715"}),(0,Rn.jsx)("a",{href:"#",className:"block p-2 text-sm font-medium text-slate-700 dark:text-slate-200",children:"Home"}),(0,Rn.jsx)("a",{href:"#",className:"block p-2 text-sm font-medium text-slate-700 dark:text-slate-200",children:"About"}),(0,Rn.jsx)("a",{href:"#",className:"block p-2 text-sm font-medium text-slate-700 dark:text-slate-200",children:"Services"}),(0,Rn.jsx)("a",{href:"#",className:"block p-2 text-sm font-medium text-slate-700 dark:text-slate-200",children:"Contact"}),(0,Rn.jsx)("button",{type:"button",className:"mt-4 flex items-center gap-2 rounded-md px-2 py-2 text-sm font-medium text-slate-700 transition hover:bg-slate-100 dark:text-slate-200 dark:hover:bg-slate-800",onClick:n,children:"light"!==a?(0,Rn.jsxs)(Rn.Fragment,{children:[(0,Rn.jsx)(_n,{icon:"heroicons:sun",size:"h-5 w-5",className:c}),"Switch to light mode"]}):(0,Rn.jsxs)(Rn.Fragment,{children:[(0,Rn.jsx)(_n,{icon:"heroicons:moon",size:"h-5 w-5",className:c}),"Switch to dark mode"]})})]})]})})};var Fn=Symbol.for("immer-nothing"),On=Symbol.for("immer-draftable"),Dn=Symbol.for("immer-state");function Mn(e){throw new Error("[Immer] minified error nr: ".concat(e,". Full error at: https://bit.ly/3cXEKWf"))}var Ln=Object.getPrototypeOf;function Pn(e){return!!e&&!!e[Dn]}function zn(e){var t;return!!e&&(Wn(e)||Array.isArray(e)||!!e[On]||!(null===(t=e.constructor)||void 0===t||!t[On])||jn(e)||Kn(e))}var Bn=Object.prototype.constructor.toString();function Wn(e){if(!e||"object"!==typeof e)return!1;const t=Ln(e);if(null===t)return!0;const n=Object.hasOwnProperty.call(t,"constructor")&&t.constructor;return n===Object||"function"==typeof n&&Function.toString.call(n)===Bn}function Vn(e,t){0===Un(e)?Reflect.ownKeys(e).forEach((n=>{t(n,e[n],e)})):e.forEach(((n,a)=>t(a,n,e)))}function Un(e){const t=e[Dn];return t?t.type_:Array.isArray(e)?1:jn(e)?2:Kn(e)?3:0}function Gn(e,t){return 2===Un(e)?e.has(t):Object.prototype.hasOwnProperty.call(e,t)}function Hn(e,t,n){const a=Un(e);2===a?e.set(t,n):3===a?e.add(n):e[t]=n}function jn(e){return e instanceof Map}function Kn(e){return e instanceof Set}function qn(e){return e.copy_||e.base_}function Xn(e,t){if(jn(e))return new Map(e);if(Kn(e))return new Set(e);if(Array.isArray(e))return Array.prototype.slice.call(e);const n=Wn(e);if(!0===t||"class_only"===t&&!n){const t=Object.getOwnPropertyDescriptors(e);delete t[Dn];let n=Reflect.ownKeys(t);for(let a=0;a<n.length;a++){const r=n[a],o=t[r];!1===o.writable&&(o.writable=!0,o.configurable=!0),(o.get||o.set)&&(t[r]={configurable:!0,writable:!0,enumerable:o.enumerable,value:e[r]})}return Object.create(Ln(e),t)}{const t=Ln(e);if(null!==t&&n)return{...e};const a=Object.create(t);return Object.assign(a,e)}}function Yn(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];return Jn(e)||Pn(e)||!zn(e)||(Un(e)>1&&(e.set=e.add=e.clear=e.delete=Qn),Object.freeze(e),t&&Object.entries(e).forEach((e=>{let[t,n]=e;return Yn(n,!0)}))),e}function Qn(){Mn(2)}function Jn(e){return Object.isFrozen(e)}var Zn,$n={};function ea(e){const t=$n[e];return t||Mn(0),t}function ta(){return Zn}function na(e,t){t&&(ea("Patches"),e.patches_=[],e.inversePatches_=[],e.patchListener_=t)}function aa(e){ra(e),e.drafts_.forEach(sa),e.drafts_=null}function ra(e){e===Zn&&(Zn=e.parent_)}function oa(e){return Zn={drafts_:[],parent_:Zn,immer_:e,canAutoFreeze_:!0,unfinalizedDrafts_:0}}function sa(e){const t=e[Dn];0===t.type_||1===t.type_?t.revoke_():t.revoked_=!0}function ia(e,t){t.unfinalizedDrafts_=t.drafts_.length;const n=t.drafts_[0];return void 0!==e&&e!==n?(n[Dn].modified_&&(aa(t),Mn(4)),zn(e)&&(e=ca(t,e),t.parent_||ua(t,e)),t.patches_&&ea("Patches").generateReplacementPatches_(n[Dn].base_,e,t.patches_,t.inversePatches_)):e=ca(t,n,[]),aa(t),t.patches_&&t.patchListener_(t.patches_,t.inversePatches_),e!==Fn?e:void 0}function ca(e,t,n){if(Jn(t))return t;const a=t[Dn];if(!a)return Vn(t,((r,o)=>la(e,a,t,r,o,n))),t;if(a.scope_!==e)return t;if(!a.modified_)return ua(e,a.base_,!0),a.base_;if(!a.finalized_){a.finalized_=!0,a.scope_.unfinalizedDrafts_--;const t=a.copy_;let r=t,o=!1;3===a.type_&&(r=new Set(t),t.clear(),o=!0),Vn(r,((r,s)=>la(e,a,t,r,s,n,o))),ua(e,t,!1),n&&e.patches_&&ea("Patches").generatePatches_(a,n,e.patches_,e.inversePatches_)}return a.copy_}function la(e,t,n,a,r,o,s){if(Pn(r)){const s=ca(e,r,o&&t&&3!==t.type_&&!Gn(t.assigned_,a)?o.concat(a):void 0);if(Hn(n,a,s),!Pn(s))return;e.canAutoFreeze_=!1}else s&&n.add(r);if(zn(r)&&!Jn(r)){if(!e.immer_.autoFreeze_&&e.unfinalizedDrafts_<1)return;ca(e,r),t&&t.scope_.parent_||"symbol"===typeof a||!Object.prototype.propertyIsEnumerable.call(n,a)||ua(e,r)}}function ua(e,t){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];!e.parent_&&e.immer_.autoFreeze_&&e.canAutoFreeze_&&Yn(t,n)}var da={get(e,t){if(t===Dn)return e;const n=qn(e);if(!Gn(n,t))return function(e,t,n){var a;const r=fa(t,n);return r?"value"in r?r.value:null===(a=r.get)||void 0===a?void 0:a.call(e.draft_):void 0}(e,n,t);const a=n[t];return e.finalized_||!zn(a)?a:a===pa(e.base_,t)?(ga(e),e.copy_[t]=ba(a,e)):a},has:(e,t)=>t in qn(e),ownKeys:e=>Reflect.ownKeys(qn(e)),set(e,t,n){const a=fa(qn(e),t);if(null!==a&&void 0!==a&&a.set)return a.set.call(e.draft_,n),!0;if(!e.modified_){const a=pa(qn(e),t),s=null===a||void 0===a?void 0:a[Dn];if(s&&s.base_===n)return e.copy_[t]=n,e.assigned_[t]=!1,!0;if(((r=n)===(o=a)?0!==r||1/r===1/o:r!==r&&o!==o)&&(void 0!==n||Gn(e.base_,t)))return!0;ga(e),ma(e)}var r,o;return e.copy_[t]===n&&(void 0!==n||t in e.copy_)||Number.isNaN(n)&&Number.isNaN(e.copy_[t])||(e.copy_[t]=n,e.assigned_[t]=!0),!0},deleteProperty:(e,t)=>(void 0!==pa(e.base_,t)||t in e.base_?(e.assigned_[t]=!1,ga(e),ma(e)):delete e.assigned_[t],e.copy_&&delete e.copy_[t],!0),getOwnPropertyDescriptor(e,t){const n=qn(e),a=Reflect.getOwnPropertyDescriptor(n,t);return a?{writable:!0,configurable:1!==e.type_||"length"!==t,enumerable:a.enumerable,value:n[t]}:a},defineProperty(){Mn(11)},getPrototypeOf:e=>Ln(e.base_),setPrototypeOf(){Mn(12)}},ha={};function pa(e,t){const n=e[Dn];return(n?qn(n):e)[t]}function fa(e,t){if(!(t in e))return;let n=Ln(e);for(;n;){const e=Object.getOwnPropertyDescriptor(n,t);if(e)return e;n=Ln(n)}}function ma(e){e.modified_||(e.modified_=!0,e.parent_&&ma(e.parent_))}function ga(e){e.copy_||(e.copy_=Xn(e.base_,e.scope_.immer_.useStrictShallowCopy_))}Vn(da,((e,t)=>{ha[e]=function(){return arguments[0]=arguments[0][0],t.apply(this,arguments)}})),ha.deleteProperty=function(e,t){return ha.set.call(this,e,t,void 0)},ha.set=function(e,t,n){return da.set.call(this,e[0],t,n,e[0])};function ba(e,t){const n=jn(e)?ea("MapSet").proxyMap_(e,t):Kn(e)?ea("MapSet").proxySet_(e,t):function(e,t){const n=Array.isArray(e),a={type_:n?1:0,scope_:t?t.scope_:ta(),modified_:!1,finalized_:!1,assigned_:{},parent_:t,base_:e,draft_:null,copy_:null,revoke_:null,isManual_:!1};let r=a,o=da;n&&(r=[a],o=ha);const{revoke:s,proxy:i}=Proxy.revocable(r,o);return a.draft_=i,a.revoke_=s,i}(e,t);return(t?t.scope_:ta()).drafts_.push(n),n}function ya(e){return Pn(e)||Mn(10),xa(e)}function xa(e){if(!zn(e)||Jn(e))return e;const t=e[Dn];let n;if(t){if(!t.modified_)return t.base_;t.finalized_=!0,n=Xn(e,t.scope_.immer_.useStrictShallowCopy_)}else n=Xn(e,!0);return Vn(n,((e,t)=>{Hn(n,e,xa(t))})),t&&(t.finalized_=!1),n}var va=new class{constructor(e){var t=this;this.autoFreeze_=!0,this.useStrictShallowCopy_=!1,this.produce=(e,t,n)=>{if("function"===typeof e&&"function"!==typeof t){const n=t;t=e;const a=this;return function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:n;for(var r=arguments.length,o=new Array(r>1?r-1:0),s=1;s<r;s++)o[s-1]=arguments[s];return a.produce(e,(e=>t.call(this,e,...o)))}}let a;if("function"!==typeof t&&Mn(6),void 0!==n&&"function"!==typeof n&&Mn(7),zn(e)){const r=oa(this),o=ba(e,void 0);let s=!0;try{a=t(o),s=!1}finally{s?aa(r):ra(r)}return na(r,n),ia(a,r)}if(!e||"object"!==typeof e){if(a=t(e),void 0===a&&(a=e),a===Fn&&(a=void 0),this.autoFreeze_&&Yn(a,!0),n){const t=[],r=[];ea("Patches").generateReplacementPatches_(e,a,t,r),n(t,r)}return a}Mn(1)},this.produceWithPatches=(e,n)=>{if("function"===typeof e)return function(n){for(var a=arguments.length,r=new Array(a>1?a-1:0),o=1;o<a;o++)r[o-1]=arguments[o];return t.produceWithPatches(n,(t=>e(t,...r)))};let a,r;const o=this.produce(e,n,((e,t)=>{a=e,r=t}));return[o,a,r]},"boolean"===typeof(null===e||void 0===e?void 0:e.autoFreeze)&&this.setAutoFreeze(e.autoFreeze),"boolean"===typeof(null===e||void 0===e?void 0:e.useStrictShallowCopy)&&this.setUseStrictShallowCopy(e.useStrictShallowCopy)}createDraft(e){zn(e)||Mn(8),Pn(e)&&(e=ya(e));const t=oa(this),n=ba(e,void 0);return n[Dn].isManual_=!0,ra(t),n}finishDraft(e,t){const n=e&&e[Dn];n&&n.isManual_||Mn(9);const{scope_:a}=n;return na(a,t),ia(void 0,a)}setAutoFreeze(e){this.autoFreeze_=e}setUseStrictShallowCopy(e){this.useStrictShallowCopy_=e}applyPatches(e,t){let n;for(n=t.length-1;n>=0;n--){const a=t[n];if(0===a.path.length&&"replace"===a.op){e=a.value;break}}n>-1&&(t=t.slice(n+1));const a=ea("Patches").applyPatches_;return Pn(e)?a(e,t):this.produce(e,(e=>a(e,t)))}},wa=va.produce;va.produceWithPatches.bind(va),va.setAutoFreeze.bind(va),va.setUseStrictShallowCopy.bind(va),va.applyPatches.bind(va),va.createDraft.bind(va),va.finishDraft.bind(va);function ka(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"expected a function, instead received ".concat(typeof e);if("function"!==typeof e)throw new TypeError(t)}var Ia=e=>Array.isArray(e)?e:[e];function Sa(e){const t=Array.isArray(e[0])?e[0]:e;return function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"expected all items to be functions, instead received the following types: ";if(!e.every((e=>"function"===typeof e))){const n=e.map((e=>"function"===typeof e?"function ".concat(e.name||"unnamed","()"):typeof e)).join(", ");throw new TypeError("".concat(t,"[").concat(n,"]"))}}(t,"createSelector expects all input-selectors to be functions, but received the following types: "),t}Symbol(),Object.getPrototypeOf({});var Na="undefined"!==typeof WeakRef?WeakRef:class{constructor(e){this.value=e}deref(){return this.value}},Ca=0,Ta=1;function Ea(){return{s:Ca,v:void 0,o:null,p:null}}function Ra(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},n=Ea();const{resultEqualityCheck:a}=t;let r,o=0;function s(){let t=n;const{length:s}=arguments;for(let e=0,n=s;e<n;e++){const n=arguments[e];if("function"===typeof n||"object"===typeof n&&null!==n){let e=t.o;null===e&&(t.o=e=new WeakMap);const a=e.get(n);void 0===a?(t=Ea(),e.set(n,t)):t=a}else{let e=t.p;null===e&&(t.p=e=new Map);const a=e.get(n);void 0===a?(t=Ea(),e.set(n,t)):t=a}}const i=t;let c;if(t.s===Ta?c=t.v:(c=e.apply(null,arguments),o++),i.s=Ta,a){var l,u,d;const e=null!==(l=null===(u=r)||void 0===u||null===(d=u.deref)||void 0===d?void 0:d.call(u))&&void 0!==l?l:r;null!=e&&a(e,c)&&(c=e,0!==o&&o--);r="object"===typeof c&&null!==c||"function"===typeof c?new Na(c):c}return i.v=c,c}return s.clearCache=()=>{n=Ea(),s.resetResultsCount()},s.resultsCount=()=>o,s.resetResultsCount=()=>{o=0},s}function _a(e){for(var t=arguments.length,n=new Array(t>1?t-1:0),a=1;a<t;a++)n[a-1]=arguments[a];const r="function"===typeof e?{memoize:e,memoizeOptions:n}:e,o=function(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];let a,o=0,s=0,i={},c=t.pop();"object"===typeof c&&(i=c,c=t.pop()),ka(c,"createSelector expects an output function after the inputs, but received: [".concat(typeof c,"]"));const l={...r,...i},{memoize:u,memoizeOptions:d=[],argsMemoize:h=Ra,argsMemoizeOptions:p=[],devModeChecks:f={}}=l,m=Ia(d),g=Ia(p),b=Sa(t),y=u((function(){return o++,c.apply(null,arguments)}),...m);const x=h((function(){s++;const e=function(e,t){const n=[],{length:a}=e;for(let r=0;r<a;r++)n.push(e[r].apply(null,t));return n}(b,arguments);return a=y.apply(null,e),a}),...g);return Object.assign(x,{resultFunc:c,memoizedResultFunc:y,dependencies:b,dependencyRecomputations:()=>s,resetDependencyRecomputations:()=>{s=0},lastResult:()=>a,recomputations:()=>o,resetRecomputations:()=>{o=0},memoize:u,argsMemoize:h})};return Object.assign(o,{withTypes:()=>o}),o}var Aa=_a(Ra),Fa=Object.assign((function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:Aa;!function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"expected an object, instead received ".concat(typeof e);if("object"!==typeof e)throw new TypeError(t)}(e,"createStructuredSelector expects first argument to be an object where each property is a selector, instead received a ".concat(typeof e));const n=Object.keys(e),a=t(n.map((t=>e[t])),(function(){for(var e=arguments.length,t=new Array(e),a=0;a<e;a++)t[a]=arguments[a];return t.reduce(((e,t,a)=>(e[n[a]]=t,e)),{})}));return a}),{withTypes:()=>Fa});function Oa(e){return"Minified Redux error #".concat(e,"; visit https://redux.js.org/Errors?code=").concat(e," for the full message or use the non-minified dev environment for full errors. ")}var Da=(()=>"function"===typeof Symbol&&Symbol.observable||"@@observable")(),Ma=()=>Math.random().toString(36).substring(7).split("").join("."),La={INIT:"@@redux/INIT".concat(Ma()),REPLACE:"@@redux/REPLACE".concat(Ma()),PROBE_UNKNOWN_ACTION:()=>"@@redux/PROBE_UNKNOWN_ACTION".concat(Ma())};function Pa(e){if("object"!==typeof e||null===e)return!1;let t=e;for(;null!==Object.getPrototypeOf(t);)t=Object.getPrototypeOf(t);return Object.getPrototypeOf(e)===t||null===Object.getPrototypeOf(e)}function za(e,t,n){if("function"!==typeof e)throw new Error(Oa(2));if("function"===typeof t&&"function"===typeof n||"function"===typeof n&&"function"===typeof arguments[3])throw new Error(Oa(0));if("function"===typeof t&&"undefined"===typeof n&&(n=t,t=void 0),"undefined"!==typeof n){if("function"!==typeof n)throw new Error(Oa(1));return n(za)(e,t)}let a=e,r=t,o=new Map,s=o,i=0,c=!1;function l(){s===o&&(s=new Map,o.forEach(((e,t)=>{s.set(t,e)})))}function u(){if(c)throw new Error(Oa(3));return r}function d(e){if("function"!==typeof e)throw new Error(Oa(4));if(c)throw new Error(Oa(5));let t=!0;l();const n=i++;return s.set(n,e),function(){if(t){if(c)throw new Error(Oa(6));t=!1,l(),s.delete(n),o=null}}}function h(e){if(!Pa(e))throw new Error(Oa(7));if("undefined"===typeof e.type)throw new Error(Oa(8));if("string"!==typeof e.type)throw new Error(Oa(17));if(c)throw new Error(Oa(9));try{c=!0,r=a(r,e)}finally{c=!1}return(o=s).forEach((e=>{e()})),e}h({type:La.INIT});return{dispatch:h,subscribe:d,getState:u,replaceReducer:function(e){if("function"!==typeof e)throw new Error(Oa(10));a=e,h({type:La.REPLACE})},[Da]:function(){const e=d;return{subscribe(t){if("object"!==typeof t||null===t)throw new Error(Oa(11));function n(){const e=t;e.next&&e.next(u())}n();return{unsubscribe:e(n)}},[Da](){return this}}}}}function Ba(e){const t=Object.keys(e),n={};for(let o=0;o<t.length;o++){const a=t[o];0,"function"===typeof e[a]&&(n[a]=e[a])}const a=Object.keys(n);let r;try{!function(e){Object.keys(e).forEach((t=>{const n=e[t];if("undefined"===typeof n(void 0,{type:La.INIT}))throw new Error(Oa(12));if("undefined"===typeof n(void 0,{type:La.PROBE_UNKNOWN_ACTION()}))throw new Error(Oa(13))}))}(n)}catch(D){r=D}return function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},t=arguments.length>1?arguments[1]:void 0;if(r)throw r;let o=!1;const s={};for(let r=0;r<a.length;r++){const i=a[r],c=n[i],l=e[i],u=c(l,t);if("undefined"===typeof u){t&&t.type;throw new Error(Oa(14))}s[i]=u,o=o||u!==l}return o=o||a.length!==Object.keys(e).length,o?s:e}}function Wa(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];return 0===t.length?e=>e:1===t.length?t[0]:t.reduce(((e,t)=>function(){return e(t(...arguments))}))}function Va(e){return t=>{let{dispatch:n,getState:a}=t;return t=>r=>"function"===typeof r?r(n,a,e):t(r)}}var Ua=Va(),Ga=Va,Ha=(function(){const e=_a(...arguments),t=Object.assign((function(){const t=e(...arguments),n=function(e){for(var n=arguments.length,a=new Array(n>1?n-1:0),r=1;r<n;r++)a[r-1]=arguments[r];return t(Pn(e)?ya(e):e,...a)};return Object.assign(n,t),n}),{withTypes:()=>t})}(Ra),"undefined"!==typeof window&&window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__?window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__:function(){if(0!==arguments.length)return"object"===typeof arguments[0]?Wa:Wa.apply(null,arguments)});"undefined"!==typeof window&&window.__REDUX_DEVTOOLS_EXTENSION__&&window.__REDUX_DEVTOOLS_EXTENSION__;function ja(e,t){function n(){if(t){let n=t(...arguments);if(!n)throw new Error(br(0));return{type:e,payload:n.payload,..."meta"in n&&{meta:n.meta},..."error"in n&&{error:n.error}}}return{type:e,payload:arguments.length<=0?void 0:arguments[0]}}return n.toString=()=>"".concat(e),n.type=e,n.match=t=>function(e){return Pa(e)&&"type"in e&&"string"===typeof e.type}(t)&&t.type===e,n}var Ka=class e extends Array{constructor(){super(...arguments),Object.setPrototypeOf(this,e.prototype)}static get[Symbol.species](){return e}concat(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];return super.concat.apply(this,t)}prepend(){for(var t=arguments.length,n=new Array(t),a=0;a<t;a++)n[a]=arguments[a];return 1===n.length&&Array.isArray(n[0])?new e(...n[0].concat(this)):new e(...n.concat(this))}};function qa(e){return zn(e)?wa(e,(()=>{})):e}function Xa(e,t,n){if(e.has(t)){let a=e.get(t);return n.update&&(a=n.update(a,t,e),e.set(t,a)),a}if(!n.insert)throw new Error(br(10));const a=n.insert(t,e);return e.set(t,a),a}var Ya="RTK_autoBatch",Qa=e=>t=>{setTimeout(t,e)},Ja="undefined"!==typeof window&&window.requestAnimationFrame?window.requestAnimationFrame:Qa(10),Za=e=>function(t){const{autoBatch:n=!0}=null!==t&&void 0!==t?t:{};let a=new Ka(e);return n&&a.push(function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{type:"raf"};return t=>function(){const n=t(...arguments);let a=!0,r=!1,o=!1;const s=new Set,i="tick"===e.type?queueMicrotask:"raf"===e.type?Ja:"callback"===e.type?e.queueNotification:Qa(e.timeout),c=()=>{o=!1,r&&(r=!1,s.forEach((e=>e())))};return Object.assign({},n,{subscribe(e){const t=n.subscribe((()=>a&&e()));return s.add(e),()=>{t(),s.delete(e)}},dispatch(e){try{var t;return a=!(null!==e&&void 0!==e&&null!==(t=e.meta)&&void 0!==t&&t[Ya]),r=!a,r&&(o||(o=!0,i(c))),n.dispatch(e)}finally{a=!0}}})}}("object"===typeof n?n:void 0)),a};function $a(e){const t={},n=[];let a;const r={addCase(e,n){const a="string"===typeof e?e:e.type;if(!a)throw new Error(br(28));if(a in t)throw new Error(br(29));return t[a]=n,r},addMatcher:(e,t)=>(n.push({matcher:e,reducer:t}),r),addDefaultCase:e=>(a=e,r)};return e(r),[t,n,a]}var er=function(){let e="",t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:21;for(;t--;)e+="ModuleSymbhasOwnPr-0123456789ABCDEFGHNRVfgctiUvz_KqYTJkLxpZXIjQW"[64*Math.random()|0];return e};var tr=Symbol.for("rtk-slice-createasyncthunk");function nr(e,t){return"".concat(e,"/").concat(t)}function ar(){var e;let{creators:t}=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};const n=null===t||void 0===t||null===(e=t.asyncThunk)||void 0===e?void 0:e[tr];return function(e){const{name:t,reducerPath:a=t}=e;if(!t)throw new Error(br(11));const r=("function"===typeof e.reducers?e.reducers(function(){function e(e,t){return{_reducerDefinitionType:"asyncThunk",payloadCreator:e,...t}}return e.withTypes=()=>e,{reducer:e=>Object.assign({[e.name](){return e(...arguments)}}[e.name],{_reducerDefinitionType:"reducer"}),preparedReducer:(e,t)=>({_reducerDefinitionType:"reducerWithPrepare",prepare:e,reducer:t}),asyncThunk:e}}()):e.reducers)||{},o=Object.keys(r),s={sliceCaseReducersByName:{},sliceCaseReducersByType:{},actionCreators:{},sliceMatchers:[]},i={addCase(e,t){const n="string"===typeof e?e:e.type;if(!n)throw new Error(br(12));if(n in s.sliceCaseReducersByType)throw new Error(br(13));return s.sliceCaseReducersByType[n]=t,i},addMatcher:(e,t)=>(s.sliceMatchers.push({matcher:e,reducer:t}),i),exposeAction:(e,t)=>(s.actionCreators[e]=t,i),exposeCaseReducer:(e,t)=>(s.sliceCaseReducersByName[e]=t,i)};function c(){const[t={},n=[],a]="function"===typeof e.extraReducers?$a(e.extraReducers):[e.extraReducers],r={...t,...s.sliceCaseReducersByType};return function(e,t){let n,[a,r,o]=$a(t);if("function"===typeof e)n=()=>qa(e());else{const t=qa(e);n=()=>t}function s(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:n(),t=arguments.length>1?arguments[1]:void 0,s=[a[t.type],...r.filter((e=>{let{matcher:n}=e;return n(t)})).map((e=>{let{reducer:t}=e;return t}))];return 0===s.filter((e=>!!e)).length&&(s=[o]),s.reduce(((e,n)=>{if(n){if(Pn(e)){const a=n(e,t);return void 0===a?e:a}if(zn(e))return wa(e,(e=>n(e,t)));{const a=n(e,t);if(void 0===a){if(null===e)return e;throw new Error(br(9))}return a}}return e}),e)}return s.getInitialState=n,s}(e.initialState,(e=>{for(let t in r)e.addCase(t,r[t]);for(let t of s.sliceMatchers)e.addMatcher(t.matcher,t.reducer);for(let t of n)e.addMatcher(t.matcher,t.reducer);a&&e.addDefaultCase(a)}))}o.forEach((a=>{const o=r[a],s={reducerName:a,type:nr(t,a),createNotation:"function"===typeof e.reducers};!function(e){return"asyncThunk"===e._reducerDefinitionType}(o)?function(e,t,n){let a,r,{type:o,reducerName:s,createNotation:i}=e;if("reducer"in t){if(i&&!function(e){return"reducerWithPrepare"===e._reducerDefinitionType}(t))throw new Error(br(17));a=t.reducer,r=t.prepare}else a=t;n.addCase(o,a).exposeCaseReducer(s,a).exposeAction(s,r?ja(o,r):ja(o))}(s,o,i):function(e,t,n,a){let{type:r,reducerName:o}=e;if(!a)throw new Error(br(18));const{payloadCreator:s,fulfilled:i,pending:c,rejected:l,settled:u,options:d}=t,h=a(r,s,d);n.exposeAction(o,h),i&&n.addCase(h.fulfilled,i);c&&n.addCase(h.pending,c);l&&n.addCase(h.rejected,l);u&&n.addMatcher(h.settled,u);n.exposeCaseReducer(o,{fulfilled:i||sr,pending:c||sr,rejected:l||sr,settled:u||sr})}(s,o,i,n)}));const l=e=>e,u=new Map;let d;function h(e,t){return d||(d=c()),d(e,t)}function p(){return d||(d=c()),d.getInitialState()}function f(t){let n=arguments.length>1&&void 0!==arguments[1]&&arguments[1];function a(e){let a=e[t];return"undefined"===typeof a&&n&&(a=p()),a}function r(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:l;const a=Xa(u,n,{insert:()=>new WeakMap});return Xa(a,t,{insert:()=>{const a={};for(const[o,s]of Object.entries(null!==(r=e.selectors)&&void 0!==r?r:{})){var r;a[o]=rr(s,t,p,n)}return a}})}return{reducerPath:t,getSelectors:r,get selectors(){return r(a)},selectSlice:a}}const m={name:t,reducer:h,actions:s.actionCreators,caseReducers:s.sliceCaseReducersByName,getInitialState:p,...f(a),injectInto(e){let{reducerPath:t,...n}=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const r=null!==t&&void 0!==t?t:a;return e.inject({reducerPath:r,reducer:h},n),{...m,...f(r,!0)}}};return m}}function rr(e,t,n,a){function r(r){let o=t(r);"undefined"===typeof o&&a&&(o=n());for(var s=arguments.length,i=new Array(s>1?s-1:0),c=1;c<s;c++)i[c-1]=arguments[c];return e(o,...i)}return r.unwrapped=e,r}var or=ar();function sr(){}var ir="listener",cr="completed",lr="cancelled",ur=("task-".concat(lr),"task-".concat(cr),"".concat(ir,"-").concat(lr),"".concat(ir,"-").concat(cr),(e,t)=>{if("function"!==typeof e)throw new Error(br(32))});var{assign:dr}=Object,hr="listenerMiddleware",pr=e=>{let{type:t,actionCreator:n,matcher:a,predicate:r,effect:o}=e;if(t)r=ja(t).match;else if(n)t=n.type,r=n.match;else if(a)r=a;else if(!r)throw new Error(br(21));return ur(o),{predicate:r,type:t,effect:o}},fr=Object.assign((e=>{const{type:t,predicate:n,effect:a}=pr(e);return{id:er(),effect:a,type:t,predicate:n,pending:new Set,unsubscribe:()=>{throw new Error(br(22))}}}),{withTypes:()=>fr}),mr=Object.assign(ja("".concat(hr,"/add")),{withTypes:()=>mr}),gr=(ja("".concat(hr,"/removeAll")),Object.assign(ja("".concat(hr,"/remove")),{withTypes:()=>gr}));Symbol.for("rtk-state-proxy-original");function br(e){return"Minified Redux Toolkit error #".concat(e,"; visit https://redux-toolkit.js.org/Errors?code=").concat(e," for the full message or use the non-minified dev environment for full errors. ")}const yr=or({name:"main",initialState:{path:"",error:"",message:"",signalr:{},theme:(()=>{if("undefined"===typeof window)return"light";const e=window.localStorage.getItem("theme");if("light"===e||"dark"===e)return e;return window.matchMedia&&window.matchMedia("(prefers-color-scheme: dark)").matches?"dark":"light"})(),prefersLightMode:!("undefined"===typeof window||!window.matchMedia||!window.matchMedia("(prefers-color-scheme: light)").matches),GlobalCallErrors:[],constants:{drawerWidth:240}},reducers:{set:(e,t)=>{e[t.target]=t.payload},setTheme:(e,t)=>{e.theme=t.payload},setPath:(e,t)=>{e.path=t.payload},setError:(e,t)=>{e.error=t.payload},setMessage:(e,t)=>{e.message=t.payload},setSignalr:(e,t)=>{e.signalr=t.payload},setPrefersLightMode:(e,t)=>{e.prefersLightMode=t.payload},setGlobalCallErrors:(e,t)=>{e.GlobalCallErrors=t.payload}}}),{set:xr,setTheme:vr,setPath:wr,setError:kr,setMessage:Ir,setSignalr:Sr,setPrefersLightMode:Nr,setGlobalCallErrors:Cr}=yr.actions,Tr=yr.reducer;var Er=n(237),Rr=A,_r=Symbol.for("react-redux-context"),Ar="undefined"!==typeof globalThis?globalThis:{};function Fr(){var e;if(!Rr.createContext)return{};const t=null!==(e=Ar[_r])&&void 0!==e?e:Ar[_r]=new Map;let n=t.get(Rr.createContext);return n||(n=Rr.createContext(null),t.set(Rr.createContext,n)),n}var Or=Fr(),Dr=()=>{throw new Error("uSES not initialized!")};function Mr(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:Or;return function(){return Rr.useContext(e)}}var Lr=Mr(),Pr=Dr,zr=(e,t)=>e===t;function Br(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:Or;const t=e===Or?Lr:Mr(e),n=function(e){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const{equalityFn:a=zr,devModeChecks:r={}}="function"===typeof n?{equalityFn:n}:n;const{store:o,subscription:s,getServerState:i,stabilityCheck:c,identityFunctionCheck:l}=t(),u=(Rr.useRef(!0),Rr.useCallback({[e.name]:t=>e(t)}[e.name],[e,c,r.stabilityCheck])),d=Pr(s.addNestedSub,o.getState,i||o.getState,u,a);return Rr.useDebugValue(d),d};return Object.assign(n,{withTypes:()=>n}),n}var Wr=Br();Symbol.for("react.element"),Symbol.for("react.portal"),Symbol.for("react.fragment"),Symbol.for("react.strict_mode"),Symbol.for("react.profiler"),Symbol.for("react.provider"),Symbol.for("react.context"),Symbol.for("react.server_context"),Symbol.for("react.forward_ref"),Symbol.for("react.suspense"),Symbol.for("react.suspense_list"),Symbol.for("react.memo"),Symbol.for("react.lazy"),Symbol.for("react.offscreen"),Symbol.for("react.client.reference");function Vr(e){e()}var Ur={notify(){},get:()=>[]};function Gr(e,t){let n,a=Ur,r=0,o=!1;function s(){l.onStateChange&&l.onStateChange()}function i(){r++,n||(n=t?t.addNestedSub(s):e.subscribe(s),a=function(){let e=null,t=null;return{clear(){e=null,t=null},notify(){Vr((()=>{let t=e;for(;t;)t.callback(),t=t.next}))},get(){const t=[];let n=e;for(;n;)t.push(n),n=n.next;return t},subscribe(n){let a=!0;const r=t={callback:n,next:null,prev:t};return r.prev?r.prev.next=r:e=r,function(){a&&null!==e&&(a=!1,r.next?r.next.prev=r.prev:t=r.prev,r.prev?r.prev.next=r.next:e=r.next)}}}}())}function c(){r--,n&&0===r&&(n(),n=void 0,a.clear(),a=Ur)}const l={addNestedSub:function(e){i();const t=a.subscribe(e);let n=!1;return()=>{n||(n=!0,t(),c())}},notifyNestedSubs:function(){a.notify()},handleChangeWrapper:s,isSubscribed:function(){return o},trySubscribe:function(){o||(o=!0,i())},tryUnsubscribe:function(){o&&(o=!1,c())},getListeners:()=>a};return l}var Hr=!("undefined"===typeof window||"undefined"===typeof window.document||"undefined"===typeof window.document.createElement),jr="undefined"!==typeof navigator&&"ReactNative"===navigator.product,Kr=Hr||jr?Rr.useLayoutEffect:Rr.useEffect;Object.defineProperty,Object.getOwnPropertyNames,Object.getOwnPropertySymbols,Object.getOwnPropertyDescriptor,Object.getPrototypeOf,Object.prototype;var qr=function(e){let{store:t,context:n,children:a,serverState:r,stabilityCheck:o="once",identityFunctionCheck:s="once"}=e;const i=Rr.useMemo((()=>{const e=Gr(t);return{store:t,subscription:e,getServerState:r?()=>r:void 0,stabilityCheck:o,identityFunctionCheck:s}}),[t,r,o,s]),c=Rr.useMemo((()=>t.getState()),[t]);Kr((()=>{const{subscription:e}=i;return e.onStateChange=e.notifyNestedSubs,e.trySubscribe(),c!==t.getState()&&e.notifyNestedSubs(),()=>{e.tryUnsubscribe(),e.onStateChange=void 0}}),[i,c]);const l=n||Or;return Rr.createElement(l.Provider,{value:i},a)};function Xr(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:Or;const t=e===Or?Lr:Mr(e),n=()=>{const{store:e}=t();return e};return Object.assign(n,{withTypes:()=>n}),n}var Yr=Xr();function Qr(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:Or;const t=e===Or?Yr:Xr(e),n=()=>t().dispatch;return Object.assign(n,{withTypes:()=>n}),n}var Jr,Zr=Qr();Jr=Er.useSyncExternalStoreWithSelector,Pr=Jr,(e=>{e})(A.useSyncExternalStore);class $r{constructor(e,t){this.backend=e,this.dataMover=t,this.data=new WeakMap,this.dataIdsCount=0}get(e){return this.data.has(e)||this.dataMover.moveData(this.backend,e),this.data.get(e)}set(e,t){this.dataIdsCount++,this.data.set(e,t)}has(e){return this.data.has(e)}delete(e){return this.dataIdsCount--,this.data.delete(e)}numDataIds(){return this.dataIdsCount}}class eo{refCount(e){return to("refCount")}incRef(e){return to("incRef")}timerAvailable(){return!0}time(e){return to("time")}read(e){return to("read")}readSync(e){return to("readSync")}readToGPU(e,t){return to("readToGPU")}numDataIds(){return to("numDataIds")}disposeData(e,t){return to("disposeData")}write(e,t,n){return to("write")}move(e,t,n,a,r){return to("move")}createTensorFromGPUData(e,t,n){return to("createTensorFromGPUData")}memory(){return to("memory")}floatPrecision(){return to("floatPrecision")}epsilon(){return 32===this.floatPrecision()?1e-7:1e-4}dispose(){return to("dispose")}}function to(e){throw new Error("'".concat(e,"' not yet implemented or not found in the registry. ")+"This kernel may not be supported by the tfjs backend you have chosen")}function no(e){let t=e.length,n=0;for(;t>0;)n=Math.random()*t|0,t--,oo(e,t,n)}function ao(e,t,n){return Math.max(e,Math.min(t,n))}function ro(e){return e%2===0?e:e+1}function oo(e,t,n){const a=e[t];e[t]=e[n],e[n]=a}function so(e,t){if(!e)throw new Error("string"===typeof t?t:t())}function io(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"";so(uo(e,t),(()=>n+" Shapes ".concat(e," and ").concat(t," must match")))}function co(e){so(null!=e,(()=>"The input to the tensor constructor must be a non-null value."))}function lo(e){if(0===e.length)return 1;let t=e[0];for(let n=1;n<e.length;n++)t*=e[n];return t}function uo(e,t){if(e===t)return!0;if(null==e||null==t)return!1;if(e.length!==t.length)return!1;for(let n=0;n<e.length;n++)if(e[n]!==t[n])return!1;return!0}function ho(e){return e%1===0}function po(e){const t=Math.ceil(Math.sqrt(e));return[t,Math.ceil(e/t)]}function fo(e,t){return t<=e.length?e:e+" ".repeat(t-e.length)}function mo(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:e=>0,n=arguments.length>2?arguments[2]:void 0,a=arguments.length>3?arguments[3]:void 0;return new Promise(((r,o)=>{let s=0;const i=()=>{if(e())return void r();s++;const c=t(s);null!=n&&s>=n?o():null!=a?a(i,c):setTimeout(i,c)};i()}))}function go(e,t){let n=1,a=-1;for(let o=0;o<e.length;++o)if(e[o]>=0)n*=e[o];else if(-1===e[o]){if(-1!==a)throw Error("Shapes can only have 1 implicit size. "+"Found -1 at dim ".concat(a," and dim ").concat(o));a=o}else if(e[o]<0)throw Error("Shapes can not be < 0. Found ".concat(e[o]," at dim ").concat(o));if(-1===a){if(t>0&&t!==n)throw Error("Size(".concat(t,") must match the product of shape ").concat(e));return e}if(0===n)throw Error("Cannot infer the missing size in [".concat(e,"] when ")+"there are 0 elements");if(t%n!==0)throw Error("The implicit shape can't be a fractional number. "+"Got ".concat(t," / ").concat(n));const r=e.slice();return r[a]=t/n,r}function bo(e,t){const n=t.length;return e=null==e?t.map(((e,t)=>t)):[].concat(e),so(e.every((e=>e>=-n&&e<n)),(()=>"All values in axis param must be in range [-".concat(n,", ").concat(n,") but ")+"got axis ".concat(e))),so(e.every((e=>ho(e))),(()=>"All values in axis param must be integers but "+"got axis ".concat(e))),e.map((e=>e<0?n+e:e))}function yo(e,t){const n=[],a=[],r=null!=t&&Array.isArray(t)&&0===t.length,o=null==t||r?null:bo(t,e).sort();let s=0;for(let i=0;i<e.length;++i){if(null!=o){if(o[s]===i&&1!==e[i])throw new Error("Can't squeeze axis ".concat(i," since its dim '").concat(e[i],"' is not 1"));(null==o[s]||o[s]>i)&&1===e[i]&&(n.push(e[i]),a.push(i)),o[s]<=i&&s++}1!==e[i]&&(n.push(e[i]),a.push(i))}return{newShape:n,keptDims:a}}function xo(e,t){return vo(e,t)}function vo(e,t){let n=null;if(null==e||"float32"===e)n=new Float32Array(t);else if("int32"===e)n=new Int32Array(t);else if("bool"===e)n=new Uint8Array(t);else{if("string"!==e)throw new Error("Unknown data type ".concat(e));n=new Array(t)}return n}function wo(e,t){return"complex64"!==t&&(("float32"!==t||"complex64"===e)&&(("int32"!==t||"float32"===e||"complex64"===e)&&("bool"!==t||"bool"!==e)))}function ko(e){if("float32"===e||"int32"===e)return 4;if("complex64"===e)return 8;if("bool"===e)return 1;throw new Error("Unknown dtype ".concat(e))}function Io(e){return"string"===typeof e||e instanceof String}function So(e){return"number"===typeof e}function No(e){return Array.isArray(e)?No(e[0]):e instanceof Float32Array?"float32":e instanceof Int32Array||e instanceof Uint8Array||e instanceof Uint8ClampedArray?"int32":So(e)?"float32":Io(e)?"string":"boolean"===typeof e?"bool":"float32"}function Co(e){return!!(e&&e.constructor&&e.call&&e.apply)}function To(e,t){for(let n=t;n<e;++n)if(e%n===0)return n;return e}function Eo(e){const t=e.length;if(t<2)return[];const n=new Array(t-1);n[t-2]=e[t-1];for(let a=t-3;a>=0;--a)n[a]=n[a+1]*e[a+1];return n}function Ro(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const r=new Array;if(1===t.length){const o=t[0]*(a?2:1);for(let t=0;t<o;t++)r[t]=n[e+t]}else{const o=t[0],s=t.slice(1),i=s.reduce(((e,t)=>e*t))*(a?2:1);for(let t=0;t<o;t++)r[t]=Ro(e+t*i,s,n,a)}return r}function _o(e,t){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];if(0===e.length)return t[0];const a=e.reduce(((e,t)=>e*t))*(n?2:1);if(0===a)return[];if(a!==t.length)throw new Error("[".concat(e,"] does not match the input size ").concat(t.length).concat(n?" for a complex tensor":"","."));return Ro(0,e,t,n)}function Ao(e,t){const n=Fo(e,t);for(let a=0;a<n.length;a++)n[a]=1;return n}function Fo(e,t){if(null==t||"float32"===t||"complex64"===t)return new Float32Array(e);if("int32"===t)return new Int32Array(e);if("bool"===t)return new Uint8Array(e);throw new Error("Unknown data type ".concat(t))}function Oo(e,t){const n=e.reduce(((e,t)=>e*t),1);if(null==t||"float32"===t)return _o(e,new Float32Array(n));if("int32"===t)return _o(e,new Int32Array(n));if("bool"===t)return _o(e,new Uint8Array(n));throw new Error("Unknown data type ".concat(t))}function Do(e){e.forEach((t=>{so(Number.isInteger(t)&&t>=0,(()=>"Tensor must have a shape comprised of positive integers but got "+"shape [".concat(e,"].")))}))}function Mo(e,t,n){if(0===t)return 0;if(1===t)return e[0];let a=e[e.length-1];for(let r=0;r<e.length-1;++r)a+=n[r]*e[r];return a}function Lo(e,t,n){if(0===t)return[];if(1===t)return[e];const a=new Array(t);for(let r=0;r<a.length-1;++r)a[r]=Math.floor(e/n[r]),e-=a[r]*n[r];return a[a.length-1]=e,a}function Po(e){return e&&e.then&&"function"===typeof e.then}const zo="tfjsflags";class Bo{constructor(e){this.global=e,this.flags={},this.flagRegistry={},this.urlFlags={},this.getQueryParams=Wo,this.populateURLFlags()}setPlatform(e,t){null!=this.platform&&(Vo().getBool("IS_TEST")||Vo().getBool("PROD")||console.warn("Platform ".concat(this.platformName," has already been set. ")+"Overwriting the platform with ".concat(e,"."))),this.platformName=e,this.platform=t}registerFlag(e,t,n){if(this.flagRegistry[e]={evaluationFn:t,setHook:n},null!=this.urlFlags[e]){const t=this.urlFlags[e];Vo().getBool("IS_TEST")||Vo().getBool("PROD")||console.warn("Setting feature override from URL ".concat(e,": ").concat(t,".")),this.set(e,t)}}async getAsync(e){return e in this.flags||(this.flags[e]=await this.evaluateFlag(e)),this.flags[e]}get(e){if(e in this.flags)return this.flags[e];const t=this.evaluateFlag(e);if(Po(t))throw new Error("Flag ".concat(e," cannot be synchronously evaluated. ")+"Please use getAsync() instead.");return this.flags[e]=t,this.flags[e]}getNumber(e){return this.get(e)}getBool(e){return this.get(e)}getString(e){return this.get(e)}getFlags(){return this.flags}get features(){return this.flags}set(e,t){if(null==this.flagRegistry[e])throw new Error("Cannot set flag ".concat(e," as it has not been registered."));this.flags[e]=t,null!=this.flagRegistry[e].setHook&&this.flagRegistry[e].setHook(t)}evaluateFlag(e){if(null==this.flagRegistry[e])throw new Error("Cannot evaluate flag '".concat(e,"': no evaluation function found."));return this.flagRegistry[e].evaluationFn()}setFlags(e){this.flags=Object.assign({},e)}reset(){this.flags={},this.urlFlags={},this.populateURLFlags()}populateURLFlags(){if("undefined"===typeof this.global||"undefined"===typeof this.global.location||"undefined"===typeof this.global.location.search)return;const e=this.getQueryParams(this.global.location.search);if(zo in e){e[zo].split(",").forEach((e=>{const[t,n]=e.split(":");this.urlFlags[t]=function(e,t){const n=t.toLowerCase();return"true"===n||"false"===n?"true"===n:"".concat(+n)===n?+n:t}(0,n)}))}}}function Wo(e){const t={};return e.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g,(function(e){for(var n=arguments.length,a=new Array(n>1?n-1:0),r=1;r<n;r++)a[r-1]=arguments[r];return function(e,t,n){e[decodeURIComponent(t)]=decodeURIComponent(n||"")}(t,a[0],a[1]),a.join("=")})),t}function Vo(){return Go}let Uo,Go=null;function Ho(){if(null==Uo){let e;if("undefined"!==typeof window)e=window;else if("undefined"!==typeof n.g)e=n.g;else if("undefined"!==typeof process)e=process;else{if("undefined"===typeof self)throw new Error("Could not find a global object");e=self}Uo=e}return Uo}function jo(e,t){const n=function(){const e=Ho();return null==e._tfGlobals&&(e._tfGlobals=new Map),e._tfGlobals}();if(n.has(e))return n.get(e);{const a=t();return n.set(e,a),n.get(e)}}const Ko="Abs",qo="Acos",Xo="Acosh",Yo="Add",Qo="AddN",Jo="All",Zo="Any",$o="ArgMax",es="ArgMin",ts="Asin",ns="Asinh",as="Atan",rs="Atanh",os="Atan2",ss="AvgPool",is="AvgPoolGrad",cs="AvgPool3D",ls="AvgPool3DGrad",us="BatchMatMul",ds="BatchToSpaceND",hs="Bincount",ps="BitwiseAnd",fs="BroadcastArgs",ms="Cast",gs="Ceil",bs="ClipByValue",ys="Complex",xs="ComplexAbs",vs="Concat",ws="Conv2D",ks="Conv2DBackpropFilter",Is="Conv2DBackpropInput",Ss="Conv3D",Ns="Conv3DBackpropFilterV2",Cs="Conv3DBackpropInputV2",Ts="Cos",Es="Cosh",Rs="Cumprod",_s="Cumsum",As="CropAndResize",Fs="DenseBincount",Os="DepthToSpace",Ds="DepthwiseConv2dNative",Ms="DepthwiseConv2dNativeBackpropFilter",Ls="DepthwiseConv2dNativeBackpropInput",Ps="Diag",zs="Dilation2D",Bs="Dilation2DBackpropInput",Ws="Dilation2DBackpropFilter",Vs="Draw",Us="RealDiv",Gs="Einsum",Hs="Elu",js="EluGrad",Ks="Erf",qs="Equal",Xs="Exp",Ys="ExpandDims",Qs="Expm1",Js="FFT",Zs="Fill",$s="FlipLeftRight",ei="Floor",ti="FloorDiv",ni="FusedBatchNorm",ai="GatherV2",ri="GatherNd",oi="Greater",si="GreaterEqual",ii="Identity",ci="IFFT",li="Imag",ui="IsFinite",di="IsInf",hi="IsNan",pi="LeakyRelu",fi="Less",mi="LessEqual",gi="LinSpace",bi="Log",yi="Log1p",xi="LogicalAnd",vi="LogicalNot",wi="LogicalOr",ki="LRN",Ii="LRNGrad",Si="Max",Ni="Maximum",Ci="MaxPool",Ti="MaxPoolGrad",Ei="MaxPool3D",Ri="MaxPool3DGrad",_i="MaxPoolWithArgmax",Ai="Mean",Fi="Min",Oi="Minimum",Di="MirrorPad",Mi="Mod",Li="Multinomial",Pi="Multiply",zi="Neg",Bi="NotEqual",Wi="NonMaxSuppressionV3",Vi="NonMaxSuppressionV4",Ui="NonMaxSuppressionV5",Gi="OnesLike",Hi="OneHot",ji="Pack",Ki="PadV2",qi="Pow",Xi="Prelu",Yi="Prod",Qi="RaggedGather",Ji="RaggedRange",Zi="RaggedTensorToTensor",$i="Range",ec="Real",tc="Reciprocal",nc="Relu",ac="Reshape",rc="ResizeNearestNeighbor",oc="ResizeNearestNeighborGrad",sc="ResizeBilinear",ic="ResizeBilinearGrad",cc="Relu6",lc="Reverse",uc="Round",dc="Rsqrt",hc="ScatterNd",pc="TensorScatterUpdate",fc="SearchSorted",mc="Select",gc="Selu",bc="Slice",yc="Sin",xc="Sinh",vc="Sign",wc="Sigmoid",kc="Softplus",Ic="Sqrt",Sc="Sum",Nc="SpaceToBatchND",Cc="SplitV",Tc="Softmax",Ec="SparseFillEmptyRows",Rc="SparseReshape",_c="SparseSegmentMean",Ac="SparseSegmentSum",Fc="SparseToDense",Oc="SquaredDifference",Dc="Square",Mc="StaticRegexReplace",Lc="StridedSlice",Pc="StringNGrams",zc="StringSplit",Bc="StringToHashBucketFast",Wc="Sub",Vc="Tan",Uc="Tanh",Gc="Tile",Hc="TopK",jc="Transform",Kc="Transpose",qc="Unique",Xc="Unpack",Yc="UnsortedSegmentSum",Qc="ZerosLike",Jc="Step",Zc="FromPixels",$c="RotateWithOffset",el="_FusedMatMul",tl="FusedConv2D",nl="FusedDepthwiseConv2D";function al(){Vo().getBool("IS_TEST")||Vo().getBool("PROD")||console.warn(...arguments)}function rl(){Vo().getBool("IS_TEST")||Vo().getBool("PROD")||console.log(...arguments)}const ol=jo("kernelRegistry",(()=>new Map)),sl=jo("gradRegistry",(()=>new Map));function il(e,t){const n=hl(e,t);return ol.get(n)}function cl(e){return sl.get(e)}function ll(e){const t=ol.entries(),n=[];for(;;){const{done:a,value:r}=t.next();if(a)break;const[o,s]=r,[i]=o.split("_");i===e&&n.push(s)}return n}function ul(e){const{kernelName:t,backendName:n}=e,a=hl(t,n);ol.has(a)&&al("The kernel '".concat(t,"' for backend ")+"'".concat(n,"' is already registered")),ol.set(a,e)}function dl(e){const{kernelName:t}=e;sl.has(t)&&Vo().getBool("DEBUG")&&al("Overriding the gradient for '".concat(t,"'")),sl.set(t,e)}function hl(e,t){return"".concat(t,"_").concat(e)}function pl(e){return e instanceof Float32Array||e instanceof Int32Array||e instanceof Uint8Array||e instanceof Uint8ClampedArray}var fl=n(353),ml=n.n(fl);const gl=ml()||fl;function bl(e){return gl.fromString(e,!0,16)}const yl=bl("c3a5c85c97cb3127"),xl=bl("b492b66fbe98f273"),vl=bl("9ae16a3b2f90404f");function wl(e){return e.xor(e.shru(47))}function kl(e,t,n){const a=e.slice(t,t+n);return gl.fromBytes(Array.from(a),!0,!0)}function Il(e,t){return kl(e,t,8)}function Sl(e,t){return kl(e,t,4)}function Nl(e,t){return 0===t?e:e.shru(t).or(e.shl(64-t))}function Cl(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:bl("9ddfea08eb382d69"),a=e.xor(t).mul(n);a=a.xor(a.shru(47));let r=t.xor(a).mul(n);return r=r.xor(r.shru(47)),r=r.mul(n),r}function Tl(e,t,n,a){return function(e,t,n,a,r,o){r=r.add(e),o=Nl(o.add(r).add(a),21);const s=r;return r=(r=r.add(t)).add(n),o=o.add(Nl(r,44)),[r.add(a),o.add(s)]}(Il(e,t),Il(e,t+8),Il(e,t+16),Il(e,t+24),n,a)}function El(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:e.length;const n=gl.fromNumber(81,!0);if(t<=32)return t<=16?function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:e.length;if(t>=8){const n=vl.add(2*t),a=Il(e,0).add(vl),r=Il(e,t-8);return Cl(Nl(r,37).mul(n).add(a),Nl(a,25).add(r).mul(n),n)}if(t>=4){const n=vl.add(2*t);return Cl(Sl(e,0).shl(3).add(t),Sl(e,t-4),n)}if(t>0){const n=e[0]+(e[t>>1]<<8),a=t+(e[t-1]<<2);return wl(vl.mul(n).xor(yl.mul(a))).mul(vl)}return vl}(e,t):function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:e.length;const n=vl.add(2*t),a=Il(e,0).mul(xl),r=Il(e,8),o=Il(e,t-8).mul(n),s=Il(e,t-16).mul(vl);return Cl(Nl(a.add(r),43).add(Nl(o,30)).add(s),a.add(Nl(r.add(vl),18)).add(o),n)}(e,t);if(t<=64)return function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:e.length;const n=vl.add(2*t),a=Il(e,0).mul(vl),r=Il(e,8),o=Il(e,t-8).mul(n),s=Il(e,t-16).mul(vl),i=Nl(a.add(r),43).add(Nl(o,30)).add(s),c=Cl(i,a.add(Nl(r.add(vl),18)).add(o),n),l=Il(e,16).mul(n),u=Il(e,24),d=i.add(Il(e,t-32)).mul(n),h=c.add(Il(e,t-24)).mul(n);return Cl(Nl(l.add(u),43).add(Nl(d,30)).add(h),l.add(Nl(u.add(a),18)).add(d),n)}(e,t);let a=n,r=n.mul(xl).add(113),o=wl(r.mul(vl).add(113)).mul(vl),s=[gl.UZERO,gl.UZERO],i=[gl.UZERO,gl.UZERO];a=a.mul(vl).add(Il(e,0));let c=0;const l=64*(t-1>>6),u=l+(t-1&63)-63;do{a=Nl(a.add(r).add(s[0]).add(Il(e,c+8)),37).mul(xl),r=Nl(r.add(s[1]).add(Il(e,c+48)),42).mul(xl),a=a.xor(i[1]),r=r.add(s[0]).add(Il(e,c+40)),o=Nl(o.add(i[0]),33).mul(xl),s=Tl(e,c,s[1].mul(xl),a.add(i[0])),i=Tl(e,c+32,o.add(i[1]),r.add(Il(e,c+16))),[o,a]=[a,o],c+=64}while(c!==l);const d=xl.add(o.and(255).shl(1));return c=u,i[0]=i[0].add(t-1&63),s[0]=s[0].add(i[0]),i[0]=i[0].add(s[0]),a=Nl(a.add(r).add(s[0]).add(Il(e,c+8)),37).mul(d),r=Nl(r.add(s[1]).add(Il(e,c+48)),42).mul(d),a=a.xor(i[1].mul(9)),r=r.add(s[0].mul(9).add(Il(e,c+40))),o=Nl(o.add(i[0]),33).mul(d),s=Tl(e,c,s[1].mul(d),a.add(i[0])),i=Tl(e,c+32,o.add(i[1]),r.add(Il(e,c+16))),[o,a]=[a,o],Cl(Cl(s[0],i[0],d).add(wl(r).mul(yl)).add(o),Cl(s[1],i[1],d).add(a),d)}function Rl(e,t){return"string"===t?Fl(e):_l([e],t)}function _l(e,t){if("string"===t)throw new Error("Cannot convert a string[] to a TypedArray");if(Array.isArray(e)&&(e=Ml(e)),Vo().getBool("DEBUG")&&function(e,t){for(let n=0;n<e.length;n++){const a=e[n];if(isNaN(a)||!isFinite(a))throw Error("A tensor of type ".concat(t," being uploaded contains ").concat(a,"."))}}(e,t),function(e,t){return e instanceof Float32Array&&"float32"===t||e instanceof Int32Array&&"int32"===t||e instanceof Uint8Array&&"bool"===t}(e,t))return e;if(null==t||"float32"===t||"complex64"===t)return new Float32Array(e);if("int32"===t)return new Int32Array(e);if("bool"===t){const t=new Uint8Array(e.length);for(let n=0;n<t.length;++n)0!==Math.round(e[n])&&(t[n]=1);return t}throw new Error("Unknown data type ".concat(t))}function Al(){return Vo().platform.now()}function Fl(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"utf-8";return t=t||"utf-8",Vo().platform.encode(e,t)}function Ol(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"utf-8";return t=t||"utf-8",Vo().platform.decode(e,t)}function Dl(e){return null!=Vo().platform.isTypedArray?Vo().platform.isTypedArray(e):pl(e)}function Ml(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[],n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];if(null==t&&(t=[]),"boolean"===typeof e||"number"===typeof e||"string"===typeof e||Po(e)||null==e||Dl(e)&&n)t.push(e);else if(Array.isArray(e)||Dl(e))for(let a=0;a<e.length;++a)Ml(e[a],t,n);else{let a=-1;for(const t of Object.keys(e))/^([1-9]+[0-9]*|0)$/.test(t)&&(a=Math.max(a,Number(t)));for(let r=0;r<=a;r++)Ml(e[r],t,n)}return t}class Ll{constructor(e,t){this.backendTimer=e,this.logger=t,null==t&&(this.logger=new zl)}profileKernel(e,t,n){let a;const r=()=>{a=n()};let o;const s=Al();if(this.backendTimer.timerAvailable())o=this.backendTimer.time(r);else{r();for(const e of a)e.dataSync();o=Promise.resolve({kernelMs:Al()-s})}if(Vo().getBool("CHECK_COMPUTATION_FOR_ERRORS"))for(let i=0;i<a.length;i++){const t=a[i];t.data().then((n=>{Pl(n,t.dtype,e)}))}return{kernelName:e,outputs:a,inputs:t,timeMs:o.then((e=>e.kernelMs)),extraInfo:o.then((e=>null!=e.getExtraProfileInfo?e.getExtraProfileInfo():""))}}logKernelProfile(e){const{kernelName:t,outputs:n,timeMs:a,inputs:r,extraInfo:o}=e;n.forEach((e=>{Promise.all([e.data(),a,o]).then((n=>{this.logger.logKernelProfile(t,e,n[0],n[1],r,n[2])}))}))}}function Pl(e,t,n){if("float32"!==t)return!1;for(let a=0;a<e.length;a++){const t=e[a];if(isNaN(t)||!isFinite(t))return console.warn("Found ".concat(t," in the result of '").concat(n,"'")),!0}return!1}class zl{logKernelProfile(e,t,n,a,r,o){const s="number"===typeof a?fo("".concat(a,"ms"),9):a.error,i=fo(e,25),c=t.rank,l=t.size,u=fo(t.shape.toString(),14);let d="";for(const h in r){const e=r[h];if(null!=e){const n=e.shape||t.shape,a=n.length;d+="".concat(h,": ").concat(a,"D ").concat(a>0?n:""," ")}}console.log("%c".concat(i,"\t%c").concat(s,"\t%c").concat(c,"D ").concat(u,"\t%c").concat(l,"\t%c").concat(d,"\t%c").concat(o),"font-weight:bold","color:red","color:blue","color: orange","color: green","color: steelblue")}}const Bl=20,Wl=3,Vl=7;function Ul(e,t,n,a){const r=Eo(t),o=function(e,t,n,a){const r=lo(t),o=a[a.length-1],s=new Array(o).fill(0),i=t.length,c="complex64"===n?Kl(e):e;if(i>1)for(let l=0;l<r/o;l++){const e=l*o;for(let t=0;t<o;t++)s[t]=Math.max(s[t],Gl(c[e+t],0,n).length)}return s}(e,t,n,r),s=t.length,i=jl(e,t,n,r,o),c=["Tensor"];return a&&(c.push("  dtype: ".concat(n)),c.push("  rank: ".concat(s)),c.push("  shape: [".concat(t,"]")),c.push("  values:")),c.push(i.map((e=>"    "+e)).join("\n")),c.join("\n")}function Gl(e,t,n){let a;return a=Array.isArray(e)?"".concat(parseFloat(e[0].toFixed(Vl))," + ")+"".concat(parseFloat(e[1].toFixed(Vl)),"j"):Io(e)?"'".concat(e,"'"):"bool"===n?Hl(e):parseFloat(e.toFixed(Vl)).toString(),fo(a,t)}function Hl(e){return 0===e?"false":"true"}function jl(e,t,n,a,r){let o=!(arguments.length>5&&void 0!==arguments[5])||arguments[5];const s="complex64"===n?2:1,i=t[0],c=t.length;if(0===c){if("complex64"===n){return[Gl(Kl(e)[0],0,n)]}return"bool"===n?[Hl(e[0])]:[e[0].toString()]}if(1===c){if(i>Bl){const t=Wl*s;let a=Array.from(e.slice(0,t)),o=Array.from(e.slice((i-Wl)*s,i*s));return"complex64"===n&&(a=Kl(a),o=Kl(o)),["["+a.map(((e,t)=>Gl(e,r[t],n))).join(", ")+", ..., "+o.map(((e,t)=>Gl(e,r[i-Wl+t],n))).join(", ")+"]"]}return["["+("complex64"===n?Kl(e):Array.from(e)).map(((e,t)=>Gl(e,r[t],n))).join(", ")+"]"]}const l=t.slice(1),u=a.slice(1),d=a[0]*s,h=[];if(i>Bl){for(let t=0;t<Wl;t++){const a=t*d,o=a+d;h.push(...jl(e.slice(a,o),l,n,u,r,!1))}h.push("...");for(let t=i-Wl;t<i;t++){const a=t*d,o=a+d;h.push(...jl(e.slice(a,o),l,n,u,r,t===i-1))}}else for(let m=0;m<i;m++){const t=m*d,a=t+d;h.push(...jl(e.slice(t,a),l,n,u,r,m===i-1))}const p=2===c?",":"";h[0]="["+(i>0?h[0]+p:"");for(let m=1;m<h.length-1;m++)h[m]=" "+h[m]+p;let f=",\n";for(let m=2;m<c;m++)f+="\n";return h[h.length-1]=" "+h[h.length-1]+"]"+(o?"":f),h}function Kl(e){const t=[];for(let n=0;n<e.length;n+=2)t.push([e[n],e[n+1]]);return t}class ql{constructor(e,t,n){if(this.dtype=t,this.shape=e.slice(),this.size=lo(e),null!=n){const e=n.length;so(e===this.size,(()=>"Length of values '".concat(e,"' does not match the size ")+"inferred by the shape '".concat(this.size,"'.")))}if("complex64"===t)throw new Error("complex64 dtype TensorBuffers are not supported. Please create a TensorBuffer for the real and imaginary parts separately and call tf.complex(real, imag).");this.values=n||vo(t,this.size),this.strides=Eo(e)}set(e){for(var t=arguments.length,n=new Array(t>1?t-1:0),a=1;a<t;a++)n[a-1]=arguments[a];0===n.length&&(n=[0]),so(n.length===this.rank,(()=>"The number of provided coordinates (".concat(n.length,") must ")+"match the rank (".concat(this.rank,")")));const r=this.locToIndex(n);this.values[r]=e}get(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];0===t.length&&(t=[0]);let a=0;for(const o of t){if(o<0||o>=this.shape[a]){const e="Requested out of range element at ".concat(t,". ")+"  Buffer shape=".concat(this.shape);throw new Error(e)}a++}let r=t[t.length-1];for(let o=0;o<t.length-1;++o)r+=this.strides[o]*t[o];return this.values[r]}locToIndex(e){if(0===this.rank)return 0;if(1===this.rank)return e[0];let t=e[e.length-1];for(let n=0;n<e.length-1;++n)t+=this.strides[n]*e[n];return t}indexToLoc(e){if(0===this.rank)return[];if(1===this.rank)return[e];const t=new Array(this.shape.length);for(let n=0;n<t.length-1;++n)t[n]=Math.floor(e/this.strides[n]),e-=t[n]*this.strides[n];return t[t.length-1]=e,t}get rank(){return this.shape.length}toTensor(){return Xl().makeTensor(this.values,this.shape,this.dtype)}}let Xl=null,Yl=null,Ql=null;class Jl{constructor(e,t,n,a){this.kept=!1,this.isDisposedInternal=!1,this.shape=e.slice(),this.dtype=t||"float32",this.size=lo(e),this.strides=Eo(e),this.dataId=n,this.id=a,this.rankType=this.rank<5?this.rank.toString():"higher"}get rank(){return this.shape.length}async buffer(){const e=await this.data();return Yl.buffer(this.shape,this.dtype,e)}bufferSync(){return Yl.buffer(this.shape,this.dtype,this.dataSync())}async array(){const e=await this.data();return _o(this.shape,e,"complex64"===this.dtype)}arraySync(){return _o(this.shape,this.dataSync(),"complex64"===this.dtype)}async data(){this.throwIfDisposed();const e=Xl().read(this.dataId);if("string"===this.dtype){const n=await e;try{return n.map((e=>Ol(e)))}catch(t){throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}}return e}dataToGPU(e){return this.throwIfDisposed(),Xl().readToGPU(this.dataId,e)}dataSync(){this.throwIfDisposed();const e=Xl().readSync(this.dataId);if("string"===this.dtype)try{return e.map((e=>Ol(e)))}catch(t){throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}return e}async bytes(){this.throwIfDisposed();const e=await Xl().read(this.dataId);return"string"===this.dtype?e:new Uint8Array(e.buffer)}dispose(){this.isDisposed||(this.kerasMask&&this.kerasMask.dispose(),Xl().disposeTensor(this),this.isDisposedInternal=!0)}get isDisposed(){return this.isDisposedInternal}throwIfDisposed(){if(this.isDisposed)throw new Error("Tensor is disposed.")}print(){let e=arguments.length>0&&void 0!==arguments[0]&&arguments[0];return Yl.print(this,e)}clone(){return this.throwIfDisposed(),Yl.clone(this)}toString(){let e=arguments.length>0&&void 0!==arguments[0]&&arguments[0];return Ul(this.dataSync(),this.shape,this.dtype,e)}cast(e){return this.throwIfDisposed(),Yl.cast(this,e)}variable(){let e=!(arguments.length>0&&void 0!==arguments[0])||arguments[0],t=arguments.length>1?arguments[1]:void 0,n=arguments.length>2?arguments[2]:void 0;return this.throwIfDisposed(),Xl().makeVariable(this,e,t,n)}}function Zl(){return jo("Tensor",(()=>Jl))}Object.defineProperty(Jl,Symbol.hasInstance,{value:e=>!!e&&null!=e.data&&null!=e.dataSync&&null!=e.throwIfDisposed}),Zl();class $l extends Jl{constructor(e,t,n,a){super(e.shape,e.dtype,e.dataId,a),this.trainable=t,this.name=n}assign(e){if(e.dtype!==this.dtype)throw new Error("dtype of the new value (".concat(e.dtype,") and ")+"previous value (".concat(this.dtype,") must match"));if(!uo(e.shape,this.shape))throw new Error("shape of the new value (".concat(e.shape,") and ")+"previous value (".concat(this.shape,") must match"));Xl().disposeTensor(this),this.dataId=e.dataId,Xl().incRef(this,null)}dispose(){Xl().disposeVariable(this),this.isDisposedInternal=!0}}var eu,tu,nu,au,ru;Object.defineProperty($l,Symbol.hasInstance,{value:e=>e instanceof Jl&&null!=e.assign&&e.assign instanceof Function}),function(e){e.R0="R0",e.R1="R1",e.R2="R2",e.R3="R3",e.R4="R4",e.R5="R5",e.R6="R6"}(eu||(eu={})),function(e){e.float32="float32",e.int32="int32",e.bool="int32",e.complex64="complex64"}(tu||(tu={})),function(e){e.float32="float32",e.int32="int32",e.bool="bool",e.complex64="complex64"}(nu||(nu={})),function(e){e.float32="float32",e.int32="float32",e.bool="float32",e.complex64="complex64"}(au||(au={})),function(e){e.float32="complex64",e.int32="complex64",e.bool="complex64",e.complex64="complex64"}(ru||(ru={}));const ou={float32:au,int32:tu,bool:nu,complex64:ru};function su(e,t){if("string"===e||"string"===t){if("string"===e&&"string"===t)return"string";throw new Error("Can not upcast ".concat(e," with ").concat(t))}return ou[e][t]}function iu(e){return su(e,"int32")}function cu(e){return null!=e&&"object"===typeof e&&"texture"in e&&e.texture instanceof WebGLTexture}function lu(e){return"undefined"!==typeof GPUBuffer&&null!=e&&"object"===typeof e&&"buffer"in e&&e.buffer instanceof GPUBuffer}function uu(e,t){if(e.dtype===t.dtype)return[e,t];const n=su(e.dtype,t.dtype);return[e.cast(n),t.cast(n)]}function du(e,t){return t.some((t=>t.id===e.id))}function hu(e){const t=[];return pu(e,t,new Set),t}function pu(e,t,n){if(null==e)return;if(e instanceof Jl)return void t.push(e);if(a=e,!Array.isArray(a)&&"object"!==typeof a)return;var a;const r=e;for(const o in r){const e=r[o];n.has(e)||(n.add(e),pu(e,t,n))}}function fu(e){return null!=e.kernelName}class mu{constructor(){this.registeredVariables={},this.nextTapeNodeId=0,this.numBytes=0,this.numTensors=0,this.numStringTensors=0,this.numDataBuffers=0,this.gradientDepth=0,this.kernelDepth=0,this.scopeStack=[],this.numDataMovesStack=[],this.nextScopeId=0,this.tensorInfo=new WeakMap,this.profiling=!1,this.activeProfile={newBytes:0,newTensors:0,peakBytes:0,kernels:[],result:null,get kernelNames(){return Array.from(new Set(this.kernels.map((e=>e.name))))}}}dispose(){for(const e in this.registeredVariables)this.registeredVariables[e].dispose()}}class gu{constructor(e){this.ENV=e,this.registry={},this.registryFactory={},this.pendingBackendInitId=0,this.state=new mu}async ready(){if(null!=this.pendingBackendInit)return this.pendingBackendInit.then((()=>{}));if(null!=this.backendInstance)return;const e=this.getSortedBackends();for(let t=0;t<e.length;t++){const n=e[t];if(await this.initializeBackend(n).success)return void await this.setBackend(n)}throw new Error("Could not initialize any backends, all backend initializations failed.")}get backend(){if(null!=this.pendingBackendInit)throw new Error("Backend '".concat(this.backendName,"' has not yet been initialized. Make ")+"sure to await tf.ready() or await tf.setBackend() before calling other methods");if(null==this.backendInstance){const{name:e,asyncInit:t}=this.initializeBackendsAndReturnBest();if(t)throw new Error("The highest priority backend '".concat(e,"' has not yet been ")+"initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods");this.setBackend(e)}return this.backendInstance}backendNames(){return Object.keys(this.registryFactory)}findBackend(e){if(!(e in this.registry)){if(!(e in this.registryFactory))return null;{const{asyncInit:t}=this.initializeBackend(e);if(t)return null}}return this.registry[e]}findBackendFactory(e){return e in this.registryFactory?this.registryFactory[e].factory:null}registerBackend(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1;return e in this.registryFactory?(al("".concat(e," backend was already registered. ")+"Reusing existing backend factory."),!1):(this.registryFactory[e]={factory:t,priority:n},!0)}async setBackend(e){if(null==this.registryFactory[e])throw new Error("Backend name '".concat(e,"' not found in registry"));if(this.backendName=e,null==this.registry[e]){this.backendInstance=null;const{success:t,asyncInit:n}=this.initializeBackend(e);if(!(n?await t:t))return!1}return this.backendInstance=this.registry[e],this.setupRegisteredKernels(),this.profiler=new Ll(this.backendInstance),!0}setupRegisteredKernels(){ll(this.backendName).forEach((e=>{null!=e.setupFunc&&e.setupFunc(this.backendInstance)}))}disposeRegisteredKernels(e){ll(e).forEach((t=>{null!=t.disposeFunc&&t.disposeFunc(this.registry[e])}))}initializeBackend(e){const t=this.registryFactory[e];if(null==t)throw new Error("Cannot initialize backend ".concat(e,", no registration found."));try{const n=t.factory();if(!n||n instanceof eo||"function"!==typeof n.then)return this.registry[e]=n,{success:!0,asyncInit:!1};{const t=++this.pendingBackendInitId,a=n.then((n=>!(t<this.pendingBackendInitId)&&(this.registry[e]=n,this.pendingBackendInit=null,!0))).catch((n=>(t<this.pendingBackendInitId||(this.pendingBackendInit=null,al("Initialization of backend ".concat(e," failed")),al(n.stack||n.message)),!1)));return this.pendingBackendInit=a,{success:a,asyncInit:!0}}}catch(n){return al("Initialization of backend ".concat(e," failed")),al(n.stack||n.message),{success:!1,asyncInit:!1}}}removeBackend(e){if(!(e in this.registryFactory))throw new Error("".concat(e," backend not found in registry"));this.backendName===e&&null!=this.pendingBackendInit&&this.pendingBackendInitId++,e in this.registry&&(this.disposeRegisteredKernels(e),this.registry[e].dispose(),delete this.registry[e]),delete this.registryFactory[e],this.backendName===e&&(this.pendingBackendInit=null,this.backendName=null,this.backendInstance=null)}getSortedBackends(){if(0===Object.keys(this.registryFactory).length)throw new Error("No backend found in registry.");return Object.keys(this.registryFactory).sort(((e,t)=>this.registryFactory[t].priority-this.registryFactory[e].priority))}initializeBackendsAndReturnBest(){const e=this.getSortedBackends();for(let t=0;t<e.length;t++){const n=e[t],{success:a,asyncInit:r}=this.initializeBackend(n);if(r||a)return{name:n,asyncInit:r}}throw new Error("Could not initialize any backends, all backend initializations failed.")}moveData(e,t){const n=this.state.tensorInfo.get(t),a=n.backend,r=this.readSync(t),o=a.refCount(t);a.disposeData(t,!0),n.backend=e,e.move(t,r,n.shape,n.dtype,o),this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack[this.state.numDataMovesStack.length-1]++}tidy(e,t){let n,a=null;if(null==t){if("function"!==typeof e)throw new Error("Please provide a function to tidy()");t=e}else{if("string"!==typeof e&&!(e instanceof String))throw new Error("When calling with two arguments, the first argument to tidy() must be a string");if("function"!==typeof t)throw new Error("When calling with two arguments, the 2nd argument to tidy() must be a function");a=e}return this.scopedRun((()=>this.startScope(a)),(()=>this.endScope(n)),(()=>(n=t(),n instanceof Promise&&console.error("Cannot return a Promise inside of tidy."),n)))}scopedRun(e,t,n){e();try{const e=n();return t(),e}catch(a){throw t(),a}}nextTensorId(){return gu.nextTensorId++}nextVariableId(){return gu.nextVariableId++}clone(e){const t=yu.runKernel(ii,{x:e}),n={x:e};return this.addTapeNode(this.state.activeScope.name,n,[t],(e=>({x:()=>{const t={x:e},n={dtype:"float32"};return yu.runKernel(ms,t,n)}})),[],{}),t}runKernel(e,t,n){null==this.backendName&&this.backend;if(!(null!=il(e,this.backendName)))throw new Error("Kernel '".concat(e,"' not registered for backend '").concat(this.backendName,"'"));return this.runKernelFunc({kernelName:e,inputs:t,attrs:n})}shouldCheckForMemLeaks(){return this.ENV.getBool("IS_TEST")}checkKernelForMemLeak(e,t,n){const a=this.backend.numDataIds();let r=0;n.forEach((e=>{r+="complex64"===e.dtype?3:1}));const o=this.state.numDataMovesStack[this.state.numDataMovesStack.length-1],s=a-t-r-o;if(s>0)throw new Error("Backend '".concat(this.backendName,"' has an internal memory leak ")+"(".concat(s," data ids) after running '").concat(e,"'"))}runKernelFunc(e){let t,n=[];const a=this.isTapeOn(),r=this.state.numBytes,o=this.state.numTensors;let s,i;this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack.push(0),null==this.backendName&&this.backend;const c=fu(e)?e.kernelName:null!=this.state.activeScope?this.state.activeScope.name:"";if(fu(e)){const{kernelName:t,inputs:r,attrs:o}=e;null==this.backendName&&this.backend;const c=il(t,this.backendName);so(null!=c,(()=>"Cannot find registered kernel '".concat(t,"' for backend '").concat(this.backendName,"'"))),s=()=>{const e=this.backend.numDataIds();i=c.kernelFunc({inputs:r,attrs:o,backend:this.backend});const s=Array.isArray(i)?i:[i];this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(t,e,s);const l=s.map((e=>null!=e.rank?e:this.makeTensorFromTensorInfo(e)));if(a){const e=this.getTensorsForGradient(t,r,l);n=this.saveTensorsForBackwardMode(e)}return l}}else{const{forwardFunc:t}=e,r=e=>{a&&(n=e.map((e=>this.keep(this.clone(e)))))};s=()=>{const e=this.backend.numDataIds();i=this.tidy((()=>t(this.backend,r)));const n=Array.isArray(i)?i:[i];return this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(c,e,n),n}}const{inputs:l,attrs:u}=e,d=fu(e)?null:e.backwardsFunc;let h;return this.scopedRun((()=>this.state.kernelDepth++),(()=>this.state.kernelDepth--),(()=>{this.ENV.getBool("DEBUG")||this.state.profiling?(h=this.profiler.profileKernel(c,l,(()=>s())),this.ENV.getBool("DEBUG")&&this.profiler.logKernelProfile(h),t=h.outputs):t=s()})),a&&this.addTapeNode(c,l,t,d,n,u),this.state.profiling&&this.state.activeProfile.kernels.push({name:c,bytesAdded:this.state.numBytes-r,totalBytesSnapshot:this.state.numBytes,tensorsAdded:this.state.numTensors-o,totalTensorsSnapshot:this.state.numTensors,inputShapes:Object.keys(l).map((e=>null!=l[e]?l[e].shape:null)),outputShapes:t.map((e=>e.shape)),kernelTimeMs:h.timeMs,extraInfo:h.extraInfo}),Array.isArray(i)?t:t[0]}saveTensorsForBackwardMode(e){return e.map((e=>this.keep(this.clone(e))))}getTensorsForGradient(e,t,n){const a=cl(e);if(null!=a){const e=a.inputsToSave||[],r=a.outputsToSave||[];let o;a.saveAllInputs?(so(Array.isArray(t),(()=>"saveAllInputs is true, expected inputs to be an array.")),o=Object.keys(t).map((e=>t[e]))):o=e.map((e=>t[e]));const s=n.filter(((e,t)=>r[t]));return o.concat(s)}return[]}makeTensor(e,t,n,a){if(null==e)throw new Error("Values passed to engine.makeTensor() are null");n=n||"float32",a=a||this.backend;let r=e;"string"===n&&Io(e[0])&&(r=e.map((e=>Fl(e))));const o=a.write(r,t,n),s=new Jl(t,n,o,this.nextTensorId());if(this.trackTensor(s,a),"string"===n){const e=this.state.tensorInfo.get(o),t=function(e){if(null==e)return 0;let t=0;return e.forEach((e=>t+=e.length)),t}(r);this.state.numBytes+=t-e.bytes,e.bytes=t}return s}makeTensorFromDataId(e,t,n,a){const r={dataId:e,shape:t,dtype:n=n||"float32"};return this.makeTensorFromTensorInfo(r,a)}makeTensorFromTensorInfo(e,t){const{dataId:n,shape:a,dtype:r}=e,o=new Jl(a,r,n,this.nextTensorId());return this.trackTensor(o,t),o}makeVariable(e){let t=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],n=arguments.length>2?arguments[2]:void 0,a=arguments.length>3?arguments[3]:void 0;n=n||this.nextVariableId().toString(),null!=a&&a!==e.dtype&&(e=e.cast(a));const r=new $l(e,t,n,this.nextTensorId());if(null!=this.state.registeredVariables[r.name])throw new Error("Variable with name ".concat(r.name," was already registered"));return this.state.registeredVariables[r.name]=r,this.incRef(r,this.backend),r}trackTensor(e,t){this.state.numTensors++,"string"===e.dtype&&this.state.numStringTensors++;let n=0;"complex64"!==e.dtype&&"string"!==e.dtype&&(n=e.size*ko(e.dtype)),this.state.numBytes+=n,this.state.tensorInfo.has(e.dataId)||(this.state.numDataBuffers++,this.state.tensorInfo.set(e.dataId,{backend:t||this.backend,dtype:e.dtype,shape:e.shape,bytes:n})),e instanceof $l||this.track(e)}incRef(e,t){this.trackTensor(e,t),this.backend.incRef(e.dataId)}removeDataId(e,t){this.state.tensorInfo.has(e)&&this.state.tensorInfo.get(e).backend===t&&(this.state.tensorInfo.delete(e),this.state.numDataBuffers--)}disposeTensor(e){if(!this.state.tensorInfo.has(e.dataId))return;const t=this.state.tensorInfo.get(e.dataId);if(this.state.numTensors--,"string"===e.dtype&&(this.state.numStringTensors--,this.state.numBytes-=t.bytes),"complex64"!==e.dtype&&"string"!==e.dtype){const t=e.size*ko(e.dtype);this.state.numBytes-=t}t.backend.disposeData(e.dataId)&&this.removeDataId(e.dataId,t.backend)}disposeVariables(){for(const e in this.state.registeredVariables){const t=this.state.registeredVariables[e];this.disposeVariable(t)}}disposeVariable(e){this.disposeTensor(e),null!=this.state.registeredVariables[e.name]&&delete this.state.registeredVariables[e.name]}memory(){const e=this.backend.memory();return e.numTensors=this.state.numTensors,e.numDataBuffers=this.state.numDataBuffers,e.numBytes=this.state.numBytes,this.state.numStringTensors>0&&(e.unreliable=!0,null==e.reasons&&(e.reasons=[]),e.reasons.push("Memory usage by string tensors is approximate (2 bytes per character)")),e}async profile(e){this.state.profiling=!0;const t=this.state.numBytes,n=this.state.numTensors;this.state.activeProfile.kernels=[],this.state.activeProfile.result=await e(),this.state.profiling=!1,this.state.activeProfile.peakBytes=Math.max(...this.state.activeProfile.kernels.map((e=>e.totalBytesSnapshot))),this.state.activeProfile.newBytes=this.state.numBytes-t,this.state.activeProfile.newTensors=this.state.numTensors-n;for(const a of this.state.activeProfile.kernels)a.kernelTimeMs=await a.kernelTimeMs,a.extraInfo=await a.extraInfo;return this.state.activeProfile}isTapeOn(){return this.state.gradientDepth>0&&0===this.state.kernelDepth}addTapeNode(e,t,n,a,r,o){const s={id:this.state.nextTapeNodeId++,kernelName:e,inputs:t,outputs:n,saved:r},i=cl(e);null!=i&&(a=i.gradFunc),null!=a&&(s.gradient=e=>(e=e.map(((e,t)=>{if(null==e){const e=n[t],a=Fo(e.size,e.dtype);return this.makeTensor(a,e.shape,e.dtype)}return e})),a(e.length>1?e:e[0],r,o))),this.state.activeTape.push(s)}keep(e){return e.kept=!0,e}startTape(){0===this.state.gradientDepth&&(this.state.activeTape=[]),this.state.gradientDepth++}endTape(){this.state.gradientDepth--}startScope(e){const t={track:[],name:"unnamed scope",id:this.state.nextScopeId++};e&&(t.name=e),this.state.scopeStack.push(t),this.state.activeScope=t}endScope(e){const t=hu(e),n=new Set(t.map((e=>e.id)));for(let r=0;r<this.state.activeScope.track.length;r++){const e=this.state.activeScope.track[r];e.kept||n.has(e.id)||e.dispose()}const a=this.state.scopeStack.pop();this.state.activeScope=0===this.state.scopeStack.length?null:this.state.scopeStack[this.state.scopeStack.length-1],t.forEach((e=>{e.kept||e.scopeId!==a.id||this.track(e)}))}gradients(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]&&arguments[3];if(so(t.length>0,(()=>"gradients() received an empty list of xs.")),null!=n&&"float32"!==n.dtype)throw new Error("dy must have 'float32' dtype, but has '".concat(n.dtype,"'"));const r=this.scopedRun((()=>this.startTape()),(()=>this.endTape()),(()=>this.tidy("forward",e)));so(r instanceof Jl,(()=>"The result y returned by f() must be a tensor."));const o=function(e,t,n){const a={},r={};for(let c=0;c<t.length;c++)a[t[c].id]=!0;for(let c=0;c<e.length;c++){const n=e[c],o=n.inputs;for(const e in o){const s=o[e];let i=!1;for(let e=0;e<t.length;e++)if(a[s.id]){n.outputs.forEach((e=>a[e.id]=!0)),i=!0,r[n.id]=!0;break}if(i)break}}const o={};o[n.id]=!0;const s={};for(let c=e.length-1;c>=0;c--){const t=e[c],n=t.inputs;for(let e=0;e<t.outputs.length;e++)if(o[t.outputs[e].id]){for(const e in n)o[n[e].id]=!0,s[t.id]=!0;break}}const i=[];for(let c=0;c<e.length;c++){const t=e[c];if(r[t.id]&&s[t.id]){const e={};for(const r in t.inputs){const n=t.inputs[r];a[n.id]&&(e[r]=n)}const n=Object.assign({},t);n.inputs=e,n.outputs=t.outputs,i.push(n)}}return i}(this.state.activeTape,t,r);if(!a&&0===o.length&&t.length>0)throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that the f you passed encloses all operations that lead from x to y.");return this.tidy("backward",(()=>{const e={};e[r.id]=null==n?function(e){const t=Ao(lo(e),"float32");return yu.makeTensor(t,e,"float32")}(r.shape):n,function(e,t,n,a){for(let r=t.length-1;r>=0;r--){const o=t[r],s=[];if(o.outputs.forEach((t=>{const n=e[t.id];null!=n?s.push(n):s.push(null)})),null==o.gradient)throw new Error("Cannot compute gradient: gradient function not found "+"for ".concat(o.kernelName,"."));const i=o.gradient(s);for(const t in o.inputs){if(!(t in i))throw new Error("Cannot backprop through input ".concat(t,". ")+"Available gradients found: ".concat(Object.keys(i),"."));const r=n((()=>i[t]()));if("float32"!==r.dtype)throw new Error("Error in gradient for op ".concat(o.kernelName,". The gradient of input ")+"".concat(t," must have 'float32' dtype, but has '").concat(r.dtype,"'"));const s=o.inputs[t];if(!uo(r.shape,s.shape))throw new Error("Error in gradient for op ".concat(o.kernelName,". The gradient of input ")+"'".concat(t,"' has shape '").concat(r.shape,"', which does not match ")+"the shape of the input '".concat(s.shape,"'"));if(null==e[s.id])e[s.id]=r;else{const t=e[s.id];e[s.id]=a(t,r),t.dispose()}}}}(e,o,(e=>this.tidy(e)),xu);const a=t.map((t=>e[t.id]));return 0===this.state.gradientDepth&&(this.state.activeTape.forEach((e=>{for(const t of e.saved)t.dispose()})),this.state.activeTape=null),{value:r,grads:a}}))}customGrad(e){var t=this;return so(Co(e),(()=>"The f passed in customGrad(f) must be a function.")),function(){for(var n=arguments.length,a=new Array(n),r=0;r<n;r++)a[r]=arguments[r];let o;so(a.every((e=>e instanceof Jl)),(()=>"The args passed in customGrad(f)(x1, x2,...) must all be tensors"));const s={};a.forEach(((e,t)=>{s[t]=e}));return t.runKernelFunc({forwardFunc:(t,n)=>(o=e(...a,n),so(o.value instanceof Jl,(()=>"The function f passed in customGrad(f) must return an object where `obj.value` is a tensor")),so(Co(o.gradFunc),(()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function.")),o.value),backwardsFunc:(e,t)=>{const n=o.gradFunc(e,t),r=Array.isArray(n)?n:[n];so(r.length===a.length,(()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns the same number of tensors as inputs passed to f(...).")),so(r.every((e=>e instanceof Jl)),(()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns a list of only tensors."));const s={};return r.forEach(((e,t)=>{s[t]=()=>e})),s},inputs:s})}}readSync(e){return this.state.tensorInfo.get(e).backend.readSync(e)}read(e){return this.state.tensorInfo.get(e).backend.read(e)}readToGPU(e,t){return this.state.tensorInfo.get(e).backend.readToGPU(e,t)}async time(e){const t=Al(),n=await this.backend.time(e);return n.wallMs=Al()-t,n}track(e){return null!=this.state.activeScope&&(e.scopeId=this.state.activeScope.id,this.state.activeScope.track.push(e)),e}get registeredVariables(){return this.state.registeredVariables}reset(){this.pendingBackendInitId++,this.state.dispose(),this.ENV.reset(),this.state=new mu;for(const e in this.registry)this.disposeRegisteredKernels(e),this.registry[e].dispose(),delete this.registry[e];this.backendName=null,this.backendInstance=null,this.pendingBackendInit=null}}function bu(){const e=Ho();if(null==e._tfengine){const t=new Bo(e);e._tfengine=new gu(t)}var t;return t=e._tfengine.ENV,Go=t,function(e){Xl=e}((()=>e._tfengine)),e._tfengine}gu.nextTensorId=0,gu.nextVariableId=0;const yu=bu();function xu(e,t){const n={a:e,b:t};return yu.runKernel(Yo,n)}let vu;function wu(e){if(void 0!==vu)return vu;if(e||"undefined"!==typeof navigator&&null!=navigator){if(e||(e=navigator),"ReactNative"===e.product)return!0;const t=e.userAgent||e.vendor||("undefined"!==typeof window?window.opera:"");if(!t){const t=e;return t.userAgentData&&t.userAgentData.mobile}return/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(t)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(t.substr(0,4))}return!1}function ku(){return"undefined"!==typeof window&&null!=window.document||"undefined"!==typeof WorkerGlobalScope}const Iu=Vo();function Su(e,t){let n=e;if(Dl(e))return"string"===t?[]:[e.length];if(cu(e)){const t=e.channels||"RGBA";return[e.height,e.width*t.length]}if(lu(e))return[e.buffer.size/(null==t?4:ko(t))];if(!Array.isArray(e))return[];const a=[];for(;Array.isArray(n)||Dl(n)&&"string"!==t;)a.push(n.length),n=n[0];return Array.isArray(e)&&Vo().getBool("TENSORLIKE_CHECK_SHAPE_CONSISTENCY")&&Nu(e,a,[]),a}function Nu(e,t,n){if(n=n||[],!Array.isArray(e)&&!Dl(e))return void so(0===t.length,(()=>"Element arr[".concat(n.join("]["),"] is a primitive, ")+"but should be an array/TypedArray of ".concat(t[0]," elements")));so(t.length>0,(()=>"Element arr[".concat(n.join("]["),"] should be a primitive, ")+"but is an array of ".concat(e.length," elements"))),so(e.length===t[0],(()=>"Element arr[".concat(n.join("]["),"] should have ").concat(t[0]," ")+"elements, but has ".concat(e.length," elements")));const a=t.slice(1);for(let r=0;r<e.length;++r)Nu(e[r],a,n.concat(r))}function Cu(e,t,n,a){if("string_or_numeric"!==e){if(null==e)throw new Error("Expected dtype cannot be null.");if("numeric"!==e&&e!==t||"numeric"===e&&"string"===t)throw new Error("Argument '".concat(n,"' passed to '").concat(a,"' must ")+"be ".concat(e," tensor, but got ").concat(t," tensor"))}}function Tu(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"numeric";if(e instanceof Zl())return Cu(a,e.dtype,t,n),e;let r=No(e);if("string"!==r&&["bool","int32","float32"].indexOf(a)>=0&&(r=a),Cu(a,r,t,n),null==e||!Dl(e)&&!Array.isArray(e)&&"number"!==typeof e&&"boolean"!==typeof e&&"string"!==typeof e){const a=null==e?"null":e.constructor.name;throw new Error("Argument '".concat(t,"' passed to '").concat(n,"' must be a ")+"Tensor or TensorLike, but got '".concat(a,"'"))}const o=Su(e,r);Dl(e)||Array.isArray(e)||(e=[e]);const s="string"!==r?_l(e,r):Ml(e,[],!0);return yu.makeTensor(s,o,r)}function Eu(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"numeric";if(!Array.isArray(e))throw new Error("Argument ".concat(t," passed to ").concat(n," must be a ")+"`Tensor[]` or `TensorLike[]`");return e.map(((e,r)=>Tu(e,"".concat(t,"[").concat(r,"]"),n,a)))}Iu.registerFlag("DEBUG",(()=>!1),(e=>{e&&console.warn("Debugging mode is ON. The output of every math call will be downloaded to CPU and checked for NaNs. This significantly impacts performance.")})),Iu.registerFlag("IS_BROWSER",(()=>ku())),Iu.registerFlag("IS_NODE",(()=>"undefined"!==typeof process&&"undefined"!==typeof process.versions&&"undefined"!==typeof process.versions.node)),Iu.registerFlag("IS_CHROME",(()=>"undefined"!==typeof navigator&&null!=navigator&&null!=navigator.userAgent&&/Chrome/.test(navigator.userAgent)&&/Google Inc/.test(navigator.vendor))),Iu.registerFlag("IS_SAFARI",(()=>"undefined"!==typeof navigator&&null!=navigator&&null!=navigator.userAgent&&/Safari/.test(navigator.userAgent)&&/Apple/.test(navigator.vendor))),Iu.registerFlag("PROD",(()=>!1)),Iu.registerFlag("TENSORLIKE_CHECK_SHAPE_CONSISTENCY",(()=>Iu.getBool("DEBUG"))),Iu.registerFlag("DEPRECATION_WARNINGS_ENABLED",(()=>!0)),Iu.registerFlag("IS_TEST",(()=>!1)),Iu.registerFlag("CHECK_COMPUTATION_FOR_ERRORS",(()=>Iu.getBool("DEBUG"))),Iu.registerFlag("WRAP_TO_IMAGEBITMAP",(()=>!1)),Iu.registerFlag("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU",(()=>!1)),Iu.registerFlag("USE_SETTIMEOUTCUSTOM",(()=>!1));function Ru(e){const t=Object.keys(e);if(1!==t.length)throw new Error("Please provide an object with a single key (operation name) mapping to a function. Got an object with "+"".concat(t.length," keys."));let n=t[0];const a=e[n];n.endsWith("_")&&(n=n.substring(0,n.length-1)),n+="__op";const r=function(){yu.startScope(n);try{const e=a(...arguments);return Po(e)&&console.error("Cannot return a Promise inside of tidy."),yu.endScope(e),e}catch(e){throw yu.endScope(null),e}};return Object.defineProperty(r,"name",{value:n,configurable:!0}),r}const _u=Ru({complex_:function(e,t){const n=Tu(e,"real","complex"),a=Tu(t,"imag","complex");io(n.shape,a.shape,"real and imag shapes, ".concat(n.shape," and ").concat(a.shape,", ")+"must match in call to tf.complex().");const r={real:n,imag:a};return yu.runKernel(ys,r)}});function Au(e,t,n,a){if(null==a)a=No(e);else if("complex64"===a)throw new Error("Cannot construct a complex64 tensor directly. Please use tf.complex(real, imag).");if(lu(e)||cu(e)){if("float32"!==a&&"int32"!==a)throw new Error("Creating tensor from GPU data only supports "+"'float32'|'int32' dtype, while the dtype is ".concat(a,"."));return yu.backend.createTensorFromGPUData(e,t||n,a)}if(!Dl(e)&&!Array.isArray(e)&&"number"!==typeof e&&"boolean"!==typeof e&&"string"!==typeof e)throw new Error("values passed to tensor(values) must be a number/boolean/string or an array of numbers/booleans/strings, or a TypedArray");if(null!=t){Do(t);const e=lo(t),a=lo(n);so(e===a,(()=>"Based on the provided shape, [".concat(t,"], the tensor should have ")+"".concat(e," values but has ").concat(a)));for(let r=0;r<n.length;++r){const e=n[r],a=r!==n.length-1||e!==lo(t.slice(r));so(n[r]===t[r]||!a,(()=>"Error creating a new Tensor. Inferred shape "+"(".concat(n,") does not match the provided ")+"shape (".concat(t,"). ")))}}return Dl(e)||Array.isArray(e)||(e=[e]),t=t||n,e="string"!==a?_l(e,a):Ml(e,[],!0),yu.makeTensor(e,t,a)}function Fu(e,t,n){return Au(e,t,Su(e,n),n)}class Ou{static join(e){return new Ou(e).slice()}constructor(e){if(this.shards=[],this.previousShardIndex=0,null==e)return;if(e instanceof Array||(e=[e]),0===(e=e.map((e=>Dl(e)?e.buffer:e))).length)return;this.bufferUniformSize=e[0].byteLength;let t=0;for(let n=0;n<e.length;n++){const a=e[n];n!==e.length-1&&a.byteLength!==this.bufferUniformSize&&(this.bufferUniformSize=void 0);const r=t+a.byteLength;this.shards.push({buffer:a,start:t,end:r}),t=r}0===this.shards.length&&(this.byteLength=0),this.byteLength=this.shards[this.shards.length-1].end}slice(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:this.byteLength;if(0===this.shards.length)return new ArrayBuffer(0);if(e=isNaN(Number(e))?0:e,t=isNaN(Number(t))?0:t,e=Math.max(0,e),t=Math.min(this.byteLength,t),t<=e)return new ArrayBuffer(0);const n=this.findShardForByte(e);if(-1===n)throw new Error("Could not find start shard for byte ".concat(e));const a=new ArrayBuffer(t-e),r=new Uint8Array(a);let o=0;for(let s=n;s<this.shards.length;s++){const n=this.shards[s],a=e+o-n.start,i=o,c=Math.min(t,n.end)-n.start,l=new Uint8Array(n.buffer,a,c-a);if(r.set(l,i),o+=l.length,t<n.end)break}return a}findShardForByte(e){if(0===this.shards.length||e<0||e>=this.byteLength)return-1;if(null!=this.bufferUniformSize)return this.previousShardIndex=Math.floor(e/this.bufferUniformSize),this.previousShardIndex;function t(t){return e<t.start?-1:e>=t.end?1:0}if(0===t(this.shards[this.previousShardIndex]))return this.previousShardIndex;const n=function(e,t){let n=0,a=e.length;for(;n<=a;){const r=Math.floor((a-n)/2)+n,o=t(e[r]);if(0===o)return r;o<0?a=r:n=r+1}return-1}(this.shards,t);return-1===n?-1:(this.previousShardIndex=n,this.previousShardIndex)}}function Du(){return yu}function Mu(){return yu.memory()}function Lu(e,t){return yu.tidy(e,t)}function Pu(e){hu(e).forEach((e=>e.dispose()))}function zu(e){return yu.keep(e)}function Bu(e){return yu.setBackend(e)}function Wu(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1;return yu.registerBackend(e,t,n)}function Vu(){return yu.backend}!function(e){Ql=e}((function(e){Vo().getBool("DEPRECATION_WARNINGS_ENABLED")&&console.warn(e+" You can disable deprecation warnings with tf.disableDeprecationWarnings().")}));const Uu=4;async function Gu(e,t){const n=[],a=[],r=Array.isArray(e)?e.map((e=>e.name)):Object.keys(e);for(let o=0;o<r.length;++o){const s=r[o],i=Array.isArray(e)?e[o].tensor:e[s];if("float32"!==i.dtype&&"int32"!==i.dtype&&"bool"!==i.dtype&&"string"!==i.dtype&&"complex64"!==i.dtype)throw new Error("Unsupported dtype in weight '".concat(s,"': ").concat(i.dtype));const c={name:s,shape:i.shape,dtype:i.dtype};if("string"===i.dtype){const e=new Promise((async e=>{const t=await i.bytes(),n=t.reduce(((e,t)=>e+t.length),0)+Uu*t.length,a=new Uint8Array(n);let r=0;for(let o=0;o<t.length;o++){const e=t[o],n=new Uint8Array(new Uint32Array([e.length]).buffer);a.set(n,r),r+=Uu,a.set(e,r),r+=e.length}e(a)}));a.push(e)}else a.push(i.data());null!=t&&(c.group=t),n.push(c)}return{data:Hu(await Promise.all(a)),specs:n}}function Hu(e){if(null===e)throw new Error("Invalid input value: ".concat(JSON.stringify(e)));let t=0;const n=[];e.forEach((e=>{if(t+=e.byteLength,n.push(e.byteLength===e.buffer.byteLength?e:new e.constructor(e)),!(e instanceof Float32Array||e instanceof Int32Array||e instanceof Uint8Array))throw new Error("Unsupported TypedArray subtype: ".concat(e.constructor.name))}));const a=new Uint8Array(t);let r=0;return n.forEach((e=>{a.set(new Uint8Array(e.buffer),r),r+=e.byteLength})),a.buffer}const ju="undefined"!==typeof Buffer&&("undefined"===typeof Blob||"undefined"===typeof atob||"undefined"===typeof btoa);function Ku(e){return ju?Buffer.byteLength(e,"utf8"):new Blob([e]).size}function qu(e,t){const n={modelTopology:e.modelTopology,format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy,weightsManifest:t};return null!=e.signature&&(n.signature=e.signature),null!=e.userDefinedMetadata&&(n.userDefinedMetadata=e.userDefinedMetadata),null!=e.modelInitializer&&(n.modelInitializer=e.modelInitializer),null!=e.initializerSignature&&(n.initializerSignature=e.initializerSignature),null!=e.trainingConfig&&(n.trainingConfig=e.trainingConfig),n}async function Xu(e,t){let n,a;return null!=e.weightsManifest&&([n,a]=await t(e.weightsManifest)),function(e,t,n){const a={modelTopology:e.modelTopology,format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy};if(null!=e.trainingConfig&&(a.trainingConfig=e.trainingConfig),null!=e.weightsManifest){if(!t)throw new Error("modelJSON has weightsManifest but weightSpecs is null");if(!n)throw new Error("modelJSON has weightsManifest but weightData is null");a.weightSpecs=t,a.weightData=n}return null!=e.signature&&(a.signature=e.signature),null!=e.userDefinedMetadata&&(a.userDefinedMetadata=e.userDefinedMetadata),null!=e.modelInitializer&&(a.modelInitializer=e.modelInitializer),null!=e.initializerSignature&&(a.initializerSignature=e.initializerSignature),a}(e,n,a)}function Yu(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("Expected JSON model topology, received ArrayBuffer.");return{dateSaved:new Date,modelTopologyType:"JSON",modelTopologyBytes:null==e.modelTopology?0:Ku(JSON.stringify(e.modelTopology)),weightSpecsBytes:null==e.weightSpecs?0:Ku(JSON.stringify(e.weightSpecs)),weightDataBytes:null==e.weightData?0:new Ou(e.weightData).byteLength}}function Qu(e){const t=[];for(const n of e)t.push(...n.weights);return t}class Ju{constructor(){this.saveRouters=[],this.loadRouters=[]}static getInstance(){return null==Ju.instance&&(Ju.instance=new Ju),Ju.instance}static registerSaveRouter(e){Ju.getInstance().saveRouters.push(e)}static registerLoadRouter(e){Ju.getInstance().loadRouters.push(e)}static getSaveHandlers(e){return Ju.getHandlers(e,"save")}static getLoadHandlers(e,t){return Ju.getHandlers(e,"load",t)}static getHandlers(e,t,n){const a=[];return("load"===t?Ju.getInstance().loadRouters:Ju.getInstance().saveRouters).forEach((t=>{const r=t(e,n);null!==r&&a.push(r)})),a}}const Zu="tensorflowjs",$u="models_store",ed="model_info_store";function td(){if(!Vo().getBool("IS_BROWSER"))throw new Error("Failed to obtain IndexedDB factory because the current environmentis not a web browser.");const e="undefined"===typeof window?self:window,t=e.indexedDB||e.mozIndexedDB||e.webkitIndexedDB||e.msIndexedDB||e.shimIndexedDB;if(null==t)throw new Error("The current browser does not appear to support IndexedDB.");return t}function nd(e){const t=e.result;t.createObjectStore($u,{keyPath:"modelPath"}),t.createObjectStore(ed,{keyPath:"modelPath"})}class ad{constructor(e){if(this.indexedDB=td(),null==e||!e)throw new Error("For IndexedDB, modelPath must not be null, undefined or empty.");this.modelPath=e}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");return this.databaseAction(this.modelPath,e)}async load(){return this.databaseAction(this.modelPath)}databaseAction(e,t){return new Promise(((e,n)=>{const a=this.indexedDB.open(Zu,1);a.onupgradeneeded=()=>nd(a),a.onsuccess=()=>{const r=a.result;if(null==t){const t=r.transaction($u,"readonly"),a=t.objectStore($u).get(this.modelPath);a.onsuccess=()=>{if(null==a.result)return r.close(),n(new Error("Cannot find model with path '".concat(this.modelPath,"' ")+"in IndexedDB."));e(a.result.modelArtifacts)},a.onerror=e=>(r.close(),n(a.error)),t.oncomplete=()=>r.close()}else{t.weightData=Ou.join(t.weightData);const a=Yu(t),s=r.transaction(ed,"readwrite");let i,c,l=s.objectStore(ed);try{i=l.put({modelPath:this.modelPath,modelArtifactsInfo:a})}catch(o){return n(o)}i.onsuccess=()=>{c=r.transaction($u,"readwrite");const i=c.objectStore($u);let u;try{u=i.put({modelPath:this.modelPath,modelArtifacts:t,modelArtifactsInfo:a})}catch(o){return n(o)}u.onsuccess=()=>e({modelArtifactsInfo:a}),u.onerror=e=>{l=s.objectStore(ed);const t=l.delete(this.modelPath);t.onsuccess=()=>(r.close(),n(u.error)),t.onerror=e=>(r.close(),n(u.error))}},i.onerror=e=>(r.close(),n(i.error)),s.oncomplete=()=>{null==c?r.close():c.oncomplete=()=>r.close()}}},a.onerror=e=>n(a.error)}))}}ad.URL_SCHEME="indexeddb://";const rd=e=>{return Vo().getBool("IS_BROWSER")&&!Array.isArray(e)&&e.startsWith(ad.URL_SCHEME)?(t=e.slice(ad.URL_SCHEME.length),new ad(t)):null;var t};Ju.registerSaveRouter(rd),Ju.registerLoadRouter(rd);class od{constructor(){this.indexedDB=td()}async listModels(){return new Promise(((e,t)=>{const n=this.indexedDB.open(Zu,1);n.onupgradeneeded=()=>nd(n),n.onsuccess=()=>{const a=n.result,r=a.transaction(ed,"readonly"),o=r.objectStore(ed).getAll();o.onsuccess=()=>{const t={};for(const e of o.result)t[e.modelPath]=e.modelArtifactsInfo;e(t)},o.onerror=e=>(a.close(),t(o.error)),r.oncomplete=()=>a.close()},n.onerror=e=>t(n.error)}))}async removeModel(e){var t;return e=(t=e).startsWith(ad.URL_SCHEME)?t.slice(ad.URL_SCHEME.length):t,new Promise(((t,n)=>{const a=this.indexedDB.open(Zu,1);a.onupgradeneeded=()=>nd(a),a.onsuccess=()=>{const r=a.result,o=r.transaction(ed,"readwrite"),s=o.objectStore(ed),i=s.get(e);let c;i.onsuccess=()=>{if(null==i.result)return r.close(),n(new Error("Cannot find model with path '".concat(e,"' ")+"in IndexedDB."));{const a=s.delete(e),o=()=>{c=r.transaction($u,"readwrite");const a=c.objectStore($u).delete(e);a.onsuccess=()=>t(i.result.modelArtifactsInfo),a.onerror=e=>n(i.error)};a.onsuccess=o,a.onerror=e=>(o(),r.close(),n(i.error))}},i.onerror=e=>(r.close(),n(i.error)),o.oncomplete=()=>{null==c?r.close():c.oncomplete=()=>r.close()}},a.onerror=e=>n(a.error)}))}}const sd="/",id="tensorflowjs_models",cd="info",ld="model_topology",ud="weight_specs",dd="weight_data",hd="model_metadata";function pd(e){return{info:[id,e,cd].join(sd),topology:[id,e,ld].join(sd),weightSpecs:[id,e,ud].join(sd),weightData:[id,e,dd].join(sd),modelMetadata:[id,e,hd].join(sd)}}function fd(e){for(const t of Object.values(e))window.localStorage.removeItem(t)}function md(e){const t=e.split(sd);if(t.length<3)throw new Error("Invalid key format: ".concat(e));return t.slice(1,t.length-1).join(sd)}class gd{constructor(e){if(!Vo().getBool("IS_BROWSER")||"undefined"===typeof window||"undefined"===typeof window.localStorage)throw new Error("The current environment does not support local storage.");if(this.LS=window.localStorage,null==e||!e)throw new Error("For local storage, modelPath must not be null, undefined or empty.");this.modelPath=e,this.keys=pd(this.modelPath)}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");{const n=JSON.stringify(e.modelTopology),a=JSON.stringify(e.weightSpecs),r=Yu(e),o=Ou.join(e.weightData);try{this.LS.setItem(this.keys.info,JSON.stringify(r)),this.LS.setItem(this.keys.topology,n),this.LS.setItem(this.keys.weightSpecs,a),this.LS.setItem(this.keys.weightData,function(e){if(ju)return Buffer.from(e).toString("base64");const t=new Uint8Array(e);let n="";for(let a=0,r=t.length;a<r;a++)n+=String.fromCharCode(t[a]);return btoa(n)}(o));const t={format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy,signature:null!=e.signature?e.signature:void 0,userDefinedMetadata:null!=e.userDefinedMetadata?e.userDefinedMetadata:void 0,modelInitializer:null!=e.modelInitializer?e.modelInitializer:void 0,initializerSignature:null!=e.initializerSignature?e.initializerSignature:void 0,trainingConfig:null!=e.trainingConfig?e.trainingConfig:void 0};return this.LS.setItem(this.keys.modelMetadata,JSON.stringify(t)),{modelArtifactsInfo:r}}catch(t){throw fd(this.keys),new Error("Failed to save model '".concat(this.modelPath,"' to local storage: ")+"size quota being exceeded is a possible cause of this failure: "+"modelTopologyBytes=".concat(r.modelTopologyBytes,", ")+"weightSpecsBytes=".concat(r.weightSpecsBytes,", ")+"weightDataBytes=".concat(r.weightDataBytes,"."))}}}async load(){const e=JSON.parse(this.LS.getItem(this.keys.info));if(null==e)throw new Error("In local storage, there is no model with name '".concat(this.modelPath,"'"));if("JSON"!==e.modelTopologyType)throw new Error("BrowserLocalStorage does not support loading non-JSON model topology yet.");const t={},n=JSON.parse(this.LS.getItem(this.keys.topology));if(null==n)throw new Error("In local storage, the topology of model '".concat(this.modelPath,"' ")+"is missing.");t.modelTopology=n;const a=JSON.parse(this.LS.getItem(this.keys.weightSpecs));if(null==a)throw new Error("In local storage, the weight specs of model '".concat(this.modelPath,"' ")+"are missing.");t.weightSpecs=a;const r=this.LS.getItem(this.keys.modelMetadata);if(null!=r){const e=JSON.parse(r);t.format=e.format,t.generatedBy=e.generatedBy,t.convertedBy=e.convertedBy,null!=e.signature&&(t.signature=e.signature),null!=e.userDefinedMetadata&&(t.userDefinedMetadata=e.userDefinedMetadata),null!=e.modelInitializer&&(t.modelInitializer=e.modelInitializer),null!=e.initializerSignature&&(t.initializerSignature=e.initializerSignature),null!=e.trainingConfig&&(t.trainingConfig=e.trainingConfig)}const o=this.LS.getItem(this.keys.weightData);if(null==o)throw new Error("In local storage, the binary weight values of model "+"'".concat(this.modelPath,"' are missing."));return t.weightData=function(e){if(ju){const t=Buffer.from(e,"base64");return t.buffer.slice(t.byteOffset,t.byteOffset+t.byteLength)}const t=atob(e),n=new Uint8Array(t.length);for(let a=0;a<t.length;++a)n.set([t.charCodeAt(a)],a);return n.buffer}(o),t}}gd.URL_SCHEME="localstorage://";const bd=e=>{return Vo().getBool("IS_BROWSER")&&!Array.isArray(e)&&e.startsWith(gd.URL_SCHEME)?(t=e.slice(gd.URL_SCHEME.length),new gd(t)):null;var t};Ju.registerSaveRouter(bd),Ju.registerLoadRouter(bd);class yd{constructor(){so(Vo().getBool("IS_BROWSER"),(()=>"Current environment is not a web browser")),so("undefined"===typeof window||"undefined"!==typeof window.localStorage,(()=>"Current browser does not appear to support localStorage")),this.LS=window.localStorage}async listModels(){const e={},t=id+sd,n=sd+cd;for(let a=0;a<this.LS.length;++a){const r=this.LS.key(a);if(r.startsWith(t)&&r.endsWith(n)){e[md(r)]=JSON.parse(this.LS.getItem(r))}}return e}async removeModel(e){var t;const n=pd(e=(t=e).startsWith(gd.URL_SCHEME)?t.slice(gd.URL_SCHEME.length):t);if(null==this.LS.getItem(n.info))throw new Error("Cannot find model at path '".concat(e,"'"));const a=JSON.parse(this.LS.getItem(n.info));return fd(n),a}}const xd="://";class vd{constructor(){this.managers={}}static getInstance(){return null==vd.instance&&(vd.instance=new vd),vd.instance}static registerManager(e,t){so(null!=e,(()=>"scheme must not be undefined or null.")),e.endsWith(xd)&&(e=e.slice(0,e.indexOf(xd))),so(e.length>0,(()=>"scheme must not be an empty string."));const n=vd.getInstance();so(null==n.managers[e],(()=>"A model store manager is already registered for scheme '".concat(e,"'."))),n.managers[e]=t}static getManager(e){const t=vd.getInstance().managers[e];if(null==t)throw new Error("Cannot find model manager for scheme '".concat(e,"'"));return t}static getSchemes(){return Object.keys(vd.getInstance().managers)}}class wd{constructor(){this.messageName="setTimeoutCustom",this.functionRefs=[],this.handledMessageCount=0,this.hasEventListener=!1}fetch(e,t){return fetch(e,t)}now(){return performance.now()}encode(e,t){if("utf-8"!==t&&"utf8"!==t)throw new Error("Browser's encoder only supports utf-8, but got ".concat(t));return null==this.textEncoder&&(this.textEncoder=new TextEncoder),this.textEncoder.encode(e)}decode(e,t){return new TextDecoder(t).decode(e)}setTimeoutCustom(e,t){"undefined"!==typeof window&&Vo().getBool("USE_SETTIMEOUTCUSTOM")?(this.functionRefs.push(e),setTimeout((()=>{window.postMessage({name:this.messageName,index:this.functionRefs.length-1},"*")}),t),this.hasEventListener||(this.hasEventListener=!0,window.addEventListener("message",(e=>{if(e.source===window&&e.data.name===this.messageName){e.stopPropagation();(0,this.functionRefs[e.data.index])(),this.handledMessageCount++,this.handledMessageCount===this.functionRefs.length&&(this.functionRefs=[],this.handledMessageCount=0)}}),!0))):setTimeout(e,t)}isTypedArray(e){return pl(e)}}if(Vo().get("IS_BROWSER")){Vo().setPlatform("browser",new wd);try{vd.registerManager(gd.URL_SCHEME,new yd)}catch(Yue){}try{vd.registerManager(ad.URL_SCHEME,new od)}catch(Yue){}}const kd=()=>n(78);let Id;class Sd{constructor(){this.util=n(905),this.textEncoder=new this.util.TextEncoder}fetch(e,t){return null!=Vo().global.fetch?Vo().global.fetch(e,t):(null==Id&&(Id=kd()),Id(e,t))}now(){const e=process.hrtime();return 1e3*e[0]+e[1]/1e6}encode(e,t){if("utf-8"!==t&&"utf8"!==t)throw new Error("Node built-in encoder only supports utf-8, but got ".concat(t));return this.textEncoder.encode(e)}decode(e,t){return 0===e.length?"":new this.util.TextDecoder(t).decode(e)}isTypedArray(e){return this.util.types.isFloat32Array(e)||this.util.types.isInt32Array(e)||this.util.types.isUint8Array(e)||this.util.types.isUint8ClampedArray(e)}}function Nd(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"float32",n=arguments.length>2?arguments[2]:void 0;return t=t||"float32",Do(e),new ql(e,t,n)}Vo().get("IS_NODE")&&!Vo().get("IS_BROWSER")&&Vo().setPlatform("node",new Sd);const Cd=Ru({cast_:function(e,t){const n=Tu(e,"x","cast");if(!function(e){return"bool"===e||"complex64"===e||"float32"===e||"int32"===e||"string"===e}(t))throw new Error("Failed to cast to unknown dtype ".concat(t));if("string"===t&&"string"!==n.dtype||"string"!==t&&"string"===n.dtype)throw new Error("Only strings can be casted to strings");const a={x:n},r={dtype:t};return yu.runKernel(ms,a,r)}});const Td=Ru({clone_:function(e){const t={x:Tu(e,"x","clone","string_or_numeric")};return yu.runKernel(ii,t)}});bu();Yl={buffer:Nd,cast:Cd,clone:Td,print:function(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];console.log(e.toString(t))}};const Ed=Ru({add_:function(e,t){let n=Tu(e,"a","add"),a=Tu(t,"b","add");[n,a]=uu(n,a);const r={a:n,b:a};return yu.runKernel(Yo,r)}});const Rd=Ru({floorDiv_:function(e,t){let n=Tu(e,"a","floorDiv"),a=Tu(t,"b","floorDiv");[n,a]=uu(n,a);const r={a:n,b:a};return yu.runKernel(ti,r)}});const _d=Ru({div_:function(e,t){let n=Tu(e,"a","div"),a=Tu(t,"b","div");if([n,a]=uu(n,a),"int32"===n.dtype&&"int32"===a.dtype)return Rd(n,a);const r={a:n,b:a};return yu.runKernel(Us,r,{})}});const Ad=Ru({mul_:function(e,t){let n=Tu(e,"a","mul"),a=Tu(t,"b","mul");[n,a]=uu(n,a);const r={a:n,b:a};return yu.runKernel(Pi,r)}});const Fd=Ru({sqrt_:function(e){const t={x:Tu(e,"x","sqrt","float32")};return yu.runKernel(Ic,t)}});const Od=Ru({square_:function(e){const t=Tu(e,"x","square");return yu.runKernel("Square",{x:t},{})}});const Dd=Ru({zerosLike_:function(e){const t={x:Tu(e,"x","zerosLike")};return yu.runKernel(Qc,t)}});function Md(e){return yu.customGrad(e)}function Ld(e,t){if((Dl(e)&&"string"!==t||Array.isArray(e))&&"complex64"!==t)throw new Error("Error creating a new Scalar: value must be a primitive (number|boolean|string)");if("string"===t&&Dl(e)&&!(e instanceof Uint8Array))throw new Error("When making a scalar from encoded string, the value must be `Uint8Array`.");return Au(e,[],[],t)}const Pd=new Map,zd=new Map;class Bd{getClassName(){return this.constructor.className}static fromConfig(e,t){return new e(t)}}class Wd{constructor(){this.classNameMap={}}static getMap(){return null==Wd.instance&&(Wd.instance=new Wd),Wd.instance}static register(e){Wd.getMap().classNameMap[e.className]=[e,e.fromConfig]}}function Vd(e,t,n){so(null!=e.className,(()=>"Class being registered does not have the static className property defined.")),so("string"===typeof e.className,(()=>"className is required to be a string, but got type "+typeof e.className)),so(e.className.length>0,(()=>"Class being registered has an empty-string as its className, which is disallowed.")),"undefined"===typeof t&&(t="Custom"),"undefined"===typeof n&&(n=e.className);const a=t+">"+n;return Wd.register(e),Pd.set(a,e),zd.set(e,a),e}class Ud extends Bd{minimize(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1],n=arguments.length>2?arguments[2]:void 0;const{value:a,grads:r}=this.computeGradients(e,n);if(null!=n){const e=n.map((e=>({name:e.name,tensor:r[e.name]})));this.applyGradients(e)}else this.applyGradients(r);return Pu(r),t?a:(a.dispose(),null)}get iterations(){return null==this.iterations_&&(this.iterations_=0),this.iterations_}incrementIterations(){this.iterations_=this.iterations+1}computeGradients(e,t){return function(e,t){so(Co(e),(()=>"The f passed in variableGrads(f) must be a function")),so(null==t||Array.isArray(t)&&t.every((e=>e instanceof $l)),(()=>"The varList passed in variableGrads(f, varList) must be an array of variables"));const n=null!=t;if(!n){t=[];for(const e in yu.registeredVariables)t.push(yu.registeredVariables[e])}const a=n?t.filter((e=>!e.trainable)):null,r=t.length;t=t.filter((e=>e.trainable)),so(t.length>0,(()=>"variableGrads() expects at least one of the input variables to "+"be trainable, but none of the ".concat(r," variables is ")+"trainable."));const{value:o,grads:s}=yu.gradients(e,t,null,!0);so(s.some((e=>null!=e)),(()=>"Cannot find a connection between any variable and the result of the loss function y=f(x). Please make sure the operations that use variables are inside the function f passed to minimize().")),so(0===o.rank,(()=>"The f passed in variableGrads(f) must return a scalar, but it "+"returned a rank-".concat(o.rank," tensor")));const i={};return t.forEach(((e,t)=>{null!=s[t]&&(i[e.name]=s[t])})),null!=a&&a.forEach((e=>i[e.name]=null)),{value:o,grads:i}}(e,t)}dispose(){null!=this.iterations_&&Pu(this.iterations_)}async saveIterations(){return null==this.iterations_&&(this.iterations_=0),{name:"iter",tensor:Ld(this.iterations_,"int32")}}async getWeights(){throw new Error("getWeights() is not implemented for this optimizer yet.")}async setWeights(e){throw new Error("setWeights() is not implemented for this optimizer class "+"".concat(this.getClassName()))}async extractIterations(e){return this.iterations_=(await e[0].tensor.data())[0],e.slice(1)}}Object.defineProperty(Ud,Symbol.hasInstance,{value:e=>null!=e.minimize&&null!=e.computeGradients&&null!=e.applyGradients});class Gd extends Ud{static get className(){return"Adadelta"}constructor(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null;super(),this.learningRate=e,this.rho=t,this.epsilon=n,this.accumulatedGrads=[],this.accumulatedUpdates=[],null==n&&(this.epsilon=yu.backend.epsilon())}applyGradients(e){(Array.isArray(e)?e.map((e=>e.name)):Object.keys(e)).forEach(((t,n)=>{const a=yu.registeredVariables[t],r=!1;null==this.accumulatedGrads[n]&&(this.accumulatedGrads[n]={originalName:"".concat(t,"/accum_grad"),variable:Lu((()=>Dd(a).variable(r)))}),null==this.accumulatedUpdates[n]&&(this.accumulatedUpdates[n]={originalName:"".concat(t,"/accum_var"),variable:Lu((()=>Dd(a).variable(r)))});const o=Array.isArray(e)?e[n].tensor:e[t];if(null==o)return;const s=this.accumulatedGrads[n].variable,i=this.accumulatedUpdates[n].variable;Lu((()=>{const e=Ed(Ad(s,this.rho),Ad(Od(o),1-this.rho)),t=Ad(_d(Fd(Ed(i,this.epsilon)),Fd(Ed(s,this.epsilon))),o),n=Ed(Ad(i,this.rho),Ad(Od(t),1-this.rho));s.assign(e),i.assign(n);const r=Ed(Ad(t,-this.learningRate),a);a.assign(r)}))})),this.incrementIterations()}dispose(){null!=this.accumulatedUpdates&&(Pu(this.accumulatedGrads.map((e=>e.variable))),Pu(this.accumulatedUpdates.map((e=>e.variable))))}async getWeights(){const e=[...this.accumulatedGrads,...this.accumulatedUpdates];return[await this.saveIterations()].concat(e.map((e=>({name:e.originalName,tensor:e.variable}))))}async setWeights(e){const t=(e=await this.extractIterations(e)).length/2,n=!1;this.accumulatedGrads=e.slice(0,t).map((e=>({originalName:e.name,variable:e.tensor.variable(n)}))),this.accumulatedUpdates=e.slice(t,2*t).map((e=>({originalName:e.name,variable:e.tensor.variable(n)})))}getConfig(){return{learningRate:this.learningRate,rho:this.rho,epsilon:this.epsilon}}static fromConfig(e,t){return new e(t.learningRate,t.rho,t.epsilon)}}function Hd(e,t,n){Do(e);const a={shape:e,value:t,dtype:n=n||No(t)};return yu.runKernel(Zs,{},a)}class jd extends Ud{static get className(){return"Adagrad"}constructor(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:.1;super(),this.learningRate=e,this.initialAccumulatorValue=t,this.accumulatedGrads=[]}applyGradients(e){(Array.isArray(e)?e.map((e=>e.name)):Object.keys(e)).forEach(((t,n)=>{const a=yu.registeredVariables[t];if(null==this.accumulatedGrads[n]){const e=!1;this.accumulatedGrads[n]={originalName:"".concat(t,"/accumulator"),variable:Lu((()=>Hd(a.shape,this.initialAccumulatorValue).variable(e)))}}const r=Array.isArray(e)?e[n].tensor:e[t];if(null==r)return;const o=this.accumulatedGrads[n].variable;Lu((()=>{const e=Ed(o,Od(r));o.assign(e);const t=Ed(Ad(_d(r,Fd(Ed(e,yu.backend.epsilon()))),-this.learningRate),a);a.assign(t)}))})),this.incrementIterations()}dispose(){null!=this.accumulatedGrads&&Pu(this.accumulatedGrads.map((e=>e.variable)))}async getWeights(){return[await this.saveIterations()].concat(this.accumulatedGrads.map((e=>({name:e.originalName,tensor:e.variable}))))}async setWeights(e){e=await this.extractIterations(e);this.accumulatedGrads=e.map((e=>({originalName:e.name,variable:e.tensor.variable(false)})))}getConfig(){return{learningRate:this.learningRate,initialAccumulatorValue:this.initialAccumulatorValue}}static fromConfig(e,t){return new e(t.learningRate,t.initialAccumulatorValue)}}const Kd=Ru({pow_:function(e,t){let n=Tu(e,"base","pow"),a=Tu(t,"exp","pow");[n,a]=uu(n,a);const r={a:n,b:a};return yu.runKernel(qi,r)}});const qd=Ru({sub_:function(e,t){let n=Tu(e,"a","sub"),a=Tu(t,"b","sub");[n,a]=uu(n,a);const r={a:n,b:a};return yu.runKernel(Wc,r)}});class Xd extends Ud{static get className(){return"Adam"}constructor(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:null;super(),this.learningRate=e,this.beta1=t,this.beta2=n,this.epsilon=a,this.accumulatedFirstMoment=[],this.accumulatedSecondMoment=[],Lu((()=>{this.accBeta1=Ld(t).variable(),this.accBeta2=Ld(n).variable()})),null==a&&(this.epsilon=yu.backend.epsilon())}applyGradients(e){const t=Array.isArray(e)?e.map((e=>e.name)):Object.keys(e);Lu((()=>{const n=qd(1,this.accBeta1),a=qd(1,this.accBeta2);t.forEach(((t,r)=>{const o=yu.registeredVariables[t],s=!1;null==this.accumulatedFirstMoment[r]&&(this.accumulatedFirstMoment[r]={originalName:"".concat(t,"/m"),variable:Lu((()=>Dd(o).variable(s)))}),null==this.accumulatedSecondMoment[r]&&(this.accumulatedSecondMoment[r]={originalName:"".concat(t,"/v"),variable:Lu((()=>Dd(o).variable(s)))});const i=Array.isArray(e)?e[r].tensor:e[t];if(null==i)return;const c=this.accumulatedFirstMoment[r].variable,l=this.accumulatedSecondMoment[r].variable,u=Ed(Ad(c,this.beta1),Ad(i,1-this.beta1)),d=Ed(Ad(l,this.beta2),Ad(Od(i),1-this.beta2)),h=_d(u,n),p=_d(d,a);c.assign(u),l.assign(d);const f=Ed(Ad(_d(h,Ed(Fd(p),this.epsilon)),-this.learningRate),o);o.assign(f)})),this.accBeta1.assign(Ad(this.accBeta1,this.beta1)),this.accBeta2.assign(Ad(this.accBeta2,this.beta2))})),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.accBeta2.dispose(),null!=this.accumulatedFirstMoment&&Pu(this.accumulatedFirstMoment.map((e=>e.variable))),null!=this.accumulatedSecondMoment&&Pu(this.accumulatedSecondMoment.map((e=>e.variable)))}async getWeights(){const e=[...this.accumulatedFirstMoment,...this.accumulatedSecondMoment];return[await this.saveIterations()].concat(e.map((e=>({name:e.originalName,tensor:e.variable}))))}async setWeights(e){e=await this.extractIterations(e),Lu((()=>{this.accBeta1.assign(Kd(this.beta1,this.iterations_+1)),this.accBeta2.assign(Kd(this.beta2,this.iterations_+1))}));const t=e.length/2,n=!1;this.accumulatedFirstMoment=e.slice(0,t).map((e=>({originalName:e.name,variable:e.tensor.variable(n)}))),this.accumulatedSecondMoment=e.slice(t,2*t).map((e=>({originalName:e.name,variable:e.tensor.variable(n)})))}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon}}static fromConfig(e,t){return new e(t.learningRate,t.beta1,t.beta2,t.epsilon)}}const Yd=Ru({abs_:function(e){const t=Tu(e,"x","abs");if("complex64"===t.dtype){const e={x:t};return yu.runKernel(xs,e)}{const e={x:t};return yu.runKernel(Ko,e)}}});function Qd(e,t){const n=e.length,a=[];for(let r=0;r<n;r++){const o=n-1-r,s=e[o]||1;(t[t.length-1-r]||1)>1&&1===s&&a.unshift(o)}return a}function Jd(e,t){const n=[];for(let a=0;a<t.length;a++){const r=e[e.length-a-1],o=t.length-a-1,s=t[o];(null==r||1===r&&s>1)&&n.unshift(o)}return n}function Zd(e,t){const n=Math.max(e.length,t.length),a=new Array(n);for(let r=0;r<n;r++){let o=e[e.length-r-1];null==o&&(o=1);let s=t[t.length-r-1];if(null==s&&(s=1),1===o)a[n-r-1]=s;else if(1===s)a[n-r-1]=o;else{if(o!==s){const n="Operands could not be broadcast together with shapes "+"".concat(e," and ").concat(t,".");throw Error(n)}a[n-r-1]=o}}return a}const $d=Ru({maximum_:function(e,t){let n=Tu(e,"a","maximum"),a=Tu(t,"b","maximum");[n,a]=uu(n,a),"bool"===n.dtype&&(n=Cd(n,"int32"),a=Cd(a,"int32")),Zd(n.shape,a.shape);const r={a:n,b:a};return yu.runKernel(Ni,r)}});class eh extends Ud{static get className(){return"Adamax"}constructor(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:null,r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:0;super(),this.learningRate=e,this.beta1=t,this.beta2=n,this.epsilon=a,this.decay=r,this.accumulatedFirstMoment=[],this.accumulatedWeightedInfNorm=[],Lu((()=>{this.iteration=Ld(0).variable(),this.accBeta1=Ld(t).variable()})),null==a&&(this.epsilon=yu.backend.epsilon())}applyGradients(e){const t=Array.isArray(e)?e.map((e=>e.name)):Object.keys(e);Lu((()=>{const n=qd(1,this.accBeta1),a=_d(-this.learningRate,Ed(Ad(this.iteration,this.decay),1));t.forEach(((t,r)=>{const o=yu.registeredVariables[t],s=!1;null==this.accumulatedFirstMoment[r]&&(this.accumulatedFirstMoment[r]={originalName:"".concat(t,"/m"),variable:Dd(o).variable(s)}),null==this.accumulatedWeightedInfNorm[r]&&(this.accumulatedWeightedInfNorm[r]={originalName:"".concat(t,"/v"),variable:Dd(o).variable(s)});const i=Array.isArray(e)?e[r].tensor:e[t];if(null==i)return;const c=this.accumulatedFirstMoment[r].variable,l=this.accumulatedWeightedInfNorm[r].variable,u=Ed(Ad(c,this.beta1),Ad(i,1-this.beta1)),d=Ad(l,this.beta2),h=Yd(i),p=$d(d,h);c.assign(u),l.assign(p);const f=Ed(Ad(_d(a,n),_d(u,Ed(p,this.epsilon))),o);o.assign(f)})),this.iteration.assign(Ed(this.iteration,1)),this.accBeta1.assign(Ad(this.accBeta1,this.beta1))})),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.iteration.dispose(),null!=this.accumulatedFirstMoment&&Pu(this.accumulatedFirstMoment.map((e=>e.variable))),null!=this.accumulatedWeightedInfNorm&&Pu(this.accumulatedWeightedInfNorm.map((e=>e.variable)))}async getWeights(){throw new Error("getWeights() is not implemented for Adamax yet.")}async setWeights(e){throw new Error("setWeights() is not implemented for Adamax yet.")}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon,decay:this.decay}}static fromConfig(e,t){return new e(t.learningRate,t.beta1,t.beta2,t.epsilon,t.decay)}}class th extends Ud{static get className(){return"SGD"}constructor(e){super(),this.learningRate=e,this.setLearningRate(e)}applyGradients(e){const t=Array.isArray(e)?e.map((e=>e.name)):Object.keys(e);t.forEach(((t,n)=>{const a=Array.isArray(e)?e[n].tensor:e[t];if(null==a)return;const r=yu.registeredVariables[t];Lu((()=>{const e=Ed(Ad(this.c,a),r);r.assign(e)}))})),this.incrementIterations()}setLearningRate(e){this.learningRate=e,null!=this.c&&this.c.dispose(),this.c=zu(Ld(-e))}dispose(){this.c.dispose()}async getWeights(){return[await this.saveIterations()]}async setWeights(e){if(0!==(e=await this.extractIterations(e)).length)throw new Error("SGD optimizer does not have settable weights.")}getConfig(){return{learningRate:this.learningRate}}static fromConfig(e,t){return new e(t.learningRate)}}class nh extends th{static get className(){return"Momentum"}constructor(e,t){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];super(e),this.learningRate=e,this.momentum=t,this.useNesterov=n,this.accumulations=[],this.m=Ld(this.momentum)}applyGradients(e){(Array.isArray(e)?e.map((e=>e.name)):Object.keys(e)).forEach(((t,n)=>{const a=yu.registeredVariables[t];if(null==this.accumulations[n]){const e=!1;this.accumulations[n]={originalName:"".concat(t,"/momentum"),variable:Lu((()=>Dd(a).variable(e)))}}const r=this.accumulations[n].variable,o=Array.isArray(e)?e[n].tensor:e[t];null!=o&&Lu((()=>{let e;const t=Ed(Ad(this.m,r),o);e=this.useNesterov?Ed(Ad(this.c,Ed(o,Ad(t,this.m))),a):Ed(Ad(this.c,t),a),r.assign(t),a.assign(e)}))})),this.incrementIterations()}dispose(){this.m.dispose(),null!=this.accumulations&&Pu(this.accumulations.map((e=>e.variable)))}setMomentum(e){this.momentum=e}async getWeights(){return[await this.saveIterations()].concat(this.accumulations.map((e=>({name:e.originalName,tensor:e.variable}))))}async setWeights(e){e=await this.extractIterations(e);this.accumulations=e.map((e=>({originalName:e.name,variable:e.tensor.variable(false)})))}getConfig(){return{learningRate:this.learningRate,momentum:this.momentum,useNesterov:this.useNesterov}}static fromConfig(e,t){return new e(t.learningRate,t.momentum,t.useNesterov)}}class ah extends Ud{static get className(){return"RMSProp"}constructor(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:.9,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:null,r=arguments.length>4&&void 0!==arguments[4]&&arguments[4];if(super(),this.learningRate=e,this.decay=t,this.momentum=n,this.epsilon=a,this.accumulatedMeanSquares=[],this.accumulatedMoments=[],this.accumulatedMeanGrads=[],this.centered=r,null==a&&(this.epsilon=yu.backend.epsilon()),null==e)throw new Error("learningRate for RMSPropOptimizer must be defined.")}applyGradients(e){(Array.isArray(e)?e.map((e=>e.name)):Object.keys(e)).forEach(((t,n)=>{const a=yu.registeredVariables[t],r=!1;null==this.accumulatedMeanSquares[n]&&(this.accumulatedMeanSquares[n]={originalName:"".concat(t,"/rms"),variable:Lu((()=>Dd(a).variable(r)))}),null==this.accumulatedMoments[n]&&(this.accumulatedMoments[n]={originalName:"".concat(t,"/momentum"),variable:Lu((()=>Dd(a).variable(r)))}),null==this.accumulatedMeanGrads[n]&&this.centered&&(this.accumulatedMeanGrads[n]={originalName:"".concat(t,"/mg"),variable:Lu((()=>Dd(a).variable(r)))});const o=Array.isArray(e)?e[n].tensor:e[t];if(null==o)return;const s=this.accumulatedMeanSquares[n].variable,i=this.accumulatedMoments[n].variable;Lu((()=>{const e=Ed(Ad(s,this.decay),Ad(Od(o),1-this.decay));if(this.centered){const t=this.accumulatedMeanGrads[n].variable,r=Ed(Ad(t,this.decay),Ad(o,1-this.decay)),c=_d(Ad(o,this.learningRate),Fd(qd(e,Ed(Od(r),this.epsilon)))),l=Ed(Ad(i,this.momentum),c);s.assign(e),t.assign(r),i.assign(l);const u=qd(a,l);a.assign(u)}else{const e=Ed(Ad(s,this.decay),Ad(Od(o),1-this.decay)),t=Ed(Ad(i,this.momentum),_d(Ad(o,this.learningRate),Fd(Ed(e,this.epsilon))));s.assign(e),i.assign(t);const n=qd(a,t);a.assign(n)}}))})),this.incrementIterations()}dispose(){null!=this.accumulatedMeanSquares&&Pu(this.accumulatedMeanSquares.map((e=>e.variable))),null!=this.accumulatedMeanGrads&&this.centered&&Pu(this.accumulatedMeanGrads.map((e=>e.variable))),null!=this.accumulatedMoments&&Pu(this.accumulatedMoments.map((e=>e.variable)))}async getWeights(){const e=[...this.accumulatedMeanSquares,...this.accumulatedMoments];return this.centered&&e.push(...this.accumulatedMeanGrads),[await this.saveIterations()].concat(e.map((e=>({name:e.originalName,tensor:e.variable}))))}async setWeights(e){e=await this.extractIterations(e);const t=this.centered?e.length/3:e.length/2,n=!1;this.accumulatedMeanSquares=e.slice(0,t).map((e=>({originalName:e.name,variable:e.tensor.variable(n)}))),this.accumulatedMoments=e.slice(t,2*t).map((e=>({originalName:e.name,variable:e.tensor.variable(n)}))),this.centered&&(this.accumulatedMeanGrads=e.slice(2*t,3*t).map((e=>({originalName:e.name,variable:e.tensor.variable(n)}))))}getConfig(){return{learningRate:this.learningRate,decay:this.decay,momentum:this.momentum,epsilon:this.epsilon,centered:this.centered}}static fromConfig(e,t){return new e(t.learningRate,t.decay,t.momentum,t.epsilon,t.centered)}}const rh=[Gd,jd,Xd,eh,nh,ah,th];function oh(e){return new Promise((e=>setTimeout(e))).then(e)}class sh{constructor(e){if(!Vo().getBool("IS_BROWSER"))throw new Error("browserDownloads() cannot proceed because the current environment is not a browser.");e.startsWith(sh.URL_SCHEME)&&(e=e.slice(sh.URL_SCHEME.length)),null!=e&&0!==e.length||(e="model"),this.modelJsonFileName=e+".json",this.weightDataFileName=e+".weights.bin"}async save(e){if("undefined"===typeof document)throw new Error("Browser downloads are not supported in this environment since `document` is not present");const t=Ou.join(e.weightData),n=window.URL.createObjectURL(new Blob([t],{type:"application/octet-stream"}));if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserDownloads.save() does not support saving model topology in binary formats yet.");{const t=qu(e,[{paths:["./"+this.weightDataFileName],weights:e.weightSpecs}]),a=window.URL.createObjectURL(new Blob([JSON.stringify(t)],{type:"application/json"})),r=null==this.modelJsonAnchor?document.createElement("a"):this.modelJsonAnchor;if(r.download=this.modelJsonFileName,r.href=a,await oh((()=>r.dispatchEvent(new MouseEvent("click")))),null!=e.weightData){const e=null==this.weightDataAnchor?document.createElement("a"):this.weightDataAnchor;e.download=this.weightDataFileName,e.href=n,await oh((()=>e.dispatchEvent(new MouseEvent("click"))))}return{modelArtifactsInfo:Yu(e)}}}}sh.URL_SCHEME="downloads://";function ih(e,t,n,a){!function(e){so(null!=e&&Array.isArray(e)&&e.length>0,(()=>"promises must be a none empty array"))}(e),function(e,t){so(e>=0&&e<=1,(()=>"Progress fraction must be in range [0, 1], but "+"got startFraction ".concat(e))),so(t>=0&&t<=1,(()=>"Progress fraction must be in range [0, 1], but "+"got endFraction ".concat(t))),so(t>=e,(()=>"startFraction must be no more than endFraction, but "+"got startFraction ".concat(e," and endFraction ")+"".concat(t)))}(n=null==n?0:n,a=null==a?1:a);let r=0;return Promise.all(e.map((o=>(o.then((o=>{const s=n+ ++r/e.length*(a-n);return t(s),o})),o))))}async function ch(e,t){null==t&&(t={});const n=null==t.fetchFunc?Vo().platform.fetch:t.fetchFunc,a=e.map((e=>n(e,t.requestInit,{isBinary:!0}))),r=(null==t.onProgress?await Promise.all(a):await ih(a,t.onProgress,0,.5)).map((e=>e.arrayBuffer()));return null==t.onProgress?await Promise.all(r):await ih(r,t.onProgress,.5,1)}Ju.registerSaveRouter((e=>Vo().getBool("IS_BROWSER")&&!Array.isArray(e)&&e.startsWith(sh.URL_SCHEME)?function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:"model";return new sh(e)}(e.slice(sh.URL_SCHEME.length)):null));class lh{constructor(e,t){if(this.DEFAULT_METHOD="POST",null==t&&(t={}),this.weightPathPrefix=t.weightPathPrefix,this.weightUrlConverter=t.weightUrlConverter,null!=t.fetchFunc?(so("function"===typeof t.fetchFunc,(()=>"Must pass a function that matches the signature of `fetch` (see https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)")),this.fetch=t.fetchFunc):this.fetch=Vo().platform.fetch,so(null!=e&&e.length>0,(()=>"URL path for http must not be null, undefined or empty.")),Array.isArray(e)&&so(2===e.length,(()=>"URL paths for http must have a length of 2, "+"(actual length is ".concat(e.length,")."))),this.path=e,null!=t.requestInit&&null!=t.requestInit.body)throw new Error("requestInit is expected to have no pre-existing body, but has one.");this.requestInit=t.requestInit||{},this.loadOptions=t}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserHTTPRequest.save() does not support saving model topology in binary formats yet.");const t=Object.assign({method:this.DEFAULT_METHOD},this.requestInit);t.body=new FormData;const n=qu(e,[{paths:["./model.weights.bin"],weights:e.weightSpecs}]);if(t.body.append("model.json",new Blob([JSON.stringify(n)],{type:"application/json"}),"model.json"),null!=e.weightData){const n=Ou.join(e.weightData);t.body.append("model.weights.bin",new Blob([n],{type:"application/octet-stream"}),"model.weights.bin")}const a=await this.fetch(this.path,t);if(a.ok)return{modelArtifactsInfo:Yu(e),responses:[a]};throw new Error("BrowserHTTPRequest.save() failed due to HTTP response status "+"".concat(a.status,"."))}async loadModelJSON(){const e=await this.fetch(this.path,this.requestInit);if(!e.ok)throw new Error("Request to ".concat(this.path," failed with status code ")+"".concat(e.status,". Please verify this URL points to ")+"the model JSON of the model to load.");let t;try{t=await e.json()}catch(D){let t="Failed to parse model JSON of response from ".concat(this.path,".");throw this.path.endsWith(".pb")?t+=" Your path contains a .pb file extension. Support for .pb models have been removed in TensorFlow.js 1.0 in favor of .json models. You can re-convert your Python TensorFlow model using the TensorFlow.js 1.0 conversion scripts or you can convert your.pb models with the 'pb2json'NPM script in the tensorflow/tfjs-converter repository.":t+=" Please make sure the server is serving valid JSON for this request.",new Error(t)}const n=t.modelTopology,a=t.weightsManifest;if(null==n&&null==a)throw new Error("The JSON from HTTP path ".concat(this.path," contains neither model ")+"topology or manifest for weights.");return t}async load(){if(this.loadOptions.streamWeights)return this.loadStream();return Xu(await this.loadModelJSON(),(e=>this.loadWeights(e)))}async loadStream(){const e=await this.loadModelJSON(),t=await this.getWeightUrls(e.weightsManifest),n=Qu(e.weightsManifest);return Object.assign(Object.assign({},e),{weightSpecs:n,getWeightStream:()=>function(e,t){var n;const a=null==t.fetchFunc?Vo().platform.fetch:t.fetchFunc;let r,o=0;return null===(n=t.onProgress)||void 0===n||n.call(t,0),new ReadableStream({pull:async n=>{for(var s;o<e.length;){if(!r){const n=(await a(e[o],t.requestInit,{isBinary:!0})).body;r=n.getReader()}const{done:i,value:c}=await r.read();if(!i)return void n.enqueue(c);o++,r=void 0,null===(s=t.onProgress)||void 0===s||s.call(t,o/e.length)}n.close()}})}(t,this.loadOptions)})}async getWeightUrls(e){const t=Array.isArray(this.path)?this.path[1]:this.path,[n,a]=function(e){const t=e.lastIndexOf("/"),n=e.lastIndexOf("?"),a=e.substring(0,t),r=n>t?e.substring(n):"";return[a+"/",r]}(t),r=this.weightPathPrefix||n,o=[],s=[];for(const i of e)for(const e of i.paths)null!=this.weightUrlConverter?s.push(this.weightUrlConverter(e)):o.push(r+e+a);return this.weightUrlConverter&&o.push(...await Promise.all(s)),o}async loadWeights(e){const t=await this.getWeightUrls(e);return[Qu(e),await ch(t,this.loadOptions)]}}function uh(e){return null!=e.match(lh.URL_SCHEME_REGEX)}lh.URL_SCHEME_REGEX=/^https?:\/\//;const dh=(e,t)=>{if("undefined"===typeof fetch&&(null==t||null==t.fetchFunc))return null;{let n=!0;if(n=Array.isArray(e)?e.every((e=>uh(e))):uh(e),n)return hh(e,t)}return null};function hh(e,t){return new lh(e,t)}Ju.registerSaveRouter(dh),Ju.registerLoadRouter(dh);const ph=-2,fh=-1;function mh(e,t,n){const a=e.shape.length;so(a===t.length,(()=>"Error in slice".concat(a,"D: Length of begin ").concat(t," must ")+"match the rank of the array (".concat(a,")."))),so(a===n.length,(()=>"Error in slice".concat(a,"D: Length of size ").concat(n," must ")+"match the rank of the array (".concat(a,").")));for(let r=0;r<a;++r)so(t[r]+n[r]<=e.shape[r],(()=>"Error in slice".concat(a,"D: begin[").concat(r,"] + size[").concat(r,"] ")+"(".concat(t[r]+n[r],") would overflow input.shape[").concat(r,"] (").concat(e.shape[r],")")))}function gh(e){const t=[];let n=0;for(;e>0;)1&e&&t.push(n),e/=2,n++;return t}function bh(e,t,n){const a=[];for(let r=0;r<e.length;r++)a[r]=Math.ceil((t[r]-e[r])/n[r]);return a}function yh(e,t,n,a){const r=[...e];for(let o=r.length;o<a.length;o++)r.push(1);for(let o=0;o<n;o++)0===o?r[t]=1:(r.splice(t,0,1),r.pop());return r}function xh(e,t,n){return n<=e?n:n-(t-1)}function vh(e,t){const n=[];for(let a=0;a<e;a++)n.push(t+a);return n}function wh(e,t,n,a,r,o,s,i,c){const l=e.length;let u=new Array(l),d=new Array(l),h=new Array(l);if(t.length&&n>0){const c=t[0],l=n+1;u=kh(s,c,l,a,e),d=Ih(i,c,l,r,e),h=yh(o,c,l,e)}else for(let p=0;p<l;p++)u[p]=Nh(s,a,o,e,p,c),d[p]=Ch(i,r,o,e,p,c),h[p]=Sh(o,p,c);return{begin:u,end:d,strides:h}}function kh(e,t,n,a,r){const o=[...r],s=vh(n,t);for(let i=0;i<o.length;i++)if(s.indexOf(i)>-1)o[i]=0;else{const r=xh(t,n,i);let s=a[r];e&1<<r&&(s=0),o[i]=s}return o}function Ih(e,t,n,a,r){const o=[...r],s=vh(n,t);for(let i=0;i<o.length;i++)if(s.indexOf(i)>-1)o[i]=Number.MAX_SAFE_INTEGER;else{const r=xh(t,n,i);let s=a[r];e&1<<r&&(s=Number.MAX_SAFE_INTEGER),o[i]=s}for(let i=0;i<o.length;i++){const e=r[i];o[i]<0&&(o[i]+=e),o[i]=ao(0,o[i],r[i])}return o}function Sh(e,t,n){let a=e[t];return(n&1<<t||null==a)&&(a=1),a}function Nh(e,t,n,a,r,o){let s=t[r];const i=n[r]||1;(e&1<<r||o&1<<r||null==s)&&(s=i>0?Number.MIN_SAFE_INTEGER:Number.MAX_SAFE_INTEGER);const c=a[r];return s<0&&(s+=c),s=ao(0,s,c-1),s}function Ch(e,t,n,a,r,o){let s=t[r];const i=n[r]||1;(e&1<<r||o&1<<r||null==s)&&(s=i>0?Number.MAX_SAFE_INTEGER:Number.MIN_SAFE_INTEGER);const c=a[r];return s<0&&(s+=c),s=i>0?ao(0,s,c):ao(-1,s,c-1),s}function Th(e,t,n){let a=n.length;for(let r=0;r<n.length;r++)if(n[r]>1){a=r;break}for(let r=a+1;r<n.length;r++)if(t[r]>0||n[r]!==e[r])return!1;return!0}function Eh(e,t){let n=e.length>0?e[e.length-1]:1;for(let a=0;a<e.length-1;a++)n+=e[a]*t[a];return n}function Rh(e,t,n){let a;const r=e.shape.length;let o;return a="number"===typeof t?[t,...new Array(r-1).fill(0)]:t.length<r?t.concat(new Array(r-t.length).fill(0)):t.slice(),a.forEach((e=>{so(-1!==e,(()=>"slice() does not support negative begin indexing."))})),o=null==n?new Array(r).fill(-1):"number"===typeof n?[n,...new Array(r-1).fill(-1)]:n.length<r?n.concat(new Array(r-n.length).fill(-1)):n,o=o.map(((t,n)=>t>=0?t:(so(-1===t,(()=>"Negative size values should be exactly -1 but got "+"".concat(t," for the slice() size at index ").concat(n,"."))),e.shape[n]-a[n]))),[a,o]}function _h(e,t,n,a,r,o,s,i,c){let l;if(null==a?(l=new Array(t.length),l.fill(1)):l=a,null!=s&&0!==(s&s-1))throw new Error("Multiple ellipses in slice is not allowed.");let u=!1;const d={dims:l.length,numAddAxisAfterEllipsis:0,begin:t.slice(),end:n.slice(),strides:l.slice(),beginMask:r,endMask:o,ellipsisMask:s,newAxisMask:i,shrinkAxisMask:c};for(let x=0;x<d.dims;x++)u&&0!==(1<<x&i)&&d.numAddAxisAfterEllipsis++,1<<x&s&&(u=!0);u||(d.ellipsisMask|=1<<d.dims,d.dims++);const h={dims:e.length,beginMask:0,endMask:0,beginValid:!1,endValid:!1};!function(e,t){t.beginMask=0,t.endMask=0,t.shrinkAxisMask=0;let n=0;t.beginValid=null!=e.begin,t.endValid=null!=e.end,t.begin=new Array(t.dims),t.end=new Array(t.dims),t.strides=new Array(t.dims),t.finalShapeGatherIndices=[],t.finalShapeGatherIndicesSparse=[],t.inputShapeGatherIndicesSparse=new Array(t.dims);for(let a=0;a<e.dims;a++)if(1<<a&e.ellipsisMask){const r=Math.min(t.dims-(e.dims-a)+1+e.numAddAxisAfterEllipsis,t.dims);for(;n<r;n++)t.begin[n]=0,t.end[n]=0,t.strides[n]=1,t.beginMask|=1<<n,t.endMask|=1<<n,t.finalShapeGatherIndices.push(n),t.finalShapeGatherIndicesSparse.push(-1),t.inputShapeGatherIndicesSparse[n]=a}else if(1<<a&e.newAxisMask)t.finalShapeGatherIndices.push(ph),t.finalShapeGatherIndicesSparse.push(-1);else{if(n===t.begin.length)throw Error("Index out of range using input dim ".concat(n,"; input ")+"has only ".concat(t.dims," dims, ").concat(t.begin.length,"."));null!=e.begin&&(t.begin[n]=e.begin[a]),null!=e.end&&(t.end[n]=e.end[a]),t.strides[n]=e.strides[a],e.beginMask&1<<a&&(t.beginMask|=1<<n),e.endMask&1<<a&&(t.endMask|=1<<n),e.shrinkAxisMask&1<<a?(t.finalShapeGatherIndices.push(fh),t.finalShapeGatherIndicesSparse.push(-1),t.shrinkAxisMask|=1<<n):(t.finalShapeGatherIndices.push(n),t.finalShapeGatherIndicesSparse.push(a)),t.inputShapeGatherIndicesSparse[n]=a,n++}}(d,h);let p=!0,f=!0,m=!0;const g=[],b=[];for(let x=0;x<e.length;++x){if(0===h.strides[x])throw Error("strides[".concat(x,"] must be non-zero"));const t=!!(h.shrinkAxisMask&1<<x),n=e[x];if(-1===n){g.push(t?1:-1);continue}const a=[h.beginMask&1<<x,h.endMask&1<<x],r=[h.strides[x]>0?0:-1,h.strides[x]>0?n:n-1];if(t&&h.strides[x]<=0)throw Error("only stride 1 allowed on non-range indexing.");m=m&&1===h.strides[x];const o=!!(h.beginMask&1<<x&&h.endMask&1<<x);if(h.beginValid&&h.endValid){if(t){const e=h.begin[x]<0?n+h.begin[x]:h.begin[x];if(h.begin[x]=e,h.end[x]=h.begin[x]+1,e<0||e>=n)throw Error("slice index ".concat(h.begin[x]," of dimension ").concat(x," out of bounds."))}else h.begin[x]=Ah(h.begin[x],0,h.strides[x],n,a,r),h.end[x]=Ah(h.end[x],1,h.strides[x],n,a,r);const e=1===h.strides[x]&&0===h.begin[x]&&h.end[x]===n;p=p&&e,f=f&&(0===x&&1===h.strides[x]||e)}else p=p&&1===h.strides[x]&&o,f=f&&(0===x&&1===h.strides[x]||o);let s,i=!1;if(h.beginValid&&h.endValid?(s=h.end[x]-h.begin[x],i=!0):t?(s=1,i=!0):o&&n>=0&&(s=h.strides[x]<0?-n:n,i=!0),i){let e;e=0===s||s<0!==h.strides[x]<0?0:Math.trunc(s/h.strides[x])+(s%h.strides[x]!==0?1:0),g.push(e)}else g.push(-1)}for(let x=0;x<h.finalShapeGatherIndices.length;++x){const e=h.finalShapeGatherIndices[x];e>=0?b.push(g[e]):e===ph&&b.push(1)}const y=b.filter(((e,t)=>h.finalShapeGatherIndices[t]!==ph));return{finalShapeSparse:y,finalShape:b,isIdentity:p,sliceDim0:f,isSimpleSlice:m,begin:h.begin,end:h.end,strides:h.strides}}function Ah(e,t,n,a,r,o){if(r[t])return n>0?o[t]:o[t+1&1];{const t=e<0?a+e:e;return t<o[0]?o[0]:t>o[1]?o[1]:t}}const Fh=Ru({all_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const a={x:Tu(e,"x","all","bool")},r={axis:t,keepDims:n};return yu.runKernel(Jo,a,r)}});const Oh=Ru({any_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const a={x:Tu(e,"x","any","bool")},r={axis:t,keepDims:n};return yu.runKernel(Zo,a,r)}});const Dh=Ru({argMax_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const n={x:Tu(e,"x","argMax")},a={axis:t};return yu.runKernel($o,n,a)}});function Mh(e,t,n,a){let r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"NHWC",o=arguments.length>5?arguments[5]:void 0;return zh(e,[...t,e[3]],n,o,a,null,null,Xh(r))}function Lh(e,t,n,a,r,o){let s=arguments.length>6&&void 0!==arguments[6]?arguments[6]:"channelsLast";const[i,c]=Vh(t);let l;if("channelsLast"===s)l=[i,c,e[3],e[3]];else{if("channelsFirst"!==s)throw new Error("Unknown dataFormat ".concat(s));l=[i,c,e[1],e[1]]}return zh(e,l,n,a,r,o,!1,s)}function Ph(e,t,n,a,r,o){let s=arguments.length>6&&void 0!==arguments[6]?arguments[6]:"NDHWC";const[i,c,l]=Uh(t);let u,d;if("NDHWC"===s)d="channelsLast",u=[i,c,l,e[4],e[4]];else{if("NCDHW"!==s)throw new Error("Unknown dataFormat ".concat(s));d="channelsFirst",u=[i,c,l,e[1],e[1]]}return Bh(e,u,n,a,r,!1,d,o)}function zh(e,t,n,a,r,o){let s=arguments.length>6&&void 0!==arguments[6]&&arguments[6],i=arguments.length>7&&void 0!==arguments[7]?arguments[7]:"channelsLast",[c,l,u,d]=[-1,-1,-1,-1];if("channelsLast"===i)[c,l,u,d]=e;else{if("channelsFirst"!==i)throw new Error("Unknown dataFormat ".concat(i));[c,d,l,u]=e}const[h,p,,f]=t,[m,g]=Vh(n),[b,y]=Vh(a),x=Gh(h,b),v=Gh(p,y),{padInfo:w,outHeight:k,outWidth:I}=function(e,t,n,a,r,o,s,i,c){let l,u,d;if("number"===typeof e){l={top:e,bottom:e,left:e,right:e,type:0===e?"VALID":"NUMBER"};const r=function(e,t,n,a,r){null==a&&(a=Wh(e,t,n));const o=e[0],s=e[1],i=Hh((o-t+2*a)/n+1,r),c=Hh((s-t+2*a)/n+1,r);return[i,c]}([t,n],o,a,e,i);u=r[0],d=r[1]}else if("same"===e){u=Math.ceil(t/a),d=Math.ceil(n/r);const e=Math.max(0,(u-1)*a+o-t),i=Math.max(0,(d-1)*r+s-n),c=Math.floor(e/2),h=e-c,p=Math.floor(i/2);l={top:c,bottom:h,left:p,right:i-p,type:"SAME"}}else if("valid"===e)l={top:0,bottom:0,left:0,right:0,type:"VALID"},u=Math.ceil((t-o+1)/a),d=Math.ceil((n-s+1)/r);else{if("object"!==typeof e)throw Error("Unknown padding parameter: ".concat(e));{const h="channelsLast"===c?e[1][0]:e[2][0],p="channelsLast"===c?e[1][1]:e[2][1],f="channelsLast"===c?e[2][0]:e[3][0],m="channelsLast"===c?e[2][1]:e[3][1];l={top:h,bottom:p,left:f,right:m,type:0===h&&0===p&&0===f&&0===m?"VALID":"EXPLICIT"},u=Hh((t-o+h+p)/a+1,i),d=Hh((n-s+f+m)/r+1,i)}}return{padInfo:l,outHeight:u,outWidth:d}}(r,l,u,m,g,x,v,o,i),S=s?f*d:f;let N;return"channelsFirst"===i?N=[c,S,k,I]:"channelsLast"===i&&(N=[c,k,I,S]),{batchSize:c,dataFormat:i,inHeight:l,inWidth:u,inChannels:d,outHeight:k,outWidth:I,outChannels:S,padInfo:w,strideHeight:m,strideWidth:g,filterHeight:h,filterWidth:p,effectiveFilterHeight:x,effectiveFilterWidth:v,dilationHeight:b,dilationWidth:y,inShape:e,outShape:N,filterShape:t}}function Bh(e,t,n,a,r){let o=arguments.length>5&&void 0!==arguments[5]&&arguments[5],s=arguments.length>6&&void 0!==arguments[6]?arguments[6]:"channelsLast",i=arguments.length>7?arguments[7]:void 0,[c,l,u,d,h]=[-1,-1,-1,-1,-1];if("channelsLast"===s)[c,l,u,d,h]=e;else{if("channelsFirst"!==s)throw new Error("Unknown dataFormat ".concat(s));[c,h,l,u,d]=e}const[p,f,m,,g]=t,[b,y,x]=Uh(n),[v,w,k]=Uh(a),I=Gh(p,v),S=Gh(f,w),N=Gh(m,k),{padInfo:C,outDepth:T,outHeight:E,outWidth:R}=function(e,t,n,a,r,o,s,i,c,l,u){let d,h,p,f;"valid"===e&&(e=0);if("number"===typeof e){d={top:e,bottom:e,left:e,right:e,front:e,back:e,type:0===e?"VALID":"NUMBER"};const m=function(e,t,n,a,r,o){null==r&&(r=Wh(e,t[0],a[0]));const s=[0,0,0,n];for(let i=0;i<3;i++)e[i]+2*r>=t[i]&&(s[i]=Hh((e[i]-t[i]+2*r)/a[i]+1,o));return s}([t,n,a,1],[i,c,l],1,[r,o,s],e,u);h=m[0],p=m[1],f=m[2]}else{if("same"!==e)throw Error("Unknown padding parameter: ".concat(e));{h=Math.ceil(t/r),p=Math.ceil(n/o),f=Math.ceil(a/s);const e=(h-1)*r+i-t,u=(p-1)*o+c-n,m=(f-1)*s+l-a,g=Math.floor(e/2),b=e-g,y=Math.floor(u/2),x=u-y,v=Math.floor(m/2);d={top:y,bottom:x,left:v,right:m-v,front:g,back:b,type:"SAME"}}}return{padInfo:d,outDepth:h,outHeight:p,outWidth:f}}(r,l,u,d,b,y,x,I,S,N,i),_=o?g*h:g;let A;return"channelsFirst"===s?A=[c,_,T,E,R]:"channelsLast"===s&&(A=[c,T,E,R,_]),{batchSize:c,dataFormat:s,inDepth:l,inHeight:u,inWidth:d,inChannels:h,outDepth:T,outHeight:E,outWidth:R,outChannels:_,padInfo:C,strideDepth:b,strideHeight:y,strideWidth:x,filterDepth:p,filterHeight:f,filterWidth:m,effectiveFilterDepth:I,effectiveFilterHeight:S,effectiveFilterWidth:N,dilationDepth:v,dilationHeight:w,dilationWidth:k,inShape:e,outShape:A,filterShape:t}}function Wh(e,t,n){const a=Gh(t,arguments.length>3&&void 0!==arguments[3]?arguments[3]:1);return Math.floor((e[0]*(n-1)-n+a)/2)}function Vh(e){return"number"===typeof e?[e,e,e]:2===e.length?[e[0],e[1],1]:e}function Uh(e){return"number"===typeof e?[e,e,e]:e}function Gh(e,t){return t<=1?e:e+(e-1)*(t-1)}function Hh(e,t){if(!t)return Math.trunc(e);switch(t){case"round":return Math.round(e);case"ceil":return Math.ceil(e);case"floor":return Math.floor(e);default:throw new Error("Unknown roundingMode ".concat(t))}}function jh(e){const[t,n,a]=Vh(e);return 1===t&&1===n&&1===a}function Kh(e,t){return jh(e)||jh(t)}function qh(e){return Vh(e).every((e=>e>0))}function Xh(e){if("NHWC"===e)return"channelsLast";if("NCHW"===e)return"channelsFirst";throw new Error("Unknown dataFormat ".concat(e))}function Yh(e,t,n){if(null!=n){if("string"===typeof t)throw Error("Error in ".concat(e,": pad must be an integer when using ")+"dimRoundingMode ".concat(n," but got pad ").concat(t,"."));if("number"===typeof t)so(ho(t),(()=>"Error in ".concat(e,": pad must be an integer when using ")+"dimRoundingMode ".concat(n," but got pad ").concat(t,".")));else{if("object"!==typeof t)throw Error("Error in ".concat(e,": Unknown padding parameter: ").concat(t));t.forEach((t=>{t.forEach((t=>{so(ho(t),(()=>"Error in ".concat(e,": pad must be an integer when using ")+"dimRoundingMode ".concat(n," but got pad ").concat(t,".")))}))}))}}}const Qh=Ru({reshape_:function(e,t){const n={x:Tu(e,"x","reshape","string_or_numeric")},a={shape:t};return yu.runKernel(ac,n,a)}});const Jh=Ru({avgPool_:function(e,t,n,a,r){const o=Tu(e,"x","avgPool","float32");so(Kh(n,1),(()=>"Error in avgPool: Either strides or dilations must be 1. "+"Got strides ".concat(n," and dilations '").concat(1,"'")));let s=o,i=!1;3===o.rank&&(i=!0,s=Qh(o,[1,o.shape[0],o.shape[1],o.shape[2]])),so(4===s.rank,(()=>"Error in avgPool: x must be rank 4 but got rank ".concat(s.rank,"."))),Yh("avgPool",a,r);const c={x:s},l={filterSize:t,strides:n,pad:a,dimRoundingMode:r};let u=yu.runKernel(ss,c,l);return u=Cd(u,o.dtype),i?Qh(u,[u.shape[1],u.shape[2],u.shape[3]]):u}});const Zh=Ru({avgPool3d_:function(e,t,n,a,r){let o=arguments.length>5&&void 0!==arguments[5]?arguments[5]:"NDHWC";const s=Tu(e,"x","avgPool3d","float32");let i=s,c=!1;4===s.rank&&(c=!0,i=Qh(s,[1,s.shape[0],s.shape[1],s.shape[2],s.shape[3]])),so(5===i.rank,(()=>"Error in avgPool3d: x must be rank 5 but got rank ".concat(i.rank,"."))),so("NDHWC"===o,(()=>"Error in avgPool3d: Only NDHWC is currently supported, "+"but got dataFormat of ".concat(o))),so("number"===typeof n&&n>0||Array.isArray(n)&&n[0]>0&&n[1]>0&&n[2]>0,(()=>"Error in avgPool3d: Stride must be > 0, but got '".concat(n,"'"))),Yh("avgPool3d",a,r);const l={x:i},u={filterSize:t,strides:n,pad:a,dimRoundingMode:r,dataFormat:o};let d=yu.runKernel(cs,l,u);return d=Cd(d,i.dtype),c?Qh(d,[d.shape[1],d.shape[2],d.shape[3],d.shape[4]]):d}});const $h=Ru({batchNorm_:function(e,t,n,a,r,o){null==o&&(o=.001);const s=Tu(e,"x","batchNorm"),i=Tu(t,"mean","batchNorm"),c=Tu(n,"variance","batchNorm");let l,u;null!=r&&(l=Tu(r,"scale","batchNorm")),null!=a&&(u=Tu(a,"offset","batchNorm")),so(i.rank===c.rank,(()=>"Batch normalization gradient requires mean and variance to have equal ranks.")),so(null==u||i.rank===u.rank,(()=>"Batch normalization gradient requires mean and offset to have equal ranks.")),so(null==l||i.rank===l.rank,(()=>"Batch normalization gradient requires mean and scale to have equal ranks."));const d={x:function(e){let t;return t=0===e.rank||1===e.rank?Qh(e,[1,1,1,e.size]):2===e.rank?Qh(e,[1,1,e.shape[0],e.shape[1]]):3===e.rank?Qh(e,[1,e.shape[0],e.shape[1],e.shape[2]]):e,t}(s),scale:l,offset:u,mean:i,variance:c},h={varianceEpsilon:o},p=yu.runKernel(ni,d,h);return Qh(p,s.shape)}});const ep=Ru({batchNorm2d_:function(e,t,n,a,r,o){const s=Tu(e,"x","batchNorm"),i=Tu(t,"mean","batchNorm"),c=Tu(n,"variance","batchNorm");let l,u;return null!=r&&(l=Tu(r,"scale","batchNorm")),null!=a&&(u=Tu(a,"offset","batchNorm")),so(2===s.rank,(()=>"Error in batchNorm2D: x must be rank 2 but got rank "+"".concat(s.rank,"."))),so(2===i.rank||1===i.rank,(()=>"Error in batchNorm2D: mean must be rank 2 or rank 1 but "+"got rank ".concat(i.rank,"."))),so(2===c.rank||1===c.rank,(()=>"Error in batchNorm2D: variance must be rank 2 or rank 1 "+"but got rank ".concat(c.rank,"."))),null!=l&&so(2===l.rank||1===l.rank,(()=>"Error in batchNorm2D: scale must be rank 2 or rank 1 "+"but got rank ".concat(l.rank,"."))),null!=u&&so(2===u.rank||1===u.rank,(()=>"Error in batchNorm2D: offset must be rank 2 or rank 1 "+"but got rank ".concat(u.rank,"."))),$h(s,i,c,u,l,o)}});const tp=Ru({batchNorm3d_:function(e,t,n,a,r,o){const s=Tu(e,"x","batchNorm"),i=Tu(t,"mean","batchNorm"),c=Tu(n,"variance","batchNorm");let l,u;return null!=r&&(l=Tu(r,"scale","batchNorm")),null!=a&&(u=Tu(a,"offset","batchNorm")),so(3===s.rank,(()=>"Error in batchNorm3D: x must be rank 3 but got rank "+"".concat(s.rank,"."))),so(3===i.rank||1===i.rank,(()=>"Error in batchNorm3D: mean must be rank 3 or rank 1 but "+"got rank ".concat(i.rank,"."))),so(3===c.rank||1===c.rank,(()=>"Error in batchNorm3D: variance must be rank 3 or rank 1 "+"but got rank ".concat(c.rank,"."))),null!=l&&so(3===l.rank||1===l.rank,(()=>"Error in batchNorm3D: scale must be rank 3 or rank 1 "+"but got rank ".concat(l.rank,"."))),null!=u&&so(3===u.rank||1===u.rank,(()=>"Error in batchNorm3D: offset must be rank 3 or rank 1 "+"but got rank ".concat(u.rank,"."))),$h(s,i,c,u,l,o)}});const np=Ru({batchNorm4d_:function(e,t,n,a,r,o){const s=Tu(e,"x","batchNorm"),i=Tu(t,"mean","batchNorm"),c=Tu(n,"variance","batchNorm");let l,u;return null!=r&&(l=Tu(r,"scale","batchNorm")),null!=a&&(u=Tu(a,"offset","batchNorm")),so(4===s.rank,(()=>"Error in batchNorm4D: x must be rank 4 but got rank "+"".concat(s.rank,"."))),so(4===i.rank||1===i.rank,(()=>"Error in batchNorm4D: mean must be rank 4 or rank 1 but "+"got rank ".concat(i.rank,"."))),so(4===c.rank||1===c.rank,(()=>"Error in batchNorm4D: variance must be rank 4 or rank 1 "+"but got rank ".concat(c.rank,"."))),null!=l&&so(4===l.rank||1===l.rank,(()=>"Error in batchNorm4D: scale must be rank 4 or rank 1 "+"but got rank ".concat(l.rank,"."))),null!=u&&so(4===u.rank||1===u.rank,(()=>"Error in batchNorm4D: offset must be rank 4 or rank 1 "+"but got rank ".concat(u.rank,"."))),$h(s,i,c,u,l,o)}});const ap=Ru({broadcastTo_:function(e,t){let n=Tu(e,"broadcastTo","x");const a=n.shape;if(Do(t),t.length<n.rank)throw new Error("broadcastTo(): shape.length=".concat(t.length," < input.rank=").concat(n.rank,"."));if(t.length>n.rank){const e=n.shape.slice();for(;e.length<t.length;)e.unshift(1);n=Qh(n,e)}const r=n.shape,o=Array.from(t);for(let l=t.length-1;l>=0;l--)if(r[l]===t[l])o[l]=1;else if(1!==n.shape[l])throw new Error("broadcastTo(): [".concat(a,"] cannot be broadcast to [").concat(t,"]."));const s=o.map(((e,t)=>e>1?t:-1)).filter((e=>e>=0));if(0===s.length)return Td(n);const i={x:n},c={reps:o};return yu.runKernel(Gc,i,c)}});const rp=Ru({clipByValue_:function(e,t,n){const a=Tu(e,"x","clipByValue");if(so(t<=n,(()=>"Error in clip: min (".concat(t,") must be ")+"less than or equal to max (".concat(n,")."))),t===n)return Hd(a.shape,t,a.dtype);const r={x:a},o={clipValueMin:t,clipValueMax:n};return yu.runKernel(bs,r,o)}});const op=Ru({concat_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;so(e.length>=1,(()=>"Pass at least one tensor to concat"));const n=Eu(e,"tensors","concat","string_or_numeric");if("complex64"===n[0].dtype&&n.forEach((e=>{if("complex64"!==e.dtype)throw new Error("Cannot concatenate complex64 tensors with a tensor\n          with dtype ".concat(e.dtype,". "))})),1===n.length)return Td(n[0]);const a=n,r={axis:t};return yu.runKernel(vs,a,r)}});const sp=Ru({concat1d_:function(e){return op(e,0)}});const ip=Ru({concat2d_:function(e,t){return op(e,t)}});const cp=Ru({concat3d_:function(e,t){return op(e,t)}});const lp=Ru({concat4d_:function(e,t){return op(e,t)}});const up=Ru({conv2d_:function(e,t,n,a){let r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"NHWC",o=arguments.length>5&&void 0!==arguments[5]?arguments[5]:[1,1],s=arguments.length>6?arguments[6]:void 0;const i=Tu(e,"x","conv2d","float32"),c=Tu(t,"filter","conv2d","float32");let l=i,u=!1;3===i.rank&&(u=!0,l=Qh(i,[1,i.shape[0],i.shape[1],i.shape[2]])),so(4===l.rank,(()=>"Error in conv2d: input must be rank 4, but got rank ".concat(l.rank,"."))),so(4===c.rank,(()=>"Error in conv2d: filter must be rank 4, but got rank "+"".concat(c.rank,"."))),Yh("conv2d",a,s);const d="NHWC"===r?l.shape[3]:l.shape[1];so(d===c.shape[2],(()=>"Error in conv2d: depth of input (".concat(d,") must match ")+"input depth for filter ".concat(c.shape[2],"."))),so(Kh(n,o),(()=>"Error in conv2D: Either strides or dilations must be 1. "+"Got strides ".concat(n," and dilations '").concat(o,"'"))),so(qh(o),(()=>"Error in conv2D: Dilated rates should be larger than 0.")),so(qh(n),(()=>"Error in conv2D: Strides should be larger than 0."));const h={x:l,filter:c},p={strides:n,pad:a,dataFormat:r,dilations:o,dimRoundingMode:s},f=yu.runKernel(ws,h,p);return u?Qh(f,[f.shape[1],f.shape[2],f.shape[3]]):f}});const dp=Ru({conv1d_:function(e,t,n,a){let r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"NWC",o=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,s=arguments.length>6?arguments[6]:void 0;const i=Tu(e,"x","conv1d"),c=Tu(t,"filter","conv1d");let l=i,u=!1;2===i.rank&&(u=!0,l=Qh(i,[1,i.shape[0],i.shape[1]])),so(3===l.rank,(()=>"Error in conv1d: input must be rank 3, but got rank ".concat(l.rank,"."))),so(3===c.rank,(()=>"Error in conv1d: filter must be rank 3, but got rank "+"".concat(c.rank,"."))),Yh("conv1d",a,s),so(l.shape[2]===c.shape[1],(()=>"Error in conv1d: depth of input (".concat(l.shape[2],") must match ")+"input depth for filter ".concat(c.shape[1],"."))),so(Kh(n,o),(()=>"Error in conv1D: Either stride or dilation must be 1. "+"Got stride ".concat(n," and dilation '").concat(o,"'"))),so(qh(o),(()=>"Error in conv1D: Dilated rates should be larger than 0.")),so(qh(n),(()=>"Error in conv1D: Stride should be larger than 0.")),so("NWC"===r,(()=>"Error in conv1d: got dataFormat of ".concat(r," but only NWC is currently supported.")));const d=Qh(c,[1,c.shape[0],c.shape[1],c.shape[2]]),h=Qh(l,[l.shape[0],1,l.shape[1],l.shape[2]]),p=up(h,d,[1,n],a,"NHWC",[1,o],s);return Qh(p,u?[p.shape[2],p.shape[3]]:[p.shape[0],p.shape[2],p.shape[3]])}});const hp=Ru({conv2DBackpropInput_:function(e,t,n,a,r){let o=arguments.length>5&&void 0!==arguments[5]?arguments[5]:"NHWC",s=arguments.length>6?arguments[6]:void 0;so(e.length===t.rank,(()=>"Length of inShape "+"(".concat(e.length,") and rank of dy (").concat(t.rank,") must match")));let i=e,c=t,l=!1;3===t.rank&&(l=!0,c=Qh(t,[1,t.shape[0],t.shape[1],t.shape[2]]),i=[1,e[0],e[1],e[2]]),so(4===i.length,(()=>"Error in conv2dDerInput: inShape must be length 4, but got length "+"".concat(i.length,"."))),so(4===c.rank,(()=>"Error in conv2dDerInput: dy must be rank 4, but got "+"rank ".concat(c.rank))),so(4===n.rank,(()=>"Error in conv2dDerInput: filter must be rank 4, but got "+"rank ".concat(n.rank)));const u="NHWC"===o?i[3]:i[1],d="NHWC"===o?c.shape[3]:c.shape[1];so(u===n.shape[2],(()=>"Error in conv2dDerInput: depth of input (".concat(u,") must ")+"match input depth for filter ".concat(n.shape[2],"."))),so(d===n.shape[3],(()=>"Error in conv2dDerInput: depth of output (".concat(d,") must ")+"match output depth for filter ".concat(n.shape[3],"."))),Yh("conv2dDerInput",r,s);const h={dy:c,filter:n},p={strides:a,pad:r,dataFormat:o,dimRoundingMode:s,inputShape:i},f=yu.runKernel(Is,h,p);return l?Qh(f,[f.shape[1],f.shape[2],f.shape[3]]):f}});const pp=Ru({conv2dTranspose_:function(e,t,n,a,r,o){const s=Tu(e,"x","conv2dTranspose"),i=Tu(t,"filter","conv2dTranspose");return hp(n,s,i,a,r,"NHWC",o)}});const fp=Ru({conv3d_:function(e,t,n,a){let r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"NDHWC",o=arguments.length>5&&void 0!==arguments[5]?arguments[5]:[1,1,1];const s=Tu(e,"x","conv3d"),i=Tu(t,"filter","conv3d");let c=s,l=!1;4===s.rank&&(l=!0,c=Qh(s,[1,s.shape[0],s.shape[1],s.shape[2],s.shape[3]])),so(5===c.rank,(()=>"Error in conv3d: input must be rank 5, but got rank ".concat(c.rank,"."))),so(5===i.rank,(()=>"Error in conv3d: filter must be rank 5, but got rank "+"".concat(i.rank,"."))),so(c.shape[4]===i.shape[3],(()=>"Error in conv3d: depth of input (".concat(c.shape[4],") must match ")+"input depth for filter ".concat(i.shape[3],"."))),so(Kh(n,o),(()=>"Error in conv3D: Either strides or dilations must be 1. "+"Got strides ".concat(n," and dilations '").concat(o,"'"))),so("NDHWC"===r,(()=>"Error in conv3d: got dataFormat of ".concat(r," but only NDHWC is currently supported."))),so(qh(o),(()=>"Error in conv3D: Dilated rates should be larger than 0.")),so(qh(n),(()=>"Error in conv3D: Strides should be larger than 0."));const u={x:c,filter:i},d={strides:n,pad:a,dataFormat:r,dilations:o},h=yu.runKernel(Ss,u,d);return l?Qh(h,[h.shape[1],h.shape[2],h.shape[3],h.shape[4]]):h}});const mp=Ru({conv3DBackpropInput_:function(e,t,n,a,r){so(e.length===t.rank,(()=>"Length of inShape "+"(".concat(e.length,") and rank of dy (").concat(t.rank,") must match")));let o=e,s=t,i=!1;4===t.rank&&(i=!0,s=Qh(t,[1,t.shape[0],t.shape[1],t.shape[2],t.shape[3]]),o=[1,e[0],e[1],e[2],e[3]]);const c=o[4],l=s.shape[4];so(5===o.length,(()=>"Error in conv3dDerInput: inShape must be length 5, but got length "+"".concat(o.length,"."))),so(5===s.rank,(()=>"Error in conv3dDerInput: dy must be rank 5, but got "+"rank ".concat(s.rank))),so(5===n.rank,(()=>"Error in conv3dDerInput: filter must be rank 5, but got "+"rank ".concat(n.rank))),so(c===n.shape[3],(()=>"Error in conv3dDerInput: depth of input (".concat(c,") must ")+"match input depth for filter ".concat(n.shape[3],"."))),so(l===n.shape[4],(()=>"Error in conv3dDerInput: depth of output (".concat(l,") must ")+"match output depth for filter ".concat(n.shape[4],".")));const u={dy:s,filter:n},d={pad:r,strides:a,inputShape:o},h=yu.runKernel(Cs,u,d);return i?Qh(h,[h.shape[1],h.shape[2],h.shape[3],h.shape[4]]):h}});const gp=Ru({conv3dTranspose_:function(e,t,n,a,r){const o=Tu(e,"x","conv3dTranspose"),s=Tu(t,"filter","conv3dTranspose");return mp(n,o,s,a,r)}});const bp=Ru({denseBincount_:function(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const r=Tu(e,"x","denseBincount"),o=Tu(t,"weights","denseBincount");so("int32"===r.dtype,(()=>"Error in denseBincount: input "+"dtype must be int32, but got ".concat(r.dtype))),so(r.rank<=2,(()=>"Error in denseBincount: input must be at most rank 2, but got "+"rank ".concat(r.rank,"."))),so(n>=0,(()=>"size must be non-negative, but got ".concat(n,"."))),so(o.size===r.size||0===o.size,(()=>"Error in denseBincount: weights must have the same shape as x or "+"0-length, but got x shape: ".concat(r.shape,", weights shape: ")+"".concat(o.shape,".")));const s={x:r,weights:o},i={size:n,binaryOutput:a};return yu.runKernel(Fs,s,i)}});const yp=Ru({depthwiseConv2d_:function(e,t,n,a){let r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"NHWC",o=arguments.length>5&&void 0!==arguments[5]?arguments[5]:[1,1],s=arguments.length>6?arguments[6]:void 0;const i=Tu(e,"x","depthwiseConv2d","float32"),c=Tu(t,"filter","depthwiseConv2d","float32");let l=i,u=!1;3===i.rank&&(u=!0,l=Qh(i,[1,i.shape[0],i.shape[1],i.shape[2]])),so(4===l.rank,(()=>"Error in depthwiseConv2d: input must be rank 4, but got "+"rank ".concat(l.rank,"."))),so(4===c.rank,(()=>"Error in depthwiseConv2d: filter must be rank 4, but got rank "+"".concat(c.rank,".")));const d="NHWC"===r?l.shape[3]:l.shape[1];so(d===c.shape[2],(()=>"Error in depthwiseConv2d: number of input channels "+"(".concat(d,") must match the inChannels dimension in ")+"filter ".concat(c.shape[2],"."))),Yh("depthwiseConv2d",a,s);const h={x:l,filter:c},p={strides:n,pad:a,dataFormat:r,dilations:o,dimRoundingMode:s},f=yu.runKernel(Ds,h,p);return u?Qh(f,[f.shape[1],f.shape[2],f.shape[3]]):f}});const xp=Ru({elu_:function(e){const t={x:Tu(e,"x","elu","float32")};return yu.runKernel(Hs,t)}});const vp=Ru({equal_:function(e,t){let n=Tu(e,"a","equal","string_or_numeric"),a=Tu(t,"b","equal","string_or_numeric");[n,a]=uu(n,a),Zd(n.shape,a.shape);const r={a:n,b:a};return yu.runKernel(qs,r)}});const wp=Ru({exp_:function(e){const t={x:Tu(e,"x","exp")};return yu.runKernel(Xs,t)}});const kp=Ru({expandDims_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const n=Tu(e,"x","expandDims","string_or_numeric");so(t<=n.rank,(()=>"Axis must be <= rank of the tensor"));const a={input:n},r={dim:t};return yu.runKernel(Ys,a,r)}});const Ip=Ru({tile_:function(e,t){const n=Tu(e,"x","tile","string_or_numeric");so(n.rank===t.length,(()=>"Error in transpose: rank of input ".concat(n.rank," ")+"must match length of reps ".concat(t,".")));const a={x:n},r={reps:t};return yu.runKernel(Gc,a,r)}});const Sp=Ru({eye_:function(e,t,n){null==t&&(t=e);const a=Nd([e,t],arguments.length>3&&void 0!==arguments[3]?arguments[3]:"float32"),r=e<=t?e:t;for(let s=0;s<r;++s)a.set(1,s,s);const o=Qh(a.toTensor(),[e,t]);if(null==n)return o;if(1===n.length)return Ip(kp(o,0),[n[0],1,1]);if(2===n.length)return Ip(kp(kp(o,0),0),[n[0],n[1],1,1]);if(3===n.length)return Ip(kp(kp(kp(o,0),0),0),[n[0],n[1],n[2],1,1]);throw new Error("eye() currently supports only 1D and 2D "+"batchShapes, but received ".concat(n.length,"D."))}});const Np=Ru({floor_:function(e){const t={x:Tu(e,"x","floor","float32")};return yu.runKernel(ei,t)}});const Cp=Ru({gather_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;const r={x:Tu(e,"x","gather"),indices:Tu(t,"indices","gather","int32")},o={axis:n,batchDims:a};return yu.runKernel(ai,r,o)}});const Tp=Ru({greater_:function(e,t){let n=Tu(e,"a","greater","string_or_numeric"),a=Tu(t,"b","greater","string_or_numeric");[n,a]=uu(n,a),Zd(n.shape,a.shape);const r={a:n,b:a};return yu.runKernel(oi,r)}});const Ep=Ru({greaterEqual_:function(e,t){let n=Tu(e,"a","greaterEqual","string_or_numeric"),a=Tu(t,"b","greaterEqual","string_or_numeric");[n,a]=uu(n,a),Zd(n.shape,a.shape);const r={a:n,b:a};return yu.runKernel(si,r)}});const Rp=Ru({leakyRelu_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:.2;const n={x:Tu(e,"x","leakyRelu")},a={alpha:t};return yu.runKernel(pi,n,a)}});const _p=Ru({log_:function(e){const t={x:Tu(e,"x","log","float32")};return yu.runKernel(bi,t)}});const Ap=Ru({log1p_:function(e){const t={x:Tu(e,"x","log1p")};return yu.runKernel(yi,t)}});const Fp=Ru({max_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const a={x:Tu(e,"x","max")},r={reductionIndices:t,keepDims:n};return yu.runKernel(Si,a,r)}});const Op=Ru({sum_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],a=Tu(e,"x","sum");"bool"===a.dtype&&(a=Cd(a,"int32"));const r={x:a},o={axis:t,keepDims:n};return yu.runKernel(Sc,r,o)}});const Dp=Ru({logSoftmax_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:-1;const n=Tu(e,"logits","logSoftmax");if(-1===t&&(t=n.rank-1),t!==n.rank-1)throw Error("Log Softmax along a non-last dimension is not yet supported. "+"Logits was rank ".concat(n.rank," and axis was ").concat(t));const a=Md(((e,n)=>{const a=Fp(e,t,!0),r=qd(e,a),o=qd(Cd(r,"float32"),_p(Op(wp(r),t,!0)));n([o]);return{value:o,gradFunc:(e,n)=>{const[a]=n,r=wp(a);return qd(e,Ad(Op(e,t,!0),r))}}}));return a(n)}});function Mp(e,t){for(let n=0;n<e.length;++n)if(e[e.length-n-1]!==t-1-n)return!1;return!0}function Lp(e,t,n){const a=e.length+t.length,r=[];let o=0,s=0;for(let i=0;i<a;i++)-1===n.indexOf(i)?r.push(e[o++]):r.push(t[s++]);return r}function Pp(e,t){const n=[],a=e.length;for(let r=0;r<a;r++)-1===t.indexOf(r)&&n.push(e[r]);return[n,t.map((t=>e[t]))]}function zp(e,t){return Lp(e,t.map((e=>1)),t)}function Bp(e,t,n){so(Mp(t,n),(()=>"".concat(e," supports only inner-most axes for now. ")+"Got axes ".concat(t," and rank-").concat(n," input.")))}function Wp(e,t){if(Mp(e,t))return null;const n=[];for(let a=0;a<t;++a)-1===e.indexOf(a)&&n.push(a);return e.forEach((e=>n.push(e))),n}function Vp(e){return e.map(((e,t)=>[t,e])).sort(((e,t)=>e[1]-t[1])).map((e=>e[0]))}function Up(e,t){const n=[];for(let a=t-e;a<t;++a)n.push(a);return n}const Gp=Ru({logSumExp_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const a=Tu(e,"x","logSumExp"),r=bo(t,a.shape),o=Fp(a,r,!0),s=qd(a,o),i=wp(s),c=Op(i,r),l=_p(c),u=Ed(Qh(o,l.shape),l);if(n){const e=zp(u.shape,r);return Qh(u,e)}return u}});const Hp=Ru({logicalAnd_:function(e,t){const n=Tu(e,"a","logicalAnd","bool"),a=Tu(t,"b","logicalAnd","bool");Zd(n.shape,a.shape);const r={a:n,b:a};return yu.runKernel(xi,r)}});const jp=Ru({matMul_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],a=arguments.length>3&&void 0!==arguments[3]&&arguments[3],r=Tu(e,"a","matMul"),o=Tu(t,"b","matMul");[r,o]=uu(r,o);const s={a:r,b:o},i={transposeA:n,transposeB:a};return yu.runKernel(us,s,i)}});const Kp=Ru({maxPool_:function(e,t,n,a,r){const o=Tu(e,"x","maxPool");let s=o,i=!1;3===o.rank&&(i=!0,s=Qh(o,[1,o.shape[0],o.shape[1],o.shape[2]])),so(4===s.rank,(()=>"Error in maxPool: input must be rank 4 but got rank ".concat(s.rank,"."))),so(Kh(n,1),(()=>"Error in maxPool: Either strides or dilations must be 1. "+"Got strides ".concat(n," and dilations '").concat(1,"'"))),Yh("maxPool",a,r);const c={x:s},l={filterSize:t,strides:n,pad:a,dimRoundingMode:r},u=yu.runKernel(Ci,c,l);return i?Qh(u,[u.shape[1],u.shape[2],u.shape[3]]):u}});const qp=Ru({maxPool3d_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[1,1,1],n=arguments.length>2?arguments[2]:void 0,a=arguments.length>3?arguments[3]:void 0,r=arguments.length>4?arguments[4]:void 0,o=arguments.length>5&&void 0!==arguments[5]?arguments[5]:"NDHWC";const s=Tu(e,"x","maxPool3d");let i=s,c=!1;4===s.rank&&(c=!0,i=Qh(s,[1,s.shape[0],s.shape[1],s.shape[2],s.shape[3]])),so(5===i.rank,(()=>"Error in maxPool3d: x must be rank 5 but got rank ".concat(i.rank,"."))),so("NDHWC"===o,(()=>"Error in maxPool3d: Only NDHWC is currently supported, "+"but got dataFormat of ".concat(o))),Yh("maxPool3d",a,r);const l={x:i},u={filterSize:t,strides:n,pad:a,dimRoundingMode:r,dataFormat:o},d=yu.runKernel(Ei,l,u);return c?Qh(d,[d.shape[1],d.shape[2],d.shape[3],d.shape[4]]):d}});const Xp=Ru({mean_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const a={x:Tu(e,"x","mean")},r={axis:t,keepDims:n};return yu.runKernel(Ai,a,r)}});const Yp=Ru({min_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const a={x:Tu(e,"x","min")},r={axis:t,keepDims:n};return yu.runKernel(Fi,a,r)}});const Qp=Ru({minimum_:function(e,t){let n=Tu(e,"a","minimum"),a=Tu(t,"b","minimum");[n,a]=uu(n,a),"bool"===n.dtype&&(n=Cd(n,"int32"),a=Cd(a,"int32")),Zd(n.shape,a.shape);const r={a:n,b:a};return yu.runKernel(Oi,r)}});const Jp=Ru({moments_:function(e){let t=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const n=bo(arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,(e=Tu(e,"x","moments")).shape),a=Xp(e,n,t);let r=a.shape;t||(r=zp(a.shape,n));const o=Od(qd(Cd(e,"float32"),Qh(a,r)));return{mean:a,variance:Xp(o,n,t)}}});const Zp=Ru({neg_:function(e){const t={x:Tu(e,"x","neg")};return yu.runKernel(zi,t)}});const $p=Ru({notEqual_:function(e,t){let n=Tu(e,"a","notEqual","string_or_numeric"),a=Tu(t,"b","notEqual","string_or_numeric");[n,a]=uu(n,a),Zd(n.shape,a.shape);const r={a:n,b:a};return yu.runKernel(Bi,r)}});const ef=Ru({oneHot_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0,r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"int32";if(t<2)throw new Error("Error in oneHot: depth must be >=2, but it is ".concat(t));const o={indices:Tu(e,"indices","oneHot","int32")},s={dtype:r,depth:t,onValue:n,offValue:a};return yu.runKernel(Hi,o,s)}});function tf(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"float32";if(Do(e),"complex64"===t){const t=tf(e,"float32"),n=tf(e,"float32");return _u(t,n)}const n=Fo(lo(e),t);return yu.makeTensor(n,e,t)}function nf(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"float32";if(Do(e),"complex64"===t){const t=nf(e,"float32"),n=tf(e,"float32");return _u(t,n)}const n=Ao(lo(e),t);return yu.makeTensor(n,e,t)}const af=Ru({onesLike_:function(e){const t={x:Tu(e,"x","onesLike")};return yu.runKernel(Gi,t)}});const rf=Ru({pad_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;const a=Tu(e,"x","pad");if(0===a.rank)throw new Error("pad(scalar) is not defined. Pass non-scalar to pad");const r={paddings:t,constantValue:n},o={x:a};return yu.runKernel(Ki,o,r)}});const of=Ru({prelu_:function(e,t){const n={x:Tu(e,"x","prelu"),alpha:Tu(t,"alpha","prelu")};return yu.runKernel(Xi,n)}});var sf=n(334);class cf{constructor(e,t,n,a,r){this.mean=e,this.stdDev=t,this.dtype=n,this.nextVal=NaN,this.truncated=a,this.truncated&&(this.upper=this.mean+2*this.stdDev,this.lower=this.mean-2*this.stdDev);const o=r||Math.random();this.random=sf.alea(o.toString())}nextValue(){if(!isNaN(this.nextVal)){const e=this.nextVal;return this.nextVal=NaN,e}let e,t,n=!1;for(;!n;){let a,r,o;do{a=2*this.random()-1,r=2*this.random()-1,o=a*a+r*r}while(o>=1||0===o);const s=Math.sqrt(-2*Math.log(o)/o);e=this.mean+this.stdDev*a*s,t=this.mean+this.stdDev*r*s,this.truncated&&!this.isValidTruncated(e)||(n=!0)}return this.truncated&&!this.isValidTruncated(t)||(this.nextVal=this.convertValue(t)),this.convertValue(e)}convertValue(e){return null==this.dtype||"float32"===this.dtype?e:Math.round(e)}isValidTruncated(e){return e<=this.upper&&e>=this.lower}}class lf{constructor(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,n=arguments.length>2?arguments[2]:void 0,a=arguments.length>3?arguments[3]:void 0;if(this.canReturnFloat=()=>null==this.dtype||"float32"===this.dtype,this.min=e,this.range=t-e,this.dtype=n,null==a&&(a=Math.random()),"number"===typeof a&&(a=a.toString()),!this.canReturnFloat()&&this.range<=1)throw new Error("The difference between ".concat(e," - ").concat(t," <= 1 and dtype is not float"));this.random=sf.alea(a)}convertValue(e){return this.canReturnFloat()?e:Math.round(e)}nextValue(){return this.convertValue(this.min+this.range*this.random())}}const uf=Ru({randomNormal_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,a=arguments.length>3?arguments[3]:void 0,r=arguments.length>4?arguments[4]:void 0;if(Do(e),null!=a&&"bool"===a)throw new Error("Unsupported data type ".concat(a));const o=new cf(t,n,a,!1,r),s=Nd(e,a);for(let i=0;i<s.values.length;i++)s.values[i]=o.nextValue();return s.toTensor()}});const df=Ru({randomUniform_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"float32",r=arguments.length>4?arguments[4]:void 0;Do(e);const o=Nd(e,a),s=new lf(t,n,null,r);for(let i=0;i<o.values.length;i++)o.values[i]=s.nextValue();return o.toTensor()}});function hf(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"float32";if(0===n)throw new Error("Cannot have a step of zero");const r={start:e,stop:t,step:n,dtype:a};return yu.runKernel($i,{},r)}const pf=Ru({relu_:function(e){const t={x:Tu(e,"x","relu")};return yu.runKernel(nc,t)}});const ff=Ru({reverse_:function(e,t){const n={x:Tu(e,"x","reverse")},a={dims:t};return yu.runKernel(lc,n,a)}});const mf=Ru({selu_:function(e){const t={x:Tu(e,"x","selu")};return yu.runKernel(gc,t)}});const gf=Ru({separableConv2d_:function(e,t,n,a,r){let o=arguments.length>5&&void 0!==arguments[5]?arguments[5]:[1,1],s=arguments.length>6&&void 0!==arguments[6]?arguments[6]:"NHWC";const i=Tu(e,"x","separableConv2d"),c=Tu(t,"depthwiseFilter","separableConv2d"),l=Tu(n,"pointwiseFilter","separableConv2d");let u=i,d=!1;if(3===i.rank&&(d=!0,u=Qh(i,[1,i.shape[0],i.shape[1],i.shape[2]])),"NCHW"===s)throw new Error("separableConv2d currently does not support dataFormat NCHW; only NHWC is supported");so(4===u.rank,(()=>"Error in separableConv2d: input must be rank 4, but got "+"rank ".concat(u.rank,"."))),so(4===c.rank,(()=>"Error in separableConv2d: depthwise filter must be rank 4, but "+"got rank ".concat(c.rank,"."))),so(4===l.rank,(()=>"Error in separableConv2d: pointwise filter must be rank 4, but "+"got rank ".concat(c.rank,"."))),so(1===l.shape[0],(()=>"Error in separableConv2d: the first dimension of pointwise filter "+" must be 1, but got ".concat(l.shape[0],"."))),so(1===l.shape[1],(()=>"Error in separableConv2d: the second dimension of pointwise "+"filter must be 1, but got ".concat(l.shape[1],".")));const h=c.shape[2],p=c.shape[3];so(l.shape[2]===h*p,(()=>"Error in separableConv2d: the third dimension of pointwise filter "+"must be ".concat(h*p,", ")+"but got ".concat(l.shape[2],".")));const f=yp(u,c,a,r,s,o),m=up(f,l,1,"valid",s);return d?Qh(m,[m.shape[1],m.shape[2],m.shape[3]]):m}});const bf=Ru({sigmoid_:function(e){const t={x:Tu(e,"x","sigmoid","float32")};return yu.runKernel(wc,t)}});const yf=Ru({slice_:function(e,t,n){const a=Tu(e,"x","slice","string_or_numeric");if(0===a.rank)throw new Error("Slicing scalar is not possible");const r={x:a},o={begin:t,size:n};return yu.runKernel(bc,r,o)}});const xf=Ru({slice1d_:function(e,t,n){const a=Tu(e,"x","slice1d");return so(1===a.rank,(()=>"slice1d expects a rank-1 tensor, but got a rank-".concat(a.rank," tensor"))),yf(a,[t],[n])}});const vf=Ru({slice2d_:function(e,t,n){const a=Tu(e,"x","slice2d");return so(2===a.rank,(()=>"slice2d expects a rank-2 tensor, but got a rank-".concat(a.rank," tensor"))),yf(a,t,n)}});const wf=Ru({slice3d_:function(e,t,n){const a=Tu(e,"x","slice3d");return so(3===a.rank,(()=>"slice3d expects a rank-3 tensor, but got a rank-".concat(a.rank," tensor"))),yf(a,t,n)}});const kf=Ru({slice4d_:function(e,t,n){const a=Tu(e,"x","slice4d");return so(4===a.rank,(()=>"slice4d expects a rank-4 tensor, but got a rank-".concat(a.rank," tensor"))),yf(a,t,n)}});const If=Ru({softmax_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:-1;const n=Tu(e,"logits","softmax","float32");if(-1===t&&(t=n.rank-1),t!==n.rank-1)throw Error("Softmax along a non-last dimension is not yet supported. "+"Logits was rank ".concat(n.rank," and dim was ").concat(t));const a={logits:n},r={dim:t};return yu.runKernel(Tc,a,r)}});const Sf=Ru({softplus_:function(e){const t={x:Tu(e,"x","softplus")};return yu.runKernel(kc,t)}});const Nf=Ru({split_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;const a={x:Tu(e,"x","split")},r={numOrSizeSplits:t,axis:n};return yu.runKernel(Cc,a,r)}});const Cf=Ru({squeeze_:function(e,t){const n=Tu(e,"x","squeeze","string_or_numeric");return Qh(n,yo(n.shape,t).newShape)}});const Tf=Ru({stack_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const n=Eu(e,"tensors","stack","string_or_numeric");so(n.length>=1,(()=>"Pass at least one tensor to tf.stack")),n.length>0&&so(t<=n[0].rank,(()=>"Axis must be <= rank of the tensor"));const a=n,r={axis:t};return yu.runKernel(ji,a,r)}});const Ef=Ru({tanh_:function(e){const t={x:Tu(e,"x","tanh","float32")};return yu.runKernel(Uc,t)}});function Rf(e,t){co(e);const n=Su(e,t);if(1!==n.length)throw new Error("tensor1d() requires values to be a flat/TypedArray");return Au(e,null,n,t)}function _f(e,t,n){if(co(e),null!=t&&2!==t.length)throw new Error("tensor2d() requires shape to have two numbers");const a=Su(e,n);if(2!==a.length&&1!==a.length)throw new Error("tensor2d() requires values to be number[][] or flat/TypedArray");if(1===a.length&&null==t)throw new Error("tensor2d() requires shape to be provided when `values` are a flat/TypedArray");return Au(e,t,a,n)}const Af=Ru({truncatedNormal_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,a=arguments.length>3?arguments[3]:void 0,r=arguments.length>4?arguments[4]:void 0;if(Do(e),null!=a&&"bool"===a)throw new Error("Unsupported data type $ { dtype }");const o=new cf(t,n,a,!0,r),s=Nd(e,a);for(let i=0;i<s.values.length;i++)s.values[i]=o.nextValue();return s.toTensor()}});const Ff=Ru({unstack_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const n=Tu(e,"x","unstack","string_or_numeric");so(t>=-n.shape.length&&t<n.shape.length,(()=>"Axis = ".concat(t," is not in [-").concat(n.shape.length,", ").concat(n.shape.length,")")));const a={value:n},r={axis:t};return yu.runKernel(Xc,a,r)}});const Of=Ru({where_:function(e,t,n){const a=Tu(t,"a","where"),r=Tu(n,"b","where"),o=Tu(e,"condition","where","bool"),s=Zd(Zd(o.shape,a.shape),r.shape),i={condition:ap(o,s),t:ap(a,s),e:ap(r,s)};return yu.runKernel(mc,i)}});const Df=Ru({imag_:function(e){const t={input:Tu(e,"input","imag")};return yu.runKernel(li,t)}});const Mf=Ru({real_:function(e){const t={input:Tu(e,"input","real")};return yu.runKernel(ec,t)}});const Lf=Ru({transpose_:function(e,t,n){const a=Tu(e,"x","transpose");if(null==t&&(t=a.shape.map(((e,t)=>t)).reverse()),so(a.rank===t.length,(()=>"Error in transpose: rank of input ".concat(a.rank," ")+"must match length of perm ".concat(t,"."))),t.forEach((e=>{so(e>=0&&e<a.rank,(()=>"All entries in 'perm' must be between 0 and ".concat(a.rank-1)+" but got ".concat(t)))})),a.rank<=1)return a.clone();const r={x:a},o={perm:t};return"complex64"===a.dtype?Lu((()=>{let e=Mf(a),t=Df(a);return e=yu.runKernel(Kc,{x:e},o),t=yu.runKernel(Kc,{x:t},o),n&&(t=Zp(t)),_u(e,t)})):yu.runKernel(Kc,r,o)}});const Pf=Ru({dropout_:function(e,t,n,a){const r=Tu(e,"x","dropout");if(so("float32"===r.dtype,(()=>"x has to be a floating point tensor since it's going to be "+"scaled, but got a ".concat(r.dtype," tensor instead."))),so(t>=0&&t<1,(()=>"rate must be a float in the range [0, 1), but got ".concat(t,"."))),0===t)return e instanceof Jl?r.clone():r;const o=function(e,t){if(null==t)return e.shape.slice();if(uo(e.shape,t))return t;if(e.shape.length===t.length){const n=[];for(let a=0;a<e.shape.length;a++)null==t[a]&&null!=e.shape[a]?n.push(e.shape[a]):n.push(t[a]);return n}return t}(r,n),s=1-t,i=_d(Np(Ed(df(o,0,1,"float32",a),s)),s);return Ad(r,i)}});const zf=Ru({fft_:function(e){so("complex64"===e.dtype,(()=>"The dtype for tf.spectral.fft() must be complex64 "+"but got ".concat(e.dtype,".")));const t={input:e};return yu.runKernel(Js,t)}});const Bf=Ru({rfft_:function(e,t){so("float32"===e.dtype,(()=>"The dtype for rfft() must be real value but got ".concat(e.dtype)));let n=e.shape[e.shape.length-1];const a=e.size/n;let r;if(null!=t&&t<n){const a=e.shape.map((e=>0)),o=e.shape.map((e=>e));o[e.shape.length-1]=t,r=yf(e,a,o),n=t}else if(null!=t&&t>n){const a=e.shape.map((e=>e));a[e.shape.length-1]=t-n,r=op([e,tf(a)],e.shape.length-1),n=t}else r=e;const o=Dd(r),s=Qh(_u(r,o),[a,n]),i=zf(s),c=Math.floor(n/2)+1,l=Mf(i),u=Df(i),d=Nf(l,[c,n-c],l.shape.length-1),h=Nf(u,[c,n-c],u.shape.length-1),p=r.shape.slice();return p[r.shape.length-1]=c,Qh(_u(d[0],h[0]),p)}});const Wf=Ru({ifft_:function(e){so("complex64"===e.dtype,(()=>"The dtype for tf.spectral.ifft() must be complex64 "+"but got ".concat(e.dtype,".")));const t={input:e};return yu.runKernel(ci,t)}});const Vf=Ru({irfft_:function(e){const t=e.shape[e.shape.length-1],n=e.size/t;let a;if(t<=2){const r=Qh(e,[n,t]);a=Wf(r)}else{const r=[n,2*(t-1)],o=Qh(Mf(e),[n,t]),s=Qh(Df(e),[n,t]),i=ff(yf(o,[0,1],[n,t-2]),1),c=Ad(ff(yf(s,[0,1],[n,t-2]),1),Ld(-1)),l=op([o,i],1),u=op([s,c],1),d=Qh(_u(l,u),[r[0],r[1]]);a=Wf(d)}if(a=Mf(a),3===e.rank&&0!==e.shape[0]){const t=a,n=e.shape[0];a=Qh(a,[n,a.shape[0]/n,a.shape[1]]),t.dispose()}return a}});const Uf=Ru({conv2DBackpropFilter_:function(e,t,n,a,r){let o=arguments.length>5&&void 0!==arguments[5]?arguments[5]:"NHWC",s=arguments.length>6?arguments[6]:void 0,i=e;3===e.rank&&(i=Qh(e,[1,e.shape[0],e.shape[1],e.shape[2]]));let c=t;3===c.rank&&(c=Qh(t,[1,t.shape[0],t.shape[1],t.shape[2]])),so(4===i.rank,(()=>"Error in conv2dDerFilter: input must be rank 4, but got shape "+"".concat(i.shape,"."))),so(4===c.rank,(()=>"Error in conv2dDerFilter: dy must be rank 4, but got shape "+"".concat(c.shape,"."))),so(4===n.length,(()=>"Error in conv2dDerFilter: filterShape must be length 4, but got "+"".concat(n,".")));const l="NHWC"===o?i.shape[3]:i.shape[1],u="NHWC"===o?c.shape[3]:c.shape[1];so(l===n[2],(()=>"Error in conv2dDerFilter: depth of input ".concat(l,") must ")+"match input depth in filter (".concat(n[2],"."))),so(u===n[3],(()=>"Error in conv2dDerFilter: depth of dy (".concat(u,") must ")+"match output depth for filter (".concat(n[3],")."))),Yh("conv2dDerFilter",r,s);const d={x:i,dy:c},h={strides:a,pad:r,dataFormat:o,dimRoundingMode:s,filterShape:n};return yu.runKernel(ks,d,h)}});const Gf=Ru({relu6_:function(e){const t={x:Tu(e,"x","relu6")};return yu.runKernel(cc,t)}});const Hf=Ru({step_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const n={x:Tu(e,"x","step")},a={alpha:t};return yu.runKernel(Jc,n,a)}});function jf(e,t,n){if(null==n||"linear"===n)return e;if("relu"===n)return Ad(e,Hf(t));throw new Error("Cannot compute gradient for fused activation ".concat(n,"."))}function Kf(e,t){let n=t;const a=Jd(e.shape,t.shape);return a.length>0&&(n=Op(n,a)),Qh(n,e.shape)}function qf(e,t,n,a){if("linear"===t)return e;if("relu"===t)return pf(e);if("elu"===t)return xp(e);if("relu6"===t)return Gf(e);if("prelu"===t)return of(e,n);if("leakyrelu"===t)return Rp(e,a);if("sigmoid"===t)return bf(e);throw new Error("Unknown fused activation ".concat(t,"."))}const Xf=(e,t)=>!(e>0)||"linear"===t;const Yf=Ru({fusedConv2d_:function(e){let{x:t,filter:n,strides:a,pad:r,dataFormat:o="NHWC",dilations:s=[1,1],dimRoundingMode:i,bias:c,activation:l="linear",preluActivationWeights:u,leakyreluAlpha:d}=e;if(l=l||"linear",!1===Xf(yu.state.gradientDepth,l)){so("NHWC"===o,(()=>"Error in fused conv2d: got dataFormat of ".concat(o," but ")+"only NHWC is currently supported for the case of gradient depth is 0 and the activation is not linear."));let e=up(t,n,a,r,o,s,i);return null!=c&&(e=Ed(e,c)),qf(e,l,u,d)}const h=Tu(t,"x","conv2d","float32"),p=Tu(n,"filter","conv2d","float32");let f=h,m=!1;3===h.rank&&(m=!0,f=Qh(h,[1,h.shape[0],h.shape[1],h.shape[2]])),so(4===f.rank,(()=>"Error in fused conv2d: input must be rank 4, but got rank "+"".concat(f.rank,"."))),so(4===p.rank,(()=>"Error in fused conv2d: filter must be rank 4, but got rank "+"".concat(p.rank,"."))),Yh("fused conv2d",r,i);const g="NHWC"===o?f.shape[3]:f.shape[1];so(p.shape[2]===g,(()=>"Error in conv2d: depth of input (".concat(g,") must match ")+"input depth for filter ".concat(p.shape[2],"."))),so(Kh(a,s),(()=>"Error in conv2D: Either strides or dilations must be 1. "+"Got strides ".concat(a," and dilations '").concat(s,"'")));const b=zh(f.shape,p.shape,a,s,r,i);let y,x;if(null!=c&&(y=Tu(c,"bias","fused conv2d"),[y]=uu(y,h),"NHWC"===o?Zd(b.outShape,y.shape):(so(y.shape.length<=1,(()=>"Error in fused conv2d: only supports scalar or 1-D Tensor bias for NCHW format but got the bias of "+"rank-".concat(y.shape.length,"."))),so(0===y.shape.length||y.shape[0]===b.outChannels||1===y.shape[0],(()=>"Error in fused conv2d: bias shape (".concat(y.shape,") is not ")+"compatible with the number of output channels "+"(".concat(b.outChannels,")"))))),null!=u){const e=u.shape;if(so(e.length<=1||3===e.length,(()=>"Error in fused conv2d: only supports scalar, 1-D Tensor or 3-D Tensor PReLU activation weights but got a tensor of "+"rank-".concat(e.length,"."))),1===e.length)so(1===e[0]||e[0]===b.outChannels,(()=>"Error in fused conv2d: PReLU activation weights "+"(".concat(e,") is not compatible with the number of output ")+"channels (".concat(b.outChannels,").")));else if(3===e.length)try{Zd(e,b.outShape)}catch(D){const n="Error in fused conv2d: PReLU activation weights (".concat(e,") ")+"is not compatible with the output shape of the conv2d "+"(".concat(b.outShape,").");throw Error(n)}x=Tu(u,"prelu weights","fused conv2d")}const v=(e,t)=>{so("NHWC"===o,(()=>"Error in gradient of fused conv2D: got dataFormat of ".concat(o," but only NHWC is currently supported.")));const[n,i,c,u]=t,d=jf(e,c,l);so(jh(s),(()=>"Error in gradient of fused conv2D: dilation rates greater than 1 "+"are not yet supported in gradients. Got dilations '".concat(s,"'")));const h=[hp(i.shape,d,n,a,r),Uf(i,d,n.shape,a,r)];if(null!=u){const e=Kf(u,d);h.push(e)}return h},w={x:f,filter:p,bias:y,preluActivationWeights:x},k={strides:a,pad:r,dataFormat:o,dilations:s,dimRoundingMode:i,activation:l,leakyreluAlpha:d};if(null==c){const e=Md(((e,t,n)=>{let a=yu.runKernel(tl,w,k);return n([t,e,a]),m&&(a=Qh(a,[a.shape[1],a.shape[2],a.shape[3]])),{value:a,gradFunc:v}}));return e(f,p)}{const e=Md(((e,t,n,a)=>{let r=yu.runKernel(tl,w,k);return a([t,e,r,n]),m&&(r=Qh(r,[r.shape[1],r.shape[2],r.shape[3]])),{value:r,gradFunc:v}}));return e(f,p,y)}}});const Qf=Ru({depthwiseConv2dNativeBackpropFilter_:function(e,t,n,a,r){let o=arguments.length>5&&void 0!==arguments[5]?arguments[5]:[1,1],s=arguments.length>6?arguments[6]:void 0,i=e;3===e.rank&&(i=Qh(e,[1,e.shape[0],e.shape[1],e.shape[2]]));let c=t;3===c.rank&&(c=Qh(t,[1,t.shape[0],t.shape[1],t.shape[2]]));const l={x:i,dy:c},u={strides:a,pad:r,dimRoundingMode:s,dilations:o,filterShape:n};return yu.runKernel(Ms,l,u)}});const Jf=Ru({depthwiseConv2dNativeBackpropInput_:function(e,t,n,a,r){let o=arguments.length>5&&void 0!==arguments[5]?arguments[5]:[1,1],s=arguments.length>6?arguments[6]:void 0,i=t,c=!1;3===t.rank&&(c=!0,i=Qh(t,[1,t.shape[0],t.shape[1],t.shape[2]]));const l={dy:i,filter:n},u={strides:a,pad:r,dimRoundingMode:s,dilations:o,inputShape:e},d=yu.runKernel(Ls,l,u);return c?Qh(d,[d.shape[1],d.shape[2],d.shape[3]]):d}});const Zf=Ru({fusedMatMul_:function(e){let{a:t,b:n,transposeA:a=!1,transposeB:r=!1,bias:o,activation:s="linear",preluActivationWeights:i,leakyreluAlpha:c=.2}=e;if(!1===Xf(yu.state.gradientDepth,s)){let e=jp(t,n,a,r);return null!=o&&(e=Ed(e,o)),qf(e,s,i,c)}let l=Tu(t,"a","fused matMul"),u=Tu(n,"b","fused matMul");[l,u]=uu(l,u);const d=a?l.shape[l.rank-2]:l.shape[l.rank-1],h=r?u.shape[u.rank-1]:u.shape[u.rank-2],p=a?l.shape[l.rank-1]:l.shape[l.rank-2],f=r?u.shape[u.rank-2]:u.shape[u.rank-1],m=l.shape.slice(0,-2),g=u.shape.slice(0,-2),b=lo(m),y=lo(g);so(d===h,(()=>"Error in fused matMul: inner shapes (".concat(d,") and (")+"".concat(h,") of Tensors with shapes ").concat(l.shape," and ")+"".concat(u.shape," and transposeA=").concat(a)+" and transposeB=".concat(r," must match.")));const x=Zd(l.shape.slice(0,-2),u.shape.slice(0,-2)).concat([p,f]),v=Qh(l,a?[b,d,p]:[b,p,d]),w=Qh(u,r?[y,f,h]:[y,h,f]);let k,I;null!=o&&(k=Tu(o,"bias","fused matMul"),[k]=uu(k,l),Zd(x,k.shape)),null!=i&&(I=Tu(i,"prelu weights","fused matMul"));const S=(e,t)=>{const[n,i,c,l]=t,u=jf(Qh(e,c.shape),c,s);let d,h;if(a||r?!a&&r?(d=jp(u,i,!1,!1),h=jp(u,n,!0,!1)):a&&!r?(d=jp(i,u,!1,!0),h=jp(n,u,!1,!1)):(d=jp(i,u,!0,!0),h=jp(u,n,!0,!0)):(d=jp(u,i,!1,!0),h=jp(n,u,!0,!1)),null!=o){return[d,h,Kf(l,u)]}return[d,h]},N={a:v,b:w,bias:k,preluActivationWeights:I},C={transposeA:a,transposeB:r,activation:s,leakyreluAlpha:c};if(null==o){const e=Md(((e,t,n)=>{const a=yu.runKernel(el,N,C);return n([e,t,a]),{value:Qh(a,x),gradFunc:S}}));return e(v,w)}{const e=Md(((e,t,n,a)=>{const r=yu.runKernel(el,N,C);return a([e,t,r,n]),{value:Qh(r,x),gradFunc:S}}));return e(v,w,k)}}});const $f=Ru({cropAndResize_:function(e,t,n,a){let r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"bilinear",o=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0;const s=Tu(e,"image","cropAndResize"),i=Tu(t,"boxes","cropAndResize","float32"),c=Tu(n,"boxInd","cropAndResize","int32"),l=i.shape[0];so(4===s.rank,(()=>"Error in cropAndResize: image must be rank 4,"+"but got rank ".concat(s.rank,"."))),so(2===i.rank&&4===i.shape[1],(()=>"Error in cropAndResize: boxes must be have size [".concat(l,",4] ")+"but had shape ".concat(i.shape,"."))),so(1===c.rank&&c.shape[0]===l,(()=>"Error in cropAndResize: boxInd must be have size [".concat(l,"] ")+"but had shape ".concat(i.shape,"."))),so(2===a.length,(()=>"Error in cropAndResize: cropSize must be of length 2, but got "+"length ".concat(a.length,"."))),so(a[0]>=1&&a[1]>=1,(()=>"cropSize must be atleast [1,1], but was ".concat(a))),so("bilinear"===r||"nearest"===r,(()=>"method must be bilinear or nearest, but was ".concat(r)));const u={image:s,boxes:i,boxInd:c},d={method:r,extrapolationValue:o,cropSize:a};return yu.runKernel(As,u,d)}});const em=Ru({flipLeftRight_:function(e){const t=Tu(e,"image","flipLeftRight","float32");so(4===t.rank,(()=>"Error in flipLeftRight: image must be rank 4,"+"but got rank ".concat(t.rank,".")));const n={image:t};return yu.runKernel($s,n,{})}});const tm=Ru({grayscaleToRGB_:function(e){const t=Tu(e,"image","grayscaleToRGB"),n=t.rank-1,a=t.shape[n];so(t.rank>=2,(()=>"Error in grayscaleToRGB: images must be at least rank 2, "+"but got rank ".concat(t.rank,"."))),so(1===a,(()=>"Error in grayscaleToRGB: last dimension of a grayscale image "+"should be size 1, but got size ".concat(a,".")));const r=new Array(t.rank);return r.fill(1,0,n),r[n]=3,Ip(t,r)}});const nm=Ru({einsum_:function(e){for(var t=arguments.length,n=new Array(t>1?t-1:0),a=1;a<t;a++)n[a-1]=arguments[a];const r=n.map(((e,t)=>Tu(e,"tensors".concat(t),"einsum"))),o={equation:e};return yu.runKernel(Gs,r,o)}});const am=Ru({rgbToGrayscale_:function(e){const t=Tu(e,"image","RGBToGrayscale"),n=t.rank-1,a=t.shape[n];so(t.rank>=2,(()=>"Error in RGBToGrayscale: images must be at least rank 2, "+"but got rank ".concat(t.rank,"."))),so(3===a,(()=>"Error in RGBToGrayscale: last dimension of an RGB image "+"should be size 3, but got size ".concat(a,".")));const r=t.dtype,o=Cd(t,"float32"),s=Rf([.2989,.587,.114]);let i;switch(t.rank){case 2:i=nm("ij,j->i",o,s);break;case 3:i=nm("ijk,k->ij",o,s);break;case 4:i=nm("ijkl,l->ijk",o,s);break;case 5:i=nm("ijklm,m->ijkl",o,s);break;case 6:i=nm("ijklmn,n->ijklm",o,s);break;default:throw new Error("Not a valid tensor rank.")}return i=kp(i,-1),Cd(i,r)}});const rm=Ru({rotateWithOffset_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:.5;const r=Tu(e,"image","rotateWithOffset","float32");so(4===r.rank,(()=>"Error in rotateWithOffset: image must be rank 4,"+"but got rank ".concat(r.rank,".")));const o={image:r},s={radians:t,fillValue:n,center:a};return yu.runKernel($c,o,s)}});function om(e,t,n,a,r,o){null==a&&(a=.5),null==r&&(r=Number.NEGATIVE_INFINITY),null==o&&(o=0);const s=e.shape[0];return n=Math.min(n,s),so(0<=a&&a<=1,(()=>"iouThreshold must be in [0, 1], but was '".concat(a,"'"))),so(2===e.rank,(()=>"boxes must be a 2D tensor, but was of rank '".concat(e.rank,"'"))),so(4===e.shape[1],(()=>"boxes must have 4 columns, but 2nd dimension was ".concat(e.shape[1]))),so(1===t.rank,(()=>"scores must be a 1D tensor")),so(t.shape[0]===s,(()=>"scores has incompatible shape with boxes. Expected ".concat(s,", ")+"but was ".concat(t.shape[0]))),so(0<=o&&o<=1,(()=>"softNmsSigma must be in [0, 1], but was '".concat(o,"'"))),{maxOutputSize:n,iouThreshold:a,scoreThreshold:r,softNmsSigma:o}}const sm=Ru({nonMaxSuppression_:function(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:.5,r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:Number.NEGATIVE_INFINITY;const o=Tu(e,"boxes","nonMaxSuppression","float32"),s=Tu(t,"scores","nonMaxSuppression","float32"),i=om(o,s,n,a,r);n=i.maxOutputSize,a=i.iouThreshold,r=i.scoreThreshold;const c={maxOutputSize:n,iouThreshold:a,scoreThreshold:r};return yu.runKernel(Wi,{boxes:o,scores:s},c)}});function im(e,t,n){const a=function(e,t,n){return function(e,t,n){let a=0,r=e.length,o=0,s=!1;for(;a<r;){o=a+(r-a>>>1);const i=n(t,e[o]);i>0?a=o+1:(r=o,s=!i)}return s?a:-a-1}(e,t,n||cm)}(e,t,n),r=a<0?-(a+1):a;e.splice(r,0,t)}function cm(e,t){return e>t?1:e<t?-1:0}function lm(e,t,n,a,r){return hm(e,t,n,a,r,0)}function um(e,t,n,a,r,o){return hm(e,t,n,a,r,0,!1,o,!0)}function dm(e,t,n,a,r,o){return hm(e,t,n,a,r,o,!0)}function hm(e,t,n,a,r,o){let s=arguments.length>6&&void 0!==arguments[6]&&arguments[6],i=arguments.length>7&&void 0!==arguments[7]&&arguments[7],c=arguments.length>8&&void 0!==arguments[8]&&arguments[8];const l=[];for(let g=0;g<t.length;g++)t[g]>r&&l.push({score:t[g],boxIndex:g,suppressBeginIndex:0});l.sort(mm);const u=o>0?-.5/o:0,d=[],h=[];for(;d.length<n&&l.length>0;){const t=l.pop(),{score:n,boxIndex:o,suppressBeginIndex:s}=t;if(n<r)break;let i=!1;for(let c=d.length-1;c>=s;--c){const n=pm(e,o,d[c]);if(n>=a){i=!0;break}if(t.score=t.score*fm(a,u,n),t.score<=r)break}t.suppressBeginIndex=d.length,i||(t.score===n?(d.push(o),h.push(t.score)):t.score>r&&im(l,t,mm))}const p=d.length,f=n-p;i&&f>0&&(d.push(...new Array(f).fill(0)),h.push(...new Array(f).fill(0)));const m={selectedIndices:d};return s&&(m.selectedScores=h),c&&(m.validOutputs=p),m}function pm(e,t,n){const a=e.subarray(4*t,4*t+4),r=e.subarray(4*n,4*n+4),o=Math.min(a[0],a[2]),s=Math.min(a[1],a[3]),i=Math.max(a[0],a[2]),c=Math.max(a[1],a[3]),l=Math.min(r[0],r[2]),u=Math.min(r[1],r[3]),d=Math.max(r[0],r[2]),h=Math.max(r[1],r[3]),p=(i-o)*(c-s),f=(d-l)*(h-u);if(p<=0||f<=0)return 0;const m=Math.max(o,l),g=Math.max(s,u),b=Math.min(i,d),y=Math.min(c,h),x=Math.max(b-m,0)*Math.max(y-g,0);return x/(p+f-x)}function fm(e,t,n){const a=Math.exp(t*n*n);return n<=e?a:0}function mm(e,t){return e.score-t.score||e.score===t.score&&t.boxIndex-e.boxIndex}const gm=async function(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:.5,r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:Number.NEGATIVE_INFINITY;const o=Tu(e,"boxes","nonMaxSuppressionAsync"),s=Tu(t,"scores","nonMaxSuppressionAsync"),i=om(o,s,n,a,r);n=i.maxOutputSize,a=i.iouThreshold,r=i.scoreThreshold;const c=await Promise.all([o.data(),s.data()]),l=c[0],u=c[1],{selectedIndices:d}=lm(l,u,n,a,r);return o!==e&&o.dispose(),s!==t&&s.dispose(),Rf(d,"int32")};const bm=Ru({nonMaxSuppressionWithScore_:function(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:.5,r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:Number.NEGATIVE_INFINITY,o=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0;const s=Tu(e,"boxes","nonMaxSuppression"),i=Tu(t,"scores","nonMaxSuppression"),c=om(s,i,n,a,r,o);n=c.maxOutputSize,a=c.iouThreshold,r=c.scoreThreshold,o=c.softNmsSigma;const l={boxes:s,scores:i},u={maxOutputSize:n,iouThreshold:a,scoreThreshold:r,softNmsSigma:o},d=yu.runKernel(Ui,l,u);return{selectedIndices:d[0],selectedScores:d[1]}}});const ym=async function(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:.5,r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:Number.NEGATIVE_INFINITY,o=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0;const s=Tu(e,"boxes","nonMaxSuppressionAsync"),i=Tu(t,"scores","nonMaxSuppressionAsync"),c=om(s,i,n,a,r,o);n=c.maxOutputSize,a=c.iouThreshold,r=c.scoreThreshold,o=c.softNmsSigma;const l=await Promise.all([s.data(),i.data()]),u=l[0],d=l[1],{selectedIndices:h,selectedScores:p}=dm(u,d,n,a,r,o);return s!==e&&s.dispose(),i!==t&&i.dispose(),{selectedIndices:Rf(h,"int32"),selectedScores:Rf(p)}};const xm=Ru({nonMaxSuppressionPadded_:function(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:.5,r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:Number.NEGATIVE_INFINITY,o=arguments.length>5&&void 0!==arguments[5]&&arguments[5];const s=Tu(e,"boxes","nonMaxSuppression"),i=Tu(t,"scores","nonMaxSuppression"),c=om(s,i,n,a,r,null),l={boxes:s,scores:i},u={maxOutputSize:c.maxOutputSize,iouThreshold:c.iouThreshold,scoreThreshold:c.scoreThreshold,padToMaxOutputSize:o},d=yu.runKernel(Vi,l,u);return{selectedIndices:d[0],validOutputs:d[1]}}});const vm=async function(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:.5,r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:Number.NEGATIVE_INFINITY,o=arguments.length>5&&void 0!==arguments[5]&&arguments[5];const s=Tu(e,"boxes","nonMaxSuppressionAsync"),i=Tu(t,"scores","nonMaxSuppressionAsync"),c=om(s,i,n,a,r,null),l=c.maxOutputSize,u=c.iouThreshold,d=c.scoreThreshold,[h,p]=await Promise.all([s.data(),i.data()]),{selectedIndices:f,validOutputs:m}=um(h,p,l,u,d,o);return s!==e&&s.dispose(),i!==t&&i.dispose(),{selectedIndices:Rf(f,"int32"),validOutputs:Ld(m,"int32")}};const wm=Ru({resizeBilinear_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],a=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const r=Tu(e,"images","resizeBilinear");so(3===r.rank||4===r.rank,(()=>"Error in resizeBilinear: x must be rank 3 or 4, but got "+"rank ".concat(r.rank,"."))),so(2===t.length,(()=>"Error in resizeBilinear: new shape must 2D, but got shape "+"".concat(t,"."))),so(!1===a||!1===n,(()=>"Error in resizeBilinear: If halfPixelCenters is true, alignCorners must be false."));let o=r,s=!1;3===r.rank&&(s=!0,o=Qh(r,[1,r.shape[0],r.shape[1],r.shape[2]]));const[]=t,i={images:o},c={alignCorners:n,halfPixelCenters:a,size:t},l=yu.runKernel(sc,i,c);return s?Qh(l,[l.shape[1],l.shape[2],l.shape[3]]):l}});const km=Ru({resizeNearestNeighbor_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],a=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const r=Tu(e,"images","resizeNearestNeighbor");so(3===r.rank||4===r.rank,(()=>"Error in resizeNearestNeighbor: x must be rank 3 or 4, but got "+"rank ".concat(r.rank,"."))),so(2===t.length,(()=>"Error in resizeNearestNeighbor: new shape must 2D, but got shape "+"".concat(t,"."))),so("float32"===r.dtype||"int32"===r.dtype,(()=>"`images` must have `int32` or `float32` as dtype")),so(!1===a||!1===n,(()=>"Error in resizeNearestNeighbor: If halfPixelCenters is true, alignCorners must be false."));let o=r,s=!1;3===r.rank&&(s=!0,o=Qh(r,[1,r.shape[0],r.shape[1],r.shape[2]]));const[]=t,i={images:o},c={alignCorners:n,halfPixelCenters:a,size:t},l=yu.runKernel(rc,i,c);return s?Qh(l,[l.shape[1],l.shape[2],l.shape[3]]):l}});const Im=Ru({bincount_:function(e,t,n){const a=Tu(e,"x","bincount"),r=Tu(t,"weights","bincount");so("int32"===a.dtype,(()=>"Error in bincount: input "+"dtype must be int32, but got ".concat(a.dtype))),so(n>=0,(()=>"size must be non-negative, but got ".concat(n,"."))),so(r.size===a.size||0===r.size,(()=>"Error in bincount: weights must have the same size as input or"+"0-length, but got input shape: ".concat(a.shape,", weights shape: ")+"".concat(r.shape,".")));const o={x:a,weights:r},s={size:n};return yu.runKernel(hs,o,s)}});const Sm=Ru({lessEqual_:function(e,t){let n=Tu(e,"a","lessEqual","string_or_numeric"),a=Tu(t,"b","lessEqual","string_or_numeric");[n,a]=uu(n,a),Zd(n.shape,a.shape);const r={a:n,b:a};return yu.runKernel(mi,r)}});const Nm=Ru({round_:function(e){const t={x:Tu(e,"x","round")};return yu.runKernel(uc,t)}});const Cm=Ru({threshold_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"binary",n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:.5;const r=Tu(e,"image","threshold"),o=r.shape[0]*r.shape[1];let s,i,c,l,u=Ad(Rf([a]),255);if(so(3===r.rank,(()=>"Error in threshold: image must be rank 3,"+"but got rank ".concat(r.rank,"."))),so(3===r.shape[2]||1===r.shape[2],(()=>"Error in threshold: image color channel must be equal to 3 or 1"+"but got ".concat(r.shape[2],"."))),so("int32"===r.dtype||"float32"===r.dtype,(()=>"Error in dtype: image dtype must be int32 or float32,"+"but got dtype ".concat(r.dtype,"."))),so("otsu"===t||"binary"===t,(()=>"Method must be binary or otsu, but was ".concat(t))),3===r.shape[2]){[s,i,c]=Nf(r,[1,1,1],-1);const e=Ad(s,.2989),t=Ad(i,.587),n=Ad(c,.114);l=Ed(Ed(e,t),n)}else l=e;if("otsu"===t){u=function(e,t){let n,a,r,o,s,i,c=Rf([-1]),l=Rf([0]),u=Rf([0]);for(let d=0;d<e.size-1;d++){n=yf(e,0,d+1),a=yf(e,d+1),s=_d(Op(n),t),i=_d(Op(a),t);const h=Op(Ad(n,hf(0,n.size)));r=_d(h,Op(n));const p=Hd(a.shape,n.size),f=Ed(hf(0,a.size),p),m=Ad(a,f);o=_d(Op(m),Op(a));const g=qd(r,o),b=qd(r,o),y=Ad(s,i);u=Ad(Ad(y,g),b);const x=Tp(u,l);l=Of(x,u,l),c=Of(x,Rf([d]),c)}return c}(Im(Cd(Nm(l),"int32"),Fu([]),256),o)}const d=n?Sm(l,u):Tp(l,u);return Cd(Ad(d,255),"int32")}});const Tm=Ru({transform_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"nearest",a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"constant",r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:0,o=arguments.length>5?arguments[5]:void 0;const s=Tu(e,"image","transform","float32"),i=Tu(t,"transforms","transform","float32");so(4===s.rank,(()=>"Error in transform: image must be rank 4,"+"but got rank ".concat(s.rank,"."))),so(2===i.rank&&(i.shape[0]===s.shape[0]||1===i.shape[0])&&8===i.shape[1],(()=>"Error in transform: Input transform should be batch x 8 or 1 x 8")),so(null==o||2===o.length,(()=>"Error in transform: outputShape must be [height, width] or null, "+"but got ".concat(o,".")));const c={image:s,transforms:i},l={interpolation:n,fillMode:a,fillValue:r,outputShape:o};return yu.runKernel(jc,c,l)}});const Em=Ru({less_:function(e,t){let n=Tu(e,"a","less","string_or_numeric"),a=Tu(t,"b","less","string_or_numeric");[n,a]=uu(n,a),Zd(n.shape,a.shape);const r={a:n,b:a};return yu.runKernel(fi,r)}});const Rm=Ru({bandPart_:function(e,t,n){const a=Tu(e,"a","bandPart");so(a.rank>=2,(()=>"bandPart(): Rank must be at least 2, got ".concat(a.rank,".")));const r=a.shape,[o,s]=a.shape.slice(-2);let i,c;"number"===typeof t?(so(t%1===0,(()=>"bandPart(): numLower must be an integer, got ".concat(t,"."))),so(t<=o,(()=>"bandPart(): numLower (".concat(t,")")+" must not be greater than the number of rows (".concat(o,")."))),i=Tu(t<0?o:t,"numLower","bandPart")):(so("int32"===t.dtype,(()=>"bandPart(): numLower's dtype must be an int32.")),i=Of(Em(t,0),o,Qp(t,o))),"number"===typeof n?(so(n%1===0,(()=>"bandPart(): numUpper must be an integer, got ".concat(n,"."))),so(n<=s,(()=>"bandPart(): numUpper (".concat(n,")")+" must not be greater than the number of columns (".concat(s,")."))),c=Tu(n<0?s:n,"numUpper","bandPart")):(so("int32"===n.dtype,(()=>"bandPart(): numUpper's dtype must be an int32.")),c=Of(Em(n,0),s,Qp(n,s)));const l=Qh(hf(0,o,1,"int32"),[-1,1]),u=hf(0,s,1,"int32"),d=qd(l,u),h=Hp(Sm(d,i),Ep(d,Zp(c))),p=tf([o,s],a.dtype);return Qh(Tf(Ff(Qh(a,[-1,o,s])).map((e=>Of(h,e,p)))),r)}});function _m(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null;if(0===e.rank)return Yd(e);if(1!==e.rank&&null===n)return _m(Qh(e,[-1]),t,n);if(1===e.rank||"number"===typeof n||Array.isArray(n)&&1===n.length){if(1===t)return Op(Yd(e),n);if(t===1/0)return Fp(Yd(e),n);if(t===-1/0)return Yp(Yd(e),n);if("euclidean"===t||2===t)return Fd(Op(Kd(Yd(e),Ld(2,"int32")),n));throw new Error("Error in norm: invalid ord value: ".concat(t))}if(Array.isArray(n)&&2===n.length){if(1===t)return Fp(Op(Yd(e),n[0]),n[1]-1);if(t===1/0)return Fp(Op(Yd(e),n[1]),n[0]);if(t===-1/0)return Yp(Op(Yd(e),n[1]),n[0]);if("fro"===t||"euclidean"===t)return Fd(Op(Od(e),n));throw new Error("Error in norm: invalid ord value: ".concat(t))}throw new Error("Error in norm: invalid axis: ".concat(n))}const Am=Ru({norm_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"euclidean",n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null,a=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const r=_m(e=Tu(e,"x","norm"),t,n);let o=r.shape;if(a){const t=bo(n,e.shape);o=zp(r.shape,t)}return Qh(r,o)}});const Fm=Ru({gramSchmidt_:function(e){let t;if(Array.isArray(e)){t=!1,so(null!=e&&e.length>0,(()=>"Gram-Schmidt process: input must not be null, undefined, or empty"));const n=e[0].shape[0];for(let t=1;t<e.length;++t)so(e[t].shape[0]===n,(()=>"Gram-Schmidt: Non-unique lengths found in the input vectors: "+"(".concat(e[t].shape[0]," vs. ").concat(n,")")))}else t=!0,e=Nf(e,e.shape[0],0).map((e=>Cf(e,[0])));so(e.length<=e[0].shape[0],(()=>"Gram-Schmidt: Number of vectors (".concat(e.length,") exceeds ")+"number of dimensions (".concat(e[0].shape[0],").")));const n=[],a=e;for(let r=0;r<e.length;++r)n.push(yu.tidy((()=>{let e=a[r];if(r>0)for(let t=0;t<r;++t){const a=Ad(Op(Ad(n[t],e)),n[t]);e=qd(e,a)}return _d(e,Am(e,"euclidean"))})));return t?Tf(n,0):n}});function Om(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];return yu.tidy((()=>{so(2===e.shape.length,(()=>"qr2d() requires a 2D Tensor, but got a ".concat(e.shape.length,"D Tensor.")));const n=e.shape[0],a=e.shape[1];let r=Sp(n),o=Td(e);const s=_f([[1]],[1,1]);let i=Td(s);const c=n>=a?a:n;for(let e=0;e<c;++e){const t=o,c=i,l=r;[i,o,r]=yu.tidy((()=>{const t=yf(o,[e,e],[n-e,1]),c=Am(t),l=yf(o,[e,e],[1,1]),u=Of(Tp(l,0),_f([[-1]]),_f([[1]])),d=qd(l,Ad(u,c)),h=_d(t,d);i=1===h.shape[0]?Td(s):op([s,yf(h,[1,0],[h.shape[0]-1,h.shape[1]])],0);const p=Zp(_d(jp(u,d),c)),f=yf(o,[e,0],[n-e,a]),m=Ad(p,i),g=Lf(i);if(0===e)o=qd(f,jp(m,jp(g,f)));else{const t=qd(f,jp(m,jp(g,f)));o=op([yf(o,[0,0],[e,a]),t],0)}const b=Lf(m),y=yf(r,[0,e],[n,r.shape[1]-e]);if(0===e)r=qd(y,jp(jp(y,i),b));else{const t=qd(y,jp(jp(y,i),b));r=op([yf(r,[0,0],[n,e]),t],1)}return[i,o,r]})),Pu([t,c,l])}return!t&&n>a&&(r=yf(r,[0,0],[n,a]),o=yf(o,[0,0],[a,a])),[r,o]}))}const Dm=Ru({qr_:function(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];if(so(e.rank>=2,(()=>"qr() requires input tensor to have a rank >= 2, but got rank ".concat(e.rank))),2===e.rank)return Om(e,t);{const n=e.shape.slice(0,e.shape.length-2).reduce(((e,t)=>e*t)),a=Ff(Qh(e,[n,e.shape[e.shape.length-2],e.shape[e.shape.length-1]]),0),r=[],o=[];a.forEach((e=>{const[n,a]=Om(e,t);r.push(n),o.push(a)}));return[Qh(Tf(r,0),e.shape),Qh(Tf(o,0),e.shape)]}}});var Mm;!function(e){e[e.NONE=0]="NONE",e[e.MEAN=1]="MEAN",e[e.SUM=2]="SUM",e[e.SUM_BY_NONZERO_WEIGHTS=3]="SUM_BY_NONZERO_WEIGHTS"}(Mm||(Mm={}));const Lm=Ru({squaredDifference_:function(e,t){let n=Tu(e,"a","squaredDifference"),a=Tu(t,"b","squaredDifference");[n,a]=uu(n,a),Zd(n.shape,a.shape);const r={a:n,b:a};return yu.runKernel(Oc,r,{})}});const Pm={flipLeftRight:em,grayscaleToRGB:tm,resizeNearestNeighbor:km,resizeBilinear:wm,rgbToGrayscale:am,rotateWithOffset:rm,cropAndResize:$f,nonMaxSuppression:sm,nonMaxSuppressionAsync:gm,nonMaxSuppressionWithScore:bm,nonMaxSuppressionWithScoreAsync:ym,nonMaxSuppressionPadded:xm,nonMaxSuppressionPaddedAsync:vm,threshold:Cm,transform:Tm},zm={bandPart:Rm,gramSchmidt:Fm,qr:Dm};const Bm=class{static sgd(e){return new th(e)}static momentum(e,t){return new nh(e,t,arguments.length>2&&void 0!==arguments[2]&&arguments[2])}static rmsprop(e){return new ah(e,arguments.length>1&&void 0!==arguments[1]?arguments[1]:.9,arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,arguments.length>3&&void 0!==arguments[3]?arguments[3]:null,arguments.length>4&&void 0!==arguments[4]&&arguments[4])}static adam(){return new Xd(arguments.length>0&&void 0!==arguments[0]?arguments[0]:.001,arguments.length>1&&void 0!==arguments[1]?arguments[1]:.9,arguments.length>2&&void 0!==arguments[2]?arguments[2]:.999,arguments.length>3&&void 0!==arguments[3]?arguments[3]:null)}static adadelta(){return new Gd(arguments.length>0&&void 0!==arguments[0]?arguments[0]:.001,arguments.length>1&&void 0!==arguments[1]?arguments[1]:.95,arguments.length>2&&void 0!==arguments[2]?arguments[2]:null)}static adamax(){return new eh(arguments.length>0&&void 0!==arguments[0]?arguments[0]:.002,arguments.length>1&&void 0!==arguments[1]?arguments[1]:.9,arguments.length>2&&void 0!==arguments[2]?arguments[2]:.999,arguments.length>3&&void 0!==arguments[3]?arguments[3]:null,arguments.length>4&&void 0!==arguments[4]?arguments[4]:0)}static adagrad(e){return new jd(e,arguments.length>1&&void 0!==arguments[1]?arguments[1]:.1)}},Wm="undefined"!==typeof requestAnimationFrame?requestAnimationFrame:"undefined"!==typeof setImmediate?setImmediate:e=>e();function Vm(){return new Promise((e=>Wm((()=>e()))))}function Um(e,t){const n=e[0].length;e.forEach(((e,t)=>{so(e.length===n,(()=>"Error in concat".concat(n,"D: rank of tensors[").concat(t,"] must be the same ")+"as the rank of the rest (".concat(n,")")))})),so(t>=0&&t<n,(()=>"Error in concat".concat(n,"D: axis must be between 0 and ").concat(n-1,".")));const a=e[0];e.forEach(((e,r)=>{for(let o=0;o<n;o++)so(o===t||e[o]===a[o],(()=>"Error in concat".concat(n,"D: Shape of tensors[").concat(r,"] (").concat(e,") ")+"does not match the shape of the rest (".concat(a,") ")+"along the non-concatenated axis ".concat(r,".")))}))}function Gm(e,t){const n=e[0].slice();for(let a=1;a<e.length;a++)n[t]+=e[a][t];return n}var Hm;function jm(e,t,n){let a=new Array;if(null==n&&null==t)return a;if(null==t)for(;a.length<e+n.length;)a.push(-1);else a=t.slice();if(null==n)return a;if(e+n.length!==a.length)throw new Error("rt input.shape and shape=".concat(t," are incompatible: rt input.rank = ").concat(e+n.length,", but shape.rank = ").concat(a.length));for(let r=1;r<n.length;++r){const o=n[r],s=a[a.length-n.length+r],i=a[s];if(o>=0)if(i>=0){if(i!==o)throw new Error("rt input.shape and shape=".concat(t," are incompatible: rt input.shape[").concat(r+e,"] = ").concat(o," but shape[").concat(r+e,"] = ").concat(i))}else a[s]=o}return a}function Km(e){const t={FIRST_DIM_SIZE:Hm.FIRST_DIM_SIZE,VALUE_ROWIDS:Hm.VALUE_ROWIDS,ROW_LENGTHS:Hm.ROW_LENGTHS,ROW_SPLITS:Hm.ROW_SPLITS,ROW_LIMITS:Hm.ROW_LIMITS,ROW_STARTS:Hm.ROW_STARTS},n=[];for(const a of e){if(!(a in t))break;n.push(t[a])}return n}function qm(e){return 0===e.length?0:e[0]===Hm.FIRST_DIM_SIZE?e.length-1:e.length}function Xm(e,t){if(null==e||null==t)return;const n=e.length,a=t.length;if(n>=a)throw new Error("defaultValue.shape=".concat(e," and ragged tensor flatValues.shape=").concat(t,", are incompatible: defaultValue.rank = ").concat(n," must be less than ragged tensor input flatValues.rank = ").concat(a,")"));for(let r=0;r<Math.min(n,a-1);++r){const n=e[r],a=t[r+1];if(n>=0&&a>=0&&1!==n&&n!==a)throw new Error("defaultValue.shape=".concat(e,", and ragged tensor input flatValues.shape=").concat(t," are incompatible: defaultValue.shape[").concat(r-e.length,"] = ").concat(n," but ragged tensor input.flatValues.shape[").concat(r-e.length,"] = ").concat(a))}}!function(e){e[e.FIRST_DIM_SIZE=0]="FIRST_DIM_SIZE",e[e.VALUE_ROWIDS=1]="VALUE_ROWIDS",e[e.ROW_LENGTHS=2]="ROW_LENGTHS",e[e.ROW_SPLITS=3]="ROW_SPLITS",e[e.ROW_LIMITS=4]="ROW_LIMITS",e[e.ROW_STARTS=5]="ROW_STARTS"}(Hm||(Hm={}));const Ym=30;function Qm(e){return e<=Ym?e:To(e,Math.floor(Math.sqrt(e)))}function Jm(e,t,n){return[n*("number"===typeof e?e:e[0]),t*("number"===typeof e?e:e[1])]}function Zm(e,t,n){let a=[];if(!(arguments.length>3&&void 0!==arguments[3])||arguments[3])a=a.concat(t.slice(0)),a.push(e[0]/n),a=a.concat(e.slice(1));else{a=a.concat(e[0]);const n=t.length;for(let r=0;r<n;++r)a=a.concat([e[r+1]/t[r],t[r]]);a=a.concat(e.slice(n+1))}return a}function $m(e,t){const n=[];if(!(arguments.length>2&&void 0!==arguments[2])||arguments[2]){n.push(t);for(let a=t+1;a<e;++a)a<=2*t?(n.push(a),n.push(a-(t+1))):n.push(a)}else{const a=[],r=[];for(let n=1;n<e;++n)n>=2*t+1||n%2===1?r.push(n):a.push(n);n.push(...a),n.push(0),n.push(...r)}return n}function eg(e,t,n){let a=!(arguments.length>3&&void 0!==arguments[3])||arguments[3];const r=[];a?r.push(e[0]/n):r.push(e[0]*n);for(let o=1;o<e.length;++o)o<=t.length?a?r.push(t[o-1]*e[o]):r.push(e[o]/t[o-1]):r.push(e[o]);return r}function tg(e,t){const n=[0];for(let a=0;a<t;++a)n.push(e[a][0]);return n}function ng(e,t,n){const a=e.slice(0,1);for(let r=0;r<n;++r)a.push(e[r+1]-t[r][0]-t[r][1]);return a}function ag(e,t){const n=e.shape.length,a=t.shape.length;if(n<1)throw new Error("tf.gatherND() expects the input to be rank 1 or higher,"+" but the rank was ".concat(n,"."));if(a<1)throw new Error("tf.gatherND() expects the indices to be rank 1 or higher,"+" but the rank was ".concat(a,"."));if("int32"!==t.dtype)throw new Error("tf.gatherND() expects the indices to be int32 type,"+" but the dtype was ".concat(t.dtype,"."));if(t.shape[a-1]>n)throw new Error("index innermost dimension length must be <= tensor rank; saw: "+"".concat(t.shape[a-1]," vs. ").concat(n));if(0===lo(e.shape))throw new Error("Requested more than 0 entries, but input is empty."+" Input shape: ".concat(e.shape,"."));const r=t.shape,o=r[r.length-1];let s=1;for(let d=0;d<r.length-1;++d)s*=r[d];const i=e.shape,c=r.slice();c.pop();let l=1;for(let d=o;d<n;++d)l*=i[d],c.push(i[d]);const u=[...Eo(e.shape).map((e=>e/l)),1].slice(0,o);return[c,s,l,u]}function rg(e,t,n){const a=t.rank>1?t.shape[t.rank-1]:1,r=t.rank>1?t.rank-1:1,o="Must have updates.shape = indices.shape[:batchDim] + "+"shape[sliceDim:], got updates.shape: ".concat(n.shape)+", indices.shape: ".concat(t.shape,", shape: ").concat(e)+", sliceDim: ".concat(a,", and batchDim: ").concat(r,".");if(n.rank<r)throw new Error(o+" update.rank < ".concat(r,". "));if(e.length<a+(n.rank-r))throw new Error(o+" Output shape length < ".concat(a+(n.rank-r)));if(n.rank!==r+e.length-a)throw new Error(o+" update.rank != ".concat(r+e.length-a));for(let s=0;s<r;++s)if(n.shape[s]!==t.shape[s])throw new Error(o+" updates.shape[".concat(s,"] (").concat(n.shape[s],") != indices.shape[").concat(s,"] (").concat(t.shape[s],")."));for(let s=0;s<n.rank-r;++s)if(n.shape[s+r]!==e[s+a])throw new Error(o+" updates.shape[".concat(s+r,"] (").concat(n.shape[s+r],") != shape[").concat(s+r,"] (").concat(e[s+r],")"))}function og(e,t,n){if(t.rank<1)throw new Error("tf.scatterND() expects the indices to be rank 1 or higher,"+" but the rank was ".concat(t.rank,"."));if(e.rank<1)throw new Error("tf.scatterND() expects the updates to be rank 1 or higher,"+" but the rank was ".concat(e.rank,"."));if("int32"!==t.dtype)throw new Error("The dtype of 'indices' should be int32, but got dtype: ".concat(t.dtype));if(n.length<1)throw new Error("Output rank must be greater or equal to 1, but got shape: ".concat(n));if(0===n.length){if(0===t.size)throw new Error("Indices specified for empty output. indices shape: ".concat(t.shape));if(0===e.size)throw new Error("Updates specified for empty output. updates shape: ".concat(e.shape))}rg(n,t,e)}function sg(e,t,n){const a=t.shape.length,r=a>1?t.shape[a-1]:1,o=n.length;let s=1;for(let c=r;c<o;++c)s*=n[c];const i=r<1?1:r;return{sliceRank:r,numUpdates:lo(t.shape)/i,sliceSize:s,strides:[...Eo(n.slice(0,r)),1],outputSize:lo(n)}}const ig=1.7580993408473768,cg=1.0507009873554805,lg=.3275911,ug=.254829592,dg=-.284496736,hg=1.421413741,pg=-1.453152027,fg=1.061405429;function mg(e,t){if(e.length!==t.length)throw new Error("Cannot merge real and imag arrays of different lengths. real:"+"".concat(e.length,", imag: ").concat(t.length,"."));const n=new Float32Array(2*e.length);for(let a=0;a<n.length;a+=2)n[a]=e[a/2],n[a+1]=t[a/2];return n}function gg(e){const t=new Float32Array(e.length/2),n=new Float32Array(e.length/2);for(let a=0;a<e.length;a+=2)t[a/2]=e[a],n[a/2]=e[a+1];return{real:t,imag:n}}function bg(e){const t=Math.ceil(e.length/4),n=new Float32Array(t),a=new Float32Array(t);for(let r=0;r<e.length;r+=4)n[Math.floor(r/4)]=e[r],a[Math.floor(r/4)]=e[r+1];return{real:n,imag:a}}function yg(e){const t=Math.floor(e.length/4),n=new Float32Array(t),a=new Float32Array(t);for(let r=2;r<e.length;r+=4)n[Math.floor(r/4)]=e[r],a[Math.floor(r/4)]=e[r+1];return{real:n,imag:a}}function xg(e,t){return{real:e[2*t],imag:e[2*t+1]}}function vg(e,t,n,a){e[2*a]=t,e[2*a+1]=n}function wg(e,t){const n=new Float32Array(e/2),a=new Float32Array(e/2);for(let r=0;r<Math.ceil(e/2);r++){const o=(t?2:-2)*Math.PI*(r/e);n[r]=Math.cos(o),a[r]=Math.sin(o)}return{real:n,imag:a}}function kg(e,t,n){const a=(n?2:-2)*Math.PI*(e/t);return{real:Math.cos(a),imag:Math.sin(a)}}const Ig="->",Sg=/->/g,Ng=",",Cg="...";function Tg(e,t){const n=((e=e.replace(/\s/g,"")).length-e.replace(Sg,"").length)/Ig.length;if(n<1)throw new Error("Equations without an arrow are not supported.");if(n>1)throw new Error('Equation must contain exactly one arrow ("'.concat(Ig,'").'));const[a,r]=e.split(Ig);so(-1===a.indexOf(Cg),(()=>'The ellipsis notation ("'.concat(Cg,'") is not supported yet.')));const o=a.split(Ng),s=o.length;if(t!==s)throw new Error("Expected ".concat(s," input tensors, received ").concat(t));if(s>2)throw new Error("Support for more than 2 input tensors is not implemented yet.");const i=[];for(let d=0;d<r.length;++d){const e=r[d];if(!o.some((t=>-1!==t.indexOf(e))))throw new Error("Output subscripts contain the label ".concat(e," ")+"not present in the input subscripts.");-1===i.indexOf(e)&&i.push(e)}for(let d=0;d<a.length;++d){const e=a[d];-1===i.indexOf(e)&&e!==Ng&&i.push(e)}const c=new Array(o.length);for(let d=0;d<s;++d){if(new Set(o[d].split("")).size!==o[d].length)throw new Error("Found duplicate axes in input component ".concat(o[d],". ")+"Support for duplicate axes in input is not implemented yet.");c[d]=[];for(let e=0;e<o[d].length;++e)c[d].push(i.indexOf(o[d][e]))}const l=i.length,u=[];for(let d=r.length;d<l;++d)u.push(d);return{allDims:i,summedDims:u,idDims:c}}function Eg(e,t){let n=new Array(e);n.fill(-1);for(let r=0;r<t.length;++r)n[t[r]]=r;const a=[];for(let r=0;r<e;++r)-1===n[r]&&a.push(r);return n=n.filter((e=>-1!==e)),{permutationIndices:n,expandDims:a}}function Rg(e,t,n){const a=new Array(e);for(let r=0;r<n.length;++r){const e=n[r].shape;for(let n=0;n<t[r].length;++n)void 0===a[t[r][n]]?a[t[r][n]]=e[n]:so(a[t[r][n]]===e[n],(()=>"Expected dimension ".concat(a[t[r][n]]," at axis ").concat(n," ")+"of input shaped ".concat(JSON.stringify(e),", ")+"but got dimension ".concat(e[n])))}}function _g(e,t){const n=e,a=[];let r=0;0===e.length&&n.push(-1),r=e.length+1;for(let s=0;s<r;++s)a.push([]);const o=[];for(let s=0;s<n.length;++s){const e=Fg(t,n[s]);for(const t of e)-1===o.indexOf(t)&&(a[s].push(t),o.push(t))}return{path:n,steps:a}}function Ag(e){return e.every(((e,t)=>e===t))}function Fg(e,t){const n=[];for(let a=0;a<e.length;++a)0!==e[a].length&&-1===e[a].indexOf(t)&&-1!==t||n.push(a);return n}function Og(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,a=[];if("number"===typeof t)so(e.shape[n]%t===0,(()=>"Number of splits must evenly divide the axis.")),a=new Array(t).fill(e.shape[n]/t);else{const r=t.reduce(((e,t)=>(-1===t&&(e+=1),e)),0);so(r<=1,(()=>"There should be only one negative value in split array."));const o=t.indexOf(-1);if(-1!==o){const a=t.reduce(((e,t)=>t>0?e+t:e));t[o]=e.shape[n]-a}so(e.shape[n]===t.reduce(((e,t)=>e+t)),(()=>"The sum of sizes must match the size of the axis dimension.")),a=t}return a}function Dg(e){return"Received SparseTensor with denseShape[0] = 0 but\n  indices.shape[0] = ".concat(e)}function Mg(e,t){return"indices(".concat(e,", 0) is invalid: ").concat(t," < 0")}function Lg(e,t,n){return"indices(".concat(e,", 0) is invalid: ").concat(t," >= ").concat(n)}function Pg(e,t){return"only one output dimension may be -1, not both ".concat(e," and ").concat(t)}function zg(e,t){return"size ".concat(e," must be non-negative, not ").concat(t)}function Bg(){return"reshape cannot infer the missing input size for an empty tensor unless all specified input sizes are non-zero"}function Wg(e,t){const n=lo(e),a=lo(t);return"Input to reshape is a SparseTensor with ".concat(n,"\n  dense values, but the requested shape requires a multiple of ").concat(a,". inputShape=").concat(e," outputShape= ").concat(t)}function Vg(e,t){const n=lo(e),a=lo(t);return"Input to reshape is a tensor with ".concat(n," dense values, but the requested shape has ").concat(a,". inputShape=").concat(e," outputShape=").concat(t)}function Ug(){return"segment ids must be >= 0"}function Gg(){return"segment ids are not increasing"}function Hg(e,t){return"Segment id ".concat(e," out of range [0, ").concat(t,"), possibly because segmentIds input is not sorted.")}function jg(e,t,n){return"Bad: indices[".concat(e,"] == ").concat(t," out of range [0, ").concat(n,")")}function Kg(e,t){let n,a=!1;for(e<=Ym?(n=e,a=!0):n=To(e,Math.floor(Math.sqrt(e)));!a;)n>t||n===e?a=!0:n=To(e,n+1);return n}function qg(e,t,n){const a=[],r=e.length;for(let o=0;o<r;o++)o!==t?a.push(e[o]):a.push(n);return a}function Xg(e,t,n,a){const r=t.shape.length,o=e.shape.length;if(0!==a&&(a<-r||a>r))throw new Error("Expect batchDims in the range of [-".concat(r,", ").concat(r,"], but got ").concat(a));if(a<0&&(a+=r),a>o)throw new Error("batchDims (".concat(a,") must be less than rank(x) (\n    ").concat(o,")."));if(n<a)throw new Error("batchDims (".concat(a,") must be less than or equal to axis (").concat(n,")."));for(let d=0;d<a;++d)if(e.shape[d]!==t.shape[d])throw new Error("x.shape[".concat(d,"]: ").concat(e.shape[d]," should be equal to indices.shape[").concat(d,"]: ").concat(t.shape[d],"."));const s=e.shape[n],i=[];let c=1,l=1,u=1;for(let d=0;d<a;++d)i.push(e.shape[d]),c*=e.shape[d];for(let d=a;d<n;d++)i.push(e.shape[d]),l*=e.shape[d];for(let d=a;d<r;d++)i.push(t.shape[d]);for(let d=n+1;d<o;d++)i.push(e.shape[d]),u*=e.shape[d];return{batchSize:c,sliceSize:u,outerSize:l,dimSize:s,outputShape:i}}function Yg(e){try{return e.map((e=>Ol(e)))}catch(Yue){throw new Error("Failed to decode encoded string bytes into utf-8, error: ".concat(Yue))}}function Qg(e){return e.map((e=>Fl(e)))}function Jg(e,t){const n=[];for(let o=0;o<t.length;o++)t[o]&&n.push(o);const a=Nd(e,"int32"),r=Nd([n.length,e.length],"int32");for(let o=0;o<n.length;o++){const t=a.indexToLoc(n[o]),s=o*e.length;r.values.set(t,s)}return r.toTensor()}!function(){for(const e of rh)Vd(e)}();const Zg={kernelName:Ko,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>Ad(e,Hf(Cd(n,"float32"),-1))}}},$g={kernelName:qo,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>{const t=Od(Cd(n,"float32")),a=Fd(qd(Ld(1),t));return Zp(_d(e,a))}}}},eb={kernelName:Xo,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>{const t=Fd(qd(Od(Cd(n,"float32")),1));return _d(e,t)}}}},tb={kernelName:Yo,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,a]=t,r=Zd(n.shape,a.shape);return{a:()=>{let t=e;const a=Jd(n.shape,r);return a.length>0&&(t=Op(t,a)),Qh(t,n.shape)},b:()=>{let t=e;const n=Jd(a.shape,r);return n.length>0&&(t=Op(t,n)),Qh(t,a.shape)}}}},nb={kernelName:Qo,saveAllInputs:!0,gradFunc:(e,t)=>{const n={};return t.forEach(((t,a)=>{n[a]=()=>e.clone()})),n}},ab={kernelName:$o,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>Dd(n)}}},rb={kernelName:es,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>Dd(n)}}},ob={kernelName:ts,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>_d(e,Fd(qd(Ld(1),Od(Cd(n,"float32")))))}}},sb={kernelName:ns,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>{const t=Fd(Ed(Ld(1),Od(Cd(n,"float32"))));return _d(e,t)}}}},ib={kernelName:os,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,a]=t,r=Zd(n.shape,a.shape);return{a:()=>{const t=Ed(Od(n),Od(a));let o=Ad(e,_d(a,t));const s=Jd(n.shape,r);return s.length>0&&(o=Op(o,s)),Qh(o,n.shape)},b:()=>{const t=Ed(Od(n),Od(a));let o=Zp(Ad(e,_d(n,t)));const s=Jd(a.shape,r);return s.length>0&&(o=Op(o,s)),Qh(o,a.shape)}}}},cb={kernelName:as,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>_d(e,Ed(Od(Cd(n,"float32")),1))}}},lb={kernelName:rs,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>_d(e,qd(Ld(1),Od(Cd(n,"float32"))))}}};const ub=Ru({avgPool3dGrad_:function(e,t,n,a,r,o){const s=Tu(e,"dy","avgPool3dGrad"),i=Tu(t,"input","avgPool3dGrad");let c=s,l=i,u=!1;4===i.rank&&(u=!0,c=Qh(s,[1,s.shape[0],s.shape[1],s.shape[2],s.shape[3]]),l=Qh(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]])),so(5===c.rank,(()=>"Error in avgPool3dGrad: dy must be rank 5 but got rank "+"".concat(c.rank,"."))),so(5===l.rank,(()=>"Error in avgPool3dGrad: input must be rank 5 but got rank "+"".concat(l.rank,"."))),Yh("avgPool3dGrad",r,o);const d={dy:c,input:l},h={filterSize:n,strides:a,pad:r,dimRoundingMode:o},p=yu.runKernel(ls,d,h);return u?Qh(p,[p.shape[1],p.shape[2],p.shape[3],p.shape[4]]):p}}),db={kernelName:cs,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[a]=t,{filterSize:r,strides:o,pad:s,dimRoundingMode:i}=n;return{x:()=>ub(e,a,r,o,s,i)}}};const hb=Ru({avgPoolGrad_:function(e,t,n,a,r){const o=Tu(e,"dy","avgPoolGrad"),s=Tu(t,"input","avgPoolGrad");so(s.rank===o.rank,(()=>"Rank of input (".concat(s.rank,") does not match rank of dy (").concat(o.rank,")")));let i=s,c=o,l=!1;3===s.rank&&(l=!0,i=Qh(s,[1,s.shape[0],s.shape[1],s.shape[2]]),c=Qh(o,[1,o.shape[0],o.shape[1],o.shape[2]])),so(4===c.rank,(()=>"Error in avgPoolGrad: dy must be rank 4 but got rank "+"".concat(c.rank,"."))),so(4===i.rank,(()=>"Error in avgPoolGrad: input must be rank 4 but got rank "+"".concat(i.rank,".")));const u={dy:c,input:i},d={filterSize:n,strides:a,pad:r},h=yu.runKernel(is,u,d);return l?Qh(h,[h.shape[1],h.shape[2],h.shape[3]]):h}}),pb={kernelName:ss,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[a]=t,{filterSize:r,strides:o,pad:s}=n;return{x:()=>hb(e,a,r,o,s)}}},fb={kernelName:us,inputsToSave:["a","b"],gradFunc:(e,t,n)=>{const[a,r]=t,{transposeA:o,transposeB:s}=n;return o||s?!o&&s?{a:()=>jp(e,r,!1,!1),b:()=>jp(e,a,!0,!1)}:o&&!s?{a:()=>jp(r,e,!1,!0),b:()=>jp(a,e,!1,!1)}:{a:()=>jp(r,e,!0,!0),b:()=>jp(e,a,!0,!0)}:{a:()=>jp(e,r,!1,!0),b:()=>jp(a,e,!0,!1)}}};const mb=Ru({spaceToBatchND_:function(e,t,n){const a=Tu(e,"x","spaceToBatchND");so(a.rank>=1+t.length,(()=>"input rank ".concat(a.rank," should be > than [blockShape] ").concat(t.length))),so(n.length===t.length,(()=>"paddings.shape[0] ".concat(n.length," must be equal to [blockShape] ").concat(t.length))),so(a.shape.reduce(((e,a,r)=>r>0&&r<=t.length?e&&(a+n[r-1][0]+n[r-1][1])%t[r-1]===0:e),!0),(()=>"input spatial dimensions ".concat(a.shape.slice(1)," with paddings ").concat(n.toString()," must be divisible by blockShapes ").concat(t.toString())));const r={x:a},o={blockShape:t,paddings:n};return yu.runKernel(Nc,r,o)}}),gb={kernelName:ds,gradFunc:(e,t,n)=>{const{blockShape:a,crops:r}=n;return{x:()=>mb(e,a,r)}}},bb={kernelName:"BroadcastTo",gradFunc:(e,t,n)=>{const a=n,r=a.inputShape,o=a.shape,s=Array.from(o);for(let c=r.length-1;c>=0;c--)if(r[c]===o[c])s[c]=1;else if(1!==r[c])throw new Error("broadcastTo(): [".concat(r,"] cannot be broadcast to [").concat(o,"]."));const i=[];for(let c=0;c<s.length;c++)s[c]>1&&i.push(c);return{x:()=>Op(e,i,!0)}}},yb={kernelName:ms,gradFunc:e=>({x:()=>e.clone()})},xb={kernelName:gs,gradFunc:e=>({x:()=>Dd(e)})},vb={kernelName:bs,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[a]=t,{clipValueMin:r,clipValueMax:o}=n;return{x:()=>Of(Hp(Ep(a,r),Sm(a,o)),e,Dd(e))}}},wb={kernelName:xs,inputsToSave:["x"],gradFunc:Zg.gradFunc},kb={kernelName:vs,saveAllInputs:!0,gradFunc:(e,t,n)=>{const a=t.map((e=>e.shape)),{axis:r}=n,o=bo(r,t[0].shape)[0],s=a.map((e=>e[o]));return Nf(e,s,o).map((e=>()=>e))}},Ib={kernelName:ws,inputsToSave:["x","filter"],gradFunc:(e,t,n)=>{const[a,r]=t,{dilations:o,strides:s,pad:i,dataFormat:c}=n;return so(jh(o),(()=>"Error in gradient of conv2D: dilation rates greater than 1 "+"are not yet supported in gradients. Got dilations '".concat(o,"'"))),{x:()=>hp(a.shape,e,r,s,i,c),filter:()=>Uf(a,e,r.shape,s,i,c)}}},Sb={kernelName:Is,inputsToSave:["dy","filter"],gradFunc:(e,t,n)=>{const[a,r]=t,{strides:o,pad:s,dataFormat:i,dimRoundingMode:c}=n;return{dy:()=>up(e,r,o,s,i,1,c),filter:()=>Uf(e,a,r.shape,o,s,i,c)}}};const Nb=Ru({conv3DBackpropFilter_:function(e,t,n,a,r){let o=e;4===e.rank&&(o=Qh(e,[1,e.shape[0],e.shape[1],e.shape[2],e.shape[3]]));let s=t;4===s.rank&&(s=Qh(t,[1,t.shape[0],t.shape[1],t.shape[2],t.shape[3]])),so(5===o.rank,(()=>"Error in conv3dDerFilter: input must be rank 5, but got shape "+"".concat(o.shape,"."))),so(5===s.rank,(()=>"Error in conv3dDerFilter: dy must be rank 5, but got shape "+"".concat(s.shape,"."))),so(5===n.length,(()=>"Error in conv3dDerFilter: filterShape must be length 5, but got "+"".concat(n,"."))),so(o.shape[4]===n[3],(()=>"Error in conv3dDerFilter: depth of input ".concat(o.shape[4],") must ")+"match input depth in filter (".concat(n[3],"."))),so(s.shape[4]===n[4],(()=>"Error in conv3dDerFilter: depth of dy (".concat(s.shape[4],") must ")+"match output depth for filter (".concat(n[4],").")));const i={x:o,dy:s},c={strides:a,pad:r,filterShape:n};return yu.runKernel(Ns,i,c)}}),Cb={kernelName:Ss,inputsToSave:["x","filter"],gradFunc:(e,t,n)=>{const{dilations:a,strides:r,pad:o}=n;so(jh(a),(()=>"Error in gradient of conv3D: dilation rates greater than 1 are "+"not yet supported in gradients. Got dilations '".concat(a,"'")));const[s,i]=t;return{x:()=>mp(s.shape,e,i,r,o),filter:()=>Nb(s,e,i.shape,r,o)}}};const Tb=Ru({sin_:function(e){const t={x:Tu(e,"x","sin","float32")};return yu.runKernel(yc,t)}}),Eb={kernelName:Ts,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>Ad(Zp(Tb(Cd(n,"float32"))),e)}}};const Rb=Ru({sinh_:function(e){const t={x:Tu(e,"x","sinh")};return yu.runKernel(xc,t)}}),_b={kernelName:Es,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>Ad(Rb(Cd(n,"float32")),e)}}};const Ab=Ru({cumsum_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],a=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const r={x:Tu(e,"x","cumsum")},o={axis:t,exclusive:n,reverse:a};return yu.runKernel(_s,r,o)}}),Fb={kernelName:_s,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[a]=t,{axis:r,exclusive:o,reverse:s}=n;return{x:()=>{const t=Wp([r],a.rank);let n=Ab(e,r,o,!s);return null!=t&&(n=Lf(n,t)),n}}}},Ob={kernelName:Ds,inputsToSave:["x","filter"],gradFunc:(e,t,n)=>{const{dilations:a,strides:r,pad:o,dimRoundingMode:s}=n,i=null==a?[1,1]:a;so(jh(i),(()=>"Error in gradient of depthwiseConv2dNative: dilation rates greater than 1 are not yet supported. Got dilations "+"'".concat(i,"'")));const[c,l]=t;return so(4===c.rank,(()=>"Error in gradient of depthwiseConv2dNative: input must be "+"rank 4, but got rank ".concat(c.rank,"."))),so(4===l.rank,(()=>"Error in gradient of depthwiseConv2dNative: filter must be "+"rank 4, but got rank ".concat(l.rank,"."))),so(c.shape[3]===l.shape[2],(()=>"Error in gradient of depthwiseConv2d: number of input "+"channels (".concat(c.shape[3],") must match the inChannels dimension ")+"in filter ".concat(l.shape[2],"."))),so(Kh(r,i),(()=>"Error in gradient of depthwiseConv2d: Either strides or "+"dilations must be  1. Got strides ".concat(r," and dilations ")+"'".concat(i,"'."))),Yh("depthwiseConv2d",o,s),{x:()=>Jf(c.shape,e,l,r,o,i,s),filter:()=>Qf(c,e,l.shape,r,o,i,s)}}},Db={kernelName:zs,inputsToSave:["x","filter"],gradFunc:(e,t,n)=>{const[a,r]=t,o={x:a,filter:r,dy:e},s={x:a,filter:r,dy:e};return{x:()=>yu.runKernel(Bs,o,n),filter:()=>yu.runKernel(Ws,s,n)}}},Mb={kernelName:Hs,outputsToSave:[!0],gradFunc:(e,t)=>{const[n]=t,a={dy:e,y:n};return{x:()=>yu.runKernel(js,a)}}},Lb={kernelName:Ks,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t,a=Ad(wp(Zp(Od(n))),2/Math.sqrt(Math.PI));return{x:()=>Ad(e,a)}}},Pb={kernelName:Xs,outputsToSave:[!0],gradFunc:(e,t)=>{const[n]=t;return{x:()=>Ad(e,n)}}},zb={kernelName:Ys,inputsToSave:["input"],gradFunc:(e,t)=>{const[n]=t;return{input:()=>Qh(e,n.shape)}}},Bb={kernelName:Qs,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>Ad(e,wp(n))}}},Wb={kernelName:ei,gradFunc:e=>({x:()=>Dd(e)})},Vb={kernelName:ti,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,a]=t,r=Zd(n.shape,a.shape);return{a:()=>{const t=_d(e,Cd(a,"float32")),o=Jd(n.shape,r);return o.length>0?Qh(Op(t,o),n.shape):t},b:()=>{let t=Ad(e,Cd(n,"float32"));const o=Jd(a.shape,r);o.length>0&&(t=Qh(Op(t,o),a.shape));const s=Od(a);return Zp(_d(t,Cd(s,"float32")))}}}};const Ub=Ru({rsqrt_:function(e){const t={x:Tu(e,"x","rsqrt","float32")};return yu.runKernel(dc,t)}}),Gb={kernelName:ni,inputsToSave:["x","mean","variance","scale"],gradFunc:(e,t,n)=>{const{varianceEpsilon:a}=n,[r,o,s,i]=t,c=null==i?Ld(1):i,l=Jd(o.shape,r.shape),u=[];if(1===o.rank){for(let e=0;e<r.shape.length-1;++e)u.push(r.shape[e]);u.push(1)}const d=qd(r,o),h=Ad(e,c),p=Ub(Ed(s,Ld(a))),f=Ad(Ad(Ad(p,p),p),Ld(-.5));return{x:()=>1===o.rank?Qh(Ad(Ad(e,Ip(Qh(p,[1,1,1,o.shape[0]]),u)),c),r.shape):Qh(Ad(Ad(e,p),c),r.shape),mean:()=>{let e=Ad(Ad(p,Ld(-1)),h);return 1===o.rank&&(e=Op(e,l)),Qh(e,o.shape)},variance:()=>{let e=Ad(Ad(f,d),h);return 1===o.rank&&(e=Op(e,l)),Qh(e,o.shape)},scale:()=>{const t=Ad(d,p);let n=Ad(e,t);return 1===o.rank&&(n=Op(n,l)),Qh(n,o.shape)},offset:()=>{let t=e;return 1===o.rank&&(t=Op(t,l)),Qh(t,o.shape)}}}};const Hb=Ru({unsortedSegmentSum_:function(e,t,n){const a=Tu(e,"x","unsortedSegmentSum"),r=Tu(t,"segmentIds","unsortedSegmentSum","int32");so(ho(n),(()=>"numSegments must be of dtype int"));const o={x:a,segmentIds:r},s={numSegments:n};return yu.runKernel(Yc,o,s)}}),jb={kernelName:ai,inputsToSave:["x","indices"],gradFunc:(e,t,n)=>{const[a,r]=t,{axis:o,batchDims:s}=n,i=bo(o,a.shape)[0],c=(e,t,n)=>()=>{const a=e.shape,r=t.size,s=a.slice(0,i),c=s.length,l=a.slice(o,a.length).slice(1),u=l.length,d=Kb(0,c),h=Kb(c+1,c+1+u),p=qb([s,[r],l]),f=Qh(n,p),m=Qh(t,[r]),g=qb([[c],d,h]),b=Lf(f,g);let y=Hb(b,m,e.shape[i]);const x=Vp(g);return y=Lf(y,x),y};if(1===s){const t=a.shape[0],n=a.split(t,0),o=()=>{const t=Tf(n.map(((t,n)=>c(t,r.slice(n,1),e.slice(n,1))())));return t.reshape(a.shape)};return{x:o,indices:()=>r}}return{x:c(a,r,e),indices:()=>r}}};function Kb(e,t){const n=[];for(let a=e;a<t;++a)n.push(a);return n}function qb(e){const t=[];for(let n=0;n<e.length;++n)for(let a=0;a<e[n].length;++a)t.push(e[n][a]);return t}const Xb={kernelName:si,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,a]=t;return{a:()=>Dd(n),b:()=>Dd(a)}}},Yb={kernelName:ii,gradFunc:e=>({x:()=>Cd(e,"float32")})},Qb={kernelName:ui,gradFunc:e=>({x:()=>Dd(e)})},Jb={kernelName:di,gradFunc:e=>({x:()=>Dd(e)})},Zb={kernelName:hi,gradFunc:e=>({x:()=>Dd(e)})},$b={kernelName:pi,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[a]=t,{alpha:r}=n,o=Tp(a,0);return{x:()=>Of(o,e,Ad(e,r))}}},ey={kernelName:yi,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>_d(e,Ed(n,1))}}},ty={kernelName:bi,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>_d(e,Cd(n,"float32"))}}},ny={kernelName:"LogSoftmax",inputsToSave:[],outputsToSave:[!0],gradFunc:(e,t,n)=>{const[a]=t,{axis:r}=n;return{logits:()=>{const t=wp(a);return qd(e,Ad(Op(e,r,!0),t))}}}};const ay=Ru({localResponseNormalizationBackprop_:function(e,t,n){const a={x:e,y:t,dy:n},r={depthRadius:arguments.length>3&&void 0!==arguments[3]?arguments[3]:5,bias:arguments.length>4&&void 0!==arguments[4]?arguments[4]:1,alpha:arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,beta:arguments.length>6&&void 0!==arguments[6]?arguments[6]:.5};return yu.runKernel(Ii,a,r)}}),ry={kernelName:ki,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,n)=>{const[a,r]=t,{depthRadius:o,bias:s,alpha:i,beta:c}=n;return{x:()=>ay(a,r,e,o,s,i,c)}}};function oy(e,t,n,a){return t.rank<n.rank&&(t=Qh(t,zp(t.shape,a))),e.rank<n.rank&&(e=Qh(e,zp(e.shape,a))),{x:()=>Ad(e,Cd(vp(n,t),e.dtype))}}const sy={kernelName:Si,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,n)=>{const a=n,{reductionIndices:r}=a,o=t[0],s=oy(e,t[1],o,bo(r,o.shape));return{x:()=>s.x()}}},iy={kernelName:Ni,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,a]=t;return{a:()=>Ad(e,Cd(Ep(n,a),"float32")),b:()=>Ad(e,Cd(Em(n,a),"float32"))}}};const cy=Ru({maxPool3dGrad_:function(e,t,n,a,r,o,s){const i=Tu(e,"dy","maxPool3dGrad"),c=Tu(t,"input","maxPool3dGrad"),l=Tu(n,"output","maxPool3dGrad");let u=i,d=c,h=l,p=!1;4===c.rank&&(p=!0,u=Qh(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]]),d=Qh(c,[1,c.shape[0],c.shape[1],c.shape[2],c.shape[3]]),h=Qh(l,[1,l.shape[0],l.shape[1],l.shape[2],l.shape[3]])),so(5===u.rank,(()=>"Error in maxPool3dGrad: dy must be rank 5 but got rank "+"".concat(u.rank,"."))),so(5===d.rank,(()=>"Error in maxPool3dGrad: input must be rank 5 but got rank "+"".concat(d.rank,"."))),so(5===h.rank,(()=>"Error in maxPool3dGrad: output must be rank 5 but got rank "+"".concat(h.rank,"."))),Yh("maxPool3dGrad",o,s);const f={dy:u,input:d,output:h},m={filterSize:a,strides:r,pad:o,dimRoundingMode:s},g=yu.runKernel(Ri,f,m);return p?Qh(g,[g.shape[1],g.shape[2],g.shape[3],g.shape[4]]):g}}),ly={kernelName:Ei,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,n)=>{const[a,r]=t,{filterSize:o,strides:s,pad:i,dimRoundingMode:c}=n;return{x:()=>cy(e,a,r,o,s,i,c)}}};const uy=Ru({maxPoolGrad_:function(e,t,n,a,r,o,s){const i=Tu(e,"dy","maxPoolGrad"),c=Tu(t,"input","maxPoolGrad"),l=Tu(n,"output","maxPoolGrad");so(c.rank===i.rank,(()=>"Rank of input (".concat(c.rank,") does not match rank of dy ")+"(".concat(i.rank,")"))),so(4===i.rank,(()=>"Error in maxPoolGrad: dy must be rank 4 but got rank "+"".concat(i.rank,"."))),so(4===c.rank,(()=>"Error in maxPoolGrad: input must be rank 4 but got rank "+"".concat(c.rank,"."))),Yh("maxPoolGrad",o,s);const u={dy:i,input:c,output:l},d={filterSize:a,strides:r,pad:o,dimRoundingMode:s};return yu.runKernel(Ti,u,d)}}),dy={kernelName:Ci,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,n)=>{const[a,r]=t,{filterSize:o,strides:s,pad:i}=n;return{x:()=>uy(e,a,r,o,s,i)}}},hy={kernelName:Ai,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[a]=t,{axis:r}=n,o=bo(r,a.shape),s=lo(Pp(a.shape,o)[1]);return{x:()=>{const t=a.shape.slice();o.forEach((e=>{t[e]=1}));const n=Qh(e,t);return _d(Ad(n,nf(a.shape,"float32")),s)}}}},py={kernelName:Fi,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,n)=>{const a=n,{axis:r}=a,[o,s]=t,i=oy(e,s,o,bo(r,o.shape));return{x:()=>i.x()}}},fy={kernelName:Oi,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,a]=t;return{a:()=>Ad(e,Cd(Sm(n,a),"float32")),b:()=>Ad(e,Cd(Tp(n,a),"float32"))}}},my={kernelName:Di,inputsToSave:["x"],gradFunc:(e,t,n)=>{const a=t[0],{paddings:r}=n,o=r.map((e=>e[0]));return{x:()=>yf(e,o,a.shape)}}},gy={kernelName:Mi,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,a]=t,r=Zd(n.shape,a.shape);return{a:()=>{const t=Jd(n.shape,r);return t.length>0?Qh(Op(e,t),n.shape):e},b:()=>{const t=Ad(e,Zp(Np(_d(n,a)))),o=Jd(a.shape,r);return o.length>0?Qh(Op(t,o),a.shape):t}}}},by={kernelName:Pi,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,a]=t,r=Zd(n.shape,a.shape);return{a:()=>{const t=Ad(e,Cd(a,"float32")),o=Jd(n.shape,r);return o.length>0?Qh(Op(t,o),n.shape):t},b:()=>{const t=Ad(e,Cd(n,"float32")),o=Jd(a.shape,r);return o.length>0?Qh(Op(t,o),a.shape):t}}}},yy={kernelName:zi,gradFunc:e=>({x:()=>Zp(e)})},xy={kernelName:Hi,inputsToSave:["indices"],gradFunc:(e,t)=>{const n=t[0];return{indices:()=>tf(n.shape,"float32")}}},vy={kernelName:Gi,gradFunc:e=>({x:()=>Dd(e)})},wy={kernelName:ji,saveAllInputs:!0,gradFunc:(e,t,n)=>{const{axis:a}=n;return Ff(e,a).map((e=>()=>e))}},ky={kernelName:Ki,inputsToSave:["x"],gradFunc:(e,t,n)=>{const a=t[0],{paddings:r}=n,o=r.map((e=>e[0]));return{x:()=>yf(e,o,a.shape)}}},Iy={kernelName:qi,inputsToSave:["a","b"],outputsToSave:[!0],gradFunc:(e,t)=>{const[n,a,r]=t,o=n,s=a,i=Zd(o.shape,s.shape);return{a:()=>{const t=Cd(s,"float32");let n=Ad(e,Ad(t,Kd(o,qd(t,Ld(1)))));const a=Jd(o.shape,i);return a.length>0&&(n=Op(n,a)),Qh(n,o.shape)},b:()=>{const t=Tp(o,0),n=Of(t,_p(o),Dd(o));let a=Ad(e,Ad(r,n));const c=Jd(s.shape,i);return c.length>0&&(a=Op(a,c)),Qh(a,s.shape)}}}},Sy={kernelName:Xi,inputsToSave:["x","alpha"],gradFunc:(e,t)=>{const[n,a]=t,r=Tp(n,0);return{x:()=>Of(r,e,Ad(e,a)),alpha:()=>{let t=Of(r,Dd(e),Ad(e,n));const o=Jd(a.shape,e.shape);return o.length>0&&(t=Op(t,o)),Qh(t,a.shape)}}}};const Ny=Ru({cumprod_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],a=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const r={x:Tu(e,"x","cumprod")},o={axis:t,exclusive:n,reverse:a};return yu.runKernel(Rs,r,o)}});function Cy(e,t,n){const a=e.shape.length,r=a-n.length,o=Wp(n,a);let s=e;null!=o&&(s=Lf(e,o));const i=s.shape.slice(),c=i.splice(a-n.length,n.length).reduce(((e,t)=>e*t),1);i.push(c);let l=function(e,t,n){const a=e.shape.slice();a[n]=1;const r=Qh(t,a),o=Ny(e,n,!0,!1),s=Ny(e,n,!0,!0),i=Ad(o,s);return Ad(r,i)}(s.reshape(i),t,r);if(l=l.reshape(s.shape),null!=o){const e=Vp(o);l=Lf(l,e)}return l}const Ty={kernelName:Yi,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[a]=t,{axis:r}=n;let o=[];return o=void 0===r||null===r?a.shape.map(((e,t)=>t)):"number"===typeof r?[r]:r,{x:()=>Cy(a,e,o)}}},Ey={kernelName:Us,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,a]=t,r=Zd(n.shape,a.shape);return{a:()=>{const t=_d(e,Cd(a,"float32")),o=Jd(n.shape,r);return o.length>0?Qh(Op(t,o),n.shape):t},b:()=>{let t=Ad(e,Cd(n,"float32"));const o=Jd(a.shape,r);o.length>0&&(t=Qh(Op(t,o),a.shape));const s=Od(a);return Zp(_d(t,Cd(s,"float32")))}}}},Ry={kernelName:tc,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>_d(e,Zp(Od(n)))}}},_y={kernelName:cc,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t,a=Ad(Sm(n,6),Hf(n));return{x:()=>Ad(e,Cd(a,"float32"))}}},Ay={kernelName:nc,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>Ad(e,Cd(Hf(n),"float32"))}}},Fy={kernelName:ac,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>Qh(e,n.shape)}}},Oy={kernelName:sc,inputsToSave:["images"],gradFunc:(e,t,n)=>{const[a]=t,r={dy:e,images:a};return{images:()=>yu.runKernel(ic,r,n)}}},Dy={kernelName:rc,inputsToSave:["images"],gradFunc:(e,t,n)=>{const[a]=t,r={dy:e,images:a};return{images:()=>yu.runKernel(oc,r,n)}}},My={kernelName:lc,gradFunc:(e,t,n)=>{const{dims:a}=n,r=bo(a,e.shape);return{x:()=>ff(e,r)}}},Ly={kernelName:uc,gradFunc:e=>({x:()=>Dd(e)})},Py={kernelName:dc,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>Zp(_d(e,Ad(Kd(n,1.5),2)))}}};const zy=Ru({logicalNot_:function(e){const t={x:Tu(e,"x","logicalNot","bool")};return yu.runKernel(vi,t)}}),By={kernelName:mc,inputsToSave:["condition"],gradFunc:(e,t)=>{const[n]=t;return{condition:()=>Cd(Dd(n),"float32"),t:()=>Ad(e,Cd(n,e.dtype)),e:()=>Ad(e,Cd(zy(n),e.dtype))}}},Wy={kernelName:gc,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>{const t=Tp(n,Ld(0)),a=Ld(ig),r=Ld(cg),o=Ad(e,r),s=Ad(Ad(e,a),wp(Cd(n,"float32")));return Of(t,o,s)}}}},Vy={kernelName:wc,outputsToSave:[!0],gradFunc:(e,t)=>{const[n]=t;return{x:()=>Ad(e,Ad(n,qd(Ld(1),n)))}}},Uy={kernelName:vc,gradFunc:e=>({x:()=>Dd(e)})};const Gy=Ru({cos_:function(e){const t={x:Tu(e,"x","cos","float32")};return yu.runKernel(Ts,t)}}),Hy={kernelName:yc,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>Ad(Gy(Cd(n,"float32")),e)}}};const jy=Ru({cosh_:function(e){const t={x:Tu(e,"x","cosh","float32")};return yu.runKernel(Es,t)}}),Ky={kernelName:xc,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>Ad(jy(Cd(n,"float32")),e)}}},qy={kernelName:bc,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[a]=t,{begin:r,size:o}=n,s=a.shape,[i,c]=Rh(a,r,o),l=[];for(let u=0;u<e.rank;u++)l.push([i[u],s[u]-i[u]-c[u]]);return{x:()=>rf(e,l)}}},Xy={kernelName:Tc,outputsToSave:[!0],gradFunc:(e,t,n)=>{const[a]=t,{dim:r}=n,o=Ad(e,a);return{logits:()=>qd(o,Ad(Op(o,[r],true),a))}}},Yy={kernelName:kc,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>Ad(e,bf(n))}}};const Qy=Ru({batchToSpaceND_:function(e,t,n){const a=Tu(e,"x","batchToSpaceND"),r=t.reduce(((e,t)=>e*t));so(a.rank>=1+t.length,(()=>"input rank is ".concat(a.rank," but should be > than blockShape.length ").concat(t.length))),so(n.length===t.length,(()=>"crops.length is ".concat(n.length," but should be equal to blockShape.length  ").concat(t.length))),so(a.shape[0]%r===0,(()=>"input tensor batch is ".concat(a.shape[0]," but is not divisible by the product of ")+"the elements of blockShape ".concat(t.join(" * ")," === ").concat(r)));const o={x:a},s={blockShape:t,crops:n};return yu.runKernel(ds,o,s)}}),Jy={kernelName:Nc,gradFunc:(e,t,n)=>{const{blockShape:a,paddings:r}=n;return{x:()=>Qy(e,a,r)}}},Zy={kernelName:Cc,gradFunc:(e,t,n)=>{const{axis:a}=n;return{x:()=>op(e,a)}}},$y={kernelName:Oc,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,a]=t,r=Ld(2);return{a:()=>Ad(e,Ad(r,qd(n,a))),b:()=>Ad(e,Ad(r,qd(a,n)))}}},ex={kernelName:Wc,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,a]=t,r=Zd(n.shape,a.shape);return{a:()=>{let t=e;const a=Jd(n.shape,r);return a.length>0&&(t=Op(t,a)),Qh(t,n.shape)},b:()=>{let t=e;const n=Jd(a.shape,r);return n.length>0&&(t=Op(t,n)),Qh(Zp(t),a.shape)}}}},tx={kernelName:Gc,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[a]=t,{reps:r}=n;return{x:()=>{let t=Dd(a);if(1===a.rank)for(let n=0;n<r[0];++n)t=Ed(t,yf(e,[n*a.shape[0]],[a.shape[0]]));else if(2===a.rank)for(let n=0;n<r[0];++n)for(let o=0;o<r[1];++o)t=Ed(t,yf(e,[n*a.shape[0],o*a.shape[1]],[a.shape[0],a.shape[1]]));else if(3===a.rank)for(let n=0;n<r[0];++n)for(let o=0;o<r[1];++o)for(let s=0;s<r[2];++s)t=Ed(t,yf(e,[n*a.shape[0],o*a.shape[1],s*a.shape[2]],[a.shape[0],a.shape[1],a.shape[2]]));else{if(4!==a.rank)throw new Error("Gradient for tile operation is not implemented for rank-"+"".concat(a.rank," tensors yet."));for(let n=0;n<r[0];++n)for(let o=0;o<r[1];++o)for(let s=0;s<r[2];++s)for(let i=0;i<r[3];++i)t=Ed(t,yf(e,[n*a.shape[0],o*a.shape[1],s*a.shape[2],i*a.shape[3]],[a.shape[0],a.shape[1],a.shape[2],a.shape[3]]))}return t}}}},nx={kernelName:Yc,inputsToSave:["segmentIds"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>function(e,t){const n=$d(t,Dd(t)),a=Cp(e,n);let r=Ep(t,Ld(0,"int32"));const o=a.rank-r.rank;for(let i=0;i<o;++i)r=kp(r,i+1);r=Hp(r,nf(a.shape,"bool"));const s=Dd(a);return Of(r,a,s)}(e,n)}}};const ax=[Zg,$g,eb,tb,nb,ab,rb,ob,sb,ib,cb,lb,db,pb,fb,gb,bb,yb,xb,vb,wb,kb,Sb,Ib,Cb,Eb,_b,Fb,Ob,Db,Ey,Mb,Lb,Pb,zb,Bb,Vb,Wb,Gb,jb,Xb,Yb,Qb,Jb,Zb,$b,ey,ty,ny,ry,sy,sy,iy,ly,dy,hy,py,fy,my,gy,by,yy,xy,vy,wy,ky,ky,Iy,Sy,Ty,Ry,_y,Ay,Fy,Oy,Dy,My,Ly,Py,By,Wy,Vy,Uy,Hy,Ky,qy,Xy,Yy,Jy,Jy,Zy,Zy,{kernelName:Ic,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>_d(e,Ad(Fd(Cd(n,"float32")),2))}}},$y,{kernelName:Dc,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>Ad(e,Ad(Cd(n,"float32"),2))}}},{kernelName:Jc,gradFunc:e=>({x:()=>Dd(e)})},ex,{kernelName:Sc,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[a]=t,r=a.shape.slice(),{axis:o}=n;bo(o,a.shape).forEach((e=>{r[e]=1}));const s=Qh(e,r),i=Ad(s,nf(a.shape,"float32"));return{x:()=>i}}},{kernelName:Vc,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>_d(e,Od(Gy(n)))}}},{kernelName:Uc,outputsToSave:[!0],gradFunc:(e,t)=>{const[n]=t;return{x:()=>Ad(qd(Ld(1),Od(n)),e)}}},tx,{kernelName:Kc,gradFunc:(e,t,n)=>{const a=n,{perm:r}=a,o=Vp(r);return{x:()=>Lf(e,o)}}},{kernelName:Xc,gradFunc:(e,t,n)=>{const a=n,{axis:r}=a;return{value:()=>Tf(e,r)}}},nx,{kernelName:Qc,gradFunc:e=>({x:()=>Dd(e)})}];for(const n of ax)dl(n);Zl().prototype.abs=function(){return this.throwIfDisposed(),Yd(this)};const rx=Ru({acos_:function(e){const t={x:Tu(e,"x","acos")};return yu.runKernel(qo,t)}});Zl().prototype.acos=function(){return this.throwIfDisposed(),rx(this)};const ox=Ru({acosh_:function(e){const t={x:Tu(e,"x","acosh")};return yu.runKernel(Xo,t)}});Zl().prototype.acosh=function(){return this.throwIfDisposed(),ox(this)},Zl().prototype.add=function(e){return this.throwIfDisposed(),Ed(this,e)},Zl().prototype.all=function(e,t){return this.throwIfDisposed(),Fh(this,e,t)},Zl().prototype.any=function(e,t){return this.throwIfDisposed(),Oh(this,e,t)},Zl().prototype.argMax=function(e){return this.throwIfDisposed(),Dh(this,e)};const sx=Ru({argMin_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const n={x:Tu(e,"x","argMin")},a={axis:t};return yu.runKernel(es,n,a)}});Zl().prototype.argMin=function(e){return this.throwIfDisposed(),sx(this,e)},Zl().prototype.asScalar=function(){return this.throwIfDisposed(),so(1===this.size,(()=>"The array must have only 1 element.")),Qh(this,[])},Zl().prototype.asType=function(e){return this.throwIfDisposed(),Cd(this,e)},Zl().prototype.as1D=function(){return this.throwIfDisposed(),Qh(this,[this.size])},Zl().prototype.as2D=function(e,t){return this.throwIfDisposed(),Qh(this,[e,t])},Zl().prototype.as3D=function(e,t,n){return this.throwIfDisposed(),Qh(this,[e,t,n])},Zl().prototype.as4D=function(e,t,n,a){return this.throwIfDisposed(),Qh(this,[e,t,n,a])},Zl().prototype.as5D=function(e,t,n,a,r){return this.throwIfDisposed(),Qh(this,[e,t,n,a,r])};const ix=Ru({asin_:function(e){const t={x:Tu(e,"x","asin")};return yu.runKernel(ts,t)}});Zl().prototype.asin=function(){return this.throwIfDisposed(),ix(this)};const cx=Ru({asinh_:function(e){const t={x:Tu(e,"x","asinh")};return yu.runKernel(ns,t)}});Zl().prototype.asinh=function(){return this.throwIfDisposed(),cx(this)};const lx=Ru({atan_:function(e){const t={x:Tu(e,"x","atan")};return yu.runKernel(as,t)}});Zl().prototype.atan=function(){return this.throwIfDisposed(),lx(this)};const ux=Ru({atan2_:function(e,t){let n=Tu(e,"a","atan2"),a=Tu(t,"b","atan2");[n,a]=uu(n,a);const r={a:n,b:a};return yu.runKernel(os,r)}});Zl().prototype.atan2=function(e){return this.throwIfDisposed(),ux(this,e)};const dx=Ru({atanh_:function(e){const t={x:Tu(e,"x","atanh")};return yu.runKernel(rs,t)}});Zl().prototype.atanh=function(){return this.throwIfDisposed(),dx(this)},Zl().prototype.avgPool=function(e,t,n,a){return this.throwIfDisposed(),Jh(this,e,t,n,a)},Zl().prototype.batchToSpaceND=function(e,t){return this.throwIfDisposed(),Qy(this,e,t)},Zl().prototype.batchNorm=function(e,t,n,a,r){return this.throwIfDisposed(),$h(this,e,t,n,a,r)},Zl().prototype.broadcastTo=function(e){return this.throwIfDisposed(),ap(this,e)},Zl().prototype.cast=function(e){return this.throwIfDisposed(),Cd(this,e)};const hx=Ru({ceil_:function(e){const t={x:Tu(e,"x","ceil","float32")};return yu.runKernel(gs,t)}});Zl().prototype.ceil=function(){return this.throwIfDisposed(),hx(this)},Zl().prototype.clipByValue=function(e,t){return this.throwIfDisposed(),rp(this,e,t)},Zl().prototype.concat=function(e,t){return this.throwIfDisposed(),e instanceof Jl&&(e=[e]),op([this,...e],t)},Zl().prototype.conv1d=function(e,t,n,a,r,o){return this.throwIfDisposed(),dp(this,e,t,n,a,r,o)},Zl().prototype.conv2dTranspose=function(e,t,n,a,r){return this.throwIfDisposed(),pp(this,e,t,n,a,r)},Zl().prototype.conv2d=function(e,t,n,a,r,o){return this.throwIfDisposed(),up(this,e,t,n,a,r,o)},Zl().prototype.cos=function(){return this.throwIfDisposed(),Gy(this)},Zl().prototype.cosh=function(){return this.throwIfDisposed(),jy(this)},Zl().prototype.cumprod=function(e,t,n){return this.throwIfDisposed(),Ny(this,e,t,n)},Zl().prototype.cumsum=function(e,t,n){return this.throwIfDisposed(),Ab(this,e,t,n)};const px=Ru({depthToSpace_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"NHWC";const a=Tu(e,"x","depthToSpace","float32"),r="NHWC"===n?a.shape[1]:a.shape[2],o="NHWC"===n?a.shape[2]:a.shape[3],s="NHWC"===n?a.shape[3]:a.shape[1];so(t>1,(()=>"blockSize should be > 1 for depthToSpace, but was: ".concat(t))),so(r*t>=0,(()=>"Negative dimension size caused by overflow when multiplying\n    ".concat(r," and ").concat(t,"  for depthToSpace with input shape\n    ").concat(a.shape))),so(o*t>=0,(()=>"Negative dimension size caused by overflow when multiplying\n    ".concat(o," and ").concat(t," for depthToSpace with input shape\n        ").concat(a.shape))),so(s%(t*t)===0,(()=>"Dimension size must be evenly divisible by ".concat(t*t," but is ").concat(s," for depthToSpace with input shape ").concat(a.shape)));const i={x:a},c={blockSize:t,dataFormat:n};return yu.runKernel(Os,i,c)}});Zl().prototype.depthToSpace=function(e,t){return this.throwIfDisposed(),px(this,e,t)},Zl().prototype.depthwiseConv2d=function(e,t,n,a,r,o){return this.throwIfDisposed(),yp(this,e,t,n,a,r,o)};const fx=Ru({dilation2d_:function(e,t,n,a){let r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:[1,1],o=arguments.length>5&&void 0!==arguments[5]?arguments[5]:"NHWC";const s=Tu(e,"x","dilation2d"),i=Tu(t,"filter","dilation2d");so(3===s.rank||4===s.rank,(()=>"Error in dilation2d: input must be rank 3 or 4, but got rank "+"".concat(s.rank,"."))),so(3===i.rank,(()=>"Error in dilation2d: filter must be rank 3, but got rank "+"".concat(i.rank,"."))),so("NHWC"===o,(()=>"Error in dilation2d: Only NHWC is currently supported, "+"but got dataFormat of ".concat(o)));let c=s,l=!1;3===s.rank&&(c=Qh(s,[1,s.shape[0],s.shape[1],s.shape[2]]),l=!0),so(c.shape[3]===i.shape[2],(()=>"Error in dilation2d:  input and filter must have the same depth: ".concat(c.shape[3]," vs ").concat(i.shape[2])));const u={x:c,filter:i},d={strides:n,pad:a,dilations:r},h=yu.runKernel(zs,u,d);return l?Qh(h,[h.shape[1],h.shape[2],h.shape[3]]):h}});Zl().prototype.dilation2d=function(e,t,n,a,r){return this.throwIfDisposed(),fx(this,e,t,n,a,r)};const mx=Ru({divNoNan_:function(e,t){let n=Tu(e,"a","div"),a=Tu(t,"b","div");[n,a]=uu(n,a);const r=_d(n,a),o=Dd(r),s=vp(a,o);return Of(s,o,r)}});Zl().prototype.divNoNan=function(e){return this.throwIfDisposed(),mx(this,e)},Zl().prototype.div=function(e){return this.throwIfDisposed(),_d(this,e)};const gx=Ru({dot_:function(e,t){const n=Tu(e,"t1","dot"),a=Tu(t,"t2","dot");so((1===n.rank||2===n.rank)&&(1===a.rank||2===a.rank),(()=>"Error in dot: inputs must all be rank 1 or 2, but got ranks "+"".concat(n.rank," and ").concat(a.rank,".")));const r=1===n.rank?n.size:n.shape[1],o=1===a.rank?a.size:a.shape[0];if(so(r===o,(()=>"Error in dot: inner dimensions of inputs must match, but got "+"".concat(r," and ").concat(o,"."))),1===n.rank&&1===a.rank){const e=Qh(n,[1,-1]),t=Qh(a,[-1,1]),r=jp(e,t);return Qh(r,[])}if(1===n.rank&&2===a.rank){const e=Qh(n,[1,-1]),t=Qh(a,[a.shape[0],a.shape[1]]),r=jp(e,t);return Qh(r,[r.size])}if(2===n.rank&&1===a.rank){const e=Qh(a,[-1,1]),t=jp(n,e);return Qh(t,[t.size])}{const e=Qh(a,[a.shape[0],a.shape[1]]);return jp(n,e)}}});Zl().prototype.dot=function(e){return this.throwIfDisposed(),gx(this,e)},Zl().prototype.elu=function(){return this.throwIfDisposed(),xp(this)},Zl().prototype.equal=function(e){return this.throwIfDisposed(),vp(this,e)};const bx=Ru({erf_:function(e){let t=Tu(e,"x","erf");so("int32"===t.dtype||"float32"===t.dtype,(()=>"Input dtype must be `int32` or `float32`.")),"int32"===t.dtype&&(t=Cd(t,"float32"));const n={x:t};return yu.runKernel(Ks,n)}});Zl().prototype.erf=function(){return this.throwIfDisposed(),bx(this)};const yx=Ru({euclideanNorm_:function(e){return Am(e,"euclidean",arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,arguments.length>2&&void 0!==arguments[2]&&arguments[2])}});Zl().prototype.euclideanNorm=function(e,t){return this.throwIfDisposed(),yx(this,e,t)},Zl().prototype.exp=function(){return this.throwIfDisposed(),wp(this)},Zl().prototype.expandDims=function(e){return this.throwIfDisposed(),kp(this,e)};const xx=Ru({expm1_:function(e){const t={x:Tu(e,"x","expm1")};return yu.runKernel(Qs,t)}});Zl().prototype.expm1=function(){return this.throwIfDisposed(),xx(this)},Zl().prototype.fft=function(){return this.throwIfDisposed(),zf(this)},Zl().prototype.flatten=function(){return this.throwIfDisposed(),Qh(this,[this.size])},Zl().prototype.floor=function(){return this.throwIfDisposed(),Np(this)},Zl().prototype.floorDiv=function(e){return this.throwIfDisposed(),Rd(this,e)},Zl().prototype.gather=function(e,t,n){return this.throwIfDisposed(),Cp(this,e,t,n)},Zl().prototype.greaterEqual=function(e){return this.throwIfDisposed(),Ep(this,e)},Zl().prototype.greater=function(e){return this.throwIfDisposed(),Tp(this,e)},Zl().prototype.ifft=function(){return this.throwIfDisposed(),Wf(this)},Zl().prototype.irfft=function(){return this.throwIfDisposed(),Vf(this)};const vx=Ru({isFinite_:function(e){const t={x:Tu(e,"x","isFinite")};return yu.runKernel(ui,t)}});Zl().prototype.isFinite=function(){return this.throwIfDisposed(),vx(this)};const wx=Ru({isInf_:function(e){const t={x:Tu(e,"x","isInf")};return yu.runKernel(di,t)}});Zl().prototype.isInf=function(){return this.throwIfDisposed(),wx(this)};const kx=Ru({isNaN_:function(e){const t={x:Tu(e,"x","isNaN")};return yu.runKernel(hi,t)}});Zl().prototype.isNaN=function(){return this.throwIfDisposed(),kx(this)},Zl().prototype.leakyRelu=function(e){return this.throwIfDisposed(),Rp(this,e)},Zl().prototype.lessEqual=function(e){return this.throwIfDisposed(),Sm(this,e)},Zl().prototype.less=function(e){return this.throwIfDisposed(),Em(this,e)};const Ix=Ru({localResponseNormalization_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:5,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1,r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:.5;const o=Tu(e,"x","localResponseNormalization");so(4===o.rank||3===o.rank,(()=>"Error in localResponseNormalization: x must be rank 3 or 4 but got\n               rank ".concat(o.rank,"."))),so(ho(t),(()=>"Error in localResponseNormalization: depthRadius must be an "+"integer but got depthRadius ".concat(t,".")));let s=o,i=!1;3===o.rank&&(i=!0,s=Qh(o,[1,o.shape[0],o.shape[1],o.shape[2]]));const c={x:s},l={depthRadius:t,bias:n,alpha:a,beta:r},u=yu.runKernel(ki,c,l);return i?Qh(u,[u.shape[1],u.shape[2],u.shape[3]]):u}});Zl().prototype.localResponseNormalization=function(e,t,n,a){return this.throwIfDisposed(),Ix(this,e,t,n,a)};const Sx=Ru({logSigmoid_:function(e){const t=Tu(e,"x","logSigmoid");return Md((e=>({value:Zp(Sf(Zp(e))),gradFunc:t=>Ad(t,bf(Zp(e)))})))(t)}});Zl().prototype.logSigmoid=function(){return this.throwIfDisposed(),Sx(this)},Zl().prototype.logSoftmax=function(e){return this.throwIfDisposed(),Dp(this,e)},Zl().prototype.logSumExp=function(e,t){return this.throwIfDisposed(),Gp(this,e,t)},Zl().prototype.log=function(){return this.throwIfDisposed(),_p(this)},Zl().prototype.log1p=function(){return this.throwIfDisposed(),Ap(this)},Zl().prototype.logicalAnd=function(e){return this.throwIfDisposed(),Hp(this,e)},Zl().prototype.logicalNot=function(){return this.throwIfDisposed(),zy(this)};const Nx=Ru({logicalOr_:function(e,t){const n=Tu(e,"a","logicalOr","bool"),a=Tu(t,"b","logicalOr","bool");Zd(n.shape,a.shape);const r={a:n,b:a};return yu.runKernel(wi,r)}});Zl().prototype.logicalOr=function(e){return this.throwIfDisposed(),Nx(this,e)};const Cx=Ru({logicalXor_:function(e,t){const n=Tu(e,"a","logicalXor","bool"),a=Tu(t,"b","logicalXor","bool");return Zd(n.shape,a.shape),Hp(Nx(e,t),zy(Hp(e,t)))}});Zl().prototype.logicalXor=function(e){return this.throwIfDisposed(),Cx(this,e)},Zl().prototype.matMul=function(e,t,n){return this.throwIfDisposed(),jp(this,e,t,n)},Zl().prototype.maxPool=function(e,t,n,a){return this.throwIfDisposed(),Kp(this,e,t,n,a)},Zl().prototype.max=function(e,t){return this.throwIfDisposed(),Fp(this,e,t)},Zl().prototype.maximum=function(e){return this.throwIfDisposed(),$d(this,e)},Zl().prototype.mean=function(e,t){return this.throwIfDisposed(),Xp(this,e,t)},Zl().prototype.min=function(e,t){return this.throwIfDisposed(),Yp(this,e,t)},Zl().prototype.minimum=function(e){return this.throwIfDisposed(),Qp(this,e)};const Tx=Ru({mirrorPad_:function(e,t,n){so("reflect"===n||"symmetric"===n,(()=>"Invalid mode. Mode must be either reflect or symmetric. "+"Got ".concat(n,".")));const a=Tu(e,"x","mirrorPad");if(0===a.rank)throw new Error("mirrorPad(scalar) is not defined. Pass non-scalar to mirrorPad");so(t.length===a.rank,(()=>"Padding doesn't match input. Must be ".concat(a.rank,". ")+"Got ".concat(t.length,".")));const r="reflect"===n?1:0;for(let i=0;i<a.rank;i++)so(2===t[i].length,(()=>"Invalid number of paddings. Must be length of 2 each.")),so(t[i][0]>=0&&t[i][0]<=a.shape[i]-r&&t[i][1]>=0&&t[i][1]<=a.shape[i]-r,(()=>"Padding in dimension ".concat(i," cannot be greater than or equal ")+"to ".concat(a.shape[i]-r," or less than 0 for input of ")+"shape ".concat(a.shape)));const o={paddings:t,mode:n},s={x:a};return yu.runKernel(Di,s,o)}});Zl().prototype.mirrorPad=function(e,t){return this.throwIfDisposed(),Tx(this,e,t)};const Ex=Ru({mod_:function(e,t){let n=Tu(e,"a","mod"),a=Tu(t,"b","mod");[n,a]=uu(n,a);const r={a:n,b:a};return yu.runKernel(Mi,r)}});Zl().prototype.mod=function(e){return this.throwIfDisposed(),Ex(this,e)},Zl().prototype.mul=function(e){return this.throwIfDisposed(),Ad(this,e)},Zl().prototype.neg=function(){return this.throwIfDisposed(),Zp(this)},Zl().prototype.norm=function(e,t,n){return this.throwIfDisposed(),Am(this,e,t,n)},Zl().prototype.notEqual=function(e){return this.throwIfDisposed(),$p(this,e)},Zl().prototype.oneHot=function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;return this.throwIfDisposed(),ef(this,e,t,n)},Zl().prototype.onesLike=function(){return this.throwIfDisposed(),af(this)},Zl().prototype.pad=function(e,t){return this.throwIfDisposed(),rf(this,e,t)};const Rx=Ru({pool_:function(e,t,n,a,r,o,s){null==r&&(r=[1,1]),null==o&&(o=1),0===a&&(a="valid");const i=Tu(e,"x","maxPool");let c=i,l=!1;3===i.rank&&(l=!0,c=Qh(i,[1,i.shape[0],i.shape[1],i.shape[2]])),so(Kh(o,r),(()=>"Error in pool: Either strides or dilations must be 1. "+"Got strides ".concat(o," and dilations '").concat(r,"'")));const u=Lh(c.shape,t,o,r,a),d=[u.dilationHeight,u.dilationWidth];let h;h="same"===a?function(e,t){const n=e.map(((e,n)=>e+(e-1)*(t[n]-1))),a=n.map((e=>e-1)),r=a.map((e=>Math.floor(e/2))),o=a.map(((e,t)=>e-r[t]));return a.map(((e,t)=>[r[t],o[t]]))}([u.filterHeight,u.filterWidth],d):[[0,0],[0,0]];const p=1===d[0]&&1===d[1],[f,m]=function(e,t,n){const a=n.map((e=>e[0])),r=n.map((e=>e[1])),o=e.concat(a,r),s=t.map(((e,t)=>(e-o[t]%e)%e)),i=r.map(((e,t)=>e+s[t])),c=t.map(((e,t)=>[a[t],i[t]])),l=t.map(((e,t)=>[0,s[t]]));return[c,l]}([u.inHeight,u.inWidth],d,h),g=p?a:"valid",b=p?c:mb(c,d,f),y=("avg"===n?()=>Jh(b,t,o,g,s):()=>Kp(b,t,o,g,s))(),x=p?y:Qy(y,d,m);return l?Qh(x,[x.shape[1],x.shape[2],x.shape[3]]):x}});Zl().prototype.pool=function(e,t,n,a,r,o){return this.throwIfDisposed(),Rx(this,e,t,n,a,r,o)},Zl().prototype.pow=function(e){return this.throwIfDisposed(),Kd(this,e)},Zl().prototype.prelu=function(e){return this.throwIfDisposed(),of(this,e)};const _x=Ru({prod_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],a=Tu(e,"x","prod");"bool"===a.dtype&&(a=Cd(a,"int32"));const r={x:a},o={axis:t,keepDims:n};return yu.runKernel(Yi,r,o)}});Zl().prototype.prod=function(e,t){return this.throwIfDisposed(),_x(this,e,t)};const Ax=Ru({reciprocal_:function(e){const t={x:Tu(e,"x","reciprocal")};return yu.runKernel(tc,t)}});Zl().prototype.reciprocal=function(){return this.throwIfDisposed(),Ax(this)},Zl().prototype.relu=function(){return this.throwIfDisposed(),pf(this)},Zl().prototype.relu6=function(){return this.throwIfDisposed(),Gf(this)},Zl().prototype.reshapeAs=function(e){return this.throwIfDisposed(),Qh(this,e.shape)},Zl().prototype.reshape=function(e){return this.throwIfDisposed(),Qh(this,e)},Zl().prototype.resizeBilinear=function(e,t,n){return this.throwIfDisposed(),wm(this,e,t,n)},Zl().prototype.resizeNearestNeighbor=function(e,t,n){return this.throwIfDisposed(),km(this,e,t,n)},Zl().prototype.reverse=function(e){return this.throwIfDisposed(),ff(this,e)},Zl().prototype.rfft=function(){return this.throwIfDisposed(),Bf(this)},Zl().prototype.round=function(){return this.throwIfDisposed(),Nm(this)},Zl().prototype.rsqrt=function(){return this.throwIfDisposed(),Ub(this)},Zl().prototype.selu=function(){return this.throwIfDisposed(),mf(this)},Zl().prototype.separableConv2d=function(e,t,n,a,r,o){return this.throwIfDisposed(),gf(this,e,t,n,a,r,o)},Zl().prototype.sigmoid=function(){return this.throwIfDisposed(),bf(this)};const Fx=Ru({sign_:function(e){const t={x:Tu(e,"x","sign")};return yu.runKernel(vc,t)}});Zl().prototype.sign=function(){return this.throwIfDisposed(),Fx(this)},Zl().prototype.sin=function(){return this.throwIfDisposed(),Tb(this)},Zl().prototype.sinh=function(){return this.throwIfDisposed(),Rb(this)},Zl().prototype.slice=function(e,t){return this.throwIfDisposed(),yf(this,e,t)},Zl().prototype.softmax=function(e){return this.throwIfDisposed(),If(this,e)},Zl().prototype.softplus=function(){return this.throwIfDisposed(),Sf(this)},Zl().prototype.spaceToBatchND=function(e,t){return this.throwIfDisposed(),mb(this,e,t)},Zl().prototype.split=function(e,t){return this.throwIfDisposed(),Nf(this,e,t)},Zl().prototype.sqrt=function(){return this.throwIfDisposed(),Fd(this)},Zl().prototype.square=function(){return this.throwIfDisposed(),Od(this)},Zl().prototype.squaredDifference=function(e){return this.throwIfDisposed(),Lm(this,e)},Zl().prototype.squeeze=function(e){return this.throwIfDisposed(),Cf(this,e)},Zl().prototype.stack=function(e,t){this.throwIfDisposed();const n=e instanceof Jl?[this,e]:[this,...e];return Tf(n,t)},Zl().prototype.step=function(e){return this.throwIfDisposed(),Hf(this,e)};const Ox=Ru({stridedSlice_:function(e,t,n,a){let r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:0,o=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0,s=arguments.length>6&&void 0!==arguments[6]?arguments[6]:0,i=arguments.length>7&&void 0!==arguments[7]?arguments[7]:0,c=arguments.length>8&&void 0!==arguments[8]?arguments[8]:0;const l={x:Tu(e,"x","stridedSlice","string_or_numeric")},u={begin:t,end:n,strides:a,beginMask:r,endMask:o,ellipsisMask:s,newAxisMask:i,shrinkAxisMask:c};return yu.runKernel(Lc,l,u)}});Zl().prototype.stridedSlice=function(e,t,n,a,r,o,s,i){return this.throwIfDisposed(),Ox(this,e,t,n,a,r,o,s,i)},Zl().prototype.sub=function(e){return this.throwIfDisposed(),qd(this,e)},Zl().prototype.sum=function(e,t){return this.throwIfDisposed(),Op(this,e,t)};const Dx=Ru({tan_:function(e){const t={x:Tu(e,"x","tan","float32")};return yu.runKernel(Vc,t)}});Zl().prototype.tan=function(){return this.throwIfDisposed(),Dx(this)},Zl().prototype.tanh=function(){return this.throwIfDisposed(),Ef(this)},Zl().prototype.tile=function(e){return this.throwIfDisposed(),Ip(this,e)},Zl().prototype.toBool=function(){return this.throwIfDisposed(),Cd(this,"bool")},Zl().prototype.toFloat=function(){return this.throwIfDisposed(),Cd(this,"float32")},Zl().prototype.toInt=function(){return this.throwIfDisposed(),Cd(this,"int32")};const Mx=Ru({topk_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,n=!(arguments.length>2&&void 0!==arguments[2])||arguments[2];const a=Tu(e,"x","topk");if(0===a.rank)throw new Error("topk() expects the input to be of rank 1 or higher");const r=a.shape[a.shape.length-1];if(t<0)throw new Error("'k' passed to topk() must be >= 0 but got ".concat(t));if(t>r)throw new Error("'k' passed to topk() must be <= the last dimension (".concat(r,") ")+"but got ".concat(t));const o={x:a},s={k:t,sorted:n},[i,c]=yu.runKernel(Hc,o,s);return{values:i,indices:c}}});Zl().prototype.topk=function(e,t){return this.throwIfDisposed(),Mx(this,e,t)},Zl().prototype.transpose=function(e){return this.throwIfDisposed(),Lf(this,e)};const Lx=Ru({unique_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const n=Tu(e,"x","unique","string_or_numeric");so(n.rank>0,(()=>"The input tensor must be at least 1D"));const a={x:n},r={axis:t},[o,s]=yu.runKernel(qc,a,r);return{values:o,indices:s}}});Zl().prototype.unique=function(e){return this.throwIfDisposed(),Lx(this,e)},Zl().prototype.unsortedSegmentSum=function(e,t){return this.throwIfDisposed(),Hb(this,e,t)},Zl().prototype.unstack=function(e){return this.throwIfDisposed(),Ff(this,e)},Zl().prototype.where=function(e,t){return this.throwIfDisposed(),Of(e,this,t)},Zl().prototype.zerosLike=function(){return this.throwIfDisposed(),Dd(this)};class Px extends Error{constructor(e){super(e),Object.setPrototypeOf(this,Px.prototype)}}class zx extends Error{constructor(e){super(e),Object.setPrototypeOf(this,zx.prototype)}}class Bx extends Error{constructor(e){super(e),Object.setPrototypeOf(this,Bx.prototype)}}class Wx extends Error{constructor(e){super(e),Object.setPrototypeOf(this,Wx.prototype)}}class Vx extends Error{constructor(e){super(e),Object.setPrototypeOf(this,Vx.prototype)}}Error;class Ux{constructor(e){this.maxEntries=e||100,this.cache=new Map}get(e){let t;return this.cache.has(e)&&(t=this.cache.get(e),this.cache.delete(e),this.cache.set(e,t)),t}put(e,t){if(this.cache.has(e))this.cache.delete(e);else if(this.cache.size>=this.maxEntries){const e=this.cache.keys().next().value;this.cache.delete(e)}this.cache.set(e,t)}getMaxEntries(){return this.maxEntries}setMaxEntries(e){if(e<0)throw new Error("The maxEntries of LRU caches must be at least 0, but got ".concat(e,"."));if(this.maxEntries>e)for(let t=0;t<this.maxEntries-e;t++){const e=this.cache.keys().next().value;this.cache.delete(e)}this.maxEntries=e}}function Gx(e,t){if(Array.isArray(e)){let n=[];for(let a=0;a<t;a++)n=n.concat(e);return n}{const n=new Array(t);return n.fill(e),n}}function Hx(e,t){if(!e)throw new Vx(t)}function jx(e,t){let n=0;for(const a of e)a===t&&n++;return n}function Kx(e){return 1===e.length?e[0]:e}function qx(e){return Array.isArray(e)?e:[e]}function Xx(e){const t=e.replace(/(.)([A-Z][a-z0-9]+)/g,"$1_$2").replace(/([a-z])([A-Z])/g,"$1_$2").toLowerCase();return"_"!==t[0]?t:"private"+t}function Yx(e){return e.length<=1||-1===e.indexOf("_")?e:e.replace(/[_]+(\w|$)/g,((e,t)=>t.toUpperCase()))}let Qx={};function Jx(e){if(null===e||void 0===e)return null;const t={};return t.className=e.getClassName(),t.config=e.getConfig(),t}function Zx(e){if(null!=e&&"object"===typeof e)if(Array.isArray(e))e.forEach((e=>Zx(e)));else{const t=Object.keys(e);for(const n of t){const t=e[n];null!=t&&"object"===typeof t&&(Array.isArray(t)||"ndarray"!==t.type||"number"!==typeof t.value?Zx(t):e[n]=t.value)}}}function $x(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{},a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"object",r=arguments.length>4&&void 0!==arguments[4]&&arguments[4];if("string"===typeof e){const r=e;let o;if(r in n)o=n[r];else if(r in Qx)o=Qx[r];else if(o=t[r],null==o)throw new Bx("Unknown ".concat(a,": ").concat(e,". ")+"This may be due to one of the following reasons:\n"+"1. The ".concat(a," is defined in Python, in which ")+"case it needs to be ported to TensorFlow.js or your JavaScript code.\n"+"2. The custom ".concat(a," is defined in JavaScript, ")+"but is not registered properly with tf.serialization.registerClass().");return o}{const o=e;if(null==o.className||null==o.config)throw new Bx("".concat(a,": Improper config format: ")+"".concat(JSON.stringify(o),".\n")+"'className' and 'config' must set.");const s=o.className;let i,c;if(s in n?[i,c]=n[s]:s in Qx?[i,c]=Qx.className:s in t&&([i,c]=t[s]),null==i)throw new Bx("Unknown ".concat(a,": ").concat(s,". ")+"This may be due to one of the following reasons:\n"+"1. The ".concat(a," is defined in Python, in which ")+"case it needs to be ported to TensorFlow.js or your JavaScript code.\n"+"2. The custom ".concat(a," is defined in JavaScript, ")+"but is not registered properly with tf.serialization.registerClass().");if(null!=c){const e={};for(const n of Object.keys(Qx))e[n]=Qx[n];for(const r of Object.keys(n))e[r]=n[r];o.config.customObjects=e;const t=Object.assign({},Qx);for(const r of Object.keys(n))Qx[r]=n[r];Zx(o.config);const a=c(i,o.config,n,r);return Qx=Object.assign({},t),a}{const e=Object.assign({},Qx);for(const a of Object.keys(n))Qx[a]=n[a];const t=new i(o.config);return Qx=Object.assign({},e),t}}}function ev(e,t){return-1*function(e,t){return e<t?-1:e>t?1:0}(e,t)}function tv(e){if(null==e)return e;const t=[];for(const n of e)-1===t.indexOf(n)&&t.push(n);return t}function nv(e){if(null==e)throw new Bx("Invalid value in obj: ".concat(JSON.stringify(e)));for(const t in e)if(e.hasOwnProperty(t))return!1;return!0}function av(e,t,n){if(null!=n&&e.indexOf(n)<0)throw new Bx("".concat(n," is not a valid ").concat(t,".  Valid values are ").concat(e," or null/undefined."))}function rv(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1/0;return Hx(n>=0),Hx(a>=n),Array.isArray(e)&&e.length>=n&&e.length<=a&&e.every((e=>typeof e===t))}function ov(e,t){Array.isArray(e)?(so(e.length>0,(()=>"".concat(t," is unexpectedly an empty array."))),e.forEach(((e,n)=>ov(e,"element ".concat(n+1," of ").concat(t))))):so(Number.isInteger(e)&&e>0,(()=>"Expected ".concat(t," to be a positive integer, but got ")+"".concat(sv(e),".")))}function sv(e){return null===e?"null":Array.isArray(e)?"["+e.map((e=>sv(e))).join(",")+"]":"string"===typeof e?'"'.concat(e,'"'):"".concat(e)}function iv(e){return"relu"===e?"relu":"linear"===e?"linear":"elu"===e?"elu":null}let cv=0;function lv(){return cv++}const uv={};function dv(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:"";return e in uv||(uv[e]=0),uv[e]+=1,e+uv[e].toString()}const hv=["channelsFirst","channelsLast"],pv=["nearest","bilinear"],fv=["valid","same","causal"],mv=["max","avg"],gv=["sum","mul","concat","ave"],bv=new Map;function yv(e){av(hv,"DataFormat",e)}function xv(e){av(fv,"PaddingMode",e)}function vv(e){av(mv,"PoolMode",e)}const wv=[],kv="/";function Iv(e,t){wv.push(e);try{const e=t();return wv.pop(),e}catch(D){throw wv.pop(),D}}function Sv(e){if(!Tv(e))throw new Error("Not a valid tensor name: '"+e+"'");return(0===wv.length?"":wv.join(kv)+kv)+e}function Nv(e){if(!Tv(e))throw new Error("Not a valid tensor name: '"+e+"'");bv.has(e)||bv.set(e,0);const t=bv.get(e);if(bv.set(e,bv.get(e)+1),t>0){const n="".concat(e,"_").concat(t);return bv.set(n,1),n}return e}const Cv=new RegExp(/^[A-Za-z0-9][-A-Za-z0-9\._\/]*$/);function Tv(e){return!!e.match(Cv)}function Ev(e,t,n){null==t&&(t=0),null==n&&(n=e.length);let a=1;for(let r=t;r<n;++r)a*=e[r];return a}function Rv(e){if(0===e.length)return Number.NaN;let t=Number.POSITIVE_INFINITY;for(let n=0;n<e.length;n++){const a=e[n];a<t&&(t=a)}return t}function _v(e){if(0===e.length)return Number.NaN;let t=Number.NEGATIVE_INFINITY;for(let n=0;n<e.length;n++){const a=e[n];a>t&&(t=a)}return t}function Av(e,t){if(t<e)throw new Bx("end (".concat(t,") < begin (").concat(e,") is forbidden."));const n=[];for(let a=e;a<t;++a)n.push(a);return n}let Fv;function Ov(){return null==Fv&&(Fv=Vu().epsilon()),Fv}function Dv(e,t){return Cd(e,t)}function Mv(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:-1;const n=e.shape.slice();return t<0&&(t=n.length+t+1),n.splice(t,0,1),Qh(e,n)}function Lv(e,t,n){return Lu((()=>{switch(e.rank){case 1:return xf(e,t,n);case 2:return vf(e,[t,0],[n,e.shape[1]]);case 3:return wf(e,[t,0,0],[n,e.shape[1],e.shape[2]]);case 4:return kf(e,[t,0,0,0],[n,e.shape[1],e.shape[2],e.shape[3]]);case 5:return yf(e,[t,0,0,0,0],[n,e.shape[1],e.shape[2],e.shape[3],e.shape[4]]);case 6:return yf(e,[t,0,0,0,0,0],[n,e.shape[1],e.shape[2],e.shape[3],e.shape[4],e.shape[5]]);default:throw new Bx("sliceAlongFirstAxis() received an unsupported tensor rank: "+"".concat(e.rank))}}))}function Pv(e,t,n){return Lu((()=>{switch(e.rank){case 1:return xf(e,t,n);case 2:return vf(e,[0,t],[e.shape[0],n]);case 3:return wf(e,[0,0,t],[e.shape[0],e.shape[1],n]);case 4:return kf(e,[0,0,0,t],[e.shape[0],e.shape[1],e.shape[2],n]);default:throw new Bx("sliceAlongLastAxis() received an unsupported tensor rank: "+"".concat(e.rank))}}))}function zv(e,t,n,a){return Lu((()=>{switch(e.rank){case 1:return xf(e,t,n);case 2:switch(a){case 1:return Lv(e,t,n);case 2:return Pv(e,t,n);default:throw new Bx("The axis is not within the rank of the tensor "+"".concat(a))}case 3:switch(a){case 1:return Lv(e,t,n);case 2:return wf(e,[0,t,0],[e.shape[0],n,e.shape[2]]);case 3:return Pv(e,t,n);default:throw new Bx("The axis is not within the rank of the tensor "+"".concat(a))}case 4:switch(a){case 1:return Lv(e,t,n);case 2:return kf(e,[0,t,0,0],[e.shape[0],n,e.shape[2],e.shape[3]]);case 3:return kf(e,[0,0,t,0],[e.shape[0],e.shape[1],n,e.shape[3]]);case 4:return Pv(e,t,n);default:throw new Bx("The axis is not within the rank of the tensor "+"".concat(a))}default:throw new Bx("sliceAlongLastAxis() received an unsupported tensor rank: "+"".concat(e.rank))}}))}function Bv(e){let t,n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:-1;return n<0&&(t=e[0].rank,n=0!==t?t:0),n===e[0].rank&&(n=-1),op(e,n)}function Wv(e,t){switch(e.rank){case 1:return sp([e,t]);case 2:return ip([e,t],0);case 3:return cp([e,t],0);case 4:return lp([e,t],0);default:throw new Bx("concatAlongFirstAxis() received an unsupported "+"tensor rank: ".concat(e.rank))}}function Vv(e,t){if(Array.isArray(t)||(t=[t]),e.rank!==t.length)throw new Bx("The length of input n (".concat(t.length,") does not match ")+"the number of dimensions in input x (".concat(e.rank,")"));return Ip(e,t)}function Uv(e){return uf(e,arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,arguments.length>3?arguments[3]:void 0,arguments.length>4?arguments[4]:void 0)}function Gv(e,t,n,a){if(e.rank<2||t.rank<2)throw new Wx("dot requires both inputs to be rank >= 2"+" but got x shape = ".concat(e.shape," and y shape = ").concat(t.shape));if(t.rank>=3){if(e.shape.slice(-1)[0]!==t.shape.slice(-2)[0])throw new Wx("If rank y >= 3, then the second last dim"+" of y must equal the last dim of x but got x shape = ".concat(e.shape," and ")+" y shape = ".concat(t.shape))}if(2===e.rank&&2===t.rank){return Zf({a:e,b:t,transposeA:!1,transposeB:!1,bias:a?Kv(e.rank,a,"channelsLast"):null,activation:n})}{const r=e.shape.slice(),o=r.pop();e=Qh(e,[-1,o]);const s=t.shape.slice(),i=s.pop(),c=s.pop(),l=[...s,i],u=Array.from({length:t.rank},((e,n)=>0===n?t.rank-2:n<=t.rank-2?n-1:n));t=Qh(Lf(t,u),[c,-1]);const d=[...r,...l];return Qh(Zf({a:e,b:t,transposeA:!1,transposeB:!1,bias:a?Kv(e.rank,a,"channelsLast"):null,activation:n}),d)}}function Hv(e,t,n){return Lu((()=>(t=Array.isArray(t)?Rf(t,"int32"):Cd(t,"int32"),Cp(e,t,n))))}function jv(e){return Ad(e,e)}function Kv(e,t,n){const a=t.shape;if(1!==t.rank&&t.rank!==e)throw new Bx("Unexpected bias dimensions: ".concat(t.rank)+"; expected it to be 1 or ".concat(e));if(5===e){if("channelsFirst"===n)return 1===a.length?Qh(t,[1,a[0],1,1,1]):Qh(t,[1,a[3],a[0],a[1],a[2]]);if("channelsLast"===n)return 1===a.length?Qh(t,[1,1,1,1,a[0]]):Qh(t,[1].concat(a))}else if(4===e){if("channelsFirst"===n)return 1===a.length?Qh(t,[1,a[0],1,1]):Qh(t,[1,a[2],a[0],a[1]]);if("channelsLast"===n)return 1===a.length?Qh(t,[1,1,1,a[0]]):Qh(t,[1].concat(a))}else if(3===e){if("channelsFirst"===n)return 1===a.length?Qh(t,[1,a[0],1]):Qh(t,[1,a[1],a[0]]);if("channelsLast"===n)return 1===a.length?Qh(t,[1,1,a[0]]):Qh(t,[1].concat(a))}else if(e<3)return t;throw new Bx("Unsupported input rank by biasAdd: ".concat(t.rank))}function qv(e,t,n){return Lu((()=>(null==n&&(n="channelsLast"),yv(n),Ed(e,Kv(e.rank,t,n)))))}function Xv(e,t,n,a){return Lu((()=>Pf(e,t,n,a)))}function Yv(e,t){return arguments.length>2&&void 0!==arguments[2]&&arguments[2]?e():t()}const Qv=["fanIn","fanOut","fanAvg"],Jv=["normal","uniform","truncatedNormal"];class Zv extends Bd{fromConfigUsesCustomObjects(){return!1}getConfig(){return{}}}class $v extends Zv{apply(e,t){return tf(e,t)}}$v.className="Zeros",Vd($v);class ew extends Zv{apply(e,t){return nf(e,t)}}ew.className="Ones",Vd(ew);class tw extends Zv{constructor(e){if(super(),"object"!==typeof e)throw new Bx("Expected argument of type ConstantConfig but got ".concat(e));if(void 0===e.value)throw new Bx("config must have value set but got ".concat(e));this.value=e.value}apply(e,t){return Lu((()=>Ad(Ld(this.value),nf(e,t))))}getConfig(){return{value:this.value}}}tw.className="Constant",Vd(tw);class nw extends Zv{constructor(e){super(),this.DEFAULT_MINVAL=-.05,this.DEFAULT_MAXVAL=.05,this.minval=e.minval||this.DEFAULT_MINVAL,this.maxval=e.maxval||this.DEFAULT_MAXVAL,this.seed=e.seed}apply(e,t){return df(e,this.minval,this.maxval,t,this.seed)}getConfig(){return{minval:this.minval,maxval:this.maxval,seed:this.seed}}}nw.className="RandomUniform",Vd(nw);class aw extends Zv{constructor(e){super(),this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=e.mean||this.DEFAULT_MEAN,this.stddev=e.stddev||this.DEFAULT_STDDEV,this.seed=e.seed}apply(e,t){if("float32"!==(t=t||"float32")&&"int32"!==t)throw new Wx("randomNormal does not support dType ".concat(t,"."));return Uv(e,this.mean,this.stddev,t,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}}aw.className="RandomNormal",Vd(aw);class rw extends Zv{constructor(e){super(),this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=e.mean||this.DEFAULT_MEAN,this.stddev=e.stddev||this.DEFAULT_STDDEV,this.seed=e.seed}apply(e,t){if("float32"!==(t=t||"float32")&&"int32"!==t)throw new Wx("truncatedNormal does not support dType ".concat(t,"."));return Af(e,this.mean,this.stddev,t,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}}rw.className="TruncatedNormal",Vd(rw);class ow extends Zv{constructor(e){super(),this.gain=null!=e.gain?e.gain:1}apply(e,t){return Lu((()=>{if(2!==e.length||e[0]!==e[1])throw new Bx("Identity matrix initializer can only be used for 2D square matrices.");return Ad(this.gain,Sp(e[0]))}))}getConfig(){return{gain:this.gain}}}ow.className="Identity",Vd(ow);class sw extends Zv{constructor(e){if(super(),e.scale<0)throw new Bx("scale must be a positive float. Got: ".concat(e.scale));var t;this.scale=null==e.scale?1:e.scale,this.mode=null==e.mode?"fanIn":e.mode,t=this.mode,av(Qv,"FanMode",t),this.distribution=null==e.distribution?"normal":e.distribution,function(e){av(Jv,"Distribution",e)}(this.distribution),this.seed=e.seed}apply(e,t){const n=function(e){let t,n,a=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"channelsLast";if(yv(a),2===e.length)t=e[0],n=e[1];else if(-1!==[3,4,5].indexOf(e.length)){if("channelsFirst"===a){const a=Ev(e,2);t=e[1]*a,n=e[0]*a}else if("channelsLast"===a){const a=Ev(e,0,e.length-2);t=e[e.length-2]*a,n=e[e.length-1]*a}}else{const a=Ev(e);t=Math.sqrt(a),n=Math.sqrt(a)}return[t,n]}(e),a=n[0],r=n[1];let o=this.scale;if("fanIn"===this.mode?o/=Math.max(1,a):"fanOut"===this.mode?o/=Math.max(1,r):o/=Math.max(1,(a+r)/2),"normal"===this.distribution){const n=Math.sqrt(o);if("float32"!==(t=t||"float32")&&"int32"!==t)throw new Wx("".concat(this.getClassName()," does not support dType ").concat(t,"."));return Af(e,0,n,t,this.seed)}{const n=Math.sqrt(3*o);return df(e,-n,n,t,this.seed)}}getConfig(){return{scale:this.scale,mode:this.mode,distribution:this.distribution,seed:this.seed}}}sw.className="VarianceScaling",Vd(sw);class iw extends sw{constructor(e){super({scale:1,mode:"fanAvg",distribution:"uniform",seed:null==e?null:e.seed})}getClassName(){return sw.className}}iw.className="GlorotUniform",Vd(iw);class cw extends sw{constructor(e){super({scale:1,mode:"fanAvg",distribution:"normal",seed:null==e?null:e.seed})}getClassName(){return sw.className}}cw.className="GlorotNormal",Vd(cw);class lw extends sw{constructor(e){super({scale:2,mode:"fanIn",distribution:"normal",seed:null==e?null:e.seed})}getClassName(){return sw.className}}lw.className="HeNormal",Vd(lw);class uw extends sw{constructor(e){super({scale:2,mode:"fanIn",distribution:"uniform",seed:null==e?null:e.seed})}getClassName(){return sw.className}}uw.className="HeUniform",Vd(uw);class dw extends sw{constructor(e){super({scale:1,mode:"fanIn",distribution:"normal",seed:null==e?null:e.seed})}getClassName(){return sw.className}}dw.className="LeCunNormal",Vd(dw);class hw extends sw{constructor(e){super({scale:1,mode:"fanIn",distribution:"uniform",seed:null==e?null:e.seed})}getClassName(){return sw.className}}hw.className="LeCunUniform",Vd(hw);class pw extends Zv{constructor(e){super(),this.DEFAULT_GAIN=1,this.ELEMENTS_WARN_SLOW=2e3,this.gain=null==e.gain?this.DEFAULT_GAIN:e.gain,this.seed=e.seed}apply(e,t){return Lu((()=>{if(e.length<2)throw new Wx("Shape must be at least 2D.");if("int32"!==t&&"float32"!==t&&void 0!==t)throw new TypeError("Unsupported data type ".concat(t,"."));const n=lo(e.slice(0,-1)),a=e[e.length-1],r=n*a;r>this.ELEMENTS_WARN_SLOW&&console.warn("Orthogonal initializer is being called on a matrix with more "+"than ".concat(this.ELEMENTS_WARN_SLOW," (").concat(r,") elements: ")+"Slowness may result.");const o=Uv([Math.max(a,n),Math.min(a,n)],0,1,t,this.seed),s=zm.qr(o,!1);let i=s[0];const c=s[1].flatten().stridedSlice([0],[Math.min(a,n)*Math.min(a,n)],[Math.min(a,n)+1]);return i=Ad(i,c.sign()),n<a&&(i=i.transpose()),Ad(Ld(this.gain),i.reshape(e))}))}getConfig(){return{gain:this.gain,seed:this.seed}}}pw.className="Orthogonal",Vd(pw);const fw={constant:"Constant",glorotNormal:"GlorotNormal",glorotUniform:"GlorotUniform",heNormal:"HeNormal",heUniform:"HeUniform",identity:"Identity",leCunNormal:"LeCunNormal",leCunUniform:"LeCunUniform",ones:"Ones",orthogonal:"Orthogonal",randomNormal:"RandomNormal",randomUniform:"RandomUniform",truncatedNormal:"TruncatedNormal",varianceScaling:"VarianceScaling",zeros:"Zeros"};function mw(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return $x(e,Wd.getMap().classNameMap,t,"initializer")}function gw(e){return Jx(e)}function bw(e){if("string"===typeof e){const t=e in fw?fw[e]:e;if("GlorotNormal"===t)return new cw;if("GlorotUniform"===t)return new iw;if("HeNormal"===t)return new lw;if("HeUniform"===t)return new uw;if("LeCunNormal"===t)return new dw;if("LeCunUniform"===t)return new hw;{const e={};return e.className=t,e.config={},mw(e)}}return e instanceof Zv?e:mw(e)}function yw(e){return Array.isArray(e)&&Array.isArray(e[0])}function xw(e){return 0===e.length?[]:Array.isArray(e[0])?e:[e]}function vw(e){let t;if(Array.isArray(e)){if(1!==e.length)throw new Bx("Expected Tensor length to be 1; got ".concat(e.length));t=e[0]}else t=e;return t}function ww(e){if(Array.isArray(e)&&Array.isArray(e[0])){if(1===e.length)return e[0];throw new Bx("Expected exactly 1 Shape; got ".concat(e.length))}return e}function kw(e){let t=0;for(const n of e)0===n.shape.length?t+=1:t+=n.shape.reduce(((e,t)=>e*t));return t}const Iw="Variable";class Sw{constructor(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"float32",n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:Iw,a=!(arguments.length>3&&void 0!==arguments[3])||arguments[3],r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null;this.dtype=null==t?"float32":t,this.shape=e.shape,this.id=lv(),n=null==n?Iw:n,this.originalName=Sv(n),this.name=Nv(this.originalName),this.trainable_=a,this.constraint=r,this.val=function(e){let t=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],n=arguments.length>2?arguments[2]:void 0,a=arguments.length>3?arguments[3]:void 0;return yu.makeVariable(e,t,n,a)}(e,this.trainable_,this.name,this.dtype)}read(){return this.assertNotDisposed(),this.val}write(e){return this.assertNotDisposed(),function(e,t){if(e.shape.toString()!==t.shape.toString())throw new Error("Shape mismatch: "+JSON.stringify(e.shape)+" vs. "+JSON.stringify(t.shape))}(this.val,e),this.val.id!==e.id&&(this.val.assign(e),null!=this.constraint&&this.val.assign(this.constraint.apply(this.val))),this}dispose(){this.assertNotDisposed(),this.val.dispose()}assertNotDisposed(){if(this.val.isDisposed)throw new Error("LayersVariable ".concat(this.name," is already disposed."))}get trainable(){return this.trainable_}set trainable(e){this.trainable_=e,this.val.trainable=e}}function Nw(e){return e.map((e=>e.read()))}function Cw(e){e.forEach((e=>{e[0].write(e[1])}))}class Tw{constructor(e){this.dtype=e.dtype,this.shape=e.shape,null!=e.shape?this.ndim=e.shape.length:this.ndim=e.ndim,this.maxNDim=e.maxNDim,this.minNDim=e.minNDim,this.axes=e.axes||{}}}class Ew{constructor(e,t,n,a,r,o,s){this.dtype=e,this.shape=t,this.sourceLayer=n,this.inputs=a,this.callArgs=r,this.outputTensorIndex=s,this.id=lv(),null!=o&&(this.originalName=Sv(o),this.name=Nv(this.originalName)),this.rank=t.length}}let Rw=0;class _w{constructor(e,t){this.callArgs=t,this.id=Rw++,this.outboundLayer=e.outboundLayer,this.inboundLayers=e.inboundLayers,this.nodeIndices=e.nodeIndices,this.tensorIndices=e.tensorIndices,this.inputTensors=e.inputTensors,this.outputTensors=e.outputTensors,this.inputMasks=e.inputMasks,this.outputMasks=e.outputMasks,this.inputShapes=e.inputShapes,this.outputShapes=e.outputShapes;for(const n of e.inboundLayers)null!=n&&n.outboundNodes.push(this);e.outboundLayer.inboundNodes.push(this)}getConfig(){const e=[];for(const t of this.inboundLayers)null!=t?e.push(t.name):e.push(null);return{outboundLayer:this.outboundLayer?this.outboundLayer.name:null,inboundLayers:e,nodeIndices:this.nodeIndices,tensorIndices:this.tensorIndices}}}let Aw=0;class Fw extends Bd{constructor(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};super(),this._callHook=null,this._addedWeightNames=[],this._stateful=!1,this.id=Aw++,this.activityRegularizer=null,this.inputSpec=null,this.supportsMasking=!1,this._trainableWeights=[],this._nonTrainableWeights=[],this._losses=[],this._updates=[],this._built=!1,this.inboundNodes=[],this.outboundNodes=[];let t=e.name;if(!t){const e=this.getClassName();t=Xx(e)+"_"+dv(e)}if(this.name=t,this.trainable_=null==e.trainable||e.trainable,null!=e.inputShape||null!=e.batchInputShape){let t;if(null!=e.batchInputShape)t=e.batchInputShape;else if(null!=e.inputShape){let n=null;null!=e.batchSize&&(n=e.batchSize),t=[n].concat(e.inputShape)}this.batchInputShape=t;let n=e.dtype;null==n&&(n=e.inputDType),null==n&&(n="float32"),this.dtype=n}null!=e.weights?this.initialWeights=e.weights:this.initialWeights=null,this._refCount=null,this.fastWeightInitDuringBuild=!1}static nodeKey(e,t){return e.name+"_ib-"+t.toString()}getNodeAtIndex(e,t){if(0===this.inboundNodes.length)throw new zx("The layer has never been called "+"and thus has no defined ".concat(t,"."));if(this.inboundNodes.length<=e)throw new Bx("Asked to get ".concat(t," at node ").concat(e,", ")+"but the layer has only ".concat(this.inboundNodes.length," inbound nodes."));return this.inboundNodes[e]}getInputAt(e){return Kx(this.getNodeAtIndex(e,"input").inputTensors)}getOutputAt(e){return Kx(this.getNodeAtIndex(e,"output").outputTensors)}get input(){if(this.inboundNodes.length>1)throw new Px("Layer ".concat(this.name)+' has multiple inbound nodes, hence the notion of "layer input" is ill-defined. Use `getInputAt(nodeIndex)` instead.');if(0===this.inboundNodes.length)throw new Px("Layer ".concat(this.name)+" is not connected, no input to return.");return Kx(this.getNodeAtIndex(0,"input").inputTensors)}get output(){if(0===this.inboundNodes.length)throw new Px("Layer ".concat(this.name)+" has no inbound nodes.");if(this.inboundNodes.length>1)throw new Px("Layer ".concat(this.name)+' has multiple inbound nodes, hence the notion of "layer output" is ill-defined. Use `getOutputAt(nodeIndex)` instead.');return Kx(this.getNodeAtIndex(0,"output").outputTensors)}get losses(){return this._losses}calculateLosses(){return this.losses.map((e=>e()))}get updates(){return this._updates}get built(){return this._built}set built(e){this._built=e}get trainable(){return this.trainable_}set trainable(e){this._trainableWeights.forEach((t=>t.trainable=e)),this.trainable_=e}get trainableWeights(){return this.trainable_?this._trainableWeights.filter((e=>e.trainable)):[]}set trainableWeights(e){this._trainableWeights=e}get nonTrainableWeights(){return this.trainable?this._trainableWeights.filter((e=>!e.trainable)).concat(this._nonTrainableWeights):this._trainableWeights.concat(this._nonTrainableWeights)}set nonTrainableWeights(e){this._nonTrainableWeights=e}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}get stateful(){return this._stateful}resetStates(){if(!this.stateful)throw new Error("Cannot call the resetStates() method of a non-stateful Layer object.")}assertInputCompatibility(e){const t=qx(e);if(null==this.inputSpec||0===this.inputSpec.length)return;const n=qx(this.inputSpec);if(t.length!==n.length)throw new Bx("Layer ".concat(this.name," expects ").concat(n.length," inputs, ")+"but it received ".concat(t.length," input tensors. ")+"Input received: ".concat(e));for(let a=0;a<t.length;a++){const e=t[a],r=n[a];if(null==r)continue;const o=e.rank;if(null!=r.ndim&&o!==r.ndim)throw new Bx("Input ".concat(a," is incompatible with layer ").concat(this.name,": ")+"expected ndim=".concat(r.ndim,", found ndim=").concat(o));if(null!=r.maxNDim&&o>r.maxNDim)throw new Bx("Input ".concat(a," is incompatible with layer ").concat(this.name)+": expected max_ndim=".concat(r.maxNDim,", found ndim=").concat(o));if(null!=r.minNDim&&o<r.minNDim)throw new Bx("Input ".concat(a," is incompatible with layer ").concat(this.name)+": expected min_ndim=".concat(r.minNDim,", found ndim=").concat(o,"."));if(null!=r.dtype&&e.dtype!==r.dtype)throw new Bx("Input ".concat(a," is incompatible with layer ").concat(this.name," ")+": expected dtype=".concat(r.dtype,", found dtype=").concat(e.dtype,"."));if(r.axes){const t=e.shape;for(const e in r.axes){const n=Number(e),o=r.axes[e],s=n>=0?t[n]:t[t.length+n];if(null!=o&&-1===[o,null].indexOf(s))throw new Bx("Input ".concat(a," is incompatible with layer ")+"".concat(this.name,": expected axis ").concat(n," of input shape to ")+"have value ".concat(o," but got shape ").concat(t,"."))}}if(null!=r.shape)for(let t=0;t<r.shape.length;++t){const n=r.shape[t],o=e.shape[t];if(null!=n&&null!=o&&n!==o)throw new Bx("Input ".concat(a," is incompatible with layer ")+"".concat(this.name,": expected shape=").concat(r.shape,", ")+"found shape=".concat(e.shape,"."))}}}call(e,t){return e}invokeCallHook(e,t){null!=this._callHook&&this._callHook(e,t)}setCallHook(e){this._callHook=e}clearCallHook(){this._callHook=null}apply(e,t){t=t||{},this.assertNotDisposed();const n=qx(e),a=function(e){let t=!0;for(const n of qx(e))if(!(n instanceof Ew)){t=!1;break}return t}(e),r=function(e){let t=!0;for(const n of qx(e))if(n instanceof Ew){t=!1;break}return t}(e);if(a===r)throw new Bx("Arguments to apply() must be all SymbolicTensors or all Tensors");return Iv(this.name,(()=>{if(!this.built){this.assertInputCompatibility(e);const t=[];for(const n of qx(e))t.push(n.shape);this.build(Kx(t)),this.built=!0,this.initialWeights&&this.setWeights(this.initialWeights),null===this._refCount&&r&&(this._refCount=1)}if(this.assertInputCompatibility(e),r){let a=this.call(e,t);this.supportsMasking&&this.setMaskMetadata(e,a);const r=qx(a),o=[];for(let e of r)-1!==n.indexOf(e)&&(e=e.clone()),o.push(e);if(a=Kx(o),null!=this.activityRegularizer)throw new Wx("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return a}{const n=function(e){e=qx(e);const t=[];for(const n of e)t.push(n.shape);return Kx(t)}(e),a=this.computeOutputShape(n);let r;const o="float32";if(this.warnOnIncompatibleInputShape(Array.isArray(e)?n[0]:n),r=null!=a&&a.length>0&&Array.isArray(a[0])?a.map(((n,a)=>new Ew(o,n,this,qx(e),t,this.name,a))):new Ew(o,a,this,qx(e),t,this.name),this.addInboundNode(e,r,null,null,n,a,t),this._refCount++,null!=this.activityRegularizer)throw new Wx("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return r}}))}warnOnIncompatibleInputShape(e){if(null!=this.batchInputShape)if(e.length!==this.batchInputShape.length)console.warn("The rank of the input tensor provided (shape: "+"".concat(JSON.stringify(e),") does not match that of the ")+"batchInputShape (".concat(JSON.stringify(this.batchInputShape),") ")+"of the layer ".concat(this.name));else{let t=!1;this.batchInputShape.forEach(((n,a)=>{null!=n&&null!=e[a]&&e[a]!==n&&(t=!0)})),t&&console.warn("The shape of the input tensor "+"(".concat(JSON.stringify(e),") does not ")+"match the expectation of layer ".concat(this.name,": ")+"".concat(JSON.stringify(this.batchInputShape)))}}get outputShape(){if(null==this.inboundNodes||0===this.inboundNodes.length)throw new Px("The layer ".concat(this.name," has never been called and thus has no ")+"defined output shape.");const e=[];for(const t of this.inboundNodes){const n=JSON.stringify(t.outputShapes);-1===e.indexOf(n)&&e.push(n)}if(1===e.length){const e=this.inboundNodes[0].outputShapes;return Array.isArray(e)&&Array.isArray(e[0])&&1===e.length?e[0]:e}throw new Px("The layer ".concat(this.name," has multiple inbound nodes with different ")+'output shapes. Hence the notion of "output shape" is ill-defined for the layer.')}countParams(){if(!this.built)throw new zx("You tried to call countParams() on ".concat(this.name,", ")+"but the layer is not built yet. Build it first by calling build(batchInputShape).");return kw(this.weights)}build(e){this.built=!0}getWeights(){return Nw(arguments.length>0&&void 0!==arguments[0]&&arguments[0]?this.trainableWeights:this.weights)}setWeights(e){Lu((()=>{const t=this.weights;if(t.length!==e.length)throw new Bx('You called setWeights(weights) on layer "'.concat(this.name,'" ')+"with a weight list of length ".concat(e.length,", ")+"but the layer was expecting ".concat(t.length," weights. ")+"Provided weights: ".concat(e,"..."));if(0===t.length)return;const n=[],a=Nw(t);for(let r=0;r<a.length;++r){const o=a[r],s=t[r],i=e[r];if(!uo(o.shape,i.shape))throw new Bx("Layer weight shape ".concat(o.shape," ")+"not compatible with provided weight shape ".concat(i.shape));n.push([s,i])}Cw(n)}))}addWeight(e,t,n,a,r,o,s,i){if(-1!==this._addedWeightNames.indexOf(e))throw new Bx("Duplicate weight name ".concat(e," for layer ").concat(this.name));this._addedWeightNames.push(e),null==n&&(n="float32"),this.fastWeightInitDuringBuild&&(a=null!=i?i():bw("zeros"));const c=a.apply(t,n),l=new Sw(c,n,e,o,s);return c.dispose(),null!=r&&this.addLoss((()=>r.apply(l.read()))),null==o&&(o=!0),o?this._trainableWeights.push(l):this._nonTrainableWeights.push(l),l}setFastWeightInitDuringBuild(e){this.fastWeightInitDuringBuild=e}addLoss(e){null==e||Array.isArray(e)&&0===e.length||(e=qx(e),void 0!==this._losses&&null!==this._losses&&this.losses.push(...e))}computeOutputShape(e){return e}computeMask(e,t){if(!this.supportsMasking){if(null!=t){if(!Array.isArray(t))throw new TypeError("Layer ".concat(this.name," does not support masking, ")+"but was passed an inputMask.");t.forEach((e=>{if(null!=e)throw new TypeError("Layer ".concat(this.name," does not support masking, ")+"but was passed an inputMask.")}))}return null}return t}setMaskMetadata(e,t,n){if(!this.supportsMasking)return;const a=this.computeMask(e,n),r=qx(t),o=qx(a);if(r.length!==o.length)throw new Error("".concat(this.name," outputs ").concat(r.length," tensors ")+"but ".concat(r.length," masks for those tensors"));for(let s=0;s<r.length;s++)r[s].kerasMask=o[s]}addInboundNode(e,t,n,a,r,o){let s=arguments.length>6&&void 0!==arguments[6]?arguments[6]:null;const i=qx(e);t=qx(t),n=qx(n),a=qx(a),r=xw(r),o=xw(o);const c=[],l=[],u=[];for(const d of i)c.push(d.sourceLayer),l.push(d.nodeIndex),u.push(d.tensorIndex);new _w({outboundLayer:this,inboundLayers:c,nodeIndices:l,tensorIndices:u,inputTensors:i,outputTensors:t,inputMasks:n,outputMasks:a,inputShapes:r,outputShapes:o},s);for(let d=0;d<t.length;d++)t[d].sourceLayer=this,t[d].nodeIndex=this.inboundNodes.length-1,t[d].tensorIndex=d}getConfig(){const e={name:this.name,trainable:this.trainable};return null!=this.batchInputShape&&(e.batchInputShape=this.batchInputShape),null!=this.dtype&&(e.dtype=this.dtype),e}disposeWeights(){return this.weights.forEach((e=>e.dispose())),this.weights.length}assertNotDisposed(){if(0===this._refCount)throw new Error("Layer '".concat(this.name,"' is already disposed."))}dispose(){if(!this.built)throw new Error("Cannot dispose Layer ".concat(this.name," because it has not been ")+"built yet.");if(null===this._refCount)throw new Error("Cannot dispose Layer ".concat(this.name," because it has not been used ")+"yet.");this.assertNotDisposed();let e=0;return 0===--this._refCount&&(e=this.disposeWeights()),{refCountAfterDispose:this._refCount,numDisposedVariables:e}}}function Ow(e,t,n){if((null==t||null!=n&&n>0)&&(t=e.sourceLayer,n=e.nodeIndex),0===t.inboundNodes.length)return[e];{const e=t.inboundNodes[n];if(0===e.inboundLayers.length)return e.inputTensors;{const t=[];for(let n=0;n<e.inboundLayers.length;n++){const a=Ow(e.inputTensors[n],e.inboundLayers[n],e.nodeIndices[n]);for(const e of a)-1===t.indexOf(e)&&t.push(e)}return t}}}class Dw extends Fw{constructor(e){if(super({dtype:e.dtype,name:null!=e.name?e.name:dv("input").toString()}),null==e.batchSize&&(e.batchSize=null),null==e.sparse&&(e.sparse=!1),this.trainable=!1,this.built=!0,this.sparse=e.sparse,null!=e.inputShape&&null!=e.batchInputShape)throw new Bx("Only provide the inputShape OR batchInputShape argument to inputLayer, not both at the same time.");let t=e.batchInputShape;if(null==t){if(null==e.inputShape)throw new Bx("An InputLayer should be passed either a `batchInputShape` or an `inputShape`.");t=[e.batchSize].concat(e.inputShape)}else if(null!=e.batchSize)throw new Bx("Cannot specify batchSize if batchInputShape is specified when creating an InputLayer.");const n=e.dtype||"float32";this.batchInputShape=t,this.dtype=n,this.inputSpec=[{shape:t}];const a=new Ew(this.dtype,this.batchInputShape,this,[],{},this.name);a.nodeIndex=0,a.tensorIndex=0,new _w({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:[a],outputTensors:[a],inputMasks:[null],outputMasks:[null],inputShapes:[t],outputShapes:[t]})}apply(e,t){throw new Bx("Cannot pass any input to an "+"InputLayer's apply() method. InputLayer name: ".concat(this.name))}dispose(){return{refCountAfterDispose:this._refCount,numDisposedVariables:0}}getConfig(){return{batchInputShape:this.batchInputShape,dtype:this.dtype,sparse:this.sparse,name:this.name}}}Dw.className="InputLayer",Vd(Dw);class Mw{constructor(e){if(this.id2Value={},this.id2Mask={},this.name2Id={},e instanceof Mw)for(const t in e.id2Value)this.id2Value[t]=e.id2Value[t],t in e.id2Mask&&(this.id2Mask[t]=e.id2Mask[t]);else{if(null==e)return;for(const t of e)this.add(t.key,t.value)}}add(e,t,n){if(null!=this.id2Value[e.id])throw new Bx("Duplicate key: name=".concat(e.name,", id=").concat(e.id));return this.id2Value[e.id]=function(e,t){if(null==e.dtype||e.dtype===t.dtype)return t;try{return Cd(t,e.dtype)}catch(Yue){throw new Bx("The dtype of the feed (".concat(t.dtype,") can not be cast to the dtype ")+"of the key '".concat(e.name,"' (").concat(e.dtype,")."))}}(e,t),this.name2Id[e.name]=e.id,null!=n&&(this.id2Mask[e.id]=n),this}addFeed(e){this.add(e.key,e.value)}hasKey(e){return null!=this.id2Value[e.id]}names(){return Object.keys(this.name2Id)}getValue(e){if(e instanceof Ew){if(null==this.id2Value[e.id])throw new Bx("Nonexistent key: ".concat(e.name));return this.id2Value[e.id]}{const t=this.name2Id[e];if(null==t)throw new Bx("Feed dict has no SymbolicTensor name: ".concat(e));return this.id2Value[t]}}getMask(e){if(e instanceof Ew){if(null==this.id2Value[e.id])throw new Bx("Nonexistent key: ".concat(e.name));return this.id2Mask[e.id]}{const t=this.name2Id[e];if(null==t)throw new Bx("Feed dict has no SymbolicTensor name: ".concat(e));return this.id2Mask[t]}}disposeMasks(){null!=this.id2Mask&&Pu(this.id2Mask)}}const Lw=new Ux,Pw=new Ux;function zw(e,t,n,a){const r=null!=n&&n.training,o=Array.isArray(e),s=o?e:[e],i=s.map((e=>e.name)),c=[],l=t.names();for(const f of i)-1!==l.indexOf(f)?c.push(t.getValue(f)):c.push(null);null!=a&&(a.maxNumTensors=-1/0,a.minNumTensors=1/0);const u=i.join(",")+"|"+t.names().sort().join(",");let d,h=Lw.get(u);if(null==h){const e=function(e,t){so(null!=e&&e.length>0,(()=>"Expected at least one fetch, got none"));let n=[],a={};if(1===e.length){const r=Ww(e[0],t);n=r.sorted,a=r.recipientMap}else{const r=new Set;for(const o of e){const{sorted:e,recipientMap:s}=Ww(o,t);for(const t of e)r.has(t.name)||(n.push(t),r.add(t.name));for(const t in s)null==a[t]&&(a[t]=new Set),s[t].forEach((e=>a[t].add(e)))}}return{sorted:n,recipientCounts:Bw(a)}}(s,t);h=e.sorted,d=e.recipientCounts,Lw.put(u,h),Pw.put(u,d)}d={},r||Object.assign(d,Pw.get(u));const p=new Mw(t);for(let f=0;f<h.length;++f){if(null!=a){const e=Mu().numTensors;e>a.maxNumTensors&&(a.maxNumTensors=e),e<a.minNumTensors&&(a.minNumTensors=e)}const e=h[f],o=e.sourceLayer;if(o instanceof Dw)continue;const s=[],l=[],u=[];let m=!1;for(const n of e.inputs){const e=p.getValue(n),a=p.getMask(n);s.push(e),l.push(a),null!=a&&(m=!0),r||(d[n.name]--,0!==d[n.name]||t.hasKey(n)||-1!==i.indexOf(n.name)||e.isDisposed||!0===n.sourceLayer.stateful||u.push(e))}m&&((n=n||{}).mask=l[0]);const g=qx(o.apply(s,n));let b=null;o.supportsMasking&&(b=o.computeMask(s,l));const y=Vw(e),x=Array.isArray(y)?y:[y];for(let t=0;t<x.length;++t){p.hasKey(x[t])||p.add(x[t],g[t],Array.isArray(b)?b[0]:b);const e=i.indexOf(x[t].name);-1!==e&&(c[e]=g[t])}r||Pu(u)}return p.disposeMasks(),o?c:c[0]}function Bw(e){const t={};for(const n in e)t[n]=e[n].size;return t}function Ww(e,t){const n=new Set,a=[],r={};for(const i of t.names())n.add(i);const o=[],s=[];for(o.push(e);o.length>0;){const e=o[o.length-1];if(n.has(e.name)){o.pop();continue}const t=s[s.length-1]===o.length-1;if(0===e.inputs.length||t)o.pop(),a.push(e),n.add(e.name),t&&s.pop();else{s.push(o.length-1);for(const t of e.inputs)null==r[t.name]&&(r[t.name]=new Set),r[t.name].add(e.name),n.has(t.name)||o.push(t)}}return{sorted:a,recipientMap:r}}function Vw(e){let t;if(1===e.sourceLayer.inboundNodes.length)t=e.sourceLayer.output;else{let n=null;for(let t=0;t<e.sourceLayer.inboundNodes.length;++t)for(const a of e.sourceLayer.inboundNodes[t].outputTensors)if(a.id===e.id){n=t;break}t=e.sourceLayer.getOutputAt(n)}return t}function Uw(e,t){return Lu((()=>Fd(Op(Ad(e,e),t,!0))))}Vo().registerFlag("TOPOLOGICAL_SORT_CACHE_MAX_ENTRIES",(()=>100),(function(e){null!=Lw&&Lw.setMaxEntries(e),null!=Pw&&Pw.setMaxEntries(e)}));class Gw extends Bd{getConfig(){return{}}}class Hw extends Gw{constructor(e){super(),this.defaultMaxValue=2,this.defaultAxis=0,this.maxValue=null!=e.maxValue?e.maxValue:this.defaultMaxValue,this.axis=null!=e.axis?e.axis:this.defaultAxis}apply(e){return Lu((()=>{const t=Uw(e,this.axis),n=rp(t,0,this.maxValue);return Ad(e,_d(n,Ed(Ov(),t)))}))}getConfig(){return{maxValue:this.maxValue,axis:this.axis}}}Hw.className="MaxNorm",Vd(Hw);class jw extends Gw{constructor(e){super(),this.defaultAxis=0,this.axis=null!=e.axis?e.axis:this.defaultAxis}apply(e){return Lu((()=>_d(e,Ed(Ov(),Uw(e,this.axis)))))}getConfig(){return{axis:this.axis}}}jw.className="UnitNorm",Vd(jw);class Kw extends Gw{apply(e){return pf(e)}}Kw.className="NonNeg",Vd(Kw);class qw extends Gw{constructor(e){super(),this.defaultMinValue=0,this.defaultMaxValue=1,this.defaultRate=1,this.defaultAxis=0,this.minValue=null!=e.minValue?e.minValue:this.defaultMinValue,this.maxValue=null!=e.maxValue?e.maxValue:this.defaultMaxValue,this.rate=null!=e.rate?e.rate:this.defaultRate,this.axis=null!=e.axis?e.axis:this.defaultAxis}apply(e){return Lu((()=>{const t=Uw(e,this.axis),n=Ed(Ad(this.rate,rp(t,this.minValue,this.maxValue)),Ad(1-this.rate,t));return Ad(e,_d(n,Ed(Ov(),t)))}))}getConfig(){return{minValue:this.minValue,maxValue:this.maxValue,rate:this.rate,axis:this.axis}}}qw.className="MinMaxNorm",Vd(qw);const Xw={maxNorm:"MaxNorm",minMaxNorm:"MinMaxNorm",nonNeg:"NonNeg",unitNorm:"UnitNorm"};function Yw(e){return Jx(e)}function Qw(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return $x(e,Wd.getMap().classNameMap,t,"constraint")}function Jw(e){if(null==e)return null;if("string"===typeof e){return Qw({className:e in Xw?Xw[e]:e,config:{}})}return e instanceof Gw?e:Qw(e)}async function Zw(e){if(null==e)return;const t=[],n=[],a=[];for(const r in e){const o=e[r];if("number"!==typeof o){const e=o;t.push(e.data()),n.push(r),a.push(e)}}if(t.length>0){const r=await Promise.all(t);for(let t=0;t<r.length;++t)e[n[t]]=r[t][0];Pu(a)}}function $w(e){if(null!=e)for(const t in e){const n=e[t];"number"!==typeof n&&n.dispose()}}var ek;!function(e){e[e.SILENT=0]="SILENT",e[e.VERBOSE=1]="VERBOSE"}(ek||(ek={}));class tk{constructor(){this.validationData=null}setParams(e){this.params=e}async onEpochBegin(e,t){}async onEpochEnd(e,t){}async onBatchBegin(e,t){}async onBatchEnd(e,t){}async onTrainBegin(e){}async onTrainEnd(e){}setModel(e){}}class nk{constructor(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:10;null==e&&(e=[]),this.callbacks=e,this.queueLength=t}append(e){this.callbacks.push(e)}setParams(e){for(const t of this.callbacks)t.setParams(e)}setModel(e){for(const t of this.callbacks)t.setModel(e)}async onEpochBegin(e,t){null==t&&(t={});for(const n of this.callbacks)await n.onEpochBegin(e,t)}async onEpochEnd(e,t){null==t&&(t={});for(const n of this.callbacks)await n.onEpochEnd(e,t)}async onBatchBegin(e,t){null==t&&(t={});for(const n of this.callbacks)await n.onBatchBegin(e,t)}async onBatchEnd(e,t){null==t&&(t={});for(const n of this.callbacks)await n.onBatchEnd(e,t)}async onTrainBegin(e){null==e&&(e={});for(const t of this.callbacks)await t.onTrainBegin(e)}async onTrainEnd(e){null==e&&(e={});for(const t of this.callbacks)await t.onTrainEnd(e)}}class ak extends tk{constructor(){super()}async onEpochBegin(e){this.seen=0,this.totals={}}async onBatchEnd(e,t){null==t&&(t={});const n=null==t.size?0:t.size;this.seen+=n;for(const a in t){const e=t[a];if("number"===typeof e)this.totals.hasOwnProperty(a)||(this.totals[a]=0),this.totals[a]=this.totals[a]+e*n;else{let t;a in this.totals?t=this.totals[a]:this.totals[a]=0;const r=Lu((()=>Ed(this.totals[a],Ad(e,n))));this.totals[a]=r,null!=t&&t.dispose()}}}async onEpochEnd(e,t){if(null!=t)for(const n of this.params.metrics)null!=this.totals[n]&&("number"===typeof this.totals[n]?t[n]=this.totals[n]/this.seen:Lu((()=>{const e=Ad(_d(1,this.seen),this.totals[n]);t[n]=e,this.totals[n].dispose(),zu(t[n])})))}}class rk extends tk{async onTrainBegin(e){this.epoch=[],this.history={}}async onEpochEnd(e,t){null==t&&(t={}),this.epoch.push(e);for(const n in t)null==this.history[n]&&(this.history[n]=[]),this.history[n].push(t[n])}async syncData(){const e=[],t=[],n=[];for(const r in this.history){const a=this.history[r];for(let o=0;o<a.length;++o)if("number"!==typeof a[o]){const s=a[o];e.push(s.data()),t.push(r),n.push(o)}}const a=await Promise.all(e);for(let r=0;r<a.length;++r){this.history[t[r]][n[r]].dispose(),this.history[t[r]][n[r]]=a[r][0]}}}class ok extends tk{constructor(e,t){if(super(),this.currentEpoch=0,this.nowFunc=e.nowFunc,this.nextFrameFunc=e.nextFrameFunc||Vm,this.yieldEvery=t||"auto","auto"===this.yieldEvery&&(this.yieldEvery=125),"never"===this.yieldEvery&&null!=e.onYield)throw new Error("yieldEvery is `never` but you provided an `onYield` callback. Either change `yieldEvery` or remove the callback");So(this.yieldEvery)&&(this.maybeWait=function(e,t,n){let a,r=null!=n?n():Al();return function(){const o=null!=n?n():Al();return o-r<t||(r=o,a=e(...arguments)),a}}(this.maybeWait.bind(this),this.yieldEvery,this.nowFunc)),this.trainBegin=e.onTrainBegin,this.trainEnd=e.onTrainEnd,this.epochBegin=e.onEpochBegin,this.epochEnd=e.onEpochEnd,this.batchBegin=e.onBatchBegin,this.batchEnd=e.onBatchEnd,this.yield=e.onYield}async maybeWait(e,t,n){const a=[];null!=this.yield&&(await Zw(n),a.push(this.yield(e,t,n))),a.push(this.nextFrameFunc()),await Promise.all(a)}async onEpochBegin(e,t){this.currentEpoch=e,null!=this.epochBegin&&(await Zw(t),await this.epochBegin(e,t))}async onEpochEnd(e,t){const n=[];null!=this.epochEnd&&(await Zw(t),n.push(this.epochEnd(e,t))),"epoch"===this.yieldEvery&&n.push(this.nextFrameFunc()),await Promise.all(n)}async onBatchBegin(e,t){null!=this.batchBegin&&(await Zw(t),await this.batchBegin(e,t))}async onBatchEnd(e,t){const n=[];null!=this.batchEnd&&(await Zw(t),n.push(this.batchEnd(e,t))),"batch"===this.yieldEvery?n.push(this.nextFrameFunc()):So(this.yieldEvery)&&n.push(this.maybeWait(this.currentEpoch,e,t)),await Promise.all(n)}async onTrainBegin(e){null!=this.trainBegin&&(await Zw(e),await this.trainBegin(e))}async onTrainEnd(e){null!=this.trainEnd&&(await Zw(e),await this.trainEnd(e))}}function sk(e,t){if(null==e&&(e={}),e instanceof tk)return[e];if(Array.isArray(e)&&e[0]instanceof tk)return e;return qx(e).map((e=>new ok(e,t)))}class ik{constructor(){}static registerCallbackConstructor(e,t){so(e>=0&&Number.isInteger(e),(()=>"Verbosity level is expected to be an integer >= 0, "+"but got ".concat(e))),ik.checkForDuplicate(t),null==ik.constructors[e]&&(ik.constructors[e]=[]),ik.constructors[e].push(t)}static checkForDuplicate(e){for(const t in ik.constructors){ik.constructors[+t].forEach((t=>{if(t===e)throw new Bx("Duplicate callback constructor.")}))}}static clear(){ik.constructors={}}static createCallbacks(e){const t=[];for(const n in ik.constructors){const a=+n;e>=a&&t.push(...ik.constructors[a])}return t.map((e=>new e))}}function ck(e,t,n,a,r,o,s,i,c){const l=new rk,u=[new ak,...ik.createCallbacks(t)];null!=e&&u.push(...e),u.push(l);const d=new nk(u);return d.setParams({epochs:n,initialEpoch:a,samples:r,steps:o,batchSize:s,verbose:t,doValidation:i,metrics:c}),{callbackList:d,history:l}}function lk(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];return $x(e,Wd.getMap().classNameMap,t,"layer",n)}function uk(e,t){return Lu((()=>{"float32"!==e.dtype&&(e=Cd(e,"float32"));const n=Op(jv(e),t,!0),a=Hd(n.shape,Ov()),r=Fd($d(n,a));return _d(e,r)}))}function dk(e,t){return Lu((()=>Xp(jv(qd(t,e)),-1)))}function hk(e,t){return Lu((()=>Xp(Yd(qd(t,e)),-1)))}function pk(e,t){return Lu((()=>{const n=qd(e,t),a=rp(Yd(e),Ov(),Number.MAX_VALUE),r=Yd(_d(n,a));return Ad(100,Xp(r,-1))}))}function fk(e,t){return Lu((()=>{const n=rp(t,Ov(),Number.MAX_VALUE),a=_p(Ed(1,n)),r=rp(e,Ov(),Number.MAX_VALUE),o=_p(Ed(1,r));return Xp(jv(qd(a,o)),-1)}))}function mk(e,t){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];return Lu((()=>{if(n)t=If(t);else{const e=Op(t,t.shape.length-1,!0);t=_d(t,e)}return t=rp(t,Ov(),1-Ov()),Zp(Op(Ad(Cd(e,"float32"),_p(t)),t.shape.length-1))}))}function gk(e,t){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];return Lu((()=>{const a=Cd(Np(function(e){const t=[Ev(e.shape)];return Qh(e,t)}(e)),"int32"),r=(t=rp(t,Ov(),1-Ov())).shape;return mk(Qh(ef(a,r[r.length-1]),r),t,n)}))}function bk(e,t){return Lu((()=>{let n;return n=rp(t,Ov(),1-Ov()),n=_p(_d(n,qd(1,n))),Xp(function(e,t){if(!uo(e.shape,t.shape))throw new Bx("logits and labels must have the same shape, but got shapes "+"".concat(JSON.stringify(e.shape)," and ").concat(JSON.stringify(t.shape)));return Lu((()=>{const n=pf(t),a=Zp(Yd(t));return Ed(qd(n,Ad(t,e)),Ap(wp(a)))}))}(e,n),-1)}))}function yk(e,t){return Lu((()=>{const n=rp(e,Ov(),1),a=rp(t,Ov(),1);return Op(Ad(e,_p(_d(n,a))),-1)}))}function xk(e,t){return Lu((()=>{const n=uk(e,-1),a=uk(t,-1),r=Ad(n,a);return Zp(Op(r,-1))}))}ik.constructors={};const vk={meanSquaredError:dk,meanAbsoluteError:hk,meanAbsolutePercentageError:pk,meanSquaredLogarithmicError:fk,squaredHinge:function(e,t){return Lu((()=>{const n=$d(0,qd(1,Ad(e,t)));return Xp(jv(n),-1)}))},hinge:function(e,t){return Lu((()=>{const n=$d(0,qd(1,Ad(e,t)));return Xp(n,-1)}))},categoricalHinge:function(e,t){return Lu((()=>{const n=Op(Ad(e,t),-1),a=Fp(Ad(qd(1,e),t),-1);return $d(0,Ed(1,qd(a,n)))}))},logcosh:function(e,t){return Lu((()=>{const n=Math.log(2),a=qd(t,e),r=qd(Ed(a,Sf(Ad(-2,a))),n);return Xp(r,-1)}))},categoricalCrossentropy:mk,sparseCategoricalCrossentropy:gk,binaryCrossentropy:bk,kullbackLeiblerDivergence:yk,poisson:function(e,t){return Lu((()=>{const n=_p(Ed(Ov(),t));return Xp(qd(t,Ad(e,n)),-1)}))},cosineProximity:xk};function wk(e){if("string"===typeof e){if(e in vk)return vk[e];let t="Unknown loss ".concat(e);throw e.toLowerCase().includes("softmaxcrossentropy")&&(t="Unknown loss ".concat(e,". ")+'Use "categoricalCrossentropy" as the string name for tf.losses.softmaxCrossEntropy'),new Bx(t)}return e}function kk(e,t){return Lu((()=>{const n=Ad(.5,af(t)),a=Dv(Tp(t,n),e.dtype);return Xp(vp(e,a),-1)}))}function Ik(e,t){return Lu((()=>Dv(vp(Dh(e,-1),Dh(t,-1)),"float32")))}function Sk(e,t){return Lu((()=>Cd(Op(Hp(vp(e,1),vp(t,1))),"float32")))}function Nk(e,t){return bk(e,t)}function Ck(e,t){return e.rank===t.rank&&(e=Cf(e,[e.rank-1])),(t=Dh(t,-1)).dtype!==e.dtype&&(t=Cd(t,e.dtype)),Cd(vp(e,t),"float32")}const Tk=mk,Ek=gk,Rk={binaryAccuracy:kk,categoricalAccuracy:Ik,precision:function(e,t){return Lu((()=>{const n=Sk(e,t),a=function(e,t){return Lu((()=>Cd(Op(Hp(vp(e,0),vp(t,1))),"float32")))}(e,t),r=Ed(n,a);return Cd(Of(Tp(r,0),_d(n,r),0),"float32")}))},categoricalCrossentropy:Tk,sparseCategoricalCrossentropy:Ek,mse:dk,MSE:dk,mae:hk,MAE:hk,mape:pk,MAPE:pk,cosine:xk};function _k(e){if("string"===typeof e&&e in Rk)return Rk[e];if("string"!==typeof e&&null!=e)return e;throw new Bx("Unknown metric ".concat(e))}function Ak(e){if(Hx(null!==e,"Unknown LossOrMetricFn ".concat(e)),"string"===typeof e)return e;{let t;for(const n of Object.keys(vk))if(vk[n]===e){t=n;break}if(void 0!==t)return t;for(const n of Object.keys(Rk))if(Rk[n]===e){t=n;break}return void 0!==t?t:e.name}}const Fk=1048576;function Ok(e,t){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];if(null==e||"object"!==typeof e||Object.getPrototypeOf(e)!==Object.prototype||!Dk(e))throw new Error("User-defined metadata is expected to be a JSON object, but is not.");if(n){const n=JSON.stringify(e);n.length>Fk&&console.warn('User-defined metadata of model "'.concat(t,'" is too large in ')+"size (length=".concat(n.length," when serialized). It is not ")+"recommended to store such large objects in user-defined metadata. Please make sure its serialized length is <= "+"".concat(Fk,"."))}}function Dk(e){if(null===e)return!0;if("object"===typeof e){if(Object.getPrototypeOf(e)===Object.prototype){const t=Object.keys(e);for(const n of t){if("string"!==typeof n)return!1;if(!Dk(e[n]))return!1}return!0}if(Array.isArray(e)){for(const t of e)if(!Dk(t))return!1;return!0}return!1}{const t=typeof e;return"string"===t||"number"===t||"boolean"===t}}function Mk(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:console.log;const r=function(e){let t=!0;const n=[],a=[];for(const r in e.nodesByDepth)n.push(e.nodesByDepth[r]);for(const r of n){if(r.length>1||1===r.length&&r[0].inboundLayers.length>1){t=!1;break}a.push(...r)}if(t)for(const r of e.layers){let e=!1;for(const n of r.inboundNodes)if(-1!==a.indexOf(n)){if(e){t=!1;break}e=!0}if(!t)break}return t}(e),o=["Layer (type)","Input Shape","Output shape","Param #"];let s;if(r?(t=t||90,n=n||[.32,.61,.89,1]):(t=t||115,n=n||[.24,.48,.7,.8,1]),n[n.length-1]<=1&&(n=n.map((e=>Math.floor(t*e)))),!r){o.push("Receives inputs"),s=[];for(const t in e.nodesByDepth)s.push(...e.nodesByDepth[t])}a("_".repeat(t)),Lk(o,n,a),a("=".repeat(t));const i=e.layers;for(let u=0;u<i.length;++u)r?Pk(i[u],n,a):zk(i[u],n,s,a),a((u===i.length-1?"=":"_").repeat(t));e.checkTrainableWeightsConsistency();const c=function(e){let t;t=null!=e.collectedTrainableWeights?kw(e.collectedTrainableWeights):kw(e.trainableWeights);return t}(e),l=kw(e.nonTrainableWeights);a("Total params: ".concat(c+l)),a("Trainable params: ".concat(c)),a("Non-trainable params: ".concat(l)),a("_".repeat(t))}function Lk(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:console.log,a="";for(let r=0;r<e.length;++r)r>0&&(a=a.slice(0,a.length-1)+" "),a+=e[r],a=a.slice(0,t[r]),a+=" ".repeat(t[r]-a.length);n(a)}function Pk(e,t,n){let a,r;try{r=e.inboundNodes.map((e=>JSON.stringify(e.inputShapes))).join(",")}catch(Yue){r="multiple"}try{a=JSON.stringify(e.outputShape)}catch(Yue){a="multiple"}const o=e.name,s=e.getClassName();Lk(["".concat(o," (").concat(s,")"),r,a,e.countParams().toString()],t,n)}function zk(e,t,n,a){let r,o;try{o=e.inboundNodes.map((e=>JSON.stringify(e.inputShapes))).join(",")}catch(Yue){o="multiple"}try{r=JSON.stringify(e.outputShape)}catch(Yue){r="multiple"}const s=[];for(const u of e.inboundNodes)if(!(null!=n&&n.length>0&&-1===n.indexOf(u)))for(let e=0;e<u.inboundLayers.length;++e){const t=u.inboundLayers[e].name,n=u.nodeIndices[e],a=u.tensorIndices[e];s.push("".concat(t,"[").concat(n,"][").concat(a,"]"))}const i=e.name,c=e.getClassName(),l=0===s.length?"":s[0];Lk(["".concat(i," (").concat(c,")"),o,r,e.countParams().toString(),l],t,a);for(let u=1;u<s.length;++u)Lk(["","","","",s[u]],t,a)}function Bk(e,t,n){return("inboundNodes"===e||"outputLayers"===e||"inputLayers"===e)&&0===t&&"string"===typeof n}function Wk(e,t){if(null===e)return null;if("string"===typeof e)return Yx(e);if("number"===typeof e||"boolean"===typeof e)return e;if(e instanceof Array){const n=[],a=e.length;for(let r=0;r<a;++r){const a=e[r];Bk(t,r,a)?n.push(a):n.push(Wk(a,t))}return n}{const t={};for(const n of Object.keys(e)){const a=e[n];if("name"===n&&"string"===typeof a)t[n]=a;else{const e=Yx(n);t[e]=Wk(a,e)}}return t}}function Vk(e,t){if(null===e||void 0===e)return null;if("string"===typeof e)return Xx(e);if("number"===typeof e||"boolean"===typeof e)return e;if(e instanceof Array){const n=[],a=e.length;for(let r=0;r<a;++r){const a=e[r];Bk(t,r,a)?n.push(a):n.push(Vk(a,t))}return n}{const t={};for(const n of Object.keys(e)){const a=e[n],r=Xx(n);t[r]="name"!==n&&"className"!==n||"string"!==typeof a?Vk(a,n):a}return t}}const Uk="4.18.0";class Gk extends Fw{constructor(e){if(super({}),this.containerNodes=new Set,this.name=e.name,null==this.name){const e=this.getClassName().toLowerCase();this.name=dv(e)}if(this.supportsMasking=!1,this.trainable_=!0,Array.isArray(e.inputs)?this.inputs=e.inputs.slice():this.inputs=[e.inputs],Array.isArray(e.outputs)?this.outputs=e.outputs.slice():this.outputs=[e.outputs],tv(this.inputs).length!==this.inputs.length)throw new Bx("The list of inputs passed to the model is redundant. All inputs should only appear once. Found: "+"".concat(this.inputs.map((e=>e.name))));tv(this.outputs).length!==this.outputs.length&&console.warn("The list of outputs passed to the model is redundant. All outputs should only appear once. Found: "+"".concat(this.outputs.map((e=>e.name)))),this.inputLayers=[],this.inputLayersNodeIndices=[],this.inputLayersTensorIndices=[],this.outputLayers=[],this.outputLayersNodeIndices=[],this.outputLayersTensorIndices=[],this.layers=[],this.internalContainerRefs=[];for(const b of this.outputs){const e=b.sourceLayer,t=b.nodeIndex,n=b.tensorIndex;this.outputLayers.push(e),this.outputLayersNodeIndices.push(t),this.outputLayersTensorIndices.push(n)}for(const b of this.inputs){const e=b.sourceLayer,t=b.nodeIndex,n=b.tensorIndex;Hx(0===t,"input layer has >1 nodes"),Hx(0===n,"input layer has >1 tensors"),this.inputLayers.push(e),this.inputLayersNodeIndices.push(t),this.inputLayersTensorIndices.push(n)}this.inputNames=[],this.outputNames=[],this.feedInputShapes=[],this.feedInputNames=[],this.feedOutputNames=[];for(let b=0;b<this.inputLayers.length;b++){const t=this.inputLayers[b];if(!(t instanceof Dw))throw new TypeError("Input layers to a LayersModel must be InputLayer objects. "+"Received inputs: ".concat(e.inputs,". ")+"Input ".concat(b," (0-based) originates ")+"from layer type ".concat(t.getClassName(),"."));this.inputNames.push(t.name),this.feedInputShapes.push(t.batchInputShape),this.feedInputNames.push(t.name)}for(const b of this.outputLayers)this.outputNames.push(b.name);this.internalInputShapes=this.inputs.map((e=>e.shape)),this.internalOutputShapes=this.outputs.map((e=>e.shape));const t={},n={},a={},r={},o={},s=[],i=(e,t,n,a,r,c)=>{null!=a&&null!=r&&null!=c||(a=e.sourceLayer,r=e.nodeIndex,c=e.tensorIndex);const l=a.inboundNodes[r];if(-1!==n.indexOf(l))throw new zx("The tensor ".concat(e.name,' at layer "').concat(a.name,'" ')+"is part of a cycle.");if(-1!==t.indexOf(l))return;this.containerNodes.add(Gk.nodeKey(a,r)),a.id in o||(o[a.id]=Object.keys(o).length),-1===n.indexOf(l)&&n.push(l);const u=l.inboundLayers.length;for(let o=0;o<u;o++){const e=l.inputTensors[o],a=l.inboundLayers[o],r=l.nodeIndices[o],s=l.tensorIndices[o];i(e,t,n,a,r,s)}for(t.push(l);n.indexOf(l)>=0;)n.splice(n.indexOf(l),1);s.push(l)},c=[],l=[];for(const b of this.outputs)i(b,c,l);const u=s.slice().reverse();for(const b of u){n[b.id]=b,b.id in t||(t[b.id]=0);let e=t[b.id];const o=null==a[b.outboundLayer.id]?0:a[b.outboundLayer.id];e=Math.max(e,o),a[b.outboundLayer.id]=e,r[b.outboundLayer.id]=b.outboundLayer,t[b.id]=e;for(let a=0;a<b.inboundLayers.length;a++){const r=b.inboundLayers[a],o=b.nodeIndices[a],s=r.inboundNodes[o],i=null==t[s.id]?0:t[s.id];t[s.id]=Math.max(e+1,i),n[s.id]=s}}const d={};for(const b in t){const e=t[b];e in d||(d[e]=[]),d[e].push(n[b])}const h={};for(const b in a){const e=a[b];e in h||(h[e]=[]),h[e].push(r[b])}let p=Object.keys(h).map((e=>parseInt(e,10))).sort(ev);this.layers=[];for(const b of p){const e=h[b];e.sort(((e,t)=>{const n=o[e.id],a=o[t.id];return n<a?-1:n>a?1:0}));for(const t of e)t instanceof Gk&&this.internalContainerRefs.push(t),this.layers.push(t)}this.layersByDepth=h,p=Object.keys(d).map((e=>parseInt(e,10))).sort(ev);const f=this.inputs.slice(),m=[];for(const b of p)for(const e of d[b]){const t=e.outboundLayer;if(null!=t){for(const n of e.inputTensors)if(-1===f.indexOf(n))throw new zx("Graph disconnected: cannot obtain value for tensor ".concat(n)+' at layer "'.concat(t.name,'". ')+"The following previous layers were accessed without "+"issue: ".concat(m));for(const t of e.outputTensors)f.push(t);m.push(t.name)}}this.nodesByDepth=d;const g=this.layers.map((e=>e.name));for(const b of g){const e=g.filter((e=>e===b)).length;if(1!==e)throw new zx('The name "'.concat(b,'" is used ').concat(e," times ")+"in the model. All layer names should be unique. Layer names: "+JSON.stringify(g))}this.outboundNodes=[],this.inboundNodes=[],new _w({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:this.inputs.map((e=>null)),outputMasks:this.outputs.map((e=>null)),inputShapes:this.inputs.map((e=>e.shape)),outputShapes:this.outputs.map((e=>e.shape))}),this.built=!0,this._refCount=1}assertNotDisposed(){if(0===this._refCount)throw new Error("Container '".concat(this.name,"' is already disposed."))}dispose(){this.assertNotDisposed();const e={refCountAfterDispose:null,numDisposedVariables:0};if(0===--this._refCount){for(const t of this.layers)e.numDisposedVariables+=t.dispose().numDisposedVariables;for(const t of this.internalContainerRefs)e.numDisposedVariables+=t.dispose().numDisposedVariables}return e.refCountAfterDispose=this._refCount,e}get trainable(){return this.trainable_}set trainable(e){this.layers.forEach((t=>{t._trainableWeights.forEach((t=>t.trainable=e))})),this.trainable_=e}get trainableWeights(){if(this._trainableWeights.length>0)throw new Bx("Container instance unexpectedly contains _trainableWeights.The trainable weights of a Container are a union of the trainable weights of its consituent Layers. Its own _trainableWeights must remain an empty Array.");if(!this.trainable)return[];let e=[];for(const t of this.layers)e=e.concat(t.trainableWeights);return e}get nonTrainableWeights(){const e=[];for(const t of this.layers)e.push(...t.nonTrainableWeights);if(!this.trainable){const t=[];for(const e of this.layers)t.push(...e.trainableWeights);return t.concat(e)}return e}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}loadWeights(e){let t=!(arguments.length>1&&void 0!==arguments[1])||arguments[1];const n={};let a=0;const r=(e=>{const t=Object.keys(e);if(0===t.length)return!1;const n=t[0].split("/");return!isNaN(parseInt(n[n.length-1],10))})(e);r&&this.parseWeights(e);for(const s of this.layers)for(const[e,t]of s.weights.entries()){const o=r?"".concat(t.name.split("/").slice(0,-1).join("/")+"/").concat(e):t.originalName;if(null!=n[o])throw new Bx("Duplicate weight name: ".concat(o));n[o]=t,a++}const o=[];for(const s in e){let a=s;if(null==n[s]){const e=s.split("/");a=e.slice(0,-2).concat([e[e.length-1]]).join("/")}if(null!=n[a])o.push([n[a],e[s]]);else if(t)throw new Bx("Provided weight data has no target variable: ".concat(s));delete n[a]}if(t){const e=[];for(const t in n)e.push(t);if(e.length>0)throw new Bx("".concat(e.length," of ").concat(a," weights are not set: ")+"".concat(e))}Cw(o)}parseWeights(e){for(const t in Object.keys(e)){const n=t.split("/"),a=["vars","layer_checkpoint_dependencies"],r=n.map((e=>e.startsWith("_")?e.slice(1):e)).filter((e=>!a.includes(e))).join("/");r!==t&&(e[r]=e[t],delete e[t])}}updatedConfig(){const e=this.getConfig(),t={};return t.className=this.getClassName(),t.config=e,t.kerasVersion="tfjs-layers ".concat(Uk),t.backend="TensorFlow.js",t}toJSON(e){let t=!(arguments.length>1&&void 0!==arguments[1])||arguments[1];const n=Vk(this.updatedConfig());return t?JSON.stringify(n):n}call(e,t){return Lu((()=>{e=qx(e);const n=new Mw;for(let t=0;t<this.inputs.length;++t)n.add(this.inputs[t],e[t]);return zw(this.outputs,n,t)}))}computeMask(e,t){return Lu((()=>{let n;return e=qx(e),n=null==t?Gx(null,e.length):qx(t),this.runInternalGraph(e,n)[1]}))}computeOutputShape(e){const t=xw(e);if(t.length!==this.inputLayers.length)throw new Bx("Invalid inputShape argument ".concat(e,": ")+"model has ".concat(this.inputLayers.length," tensor inputs."));const n={};for(let s=0;s<t.length;s++){const e=this.inputLayers[s],a=t[s];n[e.name+"_0_0"]=a}const a=Object.keys(this.nodesByDepth).map((e=>parseInt(e,10))).sort(ev);if(a.length>1)for(const s of a){const e=this.nodesByDepth[s];for(const t of e){const e=t.outboundLayer;if(-1!==this.inputLayers.map((e=>e.id)).indexOf(e.id))continue;const a=[];for(let s=0;s<t.inboundLayers.length;s++){const e=t.inboundLayers[s],r=t.nodeIndices[s],o=t.tensorIndices[s],i=n["".concat(e.name,"_").concat(r,"_").concat(o)];a.push(i)}const r=xw(e.computeOutputShape(Kx(a))),o=e.inboundNodes.indexOf(t);for(let t=0;t<r.length;t++){n["".concat(e.name,"_").concat(o,"_").concat(t)]=r[t]}}}const r=[],o=[];for(let s=0;s<this.outputLayers.length;s++){const e=this.outputLayers[s],t=this.outputLayersNodeIndices[s],n=this.outputLayersTensorIndices[s],a="".concat(e.name,"_").concat(t,"_").concat(n);o.push(a)}for(let s=0;s<o.length;s++){const e=o[s];Hx(e in n),r.push(n[e])}return Kx(r)}runInternalGraph(e,t){null==t&&(t=Gx(null,e.length));const n={};for(let i=0;i<this.inputs.length;++i){const a=this.inputs[i],r=e[i],o=t[i];n[a.id]=[r,o]}const a=Object.keys(this.nodesByDepth).map((e=>parseInt(e,10))).sort(ev);for(const i of a){const e=this.nodesByDepth[i];for(const t of e){const e=t.outboundLayer,a=t.inputTensors,r=t.outputTensors,o=new Array;for(const t of a)t.id in n&&o.push(n[t.id]);if(o.length===a.length){let a,s,i,c,l={};if(null!=t.callArgs&&(l=t.callArgs),1===o.length){const[t,n]=o[0];null==l.mask&&(l.mask=n),i=qx(e.call(t,l)),c=qx(e.computeMask(t,n)),a=[t],s=[n]}else a=o.map((e=>e[0])),s=o.map((e=>e[1])),null==l.mask&&(l.mask=s),i=qx(e.call(a,l)),c=qx(e.computeMask(a,s));if(e.activityRegularizer)throw new Wx("LayersModel invocation with concrete Tensor value(s) in the presence of activity regularizer(s) is not supported yet.");for(let e=0;e<r.length;++e){const t=r[e],a=i[e],o=c[e];n[t.id]=[a,o]}}}}const r=[],o=[],s=[];for(const i of this.outputs){Hx(i.id in n,"Could not compute output ".concat(i.name," : ").concat(i.id));const[e,t]=n[i.id];s.push(e.shape),r.push(e),o.push(t)}return[r,o,s]}buildNodeConversionMap(e){const t={};let n;for(const a of this.layers){n=a instanceof Gk?1:0;for(let e=0;e<a.inboundNodes.length;e++){const r=Gk.nodeKey(a,e);this.containerNodes.has(r)&&(t[r]=n,n+=1)}}return t}getLayer(e,t){if(null!=t)return this.findLayer(t);if(null==e)throw new Bx("Provide either a layer name or layer index");if("number"===typeof e)return this.findLayer(e);for(const n of this.layers)if(n.name===e)return n;throw new Bx("No such layer: ".concat(e))}findLayer(e){if(this.layers.length<=e)throw new Bx("Was asked to retrieve layer at index ".concat(e,", but model only ")+"has ".concat(this.layers.length," layer(s)."));return this.layers[e]}calculateLosses(){return Lu((()=>{const e=[];for(const t of this.layers)for(let n=0;n<t.inboundNodes.length;++n){const a=Gk.nodeKey(t,n);this.containerNodes.has(a)&&e.push(...t.calculateLosses())}return e}))}getConfig(){const e={name:this.name},t=this.buildNodeConversionMap(this.layers),n=[];for(const o of this.layers){const e=o.getClassName(),a=o.getConfig(),r=[];for(let n=0;n<o.inboundNodes.length;n++){const e=o.inboundNodes[n],a=Gk.nodeKey(o,n);let s={};if(this.containerNodes.has(a)){if(e.callArgs)try{JSON.stringify(e.callArgs),s=e.callArgs}catch(Yue){console.warn("Layer ".concat(o.name," was passed ")+"non-serializable keyword arguments: "+"".concat(e.callArgs,". They will not be included ")+"in the serialized model (and thus will be missing at deserialization time)."),s={}}if(e.inboundLayers.length>0){const n=[];for(let a=0;a<e.inboundLayers.length;a++){const r=e.inboundLayers[a],o=e.nodeIndices[a],i=e.tensorIndices[a];let c=t[Gk.nodeKey(r,o)];null==c&&(c=0),n.push([r.name,c,i,s])}r.push(n)}}}const s={};s.name=o.name,s.className=e,s.config=a,s.inboundNodes=r,n.push(s)}e.layers=n;const a=[];for(let o=0;o<this.inputLayers.length;o++){const e=this.inputLayers[o],n=this.inputLayersNodeIndices[o],r=Gk.nodeKey(e,n);if(!this.containerNodes.has(r))continue;let s=t[r];null!==s&&void 0!==s||(s=0);const i=this.inputLayersTensorIndices[o];a.push([e.name,s,i])}e.inputLayers=a;const r=[];for(let o=0;o<this.outputLayers.length;o++){const e=this.outputLayers[o],n=this.outputLayersNodeIndices[o],a=Gk.nodeKey(e,n);if(!this.containerNodes.has(a))continue;let s=t[a];null!==s&&void 0!==s||(s=0);const i=this.outputLayersTensorIndices[o];r.push([e.name,s,i])}return e.outputLayers=r,e}static fromConfig(e,t){let n=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const a={},r={};function o(e,t){e.name in r?r[e.name].push(t):r[e.name]=[t]}function s(e,t){const n=[];let r;for(const s of t){const i=s[0],c=s[1],l=s[2];if(r=null==s[3]?{}:s[3],!(i in a))return void o(e,t);const u=a[i];if(u.inboundNodes.length<=c)return void o(e,t);const d=u.inboundNodes[c];n.push(d.outputTensors[l])}n.length>0&&e.apply(Kx(n),r)}function i(e){const r=e.name,s=lk(e,null!=t.customObjects?t.customObjects:{});s.setFastWeightInitDuringBuild(n),a[r]=s;e.inboundNodes.forEach((e=>{if(!(e instanceof Array))throw new Bx("Corrupted configuration, expected array for nodeData: ".concat(e));o(s,e)}))}const c=t.name,l=t.layers;for(const f of l)i(f);for(;!nv(r);)for(const e of l){const t=a[e.name];if(t.name in r){const e=r[t.name];delete r[t.name];for(const n of e)s(t,n)}}const u=[],d=[],h=t.inputLayers;for(const f of h){const e=f[0],t=f[1],n=f[2];Hx(e in a);const r=a[e].inboundNodes[t].outputTensors;u.push(r[n])}const p=t.outputLayers;for(const f of p){const e=f[0],t=f[1],n=f[2];Hx(e in a);const r=a[e].inboundNodes[t].outputTensors;d.push(r[n])}return new e({inputs:u,outputs:d,name:c})}get stateful(){if(this._stateful)throw new Bx("Container instance unexpectedly has _stateful = true. The statefulness of a Container is determined by the Layers it contains. Its _stateful property must remain the default false.");for(const e of this.layers)if(e.stateful)return!0;return!1}resetStates(){Lu((()=>{this.layers.forEach((e=>{e.stateful&&e.resetStates()}))}))}}function Hk(e,t,n){const a=t.length;if(null==e||Array.isArray(e)&&0===e.length)return t.map((e=>null));if(1===a)return Array.isArray(e)&&1===e.length?e:"object"===typeof e&&t[0]in e?[e[t[0]]]:[e];if(Array.isArray(e)){if(e.length!==a)throw new Error("Provided ".concat(n," is an array of ").concat(e.length," ")+"element(s), but the model has ".concat(a," outputs. ")+"Make sure a set of weights is provided for each model output.");return e}if("object"===typeof e&&Object.keys(e).length>0&&"object"===typeof e[Object.keys(e)[0]]){const n=[];return t.forEach((t=>{t in e?n.push(e[t]):n.push(null)})),n}throw new Error("The model has multiple (".concat(a,") outputs, ")+"so ".concat(n," must be either an array with ")+"".concat(a," elements or an object with ").concat(t," keys. ")+"Provided ".concat(n," not understood: ").concat(JSON.stringify(e)))}function jk(e,t){return Hk(e,t,"classWeight")}async function Kk(e,t,n,a){if(null!=t||null!=a)throw new Error("Support sampleWeight is not implemented yet");if(null!=n){const t=Lu((()=>{if(1===e.shape.length)return Td(e);if(2===e.shape.length){if(e.shape[1]>1){return Dh(e,1)}if(1===e.shape[1])return Qh(e,[e.shape[0]]);throw new Error("Encountered unexpected last-dimension size (".concat(e.shape[1],") ")+"during handling of class weights. The size is expected to be >= 1.")}throw new Error("Unexpected rank of target (y) tensor (".concat(e.rank,") during ")+"handling of class weights. The rank is expected to be 1 or 2.")})),a=Array.from(await t.data());Pu(t);const r=[];return a.forEach((e=>{if(null==n[e])throw new Error("classWeight must contain all classes in the training data. "+"The class ".concat(e," exists in the data but not in ")+"classWeight");r.push(n[e])})),Rf(r,"float32")}return null}function qk(e,t){return Ad(e,t)}function Xk(e,t){let n,a;const r=t;n=r.xs,a=r.ys,so(null!=n&&null!=a,(()=>"A Dataset iterator for fitDataset() is expected to generate objects of the form `{xs: xVal, ys: yVal}`, where the two values may be `tf.Tensor`, an array of Tensors, or a map of string to Tensor.  The provided Dataset instead generates "+"".concat(t)));const o=Yk("input",e.inputNames,n),s=Yk("output",e.outputNames,a),i=o[0].shape[0];so(o.length===e.inputs.length,(()=>"LayersModel has ".concat(e.inputs.length," inputs, but the dataset ")+"provides ".concat(o.length," inputs.  (Expected input keys: ")+"".concat(JSON.stringify(e.inputNames),")"))),so(s.length===e.outputs.length,(()=>"LayersModel has ".concat(e.outputs.length," outputs, but the dataset ")+"provides ".concat(s.length," outputs.  (Expected output keys: ")+"".concat(JSON.stringify(e.outputNames),")")));for(let c=0;c<o.length;c++)so(o[c].shape[0]===i,(()=>"Batch size mismatch: input "+"".concat(e.inputNames[c]," has ").concat(o[c].shape[0],"; ")+"expected  ".concat(i," based on input ").concat(e.inputNames[0],".")));for(let c=0;c<s.length;c++)so(s[c].shape[0]===i,(()=>"Batch size mismatch: output "+"".concat(e.outputNames[c]," has ").concat(s[c].shape[0],"; ")+"expected  ".concat(i," based on input ").concat(e.inputNames[0],".")));return{xs:o,ys:s}}function Yk(e,t,n){if(n instanceof Jl)return[n];if(Array.isArray(n))return so(n.length===t.length,(()=>"Received an array of ".concat(n.length," Tensors, but expected ").concat(t.length," to match the ").concat(e," keys ").concat(t,"."))),n;{const a=[];for(const r of t){if(null==n[r])throw new Bx("The feature data generated by the dataset lacks the required "+"".concat(e," key '").concat(r,"'."));a.push(n[r])}return a}}async function Qk(e,t,n){const a=null!=n.batchesPerEpoch;if(so(null!=e.optimizer,(()=>"You must compile a model before training/testing. Use LayersModel.compile(modelCompileConfig).")),so(null!=n,(()=>"For fitDataset(), the 2nd argument (config) is required, but it is not provided in this call.")),so(null!=n.epochs&&n.epochs>0&&Number.isInteger(n.epochs),(()=>"For fitDataset(), config.epochs is expected to be a positive "+"integer, but got ".concat(n.epochs))),so(!a||n.batchesPerEpoch>0&&Number.isInteger(n.batchesPerEpoch),(()=>"For fitDataset(), config.batchesPerEpoch is expected to be a "+"positive integer if specified, but got ".concat(n.batchesPerEpoch))),so(null==n.validationSplit,(()=>"`validationSplit` is not supported by `fitDataset()`. Use validationData instead.")),e.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");e.isTraining=!0;try{const r=null!=n.validationData;let o,s;if(r)if(Jk(n.validationData))so(null==n.validationBatches||n.validationBatches>0&&Number.isInteger(n.validationBatches),(()=>"For fitDataset() with dataset-based validation, config.validationBatches is expected not to be provided, or to be a positive integer, "+"but got ".concat(n.validationBatches)));else{const e=function(e){if(3===e.length)throw new Wx("Validation with sample weights is not implemented yet.");return{xs:e[0],ys:e[1]}}(n.validationData);o=e.xs,s=e.ys}const i=e.makeTrainFunction(),c=e.getDedupedMetricsNames();let l;l=r?c.slice().concat(c.map((e=>"val_"+e))):c.slice();const u=sk(n.callbacks,n.yieldEvery),d=null==n.verbose?1:n.verbose,{callbackList:h,history:p}=ck(u,d,n.epochs,null,null,function(e,t){let n=null;null!=t.batchesPerEpoch?n=t.batchesPerEpoch:Number.isFinite(e.size)&&(n=e.size);return n}(t,n),null,r,l);h.setModel(e),e.history=p,await h.onTrainBegin(),e.stopTraining_=!1;let f=null==n.initialEpoch?0:n.initialEpoch,m=await t.iterator();for(;f<n.epochs;){const l={};await h.onEpochBegin(f);let u=0,d=0;for(a||(m=await t.iterator());!a||u<n.batchesPerEpoch;){const t=await m.next();if(a&&t.done){console.warn("You provided `batchesPerEpoch` as "+"".concat(n.batchesPerEpoch,", ")+"but your dataset iterator ran out of data after "+"".concat(u," batches; ")+"interrupting training. Make sure that your dataset can generate at least `batchesPerEpoch * epochs` batches (in this case, "+"".concat(n.batchesPerEpoch*n.epochs," batches). ")+"You may need to use the repeat() function when building your dataset.");break}if(null!=t.value){const{xs:a,ys:r}=Xk(e,t.value),o={};o.batch=d,o.size=a[0].shape[0],await h.onBatchBegin(d,o);const s=[];if(null!=n.classWeight){const t=jk(n.classWeight,e.outputNames);for(let e=0;e<t.length;++e)s.push(await Kk(r[e],null,t[e]))}const l=a.concat(r).concat(s),p=i(l);Pu(l);for(let e=0;e<c.length;++e){const t=c[e],n=p[e];o[t]=n,zu(n)}await h.onBatchEnd(d,o),$w(o),d++,u++}if(a?u>=n.batchesPerEpoch:t.done){if(r){let t;t=Jk(n.validationData)?qx(await e.evaluateDataset(n.validationData,{batches:n.validationBatches})):qx(e.evaluate(o,s,{batchSize:null==n.validationBatchSize?32:n.validationBatchSize,verbose:0}));for(let n=0;n<e.metricsNames.length;++n)l["val_".concat(e.metricsNames[n])]=t[n]}break}if(e.stopTraining_)break}if(await h.onEpochEnd(f,l),f++,e.stopTraining_)break}return await h.onTrainEnd(),await e.history.syncData(),e.history}finally{e.isTraining=!1}}function Jk(e){return"function"===typeof e.iterator}function Zk(e){so(e>0&&Number.isInteger(e),(()=>"batchSize is required to be a positive integer, but got ".concat(e)))}function $k(e,t,n){return null==e?[null]:Array.isArray(e)?e.map((e=>Lv(e,t,n-t))):Lv(e,t,n-t)}function eI(e,t){return Lu((()=>null==e?null:Array.isArray(e)?e.map((e=>eI(e,t))):Hv(e,"int32"===t.dtype?t:Cd(t,"int32"))))}function tI(e,t){const n=[];let a=0,r=null;for(;a<e;)r=a+t,r>=e&&(r=e),n.push([a,r]),a=r;return n}function nI(e){const t=[];e instanceof Jl&&(e=[e]);for(let n=0;n<e.length;++n){const a=e[n];if(1===a.rank)t.push(Mv(a,1));else{if(0===a.rank)throw new Error("Expected tensor to be at least 1D, but received a 0D tensor (scalar).");t.push(a)}}return t}function aI(e,t){if(null==e)return;const n=[];if(t instanceof Jl)n.push(t.id);else if(Array.isArray(t))t.forEach((e=>n.push(e.id)));else if(null!=t)for(const r in t){const e=t[r];n.push(e.id)}const a=[];if(e instanceof Jl)-1===n.indexOf(e.id)&&a.push(e);else if(Array.isArray(e))e.forEach((e=>{-1===n.indexOf(e.id)&&a.push(e)}));else if(null!=e)for(const r in e){const t=e[r];-1===n.indexOf(t.id)&&a.push(t)}a.forEach((e=>{e.isDisposed||e.dispose()}))}function rI(e){return Array.isArray(e)}function oI(e){return!function(e){return e instanceof Jl}(e)&&!rI(e)}function sI(e,t,n){let a,r=!(arguments.length>3&&void 0!==arguments[3])||arguments[3],o=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"";if(null==t||0===t.length){if(null!=e){let t=!1;if(rI(e)&&e.length>0)t=!0;else if(oI(e)){for(const n in e)if(e.hasOwnProperty(n)){t=!0;break}}else t=!0;if(t)throw new Bx("Error when checking model ".concat(o," expected no data, ")+"but got ".concat(e))}return[]}if(null==e)return t.map((e=>null));if(oI(e)){a=[];for(const n of t){if(null==e[n])throw new Bx('No data provided for "'.concat(n,'". Need data for each key in: ')+"".concat(t));a.push(e[n])}}else if(rI(e)){if(e.length!==t.length)throw new Bx("Error when checking model ".concat(o,": the Array of ")+"Tensors that you are passing to your model is not the size the "+"model expected. Expected to see ".concat(t.length," Tensor(s), but ")+"instead got the following list of Tensor(s): ".concat(e));a=e}else{if(t.length>1)throw new Bx("The model ".concat(o," expects ").concat(t.length," Tensor(s), ")+"but only received one Tensor. Found: Tensor with shape ".concat(e.shape));a=[e]}if(a=nI(a),null!=n)for(let s=0;s<t.length;++s){if(null==n[s])continue;const e=a[s];if(e.shape.length!==n[s].length)throw new Bx("Error when checking ".concat(o,": expected ").concat(t[s]," ")+"to have ".concat(n[s].length," dimension(s). but got array with ")+"shape ".concat(e.shape));for(let t=0;t<n[s].length;++t){if(0===t&&!r)continue;const a=e.shape[t],i=n[s][t];if(null!=i&&i>=0&&a!==i)throw new Bx("".concat(o," expected a batch of elements where each ")+"example has shape [".concat(n[s].slice(1,n[s].length),"] ")+"(i.e.,tensor shape [*,".concat(n[s].slice(1,n[s].length),"])")+" but the ".concat(o," received an input with ").concat(e.shape[0])+" examples, each with shape [".concat(e.shape.slice(1,e.shape.length),"]")+" (tensor shape [".concat(e.shape,"])"))}}return a}function iI(e,t,n){let a,r=!(arguments.length>3&&void 0!==arguments[3])||arguments[3],o=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"";if(Array.isArray(e)){if(e.length!==t.length)throw new Bx("Error when checking model ".concat(o,": the Array of ")+"Tensors that you are passing to your model is not the size the "+"the model expected. Expected to see ".concat(t.length," Tensor(s),")+" but instead got ".concat(e.length," Tensors(s)."));a=e}else{if(t.length>1)throw new Bx("The model expects ".concat(t.length," ").concat(o," Tensors, ")+"but only received one Tensor. Found: array with shape "+"".concat(JSON.stringify(e.shape),"."));a=[e]}if(null!=n)for(let s=0;s<t.length;++s){if(null==n[s])continue;const e=a[s];if(e.shape.length!==n[s].length)throw new Bx("Error when checking ".concat(o,": expected ").concat(t[s]," ")+"to have ".concat(n[s].length," dimension(s), but got array with ")+"shape ".concat(JSON.stringify(e.shape)));for(let a=0;a<n[s].length;++a){if(0===a&&!r)continue;const i=e.shape[a],c=n[s][a];if(null!=c&&c!==i)throw new Bx("Error when checking ".concat(o,": expected ")+"".concat(t[s]," to have shape ").concat(JSON.stringify(n[s])," but ")+"got array with shape ".concat(JSON.stringify(e.shape),"."))}}}class cI extends Gk{constructor(e){super(e),this.isTraining=!1}summary(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:console.log;if(!this.built)throw new Bx("This model has never been called, thus its weights have not been created yet. So no summary can be displayed. Build the model first (e.g., by calling it on some test data).");Mk(this,e,t,n)}compile(e){if(null==e.loss&&(e.loss=[]),this.loss=e.loss,"string"===typeof e.optimizer)this.optimizer_=function(e){const t={Adagrad:()=>Bm.adagrad(.01),Adadelta:()=>Bm.adadelta(1,.95,Ov()),Adam:()=>Bm.adam(.001,.9,.999,Ov()),Adamax:()=>Bm.adamax(.002,.9,.999,Ov(),0),RMSProp:()=>Bm.rmsprop(.001,.9,0,Ov()),SGD:()=>Bm.sgd(.01)};if(t.adagrad=t.Adagrad,t.adadelta=t.Adadelta,t.adam=t.Adam,t.adamax=t.Adamax,t.rmsprop=t.RMSProp,t.sgd=t.SGD,e in t)return t[e]();throw new Bx("Unknown Optimizer ".concat(e))}(e.optimizer),this.isOptimizerOwned=!0;else{if(!(e.optimizer instanceof Ud))throw new Bx("User-defined optimizer must be an instance of tf.Optimizer.");this.optimizer_=e.optimizer,this.isOptimizerOwned=!1}let t=[];if(Array.isArray(e.loss)||"string"===typeof e.loss||"function"===typeof e.loss)if(Array.isArray(e.loss)){if(e.loss.length!==this.outputs.length)throw new Bx("When passing an Array as loss, it should have one entry per "+"model output. The model has ".concat(this.outputs.length," output(s), ")+"but you passed loss=".concat(e.loss,"."));const n=e.loss;t=n.map((e=>wk(e)))}else{const n=wk(e.loss);this.outputs.forEach((e=>{t.push(n)}))}else{e.loss=e.loss;for(const t in e.loss)if(-1===this.outputNames.indexOf(t))throw new Bx('Unknown entry in loss dictionary: "'.concat(t,'". ')+"Only expected the following keys: ".concat(this.outputNames));for(const n of this.outputNames)null==e.loss[n]&&console.warn('Output "'.concat(n,'" is missing from loss dictionary. We assume ')+"this was done on purpose, and we will not be expecting data "+"to be passed to ".concat(n," during training")),t.push(wk(e.loss[n]))}this.lossFunctions=t,this.feedOutputNames=[],this.feedOutputShapes=[],this.feedLossFns=[];for(let o=0;o<this.outputs.length;++o){const e=this.internalOutputShapes[o],t=this.outputNames[o];this.feedOutputNames.push(t),this.feedOutputShapes.push(e),this.feedLossFns.push(this.lossFunctions[o])}const n=[];this.metrics=e.metrics,this.metricsNames=["loss"],this.metricsTensors=[],Iv("loss",(()=>{for(let e=0;e<this.outputs.length;++e){if(-1!==n.indexOf(e))continue;const t=this.lossFunctions[e];this.outputs.length>1&&(this.metricsTensors.push([t,e]),this.metricsNames.push(this.outputNames[e]+"_loss"))}}));const a=function(e,t){if(null==e||Array.isArray(e)&&0===e.length)return t.map((e=>[]));let n;if("string"===typeof e||"function"===typeof e)n=[e];else{if(!Array.isArray(e)&&"object"!==typeof e)throw new TypeError("Type of metrics argument not understood. Expected an string,"+"function, Array, or Object, found: ".concat(e));n=e}if(Array.isArray(n))return t.map((e=>n));{const e=[];for(const a of t){let t=n.hasOwnProperty(a)?n[a]:[];Array.isArray(t)||(t=[t]),e.push(t)}return e}}(e.metrics,this.outputNames),r=(e,t,n)=>{this.outputNames.length>1&&(t=this.outputNames[e]+"_"+t),this.metricsNames.push(t),this.metricsTensors.push([n,e])};Iv("metric",(()=>{for(let e=0;e<this.outputs.length;++e){if(-1!==n.indexOf(e))continue;(t=>{let n,a,o;for(const s of t){if("string"===typeof s&&-1!==["accuracy","acc","crossentropy","ce"].indexOf(s)){const t=this.internalOutputShapes[e];let r;1===t[t.length-1]||this.lossFunctions[e]===bk?-1!==["accuracy","acc"].indexOf(s)?a=kk:-1!==["crossentropy","ce"].indexOf(s)&&(a=Nk):this.lossFunctions[e]===gk?-1!==["accuracy","acc"].indexOf(s)?a=Ck:-1!==["crossentropy","ce"].indexOf(s)&&(a=Ek):-1!==["accuracy","acc"].indexOf(s)?a=Ik:-1!==["crossentropy","ce"].indexOf(s)&&(a=Tk),-1!==["accuracy","acc"].indexOf(s)?r="acc":-1!==["crossentropy","ce"].indexOf(s)&&(r="ce"),o=a,n=""+r}else{const e=_k(s);o=e,n=""+Ak(s)}let t;Iv(n,(()=>{t=o})),r(e,n,t)}})(a[e])}})),this.collectedTrainableWeights=this.trainableWeights}checkTrainableWeightsConsistency(){null!=this.collectedTrainableWeights&&this.trainableWeights.length!==this.collectedTrainableWeights.length&&console.warn("Discrepancy between trainableweights and collected trainable weights. Did you set `model.trainable` without calling `model.compile()` afterwards?")}evaluate(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};const a=null==n.batchSize?32:n.batchSize;Zk(a);const r=this.standardizeUserDataXY(e,t,!0,a);try{const e=r[0].concat(r[1]);this.makeTestFunction();const t=this.testFunction;return Kx(this.testLoop(t,e,a,n.verbose,n.steps))}finally{aI(r[0],e),aI(r[1],t)}}async evaluateDataset(e,t){return this.makeTestFunction(),async function(e,t,n){const a=null!=(n=n||{}).batches,r=e.testFunction;let o=[];if(n.verbose>0)throw new Wx("Verbose mode is not implemented yet.");so(!a||n.batches>0&&Number.isInteger(n.batches),(()=>"Test loop expects `batches` to be a positive integer, but "+"received ".concat(JSON.stringify(n.batches))));const s="function"===typeof t.next?t:await t.iterator();let i=0,c=0;for(;!a||c<n.batches;){const t=await s.next();if(o=Lu((()=>{if(t.value){const{xs:n,ys:a}=Xk(e,t.value),s=n.concat(a),l=Lu((()=>r(s)));if(Pu(s),0===c)for(let e=0;e<l.length;++e)o.push(Ld(0));const u=s[0].shape[0];for(let e=0;e<l.length;++e){const t=l[e],n=o[e];o[e]=Lu((()=>Ed(o[e],Ad(u,t)))),c>0&&Pu(n)}Pu(l),i+=u,++c}return o})),t.done){a&&console.warn("Your dataset iterator ran out of data during evaluateDataset(). Interrupting evalution. Make sure that your dataset can generate at least `batches` "+"batches (in this case, ".concat(n.batches," batches). ")+"You may need to use the repeat() function when building your dataset.");break}}for(let l=0;l<o.length;++l){const e=o[l];o[l]=_d(o[l],i),Pu(e)}return Kx(o)}(this,e,t)}checkNumSamples(e,t,n){let a,r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"steps";if(null!=n){if(a=null,null!=t)throw new Bx("If ".concat(r," is set, batchSize must be null or undefined.")+"Got batchSize = ".concat(t))}else{if(null==e)throw new Bx("Either the input data should have a defined shape, or "+"".concat(r," shoud be specified."));a=Array.isArray(e)?e[0].shape[0]:e.shape[0]}return a}execute(e,t){if(Array.isArray(t)&&0===t.length)throw new Bx("`outputs` is an empty Array, which is not allowed.");const n=Array.isArray(t),a=n?t:[t],r=this.retrieveSymbolicTensors(a),o=new Mw;if(e instanceof Jl&&(e=[e]),Array.isArray(e)){if(e.length!==this.inputs.length)throw new Bx("The number of inputs provided (".concat(e.length,") ")+"does not match the number of inputs of this model "+"(".concat(this.inputs.length,")."));for(let t=0;t<this.inputs.length;++t)o.add(this.inputs[t],e[t])}else for(const i of this.inputs){const t=e[i.name];if(null==t)throw new Bx("No value is provided for the model's input ".concat(i.name));o.add(i,t)}const s=zw(r,o);return n?s:s[0]}retrieveSymbolicTensors(e){const t=Gx(null,e.length);let n=e.length;for(const a of this.layers){const r=Array.isArray(a.output)?a.output:[a.output],o=r.map((e=>e.name));for(let a=0;a<e.length;++a){const s=o.indexOf(e[a]);if(-1!==s&&(t[a]=r[s],n--),0===n)break}if(0===n)break}if(n>0){const n=[];throw t.forEach(((t,a)=>{null==t&&n.push(e[a])})),new Bx("Cannot find SymbolicTensors for output name(s): "+"".concat(JSON.stringify(n)))}return t}predictLoop(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:32,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];return Lu((()=>{const a=this.checkNumSamples(e);if(n)throw new Wx("Verbose predictLoop() is not implemented yet.");const r=tI(a,t),o=this.outputs.map((e=>[]));for(let t=0;t<r.length;++t){const n=Lu((()=>{const n=r[t][0],a=r[t][1],o=$k(e,n,a),s=[];if(Array.isArray(o))for(let e=0;e<o.length;++e)s.push({key:this.inputs[e],value:o[e]});else s.push({key:this.inputs[0],value:o});const i=new Mw(s);return zw(this.outputs,i)}));n.forEach(((e,t)=>o[t].push(e)))}return Kx(o.map((e=>op(e,0))))}))}predict(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const n=nI(e);iI(n,this.inputNames,this.feedInputShapes,!1);try{const e=null==t.batchSize?32:t.batchSize;return Zk(e),this.predictLoop(n,e)}finally{aI(n,e)}}predictOnBatch(e){iI(e,this.inputNames,this.feedInputShapes,!0);const t=(Array.isArray(e)?e[0]:e).shape[0];return this.predictLoop(e,t)}standardizeUserDataXY(e,t){let n=arguments.length>3?arguments[3]:void 0;if(null==this.optimizer_)throw new zx("You must compile a model before training/testing. Use LayersModel.compile(modelCompileArgs).");const a=[];for(let r=0;r<this.feedOutputShapes.length;++r){const e=this.feedOutputShapes[r];this.feedLossFns[r]===gk?a.push(e.slice(0,e.length-1).concat([1])):a.push(e)}if(function(e,t,n){const a=tv(e.map((e=>e.shape[0])));a.sort();const r=tv(t.map((e=>e.shape[0])));if(r.sort(),a.length>1)throw new Bx("All input Tensors (x) should have the same number of samples. Got array shapes: "+"".concat(JSON.stringify(e.map((e=>e.shape)))));if(r.length>1)throw new Bx("All target Tensors (y) should have the same number of samples. Got array shapes: "+"".concat(JSON.stringify(t.map((e=>e.shape)))));if(a.length>0&&r.length>0&&!uo(a,r))throw new Bx("Input Tensors should have the same number of samples as target "+"Tensors. Found ".concat(a[0]," input sample(s) and ").concat(r[0]," target ")+"sample(s).")}(e=sI(e,this.feedInputNames,this.feedInputShapes,!1,"input"),t=sI(t,this.feedOutputNames,a,!1,"target")),function(e,t,n){const a=[dk,bk,mk];for(let r=0;r<e.length;++r){const o=e[r],s=t[r],i=n[r];if(null!=s){if(s===mk&&1===o.shape[o.shape.length-1])throw new Bx("You are passing a target array of shape ".concat(o.shape," while using ")+"a loss 'categorical_crossentropy'. 'categorical_crossentropy'expects targets to be binary matrices (1s and 0s) of shape [samples, classes].");if(-1!==a.indexOf(s)){const e=o.shape.slice(1),t=i.slice(1);for(let n=0;n<e.length;++n){const a=e[n],r=t[n];if(null!=r&&a!==r)throw new Bx("A target Tensor with shape ".concat(o.shape," was passed for an ")+"output of shape ".concat(i,", while using a loss function that ")+"expects targets to have the same shape as the output.")}}}}}(t,this.feedLossFns,this.feedOutputShapes),this.stateful&&null!=n&&n>0&&e[0].shape[0]%n!==0)throw new Bx("In a stateful network, you should only pass inputs with a number of samples that is divisible by the batch size "+"".concat(n,". Found: ").concat(e[0].shape[0]," sample(s)."));return[e,t]}async standardizeUserData(e,t,n,a){let r=!(arguments.length>4&&void 0!==arguments[4])||arguments[4],o=arguments.length>5?arguments[5]:void 0;const[s,i]=this.standardizeUserDataXY(e,t,r,o);if(null!=n)throw new Error("sample weight is not supported yet.");let c=null;if(null!=a){const e=jk(a,this.outputNames);c=[];for(let t=0;t<e.length;++t)c.push(await Kk(i[t],null,e[t]))}return[s,i,c]}testLoop(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0,r=arguments.length>4?arguments[4]:void 0;return Lu((()=>{const o=this.checkNumSamples(t,n,r,"steps"),s=[];if(a>0)throw new Wx("Verbose mode is not implemented yet.");if(null!=r)throw new Wx("steps mode in testLoop() is not implemented yet");{const a=tI(o,n),r=Rf(Av(0,o));for(let n=0;n<a.length;++n){const o=a[n][0],i=a[n][1],c=Lv(r,o,i-o),l=eI(t,c),u=e(l);if(0===n)for(let e=0;e<u.length;++e)s.push(Ld(0));for(let e=0;e<u.length;++e){const t=u[e];s[e]=Ed(s[e],Ad(i-o,t))}}for(let e=0;e<s.length;++e)s[e]=_d(s[e],o)}return s}))}getDedupedMetricsNames(){const e=this.metricsNames,t=[];for(let n=0;n<e.length;++n){const a=e[n];let r=a;if(jx(e,a)>1){const t=jx(e.slice(0,n),a);r+="_".concat(t)}t.push(r)}return t}makeTrainFunction(){return e=>{const t=[],n=e.slice(0,this.inputs.length),a=e.slice(this.inputs.length,this.inputs.length+this.outputs.length),r=e.slice(this.inputs.length+this.outputs.length,this.inputs.length+2*this.outputs.length),o=[],s=this.collectedTrainableWeights.map((e=>e.read())),i=this.optimizer_.minimize((()=>{const e=[];for(let t=0;t<this.inputs.length;++t)e.push({key:this.inputs[t],value:n[t]});const s=new Mw(e),i=zw(this.outputs,s,{training:!0});let c;for(let n=0;n<this.lossFunctions.length;++n){let e=(0,this.lossFunctions[n])(a[n],i[n]);null!=r[n]&&(e=qk(e,r[n]));const o=Xp(e);t.push(o),c=0===n?e:Ed(c,e)}for(let n=0;n<this.metricsTensors.length;++n){let e;if(this.outputs.length>1&&n<this.outputs.length)e=t[n];else{const t=this.metricsTensors[n][0],r=this.metricsTensors[n][1];e=Xp(t(a[r],i[r]))}zu(e),o.push(e)}return c=Xp(c),this.calculateLosses().forEach((e=>{c=Ed(c,e)})),c}),!0,s);return[i].concat(o)}}makeTestFunction(){this.testFunction=e=>Lu((()=>{const t=[];let n;const a=e.slice(0,this.inputs.length),r=e.slice(this.inputs.length,this.inputs.length+this.outputs.length),o=[];for(let e=0;e<this.inputs.length;++e)o.push({key:this.inputs[e],value:a[e]});const s=new Mw(o),i=zw(this.outputs,s);for(let e=0;e<this.lossFunctions.length;++e){const a=this.lossFunctions[e],o=Xp(a(r[e],i[e]));n=0===e?o:Ed(n,o),t.push(n)}for(let e=0;e<this.metricsTensors.length;++e){const n=this.metricsTensors[e][0],a=this.metricsTensors[e][1],o=Xp(n(r[a],i[a]));t.push(o)}return t}))}async fit(e,t){let n,a,r,o,s,i,c,l,u,d=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};if(this.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");this.isTraining=!0;try{const h=null==d.batchSize?32:d.batchSize;Zk(h);const p=!1,f=await this.standardizeUserData(e,t,d.sampleWeight,d.classWeight,p,h);n=f[0],a=f[1],u=f[2];let m,g=!1;if(null!=d.validationData&&d.validationData.length>0){if(g=!0,2!==d.validationData.length)throw 3===d.validationData.length?new Wx("validationData including sample weights is not supported yet."):new Bx("When passing validation data, it must contain 2 (valX, valY) or 3 (valX, valY, valSampleWeight) items; "+"".concat(d.validationData," is invalid."));s=d.validationData[0],i=d.validationData[1];const e=!0,t=await this.standardizeUserData(s,i,null,null,e,h);c=t[0],l=t[1],m=c.concat(l)}else if(null!=d.validationSplit&&d.validationSplit>0&&d.validationSplit<1){g=!0;const e=Math.floor(n[0].shape[0]*(1-d.validationSplit)),t=n[0].shape[0];c=$k(n,e,t),r=n,n=$k(n,0,e),l=$k(a,e,t),o=a,a=$k(a,0,e),m=c.concat(l)}else null!=d.validationSteps&&(g=!0);const b=n.concat(a).concat(u);this.checkTrainableWeightsConsistency();const y=this.makeTrainFunction(),x=this.getDedupedMetricsNames();let v,w;g?(this.makeTestFunction(),v=this.testFunction,w=x.slice().concat(x.map((e=>"val_"+e)))):(v=null,m=[],w=x.slice());const k=sk(d.callbacks,d.yieldEvery);return await this.fitLoop(y,b,x,h,d.epochs,d.verbose,k,v,m,d.shuffle,w,d.initialEpoch,null,null)}finally{this.isTraining=!1,aI(n,e),aI(a,t),aI(r,e),aI(o,t),aI(c,s),aI(l,i),null!=u&&Pu(u)}}async fitLoop(e,t,n,a,r,o,s,i,c,l,u,d,h,p){null==a&&(a=32),null==r&&(r=1),null==l&&(l=!0),null==d&&(d=0);let f=!1;if(null!=i&&null!=c&&(f=!0),null!=p&&(f=!0,null==h))throw new Bx("Can only use `validationSteps` when doing step-wise training, i.e., `stepsPerEpoch` must be set.");const m=this.checkNumSamples(t,a,h,"steps_per_epoch");let g;null!=m&&(g=Av(0,m)),null==o&&(o=1);const{callbackList:b,history:y}=ck(s,o,r,d,m,h,a,f,u);b.setModel(this),this.history=y,await b.onTrainBegin(),this.stopTraining_=!1;for(let x=d;x<r;++x){await b.onEpochBegin(x);const r={};if(null!=h)throw new Wx("stepsPerEpoch mode is not implemented yet.");{if("batch"===l)throw new Wx("batch shuffling is not implemneted yet");l&&no(g);const o=Rf(g),s=tI(m,a);for(let l=0;l<s.length;++l){const u={};if(await b.onBatchBegin(l,u),Lu((()=>{const d=s[l][0],h=s[l][1],p=Lv(o,d,h-d);u.batch=l,u.size=h-d;const m=eI(t,p),g=e(m);for(let e=0;e<n.length;++e){const t=n[e],a=g[e];u[t]=a,zu(a)}if(l===s.length-1&&f){const e=this.testLoop(i,c,a);for(let t=0;t<n.length;++t){const a=n[t],o=e[t];zu(o),r["val_"+a]=o}}})),await b.onBatchEnd(l,u),$w(u),this.stopTraining_)break}o.dispose()}if(await b.onEpochEnd(x,r),this.stopTraining_)break}return await b.onTrainEnd(),await this.history.syncData(),this.history}async fitDataset(e,t){return Qk(this,e,t)}async trainOnBatch(e,t){const n=await this.standardizeUserData(e,t),a=n[0],r=n[1],o=this.makeTrainFunction()(a.concat(r)),s=[];for(const i of o){const e=await i.data();s.push(e[0])}return Pu(o),aI(n[0],e),aI(n[1],t),Kx(s)}getNamedWeights(e){const t=[],n=null!=e&&e.trainableOnly,a=n?this.trainableWeights:this.weights,r=this.getWeights(n);for(let o=0;o<a.length;++o)n&&!a[o].trainable||t.push({name:a[o].originalName,tensor:r[o]});return t}set stopTraining(e){this.stopTraining_=e}get stopTraining(){return this.stopTraining_}get optimizer(){return this.optimizer_}set optimizer(e){this.optimizer_!==e&&(this.optimizer_=e,this.isOptimizerOwned=!1)}dispose(){const e=super.dispose();if(0===e.refCountAfterDispose&&null!=this.optimizer&&this.isOptimizerOwned){const t=Mu().numTensors;this.optimizer_.dispose(),e.numDisposedVariables+=t-Mu().numTensors}return e}getLossIdentifiers(){let e;if("string"===typeof this.loss)e=Xx(this.loss);else if(Array.isArray(this.loss)){for(const e of this.loss)if("string"!==typeof e)throw new Error("Serialization of non-string loss is not supported.");e=this.loss.map((e=>Xx(e)))}else{const t=Object.keys(this.loss);e={};const n=this.loss;for(const a of t){if("string"!==typeof n[a])throw new Error("Serialization of non-string loss is not supported.");e[a]=Xx(n[a])}}return e}getMetricIdentifiers(){if("string"===typeof this.metrics||"function"===typeof this.metrics)return[Xx(Ak(this.metrics))];if(Array.isArray(this.metrics))return this.metrics.map((e=>Xx(Ak(e))));{const e={};for(const t in this.metrics)e[t]=Xx(Ak(this.metrics[t]));return e}}getTrainingConfig(){return{loss:this.getLossIdentifiers(),metrics:this.getMetricIdentifiers(),optimizer_config:{class_name:this.optimizer.getClassName(),config:this.optimizer.getConfig()}}}loadTrainingConfig(e){if(null!=e.weighted_metrics)throw new Error("Loading weight_metrics is not supported yet.");if(null!=e.loss_weights)throw new Error("Loading loss_weights is not supported yet.");if(null!=e.sample_weight_mode)throw new Error("Loading sample_weight_mode is not supported yet.");const t=lk(Wk(e.optimizer_config));let n,a;if("string"===typeof e.loss)n=Yx(e.loss);else if(Array.isArray(e.loss))n=e.loss.map((e=>Yx(e)));else if(null!=e.loss){n={};for(const t in e.loss)n[t]=Yx(e.loss[t])}if(Array.isArray(e.metrics))a=e.metrics.map((e=>Yx(e)));else if(null!=e.metrics){a={};for(const t in e.metrics)a[t]=Yx(e.metrics[t])}this.compile({loss:n,metrics:a,optimizer:t})}async save(e,t){if("string"===typeof e){const t=(n=e,Ju.getSaveHandlers(n));if(0===t.length)throw new Bx("Cannot find any save handlers for URL '".concat(e,"'"));if(t.length>1)throw new Bx("Found more than one (".concat(t.length,") save handlers for ")+"URL '".concat(e,"'"));e=t[0]}var n;if(null==e.save)throw new Bx("LayersModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");const a=await Gu(this.getNamedWeights(t)),r={modelTopology:this.toJSON(null,!1),format:"layers-model",generatedBy:"TensorFlow.js tfjs-layers v".concat(Uk),convertedBy:null};if(null!=t&&t.includeOptimizer&&null!=this.optimizer){r.trainingConfig=this.getTrainingConfig();const e="optimizer",{data:t,specs:n}=await Gu(await this.optimizer.getWeights(),e);a.specs.push(...n),a.data=(o=[a.data,t],Ou.join(o))}var o;if(null!=this.userDefinedMetadata){const e=!0;Ok(this.userDefinedMetadata,this.name,e),r.userDefinedMetadata=this.userDefinedMetadata}return r.weightData=a.data,r.weightSpecs=a.specs,e.save(r)}setUserDefinedMetadata(e){Ok(e,this.name),this.userDefinedMetadata=e}getUserDefinedMetadata(){return this.userDefinedMetadata}}cI.className="Model",Vd(cI);class lI extends cI{}lI.className="Functional",Vd(lI);class uI extends cI{constructor(e){if(super({inputs:[],outputs:[]}),e=e||{},this.trainable=!0,this.built=!1,this.name=null!=e.name?e.name:dv("sequential_"),null!=e.layers)for(const t of e.layers)this.add(t)}checkShape(e){if(e.inboundNodes[0].outputTensors[0].shape.some((e=>e<0)))throw new Bx("Negative dimension size caused by adding layer "+"".concat(e.name," with input shape [")+"".concat(e.inboundNodes[0].inputTensors[0].shape,"]"))}add(e){const t=e instanceof uI||e instanceof cI;let n;if(t){if(n=e,1!==n.outputs.length)throw new Bx("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");if(1!==n.inputs.length)throw new Bx("All layers in a Sequential model should have a single input tensor. For multi-input layers, use the functional API.")}if(0===this.outputs.length){if(0===e.inboundNodes.length){if(null==e.batchInputShape)throw new Bx("The first layer in a Sequential model must get an `inputShape` or `batchInputShape` argument.");const t=function(e){if(null==e.batchShape&&null==e.shape)throw new Error("Please provide to Input either a `shape` or a `batchShape` argument. Note that `shape` does not include the batch dimension.");if(null!=e.batchShape&&null!=e.shape)throw new Bx("Please provide either a `shape` or `batchShape` argument to Input, but not both.");let t=e.batchShape;null!=e.shape&&null==t&&(t=[null].concat(e.shape));let n=e.dtype;return null==n&&(n="float32"),new Dw({batchInputShape:t,name:e.name,dtype:n,sparse:e.sparse}).inboundNodes[0].outputTensors[0]}({batchShape:e.batchInputShape,dtype:e.dtype,name:e.name+"_input"});e.apply(t)}if(t)this.outputs=n.outputs,this.inputs=n.inputs;else{if(1!==e.inboundNodes.length)throw new Bx("A layer added to a Sequential model must not already be "+"connected somewhere else. LayersModel received layer ".concat(e.name," ")+"which has ".concat(e.inboundNodes.length," pre-existing inbound ")+"connections.");if(1!==e.inboundNodes[0].outputTensors.length)throw new Bx("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(e),this.outputs=[e.inboundNodes[0].outputTensors[0]],this.inputs=Ow(this.outputs[0])}this.inboundNodes=[],new _w({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:Gx(null,this.inputs.length),outputMasks:[null],inputShapes:this.inputs.map((e=>e.shape)),outputShapes:this.outputs[0].shape})}else{const t=e.apply(this.outputs[0]);if(Array.isArray(t))throw new TypeError("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(e),this.outputs=[t],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}this.layers.push(e),this.built=!1}pop(){if(0===this.layers.length)throw new TypeError("There are no layers in the model.");if(this.layers.pop(),0===this.layers.length)this.outputs=[],this.inboundNodes=[],this.outboundNodes=[];else{const e=this.layers.length-1;this.layers[e].outboundNodes=[],this.outputs=[this.layers[e].output],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}}call(e,t){return null==this.model&&this.build(),this.model.call(e,t)}build(e){if(ww(e),0===this.inputs.length||0===this.outputs.length)throw new TypeError("Sequential model cannot be built: model is empty. Add some layers first.");this.model=new cI({inputs:this.inputs,outputs:this.outputs[0],name:this.name+"_model"}),this.model.trainable=this.trainable,this.supportsMasking=this.model.supportsMasking,this.inputLayers=this.model.inputLayers,this.inputLayersNodeIndices=this.model.inputLayersNodeIndices,this.inputLayersTensorIndices=this.model.inputLayersTensorIndices,this.outputLayers=this.model.outputLayers,this.outputLayersNodeIndices=this.model.outputLayersNodeIndices,this.outputLayersTensorIndices=this.model.outputLayersTensorIndices,this.nodesByDepth=this.model.nodesByDepth,this.containerNodes=this.model.containerNodes,this.outputNames=this.model.outputNames,this.inputNames=this.model.inputNames,this.built=!0}countParams(){return this.built||this.build(),super.countParams()}summary(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:console.log;this.built||this.build(),super.summary(e,t,n)}setWeights(e){null==this.model&&this.build(),this.model.setWeights(e)}evaluate(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};if(!this.built)throw new zx("The model needs to be compiled before being used.");return this.model.evaluate(e,t,n)}async evaluateDataset(e,t){if(!this.built)throw new zx("The model needs to be compiled before being used.");return this.model.evaluateDataset(e,t)}predict(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return null==this.model&&this.build(),this.model.predict(e,t)}predictOnBatch(e){return null==this.model&&this.build(),this.model.predictOnBatch(e)}compile(e){this.build(),this.model.compile(e),this.optimizer_=this.model.optimizer,this.isOptimizerOwned=this.model.isOptimizerOwned,this.loss=this.model.loss,this.metrics=this.model.metrics,this.metricsTensors=this.model.metricsTensors,this.metricsNames=this.model.metricsNames}get optimizer(){return null==this.model?void 0:this.model.optimizer}set optimizer(e){this.model.optimizer=e}async fit(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};if(!this.built)throw new zx("The model needs to be compiled before being used.");return this.model.fit(e,t,n)}async fitDataset(e,t){if(!this.built)throw new zx("The model needs to be compiled before being used.");return this.model.fitDataset(e,t)}async trainOnBatch(e,t){return this.model.trainOnBatch(e,t)}static fromConfig(e,t){let n,a=arguments.length>3&&void 0!==arguments[3]&&arguments[3],r={};if(t instanceof Array){if(null==t[0].className||"Merge"===t[0].className)throw new Bx("Legacy serialization format not supported yet.");n=t}else so(null!=t.layers,(()=>"When the config data for a Sequential model is not an Array, it must be an Object that contains the 'layers' field.")),n=t.layers,delete t.layers,r=t;const o=new e(r);if(!(o instanceof uI))throw new Wx("Sequential.fromConfig called on non-Sequential input: ".concat(o));for(const s of n){const e=lk(s,void 0,a);a&&e.setFastWeightInitDuringBuild(!0),o.add(e)}return o}set stopTraining(e){if(null==this.model)throw new Bx("Cannot set the stopTraining property of a sequential model before it is compiled.");this.model.stopTraining=e}get stopTraining(){if(null==this.model)throw new Bx("Cannot get the stopTraining property of a sequential model before it is compiled.");return this.model.stopTraining}getConfig(){const e=[];for(const t of this.layers){const n={};n.className=t.getClassName(),n.config=t.getConfig(),e.push(n)}return{name:this.name,layers:e}}}uI.className="Sequential",Vd(uI);class dI extends Bd{getConfig(){return{}}}class hI extends dI{apply(e){return function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;if(1!==t)throw new Wx("Support for alpha values other than 1 (".concat(t,") is not implemented ")+"yet.");return xp(e)}(e,arguments.length>1&&void 0!==arguments[1]?arguments[1]:1)}}hI.className="elu",Vd(hI);class pI extends dI{apply(e){return mf(e)}}pI.className="selu",Vd(pI);class fI extends dI{apply(e){return pf(e)}}fI.className="relu",Vd(fI);class mI extends dI{apply(e){return Lu((()=>Qp(6,pf(e))))}}mI.className="relu6",Vd(mI);class gI extends dI{apply(e){return e}}gI.className="linear",Vd(gI);class bI extends dI{apply(e){return bf(e)}}bI.className="sigmoid",Vd(bI);class yI extends dI{apply(e){return function(e){return Lu((()=>{const t=Ed(.5,Ad(.2,e));return rp(t,0,1)}))}(e)}}yI.className="hardSigmoid",Vd(yI);class xI extends dI{apply(e){return Sf(e)}}xI.className="softplus",Vd(xI);class vI extends dI{apply(e){return function(e){return Lu((()=>_d(e,Ed(Yd(e),1))))}(e)}}vI.className="softsign",Vd(vI);class wI extends dI{apply(e){return Ef(e)}}wI.className="tanh",Vd(wI);class kI extends dI{apply(e){return If(e,arguments.length>1&&void 0!==arguments[1]?arguments[1]:-1)}}kI.className="softmax",Vd(kI);class II extends dI{apply(e){return Dp(e,arguments.length>1&&void 0!==arguments[1]?arguments[1]:-1)}}II.className="logSoftmax",Vd(II);class SI extends dI{apply(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return Lu((()=>Ad(bf(Ad(e,t)),e)))}}SI.className="swish",Vd(SI);class NI extends dI{apply(e){return Lu((()=>Ad(e,Ef(Sf(e)))))}}function CI(e){return e.getClassName()}function TI(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return $x(e,Wd.getMap().classNameMap,t,"activation")}function EI(e){if(null==e){const e={className:"linear",config:{}};return TI(e)}if("string"===typeof e){const t={};return t.className=e,t.config={},TI(t)}return e instanceof dI?e:TI(e)}function RI(e){if(null!=e&&"object"!==typeof e)throw new Error("Argument to L1L2 regularizer's constructor is expected to be an "+"object, but received: ".concat(e))}NI.className="mish",Vd(NI);class _I extends Bd{}class AI extends _I{constructor(e){super(),RI(e),this.l1=null==e||null==e.l1?.01:e.l1,this.l2=null==e||null==e.l2?.01:e.l2,this.hasL1=0!==this.l1,this.hasL2=0!==this.l2}apply(e){return Lu((()=>{let t=tf([1]);return this.hasL1&&(t=Ed(t,Op(Ad(this.l1,Yd(e))))),this.hasL2&&(t=Ed(t,Op(Ad(this.l2,jv(e))))),Qh(t,[])}))}getConfig(){return{l1:this.l1,l2:this.l2}}static fromConfig(e,t){return new e({l1:t.l1,l2:t.l2})}}AI.className="L1L2",Vd(AI);const FI={l1l2:"L1L2"};function OI(e){return Jx(e)}function DI(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return $x(e,Wd.getMap().classNameMap,t,"regularizer")}function MI(e){if(null==e)return null;if("string"===typeof e){return DI({className:e in FI?FI[e]:e,config:{}})}return e instanceof _I?e:DI(e)}class LI extends Fw{constructor(e){super(null==e?{}:e),this.supportsMasking=!0,null!=e&&(this.maxValue=e.maxValue)}call(e,t){e=vw(e);let n=pf(e);return null!=this.maxValue&&(n=rp(n,0,this.maxValue)),n}computeOutputShape(e){return e}getConfig(){const e={maxValue:this.maxValue},t=super.getConfig();return Object.assign(e,t),e}}LI.className="ReLU",Vd(LI);class PI extends Fw{constructor(e){super(null==e?{}:e),this.DEFAULT_ALPHA=.3,null==e&&(e={}),this.alpha=null==e.alpha?this.DEFAULT_ALPHA:e.alpha}call(e,t){const n=vw(e);return Rp(n,this.alpha)}computeOutputShape(e){return e}getConfig(){const e={alpha:this.alpha},t=super.getConfig();return Object.assign(e,t),e}}PI.className="LeakyReLU",Vd(PI);class zI extends Fw{constructor(e){if(super(null==e?{}:e),this.DEFAULT_ALPHA_INITIALIZER="zeros",null==e&&(e={}),this.supportsMasking=!0,this.alphaInitializer=bw(e.alphaInitializer||this.DEFAULT_ALPHA_INITIALIZER),this.alphaRegularizer=MI(e.alphaRegularizer),this.alphaConstraint=Jw(e.alphaConstraint),null==e.sharedAxes)this.sharedAxes=null;else if(Array.isArray(e.sharedAxes))this.sharedAxes=e.sharedAxes;else{if("number"!==typeof e.sharedAxes)throw new Bx("Expected sharedAxes to be a number or an array of numbers, "+"but got ".concat(e.sharedAxes));this.sharedAxes=[e.sharedAxes]}}build(e){const t=(e=ww(e)).slice(1);if(null!=this.sharedAxes)for(const a of this.sharedAxes)t[a-1]=1;this.alpha=this.addWeight("alpha",t,"float32",this.alphaInitializer,this.alphaRegularizer,!0,this.alphaConstraint);const n={};if(null!=this.sharedAxes)for(let a=1;a<e.length;++a)n[a]=e[a];this.inputSpec=[new Tw({ndim:e.length,axes:n})],this.built=!0}call(e,t){return e=vw(e),of(e,this.alpha.read())}getConfig(){const e={alphaInitializer:gw(this.alphaInitializer),alphaRegularizer:OI(this.alphaRegularizer),alphaConstraint:Yw(this.alphaConstraint),sharedAxes:this.sharedAxes},t=super.getConfig();return Object.assign(e,t),e}}zI.className="PReLU",Vd(zI);class BI extends Fw{constructor(e){if(super(null==e?{}:e),this.DEFAULT_ALPHA=1,null==e&&(e={}),null!=e.alpha&&e.alpha!==this.DEFAULT_ALPHA)throw new Wx("Non-default alpha value (".concat(e.alpha,") is not supported by the ")+"ELU layer yet.");this.alpha=null==e.alpha?this.DEFAULT_ALPHA:e.alpha}call(e,t){const n=vw(e);return xp(n)}computeOutputShape(e){return e}getConfig(){const e={alpha:this.alpha},t=super.getConfig();return Object.assign(e,t),e}}BI.className="ELU",Vd(BI);class WI extends Fw{constructor(e){super(null==e?{}:e),this.DEFAULT_THETA=1,null==e&&(e={}),this.theta=null==e.theta?this.DEFAULT_THETA:e.theta}call(e,t){const n=vw(e);return Ad(n,Cd(Tp(n,this.theta),"float32"))}computeOutputShape(e){return e}getConfig(){const e={theta:this.theta},t=super.getConfig();return Object.assign(e,t),e}}WI.className="ThresholdedReLU",Vd(WI);class VI extends Fw{constructor(e){super(null==e?{}:e),this.DEFAULT_AXIS=1,null==e&&(e={}),this.softmax=(new kI).apply,this.axis=null==e.axis?this.DEFAULT_AXIS:e.axis}call(e,t){return Lu((()=>{let n=vw(e);const a=t.mask;if(null!=a){const e=Ad(qd(nf(n.shape),Cd(a,n.dtype)),Ld(-1e9));n=Ed(n,e)}return this.axis instanceof Array?this.axis.length>1?wp(qd(n,Gp(n,this.axis,!0))):this.softmax(n,this.axis[0]):this.softmax(n,this.axis)}))}computeOutputShape(e){return e}getConfig(){const e={axis:this.axis},t=super.getConfig();return Object.assign(e,t),e}}function UI(e,t,n){if("number"===typeof e)return Gx(e,t);if(e.length!==t)throw new Bx("The ".concat(n," argument must be an integer or tuple of ").concat(t," integers.")+" Received: ".concat(e.length," elements."));for(let r=0;r<t;++r){const o=e[r];if((a=o)!==parseInt(a.toString(),10))throw new Bx("The ".concat(n," argument must be an integer or tuple of ").concat(t)+" integers. Received: ".concat(JSON.stringify(e)," including a")+" non-integer number ".concat(o))}return e;var a}function GI(e,t,n,a){if(null==e)return e;let r;return r="same"===n?e:e-(t+(t-1)*((arguments.length>4&&void 0!==arguments[4]?arguments[4]:1)-1))+1,Math.floor((r+a-1)/a)}function HI(e,t,n,a){if(null==e)return null;if("valid"===a)e=e*t+_v([n-t,0]);else{if("same"!==a)throw new Bx("Unsupport padding mode: ".concat(a,"."));e*=t}return e}function jI(e,t){return Lu((()=>(yv(t),"channelsFirst"===t?Lf(e,[0,2,3,1]):e)))}function KI(e,t){return Lu((()=>(yv(t),"channelsFirst"===t?Lf(e,[0,2,3,4,1]):e)))}function qI(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1,r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"valid",o=arguments.length>5?arguments[5]:void 0,s=arguments.length>6&&void 0!==arguments[6]?arguments[6]:1;return Lu((()=>{if(null==o&&(o="channelsLast"),yv(o),3!==e.shape.length)throw new Bx("The input of a conv1dWithBias operation should be 3, but is "+"".concat(e.shape.length," instead."));if(3!==t.shape.length)throw new Bx("The kernel for a conv1dWithBias operation should be 3, but is "+"".concat(t.shape.length," instead"));if(null!=n&&1!==n.shape.length)throw new Bx("The bias for a conv1dWithBias operation should be 1, but is "+"".concat(t.shape.length," instead"));if("channelsFirst"===o&&(e=Lf(e,[0,2,1])),"causal"===r)throw new Wx("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");let i=dp(e,t,a,"same"===r?"same":"valid","NWC",s);return null!=n&&(i=qv(i,n)),i}))}function XI(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:[1,1],r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"valid",o=arguments.length>5?arguments[5]:void 0,s=arguments.length>6?arguments[6]:void 0,i=arguments.length>7&&void 0!==arguments[7]?arguments[7]:null;return Lu((()=>{if(null==o&&(o="channelsLast"),yv(o),3!==e.rank&&4!==e.rank)throw new Bx("conv2dWithBiasActivation expects input to be of rank 3 or 4, "+"but received ".concat(e.rank,"."));if(3!==t.rank&&4!==t.rank)throw new Bx("conv2dWithBiasActivation expects kernel to be of rank 3 or 4, "+"but received ".concat(e.rank,"."));let c=jI(e,o);if("causal"===r)throw new Wx("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");return c=Yf({x:c,filter:t,strides:a,pad:"same"===r?"same":"valid",dilations:s,dataFormat:"NHWC",bias:n,activation:i}),"channelsFirst"===o&&(c=Lf(c,[0,3,1,2])),c}))}function YI(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:[1,1,1],r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"valid",o=arguments.length>5?arguments[5]:void 0,s=arguments.length>6?arguments[6]:void 0;return Lu((()=>{if(null==o&&(o="channelsLast"),yv(o),4!==e.rank&&5!==e.rank)throw new Bx("conv3dWithBias expects input to be of rank 4 or 5, but received "+"".concat(e.rank,"."));if(4!==t.rank&&5!==t.rank)throw new Bx("conv3dWithBias expects kernel to be of rank 4 or 5, but received "+"".concat(e.rank,"."));let i=KI(e,o);if("causal"===r)throw new Wx("The support for CAUSAL padding mode in conv3dWithBias is not implemented yet.");return i=fp(i,t,a,"same"===r?"same":"valid","NDHWC",s),null!=n&&(i=qv(i,n)),"channelsFirst"===o&&(i=Lf(i,[0,4,1,2,3])),i}))}VI.className="Softmax",Vd(VI);class QI extends Fw{constructor(e,t){if(super(t),this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",QI.verifyArgs(t),this.rank=e,ov(this.rank,"rank"),1!==this.rank&&2!==this.rank&&3!==this.rank)throw new Wx("Convolution layer for rank other than 1, 2, or 3 (".concat(this.rank,") is ")+"not implemented yet.");if(this.kernelSize=UI(t.kernelSize,e,"kernelSize"),this.strides=UI(null==t.strides?1:t.strides,e,"strides"),this.padding=null==t.padding?"valid":t.padding,xv(this.padding),this.dataFormat=null==t.dataFormat?"channelsLast":t.dataFormat,yv(this.dataFormat),this.activation=EI(t.activation),this.useBias=null==t.useBias||t.useBias,this.biasInitializer=bw(t.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.biasConstraint=Jw(t.biasConstraint),this.biasRegularizer=MI(t.biasRegularizer),this.activityRegularizer=MI(t.activityRegularizer),this.dilationRate=UI(null==t.dilationRate?1:t.dilationRate,e,"dilationRate"),1===this.rank&&Array.isArray(this.dilationRate)&&1!==this.dilationRate.length)throw new Bx("dilationRate must be a number or an array of a single number for 1D convolution, but received "+"".concat(JSON.stringify(this.dilationRate)));if(2===this.rank){if("number"===typeof this.dilationRate)this.dilationRate=[this.dilationRate,this.dilationRate];else if(2!==this.dilationRate.length)throw new Bx("dilationRate must be a number or array of two numbers for 2D "+"convolution, but received ".concat(JSON.stringify(this.dilationRate)))}else if(3===this.rank)if("number"===typeof this.dilationRate)this.dilationRate=[this.dilationRate,this.dilationRate,this.dilationRate];else if(3!==this.dilationRate.length)throw new Bx("dilationRate must be a number or array of three numbers for 3D "+"convolution, but received ".concat(JSON.stringify(this.dilationRate)))}static verifyArgs(e){if(Hx("kernelSize"in e,"required key 'kernelSize' not in config"),"number"!==typeof e.kernelSize&&!rv(e.kernelSize,"number",1,3))throw new Bx("BaseConv expects config.kernelSize to be number or number[] with "+"length 1, 2, or 3, but received ".concat(JSON.stringify(e.kernelSize),"."))}getConfig(){const e={kernelSize:this.kernelSize,strides:this.strides,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,activation:CI(this.activation),useBias:this.useBias,biasInitializer:gw(this.biasInitializer),biasRegularizer:OI(this.biasRegularizer),activityRegularizer:OI(this.activityRegularizer),biasConstraint:Yw(this.biasConstraint)},t=super.getConfig();return Object.assign(e,t),e}}class JI extends QI{constructor(e,t){super(e,t),this.kernel=null,JI.verifyArgs(t),this.filters=t.filters,ov(this.filters,"filters"),this.kernelInitializer=bw(t.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.kernelConstraint=Jw(t.kernelConstraint),this.kernelRegularizer=MI(t.kernelRegularizer)}build(e){e=ww(e);const t="channelsFirst"===this.dataFormat?1:e.length-1;if(null==e[t])throw new Bx("The channel dimension of the input should be defined. "+"Found ".concat(e[t]));const n=e[t],a=this.kernelSize.concat([n,this.filters]);this.kernel=this.addWeight("kernel",a,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[{ndim:this.rank+2,axes:{[t]:n}}],this.built=!0}call(e,t){return Lu((()=>{let t;e=vw(e);const n=null==this.bias?null:this.bias.read(),a=iv(this.activation.getClassName());if(null!=a&&2===this.rank)t=XI(e,this.kernel.read(),n,this.strides,this.padding,this.dataFormat,this.dilationRate,a);else{if(1===this.rank)t=qI(e,this.kernel.read(),n,this.strides[0],this.padding,this.dataFormat,this.dilationRate[0]);else if(2===this.rank)t=XI(e,this.kernel.read(),n,this.strides,this.padding,this.dataFormat,this.dilationRate);else{if(3!==this.rank)throw new Wx("convolutions greater than 3D are not implemented yet.");t=YI(e,this.kernel.read(),n,this.strides,this.padding,this.dataFormat,this.dilationRate)}null!=this.activation&&(t=this.activation.apply(t))}return t}))}computeOutputShape(e){e=ww(e);const t=[],n="channelsLast"===this.dataFormat?e.slice(1,e.length-1):e.slice(2);for(let r=0;r<n.length;++r){const e=GI(n[r],this.kernelSize[r],this.padding,this.strides[r],"number"===typeof this.dilationRate?this.dilationRate:this.dilationRate[r]);t.push(e)}let a=[e[0]];return"channelsLast"===this.dataFormat?(a=a.concat(t),a.push(this.filters)):(a.push(this.filters),a=a.concat(t)),a}getConfig(){const e={filters:this.filters,kernelInitializer:gw(this.kernelInitializer),kernelRegularizer:OI(this.kernelRegularizer),kernelConstraint:Yw(this.kernelConstraint)},t=super.getConfig();return Object.assign(e,t),e}static verifyArgs(e){if(!("filters"in e)||"number"!==typeof e.filters||e.filters<1)throw new Bx("Convolution layer expected config.filters to be a 'number' > 0 "+"but got ".concat(JSON.stringify(e.filters)))}}class ZI extends JI{constructor(e){super(2,e),ZI.verifyArgs(e)}getConfig(){const e=super.getConfig();return delete e.rank,e}static verifyArgs(e){if("number"!==typeof e.kernelSize&&!rv(e.kernelSize,"number",1,2))throw new Bx("Conv2D expects config.kernelSize to be number or number[] with "+"length 1 or 2, but received ".concat(JSON.stringify(e.kernelSize),"."))}}ZI.className="Conv2D",Vd(ZI);class $I extends JI{constructor(e){super(3,e),$I.verifyArgs(e)}getConfig(){const e=super.getConfig();return delete e.rank,e}static verifyArgs(e){if("number"!==typeof e.kernelSize&&(!Array.isArray(e.kernelSize)||1!==e.kernelSize.length&&3!==e.kernelSize.length))throw new Bx("Conv3D expects config.kernelSize to be number or"+" [number, number, number], but received ".concat(JSON.stringify(e.kernelSize),"."))}}$I.className="Conv3D",Vd($I);class eS extends ZI{constructor(e){if(super(e),this.inputSpec=[new Tw({ndim:4})],"same"!==this.padding&&"valid"!==this.padding)throw new Bx("Conv2DTranspose currently supports only padding modes 'same' "+"and 'valid', but received padding mode ".concat(this.padding))}build(e){if(4!==(e=ww(e)).length)throw new Bx("Input should have rank 4; Received input shape: "+JSON.stringify(e));const t="channelsFirst"===this.dataFormat?1:e.length-1;if(null==e[t])throw new Bx("The channel dimension of the inputs should be defined. Found `None`.");const n=e[t],a=this.kernelSize.concat([this.filters,n]);this.kernel=this.addWeight("kernel",a,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new Tw({ndim:4,axes:{[t]:n}})],this.built=!0}call(e,t){return Lu((()=>{let t=vw(e);if(4!==t.shape.length)throw new Bx("Conv2DTranspose.call() expects input tensor to be rank-4, but "+"received a tensor of rank-".concat(t.shape.length));const n=t.shape,a=n[0];let r,o;"channelsFirst"===this.dataFormat?(r=2,o=3):(r=1,o=2);const s=n[r],i=n[o],c=this.kernelSize[0],l=this.kernelSize[1],u=this.strides[0],d=this.strides[1],h=[a,HI(s,u,c,this.padding),HI(i,d,l,this.padding),this.filters];"channelsLast"!==this.dataFormat&&(t=Lf(t,[0,2,3,1]));let p=pp(t,this.kernel.read(),h,this.strides,this.padding);return"channelsLast"!==this.dataFormat&&(p=Lf(p,[0,3,1,2])),null!=this.bias&&(p=qv(p,this.bias.read(),this.dataFormat)),null!=this.activation&&(p=this.activation.apply(p)),p}))}computeOutputShape(e){const t=(e=ww(e)).slice();let n,a,r;"channelsFirst"===this.dataFormat?(n=1,a=2,r=3):(n=3,a=1,r=2);const o=this.kernelSize[0],s=this.kernelSize[1],i=this.strides[0],c=this.strides[1];return t[n]=this.filters,t[a]=HI(t[a],i,o,this.padding),t[r]=HI(t[r],c,s,this.padding),t}getConfig(){const e=super.getConfig();return delete e.dilationRate,e}}eS.className="Conv2DTranspose",Vd(eS);class tS extends $I{constructor(e){if(super(e),this.inputSpec=[new Tw({ndim:5})],"same"!==this.padding&&"valid"!==this.padding)throw new Bx("Conv3DTranspose currently supports only padding modes 'same' "+"and 'valid', but received padding mode ".concat(this.padding))}build(e){if(5!==(e=ww(e)).length)throw new Bx("Input should have rank 5; Received input shape: "+JSON.stringify(e));const t="channelsFirst"===this.dataFormat?1:e.length-1;if(null==e[t])throw new Bx("The channel dimension of the inputs should be defined. Found `None`.");const n=e[t],a=this.kernelSize.concat([this.filters,n]);this.kernel=this.addWeight("kernel",a,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new Tw({ndim:5,axes:{[t]:n}})],this.built=!0}call(e,t){return Lu((()=>{let t=vw(e);if(5!==t.shape.length)throw new Bx("Conv3DTranspose.call() expects input tensor to be rank-4, but "+"received a tensor of rank-".concat(t.shape.length));const n=t.shape,a=n[0];let r,o,s;"channelsFirst"===this.dataFormat?(s=2,r=3,o=4):(s=1,r=2,o=3);const i=n[s],c=n[r],l=n[o],u=this.kernelSize[0],d=this.kernelSize[1],h=this.kernelSize[2],p=this.strides[0],f=this.strides[1],m=this.strides[2],g=[a,HI(i,p,u,this.padding),HI(c,f,d,this.padding),HI(l,m,h,this.padding),this.filters];"channelsLast"!==this.dataFormat&&(t=Lf(t,[0,2,3,4,1]));let b=gp(t,this.kernel.read(),g,this.strides,this.padding);return"channelsLast"!==this.dataFormat&&(b=Lf(b,[0,4,1,2,3])),null!==this.bias&&(b=qv(b,this.bias.read(),this.dataFormat)),null!==this.activation&&(b=this.activation.apply(b)),b}))}computeOutputShape(e){const t=(e=ww(e)).slice();let n,a,r,o;"channelsFirst"===this.dataFormat?(n=1,a=2,r=3,o=4):(n=4,a=1,r=2,o=3);const s=this.kernelSize[0],i=this.kernelSize[1],c=this.kernelSize[2],l=this.strides[0],u=this.strides[1],d=this.strides[2];return t[n]=this.filters,t[a]=HI(t[a],l,s,this.padding),t[r]=HI(t[r],u,i,this.padding),t[o]=HI(t[o],d,c,this.padding),t}getConfig(){const e=super.getConfig();return delete e.dilationRate,e}}tS.className="Conv3DTranspose",Vd(tS);class nS extends JI{constructor(e,t){if(super(e,t),this.DEFAULT_DEPTHWISE_INITIALIZER="glorotUniform",this.DEFAULT_POINTWISE_INITIALIZER="glorotUniform",this.depthwiseKernel=null,this.pointwiseKernel=null,null==t.filters)throw new Bx("The `filters` configuration field is required by SeparableConv, but is unspecified.");if(null!=t.kernelInitializer||null!=t.kernelRegularizer||null!=t.kernelConstraint)throw new Bx("Fields kernelInitializer, kernelRegularizer and kernelConstraint are invalid for SeparableConv2D. Use depthwiseInitializer, depthwiseRegularizer, depthwiseConstraint, pointwiseInitializer, pointwiseRegularizer and pointwiseConstraint instead.");if(null!=t.padding&&"same"!==t.padding&&"valid"!==t.padding)throw new Bx("SeparableConv".concat(this.rank,"D supports only padding modes: ")+"'same' and 'valid', but received ".concat(JSON.stringify(t.padding)));this.depthMultiplier=null==t.depthMultiplier?1:t.depthMultiplier,this.depthwiseInitializer=bw(t.depthwiseInitializer||this.DEFAULT_DEPTHWISE_INITIALIZER),this.depthwiseRegularizer=MI(t.depthwiseRegularizer),this.depthwiseConstraint=Jw(t.depthwiseConstraint),this.pointwiseInitializer=bw(t.depthwiseInitializer||this.DEFAULT_POINTWISE_INITIALIZER),this.pointwiseRegularizer=MI(t.pointwiseRegularizer),this.pointwiseConstraint=Jw(t.pointwiseConstraint)}build(e){if((e=ww(e)).length<this.rank+2)throw new Bx("Inputs to SeparableConv".concat(this.rank,"D should have rank ")+"".concat(this.rank+2,", but received input shape: ")+"".concat(JSON.stringify(e)));const t="channelsFirst"===this.dataFormat?1:e.length-1;if(null==e[t]||e[t]<0)throw new Bx("The channel dimension of the inputs should be defined, "+"but found ".concat(JSON.stringify(e[t])));const n=e[t],a=this.kernelSize.concat([n,this.depthMultiplier]),r=[];for(let s=0;s<this.rank;++s)r.push(1);r.push(n*this.depthMultiplier,this.filters);const o=!0;this.depthwiseKernel=this.addWeight("depthwise_kernel",a,"float32",this.depthwiseInitializer,this.depthwiseRegularizer,o,this.depthwiseConstraint),this.pointwiseKernel=this.addWeight("pointwise_kernel",r,"float32",this.pointwiseInitializer,this.pointwiseRegularizer,o,this.pointwiseConstraint),this.useBias?this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,o,this.biasConstraint):this.bias=null,this.inputSpec=[new Tw({ndim:this.rank+2,axes:{[t]:n}})],this.built=!0}call(e,t){return Lu((()=>{let t;if(e=vw(e),1===this.rank)throw new Wx("1D separable convolution is not implemented yet.");return 2===this.rank&&("channelsFirst"===this.dataFormat&&(e=Lf(e,[0,2,3,1])),t=gf(e,this.depthwiseKernel.read(),this.pointwiseKernel.read(),this.strides,this.padding,this.dilationRate,"NHWC")),this.useBias&&(t=qv(t,this.bias.read(),this.dataFormat)),null!=this.activation&&(t=this.activation.apply(t)),"channelsFirst"===this.dataFormat&&(t=Lf(t,[0,3,1,2])),t}))}getConfig(){const e=super.getConfig();return delete e.rank,delete e.kernelInitializer,delete e.kernelRegularizer,delete e.kernelConstraint,e.depthwiseInitializer=gw(this.depthwiseInitializer),e.pointwiseInitializer=gw(this.pointwiseInitializer),e.depthwiseRegularizer=OI(this.depthwiseRegularizer),e.pointwiseRegularizer=OI(this.pointwiseRegularizer),e.depthwiseConstraint=Yw(this.depthwiseConstraint),e.pointwiseConstraint=Yw(this.pointwiseConstraint),e}}nS.className="SeparableConv";class aS extends nS{constructor(e){super(2,e)}}aS.className="SeparableConv2D",Vd(aS);class rS extends JI{constructor(e){super(1,e),rS.verifyArgs(e),this.inputSpec=[{ndim:3}]}getConfig(){const e=super.getConfig();return delete e.rank,delete e.dataFormat,e}static verifyArgs(e){if("number"!==typeof e.kernelSize&&!rv(e.kernelSize,"number",1,1))throw new Bx("Conv1D expects config.kernelSize to be number or number[] with "+"length 1, but received ".concat(JSON.stringify(e.kernelSize),"."))}}rS.className="Conv1D",Vd(rS);class oS extends Fw{constructor(e){super(e),"number"===typeof e.cropping?this.cropping=[[e.cropping,e.cropping],[e.cropping,e.cropping]]:"number"===typeof e.cropping[0]?this.cropping=[[e.cropping[0],e.cropping[0]],[e.cropping[1],e.cropping[1]]]:this.cropping=e.cropping,this.dataFormat=void 0===e.dataFormat?"channelsLast":e.dataFormat,this.inputSpec=[{ndim:4}]}computeOutputShape(e){return"channelsFirst"===this.dataFormat?[e[0],e[1],e[2]-this.cropping[0][0]-this.cropping[0][1],e[3]-this.cropping[1][0]-this.cropping[1][1]]:[e[0],e[1]-this.cropping[0][0]-this.cropping[0][1],e[2]-this.cropping[1][0]-this.cropping[1][1],e[3]]}call(e,t){return Lu((()=>{if(e=vw(e),"channelsLast"===this.dataFormat){const t=zv(e,this.cropping[0][0],e.shape[1]-this.cropping[0][0]-this.cropping[0][1],2);return zv(t,this.cropping[1][0],e.shape[2]-this.cropping[1][1]-this.cropping[1][0],3)}{const t=zv(e,this.cropping[0][0],e.shape[2]-this.cropping[0][0]-this.cropping[0][1],3);return zv(t,this.cropping[1][0],e.shape[3]-this.cropping[1][1]-this.cropping[1][0],4)}}))}getConfig(){const e={cropping:this.cropping,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}}oS.className="Cropping2D",Vd(oS);class sS extends Fw{constructor(e){var t;super(e),this.DEFAULT_SIZE=[2,2],this.inputSpec=[{ndim:4}],this.size=null==e.size?this.DEFAULT_SIZE:e.size,this.dataFormat=null==e.dataFormat?"channelsLast":e.dataFormat,yv(this.dataFormat),this.interpolation=null==e.interpolation?"nearest":e.interpolation,t=this.interpolation,av(pv,"InterpolationFormat",t)}computeOutputShape(e){if("channelsFirst"===this.dataFormat){const t=null==e[2]?null:this.size[0]*e[2],n=null==e[3]?null:this.size[1]*e[3];return[e[0],e[1],t,n]}{const t=null==e[1]?null:this.size[0]*e[1],n=null==e[2]?null:this.size[1]*e[2];return[e[0],t,n,e[3]]}}call(e,t){return Lu((()=>{let t=vw(e);const n=t.shape;if("channelsFirst"===this.dataFormat){t=Lf(t,[0,2,3,1]);const e=this.size[0]*n[2],a=this.size[1]*n[3],r="nearest"===this.interpolation?Pm.resizeNearestNeighbor(t,[e,a]):Pm.resizeBilinear(t,[e,a]);return Lf(r,[0,3,1,2])}{const e=this.size[0]*n[1],a=this.size[1]*n[2];return"nearest"===this.interpolation?Pm.resizeNearestNeighbor(t,[e,a]):Pm.resizeBilinear(t,[e,a])}}))}getConfig(){const e={size:this.size,dataFormat:this.dataFormat,interpolation:this.interpolation},t=super.getConfig();return Object.assign(e,t),e}}sS.className="UpSampling2D",Vd(sS);class iS extends QI{constructor(e){super(2,e),this.depthwiseKernel=null,this.depthMultiplier=null==e.depthMultiplier?1:e.depthMultiplier,this.depthwiseInitializer=bw(e.depthwiseInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.depthwiseConstraint=Jw(e.depthwiseConstraint),this.depthwiseRegularizer=MI(e.depthwiseRegularizer)}build(e){if((e=ww(e)).length<4)throw new Bx("Inputs to DepthwiseConv2D should have rank 4. "+"Received input shape: ".concat(JSON.stringify(e),"."));const t="channelsFirst"===this.dataFormat?1:3;if(null==e[t]||e[t]<0)throw new Bx("The channel dimension of the inputs to DepthwiseConv2D should "+"be defined, but is not (".concat(e[t],")."));const n=e[t],a=[this.kernelSize[0],this.kernelSize[1],n,this.depthMultiplier];this.depthwiseKernel=this.addWeight("depthwise_kernel",a,null,this.depthwiseInitializer,this.depthwiseRegularizer,!0,this.depthwiseConstraint),this.useBias?this.bias=this.addWeight("bias",[n*this.depthMultiplier],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(e,t){return Lu((()=>{let t=function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:[1,1],a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"valid",r=arguments.length>4?arguments[4]:void 0,o=arguments.length>5?arguments[5]:void 0;return Lu((()=>{null==r&&(r="channelsLast"),yv(r);let s=jI(e,r);if(4!==e.rank)throw new Bx("Input for depthwiseConv2d is required to be 4-D, but is instead "+"".concat(e.rank,"-D"));if(4!==t.rank)throw new Bx("depthwiseKernel is required to be 4-D, but is instead "+"".concat(t.rank,"-D"));return s=yp(s,t,n,"same"===a?"same":"valid","NHWC",o),"channelsFirst"===r&&(s=Lf(s,[0,3,1,2])),s}))}(e=vw(e),this.depthwiseKernel.read(),this.strides,this.padding,this.dataFormat,null);return this.useBias&&(t=qv(t,this.bias.read(),this.dataFormat)),null!=this.activation&&(t=this.activation.apply(t)),t}))}computeOutputShape(e){e=ww(e);const t="channelsFirst"===this.dataFormat?e[2]:e[1],n="channelsFirst"===this.dataFormat?e[3]:e[2],a="channelsFirst"===this.dataFormat?e[1]*this.depthMultiplier:e[3]*this.depthMultiplier,r=GI(t,this.kernelSize[0],this.padding,this.strides[0]),o=GI(n,this.kernelSize[1],this.padding,this.strides[1]);return"channelsFirst"===this.dataFormat?[e[0],a,r,o]:[e[0],r,o,a]}getConfig(){const e=super.getConfig();return e.depthMultiplier=this.depthMultiplier,e.depthwiseInitializer=gw(this.depthwiseInitializer),e.depthwiseRegularizer=OI(this.depthwiseRegularizer),e.depthwiseConstraint=Yw(this.depthwiseRegularizer),e}}function cS(e,t,n,a){if(Array.isArray(e)){if(null!=t||null!=n)throw new Bx("When inputs is an array, neither initialState or constants should be provided");null!=a&&(n=e.slice(e.length-a,e.length),e=e.slice(0,e.length-a)),e.length>1&&(t=e.slice(1,e.length)),e=e[0]}function r(e){return null==e||Array.isArray(e)?e:[e]}return{inputs:e,initialState:t=r(t),constants:n=r(n)}}function lS(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]&&arguments[3],r=arguments.length>4?arguments[4]:void 0,o=arguments.length>5?arguments[5]:void 0,s=arguments.length>6&&void 0!==arguments[6]&&arguments[6],i=arguments.length>7&&void 0!==arguments[7]&&arguments[7];return Lu((()=>{const c=t.shape.length;if(c<3)throw new Bx("Input should be at least 3D, but is ".concat(c,"D."));const l=[1,0].concat(Av(2,c));if(t=Lf(t,l),null!=o)throw new Wx("The rnn() functoin of the deeplearn.js backend does not support constants yet.");s&&console.warn("Backend rnn(): the unroll = true option is not applicable to the imperative deeplearn.js backend."),null!=r&&(r=Cd(Cd(r,"bool"),"float32"),r.rank===c-1&&(r=kp(r,-1)),r=Lf(r,l)),a&&(t=ff(t,0),null!=r&&(r=ff(r,0)));const u=[];let d,h=n;const p=t.shape[0],f=Ff(t);let m,g;null!=r&&(m=Ff(r));for(let t=0;t<p;++t){const n=f[t],a=Lu((()=>e(n,h)));if(null==r)d=a[0],h=a[1];else{const e=Lu((()=>{const e=m[t],n=qd(af(e),e),r=Ed(Ad(a[0],e),Ad(h[0],n)),o=h.map(((t,r)=>Ed(Ad(a[1][r],e),Ad(t,n))));return{output:r,newStates:o}}));d=e.output,h=e.newStates}i&&u.push(d)}if(i){g=Tf(u,1)}return[d,g,h]}))}iS.className="DepthwiseConv2D",Vd(iS);class uS extends Fw{constructor(e){let t;if(super(e),null==e.cell)throw new Bx("cell property is missing for the constructor of RNN.");if(t=Array.isArray(e.cell)?new yS({cells:e.cell}):e.cell,null==t.stateSize)throw new Bx("The RNN cell should have an attribute `stateSize` (tuple of integers, one integer per RNN state).");this.cell=t,this.returnSequences=null!=e.returnSequences&&e.returnSequences,this.returnState=null!=e.returnState&&e.returnState,this.goBackwards=null!=e.goBackwards&&e.goBackwards,this._stateful=null!=e.stateful&&e.stateful,this.unroll=null!=e.unroll&&e.unroll,this.supportsMasking=!0,this.inputSpec=[new Tw({ndim:3})],this.stateSpec=null,this.states_=null,this.numConstants=null,this.keptStates=[]}getStates(){if(null==this.states_){return Av(0,Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1).map((e=>null))}return this.states_}setStates(e){this.states_=e}computeOutputShape(e){yw(e)&&(e=e[0]);let t=this.cell.stateSize;Array.isArray(t)||(t=[t]);const n=t[0];let a;if(a=this.returnSequences?[e[0],e[1],n]:[e[0],n],this.returnState){const n=[];for(const a of t)n.push([e[0],a]);return[a].concat(n)}return a}computeMask(e,t){return Lu((()=>{Array.isArray(t)&&(t=t[0]);const e=this.returnSequences?t:null;if(this.returnState){const t=this.states.map((e=>null));return[e].concat(t)}return e}))}get states(){if(null==this.states_){const e=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1,t=[];for(let n=0;n<e;++n)t.push(null);return t}return this.states_}set states(e){this.states_=e}build(e){if(null!=this.numConstants)throw new Wx("Constants support is not implemented in RNN yet.");yw(e)&&(e=e[0]);const t=this.stateful?e[0]:null,n=e.slice(2);this.inputSpec[0]=new Tw({shape:[t,null,...n]});const a=[e[0]].concat(e.slice(2));let r;if(this.cell.build(a),r=Array.isArray(this.cell.stateSize)?this.cell.stateSize:[this.cell.stateSize],null!=this.stateSpec){if(!uo(this.stateSpec.map((e=>e.shape[e.shape.length-1])),r))throw new Bx("An initialState was passed that is not compatible with "+"cell.stateSize. Received stateSpec=".concat(this.stateSpec,"; ")+"However cell.stateSize is ".concat(this.cell.stateSize))}else this.stateSpec=r.map((e=>new Tw({shape:[null,e]})));this.stateful&&this.resetStates()}resetStates(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];Lu((()=>{if(!this.stateful)throw new Px("Cannot call resetStates() on an RNN Layer that is not stateful.");const n=this.inputSpec[0].shape[0];if(null==n)throw new Bx("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(null==this.states_)Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map((e=>tf([n,e]))):this.states_=[tf([n,this.cell.stateSize])];else if(null==e)Pu(this.states_),null!=this.keptStates&&(Pu(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map((e=>tf([n,e]))):this.states_[0]=tf([n,this.cell.stateSize]);else{if(Array.isArray(e)||(e=[e]),e.length!==this.states_.length)throw new Bx("Layer ".concat(this.name," expects ").concat(this.states_.length," state(s), ")+"but it received ".concat(e.length," state value(s). Input ")+"received: ".concat(e));!0===t?this.keptStates.push(this.states_.slice()):Pu(this.states_);for(let t=0;t<this.states_.length;++t){const a=e[t],r=Array.isArray(this.cell.stateSize)?this.cell.stateSize[t]:this.cell.stateSize,o=[n,r];if(!uo(a.shape,o))throw new Bx("State ".concat(t," is incompatible with layer ").concat(this.name,": ")+"expected shape=".concat(o,", received shape=").concat(a.shape));this.states_[t]=a}}this.states_=this.states_.map((e=>zu(e.clone())))}))}apply(e,t){let n=null==t?null:t.initialState,a=null==t?null:t.constants;null==t&&(t={});const r=cS(e,n,a,this.numConstants);e=r.inputs,n=r.initialState,a=r.constants;let o=[],s=[];if(null!=n){t.initialState=n,o=o.concat(n),this.stateSpec=[];for(const e of n)this.stateSpec.push(new Tw({shape:e.shape}));s=s.concat(this.stateSpec)}null!=a&&(t.constants=a,o=o.concat(a),this.numConstants=a.length);if(o[0]instanceof Ew){const n=[e].concat(o),a=this.inputSpec.concat(s),r=this.inputSpec;this.inputSpec=a;const i=super.apply(n,t);return this.inputSpec=r,i}return super.apply(e,t)}call(e,t){return Lu((()=>{const n=null==t?null:t.mask,a=null==t?null:t.training;let r=null==t?null:t.initialState;e=vw(e),null==r&&(r=this.stateful?this.states_:this.getInitialState(e));const o=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1;if(r.length!==o)throw new Bx("RNN Layer has ".concat(o," state(s) but was passed ")+"".concat(r.length," initial state(s)."));this.unroll&&console.warn("Ignoring unroll = true for RNN layer, due to imperative backend.");const s={training:a},i=lS(((e,t)=>{const n=this.cell.call([e].concat(t),s);return[n[0],n.slice(1)]}),e,r,this.goBackwards,n,null,this.unroll,this.returnSequences),c=i[0],l=i[1],u=i[2];this.stateful&&this.resetStates(u,a);const d=this.returnSequences?l:c;return this.returnState?[d].concat(u):d}))}getInitialState(e){return Lu((()=>{let t=tf(e.shape);return t=Op(t,[1,2]),t=Mv(t),Array.isArray(this.cell.stateSize)?this.cell.stateSize.map((e=>e>1?Vv(t,[1,e]):t)):this.cell.stateSize>1?[Vv(t,[1,this.cell.stateSize])]:[t]}))}get trainableWeights(){return this.trainable?this.cell.trainableWeights:[]}get nonTrainableWeights(){return this.trainable?this.cell.nonTrainableWeights:this.cell.weights}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),null!=this.cell&&this.cell.setFastWeightInitDuringBuild(e)}getConfig(){const e=super.getConfig(),t={returnSequences:this.returnSequences,returnState:this.returnState,goBackwards:this.goBackwards,stateful:this.stateful,unroll:this.unroll};null!=this.numConstants&&(t.numConstants=this.numConstants);const n=this.cell.getConfig();return this.getClassName()===uS.className&&(t.cell={className:this.cell.getClassName(),config:n}),Object.assign(Object.assign(Object.assign({},n),e),t)}static fromConfig(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};const a=lk(t.cell,n);return new e(Object.assign(t,{cell:a}))}}uS.className="RNN",Vd(uS);class dS extends Fw{}class hS extends dS{constructor(e){super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=e.units,ov(this.units,"units"),this.activation=EI(null==e.activation?this.DEFAULT_ACTIVATION:e.activation),this.useBias=null==e.useBias||e.useBias,this.kernelInitializer=bw(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=bw(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=bw(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=MI(e.kernelRegularizer),this.recurrentRegularizer=MI(e.recurrentRegularizer),this.biasRegularizer=MI(e.biasRegularizer),this.kernelConstraint=Jw(e.kernelConstraint),this.recurrentConstraint=Jw(e.recurrentConstraint),this.biasConstraint=Jw(e.biasConstraint),this.dropout=Rv([1,_v([0,null==e.dropout?0:e.dropout])]),this.recurrentDropout=Rv([1,_v([0,null==e.recurrentDropout?0:e.recurrentDropout])]),this.dropoutFunc=e.dropoutFunc,this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){e=ww(e),this.kernel=this.addWeight("kernel",[e[e.length-1],this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias?this.bias=this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(e,t){return Lu((()=>{if(2!==e.length)throw new Bx("SimpleRNNCell expects 2 input Tensors, got ".concat(e.length,"."));let n=e[1];e=e[0];const a=null!=t.training&&t.training;let r;0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=xS({ones:()=>af(e),rate:this.dropout,training:a,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=xS({ones:()=>af(n),rate:this.recurrentDropout,training:a,dropoutFunc:this.dropoutFunc}));const o=this.dropoutMask,s=this.recurrentDropoutMask;r=Gv(null!=o?Ad(e,o):e,this.kernel.read()),null!=this.bias&&(r=qv(r,this.bias.read())),null!=s&&(n=Ad(n,s));let i=Ed(r,Gv(n,this.recurrentKernel.read()));return null!=this.activation&&(i=this.activation.apply(i)),[i,i]}))}getConfig(){const e=super.getConfig(),t={units:this.units,activation:CI(this.activation),useBias:this.useBias,kernelInitializer:gw(this.kernelInitializer),recurrentInitializer:gw(this.recurrentInitializer),biasInitializer:gw(this.biasInitializer),kernelRegularizer:OI(this.kernelRegularizer),recurrentRegularizer:OI(this.recurrentRegularizer),biasRegularizer:OI(this.biasRegularizer),activityRegularizer:OI(this.activityRegularizer),kernelConstraint:Yw(this.kernelConstraint),recurrentConstraint:Yw(this.recurrentConstraint),biasConstraint:Yw(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout};return Object.assign(Object.assign({},e),t)}}hS.className="SimpleRNNCell",Vd(hS);class pS extends uS{constructor(e){e.cell=new hS(e),super(e)}call(e,t){return Lu((()=>{null!=this.cell.dropoutMask&&(Pu(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(Pu(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);const n=null==t?null:t.mask,a=null==t?null:t.training,r=null==t?null:t.initialState;return super.call(e,{mask:n,training:a,initialState:r})}))}static fromConfig(e,t){return new e(t)}}pS.className="SimpleRNN",Vd(pS);class fS extends dS{constructor(e){if(super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",e.resetAfter)throw new Bx("GRUCell does not support reset_after parameter set to true.");this.units=e.units,ov(this.units,"units"),this.activation=EI(void 0===e.activation?this.DEFAULT_ACTIVATION:e.activation),this.recurrentActivation=EI(void 0===e.recurrentActivation?this.DEFAULT_RECURRENT_ACTIVATION:e.recurrentActivation),this.useBias=null==e.useBias||e.useBias,this.kernelInitializer=bw(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=bw(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=bw(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=MI(e.kernelRegularizer),this.recurrentRegularizer=MI(e.recurrentRegularizer),this.biasRegularizer=MI(e.biasRegularizer),this.kernelConstraint=Jw(e.kernelConstraint),this.recurrentConstraint=Jw(e.recurrentConstraint),this.biasConstraint=Jw(e.biasConstraint),this.dropout=Rv([1,_v([0,null==e.dropout?0:e.dropout])]),this.recurrentDropout=Rv([1,_v([0,null==e.recurrentDropout?0:e.recurrentDropout])]),this.dropoutFunc=e.dropoutFunc,this.implementation=e.implementation,this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){const t=(e=ww(e))[e.length-1];this.kernel=this.addWeight("kernel",[t,3*this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,3*this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias?this.bias=this.addWeight("bias",[3*this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(e,t){return Lu((()=>{if(2!==e.length)throw new Bx("GRUCell expects 2 input Tensors (inputs, h, c), got "+"".concat(e.length,"."));const n=null!=t.training&&t.training;let a=e[1];e=e[0],0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=xS({ones:()=>af(e),rate:this.dropout,training:n,count:3,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=xS({ones:()=>af(a),rate:this.recurrentDropout,training:n,count:3,dropoutFunc:this.dropoutFunc}));const r=this.dropoutMask,o=this.recurrentDropoutMask;let s,i,c;0<this.dropout&&this.dropout<1&&(e=Ad(e,r[0]));let l=Gv(e,this.kernel.read());this.useBias&&(l=qv(l,this.bias.read())),0<this.recurrentDropout&&this.recurrentDropout<1&&(a=Ad(a,o[0]));const u=this.recurrentKernel.read(),[d,h]=Nf(u,[2*this.units,this.units],u.rank-1),p=Gv(a,d),[f,m,g]=Nf(l,3,l.rank-1),[b,y]=Nf(p,2,p.rank-1);s=this.recurrentActivation.apply(Ed(f,b)),i=this.recurrentActivation.apply(Ed(m,y));const x=Gv(Ad(i,a),h);c=this.activation.apply(Ed(g,x));const v=Ed(Ad(s,a),Ad(Ed(1,Zp(s)),c));return[v,v]}))}getConfig(){const e=super.getConfig(),t={units:this.units,activation:CI(this.activation),recurrentActivation:CI(this.recurrentActivation),useBias:this.useBias,kernelInitializer:gw(this.kernelInitializer),recurrentInitializer:gw(this.recurrentInitializer),biasInitializer:gw(this.biasInitializer),kernelRegularizer:OI(this.kernelRegularizer),recurrentRegularizer:OI(this.recurrentRegularizer),biasRegularizer:OI(this.biasRegularizer),activityRegularizer:OI(this.activityRegularizer),kernelConstraint:Yw(this.kernelConstraint),recurrentConstraint:Yw(this.recurrentConstraint),biasConstraint:Yw(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation,resetAfter:!1};return Object.assign(Object.assign({},e),t)}}fS.className="GRUCell",Vd(fS);class mS extends uS{constructor(e){0===e.implementation&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),e.cell=new fS(e),super(e)}call(e,t){return Lu((()=>{null!=this.cell.dropoutMask&&(Pu(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(Pu(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);const n=null==t?null:t.mask,a=null==t?null:t.training,r=null==t?null:t.initialState;return super.call(e,{mask:n,training:a,initialState:r})}))}static fromConfig(e,t){return 0===t.implmentation&&(t.implementation=1),new e(t)}}mS.className="GRU",Vd(mS);class gS extends dS{constructor(e){super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=e.units,ov(this.units,"units"),this.activation=EI(void 0===e.activation?this.DEFAULT_ACTIVATION:e.activation),this.recurrentActivation=EI(void 0===e.recurrentActivation?this.DEFAULT_RECURRENT_ACTIVATION:e.recurrentActivation),this.useBias=null==e.useBias||e.useBias,this.kernelInitializer=bw(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=bw(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=bw(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.unitForgetBias=e.unitForgetBias,this.kernelRegularizer=MI(e.kernelRegularizer),this.recurrentRegularizer=MI(e.recurrentRegularizer),this.biasRegularizer=MI(e.biasRegularizer),this.kernelConstraint=Jw(e.kernelConstraint),this.recurrentConstraint=Jw(e.recurrentConstraint),this.biasConstraint=Jw(e.biasConstraint),this.dropout=Rv([1,_v([0,null==e.dropout?0:e.dropout])]),this.recurrentDropout=Rv([1,_v([0,null==e.recurrentDropout?0:e.recurrentDropout])]),this.dropoutFunc=e.dropoutFunc,this.implementation=e.implementation,this.stateSize=[this.units,this.units],this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){var t;const n=(e=ww(e))[e.length-1];let a;if(this.kernel=this.addWeight("kernel",[n,4*this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,4*this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias){if(this.unitForgetBias){const e=this.biasInitializer,n=this.units;a=new((t=class extends Zv{apply(t,a){const r=e.apply([n]),o=(new ew).apply([n]),s=e.apply([2*n]);return Wv(Wv(r,o),s)}}).className="CustomInit",t)}else a=this.biasInitializer;this.bias=this.addWeight("bias",[4*this.units],null,a,this.biasRegularizer,!0,this.biasConstraint)}else this.bias=null;this.built=!0}call(e,t){return Lu((()=>{const n=null!=t.training&&t.training;if(3!==e.length)throw new Bx("LSTMCell expects 3 input Tensors (inputs, h, c), got "+"".concat(e.length,"."));let a=e[1];const r=e[2];e=e[0],0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=xS({ones:()=>af(e),rate:this.dropout,training:n,count:4,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=xS({ones:()=>af(a),rate:this.recurrentDropout,training:n,count:4,dropoutFunc:this.dropoutFunc}));const o=this.dropoutMask,s=this.recurrentDropoutMask;let i,c,l,u;0<this.dropout&&this.dropout<1&&(e=Ad(e,o[0]));let d=Gv(e,this.kernel.read());0<this.recurrentDropout&&this.recurrentDropout<1&&(a=Ad(a,s[0])),d=Ed(d,Gv(a,this.recurrentKernel.read())),this.useBias&&(d=qv(d,this.bias.read()));const[h,p,f,m]=Nf(d,4,d.rank-1);i=this.recurrentActivation.apply(h),c=this.recurrentActivation.apply(p),l=Ed(Ad(c,r),Ad(i,this.activation.apply(f))),u=this.recurrentActivation.apply(m);const g=Ad(u,this.activation.apply(l));return[g,g,l]}))}getConfig(){const e=super.getConfig(),t={units:this.units,activation:CI(this.activation),recurrentActivation:CI(this.recurrentActivation),useBias:this.useBias,kernelInitializer:gw(this.kernelInitializer),recurrentInitializer:gw(this.recurrentInitializer),biasInitializer:gw(this.biasInitializer),unitForgetBias:this.unitForgetBias,kernelRegularizer:OI(this.kernelRegularizer),recurrentRegularizer:OI(this.recurrentRegularizer),biasRegularizer:OI(this.biasRegularizer),activityRegularizer:OI(this.activityRegularizer),kernelConstraint:Yw(this.kernelConstraint),recurrentConstraint:Yw(this.recurrentConstraint),biasConstraint:Yw(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation};return Object.assign(Object.assign({},e),t)}}gS.className="LSTMCell",Vd(gS);class bS extends uS{constructor(e){0===e.implementation&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),e.cell=new gS(e),super(e)}call(e,t){return Lu((()=>{null!=this.cell.dropoutMask&&(Pu(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(Pu(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);const n=null==t?null:t.mask,a=null==t?null:t.training,r=null==t?null:t.initialState;return super.call(e,{mask:n,training:a,initialState:r})}))}static fromConfig(e,t){return 0===t.implmentation&&(t.implementation=1),new e(t)}}bS.className="LSTM",Vd(bS);class yS extends dS{constructor(e){super(e),this.cells=e.cells}get stateSize(){const e=[];for(const t of this.cells.slice().reverse())Array.isArray(t.stateSize)?e.push(...t.stateSize):e.push(t.stateSize);return e}call(e,t){return Lu((()=>{let n=e.slice(1);const a=[];for(const e of this.cells.slice().reverse())Array.isArray(e.stateSize)?a.push(n.splice(0,e.stateSize.length)):a.push(n.splice(0,1));a.reverse();const r=[];let o;for(let s=0;s<this.cells.length;++s){const i=this.cells[s];n=a[s],o=0===s?[e[0]].concat(n):[o[0]].concat(n),o=i.call(o,t),r.push(o.slice(1))}n=[];for(const e of r.slice().reverse())n.push(...e);return[o[0]].concat(n)}))}build(e){let t;yw(e)&&(e=e[0]),this.cells.forEach(((n,a)=>{Iv("RNNCell_".concat(a),(()=>{n.build(e),t=Array.isArray(n.stateSize)?n.stateSize[0]:n.stateSize,e=[e[0],t]}))})),this.built=!0}getConfig(){const e=super.getConfig(),t={cells:this.cells.map((e=>({className:e.getClassName(),config:e.getConfig()})))};return Object.assign(Object.assign({},e),t)}static fromConfig(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};const a=[];for(const r of t.cells)a.push(lk(r,n));return new e({cells:a})}get trainableWeights(){if(!this.trainable)return[];const e=[];for(const t of this.cells)e.push(...t.trainableWeights);return e}get nonTrainableWeights(){const e=[];for(const t of this.cells)e.push(...t.nonTrainableWeights);if(!this.trainable){const t=[];for(const e of this.cells)t.push(...e.trainableWeights);return t.concat(e)}return e}getWeights(){const e=[];for(const t of this.cells)e.push(...t.weights);return Nw(e)}setWeights(e){const t=[];for(const n of this.cells){const a=n.weights.length,r=e.splice(a);for(let e=0;e<n.weights.length;++e)t.push([n.weights[e],r[e]])}Cw(t)}}function xS(e){const{ones:t,rate:n,training:a=!1,count:r=1,dropoutFunc:o}=e,s=()=>null!=o?o(t(),n):Xv(t(),n),i=()=>Yv(s,t,a);if(!r||r<=1)return zu(i().clone());return Array(r).fill(void 0).map(i).map((e=>zu(e.clone())))}yS.className="StackedRNNCells",Vd(yS);var vS=function(e,t){var n={};for(var a in e)Object.prototype.hasOwnProperty.call(e,a)&&t.indexOf(a)<0&&(n[a]=e[a]);if(null!=e&&"function"===typeof Object.getOwnPropertySymbols){var r=0;for(a=Object.getOwnPropertySymbols(e);r<a.length;r++)t.indexOf(a[r])<0&&Object.prototype.propertyIsEnumerable.call(e,a[r])&&(n[a[r]]=e[a[r]])}return n};class wS extends uS{constructor(e){if(e.unroll)throw new Wx("Unrolling is not possible with convolutional RNNs.");if(Array.isArray(e.cell))throw new Wx("It is not possible at the moment to stack convolutional cells.");super(e),this.inputSpec=[new Tw({ndim:5})]}call(e,t){return Lu((()=>{if(null!=this.cell.dropoutMask&&(Pu(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(Pu(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null),t&&t.constants)throw new Bx("ConvRNN2D cell does not support constants");const n=null==t?null:t.mask,a=null==t?null:t.training,r=null==t?null:t.initialState;return super.call(e,{mask:n,training:a,initialState:r})}))}computeOutputShape(e){let t=this.computeSingleOutputShape(e);return this.returnSequences||(t=[t[0],...t.slice(2)]),this.returnState&&(t=[t,...Array(2).fill([e[0],...t.slice(-3)])]),t}getInitialState(e){return Lu((()=>{const{stateSize:t}=this.cell,n=e.shape,a=this.computeSingleOutputShape(n),r=tf([a[0],...a.slice(2)]);return Array.isArray(t)?Array(t.length).fill(r):[r]}))}resetStates(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];Lu((()=>{if(!this.stateful)throw new Px("Cannot call resetStates() on an RNN Layer that is not stateful.");const n=this.inputSpec[0].shape,a=this.computeSingleOutputShape(n),r=[a[0],...a.slice(2)];if(null==n[0])throw new Bx("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(null==this.getStates())Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map((()=>tf(r))):this.states_=[tf(r)];else if(null==e)Pu(this.states_),null!=this.keptStates&&(Pu(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map((()=>tf(r))):this.states_[0]=tf(r);else{if(Array.isArray(e)||(e=[e]),e.length!==this.states_.length)throw new Bx("Layer ".concat(this.name," expects ").concat(this.states_.length," state(s), ")+"but it received ".concat(e.length," state value(s). Input ")+"received: ".concat(e));t?this.keptStates.push(this.states_.slice()):Pu(this.states_);for(let t=0;t<this.states_.length;++t){const n=e[t],a=r;if(!uo(n.shape,a))throw new Bx("State ".concat(t," is incompatible with layer ").concat(this.name,": ")+"expected shape=".concat(a,", received shape=").concat(n.shape));this.states_[t]=n}}this.states_=this.states_.map((e=>zu(e.clone())))}))}computeSingleOutputShape(e){const{dataFormat:t,filters:n,kernelSize:a,padding:r,strides:o,dilationRate:s}=this.cell,i="channelsFirst"===t,c=e[i?3:2],l=e[i?4:3],u=GI(c,a[0],r,o[0],s[0]),d=GI(l,a[1],r,o[1],s[1]);return[...e.slice(0,2),...i?[n,u,d]:[u,d,n]]}}wS.className="ConvRNN2D";class kS extends gS{constructor(e){const{filters:t,kernelSize:n,strides:a,padding:r,dataFormat:o,dilationRate:s}=e;super(Object.assign(Object.assign({},e),{units:t})),this.filters=t,ov(this.filters,"filters"),this.kernelSize=UI(n,2,"kernelSize"),this.kernelSize.forEach((e=>ov(e,"kernelSize"))),this.strides=UI(a||1,2,"strides"),this.strides.forEach((e=>ov(e,"strides"))),this.padding=r||"valid",xv(this.padding),this.dataFormat=o||"channelsLast",yv(this.dataFormat),this.dilationRate=UI(s||1,2,"dilationRate"),this.dilationRate.forEach((e=>ov(e,"dilationRate")))}build(e){var t;e=ww(e);const n="channelsFirst"===this.dataFormat?1:e.length-1;if(null==e[n])throw new Bx("The channel dimension of the input should be defined. "+"Found ".concat(e[n]));const a=e[n],r=this.kernelSize.concat([a,4*this.filters]);this.kernel=this.addWeight("kernel",r,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint);const o=this.kernelSize.concat([this.filters,4*this.filters]);if(this.recurrentKernel=this.addWeight("recurrent_kernel",o,null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias){let e;if(this.unitForgetBias){const n=this.biasInitializer,a=this.filters;e=new((t=class extends Zv{apply(e,t){return Bv([n.apply([a]),nf([a]),n.apply([2*a])])}}).className="CustomInit",t)}else e=this.biasInitializer;this.bias=this.addWeight("bias",[4*this.filters],null,e,this.biasRegularizer,!0,this.biasConstraint)}this.built=!0}call(e,t){return Lu((()=>{if(3!==e.length)throw new Bx("ConvLSTM2DCell expects 3 input Tensors (inputs, h, c), got "+"".concat(e.length,"."));const n=t.training||!1,a=e[0],r=e[1],o=e[2];0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=xS({ones:()=>af(a),rate:this.dropout,training:n,count:4,dropoutFunc:this.dropoutFunc}));const s=this.dropoutMask,i=(e,t,n)=>t&&t[n]?Ad(t[n],e):e;let c=i(a,s,0),l=i(a,s,1),u=i(a,s,2),d=i(a,s,3);0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=xS({ones:()=>af(r),rate:this.recurrentDropout,training:n,count:4,dropoutFunc:this.dropoutFunc}));const h=this.recurrentDropoutMask;let p=i(r,h,0),f=i(r,h,1),m=i(r,h,2),g=i(r,h,3);const[b,y,x,v]=Nf(this.kernel.read(),4,3),[w,k,I,S]=this.useBias?Nf(this.bias.read(),4):[null,null,null,null];c=this.inputConv(c,b,w,this.padding),l=this.inputConv(l,y,k,this.padding),u=this.inputConv(u,x,I,this.padding),d=this.inputConv(d,v,S,this.padding);const[N,C,T,E]=Nf(this.recurrentKernel.read(),4,3);p=this.recurrentConv(p,N),f=this.recurrentConv(f,C),m=this.recurrentConv(m,T),g=this.recurrentConv(g,E);const R=this.recurrentActivation.apply(Ed(c,p)),_=this.recurrentActivation.apply(Ed(l,f)),A=Ed(Ad(_,o),Ad(R,this.activation.apply(Ed(u,m)))),F=Ad(this.recurrentActivation.apply(Ed(d,g)),this.activation.apply(A));return[F,F,A]}))}getConfig(){const e=super.getConfig(),{units:t}=e,n=vS(e,["units"]),a={filters:this.filters,kernelSize:this.kernelSize,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,strides:this.strides};return Object.assign(Object.assign({},n),a)}inputConv(e,t,n,a){const r=up(e,t,this.strides,a||"valid","channelsFirst"===this.dataFormat?"NCHW":"NHWC",this.dilationRate);return n?qv(r,n,this.dataFormat):r}recurrentConv(e,t){return up(e,t,1,"same","channelsFirst"===this.dataFormat?"NCHW":"NHWC")}}kS.className="ConvLSTM2DCell",Vd(kS);class IS extends wS{constructor(e){const t=new kS(e);super(Object.assign(Object.assign({},e),{cell:t}))}static fromConfig(e,t){return new e(t)}}IS.className="ConvLSTM2D",Vd(IS);class SS extends Fw{constructor(e){super(e),this.rate=Math.max(Math.min(e.rate,1),0),this.noiseShape=e.noiseShape,this.seed=e.seed,this.supportsMasking=!0}getNoiseShape(e){if(null==this.noiseShape)return this.noiseShape;const t=e.shape,n=[];for(let a=0;a<this.noiseShape.length;++a)n.push(null==this.noiseShape[a]?t[a]:this.noiseShape[a]);return n}call(e,t){return Lu((()=>{this.invokeCallHook(e,t);const n=vw(e);if(0<this.rate&&this.rate<1){const e=null!=t.training&&t.training,a=this.getNoiseShape(n);return Yv((()=>Xv(n,this.rate,a,this.seed)),(()=>n),e)}return e}))}getConfig(){const e={rate:this.rate,noiseShape:this.noiseShape,seed:this.seed},t=super.getConfig();return Object.assign(e,t),e}dispose(){return super.dispose()}}SS.className="Dropout",Vd(SS);class NS extends SS{constructor(e){super(e),this.inputSpec=[{ndim:3}]}getNoiseShape(e){const t=e.shape;return[t[0],1,t[2]]}}NS.className="SpatialDropout1D",Vd(NS);class CS extends Fw{constructor(e){if(super(e),this.activation=null,this.useBias=!0,this.kernel=null,this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",null==e.batchInputShape&&null==e.inputShape&&null!=e.inputDim){let t=null;null!=e.batchSize&&(t=e.batchSize),this.batchInputShape=[t,e.inputDim]}this.units=e.units,ov(this.units,"units"),this.activation=EI(e.activation),null!=e.useBias&&(this.useBias=e.useBias),this.kernelInitializer=bw(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.biasInitializer=bw(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelConstraint=Jw(e.kernelConstraint),this.biasConstraint=Jw(e.biasConstraint),this.kernelRegularizer=MI(e.kernelRegularizer),this.biasRegularizer=MI(e.biasRegularizer),this.activityRegularizer=MI(e.activityRegularizer),this.supportsMasking=!0,this.inputSpec=[{minNDim:2}]}build(e){const t=(e=ww(e))[e.length-1];null==this.kernel&&(this.kernel=this.addWeight("kernel",[t,this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint))),this.inputSpec=[{minNDim:2,axes:{[-1]:t}}],this.built=!0}computeOutputShape(e){const t=(e=ww(e)).slice();return t[t.length-1]=this.units,t}call(e,t){return Lu((()=>{this.invokeCallHook(e,t);const n=vw(e),a=iv(this.activation.getClassName());let r;return null!=a?r=Gv(n,this.kernel.read(),a,this.bias?this.bias.read():null):(r=Gv(n,this.kernel.read()),null!=this.bias&&(r=qv(r,this.bias.read())),null!=this.activation&&(r=this.activation.apply(r))),r}))}getConfig(){const e={units:this.units,activation:CI(this.activation),useBias:this.useBias,kernelInitializer:gw(this.kernelInitializer),biasInitializer:gw(this.biasInitializer),kernelRegularizer:OI(this.kernelRegularizer),biasRegularizer:OI(this.biasRegularizer),activityRegularizer:OI(this.activityRegularizer),kernelConstraint:Yw(this.kernelConstraint),biasConstraint:Yw(this.biasConstraint)},t=super.getConfig();return Object.assign(e,t),e}}CS.className="Dense",Vd(CS);class TS extends Fw{constructor(e){super(e=e||{}),this.inputSpec=[{minNDim:3}],this.dataFormat=e.dataFormat}computeOutputShape(e){e=ww(e);for(const t of e.slice(1))if(null==t)throw new Bx('The shape of the input to "Flatten" is not fully defined '+"(got ".concat(e.slice(1),"). Make sure to pass a complete ")+'"input_shape" or "batch_input_shape" argument to the first layer in your model.');return[e[0],Ev(e,1)]}call(e,t){return Lu((()=>{this.invokeCallHook(e,t);let n=vw(e);if("channelsFirst"===this.dataFormat&&n.rank>1){const e=[0];for(let t=2;t<n.rank;++t)e.push(t);e.push(1),n=Lf(n,e)}return function(e){if(e.rank<=1)throw new Bx("batchFlatten requires a minimum rank of 2. Got rank: ".concat(e.rank,"."));const t=[e.shape[0],Ev(e.shape,1)];return Qh(e,t)}(n)}))}getConfig(){const e={};null!=this.dataFormat&&(e.dataFormat=this.dataFormat);const t=super.getConfig();return Object.assign(e,t),e}}TS.className="Flatten",Vd(TS);class ES extends Fw{constructor(e){super(e),this.supportsMasking=!0,this.activation=EI(e.activation)}call(e,t){return Lu((()=>{this.invokeCallHook(e,t);const n=vw(e);return this.activation.apply(n)}))}getConfig(){const e={activation:CI(this.activation)},t=super.getConfig();return Object.assign(e,t),e}}ES.className="Activation",Vd(ES);class RS extends Fw{constructor(e){super(e),this.n=e.n,this.inputSpec=[{ndim:2}]}computeOutputShape(e){return[e[0],this.n,e[1]]}call(e,t){return Lu((()=>function(e,t){return Lu((()=>{if(2!==e.shape.length)throw new Bx("repeat() expects a rank-2 tensor, but received a "+"rank-".concat(e.shape.length," tensor."));return Vv(Mv(e,1),[1,t,1])}))}(e=vw(e),this.n)))}getConfig(){const e={n:this.n},t=super.getConfig();return Object.assign(e,t),e}}RS.className="RepeatVector",Vd(RS);class _S extends Fw{constructor(e){super(e),this.targetShape=e.targetShape;for(let t=0;t<this.targetShape.length;++t)this.isUnknown(this.targetShape[t])&&(this.targetShape[t]=null)}isUnknown(e){return e<0||null==e}fixUnknownDimension(e,t){const n="Total size of new array must be unchanged.",a=t.slice();let r=1,o=null;for(let i=0;i<a.length;++i){const e=a[i];if(this.isUnknown(e)){if(null!==o)throw new Bx("Can only specifiy one unknown dimension.");o=i}else r*=e}const s=Ev(e);if(null!==o){if(0===r||s%r!==0)throw new Bx(n);a[o]=s/r}else if(s!==r)throw new Bx(n);return a}computeOutputShape(e){let t=!1;for(let n=0;n<e.length;++n)if(this.isUnknown(e[n])){t=!0;break}return t?e.slice(0,1).concat(this.targetShape):e.slice(0,1).concat(this.fixUnknownDimension(e.slice(1),this.targetShape))}call(e,t){return Lu((()=>{this.invokeCallHook(e,t);const n=vw(e),a=n.shape,r=a.slice(0,1).concat(this.fixUnknownDimension(a.slice(1),this.targetShape));return Qh(n,r)}))}getConfig(){const e={targetShape:this.targetShape},t=super.getConfig();return Object.assign(e,t),e}}_S.className="Reshape",Vd(_S);class AS extends Fw{constructor(e){if(super(e),null==e.dims)throw new Error("Required configuration field `dims` is missing during Permute constructor call.");if(!Array.isArray(e.dims))throw new Error("Permute constructor requires `dims` to be an Array, but received "+"".concat(e.dims," instead."));const t=Av(1,e.dims.length+1);if(!uo(e.dims.slice().sort(),t))throw new Error("Invalid permutation `dims`: "+JSON.stringify(e.dims)+" `dims` must contain consecutive integers starting from 1.");this.dims=e.dims,this.dimsIncludingBatch=[0].concat(this.dims),this.inputSpec=[new Tw({ndim:this.dims.length+1})]}computeOutputShape(e){const t=(e=ww(e)).slice();return this.dims.forEach(((n,a)=>{t[a+1]=e[n]})),t}call(e,t){return Lf(vw(e),this.dimsIncludingBatch)}getConfig(){const e={dims:this.dims},t=super.getConfig();return Object.assign(e,t),e}}AS.className="Permute",Vd(AS);class FS extends Fw{constructor(e){super(null==e?{}:e),this.supportsMasking=!0,this.maskValue=null!=e?null==e.maskValue?0:e.maskValue:0}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),t={maskValue:this.maskValue};return Object.assign(t,e),t}computeMask(e,t){const n=vw(e);return Oh($p(n,this.maskValue),-1)}call(e,t){return Lu((()=>{this.invokeCallHook(e,t);const n=vw(e),a=Oh($p(n,this.maskValue),-1,!0);return Ad(n,Cd(a,n.dtype))}))}}FS.className="Masking",Vd(FS);class OS extends Fw{constructor(e){if(super(e),this.embeddings=null,this.DEFAULT_EMBEDDINGS_INITIALIZER="randomUniform",null==e.batchInputShape&&null==e.inputShape){let t=null;null!=e.batchSize&&(t=e.batchSize),null==e.inputLength?this.batchInputShape=[t,null]:this.batchInputShape=[t].concat(qx(e.inputLength))}this.inputDim=e.inputDim,ov(this.inputDim,"inputDim"),this.outputDim=e.outputDim,ov(this.outputDim,"outputDim"),this.embeddingsInitializer=bw(e.embeddingsInitializer||this.DEFAULT_EMBEDDINGS_INITIALIZER),this.embeddingsRegularizer=MI(e.embeddingsRegularizer),this.activityRegularizer=MI(e.activityRegularizer),this.embeddingsConstraint=Jw(e.embeddingsConstraint),this.maskZero=e.maskZero,this.supportsMasking=e.maskZero,this.inputLength=e.inputLength}build(e){this.embeddings=this.addWeight("embeddings",[this.inputDim,this.outputDim],this.dtype,this.embeddingsInitializer,this.embeddingsRegularizer,!0,this.embeddingsConstraint),this.built=!0}warnOnIncompatibleInputShape(e){}computeMask(e,t){return Lu((()=>this.maskZero?(e=vw(e),$p(e,Dd(e))):null))}computeOutputShape(e){if(e=ww(e),null==this.inputLength)return[...e,this.outputDim];const t=qx(this.inputLength);if(t.length!==e.length-1)throw new Bx('"inputLength" is '.concat(this.inputLength,", but received ")+"input shape has shape ".concat(e));{let n=0;for(let a=0;a<t.length;++a){const r=t[a],o=e[a+1];if(null!=r&&null!=o&&r!==o)throw new Bx('"inputLength" is '.concat(this.inputLength,", but received ")+"input shape has shape ".concat(e));null==r&&(t[n]=o),n++}}return[e[0],...t,this.outputDim]}call(e,t){return Lu((()=>{this.invokeCallHook(e,t);let n=vw(e);"int32"!==n.dtype&&(n=Dv(n,"int32"));const a=Hv(this.embeddings.read(),Qh(n,[n.size]));return Qh(a,ww(this.computeOutputShape(n.shape)))}))}getConfig(){const e={inputDim:this.inputDim,outputDim:this.outputDim,embeddingsInitializer:gw(this.embeddingsInitializer),embeddingsRegularizer:OI(this.embeddingsRegularizer),activityRegularizer:OI(this.activityRegularizer),embeddingsConstraint:Yw(this.embeddingsConstraint),maskZero:this.maskZero,inputLength:this.inputLength},t=super.getConfig();return Object.assign(e,t),e}}OS.className="Embedding",Vd(OS);class DS extends Fw{constructor(e){super(e||{}),this.supportsMasking=!0}mergeFunction(e){throw new Wx}computeElementwiseOpOutputShape(e,t){if(null==e||null==t)return null;if(e.length<t.length)return this.computeElementwiseOpOutputShape(t,e);if(0===t.length)return e;const n=e.slice(0,e.length-t.length);for(let a=0;a<t.length;++a){const r=e[e.length-t.length+a],o=t[a];if(null==r||null==o||r<0||o<0)n.push(null);else if(1===r)n.push(o);else if(1===o)n.push(r);else{if(r!==o)throw new Bx("Operands could not be broadcast together with shapes "+JSON.stringify(e)+" "+JSON.stringify(t));n.push(r)}}return n}build(e){if(Array.isArray(e)&&!Array.isArray(e[0])&&(e=[ww(e)]),e.length<2)throw new Bx("A merge layer should be called on an Array of at least 2 inputs."+" Got ".concat(e.length," input(s)."));let t=[];for(const r of e)null!=r&&null!==r[0]&&t.push(r[0]);if(t=tv(t),t.length>1)throw new Bx("Can not merge tensors with different batch sizes. "+"Got tensors with shapes: ".concat(JSON.stringify(e),"."));let n=null==e[0]?null:e[0].slice(1);for(let r=1;r<e.length;++r){const t=null==e[r]?null:e[r].slice(1);n=this.computeElementwiseOpOutputShape(n,t)}const a=e.map((e=>e.length));-1===e.indexOf(null)&&1===tv(a).length?this.reshapeRequired=!1:this.reshapeRequired=!0}call(e,t){return Lu((()=>{if(this.reshapeRequired){const t=[],n=e.map((e=>e.rank));if(-1===n.indexOf(null)){const a=_v(n);for(let n of e){const e=n.rank;for(let t=0;t<a-e;++t)n=Mv(n,1);t.push(n)}return this.mergeFunction(t)}{let n=!1;for(const o of e){const e=o.rank;if(null==e){const e=o.shape,a=e[0],r=e.slice(1).concat([a]);let s=Qh(o,[a].concat(Ev(e.slice(1))));s=Lf(s,[1,0]),s=Qh(s,r),t.push(s),n=!0}else if(e>1){const a=Av(1,e).concat([0]);t.push(Lf(o,a)),n=!0}else t.push(o)}let a=this.mergeFunction(t);const r=a.rank;if(n)if(null==r){const e=a.shape,t=e[e.length-1],n=[t].concat(e.slice(0,e.length-1));a=Qh(Lf(Qh(a,[-1,t]),[1,0]),n)}else if(r>1){const e=[r-1].concat(Av(0,r-1));a=Lf(a,e)}return a}}return this.mergeFunction(e)}))}computeOutputShape(e){let t;t=null==e[0]?null:e[0].slice(1);for(let a=1;a<e.length;++a){const n=null==e[a]?null:e[a].slice(1);t=this.computeElementwiseOpOutputShape(t,n)}let n=[];for(const a of e)null!=a&&null!==a[0]&&n.push(a[0]);return n=tv(n),t=1===n.length?n.concat(t):[null].concat(t),t}computeMask(e,t){return Lu((()=>{if(null==t)return null;if(!Array.isArray(t))throw new Bx("`mask` should be an Array");if(!Array.isArray(e))throw new Bx("`inputs` should be an Array");if(t.length!==e.length)throw new Bx("The Array 'inputs' and 'mask' are expected to have the same length, but have different lengths "+"(".concat(e.length," vs ").concat(t.length,")"));if(t.every((e=>null==e)))return null;t=t.map((e=>null==e?e:kp(e,0)));let n=t[0];for(let e=1;e<t.length-1;++e)n=Hp(n,t[e]);return n}))}}class MS extends DS{constructor(e){super(e)}mergeFunction(e){return Lu((()=>{let t=e[0].clone();for(let n=1;n<e.length;++n)t=Ed(t,e[n]);return t}))}}MS.className="Add",Vd(MS);class LS extends DS{constructor(e){super(e)}mergeFunction(e){return Lu((()=>{let t=e[0].clone();for(let n=1;n<e.length;++n)t=Ad(t,e[n]);return t}))}}LS.className="Multiply",Vd(LS);class PS extends DS{constructor(e){super(e)}mergeFunction(e){return Lu((()=>{let t=e[0].clone();for(let n=1;n<e.length;++n)t=Ed(t,e[n]);return Ad(1/e.length,t)}))}}PS.className="Average",Vd(PS);class zS extends DS{constructor(e){super(e)}mergeFunction(e){return Lu((()=>{let t=e[0];for(let n=1;n<e.length;++n)t=$d(t,e[n]);return t}))}}zS.className="Maximum",Vd(zS);class BS extends DS{constructor(e){super(e)}mergeFunction(e){return Lu((()=>{let t=e[0];for(let n=1;n<e.length;++n)t=Qp(t,e[n]);return t}))}}BS.className="Minimum",Vd(BS);class WS extends DS{constructor(e){super(e),this.DEFAULT_AXIS=-1,null==e&&(e={}),this.axis=null==e.axis?this.DEFAULT_AXIS:e.axis,this.supportsMasking=!0,this.reshapeRequired=!1}build(e){if(!Array.isArray(e)||!Array.isArray(e[0])||1===e.length)throw new Bx("A `Concatenate` layer should be called on a list of at least 2 inputs");let t=!0;for(const a of e)if(null!=a){t=!1;break}if(t)return;const n=[];for(let a=0;a<e.length;++a){const t=e[a].slice();t.splice(this.axis,1);let r=!1;for(const e of n)if(uo(e,t)){r=!0;break}r||n.push(t)}if(n.length>1)throw new Bx("A `Concatenate` layer requires inputs with matching shapes except for the concat axis. Got input shapes: "+JSON.stringify(e))}mergeFunction(e){return Lu((()=>Bv(e,this.axis)))}computeOutputShape(e){if(!Array.isArray(e)||!Array.isArray(e[0]))throw new Bx("A `Concatenate` layer should be called on a list of inputs.");const t=e,n=t[0].slice(),a=this.axis<0?n.length+this.axis:this.axis;for(const r of t.slice(1)){if(null==n[a]||null==r[a]){n[a]=null;break}n[a]+=r[a]}return n}computeMask(e,t){if(null==t)return null;if(!Array.isArray(t))throw new Bx("`mask` should be an array for Concatenate");if(!Array.isArray(e))throw new Bx("`inputs` should be an array for Concatenate");if(t.length!==e.length)throw new Bx("Mismatch in the length of mask (".concat(t.length,") ")+"and the legnth of inputs (".concat(e.length,")"));return Lu((()=>{let n=!0;if(t.forEach((e=>{null==e||(n=!1)})),n)return null;const a=[];for(let o=0;o<e.length;++o)null==t[o]?a.push(Cd(af(e[o]),"bool")):t[o].rank<e[o].rank?a.push(kp(t[o],-1)):a.push(t[o]);const r=op(a,this.axis);return Fh(r,-1,!1)}))}getConfig(){const e={axis:this.axis},t=super.getConfig();return Object.assign(e,t),e}}function VS(e,t){for(;e<0;)e+=t;return e}WS.className="Concatenate",Vd(WS);class US extends DS{constructor(e){super(e),this.axes=e.axes,this.normalize=null!=e.normalize&&e.normalize,this.supportsMasking=!0,this.reshapeRequired=!1}build(e){so(Array.isArray(e)&&2===e.length&&Array.isArray(e[0])&&Array.isArray(e[1]),(()=>"A `Dot` layer should be called on a list of exactly 2 inputs."));const t=e[0],n=e[1];if(t.length>3||n.length>3)throw new Wx("Dot layer does not support tensors of 4D or higher rank yet.");const a=this.interpretAxes(t,n);if(t[a[0]]!==n[a[1]])throw new Bx("Dimension incompatibility: "+"".concat(t[a[0]]," !== ").concat(n[a[1]]))}mergeFunction(e){if(2!==e.length)throw new Bx("A `Dot` layer must be called on exactly 2 inputs, "+"but received ".concat(e.length," input(s)."));let t,n=e[0],a=e[1];return t=Array.isArray(this.axes)?this.axes.map(((t,n)=>VS(t,e[n].shape.length))):[VS(this.axes,n.shape.length),VS(this.axes,a.shape.length)],this.normalize&&(n=uk(n,t[0]),a=uk(a,t[1])),function(e,t,n){if(e.shape.length>3||t.shape.length>3)throw new Wx("batchDot is not implemented for tensors of 4D or higher rank yet");if(so(e.shape.length>=2,(()=>"batchDot requires the rank of x to be >= 2, "+"but got ".concat(e.shape.length))),so(e.shape.length>=2,(()=>"batchDot requires the rank of y to be >= 2, "+"but got ".concat(t.shape.length))),"number"===typeof n&&(n=[n,n]),"complex64"===e.dtype||"complex64"===t.dtype)throw new Wx("batchDot is not implemented for complex64-type Tensors yet.");const a=e.shape.length,r=t.shape.length;null==n&&(n=[a-1,r-2]);const o=n;return Lu((()=>{let n,s;if(a>r){n=a-r;const e=[];for(let t=0;t<n;++t)e.push(1);t=Qh(t,t.shape.concat(e))}else if(r>a){n=r-a;const t=[];for(let e=0;e<n;++e)t.push(1);e=Qh(e,e.shape.concat(t))}else n=0;if(2===e.shape.length&&2===t.shape.length)s=o[0]===o[1]?Op(Ad(e,t),o[0]):Op(Ad(Lf(e,[1,0]),t),o[1]);else{const n=o[0]!==e.shape.length-1,a=o[1]===t.shape.length-1;s=jp(e,t,n,a)}if(n>0){let e;e=a>r?a+r-3:a-1;const t=[];for(let a=e;a<e+n;++a)t.push(a);s=Cf(s,t)}return 1===s.shape.length&&(s=kp(s,1)),s}))}(n,a,t)}interpretAxes(e,t){let n;return n=Array.isArray(this.axes)?this.axes:[VS(this.axes,e.length),VS(this.axes,t.length)],n}computeOutputShape(e){so(Array.isArray(e)&&2===e.length&&Array.isArray(e[0])&&Array.isArray(e[1]),(()=>"A `Dot` layer should be called on a list of exactly 2 inputs."));const t=e[0].slice(),n=e[1].slice();if(t.length>3||n.length>3)throw new Wx("Dot layer does not support tensors of 4D or higher rank yet.");const a=this.interpretAxes(t,n);t.splice(a[0],1),n.splice(a[1],1),n.splice(0,1);const r=t.concat(n);return 1===r.length&&r.push(1),r}computeMask(e,t){return null}getConfig(){const e={axes:this.axes,normalize:this.normalize},t=super.getConfig();return Object.assign(e,t),e}}US.className="Dot",Vd(US);class GS extends Fw{constructor(e){super(e),this.supportsMasking=!0,this.stddev=e.stddev}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),t={stddev:this.stddev};return Object.assign(t,e),t}call(e,t){return Lu((()=>{this.invokeCallHook(e,t);const n=vw(e);return Yv((()=>Ed(Uv(n.shape,0,this.stddev),n)),(()=>n),t.training||!1)}))}}GS.className="GaussianNoise",Vd(GS);class HS extends Fw{constructor(e){super(e),this.supportsMasking=!0,this.rate=e.rate}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),t={rate:this.rate};return Object.assign(t,e),t}call(e,t){return Lu((()=>{this.invokeCallHook(e,t);const n=vw(e);if(this.rate>0&&this.rate<1){return Yv((()=>{const e=Math.sqrt(this.rate/(1-this.rate));return Ad(n,Uv(n.shape,1,e))}),(()=>n),t.training||!1)}return n}))}}HS.className="GaussianDropout",Vd(HS);class jS extends Fw{constructor(e){super(e),this.supportsMasking=!0,this.rate=e.rate,this.noiseShape=e.noiseShape}_getNoiseShape(e){return this.noiseShape||vw(e).shape}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),t={rate:this.rate};return Object.assign(t,e),t}call(e,t){return Lu((()=>{if(this.rate<1&&this.rate>0){const n=this._getNoiseShape(e),a=()=>{const t=vw(e),a=-1.7580993408473766;let r=Ep(df(n),this.rate);r=Dv(r,"float32");const o=((1-this.rate)*(1+this.rate*a**2))**-.5,s=-o*a*this.rate,i=Ed(Ad(t,r),Ad(Ed(r,-1),a));return Ed(Ad(i,o),s)};return Yv(a,(()=>vw(e)),t.training||!1)}return e}))}}function KS(e,t,n,a,r){let o,s=arguments.length>5&&void 0!==arguments[5]?arguments[5]:.001;if(2===e.rank)o=ep(e,t,n,a,r,s);else if(3===e.rank)o=tp(e,t,n,a,r,s);else{if(4!==e.rank)throw new Wx("batchNormalization is not implemented for array of rank ".concat(e.rank," ")+"yet");o=np(e,t,n,a,r,s)}return o}function qS(e,t,n,a){let r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:.001;return uo(a.slice().sort(),Av(0,e.rank-1))?function(e,t,n,a){let r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:.001;return Lu((()=>{const o=Jp(e,a),s=o.mean,i=o.variance;return[KS(e,s,i,n,t,r),s,i]}))}(e,t,n,a,r):function(e,t,n,a){let r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:.001;return Lu((()=>{const o=Jp(e,a),s=o.mean,i=o.variance,c=[];for(const t of Av(0,e.rank))-1!==a.indexOf(t)?c.push(1):c.push(e.shape[t]);const l=Qh(s,c),u=Qh(i,c),d=null==t?null:Qh(t,c),h=null==n?null:Qh(n,c);return[KS(e,l,u,h,d,r),s,i]}))}(e,t,n,a,r)}jS.className="AlphaDropout",Vd(jS);class XS extends Fw{constructor(e){null==e&&(e={}),super(e),this.supportsMasking=!0,this.axis=null==e.axis?-1:e.axis,this.momentum=null==e.momentum?.99:e.momentum,this.epsilon=null==e.epsilon?.001:e.epsilon,this.center=null==e.center||e.center,this.scale=null==e.scale||e.scale,this.betaInitializer=bw(e.betaInitializer||"zeros"),this.gammaInitializer=bw(e.gammaInitializer||"ones"),this.movingMeanInitializer=bw(e.movingMeanInitializer||"zeros"),this.movingVarianceInitializer=bw(e.movingVarianceInitializer||"ones"),this.betaConstraint=Jw(e.betaConstraint),this.gammaConstraint=Jw(e.gammaConstraint),this.betaRegularizer=MI(e.betaRegularizer),this.gammaRegularizer=MI(e.gammaRegularizer)}build(e){e=ww(e);const t=this.axis>=0?this.axis:this.axis+e.length,n=e[t];if(null==n)throw new Bx("Axis ".concat(t," of input tensor should have a defined dimension but ")+"the layer received an input with shape "+"".concat(JSON.stringify(e),"."));this.inputSpec=[new Tw({ndim:e.length,axes:{[t]:n}})];const a=[n];this.scale&&(this.gamma=this.addWeight("gamma",a,null,this.gammaInitializer,this.gammaRegularizer,!0,this.gammaConstraint)),this.center&&(this.beta=this.addWeight("beta",a,null,this.betaInitializer,this.betaRegularizer,!0,this.betaConstraint)),this.movingMean=this.addWeight("moving_mean",a,null,this.movingMeanInitializer,null,!1),this.movingVariance=this.addWeight("moving_variance",a,null,this.movingVarianceInitializer,null,!1),this.built=!0}call(e,t){return Lu((()=>{const n=null!=t.training&&t.training,a=vw(e),r=a.shape,o=r.length,s=Av(0,o),i=this.axis>=0?this.axis:this.axis+o;s.splice(i,1);const c=Gx(1,o);c[i]=r[i];const l=s.slice();l.sort();const u=!uo(l,Av(0,o).slice(0,o-1));if(!n)return(()=>{if(u){const e=Qh(this.movingMean.read(),c),t=Qh(this.movingVariance.read(),c),n=this.center?Qh(this.beta.read(),c):null,r=this.scale?Qh(this.gamma.read(),c):null;return KS(a,e,t,n,r,this.epsilon)}return KS(a,this.movingMean.read(),this.movingVariance.read(),null==this.beta?null:this.beta.read(),null==this.gamma?null:this.gamma.read(),this.epsilon)})();const[d,h,p]=qS(a,this.gamma.read(),this.beta.read(),s,this.epsilon),f=(e,t,n)=>{Lu((()=>{const a=1-n,r=e.read(),o=Ad(qd(r,t),a);e.write(qd(r,o))}))};return(()=>{f(this.movingMean,h,this.momentum),f(this.movingVariance,p,this.momentum)})(),d}))}getConfig(){const e={axis:this.axis,momentum:this.momentum,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:gw(this.betaInitializer),gammaInitializer:gw(this.gammaInitializer),movingMeanInitializer:gw(this.movingMeanInitializer),movingVarianceInitializer:gw(this.movingVarianceInitializer),betaRegularizer:OI(this.betaRegularizer),gammaRegularizer:OI(this.gammaRegularizer),betaConstraint:Yw(this.betaConstraint),gammaConstraint:Yw(this.gammaConstraint)},t=super.getConfig();return Object.assign(e,t),e}}XS.className="BatchNormalization",Vd(XS);class YS extends Fw{constructor(e){if(null==e&&(e={}),super(e),this.axis=null==e.axis?-1:e.axis,"number"===typeof this.axis){if(!Number.isInteger(this.axis))throw new Error("Expected axis to be an integer, but received ".concat(this.axis))}else{if(!Array.isArray(this.axis))throw new Error("Expected axis to be an integer or an array of integers, "+"but received ".concat(JSON.stringify(this.axis)));for(const e of this.axis)if(!Number.isInteger(e))throw new Error("Expected axis to be an array of integers, "+"but received ".concat(JSON.stringify(this.axis)))}this.epsilon=null==e.epsilon?.001:e.epsilon,this.center=null==e.center||e.center,this.scale=null==e.scale||e.scale,this.betaInitializer=bw(e.betaInitializer||"zeros"),this.gammaInitializer=bw(e.gammaInitializer||"ones"),this.betaRegularizer=MI(e.betaRegularizer),this.gammaRegularizer=MI(e.gammaRegularizer),this.supportsMasking=!0}build(e){const t=(e=ww(e)).length;"number"===typeof this.axis&&(this.axis=[this.axis]);for(let r=0;r<this.axis.length;++r)this.axis[r]<0&&(this.axis[r]+=t);for(const r of this.axis)if(r<0||r>=t)throw new Error("Invalid axis: ".concat(r));if(this.axis.length!==tv(this.axis).length)throw new Error("Found duplicate axes in: ".concat(this.axis));const n=this.axis.map((t=>e[t])),a=!0;this.scale?this.gamma=this.addWeight("gamma",n,"float32",this.gammaInitializer,this.gammaRegularizer,a):this.gamma=null,this.center?this.beta=this.addWeight("beta",n,"float32",this.betaInitializer,this.betaRegularizer,a):this.beta=null,this.built=!0}call(e,t){const n=vw(e),a=n.shape,r=a.length;return Lu((()=>{let{mean:e,variance:t}=Jp(n,this.axis,!0);const o=Gx(1,r);for(const n of this.axis)o[n]=a[n];const s=e=>null!=e&&e.shape.length!==r?Qh(e,o):e;let i=this.scale?s(this.gamma.read()):null,c=this.center?s(this.beta.read()):null;const l=[],u=[];for(let n=0;n<r;++n)-1!==this.axis.indexOf(n)?(l.push(a[n]),u.push(1)):(l.push(1),u.push(a[n]));return e=Ip(e,l),t=Ip(t,l),null!=i&&(i=Ip(i,u)),null!=c&&(c=Ip(c,u)),KS(n,e,t,c,i,this.epsilon)}))}getConfig(){const e={axis:this.axis,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:gw(this.betaInitializer),gammaInitializer:gw(this.gammaInitializer),betaRegularizer:OI(this.betaRegularizer),gammaRegularizer:OI(this.gammaRegularizer)},t=super.getConfig();return Object.assign(e,t),e}}YS.className="LayerNormalization",Vd(YS);class QS extends Fw{constructor(e){if(null==e&&(e={}),super(e),this.dataFormat=null==e.dataFormat?"channelsLast":e.dataFormat,null==e.padding)this.padding=[[1,1],[1,1]];else if("number"===typeof e.padding)this.padding=[[e.padding,e.padding],[e.padding,e.padding]];else{if(e.padding=e.padding,2!==e.padding.length)throw new Bx("ZeroPadding2D expects padding to be a length-2 array, but "+"received a length-".concat(e.padding.length," array."));let t,n;if("number"===typeof e.padding[0])t=[e.padding[0],e.padding[0]],n=[e.padding[1],e.padding[1]];else{if(e.padding=e.padding,2!==e.padding[0].length)throw new Bx("ZeroPadding2D expects height padding to be a length-2 array, "+"but received a length-".concat(e.padding[0].length," array."));if(t=e.padding[0],2!==e.padding[1].length)throw new Bx("ZeroPadding2D expects width padding to be a length-2 array, "+"but received a length-".concat(e.padding[1].length," array."));n=e.padding[1]}this.padding=[t,n]}this.inputSpec=[new Tw({ndim:4})]}computeOutputShape(e){let t,n;return e=ww(e),"channelsFirst"===this.dataFormat?(t=null!=e[2]&&e[2]>=0?e[2]+this.padding[0][0]+this.padding[0][1]:null,n=null!=e[3]&&e[3]>=0?e[3]+this.padding[1][0]+this.padding[1][1]:null,[e[0],e[1],t,n]):(t=null!=e[1]&&e[1]>=0?e[1]+this.padding[0][0]+this.padding[0][1]:null,n=null!=e[2]&&e[2]>=0?e[2]+this.padding[1][0]+this.padding[1][1]:null,[e[0],t,n,e[3]])}call(e,t){return Lu((()=>{return t=vw(e),n=this.padding,a=this.dataFormat,Lu((()=>{if(4!==t.rank)throw new Bx("temporalPadding expects input tensor to be 4-D, but received a "+"".concat(t.rank,"-D tensor."));if(null==n&&(n=[[1,1],[1,1]]),2!==n.length||2!==n[0].length||2!==n[1].length)throw new Bx("spatial2dPadding expects `padding` to be an Array of two Arrays, each of which is an Array of two integers.");if(null==a&&(a="channelsLast"),"channelsLast"!==a&&"channelsFirst"!==a)throw new Bx("Unknown data format: ".concat(a,". ")+"Supported data formats are 'channelsLast' and 'channelsFirst.");let e;return e="channelsFirst"===a?[[0,0],[0,0],n[0],n[1]]:[[0,0],n[0],n[1],[0,0]],rf(t,e)}));var t,n,a}))}getConfig(){const e={padding:this.padding,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}}function JS(e,t,n,a,r,o){return Lu((()=>{let s;yv(r),vv(o),xv(a),null==n&&(n=[1,1]),null==a&&(a="valid"),null==r&&(r="channelsLast"),null==o&&(o="max"),e=jI(e,r);const i="same"===a?"same":"valid";return s="max"===o?Kp(e,t,n,i):Jh(e,t,n,i),"channelsFirst"===r&&(s=Lf(s,[0,3,1,2])),s}))}function ZS(e,t,n,a,r,o){return Lu((()=>{let s;yv(r),vv(o),xv(a),null==n&&(n=[1,1,1]),null==a&&(a="valid"),null==r&&(r="channelsLast"),null==o&&(o="max"),e=KI(e,r);const i="same"===a?"same":"valid";return s="max"===o?qp(e,t,n,i):Zh(e,t,n,i),"channelsFirst"===r&&(s=Lf(s,[0,4,1,2,3])),s}))}QS.className="ZeroPadding2D",Vd(QS);class $S extends Fw{constructor(e){if(null==e.poolSize&&(e.poolSize=2),super(e),"number"===typeof e.poolSize)this.poolSize=[e.poolSize];else{if(!Array.isArray(e.poolSize)||1!==e.poolSize.length||"number"!==typeof e.poolSize[0])throw new Bx("poolSize for 1D convolutional layer must be a number or an Array of a single number, but received "+"".concat(JSON.stringify(e.poolSize)));this.poolSize=e.poolSize}if(ov(this.poolSize,"poolSize"),null==e.strides)this.strides=this.poolSize;else if("number"===typeof e.strides)this.strides=[e.strides];else{if(!Array.isArray(e.strides)||1!==e.strides.length||"number"!==typeof e.strides[0])throw new Bx("strides for 1D convolutional layer must be a number or an Array of a single number, but received "+"".concat(JSON.stringify(e.strides)));this.strides=e.strides}ov(this.strides,"strides"),this.padding=null==e.padding?"valid":e.padding,xv(this.padding),this.inputSpec=[new Tw({ndim:3})]}computeOutputShape(e){const t=GI((e=ww(e))[1],this.poolSize[0],this.padding,this.strides[0]);return[e[0],t,e[2]]}call(e,t){return Lu((()=>{this.invokeCallHook(e,t),e=Mv(vw(e),2);const n=this.poolingFunction(vw(e),[this.poolSize[0],1],[this.strides[0],1],this.padding,"channelsLast");return Cf(n,[2])}))}getConfig(){const e={poolSize:this.poolSize,padding:this.padding,strides:this.strides},t=super.getConfig();return Object.assign(e,t),e}}class eN extends $S{constructor(e){super(e)}poolingFunction(e,t,n,a,r){return yv(r),xv(a),JS(e,t,n,a,r,"max")}}eN.className="MaxPooling1D",Vd(eN);class tN extends $S{constructor(e){super(e)}poolingFunction(e,t,n,a,r){return yv(r),xv(a),JS(e,t,n,a,r,"avg")}}tN.className="AveragePooling1D",Vd(tN);class nN extends Fw{constructor(e){if(null==e.poolSize&&(e.poolSize=[2,2]),super(e),this.poolSize=Array.isArray(e.poolSize)?e.poolSize:[e.poolSize,e.poolSize],null==e.strides)this.strides=this.poolSize;else if(Array.isArray(e.strides)){if(2!==e.strides.length)throw new Bx("If the strides property of a 2D pooling layer is an Array, it is expected to have a length of 2, but received length "+"".concat(e.strides.length,"."));this.strides=e.strides}else this.strides=[e.strides,e.strides];ov(this.poolSize,"poolSize"),ov(this.strides,"strides"),this.padding=null==e.padding?"valid":e.padding,this.dataFormat=null==e.dataFormat?"channelsLast":e.dataFormat,yv(this.dataFormat),xv(this.padding),this.inputSpec=[new Tw({ndim:4})]}computeOutputShape(e){e=ww(e);let t="channelsFirst"===this.dataFormat?e[2]:e[1],n="channelsFirst"===this.dataFormat?e[3]:e[2];return t=GI(t,this.poolSize[0],this.padding,this.strides[0]),n=GI(n,this.poolSize[1],this.padding,this.strides[1]),"channelsFirst"===this.dataFormat?[e[0],e[1],t,n]:[e[0],t,n,e[3]]}call(e,t){return Lu((()=>(this.invokeCallHook(e,t),this.poolingFunction(vw(e),this.poolSize,this.strides,this.padding,this.dataFormat))))}getConfig(){const e={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}}class aN extends nN{constructor(e){super(e)}poolingFunction(e,t,n,a,r){return yv(r),xv(a),JS(e,t,n,a,r,"max")}}aN.className="MaxPooling2D",Vd(aN);class rN extends nN{constructor(e){super(e)}poolingFunction(e,t,n,a,r){return yv(r),xv(a),JS(e,t,n,a,r,"avg")}}rN.className="AveragePooling2D",Vd(rN);class oN extends Fw{constructor(e){if(null==e.poolSize&&(e.poolSize=[2,2,2]),super(e),this.poolSize=Array.isArray(e.poolSize)?e.poolSize:[e.poolSize,e.poolSize,e.poolSize],null==e.strides)this.strides=this.poolSize;else if(Array.isArray(e.strides)){if(3!==e.strides.length)throw new Bx("If the strides property of a 3D pooling layer is an Array, it is expected to have a length of 3, but received length "+"".concat(e.strides.length,"."));this.strides=e.strides}else this.strides=[e.strides,e.strides,e.strides];ov(this.poolSize,"poolSize"),ov(this.strides,"strides"),this.padding=null==e.padding?"valid":e.padding,this.dataFormat=null==e.dataFormat?"channelsLast":e.dataFormat,yv(this.dataFormat),xv(this.padding),this.inputSpec=[new Tw({ndim:5})]}computeOutputShape(e){e=ww(e);let t="channelsFirst"===this.dataFormat?e[2]:e[1],n="channelsFirst"===this.dataFormat?e[3]:e[2],a="channelsFirst"===this.dataFormat?e[4]:e[3];return t=GI(t,this.poolSize[0],this.padding,this.strides[0]),n=GI(n,this.poolSize[1],this.padding,this.strides[1]),a=GI(a,this.poolSize[2],this.padding,this.strides[2]),"channelsFirst"===this.dataFormat?[e[0],e[1],t,n,a]:[e[0],t,n,a,e[4]]}call(e,t){return Lu((()=>(this.invokeCallHook(e,t),this.poolingFunction(vw(e),this.poolSize,this.strides,this.padding,this.dataFormat))))}getConfig(){const e={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}}class sN extends oN{constructor(e){super(e)}poolingFunction(e,t,n,a,r){return yv(r),xv(a),ZS(e,t,n,a,r,"max")}}sN.className="MaxPooling3D",Vd(sN);class iN extends oN{constructor(e){super(e)}poolingFunction(e,t,n,a,r){return yv(r),xv(a),ZS(e,t,n,a,r,"avg")}}iN.className="AveragePooling3D",Vd(iN);class cN extends Fw{constructor(e){super(e),this.inputSpec=[new Tw({ndim:3})]}computeOutputShape(e){return[e[0],e[2]]}call(e,t){throw new Wx}}class lN extends cN{constructor(e){super(e||{})}call(e,t){return Lu((()=>{const t=vw(e);return Xp(t,1)}))}}lN.className="GlobalAveragePooling1D",Vd(lN);class uN extends cN{constructor(e){super(e||{})}call(e,t){return Lu((()=>{const t=vw(e);return Fp(t,1)}))}}uN.className="GlobalMaxPooling1D",Vd(uN);class dN extends Fw{constructor(e){super(e),this.dataFormat=null==e.dataFormat?"channelsLast":e.dataFormat,yv(this.dataFormat),this.inputSpec=[new Tw({ndim:4})]}computeOutputShape(e){return"channelsLast"===this.dataFormat?[e[0],e[3]]:[e[0],e[1]]}call(e,t){throw new Wx}getConfig(){const e={dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}}class hN extends dN{call(e,t){return Lu((()=>{const t=vw(e);return"channelsLast"===this.dataFormat?Xp(t,[1,2]):Xp(t,[2,3])}))}}hN.className="GlobalAveragePooling2D",Vd(hN);class pN extends dN{call(e,t){return Lu((()=>{const t=vw(e);return"channelsLast"===this.dataFormat?Fp(t,[1,2]):Fp(t,[2,3])}))}}pN.className="GlobalMaxPooling2D",Vd(pN);class fN extends Fw{constructor(e){super(e),this.layer=e.layer}build(e){this.built=!0}get trainable(){return null!=this.layer&&this.layer.trainable}set trainable(e){null!=this.layer&&(this.layer.trainable=e)}get trainableWeights(){return this.layer.trainableWeights}get nonTrainableWeights(){return this.layer.nonTrainableWeights}get updates(){return this.layer._updates}get losses(){return this.layer.losses}getWeights(){return this.layer.getWeights()}setWeights(e){this.layer.setWeights(e)}getConfig(){const e={layer:{className:this.layer.getClassName(),config:this.layer.getConfig()}},t=super.getConfig();return Object.assign(e,t),e}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),null!=this.layer&&this.layer.setFastWeightInitDuringBuild(e)}static fromConfig(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};const a=lk(t.layer,n);delete t.layer;const r={layer:a};return Object.assign(r,t),new e(r)}}class mN extends fN{constructor(e){super(e),this.supportsMasking=!0}build(e){if((e=ww(e)).length<3)throw new Bx("TimeDistributed layer expects an input shape >= 3D, but received "+"input shape ".concat(JSON.stringify(e)));this.inputSpec=[{shape:e}];const t=[e[0]].concat(e.slice(2));this.layer.built||(this.layer.build(t),this.layer.built=!0),super.build(e)}computeOutputShape(e){const t=[(e=ww(e))[0]].concat(e.slice(2)),n=this.layer.computeOutputShape(t),a=e[1];return[n[0],a].concat(n.slice(1))}call(e,t){return Lu((()=>lS(((e,n)=>[vw(this.layer.call(e,t)),[]]),e=vw(e),[],!1,null,null,!1,!0)[1]))}}mN.className="TimeDistributed",Vd(mN);class gN extends fN{constructor(e){super(e);const t=e.layer.getConfig(),n={};n.className=e.layer.getClassName(),n.config=t,this.forwardLayer=lk(n),t.goBackwards=!0!==t.goBackwards;const a={};var r;if(a.className=e.layer.getClassName(),a.config=t,this.backwardLayer=lk(a),this.forwardLayer.name="forward_"+this.forwardLayer.name,this.backwardLayer.name="backward_"+this.backwardLayer.name,this.mergeMode=void 0===e.mergeMode?"concat":e.mergeMode,r=this.mergeMode,av(gv,"BidirectionalMergeMode",r),e.weights)throw new Wx("weights support is not implemented for Bidirectional layer yet.");this._stateful=e.layer.stateful,this.returnSequences=e.layer.returnSequences,this.returnState=e.layer.returnState,this.supportsMasking=!0,this._trainable=!0,this.inputSpec=e.layer.inputSpec,this.numConstants=null}get trainable(){return this._trainable}set trainable(e){this._trainable=e,null!=this.forwardLayer&&(this.forwardLayer.trainable=e),null!=this.backwardLayer&&(this.backwardLayer.trainable=e)}getWeights(){return this.forwardLayer.getWeights().concat(this.backwardLayer.getWeights())}setWeights(e){const t=e.length,n=Math.floor(t/2);this.forwardLayer.setWeights(e.slice(0,n)),this.backwardLayer.setWeights(e.slice(n))}computeOutputShape(e){let t,n,a,r=this.forwardLayer.computeOutputShape(e);return Array.isArray(r)&&Array.isArray(r[0])||(r=[r]),this.returnState?(a=r.slice(1),t=r[0]):t=r[0],"concat"===this.mergeMode?(t[t.length-1]*=2,n=[t]):n=null==this.mergeMode?[t,t.slice()]:[t],this.returnState?null==this.mergeMode?n.concat(a).concat(a.slice()):[t].concat(a).concat(a.slice()):Kx(n)}apply(e,t){let n=null==t?null:t.initialState,a=null==t?null:t.constants;null==t&&(t={});const r=cS(e,n,a,this.numConstants);if(e=r.inputs,n=r.initialState,a=r.constants,Array.isArray(e)&&(n=e.slice(1),e=e[0]),(null==n||0===n.length)&&null==a)return super.apply(e,t);const o=[],s=[];if(null!=n){const e=n.length;if(e%2>0)throw new Bx("When passing `initialState` to a Bidrectional RNN, the state should be an Array containing the states of the underlying RNNs.");t.initialState=n,o.push(...n);const a=n.map((e=>new Tw({shape:e.shape})));this.forwardLayer.stateSpec=a.slice(0,e/2),this.backwardLayer.stateSpec=a.slice(e/2),s.push(...a)}if(null!=a)throw new Wx("Support for constants in Bidirectional layers is not implemented yet.");const i=o[0]instanceof Ew;for(const c of o)if(c instanceof Ew!==i)throw new Bx("The initial state of a Bidirectional layer cannot be specified as a mix of symbolic and non-symbolic tensors");if(i){const n=[e].concat(o),a=this.inputSpec.concat(s),r=this.inputSpec;this.inputSpec=a;const i=super.apply(n,t);return this.inputSpec=r,i}return super.apply(e,t)}call(e,t){return Lu((()=>{const n=t.initialState;let a,r,o,s;if(null==n)a=this.forwardLayer.call(e,t),r=this.backwardLayer.call(e,t);else{const o=n.slice(0,n.length/2),s=n.slice(n.length/2);a=this.forwardLayer.call(e,Object.assign(t,{initialState:o})),r=this.backwardLayer.call(e,Object.assign(t,{initialState:s}))}return this.returnState&&(Array.isArray(a)&&(o=a.slice(1).concat(r.slice(1))),a=a[0],r=r[0]),this.returnSequences&&(r=ff(r,1)),"concat"===this.mergeMode?s=Bv([a,r]):"sum"===this.mergeMode?s=Ed(a,r):"ave"===this.mergeMode?s=Ad(.5,Ed(a,r)):"mul"===this.mergeMode?s=Ad(a,r):null==this.mergeMode&&(s=[a,r]),this.returnState?null==this.mergeMode?s.concat(o):[s].concat(o):s}))}resetStates(e){this.forwardLayer.resetStates(),this.backwardLayer.resetStates()}build(e){Iv(this.forwardLayer.name,(()=>{this.forwardLayer.build(e)})),Iv(this.backwardLayer.name,(()=>{this.backwardLayer.build(e)})),this.built=!0}computeMask(e,t){let n;if(Array.isArray(t)&&(t=t[0]),n=this.returnSequences?null==this.mergeMode?[t,t]:t:null==this.mergeMode?[null,null]:null,this.returnState){const e=this.forwardLayer.states.map((e=>null));return Array.isArray(n)?n.concat(e).concat(e):[n].concat(e).concat(e)}return n}get trainableWeights(){return this.forwardLayer.trainableWeights.concat(this.backwardLayer.trainableWeights)}get nonTrainableWeights(){return this.forwardLayer.nonTrainableWeights.concat(this.backwardLayer.nonTrainableWeights)}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),null!=this.forwardLayer&&this.forwardLayer.setFastWeightInitDuringBuild(e),null!=this.backwardLayer&&this.backwardLayer.setFastWeightInitDuringBuild(e)}getConfig(){const e={mergeMode:this.mergeMode},t=super.getConfig();return Object.assign(e,t),e}static fromConfig(e,t){const n=lk(t.layer);if(delete t.layer,null!=t.numConstants)throw new Wx("Deserialization of a Bidirectional layer with numConstants present is not supported yet.");const a=t;return a.layer=n,new e(a)}}gN.className="Bidirectional",Vd(gN);class bN extends Fw{constructor(e){super(e),this.scale=e.scale,e.offset?this.offset=e.offset:this.offset=0}getConfig(){const e={scale:this.scale,offset:this.offset},t=super.getConfig();return Object.assign(e,t),e}call(e,t){return Lu((()=>("float32"!==(e=vw(e)).dtype&&(e=Dv(e,"float32")),Ed(Ad(e,this.scale),this.offset))))}}bN.className="Rescaling",Vd(bN);const{resizeBilinear:yN,cropAndResize:xN}=Pm;class vN extends Fw{constructor(e){super(e),this.height=e.height,this.width=e.width}centerCrop(e,t,n,a,r,o,s,i){return Lu((()=>{let c,l=!1;const u=[t/o,n/s,(a+t)/o,(r+n)/s],d=[];3===e.rank?(l=!0,c=Tf([e])):c=e;for(let e=0;e<c.shape[0];e++)d.push(u);const h=Fu(d,[d.length,4]),p=hf(0,d.length,1,"int32"),f=xN(c,h,p,[a,r],"nearest");return Dv(l?vw(Ff(f)):f,i)}))}upsize(e,t,n,a){return Lu((()=>Dv(yN(e,[t,n]),a)))}call(e,t){return Lu((()=>{const t=vw(e),n=t.dtype,a=t.shape,r=a[a.length-3],o=a[a.length-2];let s=0;r!==this.height&&(s=Math.floor((r-this.height)/2));let i=0;return o!==this.width&&(i=Math.floor((o-this.width)/2),0===i&&(i=1)),s>=0&&i>=0?this.centerCrop(t,s,i,this.height,this.width,r,o,n):this.upsize(e,this.height,this.width,n)}))}getConfig(){const e={height:this.height,width:this.width},t=super.getConfig();return Object.assign(e,t),e}computeOutputShape(e){const t=(e=ww(e)).length-3,n=e.length-2;return e[t]=this.height,e[n]=this.width,e}}vN.className="CenterCrop",Vd(vN);class wN extends Fw{constructor(e){super(e),this.numTokens=e.numTokens,e.outputMode?this.outputMode=e.outputMode:this.outputMode="multiHot"}getConfig(){const e={numTokens:this.numTokens,outputMode:this.outputMode},t=super.getConfig();return Object.assign(e,t),e}computeOutputShape(e){return null==(e=ww(e))?[this.numTokens]:"oneHot"===this.outputMode&&1!==e[e.length-1]?(e.push(this.numTokens),e):(e[e.length-1]=this.numTokens,e)}call(e,t){return Lu((()=>{let n;if("int32"!==(e=vw(e)).dtype&&(e=Dv(e,"int32")),"undefined"!==typeof t.countWeights){if("count"!==this.outputMode)throw new Bx("countWeights is not used when outputMode !== count.\n              Received countWeights=".concat(t.countWeights));n=vw(t.countWeights)}const a=Fp(e),r=Yp(e),o=Tp(this.numTokens,a).bufferSync().get(0),s=Ep(r,0).bufferSync().get(0);if(!o||!s)throw new Bx("Input values must be between 0 < values <="+" numTokens with numTokens=".concat(this.numTokens));return function(e,t,n,a){let r=vw(e);if("int32"!==r.dtype&&(r=Dv(r,"int32")),"int"===t)return r;const o=r.shape;if(0===r.rank&&(r=kp(r,-1)),"oneHot"===t&&1!==r.shape[r.shape.length-1]&&(r=kp(r,-1)),r.rank>2)throw new Bx("When outputMode is not int, maximum output rank is 2"+" Received outputMode ".concat(t," and input shape ").concat(o)+" which would result in output rank ".concat(r.rank,"."));const s=["multiHot","oneHot"].includes(t),i=r;let c;if(c=bp(i,"undefined"!==typeof a&&"count"===t?a:[],n,s),"tfIdf"!==t)return c;if(a)return Ad(c,a);throw new Bx("When outputMode is 'tfIdf', weights must be provided.")}(e,this.outputMode,this.numTokens,n)}))}}wN.className="CategoryEncoding",Vd(wN);const kN=new Set(["bilinear","nearest"]);class IN extends Fw{constructor(e){if(super(e),this.height=e.height,this.width=e.width,e.interpolation){if(!kN.has(e.interpolation))throw new Bx("Invalid interpolation parameter: ".concat(e.interpolation," is not implemented"));this.interpolation=e.interpolation}else this.interpolation="bilinear";this.cropToAspectRatio=Boolean(e.cropToAspectRatio)}computeOutputShape(e){const t=(e=ww(e))[2];return[this.height,this.width,t]}getConfig(){const e={height:this.height,width:this.width,interpolation:this.interpolation,cropToAspectRatio:this.cropToAspectRatio},t=super.getConfig();return Object.assign(e,t),e}call(e,t){return Lu((()=>{const t=[this.height,this.width];if("bilinear"===this.interpolation)return Pm.resizeBilinear(e,t,!this.cropToAspectRatio);if("nearest"===this.interpolation)return Pm.resizeNearestNeighbor(e,t,!this.cropToAspectRatio);throw new Error("Interpolation is ".concat(this.interpolation," but only ").concat([...kN]," are supported"))}))}}IN.className="Resizing",Vd(IN);class SN{constructor(e){this.seed=e}next(){if(void 0!==this.seed)return this.seed++}}SN.className="RandomSeed";class NN extends Fw{constructor(e){super(e),this.randomGenerator=new SN(e.seed)}getConfig(){const e={seed:this.randomGenerator.seed},t=super.getConfig();return Object.assign(e,t),e}}NN.className="BaseRandomLayer";const CN=new Set(["bilinear","nearest"]);class TN extends NN{constructor(e){super(e);const{factor:t,interpolation:n="bilinear"}=e;if(this.factor=t,Array.isArray(this.factor)&&2===this.factor.length)this.widthLower=this.factor[0],this.widthUpper=this.factor[1];else{if(Array.isArray(this.factor)||!(this.factor>0))throw new Bx("Invalid factor: ".concat(this.factor,". Must be positive number or tuple of 2 numbers"));this.widthLower=-this.factor,this.widthUpper=this.factor}if(this.widthLower<-1||this.widthUpper<-1)throw new Bx("factor must have values larger than -1. Got: ".concat(this.factor));if(this.widthUpper<this.widthLower)throw new Bx("factor cannot have upper bound less than lower bound.\n        Got upper bound: ".concat(this.widthUpper,".\n        Got lower bound: ").concat(this.widthLower,"\n      "));if(n){if(!CN.has(n))throw new Bx("Invalid interpolation parameter: ".concat(n," is not implemented"));this.interpolation=n}}getConfig(){const e={factor:this.factor,interpolation:this.interpolation},t=super.getConfig();return Object.assign(e,t),e}computeOutputShape(e){const t=(e=ww(e))[2];return[this.imgHeight,-1,t]}call(e,t){return Lu((()=>{const t=vw(e);this.imgHeight=t.shape[t.shape.length-3];const n=t.shape[t.shape.length-2];this.widthFactor=df([1],1+this.widthLower,1+this.widthUpper,"float32",this.randomGenerator.next());let a=this.widthFactor.dataSync()[0]*n;a=Math.round(a);const r=[this.imgHeight,a];switch(this.interpolation){case"bilinear":return Pm.resizeBilinear(e,r);case"nearest":return Pm.resizeNearestNeighbor(e,r);default:throw new Error("Interpolation is ".concat(this.interpolation,"\n          but only ").concat([...CN]," are supported"))}}))}}TN.className="RandomWidth",Vd(TN);var EN,RN;Vo().registerFlag("KEEP_INTERMEDIATE_TENSORS",(()=>!1),(e=>{e&&console.warn("Keep intermediate tensors is ON. This will print the values of all intermediate tensors during model inference. Not all models support this mode. For details, check e2e/benchmarks/ model_config.js. This significantly impacts performance.")})),function(e){e[e.DT_INVALID=0]="DT_INVALID",e[e.DT_FLOAT=1]="DT_FLOAT",e[e.DT_DOUBLE=2]="DT_DOUBLE",e[e.DT_INT32=3]="DT_INT32",e[e.DT_UINT8=4]="DT_UINT8",e[e.DT_INT16=5]="DT_INT16",e[e.DT_INT8=6]="DT_INT8",e[e.DT_STRING=7]="DT_STRING",e[e.DT_COMPLEX64=8]="DT_COMPLEX64",e[e.DT_INT64=9]="DT_INT64",e[e.DT_BOOL=10]="DT_BOOL",e[e.DT_QINT8=11]="DT_QINT8",e[e.DT_QUINT8=12]="DT_QUINT8",e[e.DT_QINT32=13]="DT_QINT32",e[e.DT_BFLOAT16=14]="DT_BFLOAT16",e[e.DT_QINT16=15]="DT_QINT16",e[e.DT_QUINT16=16]="DT_QUINT16",e[e.DT_UINT16=17]="DT_UINT16",e[e.DT_COMPLEX128=18]="DT_COMPLEX128",e[e.DT_HALF=19]="DT_HALF",e[e.DT_RESOURCE=20]="DT_RESOURCE",e[e.DT_VARIANT=21]="DT_VARIANT",e[e.DT_UINT32=22]="DT_UINT32",e[e.DT_UINT64=23]="DT_UINT64",e[e.DT_FLOAT_REF=101]="DT_FLOAT_REF",e[e.DT_DOUBLE_REF=102]="DT_DOUBLE_REF",e[e.DT_INT32_REF=103]="DT_INT32_REF",e[e.DT_UINT8_REF=104]="DT_UINT8_REF",e[e.DT_INT16_REF=105]="DT_INT16_REF",e[e.DT_INT8_REF=106]="DT_INT8_REF",e[e.DT_STRING_REF=107]="DT_STRING_REF",e[e.DT_COMPLEX64_REF=108]="DT_COMPLEX64_REF",e[e.DT_INT64_REF=109]="DT_INT64_REF",e[e.DT_BOOL_REF=110]="DT_BOOL_REF",e[e.DT_QINT8_REF=111]="DT_QINT8_REF",e[e.DT_QUINT8_REF=112]="DT_QUINT8_REF",e[e.DT_QINT32_REF=113]="DT_QINT32_REF",e[e.DT_BFLOAT16_REF=114]="DT_BFLOAT16_REF",e[e.DT_QINT16_REF=115]="DT_QINT16_REF",e[e.DT_QUINT16_REF=116]="DT_QUINT16_REF",e[e.DT_UINT16_REF=117]="DT_UINT16_REF",e[e.DT_COMPLEX128_REF=118]="DT_COMPLEX128_REF",e[e.DT_HALF_REF=119]="DT_HALF_REF",e[e.DT_RESOURCE_REF=120]="DT_RESOURCE_REF",e[e.DT_VARIANT_REF=121]="DT_VARIANT_REF",e[e.DT_UINT32_REF=122]="DT_UINT32_REF",e[e.DT_UINT64_REF=123]="DT_UINT64_REF"}(EN||(EN={})),function(e){let t;!function(e){e[e.LEGACY=0]="LEGACY",e[e.V1=1]="V1",e[e.V2=2]="V2"}(t=e.CheckpointFormatVersion||(e.CheckpointFormatVersion={}))}(RN||(RN={}));Error;new Set(["Switch","Merge","Enter","Exit","NextIteration","StatelessIf","StatelessWhile","if","While"]),new Set(["NonMaxSuppressionV2","NonMaxSuppressionV3","NonMaxSuppressionV5","Where"]),new Set(["HashTable","HashTableV2","LookupTableImport","LookupTableImportV2","LookupTableFind","LookupTableFindV2","LookupTableSize","LookupTableSizeV2"]);function _N(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:new Map,a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:new Set;if(null==e)return null;if("function"===typeof Blob&&e instanceof Blob)return e.slice();if(a.has(e))throw new Error("Circular references are not supported.");if(n.has(e))return n.get(e);const r=t(e);if(r.recurse&&null!==r.value)throw new Error("A deep map function may not return both a value and recurse=true.");if(r.recurse){if(DN(e)){const r=Array.isArray(e)?[]:{};a.add(e);for(const o in e){const s=_N(e[o],t,n,a);r[o]=s}return a.delete(e),e.__proto__&&(r.__proto__=e.__proto__),r}throw new Error("Can't recurse into non-iterable type: ".concat(e))}return n.set(e,r.value),r.value}function AN(e){return FN(e,arguments.length>1&&void 0!==arguments[1]?arguments[1]:ON)}function FN(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:new Set;const a=e[0];if(n.has(a))throw new Error("Circular references are not supported.");const r=t(e);if(r.recurse&&null!==r.value)throw new Error("A deep zip function may not return both a value and recurse=true.");if(r.recurse){if(DN(a)){const r=Array.isArray(a)?[]:{};n.add(a);for(const o in a){const a=FN(e.map((e=>e[o])),t,n);r[o]=a}return n.delete(a),r}throw new Error("Can't recurse into non-iterable type: ".concat(a))}return r.value}function ON(e){return null===e?null:DN(e[0])?{value:null,recurse:!0}:{value:e,recurse:!1}}function DN(e){let t=!1;if(Vo().get("IS_BROWSER"))t=e instanceof TextDecoder;else{const{StringDecoder:a}=n(222);t=e instanceof a}return null!=e&&!ArrayBuffer.isView(e)&&(Array.isArray(e)||"object"===typeof e&&!(e instanceof Jl)&&!(e instanceof Promise)&&!t)}function MN(e){return function(e,t){return _N(e,t)}(e,LN)}function LN(e){return e instanceof Jl?{value:e.clone(),recurse:!1}:DN(e)?{value:null,recurse:!0}:{value:e,recurse:!1}}class PN{constructor(e){if(this.capacity=e,this.begin=0,this.end=0,null==e)throw new RangeError("Can't create a ring buffer of unknown capacity.");if(e<1)throw new RangeError("Can't create ring buffer of capacity < 1.");this.data=new Array(e),this.doubledCapacity=2*e}wrap(e){for(;e<0;)e+=this.doubledCapacity;return e%this.doubledCapacity}get(e){if(e<0)throw new RangeError("Can't get item at a negative index.");return this.data[e%this.capacity]}set(e,t){if(e<0)throw new RangeError("Can't set item at a negative index.");this.data[e%this.capacity]=t}length(){let e=this.end-this.begin;return e<0&&(e=this.doubledCapacity+e),e}isFull(){return this.length()===this.capacity}isEmpty(){return 0===this.length()}push(e){if(this.isFull())throw new RangeError("Ring buffer is full.");this.set(this.end,e),this.end=this.wrap(this.end+1)}pushAll(e){for(const t of e)this.push(t)}pop(){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");this.end=this.wrap(this.end-1);const e=this.get(this.end);return this.set(this.end,void 0),e}unshift(e){if(this.isFull())throw new RangeError("Ring buffer is full.");this.begin=this.wrap(this.begin-1),this.set(this.begin,e)}shift(){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");const e=this.get(this.begin);return this.set(this.begin,void 0),this.begin=this.wrap(this.begin+1),e}shuffleExcise(e){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");const t=this.wrap(this.begin+e),n=this.get(t);return this.set(t,this.pop()),n}}class zN extends PN{constructor(){super(zN.INITIAL_CAPACITY)}isFull(){return!1}push(e){super.isFull()&&this.expand(),super.push(e)}unshift(e){super.isFull()&&this.expand(),super.unshift(e)}expand(){const e=2*this.capacity,t=new Array(e),n=this.length();for(let a=0;a<n;a++)t[a]=this.get(this.wrap(this.begin+a));this.data=t,this.capacity=e,this.doubledCapacity=2*this.capacity,this.begin=0,this.end=n}}function BN(e){return new GN(e)}function WN(e,t){return new eC(e,t)}zN.INITIAL_CAPACITY=32;class VN{async toArray(){const e=[];let t=await this.next();for(;!t.done;)e.push(t.value),t=await this.next();return e}async toArrayForTest(){const e=this.prefetch(100),t=[];let n=await e.next();for(;!n.done;)t.push(n.value),n=await e.next();return t}async resolveFully(){let e=await this.next();for(;!e.done;)e=await this.next()}async resolveWhile(e){let t=await this.next(),n=e(t.value);for(;!t.done&&n;)t=await this.next(),n=e(t.value)}handleErrors(e){return new QN(this,e)}filter(e){return new XN(this,e)}map(e){return new YN(this,e)}mapAsync(e){return new JN(this,e)}serialMapAsync(e){return new JN(this,e).serial()}flatmap(e){return new $N(this,e)}async forEachAsync(e){return this.map(e).resolveFully()}async serialForEach(e){return this.serialMapAsync(e).resolveWhile((e=>!0===e))}rowMajorBatch(e){return new qN(this,e,!(arguments.length>1&&void 0!==arguments[1])||arguments[1])}columnMajorBatch(e){let t=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:ON;return this.rowMajorBatch(e,t).map((e=>AN(e,n)))}concatenate(e,t){return new eC(new UN([this,e]),t)}take(e){return e<0||null==e?this:new KN(this,e)}skip(e){return e<0||null==e?this:new jN(this,e)}prefetch(e){return new nC(this,e)}shuffle(e,t){return new aC(this,e,t)}serial(){return new HN(this)}}class UN extends VN{constructor(e){super(),this.items=e,this.trav=0}summary(){return"Array of ".concat(this.items.length," items")}async next(){if(this.trav>=this.items.length)return{value:null,done:!0};const e=this.items[this.trav];return this.trav++,{value:MN(e),done:!1}}}class GN extends VN{constructor(e){super(),this.nextFn=e}summary(){return"Function call"}async next(){try{return this.nextFn()}catch(D){throw D.message="Error thrown while iterating through a dataset: ".concat(D.message),D}}}class HN extends VN{constructor(e){super(),this.upstream=e,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return"".concat(this.upstream.summary()," -> Serial")}async next(){return this.lastRead=this.lastRead.then((()=>this.serialNext())),this.lastRead}async serialNext(){return this.upstream.next()}}class jN extends VN{constructor(e,t){super(),this.upstream=e,this.maxCount=t,this.count=0,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return"".concat(this.upstream.summary()," -> Skip")}async next(){return this.lastRead=this.lastRead.then((()=>this.serialNext())),this.lastRead}async serialNext(){for(;this.count++<this.maxCount;){const e=await this.upstream.next();if(e.done)return e;Pu(e.value)}return this.upstream.next()}}class KN extends VN{constructor(e,t){super(),this.upstream=e,this.maxCount=t,this.count=0}summary(){return"".concat(this.upstream.summary()," -> Take")}async next(){return this.count++>=this.maxCount?{value:null,done:!0}:this.upstream.next()}}class qN extends VN{constructor(e,t){let n=!(arguments.length>2&&void 0!==arguments[2])||arguments[2];super(),this.upstream=e,this.batchSize=t,this.enableSmallLastBatch=n,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return"".concat(this.upstream.summary()," -> RowMajorBatch")}async next(){return this.lastRead=this.lastRead.then((()=>this.serialNext())),this.lastRead}async serialNext(){const e=[];for(;e.length<this.batchSize;){const t=await this.upstream.next();if(t.done)return this.enableSmallLastBatch&&e.length>0?{value:e,done:!1}:{value:null,done:!0};e.push(t.value)}return{value:e,done:!1}}}class XN extends VN{constructor(e,t){super(),this.upstream=e,this.predicate=t,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return"".concat(this.upstream.summary()," -> Filter")}async next(){return this.lastRead=this.lastRead.then((()=>this.serialNext())),this.lastRead}async serialNext(){for(;;){const e=await this.upstream.next();if(e.done||this.predicate(e.value))return e;Pu(e.value)}}}class YN extends VN{constructor(e,t){super(),this.upstream=e,this.transform=t}summary(){return"".concat(this.upstream.summary()," -> Map")}async next(){const e=await this.upstream.next();if(e.done)return{value:null,done:!0};const t=hu(e.value),n=this.transform(e.value),a=hu(n);for(const r of t)du(r,a)||r.dispose();return{value:n,done:!1}}}class QN extends VN{constructor(e,t){super(),this.upstream=e,this.handler=t,this.count=0,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return"".concat(this.upstream.summary()," -> handleErrors")}async next(){return this.lastRead=this.lastRead.then((()=>this.serialNext())),this.lastRead}async serialNext(){for(;;)try{return await this.upstream.next()}catch(D){if(!this.handler(D))return{value:null,done:!0}}}}class JN extends VN{constructor(e,t){super(),this.upstream=e,this.transform=t}summary(){return"".concat(this.upstream.summary()," -> AsyncMap")}async next(){const e=await this.upstream.next();if(e.done)return{value:null,done:!0};const t=hu(e.value),n=await this.transform(e.value),a=hu(n);for(const r of t)du(r,a)||r.dispose();return{value:n,done:!1}}}class ZN extends VN{constructor(){super(),this.outputQueue=new zN,this.lastRead=Promise.resolve({value:null,done:!1})}async next(){return this.lastRead=this.lastRead.then((()=>this.serialNext())),this.lastRead}async serialNext(){for(;0===this.outputQueue.length();)if(!await this.pump())return{value:null,done:!0};return{value:this.outputQueue.shift(),done:!1}}}class $N extends ZN{constructor(e,t){super(),this.upstream=e,this.transform=t}summary(){return"".concat(this.upstream.summary()," -> Flatmap")}async pump(){const e=await this.upstream.next();if(e.done)return!1;const t=hu(e.value),n=this.transform(e.value),a=hu(n);this.outputQueue.pushAll(n);for(const r of t)du(r,a)||r.dispose();return!0}}class eC extends VN{constructor(e,t){super(),this.baseErrorHandler=t,this.lastRead=null,this.iterator=null,this.moreIterators=e}summary(){return"".concat("TODO: fill in upstream of chained summaries"," -> Chained")}async next(){return this.lastRead=this.readFromChain(this.lastRead),this.lastRead}async readFromChain(e){if(await e,null==this.iterator){const e=await this.moreIterators.next();if(e.done)return{value:null,done:!0};this.iterator=e.value,null!=this.baseErrorHandler&&(this.iterator=this.iterator.handleErrors(this.baseErrorHandler))}const t=await this.iterator.next();return t.done?(this.iterator=null,this.readFromChain(e)):t}}var tC;!function(e){e[e.FAIL=0]="FAIL",e[e.SHORTEST=1]="SHORTEST",e[e.LONGEST=2]="LONGEST"}(tC||(tC={}));class nC extends VN{constructor(e,t){super(),this.upstream=e,this.bufferSize=t,this.buffer=new PN(t)}summary(){return"".concat(this.upstream.summary()," -> Prefetch")}refill(){for(;!this.buffer.isFull();){const e=this.upstream.next();this.buffer.push(e)}}next(){return this.refill(),this.buffer.shift()}}class aC extends nC{constructor(e,t,n){super(e,t),this.upstream=e,this.windowSize=t,this.upstreamExhausted=!1,this.random=sf.alea(n||Al().toString()),this.lastRead=Promise.resolve({value:null,done:!1})}async next(){return this.lastRead=this.lastRead.then((()=>this.serialNext())),this.lastRead}randomInt(e){return Math.floor(this.random()*e)}chooseIndex(){return this.randomInt(this.buffer.length())}async serialNext(){for(this.upstreamExhausted||this.refill();!this.buffer.isEmpty();){const e=this.chooseIndex(),t=await this.buffer.shuffleExcise(e);if(!t.done)return this.refill(),t;this.upstreamExhausted=!0}return{value:null,done:!0}}}class rC{constructor(){this.size=null}batch(e){let t=!(arguments.length>1&&void 0!==arguments[1])||arguments[1];const n=this;let a;return so(e>0,(()=>"batchSize needs to be positive, but it is\n      ".concat(e))),a=this.size===1/0||null==this.size?this.size:t?Math.ceil(this.size/e):Math.floor(this.size/e),oC((async()=>(await n.iterator()).columnMajorBatch(e,t,sC)),a)}concatenate(e){const t=this;let n;return n=this.size===1/0||e.size===1/0?1/0:null!=this.size&&null!=e.size?this.size+e.size:null,oC((async()=>(await t.iterator()).concatenate(await e.iterator())),n)}filter(e){const t=this;let n;return n=this.size===1/0?1/0:null,oC((async()=>(await t.iterator()).filter((t=>Lu((()=>e(t)))))),n)}async forEachAsync(e){return(await this.iterator()).forEachAsync(e)}map(e){const t=this;return oC((async()=>(await t.iterator()).map((t=>Lu((()=>e(t)))))),this.size)}mapAsync(e){const t=this;return oC((async()=>(await t.iterator()).mapAsync(e)),this.size)}prefetch(e){if(null==e)throw new RangeError("`Dataset.prefetch()` requires bufferSize to be specified.");const t=this;return oC((async()=>(await t.iterator()).prefetch(e)),this.size)}repeat(e){const t=this;let n;return n=null!=this.size&&e>0?this.size*e:0===e?0:null!=this.size&&(void 0===e||e<0)?1/0:null,oC((async()=>WN(BN((async()=>({value:await t.iterator(),done:!1}))).take(e))),n)}skip(e){const t=this;let n;return n=null!=this.size&&e>=0&&this.size>=e?this.size-e:null!=this.size&&(this.size<e||void 0===e||e<0)?0:null,oC((async()=>(await t.iterator()).skip(e)),n)}shuffle(e,t){let n=!(arguments.length>2&&void 0!==arguments[2])||arguments[2];if(null==e||e<0)throw null==this.size?new RangeError("`Dataset.shuffle()` requires bufferSize to be specified."):new RangeError("`Dataset.shuffle()` requires bufferSize to be specified.  If your data fits in main memory (for regular JS objects), and/or GPU memory (for `tf.Tensor`s), consider setting "+"bufferSize to the dataset size (".concat(this.size," elements)"));const a=this,r=sf.alea(t||Al().toString());return oC((async()=>{let t=r.int32();return n&&(t+=r.int32()),(await a.iterator()).shuffle(e,t.toString())}),this.size)}take(e){const t=this;let n;return n=null!=this.size&&this.size>e?e:null!=this.size&&this.size<=e?this.size:null,oC((async()=>(await t.iterator()).take(e)),n)}async toArray(){if(this.size===1/0)throw new Error("Can not convert infinite data stream to array.");return(await this.iterator()).toArray()}async toArrayForTest(){if(this.size===1/0)throw new Error("Can not convert infinite data stream to array.");return(await this.iterator()).toArrayForTest()}}function oC(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;return new class extends rC{constructor(){super(...arguments),this.size=t}async iterator(){return e()}}}function sC(e){if(null===e)return null;if(function(e){return null==e||null===(t=e)||"object"!==typeof t&&"function"!==typeof t||Array.isArray(e)||"object"===typeof e&&e instanceof Jl||Dl(e);var t}(e[0])){return{value:function(e){if(0===e.length)throw new Error("Can't make a batch of zero elements.");return e[0]instanceof Jl?Tf(e):Fu(e)}(e),recurse:!1}}return{value:null,recurse:!0}}rC.MAX_BUFFER_SIZE=1e4;Symbol("out"),Symbol("field"),Symbol("quote"),Symbol("quoteafterquote"),Symbol("quoteinquote");function iC(e,t){Array.isArray(e)||(e=[e]),e.forEach((e=>{null!=e&&so("complex64"!==e.dtype,(()=>"".concat(t," does not support complex64 tensors in the CPU backend.")))}))}const cC=Jg;class lC extends eo{nextDataId(){return lC.nextDataId++}constructor(){super(),this.blockSize=48,this.firstUse=!0,this.data=new $r(this,Du())}write(e,t,n){this.firstUse&&(this.firstUse=!1,Vo().get("IS_NODE")&&al("\n============================\nHi, looks like you are running TensorFlow.js in Node.js. To speed things up dramatically, install our node backend, visit https://github.com/tensorflow/tfjs-node for more details. \n============================"));const a={id:this.nextDataId()};return this.data.set(a,{values:e,dtype:n,refCount:1}),a}makeTensorInfo(e,t,n){let a;if("string"===t&&null!=n&&n.length>0&&Io(n[0])){const r=n.map((e=>Fl(e)));a=this.write(r,e,t)}else a=this.write(n,e,t);return{dataId:a,shape:e,dtype:t}}refCount(e){if(this.data.has(e)){return this.data.get(e).refCount}return 0}incRef(e){this.data.get(e).refCount++}decRef(e){if(this.data.has(e)){this.data.get(e).refCount--}}move(e,t,n,a,r){this.data.set(e,{values:t,dtype:a,refCount:r})}numDataIds(){return this.data.numDataIds()}async read(e){return this.readSync(e)}readSync(e){const{dtype:t,complexTensorInfos:n}=this.data.get(e);if("complex64"===t){return mg(this.readSync(n.real.dataId),this.readSync(n.imag.dataId))}return function(e,t){if(Array.isArray(e))return e;if("float32"===t)return e instanceof Float32Array?e:new Float32Array(e);if("int32"===t)return e instanceof Int32Array?e:new Int32Array(e);if("bool"===t||"string"===t)return Uint8Array.from(new Int32Array(e));throw new Error("Unknown dtype ".concat(t))}(this.data.get(e).values,t)}bufferSync(e){const t=this.readSync(e.dataId);if("string"===e.dtype)try{const n=t.map((e=>Ol(e)));return Nd(e.shape,e.dtype,n)}catch(n){throw new Error("Failed to decode encoded string bytes into utf-8")}return Nd(e.shape,e.dtype,t)}makeOutput(e,t,n){return Du().makeTensorFromTensorInfo(this.makeTensorInfo(t,n,e),this)}disposeData(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];if(this.data.has(e)){if(this.data.get(e).refCount--,!t&&this.data.get(e).refCount>0)return!1;const{complexTensorInfos:n}=this.data.get(e);null!=n&&(this.disposeData(n.real.dataId,!0),this.disposeData(n.imag.dataId,!0)),this.data.delete(e)}return!0}disposeIntermediateTensorInfo(e){this.disposeData(e.dataId)}async time(e){const t=Al();e();return{kernelMs:Al()-t}}memory(){return{unreliable:!0,reasons:["The reported memory is an upper bound. Due to automatic garbage collection, the true allocated memory may be less."]}}where(e){iC([e],"where");const t=this.readSync(e.dataId);return cC(e.shape,t)}dispose(){}floatPrecision(){return 32}epsilon(){return super.epsilon()}}lC.nextDataId=0;function uC(e){return(t,n,a)=>{const r=vo(n,t.length);for(let o=0;o<t.length;++o)r[o]=e(t[o],a);return r}}function dC(e,t,n){return hC(e,uC(t),n)}function hC(e,t,n){return a=>{let{inputs:r,attrs:o,backend:s}=a;const{x:i}=r;iC(i,e);const c=s,l=c.data.get(i.dataId).values;let u;if("string"===i.dtype){if(!Array.isArray(l))throw new Error("String tensor's value was not an instance of Array");u=Yg(l)}else u=l;const d=n||i.dtype,h=t(u,d,o);return c.makeTensorInfo(i.shape,d,h)}}Wu("cpu",(()=>new lC),1);const pC=dC(Hs,(e=>e>=0?e:Math.exp(e)-1)),fC={kernelName:Hs,backendName:"cpu",kernelFunc:pC};function mC(e){const{inputs:t,backend:n}=e,{x:a}=t;return n.incRef(a.dataId),{dataId:a.dataId,shape:a.shape,dtype:a.dtype}}const gC={kernelName:ii,backendName:"cpu",kernelFunc:mC};function bC(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{alpha:o}=a;iC([r],"leakyRelu");const s=lo(r.shape),i=n.data.get(r.dataId).values,c=xo("float32",s);for(let l=0;l<i.length;l++)c[l]=i[l]<0?o*i[l]:i[l];return n.makeTensorInfo(r.shape,"float32",c)}const yC={kernelName:pi,backendName:"cpu",kernelFunc:bC};function xC(e){return(t,n,a,r,o)=>{const s=Zd(t,n),i=s.length,c=Eo(s),l=xo(o,lo(s)),u=t.length,d=n.length,h=Eo(t),p=Eo(n),f=Qd(t,s),m=Qd(n,s);if(f.length+m.length===0)for(let g=0;g<l.length;++g)l[g]=e(a[g%a.length],r[g%r.length]);else for(let g=0;g<l.length;++g){const t=Lo(g,i,c),n=t.slice(-u);f.forEach((e=>n[e]=0));const o=Mo(n,u,h),s=t.slice(-d);m.forEach((e=>s[e]=0));const b=Mo(s,d,p);l[g]=e(a[o],r[b])}return[l,s]}}const vC=xC(((e,t)=>e<0?t*e:e));function wC(e){const{inputs:t,backend:n}=e,{x:a,alpha:r}=t;iC([a,r],"prelu");const o=n.data.get(a.dataId).values,s=n.data.get(r.dataId).values,[i,c]=vC(a.shape,r.shape,o,s,"float32");return n.makeTensorInfo(c,"float32",i)}const kC={kernelName:Xi,backendName:"cpu",kernelFunc:wC},IC=dC(nc,(e=>Math.max(0,e))),SC={kernelName:nc,backendName:"cpu",kernelFunc:IC},NC=dC(cc,(e=>Math.min(Math.max(0,e),6))),CC={kernelName:cc,backendName:"cpu",kernelFunc:NC},TC=uC((e=>1/(1+Math.exp(-e)))),EC=dC(wc,(e=>1/(1+Math.exp(-e)))),RC={kernelName:wc,backendName:"cpu",kernelFunc:EC};function _C(e,t,n,a,r){if("linear"===n)return mC({inputs:{x:t},backend:e});if("relu"===n)return IC({inputs:{x:t},backend:e});if("elu"===n)return pC({inputs:{x:t},backend:e});if("relu6"===n)return NC({inputs:{x:t},backend:e});if("prelu"===n)return wC({inputs:{x:t,alpha:a},backend:e});if("leakyrelu"===n)return bC({inputs:{x:t},backend:e,attrs:{alpha:r}});if("sigmoid"===n)return EC({inputs:{x:t},backend:e});throw new Error("Activation ".concat(n," has not been implemented for the CPU backend."))}function AC(e){const{inputs:t,backend:n}=e,{real:a,imag:r}=t,o=n.data.get(a.dataId).values,s=n.data.get(r.dataId).values,i=n.makeTensorInfo(a.shape,"complex64");return n.data.get(i.dataId).complexTensorInfos={real:n.makeTensorInfo(a.shape,"float32",o),imag:n.makeTensorInfo(r.shape,"float32",s)},i}const FC={kernelName:ys,backendName:"cpu",kernelFunc:AC};function OC(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"float32";if("complex64"===n){return AC({inputs:{real:OC(e,t,"float32"),imag:OC(e,t,"float32")},backend:e})}const a=Fo(lo(t),n);return e.makeTensorInfo(t,n,a)}function DC(e){const{inputs:t,backend:n}=e,{input:a}=t,r=n.data.get(a.dataId).complexTensorInfos.real,o=n.data.get(r.dataId).values;return n.makeTensorInfo(r.shape,r.dtype,o)}const MC={kernelName:ec,backendName:"cpu",kernelFunc:DC};function LC(e,t,n,a){if("int32"===a){return[t,"int32",Int32Array.from(e)]}if("bool"===a){const a=_l([0],n),[r,o]=xC(((e,t)=>e!==t?1:0))(t,[],e,a,"bool");return[o,"bool",r]}throw new Error("Error in Cast: failed to cast ".concat(n," to ").concat(a))}function PC(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{dtype:o}=a;if("complex64"===o){if("complex64"===r.dtype)return mC({inputs:{x:r},backend:n});const e=OC(n,r.shape,r.dtype),t=PC({inputs:{x:r},backend:n,attrs:{dtype:"float32"}}),a=AC({inputs:{real:t,imag:e},backend:n});return n.disposeIntermediateTensorInfo(e),n.disposeIntermediateTensorInfo(t),a}if("complex64"===r.dtype){const e=DC({inputs:{input:r},backend:n}),t=PC({inputs:{x:e},backend:n,attrs:{dtype:o}});return n.disposeIntermediateTensorInfo(e),t}if(!wo(r.dtype,o)){const e=mC({inputs:{x:r},backend:n});return{dataId:e.dataId,shape:e.shape,dtype:o}}const s=n.data.get(r.dataId).values,[i,c,l]=LC(s,r.shape,r.dtype,o);return n.makeTensorInfo(i,c,l)}const zC={kernelName:ms,backendName:"cpu",kernelFunc:PC};function BC(e,t,n,a){return null==n?n=>{let{inputs:r,backend:o}=n;const{a:s,b:i}=r,c=o;iC([s,i],e);const l=c.data.get(s.dataId).values,u=c.data.get(i.dataId).values,d="string"===s.dtype?Yg(l):l,h="string"===s.dtype?Yg(u):u,p=a||s.dtype,[f,m]=t(s.shape,i.shape,d,h,p);return c.makeTensorInfo(m,p,f)}:e=>{let{inputs:r,backend:o}=e;const{a:s,b:i}=r,c=o;if("complex64"===s.dtype||"complex64"===i.dtype){const e=PC({inputs:{x:s},backend:c,attrs:{dtype:"complex64"}}),t=c.data.get(e.dataId),a=t.complexTensorInfos.real,r=t.complexTensorInfos.imag,o=c.data.get(a.dataId).values,l=c.data.get(r.dataId).values,u=PC({inputs:{x:i},backend:c,attrs:{dtype:"complex64"}}),d=c.data.get(u.dataId),h=d.complexTensorInfos.real,p=d.complexTensorInfos.imag,f=c.data.get(h.dataId).values,m=c.data.get(p.dataId).values,[g,b,y]=n(s.shape,i.shape,o,l,f,m),x=c.makeTensorInfo(y,"float32",g),v=c.makeTensorInfo(y,"float32",b),w=AC({inputs:{real:x,imag:v},backend:c});return c.disposeIntermediateTensorInfo(e),c.disposeIntermediateTensorInfo(u),c.disposeIntermediateTensorInfo(x),c.disposeIntermediateTensorInfo(v),w}{const e=c.data.get(s.dataId).values,n=c.data.get(i.dataId).values,r=a||s.dtype,[o,l]=t(s.shape,i.shape,e,n,r);return c.makeTensorInfo(l,r,o)}}}function WC(e){return(t,n,a,r,o,s)=>{const i=Zd(t,n),c=lo(i),l=i.length,u=Eo(i),d=xo("float32",c),h=xo("float32",c),p=Qd(t,i),f=Qd(n,i),m=mg(a,r),g=mg(o,s),b=t.length,y=Eo(t),x=n.length,v=Eo(n);if(p.length+f.length===0)for(let w=0;w<d.length;w++){const t=w%m.length,n=w%g.length,a=e(m[2*t],m[2*t+1],g[2*n],g[2*n+1]);d[w]=a.real,h[w]=a.imag}else for(let w=0;w<d.length;w++){const t=Lo(w,l,u),n=t.slice(-b);p.forEach((e=>n[e]=0));const a=Mo(n,b,y),r=t.slice(-x);f.forEach((e=>r[e]=0));const o=Mo(r,x,v),s=e(m[2*a],m[2*a+1],g[2*o],g[2*o+1]);d[w]=s.real,h[w]=s.imag}return[d,h,i]}}const VC=xC(((e,t)=>e+t)),UC=WC(((e,t,n,a)=>({real:e+n,imag:t+a}))),GC=BC(Yo,VC,UC),HC={kernelName:Yo,backendName:"cpu",kernelFunc:GC};function jC(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{shape:o}=a,s=lo(r.shape),i=go(o,s),c=lo(i);so(s===c,(()=>"The new shape (".concat(i,") has ").concat(c," elements and the old ")+"shape (".concat(r.shape,") has ").concat(s," elements. The new shape and old ")+"shape must have the same number of elements.")),n.incRef(r.dataId);const l=n.data.get(r.dataId);if(null!=l.complexTensorInfos){const e=l.complexTensorInfos.real,t=l.complexTensorInfos.imag;e.shape=i,t.shape=i}return{dataId:r.dataId,shape:i,dtype:r.dtype}}const KC={kernelName:ac,backendName:"cpu",kernelFunc:jC};function qC(e){const{inputs:t,backend:n,attrs:a}=e,{a:r,b:o}=t,{transposeA:s,transposeB:i}=a;iC([r,o],"matMul");const c=r.shape.length,l=o.shape.length,u=s?r.shape[c-2]:r.shape[c-1],d=i?o.shape[l-1]:o.shape[l-2],h=s?r.shape[c-1]:r.shape[c-2],p=i?o.shape[l-2]:o.shape[l-1],f=r.shape.slice(0,-2),m=o.shape.slice(0,-2),g=lo(f),b=lo(m),y=Zd(r.shape.slice(0,-2),o.shape.slice(0,-2)).concat([h,p]);so(u===d,(()=>"Error in matMul: inner shapes (".concat(u,") and (")+"".concat(d,") of Tensors with shapes ").concat(r.shape," and ")+"".concat(o.shape," and transposeA=").concat(s)+" and transposeB=".concat(i," must match.")));const x=i?[b,p,d]:[b,d,p],v=jC({inputs:{x:r},backend:n,attrs:{shape:s?[g,u,h]:[g,h,u]}}),w=jC({inputs:{x:o},backend:n,attrs:{shape:x}}),k=s?v.shape[1]:v.shape[2],I=s?v.shape[2]:v.shape[1],S=i?w.shape[1]:w.shape[2],N=Math.max(g,b),C=n.data.get(v.dataId).values,T=n.data.get(w.dataId).values,E=Eo(v.shape),R=Eo(w.shape),[_,A,F]=s?[E[0],1,E[1]]:[E[0],E[1],1],[O,D,M]=i?[1,R[1],R[0]]:[R[1],1,R[0]],L=I*S,P=Nd([N,I,S],v.dtype),z=P.values,B=n.blockSize;for(let W=0;W<N;W++){const e=W%g,t=W%b;for(let n=0;n<I;n+=B){const a=Math.min(n+B,I);for(let r=0;r<S;r+=B){const o=Math.min(r+B,S);for(let s=0;s<k;s+=B){const i=Math.min(s+B,k);for(let c=n;c<a;c++)for(let n=r;n<o;n++){let a=0;for(let r=s;r<i;r++){a+=C[e*_+c*A+r*F]*T[r*O+n*D+t*M]}z[W*L+(c*S+n)]+=a}}}}}return n.disposeIntermediateTensorInfo(v),n.disposeIntermediateTensorInfo(w),n.makeTensorInfo(y,P.dtype,P.values)}const XC={kernelName:us,backendName:"cpu",kernelFunc:qC};const YC={kernelName:el,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{a:r,b:o,bias:s,preluActivationWeights:i}=t,{transposeA:c,transposeB:l,activation:u,leakyreluAlpha:d}=a;let h,p,f;const m=[];h=qC({inputs:{a:r,b:o},attrs:{transposeA:c,transposeB:l},backend:n}),s&&(p=GC({inputs:{a:h,b:s},backend:n}),m.push(h),h=p),u&&(f=_C(n,h,u,i,d),m.push(h),h=f);for(const g of m)n.disposeIntermediateTensorInfo(g);return h}};function QC(e){const t=new Float32Array(e.length);for(let n=0;n<e.length;++n)t[n]=Math.abs(e[n]);return t}const JC={kernelName:Ko,backendName:"cpu",kernelFunc:e=>{const{x:t}=e.inputs,n=e.backend;iC(t,"abs");let a=new Float32Array(lo(t.shape));return a=QC(n.data.get(t.dataId).values),n.makeOutput(a,t.shape,t.dtype)}},ZC=dC(qo,(e=>Math.acos(e))),$C={kernelName:qo,backendName:"cpu",kernelFunc:ZC},eT=dC(Xo,(e=>Math.acosh(e))),tT={kernelName:Xo,backendName:"cpu",kernelFunc:eT};const nT={kernelName:Qo,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,a=t;iC(t,"addN");const r=a.map((e=>n.data.get(e.dataId).values)),o=Nd(a[0].shape,a[0].dtype),s=o.values;for(let i=0;i<a.length;i++){const e=r[i];for(let t=0;t<s.length;t++)s[t]+=e[t]}return n.makeTensorInfo(o.shape,o.dtype,o.values)}};function aT(e,t,n,a,r){const o=t.length,s=lo(t),i=Eo(t),c=Eo(r),l=xo(n,lo(r));for(let u=0;u<s;++u){const t=Lo(u,o,i),n=new Array(t.length);for(let e=0;e<n.length;e++)n[e]=t[a[e]];l[Mo(n,o,c)]=e[u]}return l}function rT(e){const{inputs:t,attrs:n,backend:a}=e,{x:r}=t,{perm:o}=n;iC(r,"transpose");const s=r.shape.length,i=new Array(s);for(let l=0;l<i.length;l++)i[l]=r.shape[o[l]];const c=aT(a.data.get(r.dataId).values,r.shape,r.dtype,o,i);return{dataId:a.write(c,i,r.dtype),shape:i,dtype:r.dtype}}const oT={kernelName:Kc,backendName:"cpu",kernelFunc:rT};const sT={kernelName:Jo,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{axis:o,keepDims:s}=a;iC(r,"all");const i=bo(o,r.shape);let c=i;const l=Wp(c,r.shape.length);let u=r;null!=l&&(u=rT({inputs:{x:r},backend:n,attrs:{perm:l}}),c=Up(c.length,r.shape.length)),Bp("all",c,u.shape.length);const[d,h]=Pp(u.shape,c),p=lo(h),f=Fo(lo(d),u.dtype),m=n.data.get(u.dataId).values;for(let b=0;b<f.length;++b){const e=b*p;let t=m[e];for(let n=0;n<p;++n){const a=m[e+n];t=t&&a}f[b]=t}null!=l&&n.disposeIntermediateTensorInfo(u);const g=n.makeTensorInfo(d,u.dtype,f);if(s){const e=jC({inputs:{x:g},backend:n,attrs:{shape:zp(d,i)}});return n.disposeIntermediateTensorInfo(g),e}return g}};const iT={kernelName:Zo,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{axis:o,keepDims:s}=a;iC(r,"any");const i=bo(o,r.shape);let c=i;const l=Wp(c,r.shape.length);let u=r;null!=l&&(u=rT({inputs:{x:r},backend:n,attrs:{perm:l}}),c=Up(c.length,r.shape.length)),Bp("any",c,u.shape.length);const[d,h]=Pp(u.shape,c),p=lo(h),f=Fo(lo(d),u.dtype),m=n.data.get(u.dataId).values;for(let b=0;b<f.length;++b){const e=b*p;let t=m[e];for(let n=0;n<p;++n){const a=m[e+n];t=t||a}f[b]=t}null!=l&&n.disposeIntermediateTensorInfo(u);const g=n.makeTensorInfo(d,u.dtype,f);if(s){const e=jC({inputs:{x:g},backend:n,attrs:{shape:zp(d,i)}});return n.disposeIntermediateTensorInfo(g),e}return g}};const cT={kernelName:$o,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{axis:o}=a;iC(r,"argMax");let s=bo(o,r.shape);const i=Wp(s,r.shape.length);let c=r;const l=[];null!=i&&(c=rT({inputs:{x:r},backend:n,attrs:{perm:i}}),l.push(c),s=Up(s.length,c.shape.length)),s=[s[0]],Bp("argMax",s,c.shape.length);const[u,d]=Pp(c.shape,s),h=Fo(lo(u),"int32"),p=lo(d),f=n.data.get(c.dataId).values;for(let m=0;m<h.length;++m){const e=m*p;let t=f[e],n=0;for(let a=0;a<p;++a){const r=f[e+a];r>t&&(t=r,n=a)}h[m]=n}return l.forEach((e=>n.disposeIntermediateTensorInfo(e))),n.makeTensorInfo(u,"int32",h)}};const lT={kernelName:es,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{axis:o}=a;iC(r,"argMin");let s=bo(o,r.shape);const i=Wp(s,r.shape.length);let c=r;const l=[];null!=i&&(c=rT({inputs:{x:r},backend:n,attrs:{perm:i}}),l.push(c),s=Up(s.length,c.shape.length)),s=[s[0]],Bp("argMin",s,c.shape.length);const[u,d]=Pp(c.shape,s),h=Fo(lo(u),"int32"),p=lo(d),f=n.data.get(c.dataId).values;for(let m=0;m<h.length;++m){const e=m*p;let t=f[e],n=0;for(let a=0;a<p;++a){const r=f[e+a];r<t&&(t=r,n=a)}h[m]=n}return l.forEach((e=>n.disposeIntermediateTensorInfo(e))),n.makeTensorInfo(u,"int32",h)}},uT=dC(ts,(e=>Math.asin(e))),dT={kernelName:ts,backendName:"cpu",kernelFunc:uT},hT=dC(ns,(e=>Math.asinh(e))),pT={kernelName:ns,backendName:"cpu",kernelFunc:hT},fT=dC(as,(e=>Math.atan(e))),mT={kernelName:as,backendName:"cpu",kernelFunc:fT},gT=xC(((e,t)=>Math.atan2(e,t))),bT=BC(os,gT),yT={kernelName:os,backendName:"cpu",kernelFunc:bT},xT=dC(rs,(e=>Math.atanh(e))),vT={kernelName:rs,backendName:"cpu",kernelFunc:xT};function wT(e,t,n,a,r,o){const s=r.strideHeight,i=r.strideWidth,c=r.dilationHeight,l=r.dilationWidth,u=r.effectiveFilterHeight,d=r.effectiveFilterWidth,h=r.padInfo.top,p=r.padInfo.left,f="max"===o?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,m=Nd(r.outShape,n),g=m.values,b=r.outShape[1]*r.outShape[2]*r.outShape[3],y=r.outShape[2]*r.outShape[3],x=r.outShape[3];for(let v=0;v<r.batchSize;++v){const t=v*b,n=v*a[0];for(let m=0;m<r.inChannels;++m)for(let b=0;b<r.outHeight;++b){const v=b*s-h,w=Math.max(0,v),k=Math.min(r.inHeight,u+v),I=t+b*y;for(let t=0;t<r.outWidth;++t){const s=t*i-p,u=Math.max(0,s),h=Math.min(r.inWidth,d+s);let b=f,y=0,v=0;for(let t=w;t<k;t+=c){const r=n+t*a[1];for(let t=u;t<h;t+=l){const n=e[r+t*a[2]+m];"max"===o&&n>b?b=n:"avg"===o&&(y+=n,v++)}if(isNaN(b))break}g[I+t*x+m]="avg"===o?y/v:b}}}return m}function kT(e,t,n,a){let r=arguments.length>4&&void 0!==arguments[4]&&arguments[4],o=arguments.length>5&&void 0!==arguments[5]&&arguments[5];const s=Nd(a.outShape,"int32"),i=a.strideHeight,c=a.strideWidth,l=a.dilationHeight,u=a.dilationWidth,d=a.effectiveFilterHeight,h=a.effectiveFilterWidth,p=a.padInfo.top,f=a.padInfo.left,m=Nd(t,n,e);for(let g=0;g<a.batchSize;++g)for(let e=0;e<a.inChannels;++e)for(let t=0;t<a.outHeight;++t){const n=t*i-p;let b=n;for(;b<0;)b+=l;const y=Math.min(a.inHeight,d+n);for(let i=0;i<a.outWidth;++i){const d=i*c-f;let p=d;for(;p<0;)p+=u;const x=Math.min(a.inWidth,h+d);let v=Number.NEGATIVE_INFINITY,w=-1;for(let t=b;t<y;t+=l){const s=t-n;for(let n=p;n<x;n+=u){const i=n-d,c=m.get(g,t,n,e);c>v&&(v=c,w=r?o?((g*a.inHeight+t)*a.inWidth+n)*a.inChannels+e:(t*a.inWidth+n)*a.inChannels+e:s*h+i)}}s.set(w,g,t,i,e)}}return s}function IT(e,t,n,a,r,o){const s=r.strideDepth,i=r.strideHeight,c=r.strideWidth,l=r.dilationDepth,u=r.dilationHeight,d=r.dilationWidth,h=r.effectiveFilterDepth,p=r.effectiveFilterHeight,f=r.effectiveFilterWidth,m=r.padInfo.front,g=r.padInfo.top,b=r.padInfo.left,y="max"===o?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,x=Nd(r.outShape,n),v=x.values,w=r.outShape[1]*r.outShape[2]*r.outShape[3]*r.outShape[4],k=r.outShape[2]*r.outShape[3]*r.outShape[4],I=r.outShape[3]*r.outShape[4],S=r.outShape[4];for(let N=0;N<r.batchSize;++N){const t=N*w,n=N*a[0];for(let x=0;x<r.inChannels;++x)for(let w=0;w<r.outDepth;++w){const N=w*s-m;let C=N;for(;C<0;)C+=l;const T=Math.min(r.inDepth,h+N),E=t+w*k;for(let t=0;t<r.outHeight;++t){const s=t*i-g;let h=s;for(;h<0;)h+=u;const m=Math.min(r.inHeight,p+s),w=E+t*I;for(let t=0;t<r.outWidth;++t){const s=t*c-b;let i=s;for(;i<0;)i+=d;const p=Math.min(r.inWidth,f+s),g=w+t*S;let k=y,I=0,N=0;for(let t=C;t<T;t+=l){const r=n+t*a[1];for(let t=h;t<m;t+=u){const n=r+t*a[2];for(let t=i;t<p;t+=d){const r=e[n+t*a[3]+x];if("max"===o&&r>k?k=r:"avg"===o&&(I+=r,N++),isNaN(k))break}if(isNaN(k))break}if(isNaN(k))break}v[g+x]="avg"===o?I/Math.max(N,1):k}}}}return x}const ST={kernelName:ss,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t;iC(r,"avgPool");const{filterSize:o,strides:s,pad:i,dimRoundingMode:c}=a;so(Kh(s,1),(()=>"Error in avgPool: Either strides or dilations must be 1. "+"Got strides ".concat(s," and dilations '").concat(1,"'")));const l=Lh(r.shape,o,s,1,i,c);let u;if(1===l.filterWidth&&1===l.filterHeight&&uo(l.inShape,l.outShape))u=mC({inputs:{x:r},backend:n});else{const e=n.data.get(r.dataId).values,t=Eo(r.shape),a=wT(e,r.shape,r.dtype,t,l,"avg");u=n.makeTensorInfo(l.outShape,r.dtype,a.values)}return u}};const NT={kernelName:cs,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{filterSize:o,strides:s,pad:i,dimRoundingMode:c,dataFormat:l}=a;iC(r,"avgPool3d");const u=Ph(r.shape,o,s,1,i,c,l),d=IT(n.data.get(r.dataId).values,r.shape,r.dtype,Eo(r.shape),u,"avg");return n.makeTensorInfo(d.shape,"float32",d.values)}};const CT={kernelName:ls,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{dy:r,input:o}=t,{filterSize:s,strides:i,pad:c,dimRoundingMode:l}=a;iC([r,o],"avgPool3DGrad");const u=Ph(o.shape,s,i,1,c,l),d=u.strideDepth,h=u.strideHeight,p=u.strideWidth,f=u.filterDepth,m=u.filterHeight,g=u.filterWidth,b=u.dilationDepth,y=u.dilationHeight,x=u.dilationWidth,v=u.effectiveFilterDepth,w=u.effectiveFilterHeight,k=u.effectiveFilterWidth,I=v-1-u.padInfo.front,S=k-1-u.padInfo.left,N=w-1-u.padInfo.top,C=Nd(o.shape,"float32"),T=1/(f*m*g),E=n.bufferSync(r);for(let R=0;R<u.batchSize;++R)for(let e=0;e<u.inChannels;++e)for(let t=0;t<u.inDepth;++t)for(let n=0;n<u.inHeight;++n)for(let a=0;a<u.inWidth;++a){const r=t-I,o=n-N,s=a-S;let i=0;for(let t=0;t<v;t+=b){const n=(r+t)/d;if(!(n<0||n>=u.outDepth||Math.floor(n)!==n))for(let t=0;t<w;t+=y){const a=(o+t)/h;if(!(a<0||a>=u.outHeight||Math.floor(a)!==a))for(let t=0;t<k;t+=x){const r=(s+t)/p;if(r<0||r>=u.outWidth||Math.floor(r)!==r)continue;i+=E.get(R,n,a,r,e)}}}C.set(i*T,R,t,n,a,e)}return n.makeTensorInfo(C.shape,C.dtype,C.values)}};const TT={kernelName:is,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{dy:r,input:o}=t,s=o;iC([r,o],"avgPoolGrad");const{filterSize:i,strides:c,pad:l}=a,u=Lh(s.shape,i,c,1,l),d=u.strideHeight,h=u.strideWidth,p=u.filterHeight,f=u.filterWidth,m=u.dilationHeight,g=u.dilationWidth,b=u.effectiveFilterHeight,y=u.effectiveFilterWidth,x=y-1-u.padInfo.left,v=b-1-u.padInfo.top,w=Nd(s.shape,"float32"),k=1/(p*f),I=n.data.get(r.dataId).values,S=Nd(r.shape,"float32",I);for(let N=0;N<u.batchSize;++N)for(let e=0;e<u.inChannels;++e)for(let t=0;t<u.inHeight;++t)for(let n=0;n<u.inWidth;++n){const a=t-v,r=n-x;let o=0;for(let t=0;t<b;t+=m){const n=(a+t)/d;if(!(n<0||n>=u.outHeight||Math.floor(n)!==n))for(let t=0;t<y;t+=g){const a=(r+t)/h;if(a<0||a>=u.outWidth||Math.floor(a)!==a)continue;o+=S.get(N,n,a,e)}}w.set(o*k,N,t,n,e)}return n.makeTensorInfo(w.shape,w.dtype,w.values)}};const ET={kernelName:ni,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r,scale:o,offset:s,mean:i,variance:c}=t;so(i.shape.length===c.shape.length,(()=>"Batch normalization gradient requires mean and variance to have equal ranks.")),so(null==s||i.shape.length===s.shape.length,(()=>"Batch normalization gradient requires mean and offset to have equal ranks.")),so(null==o||i.shape.length===o.shape.length,(()=>"Batch normalization gradient requires mean and scale to have equal ranks.")),iC([r,i,c,o,s],"batchNorm");let{varianceEpsilon:l}=a;null==l&&(l=.001);const u=n.data.get(r.dataId).values,d=n.data.get(i.dataId).values,h=n.data.get(c.dataId).values,p=o?n.data.get(o.dataId).values:new Float32Array([1]),f=s?n.data.get(s.dataId).values:new Float32Array([0]),m=new Float32Array(u.length),g=f.length,b=p.length,y=h.length,x=d.length;let v=0,w=0,k=0,I=0;for(let S=0;S<u.length;++S)m[S]=f[v++]+(u[S]-d[w++])*p[k++]/Math.sqrt(h[I++]+l),v>=g&&(v=0),w>=x&&(w=0),k>=b&&(k=0),I>=y&&(I=0);return n.makeTensorInfo(r.shape,r.dtype,m)}};function RT(e,t,n,a,r){const o=Th(a,t,n),s=lo(n),i=Eo(a);if(o){const n=Eh(t,i);return"string"===r?e.slice(n,n+s):e.subarray(n,n+s)}const c=Nd(a,r,"string"===r?Yg(e):e),l=Nd(n,r);for(let u=0;u<l.size;++u){const e=l.indexToLoc(u),n=e.map(((e,n)=>e+t[n]));l.set(c.get(...n),...e)}return"string"===r?Qg(l.values):l.values}function _T(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{begin:o,size:s}=a;iC(r,"slice");const[i,c]=Rh(r,o,s);mh(r,i,c);const l=RT(n.data.get(r.dataId).values,i,c,r.shape,r.dtype);return n.makeTensorInfo(c,r.dtype,l)}const AT={kernelName:bc,backendName:"cpu",kernelFunc:_T};const FT={kernelName:ds,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{blockShape:o,crops:s}=a;iC([r],"batchToSpaceND");const i=o.reduce(((e,t)=>e*t)),c=Zm(r.shape,o,i),l=$m(c.length,o.length),u=eg(r.shape,o,i),d=tg(s,o.length),h=ng(u,s,o.length),p=jC({inputs:{x:r},backend:n,attrs:{shape:c}}),f=rT({inputs:{x:p},backend:n,attrs:{perm:l}}),m=jC({inputs:{x:f},backend:n,attrs:{shape:u}}),g=_T({inputs:{x:m},backend:n,attrs:{begin:d,size:h}});return n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),g}};function OT(e,t,n,a,r){const o=lo(a),s=Fo(r,n);for(let i=0;i<e.length;i++){const n=e[i];if(n<0)throw new Error("Input x must be non-negative!");n>=r||(s[n]+=o>0?t[i]:1)}return s}function DT(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const r=e.shape[0],o=e.shape[1],s=Nd([r,n],t.dtype);for(let i=0;i<r;i++)for(let r=0;r<o;r++){const o=e.get(i,r);if(o<0)throw new Error("Input x must be non-negative!");o>=n||(a?s.set(1,i,o):t.size>0?s.set(s.get(i,o)+t.get(i,r),i,o):s.set(s.get(i,o)+1,i,o))}return s}const MT={kernelName:hs,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r,weights:o}=t,{size:s}=a,i=OT(n.data.get(r.dataId).values,n.data.get(o.dataId).values,o.dtype,o.shape,s);return n.makeTensorInfo([s],o.dtype,i)}},LT=xC(((e,t)=>e&t)),PT={kernelName:ps,backendName:"cpu",kernelFunc:BC(ps,LT)};const zT={kernelName:fs,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{s0:a,s1:r}=t,o=n.data.get(a.dataId).values,s=n.data.get(r.dataId).values,i=Zd(Array.from(o),Array.from(s));return n.makeTensorInfo([i.length],"int32",Int32Array.from(i))}},BT=uC((e=>Math.ceil(e))),WT=hC(gs,BT),VT={kernelName:gs,backendName:"cpu",kernelFunc:WT},UT=dC(bs,((e,t)=>{const n=t;return e>n.clipValueMax?n.clipValueMax:e<n.clipValueMin?n.clipValueMin:e})),GT={kernelName:bs,backendName:"cpu",kernelFunc:UT},HT={kernelName:xs,backendName:"cpu",kernelFunc:e=>{const{x:t}=e.inputs,n=e.backend,a=new Float32Array(lo(t.shape)),r=n.data.get(t.dataId),o=r.complexTensorInfos.real,s=r.complexTensorInfos.imag,i=n.data.get(o.dataId).values,c=n.data.get(s.dataId).values;for(let l=0;l<i.length;l++){const e=i[l],t=c[l];a[l]=Math.hypot(e,t)}return n.makeOutput(a,t.shape,"float32")}};function jT(e,t,n,a){const r=vo(n,lo(t));if(a&&"string"!==n){let t=0;e.forEach((e=>{const n=lo(e.shape);r.set(e.vals,t),t+=n}))}else{let a=0;e.forEach((e=>{const o="string"===n?Yg(e.vals):e.vals;let s=0;for(let n=0;n<e.shape[0];++n){const i=n*t[1]+a;for(let t=0;t<e.shape[1];++t)r[i+t]=o[s++]}a+=e.shape[1]}))}return r}function KT(e){const{inputs:t,backend:n}=e,{input:a}=t,r=n.data.get(a.dataId).complexTensorInfos.imag,o=n.data.get(r.dataId).values;return n.makeTensorInfo(r.shape,r.dtype,o)}const qT={kernelName:li,backendName:"cpu",kernelFunc:KT};function XT(e){const{inputs:t,backend:n,attrs:a}=e,{axis:r}=a,o=bo(r,t[0].shape)[0],s=t.map((e=>e.shape));Um(s,o);let i=Gm(t.map((e=>e.shape)),o);if(0===lo(i))return n.makeTensorInfo(i,t[0].dtype,[]);const c=t.filter((e=>lo(e.shape)>0));if(1===c.length)return mC({inputs:{x:c[0]},backend:n});if("complex64"===c[0].dtype){const e=c.map((e=>DC({inputs:{input:e},backend:n}))),t=c.map((e=>KT({inputs:{input:e},backend:n}))),a=XT({inputs:e,backend:n,attrs:{axis:o}}),r=XT({inputs:t,backend:n,attrs:{axis:o}}),s=AC({inputs:{real:a,imag:r},backend:n});return e.forEach((e=>n.disposeIntermediateTensorInfo(e))),t.forEach((e=>n.disposeIntermediateTensorInfo(e))),n.disposeIntermediateTensorInfo(a),n.disposeIntermediateTensorInfo(r),s}const l=c.map((e=>{const t=lo(e.shape.slice(o));return jC({inputs:{x:e},backend:n,attrs:{shape:[-1,t]}})})),u=l.map((e=>({vals:n.data.get(e.dataId).values,shape:e.shape})));i=Gm(l.map((e=>e.shape)),1);const d=1===l[0].shape[0],h=jT(u,i,t[0].dtype,d),p=Gm(c.map((e=>e.shape)),o),f=n.makeTensorInfo(p,t[0].dtype,h);return l.forEach((e=>n.disposeIntermediateTensorInfo(e))),f}const YT={kernelName:vs,backendName:"cpu",kernelFunc:XT};function QT(e){const{inputs:t,backend:n,attrs:a}=e,{x:r,filter:o}=t,{strides:s,pad:i,dataFormat:c,dilations:l,dimRoundingMode:u}=a;iC([r,o],"conv2d");const d=Xh(c),h=zh(r.shape,o.shape,s,l,i,u,!1,d),p=h.filterHeight,f=h.filterWidth,m=h.dilationHeight,g=h.dilationWidth,b=h.padInfo.left,y=h.padInfo.top,x="channelsLast"===h.dataFormat,v=new ql(h.outShape,r.dtype),w=Eo(r.shape),k=Eo(o.shape),I=w[0],S=x?w[1]:w[2],N=x?w[2]:1,C=x?1:w[1],T=v.strides[0],E=x?v.strides[1]:v.strides[2],R=x?v.strides[2]:1,_=x?1:v.strides[1],A=n.data.get(r.dataId).values,F=n.data.get(o.dataId).values,O=v.values;for(let D=0;D<h.batchSize;++D){const e=D*I,t=D*T;for(let n=0;n<h.outHeight;++n){const a=t+n*E,r=n*h.strideHeight-y;for(let t=0;t<p;++t){const n=r+t*m;if(n<0||n>=h.inHeight)continue;const o=t*k[0],s=e+n*S;for(let e=0;e<h.outWidth;++e){const t=a+e*R,n=e*h.strideWidth-b;for(let e=0;e<f;++e){const a=n+e*g;if(a<0||a>=h.inWidth)continue;const r=s+a*N;let i=o+e*k[1];for(let e=0;e<h.inChannels;++e){const n=A[r+e*C];for(let e=0;e<h.outChannels;++e)O[t+e*_]+=n*F[i+e];i+=h.outChannels}}}}}}return n.makeTensorInfo(v.shape,v.dtype,O)}const JT={kernelName:ws,backendName:"cpu",kernelFunc:QT};const ZT={kernelName:ks,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r,dy:o}=t,{strides:s,pad:i,dataFormat:c,dimRoundingMode:l,filterShape:u}=a;iC([r,o],"conv2dBackpropFilter");const d=Xh(c),h=zh(r.shape,u,s,1,i,l,!1,d),{strideHeight:p,strideWidth:f,filterHeight:m,filterWidth:g}=h,b="channelsLast"===h.dataFormat,y=new ql(h.filterShape,"float32"),x=h.padInfo.left,v=h.padInfo.top,w=n.data.get(r.dataId).values,k=n.data.get(o.dataId).values,I=new ql(r.shape,r.dtype,w),S=new ql(o.shape,o.dtype,k);for(let N=0;N<m;++N){const e=Math.max(0,Math.ceil((v-N)/p)),t=Math.min(h.outHeight,(h.inHeight+v-N)/p);for(let n=0;n<g;++n){const a=Math.max(0,Math.ceil((x-n)/f)),r=Math.min(h.outWidth,(h.inWidth+x-n)/f);for(let o=0;o<h.inChannels;++o)for(let s=0;s<h.outChannels;++s){let i=0;for(let c=0;c<h.batchSize;++c)for(let l=e;l<t;++l){const e=N+l*p-v;for(let t=a;t<r;++t){const a=n+t*f-x;i+=b?I.get(c,e,a,o)*S.get(c,l,t,s):I.get(c,o,e,a)*S.get(c,s,l,t)}}y.set(i,N,n,o,s)}}}return n.makeTensorInfo(y.shape,y.dtype,y.values)}};const $T={kernelName:Is,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{dy:r,filter:o}=t,{inputShape:s,strides:i,pad:c,dataFormat:l,dimRoundingMode:u}=a;iC([r,o],"conv2dBackpropInput");const d=Eo(o.shape),h=Eo(r.shape);let p=Xh(l);const f=zh(s,o.shape,i,1,c,u,!1,p),m=new ql(f.inShape,"float32"),g=m.values,b=n.data.get(r.dataId).values,y=n.data.get(o.dataId).values,[x,v,w]=d,{batchSize:k,filterHeight:I,filterWidth:S,inChannels:N,inHeight:C,inWidth:T,outChannels:E,outHeight:R,outWidth:_,strideHeight:A,strideWidth:F}=f;p=f.dataFormat;const O=I-1-f.padInfo.top,D=S-1-f.padInfo.left,M="channelsLast"===p,L=m.strides[0],P=M?m.strides[1]:m.strides[2],z=M?m.strides[2]:1,B=M?1:m.strides[1],W=h[0],V=M?h[1]:h[2],U=M?h[2]:1,G=M?1:h[1];for(let H=0;H<k;++H)for(let e=0;e<N;++e)for(let t=0;t<C;++t){const n=t-O,a=Math.max(0,Math.ceil(n/A)),r=Math.min(R,(I+n)/A);for(let o=0;o<T;++o){const s=o-D,i=Math.max(0,Math.ceil(s/F)),c=Math.min(_,(S+s)/F);let l=0;for(let t=a;t<r;++t){const a=t*A-n;for(let n=i;n<c;++n){const r=W*H+V*t+U*n,o=x*(I-1-a)+v*(S-1-(n*F-s))+w*e;for(let e=0;e<E;++e){l+=b[r+G*e]*y[o+e]}}}g[L*H+P*t+z*o+B*e]=l}}return n.makeTensorInfo(m.shape,m.dtype,m.values)}};const eE={kernelName:Ss,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r,filter:o}=t,{strides:s,pad:i,dilations:c}=a;iC([r,o],"conv3d");const l=Bh(r.shape,o.shape,s,c,i),{filterDepth:u,filterHeight:d,filterWidth:h,dilationDepth:p,dilationHeight:f,dilationWidth:m,padInfo:g}=l,b=g.front,y=g.left,x=g.top,v=new ql(l.outShape,r.dtype),w=n.data.get(r.dataId).values,k=n.data.get(o.dataId).values,I=v.values,S=Eo(r.shape),N=Eo(o.shape);for(let C=0;C<l.batchSize;++C){const e=C*S[0],t=C*v.strides[0];for(let n=0;n<l.outDepth;++n){const a=t+n*v.strides[1],r=n*l.strideDepth-b;for(let t=0;t<u;++t){const n=r+t*p;if(n<0||n>=l.inDepth)continue;const o=t*N[0],s=e+n*S[1];for(let e=0;e<l.outHeight;++e){const t=a+e*v.strides[2],n=e*l.strideHeight-x;for(let e=0;e<d;++e){const a=n+e*f;if(a<0||a>=l.inHeight)continue;const r=o+e*N[1],i=s+a*S[2];for(let e=0;e<l.outWidth;++e){const n=t+e*l.outChannels,a=e*l.strideWidth-y;for(let e=0;e<h;++e){const t=a+e*m;if(t<0||t>=l.inWidth)continue;const o=r+e*N[2],s=i+t*l.inChannels;let c=o;for(let e=0;e<l.inChannels;++e){const t=w[s+e];for(let e=0;e<l.outChannels;++e)I[n+e]+=t*k[c+e];c+=l.outChannels}}}}}}}}return n.makeTensorInfo(v.shape,v.dtype,v.values)}};const tE={kernelName:Ns,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r,dy:o}=t,{strides:s,pad:i,filterShape:c}=a;iC([r,o],"conv3dBackpropFilterV2");const l=Eo(r.shape),u=Eo(o.shape),d=Bh(r.shape,c,s,1,i),h=d.strideDepth,p=d.strideHeight,f=d.strideWidth,m=d.filterDepth,g=d.filterHeight,b=d.filterWidth,y=new ql(d.filterShape,"float32"),x=y.values,[v,w,k,I]=y.strides,S=n.data.get(o.dataId).values,[N,C,T,E]=u,R=n.data.get(r.dataId).values,[_,A,F,O]=l,D=d.padInfo.front,M=d.padInfo.left,L=d.padInfo.top;for(let P=0;P<m;++P){const e=Math.max(0,Math.ceil((D-P)/h)),t=Math.min(d.outDepth,(d.inDepth+D-P)/h),n=P*v;for(let a=0;a<g;++a){const r=Math.max(0,Math.ceil((L-a)/p)),o=Math.min(d.outHeight,(d.inHeight+L-a)/p),s=a*w+n;for(let n=0;n<b;++n){const i=Math.max(0,Math.ceil((M-n)/f)),c=Math.min(d.outWidth,(d.inWidth+M-n)/f),l=n*k+s;for(let s=0;s<d.inChannels;++s){const u=s*I+l;for(let l=0;l<d.outChannels;++l){let m=0;for(let u=0;u<d.batchSize;++u){const d=u*_,g=u*N;for(let u=e;u<t;++u){const e=(P+u*h-D)*A+d,t=u*C+g;for(let u=r;u<o;++u){const r=(a+u*p-L)*F+e,o=u*T+t;for(let e=i;e<c;++e){const t=e*E+o;m+=R[(n+e*f-M)*O+r+s]*S[t+l]}}}}x[u+l]=m}}}}}return n.makeTensorInfo(y.shape,y.dtype,y.values)}};const nE={kernelName:Cs,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{dy:r,filter:o}=t,{pad:s,strides:i,inputShape:c}=a;iC([r],"conv3dBackpropInputV2");const l=Eo(r.shape),u=Eo(o.shape),d=Bh(c,o.shape,i,1,s),h=new ql(d.inShape,"float32"),p=h.values,[f,m,g,b]=h.strides,y=n.data.get(r.dataId).values,[x,v,w,k]=l,I=n.data.get(o.dataId).values,[S,N,C,T]=u,{batchSize:E,filterDepth:R,filterHeight:_,filterWidth:A,inChannels:F,inDepth:O,inHeight:D,inWidth:M,outChannels:L,outDepth:P,outHeight:z,outWidth:B,strideDepth:W,strideHeight:V,strideWidth:U}=d,G=R-1-d.padInfo.front,H=_-1-d.padInfo.top,j=A-1-d.padInfo.left;for(let K=0;K<E;++K)for(let e=0;e<F;++e)for(let t=0;t<O;++t){const n=t-G,a=Math.max(0,Math.ceil(n/W)),r=Math.min(P,(R+n)/W);for(let o=0;o<D;++o){const s=o-H,i=Math.max(0,Math.ceil(s/V)),c=Math.min(z,(_+s)/V);for(let l=0;l<M;++l){const u=l-j,d=Math.max(0,Math.ceil(u/U)),h=Math.min(B,(A+u)/U);let E=0;for(let t=a;t<r;++t){const a=t*W-n;for(let n=i;n<c;++n){const r=n*V-s;for(let o=d;o<h;++o){const s=x*K+v*t+w*n+k*o,i=S*(R-1-a)+N*(_-1-r)+C*(A-1-(o*U-u))+T*e;for(let e=0;e<L;++e){E+=y[s+e]*I[i+e]}}}}p[f*K+m*t+g*o+b*l+e]=E}}}return n.makeTensorInfo(h.shape,h.dtype,h.values)}},aE=dC(Ts,(e=>Math.cos(e))),rE={kernelName:Ts,backendName:"cpu",kernelFunc:aE},oE=dC(Es,(e=>Math.cosh(e))),sE={kernelName:Es,backendName:"cpu",kernelFunc:oE};const iE={kernelName:As,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{image:r,boxes:o,boxInd:s}=t,{cropSize:i,method:c,extrapolationValue:l}=a,[u,d,h,p]=r.shape,f=o.shape[0],[m,g]=i,b=Nd([f,m,g,p],"float32"),y=n.data.get(o.dataId).values,x=n.data.get(s.dataId).values,v=n.data.get(r.dataId).values,w=Eo(r.shape),k=Eo(b.shape);for(let I=0;I<f;I++){const e=4*I,t=y[e],n=y[e+1],a=y[e+2],r=y[e+3],o=x[I];if(o>=u)continue;const s=m>1?(a-t)*(d-1)/(m-1):0,i=g>1?(r-n)*(h-1)/(g-1):0;for(let u=0;u<m;u++){const e=m>1?t*(d-1)+u*s:.5*(t+a)*(d-1);if(e<0||e>d-1)for(let t=0;t<g;t++)for(let e=0;e<p;e++){const n=e+t*k[2]+u*k[1]+I*k[0];b.values[n]=l}else if("bilinear"===c){const t=Math.floor(e),a=Math.ceil(e),s=e-t;for(let e=0;e<g;e++){const c=g>1?n*(h-1)+e*i:.5*(n+r)*(h-1);if(c<0||c>h-1){for(let t=0;t<p;t++){const n=t+e*k[2]+u*k[1]+I*k[0];b.values[n]=l}continue}const d=Math.floor(c),f=Math.ceil(c),m=c-d;for(let n=0;n<p;n++){let r=n+d*w[2]+t*w[1]+o*w[0];const i=v[r];r=n+f*w[2]+t*w[1]+o*w[0];const c=v[r];r=n+d*w[2]+a*w[1]+o*w[0];const l=v[r];r=n+f*w[2]+a*w[1]+o*w[0];const h=i+(c-i)*m,p=l+(v[r]-l)*m;r=n+e*k[2]+u*k[1]+I*k[0],b.values[r]=h+(p-h)*s}}}else for(let t=0;t<g;++t){const a=g>1?n*(h-1)+t*i:.5*(n+r)*(h-1);if(a<0||a>h-1){for(let e=0;e<p;e++){const n=e+t*k[2]+u*k[1]+I*k[0];b.values[n]=l}continue}const s=Math.round(a),c=Math.round(e);for(let e=0;e<p;e++){const n=e+s*w[2]+c*w[1]+o*w[0],a=e+t*k[2]+u*k[1]+I*k[0];b.values[a]=v[n]}}}}return n.makeTensorInfo(b.shape,b.dtype,b.values)}};const cE={kernelName:Rs,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{axis:o,exclusive:s,reverse:i}=a;iC(r,"cumprod");const c=Wp([o],r.shape.length);let l=r;null!=c&&(l=rT({inputs:{x:r},backend:n,attrs:{perm:c}}));const u=Up(1,r.shape.length)[0];if(u!==l.shape.length-1)throw new Error("backend.cumprod in CPU expects an inner-most "+"axis=".concat(l.shape.length-1," but got axis=").concat(u));const d=su(l.dtype,"int32"),h=Ao(lo(l.shape),d),p=n.data.get(l.dataId).values,f=l.shape[l.shape.length-1],m=i?(e,t)=>e+f-t-1:(e,t)=>e+t;for(let b=0;b<p.length;b+=f)for(let e=0;e<f;e++){const t=m(b,e);if(0===e)h[t]=s?1:p[t];else{const n=m(b,e-1);h[t]=s?p[n]*h[n]:p[t]*h[n]}}const g=n.makeTensorInfo(l.shape,d,h);if(null!=c){const e=rT({inputs:{x:g},backend:n,attrs:{perm:Vp(c)}});return n.disposeIntermediateTensorInfo(g),n.disposeIntermediateTensorInfo(l),e}return g}};const lE={kernelName:_s,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{axis:o,exclusive:s,reverse:i}=a;iC(r,"cumsum");const c=Wp([o],r.shape.length);let l=r;null!=c&&(l=rT({inputs:{x:r},backend:n,attrs:{perm:c}}));const u=Up(1,r.shape.length)[0];if(u!==l.shape.length-1)throw new Error("backend.cumsum in CPU expects an inner-most "+"axis=".concat(l.shape.length-1," but got axis=").concat(u));const d=su(l.dtype,"int32"),h=Fo(lo(l.shape),d),p=n.data.get(l.dataId).values,f=l.shape[l.shape.length-1],m=i?(e,t)=>e+f-t-1:(e,t)=>e+t;for(let b=0;b<p.length;b+=f)for(let e=0;e<f;e++){const t=m(b,e);if(0===e)h[t]=s?0:p[t];else{const n=m(b,e-1);h[t]=s?p[n]+h[n]:p[t]+h[n]}}const g=n.makeTensorInfo(l.shape,d,h);if(null!=c){const e=rT({inputs:{x:g},backend:n,attrs:{perm:Vp(c)}});return n.disposeIntermediateTensorInfo(g),n.disposeIntermediateTensorInfo(l),e}return g}};const uE={kernelName:Fs,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r,weights:o}=t,{size:s,binaryOutput:i}=a;if(1===r.shape.length){const e=OT(n.data.get(r.dataId).values,n.data.get(o.dataId).values,o.dtype,o.shape,s);return n.makeTensorInfo([s],o.dtype,e)}if(2===r.shape.length){const e=DT(n.bufferSync(r),n.bufferSync(o),s,i);return n.makeTensorInfo(e.shape,o.dtype,e.values)}throw new Error("Error in denseBincount: input must be at most rank 2, but got rank"+"".concat(r.shape.length,"."))}};const dE={kernelName:Os,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{blockSize:o,dataFormat:s}=a;so("NHWC"===s,(()=>"Only NHWC dataFormat supported on CPU for depthToSpace. Got ".concat(s)));const i=r.shape[0],c=r.shape[1],l=r.shape[2],u=r.shape[3],d=c*o,h=l*o,p=u/(o*o),f=n.data.get(r.dataId).values,m=new Float32Array(i*d*h*p);let g=0;for(let b=0;b<i;++b)for(let e=0;e<d;++e){const t=Math.floor(e/o),n=e%o;for(let e=0;e<h;++e){const a=Math.floor(e/o),r=(n*o+e%o)*p;for(let e=0;e<p;++e){const n=e+r+u*(a+l*(t+c*b));m[g++]=f[n]}}}return n.makeTensorInfo([i,d,h,p],r.dtype,m)}};function hE(e){const{inputs:t,backend:n,attrs:a}=e,{x:r,filter:o}=t,{strides:s,pad:i,dilations:c,dimRoundingMode:l}=a;iC([r,o],"depthwiseConv2DNative");const u=Eo(r.shape),d=Eo(o.shape);let h=c;null==h&&(h=[1,1]),so(Kh(s,h),(()=>"Error in depthwiseConv2d: Either strides or dilations must be "+"1. Got strides ".concat(s," and dilations '").concat(h,"'")));const p=zh(r.shape,o.shape,s,h,i,l,!0),{filterHeight:f,filterWidth:m,dilationHeight:g,dilationWidth:b,padInfo:y}=p,x=y.left,v=y.top,w=p.outChannels/p.inChannels,k=new ql(p.outShape,r.dtype),I=n.data.get(r.dataId).values,S=n.data.get(o.dataId).values,N=k.values;for(let C=0;C<p.batchSize;++C){const e=C*u[0],t=C*k.strides[0];for(let n=0;n<p.outHeight;++n){const a=t+n*k.strides[1],r=n*p.strideHeight-v;for(let t=0;t<f;++t){const n=r+t*g;if(n<0||n>=p.inHeight)continue;const o=t*d[0],s=e+n*u[1];for(let e=0;e<p.outWidth;++e){const t=a+e*k.strides[2],n=e*p.strideWidth-x;for(let e=0;e<m;++e){const a=n+e*b;if(a<0||a>=p.inWidth)continue;const r=o+e*d[1],i=s+a*p.inChannels;let c=t,l=r;for(let e=0;e<p.inChannels;++e){const t=I[i+e];for(let e=0;e<w;++e)N[c+e]+=t*S[l+e];c+=w,l+=w}}}}}}return n.makeTensorInfo(k.shape,k.dtype,k.values)}const pE={kernelName:Ds,backendName:"cpu",kernelFunc:hE};const fE={kernelName:Ms,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r,dy:o}=t,{strides:s,dilations:i,pad:c,dimRoundingMode:l,filterShape:u}=a;iC([r,o],"depthwiseConv2dNativeBackpropFilter");const d=zh(r.shape,u,s,i,c,l,!0),{strideHeight:h,strideWidth:p,filterHeight:f,filterWidth:m}=d,g=new ql(d.filterShape,"float32"),b=d.padInfo.left,y=d.padInfo.top,x=d.outChannels/d.inChannels,v=n.data.get(r.dataId).values,w=new ql(r.shape,r.dtype,v),k=n.data.get(o.dataId).values,I=new ql(o.shape,o.dtype,k);for(let S=0;S<f;++S){const e=Math.max(0,Math.ceil((y-S)/h)),t=Math.min(d.outHeight,(d.inHeight+y-S)/h);for(let n=0;n<m;++n){const a=Math.max(0,Math.ceil((b-n)/p)),r=Math.min(d.outWidth,(d.inWidth+b-n)/p);for(let o=0;o<d.outChannels;++o){const s=Math.trunc(o/x),i=o%x;let c=0;for(let l=0;l<d.batchSize;++l)for(let i=e;i<t;++i){const e=S+i*h-y;for(let t=a;t<r;++t){const a=n+t*p-b;c+=w.get(l,e,a,s)*I.get(l,i,t,o)}}g.set(c,S,n,s,i)}}}return n.makeTensorInfo(g.shape,g.dtype,g.values)}};const mE={kernelName:Ls,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{dy:r,filter:o}=t,{strides:s,dilations:i,pad:c,dimRoundingMode:l,inputShape:u}=a;iC([r,o],"depthwiseConv2DNativeBackpropInput");const d=Eo(r.shape),h=Eo(o.shape),p=zh(u,o.shape,s,i,c,l,!0),f=new ql(p.inShape,"float32"),m=f.values,[g,b,y]=f.strides,x=n.data.get(r.dataId).values,[v,w,k]=d,I=n.data.get(o.dataId).values,[S,N,C]=h,{batchSize:T,filterHeight:E,filterWidth:R,inChannels:_,inHeight:A,inWidth:F,outChannels:O,outHeight:D,outWidth:M,strideHeight:L,strideWidth:P}=p,z=E-1-p.padInfo.top,B=R-1-p.padInfo.left,W=O/_;for(let V=0;V<T;++V)for(let e=0;e<_;++e)for(let t=0;t<A;++t){const n=t-z,a=Math.max(0,Math.ceil(n/L)),r=Math.min(D,(E+n)/L);for(let o=0;o<F;++o){const s=o-B,i=Math.max(0,Math.ceil(s/P)),c=Math.min(M,(R+s)/P);let l=0;for(let t=a;t<r;++t){const a=t*L-n;for(let n=i;n<c;++n){const r=v*V+w*t+k*n,o=S*(E-1-a)+N*(R-1-(n*P-s))+C*e;for(let t=0;t<W;++t){l+=x[r+(e*W+t)]*I[o+t]}}}m[g*V+b*t+y*o+e]=l}}return n.makeTensorInfo(f.shape,f.dtype,f.values)}};const gE={kernelName:Ps,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{x:a}=t,r=lo(a.shape),o=n.data.get(a.dataId).values,s=Nd([r,r],a.dtype),i=s.values;for(let l=0;l<o.length;l++)i[l*r+l]=o[l];const c=[...a.shape,...a.shape];return n.makeTensorInfo(c,s.dtype,s.values)}},bE={kernelName:zs,backendName:"cpu",kernelFunc:e=>{let{inputs:t,backend:n,attrs:a}=e;const{x:r,filter:o}=t,{strides:s,pad:i,dilations:c}=a,l=n,u=l.data.get(r.dataId).values,d=r.shape.length,h=l.data.get(o.dataId).values,p=o.shape.length,{batchSize:f,inHeight:m,inWidth:g,inChannels:b,outHeight:y,outWidth:x,padInfo:v,strideHeight:w,strideWidth:k,filterHeight:I,filterWidth:S,dilationHeight:N,dilationWidth:C,outShape:T}=Mh(r.shape,o.shape,s,i,"NHWC",c),E=lo(T),R=T.length,_=vo(r.dtype,E);for(let A=0;A<f;++A)for(let e=0;e<y;++e){const t=e*w-v.top;for(let n=0;n<x;++n){const a=n*k-v.left;for(let s=0;s<b;++s){let i=Number.MIN_SAFE_INTEGER;for(let e=0;e<I;++e){const n=t+e*N;if(n>=0&&n<m)for(let t=0;t<S;++t){const c=a+t*C;if(c>=0&&c<g){const a=Mo([A,n,c,s],d,Eo(r.shape)),l=Mo([e,t,s],p,Eo(o.shape)),f=u[a]+h[l];f>i&&(i=f)}}}_[Mo([A,e,n,s],R,Eo(T))]=i}}}return{dataId:l.write(_l(_,r.dtype),T,r.dtype),shape:T,dtype:r.dtype}}},yE={kernelName:Ws,backendName:"cpu",kernelFunc:e=>{let{inputs:t,backend:n,attrs:a}=e;const{x:r,filter:o,dy:s}=t,{strides:i,pad:c,dilations:l}=a,u=n,d=_o(r.shape,u.data.get(r.dataId).values),h=_o(o.shape,u.data.get(o.dataId).values),{batchSize:p,inHeight:f,inWidth:m,inChannels:g,outHeight:b,outWidth:y,padInfo:x,strideHeight:v,strideWidth:w,filterHeight:k,filterWidth:I,dilationHeight:S,dilationWidth:N,outShape:C}=Mh(r.shape,o.shape,i,c,"NHWC",l);so(s.rank===C.length,(()=>"Error in ".concat(Ws,", dy ")+"must have the same rank as output ".concat(C.length,", but got ")+"".concat(s.rank)));const T=_o(C,u.data.get(s.dataId).values),E=Oo(o.shape,o.dtype);for(let R=0;R<p;++R)for(let e=0;e<b;++e){const t=e*v-x.top;for(let n=0;n<y;++n){const a=n*w-x.left;for(let r=0;r<g;++r){let o=Number.MIN_SAFE_INTEGER,s=0,i=0;for(let e=0;e<k;++e){const n=t+e*S;if(n>=0&&n<f)for(let t=0;t<I;++t){const c=a+t*N;if(c>=0&&c<m){const a=d[R][n][c][r]+h[e][t][r];a>o&&(o=a,s=e,i=t)}}}E[s][i][r]+=T[R][e][n][r]}}}return{dataId:u.write(_l(E,r.dtype),o.shape,o.dtype),shape:o.shape,dtype:o.dtype}}},xE={kernelName:Bs,backendName:"cpu",kernelFunc:e=>{let{inputs:t,backend:n,attrs:a}=e;const{x:r,filter:o,dy:s}=t,{strides:i,pad:c,dilations:l}=a,u=n,d=_o(r.shape,u.data.get(r.dataId).values),h=_o(o.shape,u.data.get(o.dataId).values),{batchSize:p,inHeight:f,inWidth:m,inChannels:g,outHeight:b,outWidth:y,padInfo:x,strideHeight:v,strideWidth:w,filterHeight:k,filterWidth:I,dilationHeight:S,dilationWidth:N,outShape:C}=Mh(r.shape,o.shape,i,c,"NHWC",l);so(s.rank===C.length,(()=>"Error in ".concat(Bs,", dy ")+"must have the same rank as output ".concat(C.length,", but got ")+"".concat(s.rank)));const T=_o(C,u.data.get(s.dataId).values),E=Oo(r.shape,r.dtype);for(let R=0;R<p;++R)for(let e=0;e<b;++e){const t=e*v-x.top;for(let n=0;n<y;++n){const a=n*w-x.left;for(let r=0;r<g;++r){let o=Number.MIN_SAFE_INTEGER,s=t<0?0:t,i=a<0?0:a;for(let e=0;e<k;++e){const n=t+e*S;if(n>=0&&n<f)for(let t=0;t<I;++t){const c=a+t*N;if(c>=0&&c<m){const a=d[R][n][c][r]+h[e][t][r];a>o&&(o=a,s=n,i=c)}}}E[R][s][i][r]+=T[R][e][n][r]}}}return{dataId:u.write(_l(E,r.dtype),r.shape,r.dtype),shape:r.shape,dtype:r.dtype}}};const vE={kernelName:Vs,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{image:r}=t,{canvas:o,options:s}=a,{contextOptions:i,imageOptions:c}=s||{},l=(null===c||void 0===c?void 0:c.alpha)||1,u=(null===i||void 0===i?void 0:i.contextType)||"2d";if("2d"!==u)throw new Error("Context type ".concat(i.contextType," is not supported by the CPU backend."));const d=o.getContext(u,(null===i||void 0===i?void 0:i.contextAttributes)||{});if(null==d)throw new Error("Could not get the context with ".concat(u," type."));const[h,p]=r.shape.slice(0,2),f=2===r.shape.length?1:r.shape[2],m=n.data.get(r.dataId).values,g="float32"===r.dtype?255:1,b=new Uint8ClampedArray(p*h*4);for(let x=0;x<h*p;++x){const e=[0,0,0,255*l];for(let n=0;n<f;n++){const t=m[x*f+n];if("float32"===r.dtype){if(t<0||t>1)throw new Error("Tensor values for a float32 Tensor must be in the "+"range [0 - 1] but encountered ".concat(t,"."))}else if("int32"===r.dtype&&(t<0||t>255))throw new Error("Tensor values for a int32 Tensor must be in the "+"range [0 - 255] but encountered ".concat(t,"."));1===f?(e[0]=t*g,e[1]=t*g,e[2]=t*g):e[n]=t*g}const t=4*x;b[t+0]=Math.round(e[0]),b[t+1]=Math.round(e[1]),b[t+2]=Math.round(e[2]),b[t+3]=Math.round(e[3])}o.width=p,o.height=h;const y=new ImageData(b,p,h);return d.putImageData(y,0,0),r}},wE=xC(((e,t)=>e*t)),kE=WC(((e,t,n,a)=>({real:e*n-t*a,imag:e*a+t*n}))),IE=BC(Pi,wE,kE),SE={kernelName:Pi,backendName:"cpu",kernelFunc:IE};function NE(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{axis:o,keepDims:s}=a;let i;iC(r,"sum"),i="bool"===r.dtype?PC({inputs:{x:r},backend:n,attrs:{dtype:"int32"}}):mC({inputs:{x:r},backend:n});const c=i.shape.length,l=bo(o,i.shape),u=Wp(l,c);let d=l,h=i;null!=u&&(h=rT({inputs:{x:i},backend:n,attrs:{perm:u}}),d=Up(d.length,c)),Bp("sum",d,h.shape.length);const[p,f]=Pp(h.shape,d);let m=OC(n,p,su(h.dtype,"int32"));const g=lo(f),b=n.data.get(m.dataId).values,y=n.data.get(h.dataId).values;for(let x=0;x<b.length;++x){const e=x*g;let t=0;for(let n=0;n<g;++n)t+=y[e+n];b[x]=t}if(s){const e=m;m=jC({inputs:{x:m},backend:n,attrs:{shape:zp(m.shape,l)}}),n.disposeIntermediateTensorInfo(e)}return n.disposeIntermediateTensorInfo(i),null!=u&&n.disposeIntermediateTensorInfo(h),m}const CE={kernelName:Sc,backendName:"cpu",kernelFunc:NE};const TE={kernelName:Gs,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{equation:r}=a,o=t,{allDims:s,summedDims:i,idDims:c}=Tg(r,o.length);Rg(s.length,c,o);const{path:l,steps:u}=_g(i,c),d=u.length;let h=null,p=s.length;const f=[];for(let m=0;m<d;++m){for(const e of u[m]){const{permutationIndices:t,expandDims:a}=Eg(p,c[e]);let r;Ag(t)?r=o[e]:(r=rT({inputs:{x:o[e]},backend:n,attrs:{perm:t}}),f.push(r));const s=r.shape.slice();for(let e=0;e<a.length;++e)s.splice(a[e],0,1);uo(r.shape,s)||(r=jC({inputs:{x:r},backend:n,attrs:{shape:s}}),f.push(r)),null===h?h=r:(h=IE({inputs:{a:r,b:h},backend:n}),f.push(h))}m<d-1&&(l[m]>=0&&(h=NE({inputs:{x:h},backend:n,attrs:{axis:l[m]-(s.length-p),keepDims:!1}}),f.push(h)),p--)}for(const m of f)m!==h&&n.disposeIntermediateTensorInfo(m);return h}};const EE={kernelName:js,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{dy:a,y:r}=t;iC([a,r],"eluGrad");const o=new Float32Array(lo(r.shape)),s=n.data.get(r.dataId).values,i=n.data.get(a.dataId).values;for(let c=0;c<s.length;++c){const e=s[c];o[c]=e>=0?i[c]:i[c]*(e+1)}return n.makeTensorInfo(r.shape,"float32",o)}},RE=xC(((e,t)=>e===t?1:0)),_E=BC(qs,RE,null,"bool"),AE={kernelName:qs,backendName:"cpu",kernelFunc:_E},FE=lg,OE=ug,DE=dg,ME=hg,LE=pg,PE=fg,zE=dC(Ks,(e=>{const t=Math.sign(e),n=Math.abs(e),a=1/(1+FE*n);return t*(1-((((PE*a+LE)*a+ME)*a+DE)*a+OE)*a*Math.exp(-n*n))})),BE={kernelName:Ks,backendName:"cpu",kernelFunc:zE},WE=uC((e=>Math.exp(e))),VE=hC(Xs,WE,"float32"),UE={kernelName:Xs,backendName:"cpu",kernelFunc:VE};function GE(e){const{inputs:t,backend:n,attrs:a}=e,{input:r}=t,{dim:o}=a,s=r.shape.length,i=r.shape.slice();let c=o;return o<0&&(so(-(s+1)<=o,(()=>"Axis must be in the interval [".concat(-(s+1),", ").concat(s,"]"))),c=s+o+1),i.splice(c,0,1),jC({inputs:{x:r},backend:n,attrs:{shape:i}})}const HE={kernelName:Ys,backendName:"cpu",kernelFunc:GE},jE=uC((e=>Math.expm1(e))),KE=hC(Qs,jE),qE={kernelName:Qs,backendName:"cpu",kernelFunc:KE},XE=xC(((e,t)=>e/t)),YE=BC(Us,XE),QE={kernelName:Us,backendName:"cpu",kernelFunc:YE},JE=xC(((e,t)=>e-t)),ZE=WC(((e,t,n,a)=>({real:e-n,imag:t-a}))),$E=BC(Wc,JE,ZE),eR={kernelName:Wc,backendName:"cpu",kernelFunc:$E};function tR(e,t,n){const a=e.shape,r=a[0],o=a[1],s=n.data.get(e.dataId),i=s.complexTensorInfos.real,c=s.complexTensorInfos.imag,l=[r,o],u=lo(l),d=xo("float32",u),h=xo("float32",u);for(let g=0;g<r;g++){const e=_T({inputs:{x:i},backend:n,attrs:{begin:[g,0],size:[1,o]}}),a=_T({inputs:{x:c},backend:n,attrs:{begin:[g,0],size:[1,o]}}),r=AC({inputs:{real:e,imag:a},backend:n}),{real:s,imag:l}=nR(r,t,n),u=mg(s,l);for(let t=0;t<o;t++){const e=xg(u,t);d[g*o+t]=e.real,h[g*o+t]=e.imag}n.disposeIntermediateTensorInfo(e),n.disposeIntermediateTensorInfo(a),n.disposeIntermediateTensorInfo(r)}const p=n.makeTensorInfo(l,"float32",d),f=n.makeTensorInfo(l,"float32",h),m=AC({inputs:{real:p,imag:f},backend:n});return n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(f),m}function nR(e,t,n){const a=lo(e.shape),r=n.data.get(e.dataId),o=n.data.get(r.complexTensorInfos.real.dataId).values,s=n.data.get(r.complexTensorInfos.imag.dataId).values;if(0===((i=a)&i-1)){const r=aR(o,s,a,t,n),i=[e.shape[0],e.shape[1]];if(t){const e=n.makeTensorInfo(i,"float32",r.real),t=n.makeTensorInfo(i,"float32",r.imag),o=n.makeTensorInfo([],"float32",Rl(a,"float32")),s=mC({inputs:{x:o},backend:n}),c=QE.kernelFunc({inputs:{a:e,b:o},backend:n}),l=QE.kernelFunc({inputs:{a:t,b:s},backend:n}),u=n.data.get(c.dataId).values,d=n.data.get(l.dataId).values;return n.disposeIntermediateTensorInfo(e),n.disposeIntermediateTensorInfo(t),n.disposeIntermediateTensorInfo(o),n.disposeIntermediateTensorInfo(s),n.disposeIntermediateTensorInfo(c),n.disposeIntermediateTensorInfo(l),{real:u,imag:d}}return r}{const e=function(e,t,n){const a=new Float32Array(2*t);for(let r=0;r<t;r++){let o=0,s=0;for(let a=0;a<t;a++){const i=kg(r*a,t,n),c=xg(e,a);o+=c.real*i.real-c.imag*i.imag,s+=c.real*i.imag+c.imag*i.real}n&&(o/=t,s/=t),vg(a,o,s,r)}return a}(mg(o,s),a,t);return gg(e)}var i}function aR(e,t,n,a,r){if(1===n)return{real:e,imag:t};const o=mg(e,t),s=n/2,i=bg(o),c=i.real,l=i.imag,u=[c.length],d=r.makeTensorInfo(u,"float32",c),h=r.makeTensorInfo(u,"float32",l),p=AC({inputs:{real:d,imag:h},backend:r}),f=yg(o),m=f.real,g=f.imag,b=[m.length],y=r.makeTensorInfo(b,"float32",m),x=r.makeTensorInfo(b,"float32",g),v=AC({inputs:{real:y,imag:x},backend:r}),w=aR(c,l,s,a,r),k=w.real,I=w.imag,S=[k.length],N=r.makeTensorInfo(S,"float32",k),C=r.makeTensorInfo(S,"float32",I),T=AC({inputs:{real:N,imag:C},backend:r}),E=aR(m,g,s,a,r),R=E.real,_=E.imag,A=[R.length],F=r.makeTensorInfo(A,"float32",R),O=r.makeTensorInfo(A,"float32",_),D=AC({inputs:{real:F,imag:O},backend:r}),M=wg(n,a),L=[M.real.length],P=r.makeTensorInfo(L,"float32",M.real),z=r.makeTensorInfo(L,"float32",M.imag),B=AC({inputs:{real:P,imag:z},backend:r}),W=IE({inputs:{a:B,b:D},backend:r}),V=GC({inputs:{a:T,b:W},backend:r}),U=$E({inputs:{a:T,b:W},backend:r}),G=DC({inputs:{input:V},backend:r}),H=DC({inputs:{input:U},backend:r}),j=KT({inputs:{input:V},backend:r}),K=KT({inputs:{input:U},backend:r}),q=XT({inputs:[G,H],backend:r,attrs:{axis:0}}),X=XT({inputs:[j,K],backend:r,attrs:{axis:0}}),Y=r.data.get(q.dataId).values,Q=r.data.get(X.dataId).values;return r.disposeIntermediateTensorInfo(d),r.disposeIntermediateTensorInfo(h),r.disposeIntermediateTensorInfo(p),r.disposeIntermediateTensorInfo(y),r.disposeIntermediateTensorInfo(x),r.disposeIntermediateTensorInfo(v),r.disposeIntermediateTensorInfo(N),r.disposeIntermediateTensorInfo(C),r.disposeIntermediateTensorInfo(T),r.disposeIntermediateTensorInfo(F),r.disposeIntermediateTensorInfo(O),r.disposeIntermediateTensorInfo(D),r.disposeIntermediateTensorInfo(P),r.disposeIntermediateTensorInfo(z),r.disposeIntermediateTensorInfo(B),r.disposeIntermediateTensorInfo(W),r.disposeIntermediateTensorInfo(V),r.disposeIntermediateTensorInfo(U),r.disposeIntermediateTensorInfo(G),r.disposeIntermediateTensorInfo(j),r.disposeIntermediateTensorInfo(H),r.disposeIntermediateTensorInfo(K),r.disposeIntermediateTensorInfo(q),r.disposeIntermediateTensorInfo(X),{real:Y,imag:Q}}const rR={kernelName:Js,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{input:a}=t,r=lo(a.shape),o=a.shape[a.shape.length-1],s=jC({inputs:{x:a},backend:n,attrs:{shape:[r/o,o]}}),i=tR(s,!1,n),c=jC({inputs:{x:i},backend:n,attrs:{shape:a.shape}});return n.disposeIntermediateTensorInfo(s),n.disposeIntermediateTensorInfo(i),c}};function oR(e){const{backend:t,attrs:n}=e,{shape:a,value:r,dtype:o}=n,s=o||No(r),i=vo(s,lo(a));return function(e,t,n){e.fill(t)}(i,r),t.makeTensorInfo(a,s,i)}const sR={kernelName:Zs,backendName:"cpu",kernelFunc:oR};const iR={kernelName:$s,backendName:"cpu",kernelFunc:e=>{let{inputs:t,attrs:n,backend:a}=e;const{image:r}=t,o=a,s=xo(r.dtype,lo(r.shape)),[i,c,l,u]=r.shape,d=o.data.get(r.dataId).values;for(let h=0;h<i;h++){const e=h*l*c*u;for(let t=0;t<c;t++){const n=t*(l*u);for(let t=0;t<l;t++){const a=t*u;for(let r=0;r<u;r++){const o=Math.round(l-t-1),i=e+n+a+r;let c=d[i];if(o>=0&&o<l){c=d[e+n+o*u+r]}s[i]=c}}}}return{dataId:o.write(s,r.shape,r.dtype),shape:r.shape,dtype:r.dtype}}},cR=uC((e=>Math.floor(e))),lR=hC(ei,cR),uR={kernelName:ei,backendName:"cpu",kernelFunc:lR},dR=xC(((e,t)=>Math.floor(e/t))),hR=BC(ti,dR,null,"int32"),pR={kernelName:ti,backendName:"cpu",kernelFunc:hR};const fR={kernelName:tl,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r,filter:o,bias:s,preluActivationWeights:i}=t,{strides:c,pad:l,dataFormat:u,dilations:d,dimRoundingMode:h,activation:p,leakyreluAlpha:f}=a;let m=QT({inputs:{x:r,filter:o},backend:n,attrs:{strides:c,pad:l,dataFormat:u,dilations:d,dimRoundingMode:h}});if(s){const e=m;if("NCHW"===u&&1===s.shape.length&&1!==s.shape[0]){const e=jC({inputs:{x:s},backend:n,attrs:{shape:[s.shape[0],1,1]}});m=GC({inputs:{a:m,b:e},backend:n}),n.disposeIntermediateTensorInfo(e)}else m=GC({inputs:{a:m,b:s},backend:n});n.disposeIntermediateTensorInfo(e)}if(p){const e=m;if("NCHW"===u&&"prelu"===p&&1===i.shape.length&&1!==i.shape[0]){const e=jC({inputs:{x:i},backend:n,attrs:{shape:[i.shape[0],1,1]}});m=_C(n,m,p,e,f),n.disposeIntermediateTensorInfo(e)}else m=_C(n,m,p,i,f);n.disposeIntermediateTensorInfo(e)}return m}};const mR={kernelName:nl,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r,filter:o,bias:s,preluActivationWeights:i}=t,{strides:c,pad:l,dataFormat:u,dilations:d,dimRoundingMode:h,activation:p,leakyreluAlpha:f}=a;let m=hE({inputs:{x:r,filter:o},backend:n,attrs:{strides:c,pad:l,dataFormat:u,dilations:d,dimRoundingMode:h}});if(s){const e=m;m=GC({inputs:{a:m,b:s},backend:n}),n.disposeIntermediateTensorInfo(e)}if(p){const e=m;m=_C(n,m,p,i,f),n.disposeIntermediateTensorInfo(e)}return m}};function gR(e,t,n,a,r,o,s,i,c){const l=Nd([a,o],n);for(let u=0;u<a;u++){const n=[];let a=0;for(let t=0;t<r;t++){const o=e[u*r+t];a+=o*s[t],n.push(o)}if(a<0||a>=c/o)throw new Error("Invalid indices: ".concat(n," does not index into ").concat(i));for(let e=0;e<o;e++)l.values[u*o+e]=t.get(...t.indexToLoc(a*o+e))}return l}const bR={kernelName:ri,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{params:a,indices:r}=t,o=lo(a.shape),s=r.shape,i=s[s.length-1],[c,l,u,d]=ag(a,r);if(0===l)return n.makeTensorInfo(c,a.dtype,[]);const h=gR(n.data.get(r.dataId).values,n.bufferSync(a),a.dtype,l,i,u,d,a.shape,o);return n.makeTensorInfo(c,a.dtype,h.values)}};function yR(e,t,n){const a=Nd(n,e.dtype);for(let r=0;r<a.size;++r){const n=a.indexToLoc(r).slice(),o=n[0],s=n[2],i=t.locToIndex([o,s]);n[2]=t.values[i];const c=e.locToIndex(n);0<=c&&c<e.values.length&&(a.values[r]=e.values[c])}return a}const xR={kernelName:ai,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r,indices:o}=t,{axis:s,batchDims:i}=a;iC([r,o],"gatherV2");const c=bo(s,r.shape)[0],l=n.data.get(o.dataId).values,u=r.shape[c];for(let x=0;x<l.length;++x){const e=l[x];so(e<=u-1&&e>=0,(()=>"GatherV2: the index value ".concat(e," is not in [0, ").concat(u-1,"]")))}let d=i;null==i&&(d=0);const h=lo(o.shape),p=Xg(r,o,c,d),f=jC({inputs:{x:r},backend:n,attrs:{shape:[p.batchSize,p.outerSize,p.dimSize,p.sliceSize]}}),m=jC({inputs:{x:o},backend:n,attrs:{shape:[p.batchSize,h/p.batchSize]}}),g=[p.batchSize,p.outerSize,h/p.batchSize,p.sliceSize],b=n.bufferSync(m),y=yR(n.bufferSync(f),b,g);return n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),n.makeTensorInfo(p.outputShape,y.dtype,y.values)}},vR=xC(((e,t)=>e>t?1:0)),wR=BC(oi,vR,null,"bool"),kR={kernelName:oi,backendName:"cpu",kernelFunc:wR},IR=xC(((e,t)=>e>=t?1:0)),SR=BC(si,IR,null,"bool"),NR={kernelName:si,backendName:"cpu",kernelFunc:SR};const CR={kernelName:ci,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{input:a}=t,r=lo(a.shape),o=a.shape[a.shape.length-1],s=jC({inputs:{x:a},backend:n,attrs:{shape:[r/o,o]}}),i=tR(s,!0,n),c=jC({inputs:{x:i},backend:n,attrs:{shape:a.shape}});return n.disposeIntermediateTensorInfo(s),n.disposeIntermediateTensorInfo(i),c}},TR=dC(ui,(e=>Number.isFinite(e)?1:0),"bool"),ER={kernelName:ui,backendName:"cpu",kernelFunc:TR},RR=dC(di,(e=>Math.abs(e)===1/0?1:0),"bool"),_R={kernelName:di,backendName:"cpu",kernelFunc:RR},AR=dC(hi,(e=>Number.isNaN(e)?1:0),"bool"),FR={kernelName:hi,backendName:"cpu",kernelFunc:AR},OR=xC(((e,t)=>e<t?1:0)),DR=BC(fi,OR,null,"bool"),MR={kernelName:fi,backendName:"cpu",kernelFunc:DR},LR=xC(((e,t)=>e<=t?1:0)),PR=BC(mi,LR,null,"bool"),zR={kernelName:mi,backendName:"cpu",kernelFunc:PR};function BR(e,t,n){const a=(t-e)/(n-1),r=Fo(n,"float32");r[0]=e;for(let o=1;o<r.length;o++)r[o]=r[o-1]+a;return r}const WR={kernelName:gi,backendName:"cpu",kernelFunc:function(e){const{backend:t,attrs:n}=e,{start:a,stop:r,num:o}=n,s=BR(a,r,o);return t.makeTensorInfo([s.length],"float32",s)}},VR=uC((e=>Math.log(e))),UR=hC(bi,VR),GR={kernelName:bi,backendName:"cpu",kernelFunc:UR},HR=dC(yi,(e=>Math.log1p(e))),jR={kernelName:yi,backendName:"cpu",kernelFunc:HR},KR=xC(((e,t)=>e&&t)),qR=BC(xi,KR,null,"bool"),XR={kernelName:xi,backendName:"cpu",kernelFunc:qR},YR=dC(vi,(e=>e?0:1),"bool"),QR={kernelName:vi,backendName:"cpu",kernelFunc:YR},JR=xC(((e,t)=>e||t)),ZR=BC(wi,JR,null,"bool"),$R={kernelName:wi,backendName:"cpu",kernelFunc:ZR};const e_={kernelName:ki,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{depthRadius:o,bias:s,alpha:i,beta:c}=a;iC(r,"LRN");const l=r.shape[3],u=l-1,d=n.data.get(r.dataId).values,h=lo(r.shape),p=new Float32Array(h);function f(e){const t=e%l;let n=e-t+Math.max(0,t-o);const a=e-t+Math.min(t+o,u);let r=0;for(;n<=a;n++){const e=d[n];r+=e*e}return r}for(let m=0;m<h;m++){const e=f(m),t=d[m]*Math.pow(s+i*e,-c);p[m]=t}return n.makeTensorInfo(r.shape,r.dtype,p)}};const t_={kernelName:Ii,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r,y:o,dy:s}=t,{depthRadius:i,bias:c,alpha:l,beta:u}=a;iC(s,"LRNGrad");const d=lo(s.shape),h=s.shape[3],p=n.data.get(s.dataId).values,f=n.data.get(r.dataId).values,m=n.data.get(o.dataId).values,g=new Float32Array(d),b=d;for(let y=0;y<b;y++){const e=y%h,t=y-e+Math.max(0,e-i),n=y-e+Math.min(h,e+i+1);let a=0;for(let r=t;r<n;r++)a+=Math.pow(f[r],2);a=l*a+c;for(let r=t;r<n;r++){let e=-2*l*u*f[r]*m[y]/a;y===r&&(e+=Math.pow(a,-u)),e*=p[y],g[r]+=e}}return n.makeTensorInfo(s.shape,r.dtype,g)}};function n_(e,t,n,a){const r=xo(a,lo(n));for(let o=0;o<r.length;++o){const n=o*t;let a=e[n];for(let r=0;r<t;++r){const t=e[n+r];(Number.isNaN(t)||t>a)&&(a=t)}r[o]=a}return r}function a_(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{reductionIndices:o,keepDims:s}=a,i=n;let c=r.shape;const l=c.length,u=bo(o,c);let d=u;const h=Wp(d,l);let p=i.data.get(r.dataId).values;if(null!=h){const e=new Array(l);for(let t=0;t<e.length;t++)e[t]=c[h[t]];p=aT(p,c,r.dtype,h,e),d=Up(d.length,l),c=e}iC(r,"max"),Bp("max",d,l);const[f,m]=Pp(c,d),g=n_(p,lo(m),f,r.dtype),b=i.write(g,f,r.dtype);let y=f;if(s){y=zp(f,u)}return{dataId:b,shape:y,dtype:r.dtype}}const r_={kernelName:Si,backendName:"cpu",kernelFunc:a_},o_=xC(((e,t)=>Math.max(e,t))),s_=BC(Ni,o_),i_={kernelName:Ni,backendName:"cpu",kernelFunc:s_};const c_={kernelName:Ci,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t;iC(r,"maxPool");const{filterSize:o,strides:s,pad:i,dimRoundingMode:c}=a;so(Kh(s,1),(()=>"Error in maxPool: Either strides or dilations must be 1. "+"Got strides ".concat(s," and dilations '").concat(1,"'")));const l=Lh(r.shape,o,s,1,i,c);let u;if(1===l.filterWidth&&1===l.filterHeight&&uo(l.inShape,l.outShape))u=mC({inputs:{x:r},backend:n});else{const e=n.data.get(r.dataId).values,t=Eo(r.shape),a=wT(e,r.shape,r.dtype,t,l,"max");u=n.makeTensorInfo(l.outShape,r.dtype,a.values)}return u}};const l_={kernelName:Ei,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{filterSize:o,strides:s,pad:i,dimRoundingMode:c,dataFormat:l}=a;iC(r,"maxPool3d");const u=Ph(r.shape,o,s,1,i,c,l),d=IT(n.data.get(r.dataId).values,r.shape,r.dtype,Eo(r.shape),u,"max");return n.makeTensorInfo(d.shape,"float32",d.values)}};const u_={kernelName:Ri,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{dy:r,input:o}=t,{filterSize:s,strides:i,pad:c,dimRoundingMode:l}=a;iC([r,o],"maxPool3DGrad");const u=Ph(o.shape,s,i,1,c,l),d=function(e,t){const n=Nd(t.outShape,"int32"),a=t.strideDepth,r=t.strideHeight,o=t.strideWidth,s=t.dilationDepth,i=t.dilationHeight,c=t.dilationWidth,l=t.effectiveFilterDepth,u=t.effectiveFilterHeight,d=t.effectiveFilterWidth,h=t.padInfo.front,p=t.padInfo.top,f=t.padInfo.left;for(let m=0;m<t.batchSize;++m)for(let g=0;g<t.inChannels;++g)for(let b=0;b<t.outDepth;++b){const y=b*a-h;let x=y;for(;x<0;)x+=s;const v=Math.min(t.inDepth,l+y);for(let a=0;a<t.outHeight;++a){const l=a*r-p;let h=l;for(;h<0;)h+=i;const w=Math.min(t.inHeight,u+l);for(let r=0;r<t.outWidth;++r){const p=r*o-f;let k=p;for(;k<0;)k+=c;const I=Math.min(t.inWidth,d+p);let S=Number.NEGATIVE_INFINITY,N=-1;for(let t=x;t<v;t+=s){const n=t-y;for(let a=h;a<w;a+=i){const r=a-l;for(let o=k;o<I;o+=c){const s=o-p,i=e.get(m,t,a,o,g);i>=S&&(S=i,N=n*u*d+r*u+s)}}}n.set(N,m,b,a,r,g)}}}return n}(n.bufferSync(o),u),h=u.strideDepth,p=u.strideHeight,f=u.strideWidth,m=u.dilationDepth,g=u.dilationHeight,b=u.dilationWidth,y=u.effectiveFilterDepth,x=u.effectiveFilterHeight,v=u.effectiveFilterWidth,w=y-1-u.padInfo.front,k=v-1-u.padInfo.left,I=x-1-u.padInfo.top,S=Nd(o.shape,"float32"),N=n.bufferSync(r);for(let C=0;C<u.batchSize;++C)for(let e=0;e<u.inChannels;++e)for(let t=0;t<u.inDepth;++t)for(let n=0;n<u.inHeight;++n)for(let a=0;a<u.inWidth;++a){const r=t-w,o=n-I,s=a-k;let i=0;for(let t=0;t<y;t+=m){const n=(r+t)/h;if(!(n<0||n>=u.outDepth||Math.floor(n)!==n))for(let a=0;a<x;a+=g){const r=(o+a)/p;if(!(r<0||r>=u.outHeight||Math.floor(r)!==r))for(let o=0;o<v;o+=b){const c=(s+o)/f;if(c<0||c>=u.outWidth||Math.floor(c)!==c)continue;const l=y*x*v-1-d.get(C,n,r,c,e)===t*x*v+a*v+o?1:0;if(0===l)continue;i+=N.get(C,n,r,c,e)*l}}}S.set(i,C,t,n,a,e)}return n.makeTensorInfo(S.shape,S.dtype,S.values)}};const d_={kernelName:Ti,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{dy:r,input:o,output:s}=t,i=o;iC([o,s],"maxPoolGrad");const{filterSize:c,strides:l,pad:u,dimRoundingMode:d}=a,h=Lh(i.shape,c,l,1,u,d),p=n.data.get(i.dataId).values,f=Nd(h.outShape,i.dtype,kT(p,i.shape,i.dtype,h).values),m=h.strideHeight,g=h.strideWidth,b=h.dilationHeight,y=h.dilationWidth,x=h.effectiveFilterHeight,v=h.effectiveFilterWidth,w=v-1-h.padInfo.left,k=x-1-h.padInfo.top,I=Nd(i.shape,"float32"),S=n.data.get(r.dataId).values,N=Nd(r.shape,"float32",S);for(let C=0;C<h.batchSize;++C)for(let e=0;e<h.inChannels;++e)for(let t=0;t<h.inHeight;++t)for(let n=0;n<h.inWidth;++n){const a=t-k,r=n-w;let o=0;for(let t=0;t<x;t+=b){const n=(a+t)/m;if(!(n<0||n>=h.outHeight||Math.floor(n)!==n))for(let a=0;a<v;a+=y){const s=(r+a)/g;if(s<0||s>=h.outWidth||Math.floor(s)!==s)continue;const i=x*v-1-f.get(C,n,s,e)===t*v+a?1:0;if(0===i)continue;o+=N.get(C,n,s,e)*i}}I.set(o,C,t,n,e)}return n.makeTensorInfo(I.shape,I.dtype,I.values)}};const h_={kernelName:_i,backendName:"cpu",kernelFunc:e=>{let{inputs:t,attrs:n,backend:a}=e;const{x:r}=t,{filterSize:o,strides:s,pad:i,includeBatchInIndex:c}=n,l=a;iC(r,"MaxPoolWithArgmax");const u=l.data.get(r.dataId).values,d=Lh(r.shape,o,s,[1,1],i),[h,p]=function(e,t,n,a,r){const o=wT(e,0,n,Eo(t),r,"max"),s=kT(e,t,n,r,!0,a);return[o.values,s.values]}(u,r.shape,r.dtype,c,d),f=l.write(h,d.outShape,r.dtype),m=l.write(p,d.outShape,r.dtype);return[{dataId:f,shape:d.outShape,dtype:r.dtype},{dataId:m,shape:d.outShape,dtype:"int32"}]}};const p_={kernelName:Ai,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{axis:o,keepDims:s}=a,i=bo(o,r.shape),c=lo(Pp(r.shape,i)[1]),l=[],u=n.makeTensorInfo([],"float32",new Float32Array([c]));l.push(u);const d=PC({inputs:{x:r},backend:n,attrs:{dtype:"float32"}});l.push(d);const h=YE({inputs:{a:d,b:u},backend:n});l.push(h);const p=NE({inputs:{x:h},backend:n,attrs:{axis:o,keepDims:s}});return l.forEach((e=>n.disposeIntermediateTensorInfo(e))),p}};const f_={kernelName:Fi,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{axis:o,keepDims:s}=a;iC(r,"min");const i=bo(o,r.shape);let c=i;const l=Wp(c,r.shape.length);let u=r;null!=l&&(u=rT({inputs:{x:r},backend:n,attrs:{perm:l}}),c=Up(c.length,r.shape.length)),Bp("min",c,u.shape.length);const[d,h]=Pp(u.shape,c),p=lo(h),f=Fo(lo(d),u.dtype),m=n.data.get(u.dataId).values;for(let b=0;b<f.length;++b){const e=b*p;let t=m[e];for(let n=0;n<p;++n){const a=m[e+n];(Number.isNaN(a)||a<t)&&(t=a)}f[b]=t}null!=l&&n.disposeIntermediateTensorInfo(u);const g=n.makeTensorInfo(d,u.dtype,f);if(s){const e=jC({inputs:{x:g},backend:n,attrs:{shape:zp(d,i)}});return n.disposeIntermediateTensorInfo(g),e}return g}},m_=xC(((e,t)=>Math.min(e,t))),g_=BC(Oi,m_),b_={kernelName:Oi,backendName:"cpu",kernelFunc:g_};const y_={kernelName:Di,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{paddings:o,mode:s}=a;iC(r,"mirrorPad");const i=o.map(((e,t)=>e[0]+r.shape[t]+e[1])),c=o.map((e=>e[0])),l=o.map(((e,t)=>e[0]+r.shape[t])),u="reflect"===s?0:1,d=n.data.get(r.dataId).values,h=r.shape.length,p=Eo(r.shape),f=lo(i),m=i.length,g=Eo(i),b=xo(r.dtype,f);for(let y=0;y<f;y++){let e=Lo(y,m,g);for(let n=0;n<m;n++)e[n]<c[n]?e[n]=2*c[n]-e[n]-u:e[n]>=l[n]&&(e[n]=2*(l[n]-1)-e[n]+u);e=e.map(((e,t)=>e-c[t]));const t=Mo(e,h,p);b[y]=d[t]}return{dataId:n.write(b,i,r.dtype),shape:i,dtype:r.dtype}}},x_=xC(((e,t)=>{const n=e%t;return e<0&&t<0||e>=0&&t>=0?n:(n+t)%t})),v_=BC(Mi,x_),w_={kernelName:Mi,backendName:"cpu",kernelFunc:v_};function k_(e){const{inputs:t,backend:n,attrs:a}=e,{logits:r}=t,{dim:o}=a,s=r.shape.length;let i=o;if(-1===i&&(i=s-1),i!==s-1)throw Error("Softmax along a non-last dimension is not yet supported. "+"Logits was rank ".concat(s," and dim was ").concat(i));const c=bo([i],r.shape),l=a_({inputs:{x:r},backend:n,attrs:{reductionIndices:c,keepDims:!1}}),u=zp(l.shape,c),d=jC({inputs:{x:l},backend:n,attrs:{shape:u}}),h=$E({inputs:{a:r,b:d},backend:n}),p=VE({inputs:{x:h},backend:n}),f=NE({inputs:{x:p},backend:n,attrs:{axis:c,keepDims:!1}}),m=jC({inputs:{x:f},backend:n,attrs:{shape:u}}),g=YE({inputs:{a:p,b:m},backend:n});return n.disposeIntermediateTensorInfo(l),n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),g}const I_={kernelName:Tc,backendName:"cpu",kernelFunc:k_};const S_={kernelName:Li,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{logits:r}=t,{numSamples:o,seed:s,normalized:i}=a;iC(r,"multinomial");const c=i?r:k_({inputs:{logits:r},backend:n,attrs:{dim:-1}}),l=c.shape[0],u=c.shape[1],d=n.data.get(c.dataId).values,h=[l,o],p=Fo(lo(h),"int32");for(let f=0;f<l;++f){const e=f*u,t=new Float32Array(u-1);t[0]=d[e];for(let r=1;r<t.length;++r)t[r]=t[r-1]+d[e+r];const n=sf.alea(s.toString()),a=f*o;for(let r=0;r<o;++r){const e=n();p[a+r]=t.length;for(let n=0;n<t.length;n++)if(e<t[n]){p[a+r]=n;break}}}return i||n.disposeIntermediateTensorInfo(c),n.makeTensorInfo(h,"int32",p)}};function N_(e,t,n){const a=Rl(-1,n);return wE([],t,a,e,n)}const C_={kernelName:zi,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{x:a}=t;iC(a,"neg");const r=n.data.get(a.dataId).values,[o,s]=N_(r,a.shape,a.dtype);return n.makeTensorInfo(s,a.dtype,o)}},T_=lm;const E_={kernelName:Wi,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{boxes:r,scores:o}=t,{maxOutputSize:s,iouThreshold:i,scoreThreshold:c}=a;iC(r,"NonMaxSuppression");const l=n.data.get(r.dataId).values,u=n.data.get(o.dataId).values,{selectedIndices:d}=T_(l,u,s,i,c);return n.makeTensorInfo([d.length],"int32",new Int32Array(d))}},R_=um;const __={kernelName:Vi,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{boxes:r,scores:o}=t,{maxOutputSize:s,iouThreshold:i,scoreThreshold:c,padToMaxOutputSize:l}=a;iC(r,"NonMaxSuppressionPadded");const u=n.data.get(r.dataId).values,d=n.data.get(o.dataId).values,{selectedIndices:h,validOutputs:p}=R_(u,d,s,i,c,l);return[n.makeTensorInfo([h.length],"int32",new Int32Array(h)),n.makeTensorInfo([],"int32",new Int32Array([p]))]}},A_=dm;const F_={kernelName:Ui,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{boxes:r,scores:o}=t,{maxOutputSize:s,iouThreshold:i,scoreThreshold:c,softNmsSigma:l}=a;iC(r,"NonMaxSuppressionWithScore");const u=n.data.get(r.dataId).values,d=n.data.get(o.dataId).values,h=s,p=i,f=c,m=l,{selectedIndices:g,selectedScores:b}=A_(u,d,h,p,f,m);return[n.makeTensorInfo([g.length],"int32",new Int32Array(g)),n.makeTensorInfo([b.length],"float32",new Float32Array(b))]}},O_=xC(((e,t)=>e!==t?1:0)),D_=BC(Bi,O_,null,"bool"),M_={kernelName:Bi,backendName:"cpu",kernelFunc:D_};const L_={kernelName:Hi,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{indices:r}=t,{dtype:o,depth:s,onValue:i,offValue:c}=a;iC(r,"oneHot");const l=lo(r.shape),u=new Float32Array(l*s);u.fill(c);const d=n.data.get(r.dataId).values;for(let h=0;h<l;++h)d[h]>=0&&d[h]<s&&(u[h*s+d[h]]=i);return n.makeTensorInfo([...r.shape,s],o,u)}};function P_(e){const{inputs:t,backend:n}=e,{x:a}=t;if("string"===a.dtype)throw new Error("zerosLike is not supported for string tensors");if("complex64"===a.dtype){const e=DC({inputs:{input:a},backend:n}),t=P_({inputs:{x:e},backend:n}),r=KT({inputs:{input:a},backend:n}),o=P_({inputs:{x:r},backend:n}),s=AC({inputs:{real:t,imag:o},backend:n});return n.disposeIntermediateTensorInfo(e),n.disposeIntermediateTensorInfo(t),n.disposeIntermediateTensorInfo(r),n.disposeIntermediateTensorInfo(o),s}return oR({backend:n,attrs:{shape:a.shape,value:0,dtype:a.dtype}})}const z_={kernelName:Qc,backendName:"cpu",kernelFunc:P_};const B_={kernelName:Gi,backendName:"cpu",kernelFunc:function e(t){const{inputs:n,backend:a}=t,{x:r}=n;if("string"===r.dtype)throw new Error("onesLike is not supported for string tensors");if("complex64"===r.dtype){const t=DC({inputs:{input:r},backend:a}),n=e({inputs:{x:t},backend:a}),o=KT({inputs:{input:r},backend:a}),s=P_({inputs:{x:o},backend:a}),i=AC({inputs:{real:n,imag:s},backend:a});return a.disposeIntermediateTensorInfo(t),a.disposeIntermediateTensorInfo(n),a.disposeIntermediateTensorInfo(o),a.disposeIntermediateTensorInfo(s),i}return oR({backend:a,attrs:{shape:r.shape,value:1,dtype:r.dtype}})}};function W_(e){const{inputs:t,backend:n,attrs:a}=e,{axis:r}=a;if(1===t.length)return GE({inputs:{input:t[0]},backend:n,attrs:{dim:r}});const o=t[0].shape,s=t[0].dtype;t.forEach((e=>{io(o,e.shape,"All tensors passed to stack must have matching shapes"),so(s===e.dtype,(()=>"All tensors passed to stack must have matching dtypes"))}));const i=[],c=t.map((e=>{const t=GE({inputs:{input:e},backend:n,attrs:{dim:r}});return i.push(t),t})),l=XT({inputs:c,backend:n,attrs:{axis:r}});return i.forEach((e=>n.disposeIntermediateTensorInfo(e))),l}const V_={kernelName:ji,backendName:"cpu",kernelFunc:W_};const U_={kernelName:Ki,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{paddings:o,constantValue:s}=a;iC(r,"pad");const i=o.map(((e,t)=>e[0]+r.shape[t]+e[1])),c=o.map((e=>e[0])),l=n.data.get(r.dataId).values,u=lo(r.shape),d=r.shape.length,h=Eo(r.shape),p=lo(i),f=i.length,m=Eo(i),g=xo(r.dtype,p);0!==s&&g.fill(s);for(let b=0;b<u;b++){const e=Lo(b,d,h).map(((e,t)=>e+c[t]));g[Mo(e,f,m)]=l[b]}return{dataId:n.write(g,i,r.dtype),shape:i,dtype:r.dtype}}},G_=xC(((e,t)=>Math.pow(e,t))),H_=BC(qi,G_),j_={kernelName:qi,backendName:"cpu",kernelFunc:H_};function K_(e,t,n,a){const[r,o]=Pp(e,a),s=su(t,"int32"),i=Fo(lo(r),s),c=lo(o);for(let l=0;l<i.length;++l){const e=l*c;let t=1;for(let a=0;a<c;++a)t*=n[e+a];i[l]=t}return{outVals:i,outShape:r,outDtype:s}}const q_={kernelName:Yi,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{axis:o,keepDims:s}=a;iC(r,"prod");const i=r.shape.length,c=bo(o,r.shape),l=Wp(c,i);let u=c,d=r;const h=[];null!=l&&(d=rT({inputs:{x:r},backend:n,attrs:{perm:l}}),h.push(d),u=Up(u.length,i));const p=n.data.get(d.dataId).values,{outVals:f,outShape:m,outDtype:g}=K_(d.shape,d.dtype,p,u);let b=m;return s&&(b=zp(m,c)),h.forEach((e=>n.disposeIntermediateTensorInfo(e))),n.makeTensorInfo(b,g,f)}};function X_(e,t,n,a){const r=[];let o=0;const s=t.length-1+n.length,i=new Array(s).fill(null).map((()=>[0]));!function(e,t){for(let n=0;n<e.length;++n){const a=e[n],r=n===e.length-1?t:e[n+1].length;if(0===a.length)throw new Error("Ragged splits may not be empty");if(a[0]<0)throw new Error("Ragged splits must be non-negative");if(a[a.length-1]>r)throw new Error("Ragged splits must not point past values");for(let e=1;e<a.length;++e)if(a[e-1]>a[e])throw new Error("Ragged splits must be sorted in ascending order")}}(n,a);let c=1;for(let l=0;l<t.length-1;++l){c*=t[l];const e=t[l+1];for(let t=1;t<c+1;++t)i[l].push(t*e)}for(let l=0;l<e.length;++l){let a=e[l],s=e[l]+1;for(let e=0;e<n.length;++e){const r=n[e],o=e+t.length-1;if(o>=0){const e=i[o],t=e[e.length-1]-r[a];for(let n=a;n<s;++n)i[o].push(r[n+1]+t)}a=r[a],s=r[s]}s!==a&&(r.push([a,s]),o+=s-a)}return{outSplits:i,valueSlices:r,numValues:o}}function Y_(e,t){const n=e.slice(0,t);for(;n.length<t;)n.push(1);for(let a=t;a<e.length;a++)n[t-1]*=e[a];return n}function Q_(e,t,n,a,r){const o=t.slice();o[0]=r;const s=vo(n,lo(o)),i=e.length;return function(e,t,n,a,r,o){const s=Y_(t,2)[1],i=Y_(o,2)[1];let c=0;for(const l of n)for(let t=l[0];t<l[1];++t){for(let n=0;n<a;++n)r[c*i+n]=e[t*s+n];++c}}(e,t,a,0===i?0:i/t[0],s,o),[s,o]}function J_(e,t,n,a,r,o,s,i){if(0===e.length)throw new Error("paramsNestedSplits must be non empty");if(0===t[0].length)throw new Error("Split tensors must not be scalars");if(function(e,t,n){e.forEach(((e,a)=>{if(e<0||e>=n){const r=Lo(a,t.length,Eo(t)).join(",");throw new Error("indices[".concat(r,"] = ").concat(e," is not in [0, ").concat(n,")"))}}))}(o,s,t[0][0]-1),0===a.length)throw new Error("params.rank must be nonzero");const c=a[0],{outSplits:l,valueSlices:u,numValues:d}=X_(o,s,e,c),h=function(e){const t=[];for(let n=0;n<e.length;++n){const a=vo("int32",e[n].length);t.push(a),e[n].forEach(((e,t)=>a[t]=e))}return t}(l),p=Q_(n,a,r,u,d);return[h,p[0],p[1]]}const Z_={kernelName:Qi,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{paramsNestedSplits:r,paramsDenseValues:o,indices:s}=t,{outputRaggedRank:i}=a,c=r.map((e=>n.data.get(e.dataId).values)),l=r.map((e=>e.shape)),u=n.data.get(o.dataId).values,d=n.data.get(s.dataId).values,[h,p,f]=J_(c,l,u,o.shape,o.dtype,d,s.shape),m=h.map((e=>n.makeTensorInfo([e.length],"int32",e))),g=n.makeTensorInfo(f,o.dtype,p);return m.concat([g])}},$_=2147483647;function eA(e,t,n,a,r,o,s){if(t.length>1)throw new Error("starts must be a scalar or vector");if(r.length>1)throw new Error("limits must be a scalar or vector");if(s.length>1)throw new Error("deltas must be a scalar or vector");const i=0===t.length,c=0===r.length,l=0===s.length,u=[];i||u.push(t[0]),c||u.push(r[0]),l||u.push(s[0]);for(let m=1;m<u.length;++m)if(u[m]!==u[m-1])throw new Error("starts, limits, and deltas must have the same shape");const d=0===u.length?1:u[0],h=vo("int32",d+1);h[0]=0;for(let m=0;m<d;++m){const t=i?e[0]:e[m],n=c?a[0]:a[m],r=l?o[0]:o[m];if(0===r)throw new Error("Requires delta != 0");let s;if(r>0&&n<t||r<0&&n>t)s=0;else if(s=Math.ceil(Math.abs((n-t)/r)),s>$_)throw new Error("Requires ((limit - start) / delta) <= ".concat($_));h[m+1]=h[m]+s}const p=vo(n,h[d]);let f=0;for(let m=0;m<d;++m){const t=h[m+1]-h[m];let n=i?e[0]:e[m];const a=l?o[0]:o[m];for(let e=0;e<t;++e)p[f++]=n,n+=a}return[h,p]}const tA={kernelName:Ji,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{starts:a,limits:r,deltas:o}=t,s=n.data.get(a.dataId).values,i=n.data.get(r.dataId).values,c=n.data.get(o.dataId).values,[l,u]=eA(s,a.shape,a.dtype,i,r.shape,c,o.shape);return[n.makeTensorInfo([l.length],"int32",l),n.makeTensorInfo([u.length],a.dtype,u)]}};var nA=Hm;class aA{constructor(e,t,n,a,r,o,s,i,c,l){this.shape=e,this.shapeShape=t,this.values=n,this.valuesShape=a,this.valuesDType=r,this.defaultValue=o,this.defaultValueShape=s,this.rowPartitionValues=i,this.rowPartitionValuesShapes=c,this.rowPartitionTypes=Km(l),this.raggedRank=qm(this.rowPartitionTypes)}getRowPartitionTypeByDimension(e){return this.rowPartitionTypes[0]===nA.FIRST_DIM_SIZE?this.rowPartitionTypes[e+1]:this.rowPartitionTypes[e]}getRowPartitionTensor(e){return this.rowPartitionTypes[0]===nA.FIRST_DIM_SIZE?this.rowPartitionValues[e+1]:this.rowPartitionValues[e]}getMaxWidth(e){const t=this.getRowPartitionTensor(e-1);switch(this.getRowPartitionTypeByDimension(e-1)){case nA.VALUE_ROWIDS:return aA.getMaxWidthValueRowID(t);case nA.ROW_SPLITS:return aA.getMaxWidthRowSplit(t);default:throw new Error("Cannot handle partition type ".concat(nA[this.getRowPartitionTypeByDimension(e-1)]))}}static getMaxWidthRowSplit(e){const t=e.length;if(0===t||1===t)return 0;let n=0;for(let a=0;a<t-1;++a){const t=e[a+1]-e[a];t>n&&(n=t)}return n}static getMaxWidthValueRowID(e){const t=e.length;if(0===t)return 0;let n=0,a=e[0],r=0;for(let o=1;o<t;++o){const t=e[o];t!==a&&(a=t,r=Math.max(o-n,r),n=o)}return Math.max(t-n,r)}tensorShapeFromTensor(e,t){let n=!(arguments.length>2&&void 0!==arguments[2])||arguments[2];if(0===t.length){if(-1===e[0])return[];throw new Error("The only valid scalar shape tensor is the fully unknown shape specified as -1.")}return oA(e,n)}calculateOutputSize(e){const t=this.valuesShape;Xm(this.defaultValueShape,t);const n=this.tensorShapeFromTensor(this.shape,this.shapeShape),a=jm(this.raggedRank,n,t);a[0]<0&&(a[0]=e);for(let r=1;r<=this.raggedRank;++r)a[r]<0&&(a[r]=this.getMaxWidth(r));return a}calculateFirstParentOutputIndex(e,t,n){const a=Math.min(e,n),r=[];let o=0;for(let s=0;s<a;++s,o+=t)r.push(o);for(let s=a;s<e;++s)r.push(-1);return so(r.length===e,(()=>"Final length of result must be equal to firstDimension.")),r}calculateOutputIndexRowSplit(e,t,n,a){const r=e.length,o=[];for(let s=0;s<r-1;++s){const r=e[s+1]-e[s];let i=Math.min(a,r),c=t[s];-1===c&&(i=0);for(let e=0;e<i;++e)o.push(c),c+=n;for(let e=0;e<r-i;++e)o.push(-1)}if(r>0&&o.length!==e[r-1])throw new Error("Invalid row split size.");return o}calculateOutputIndexValueRowID(e,t,n,a){const r=e.length,o=[];if(0===r)return[];let s=0,i=e[0];if(i>=t.length)throw new Error("Got currentValueRowId=".concat(i,", which is not less than ").concat(t.length));let c=t[i];o.push(c);for(let l=1;l<r;++l){const r=e[l];if(r===i)c>=0&&(++s,s<a?c+=n:c=-1);else{if(s=0,i=r,r>=t.length)throw new Error("Got nextValueRowId=".concat(r," which is not less than ").concat(t.length));c=t[r]}o.push(c)}if(o.length!==e.length)throw new Error("Invalid row ids.");return o}calculateOutputIndex(e,t,n,a){const r=this.getRowPartitionTensor(e),o=this.getRowPartitionTypeByDimension(e);switch(o){case nA.VALUE_ROWIDS:return this.calculateOutputIndexValueRowID(r,t,n,a);case nA.ROW_SPLITS:if(r.length-1>t.length)throw new Error("Row partition size is greater than output size: ".concat(r.length-1," > ").concat(t.length));return this.calculateOutputIndexRowSplit(r,t,n,a);default:throw new Error("Unsupported partition type: ".concat(nA[o]))}}getFirstDimensionSize(){const e=this.rowPartitionValues[0];if(0===this.rowPartitionTypes.length)throw new Error("No row_partition_types given.");const t=this.rowPartitionTypes[0];switch(t){case nA.FIRST_DIM_SIZE:return e[0];case nA.VALUE_ROWIDS:throw new Error("Cannot handle VALUE_ROWIDS in first dimension.");case nA.ROW_SPLITS:return this.rowPartitionValuesShapes[0][0]-1;default:throw new Error("Cannot handle type ".concat(nA[t]))}}compute(){if(this.rowPartitionValues[0].length<=0)throw new Error("Invalid first partition input. Tensor requires at least one element.");const e=this.getFirstDimensionSize(),t=this.calculateOutputSize(e),n=new Array(this.raggedRank+1);n[n.length-1]=1;for(let o=n.length-2;o>=0;--o)n[o]=n[o+1]*t[o+1];const a=oA(t,!1),r=vo(this.valuesDType,lo(a));if(n[0]*t[0]>0){let o=this.calculateFirstParentOutputIndex(e,n[0],t[0]);for(let e=1;e<=this.raggedRank;++e){o=this.calculateOutputIndex(e-1,o,n[e],t[e])}this.setOutput(this.raggedRank,o,r,a)}return[a,r]}setOutput(e,t,n,a){if(0===n.length)return;const r=this.values,o=n;let s=a.slice();s=s.slice(e+1);const i=lo(s),c=t.length;let l=this.defaultValue;if(l.length!==i&&1!==l.length){const e=this.defaultValueShape;Lu((()=>{const t=Qh(l,e),n=ap(t,s);l=n.dataSync()}))}let u=0,d=0,h=0;for(let p=0;p<=c;++p){let e=p<c?t[p]:-1;if(e!==h){if(d<h){const e=r.subarray(u*i);rA(o.subarray(d*i),e,(h-d)*i)}if(p>=c){const t=n.length;e=Math.floor(t/i)}if(e>h)if(1===this.defaultValue.length)o.subarray(h*i,e*i).fill(this.defaultValue[0]),h=e;else for(;e>h;){rA(o.slice(h*i),l,i),++h}e<0?(u=p+1,d=h):(u=p,d=h,h=d+1)}else++h}}}function rA(e,t,n){for(let a=0;a<n;a++)e[a]=t[a]}function oA(e,t){const n=[];for(let a of e){if(a<0){if(!t)throw new Error("Dimension ".concat(a," must be >= 0"));if(a<-1)throw new Error("Dimension ".concat(a," must be >= -1"));a=-1}n.push(a)}return n}function sA(e,t,n,a,r,o,s,i,c,l){return new aA(e,t,n,a,r,o,s,i,c,l).compute()}const iA={kernelName:Zi,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{shape:r,values:o,defaultValue:s,rowPartitionTensors:i}=t,{rowPartitionTypes:c}=a,l=n.data.get(r.dataId).values,u=n.data.get(o.dataId).values,d=n.data.get(s.dataId).values,h=i.map((e=>n.data.get(e.dataId).values)),p=i.map((e=>e.shape)),[f,m]=sA(l,r.shape,u,o.shape,o.dtype,d,s.shape,h,p,c);return n.makeTensorInfo(f,o.dtype,m)}};function cA(e,t,n,a){if(e===t||e<t&&n<0||t<e&&n>1)return Fo(0,a);const r=Fo(Math.abs(Math.ceil((t-e)/n)),a);t<e&&1===n&&(n=-1),r[0]=e;for(let o=1;o<r.length;o++)r[o]=r[o-1]+n;return r}const lA={kernelName:$i,backendName:"cpu",kernelFunc:function(e){const{backend:t,attrs:n}=e,{start:a,stop:r,dtype:o,step:s}=n,i=cA(a,r,s,o);return t.makeTensorInfo([i.length],o,i)}},uA=dC(tc,(e=>1/e)),dA={kernelName:tc,backendName:"cpu",kernelFunc:uA};const hA={kernelName:sc,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{images:r}=t,{alignCorners:o,halfPixelCenters:s,size:i}=a;iC(r,"resizeBilinear");const c=Eo(r.shape),[l,u]=i,[d,h,p,f]=r.shape,m=n.data.get(r.dataId).values,g=new Float32Array(lo([d,l,u,f])),b=[o&&l>1?h-1:h,o&&u>1?p-1:p],y=[o&&l>1?l-1:l,o&&u>1?u-1:u];let x=0;const v=b[0]/y[0],w=b[1]/y[1];for(let k=0;k<d;k++)for(let e=0;e<l;e++){let t;t=s?v*(e+.5)-.5:v*e;const n=Math.max(0,Math.floor(t)),a=t-n,r=Math.min(h-1,Math.ceil(t)),o=k*c[0]+n*c[1],i=k*c[0]+r*c[1];for(let e=0;e<u;e++){let t;t=s?w*(e+.5)-.5:w*e;const n=Math.max(0,Math.floor(t)),r=t-n,l=Math.min(p-1,Math.ceil(t)),u=o+n*c[2],d=i+n*c[2],h=o+l*c[2],b=i+l*c[2];for(let e=0;e<f;e++){const t=m[u+e],n=m[d+e],o=t+(m[h+e]-t)*r,s=o+(n+(m[b+e]-n)*r-o)*a;g[x++]=s}}}return n.makeTensorInfo([d,l,u,f],"float32",g)}};const pA={kernelName:ic,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{images:r,dy:o}=t,{alignCorners:s}=a;iC([o,r],"resizeBilinearGrad");const i=Eo(r.shape),[c,l,u,d]=r.shape,[,h,p]=o.shape,f=new Float32Array(c*l*u*d),m=[s&&h>1?l-1:l,s&&p>1?u-1:u],g=[s&&h>1?h-1:h,s&&p>1?p-1:p],b=m[0]/g[0],y=m[1]/g[1],x=n.data.get(o.dataId).values;let v=0;for(let w=0;w<c;w++){const e=w*i[0];for(let t=0;t<h;t++){const n=t*b,a=Math.floor(n),r=Math.min(Math.ceil(n),l-1),o=e+a*i[1],s=e+r*i[1],c=n-a,h=1-c;for(let e=0;e<p;e++){const t=e*y,n=Math.floor(t),a=Math.min(Math.ceil(t),u-1),r=t-n,l=1-r,p=o+n*i[2],m=o+a*i[2],g=s+n*i[2],b=s+a*i[2],w=h*l,k=h*r,I=c*l,S=c*r;for(let e=0;e<d;e++){const t=x[v++];f[p+e]+=t*w,f[m+e]+=t*k,f[g+e]+=t*I,f[b+e]+=t*S}}}}return n.makeTensorInfo([c,u,l,d],"float32",f)}};const fA={kernelName:rc,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{images:r}=t,{alignCorners:o,halfPixelCenters:s,size:i}=a;iC(r,"resizeNearestNeighbor");const c=Eo(r.shape),[l,u]=i,[d,h,p,f]=r.shape,m=n.data.get(r.dataId).values,g=new Float32Array(d*l*u*f),b=[o&&l>1?h-1:h,o&&u>1?p-1:p],y=[o&&l>1?l-1:l,o&&u>1?u-1:u],x=b[0]/y[0],v=b[1]/y[1];let w=0;for(let k=0;k<d;k++){const e=k*c[0];for(let t=0;t<l;t++){const n=s?x*(t+.5):x*t;let a=Math.min(h-1,o?Math.round(n):Math.floor(n));s&&(a=Math.max(0,a));const r=e+a*c[1];for(let e=0;e<u;e++){const t=s?v*(e+.5):v*e;let n=Math.min(p-1,o?Math.round(t):Math.floor(t));s&&(n=Math.max(0,n));const a=r+n*c[2];for(let e=0;e<f;e++){const t=m[a+e];g[w++]=t}}}}return n.makeTensorInfo([d,l,u,f],r.dtype,g)}};const mA={kernelName:oc,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{images:r,dy:o}=t,{alignCorners:s}=a;iC([o,r],"resizeNearestNeighborGrad");const i=Eo(r.shape),c=Eo(o.shape),[l,u,d,h]=r.shape,[,p,f]=o.shape,m=new Float32Array(l*u*d*h),g=n.data.get(o.dataId).values,b=[s&&p>1?u-1:u,s&&f>1?d-1:d],y=[s&&p>1?p-1:p,s&&f>1?f-1:f],x=b[0]/y[0],v=b[1]/y[1],w=1/x,k=1/v,I=2*Math.ceil(w)+2,S=2*Math.ceil(k)+2;for(let N=0;N<l;N++){const e=N*i[0];for(let t=0;t<u;t++){const n=e+t*i[1],a=Math.floor(t*w),r=Math.floor(a-I/2);for(let o=0;o<d;o++){const a=n+o*i[2],l=Math.floor(o*k),b=Math.floor(l-S/2);for(let n=0;n<h;n++){let i=0;for(let a=0;a<I;a++){const l=a+r;if(l<0||l>=p)continue;const h=e+l*c[1],m=l*x;if(t===Math.min(u-1,s?Math.round(m):Math.floor(m)))for(let e=0;e<S;e++){const t=e+b;if(t<0||t>=f)continue;const a=h+t*c[2],r=t*v;o===Math.min(d-1,s?Math.round(r):Math.floor(r))&&(i+=g[a+n])}}m[a+n]=i}}}}return n.makeTensorInfo(r.shape,r.dtype,m)}};const gA={kernelName:lc,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{dims:o}=a;iC(r,"reverse");const s=r.shape.length,i=bo(o,r.shape);if(0===s)return mC({inputs:{x:r},backend:n});const c=new ql(r.shape,r.dtype),l=n.bufferSync(r);for(let u=0;u<c.size;u++){const e=c.indexToLoc(u),t=e.slice();i.forEach((e=>t[e]=r.shape[e]-1-t[e])),c.set(l.get(...t),...e)}return n.makeTensorInfo(c.shape,c.dtype,c.values)}},bA={kernelName:$c,backendName:"cpu",kernelFunc:e=>{let{inputs:t,attrs:n,backend:a}=e;const{image:r}=t,{radians:o,fillValue:s,center:i}=n,c=a,l=xo(r.dtype,lo(r.shape)),[u,d,h,p]=r.shape,[f,m]=Jm(i,d,h),g=Math.sin(o),b=Math.cos(o),y=c.data.get(r.dataId).values;for(let x=0;x<u;x++){const e=x*h*d*p;for(let t=0;t<d;t++){const n=t*(h*p);for(let a=0;a<h;a++){const r=a*p;for(let o=0;o<p;o++){const i=[u,t,a,o],c=i[2],x=i[1];let v=(c-f)*b-(x-m)*g,w=(c-f)*g+(x-m)*b;v=Math.round(v+f),w=Math.round(w+m);let k=s;if("number"!==typeof s&&(k=3===o?255:s[o]),v>=0&&v<h&&w>=0&&w<d){k=y[e+w*(h*p)+v*p+o]}l[e+n+r+o]=k}}}}return{dataId:c.write(l,r.shape,r.dtype),shape:r.shape,dtype:r.dtype}}},yA=dC(uc,(e=>{const t=Math.floor(e);return e-t<.5?Math.floor(e):e-t>.5?Math.ceil(e):t%2===0?t:t+1})),xA={kernelName:uc,backendName:"cpu",kernelFunc:yA},vA=uC((e=>1/Math.sqrt(e))),wA=hC(dc,vA),kA={kernelName:dc,backendName:"cpu",kernelFunc:wA};function IA(e,t,n,a,r,o,s,i,c,l){const u=[a/r,r],d=e.values,h=t.values;if(0===a)return Nd(n,t.dtype);const p=c instanceof ql?c:Nd(u,t.dtype);"string"===typeof c||"number"===typeof c?p.values.fill(c):"boolean"===typeof c&&p.values.fill(+c);for(let f=0;f<o;f++){const e=[];let o=0;for(let t=0;t<s;t++){const n=d[f*s+t];e.push(n),o+=n*i[t]}if(o<0||o>=a/r)throw new Error("Invalid indices: ".concat(e," does not index into ").concat(n));for(let n=0;n<r;n++)l?p.values[o*r+n]+=h[f*r+n]:p.values[o*r+n]=0===t.rank?h[0]:h[f*r+n]}return p}const SA={kernelName:hc,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{indices:r,updates:o}=t,{shape:s}=a,{sliceRank:i,numUpdates:c,sliceSize:l,strides:u,outputSize:d}=sg(0,r,s),h=IA(n.bufferSync(r),n.bufferSync(o),s,d,l,c,i,u,0,!0);return n.makeTensorInfo(s,h.dtype,h.values)}};function NA(e,t){let n=0,a=e.length,r=0;for(;n<a;)r=Math.floor((n+a)/2),e[r]<t?n=r+1:a=r;return a}function CA(e,t){let n=0,a=e.length,r=0;for(;n<a;)r=Math.floor((n+a)/2),e[r]<=t?n=r+1:a=r;return a}const TA={kernelName:fc,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{sortedSequence:r,values:o}=t,{side:s}=a,i=function(e,t,n,a,r,o){const s=vo("int32",n*r);for(let i=0;i<n;++i){const n=e.slice(i*a,(i+1)*a),c=i*r;for(let e=0;e<r;++e)s[c+e]="left"===o?NA(n,t[e+c]):CA(n,t[e+c])}return s}(n.data.get(r.dataId).values,n.data.get(o.dataId).values,r.shape[0],r.shape[1],o.shape[1],s);return n.makeTensorInfo(o.shape,"int32",i)}};const EA={kernelName:mc,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{condition:a,t:r,e:o}=t;iC([a,r,o],"select");const s=a.shape.length,i=n.data.get(a.dataId).values,c=n.data.get(r.dataId).values,l=n.data.get(o.dataId).values,u=su(r.dtype,o.dtype),d=Fo(lo(r.shape),u);let h=0;const p=0===s||s>1||1===r.shape.length?1:lo(r.shape.slice(1));for(let f=0;f<i.length;f++)for(let e=0;e<p;e++)1===i[f]?d[h++]=c[f]:d[h++]=l[f];return n.makeTensorInfo(r.shape,u,d)}},RA=ig,_A=cg,AA=dC(gc,(e=>e>=0?_A*e:RA*(Math.exp(e)-1))),FA={kernelName:gc,backendName:"cpu",kernelFunc:AA},OA=dC(vc,(e=>e<0?-1:e>0?1:0)),DA={kernelName:vc,backendName:"cpu",kernelFunc:OA},MA=dC(yc,(e=>Math.sin(e))),LA={kernelName:yc,backendName:"cpu",kernelFunc:MA},PA=dC(xc,(e=>Math.sinh(e))),zA={kernelName:xc,backendName:"cpu",kernelFunc:PA},BA=Math.log(1.1920928955078125e-7)+2,WA=dC(kc,(e=>{const t=e>-BA,n=e<BA,a=Math.exp(e);let r;return r=n?a:t?e:Math.log(1+a),r})),VA={kernelName:kc,backendName:"cpu",kernelFunc:WA};const UA={kernelName:Nc,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{blockShape:o,paddings:s}=a;iC([r],"spaceToBatchND");const i=lo(o),c=[[0,0]];c.push(...s);for(let g=1+o.length;g<r.shape.length;++g)c.push([0,0]);const l=U_.kernelFunc({inputs:{x:r},backend:n,attrs:{paddings:c,constantValue:0}}),u=Zm(l.shape,o,i,!1),d=$m(u.length,o.length,!1),h=eg(l.shape,o,i,!1),p=jC({inputs:{x:l},backend:n,attrs:{shape:u}}),f=rT({inputs:{x:p},backend:n,attrs:{perm:d}}),m=jC({inputs:{x:f},backend:n,attrs:{shape:h}});return n.disposeIntermediateTensorInfo(l),n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(f),m}};function GA(e,t,n,a,r,o,s){const i=t[0],c=o[0],l=new Array(c),u=new Array(i),d=t[1];if(0===c){if(0!==i)throw new Error(Dg(i));return[vo(n,0),[0,d],vo(r,0),l,u]}let h=!0,p=0;const f=new Array(c).fill(0);for(let g=0;g<i;++g){const t=e[g*d];if(t<0)throw new Error(Mg(g,t));if(t>=c)throw new Error(Lg(g,t,c));++f[t],h=h&&t>=p,p=t}let m=!0;for(let g=0;g<c;++g){const e=0===f[g];l[g]=e,m=m&&!e,f[g]=Math.max(f[g],1),g>0&&(f[g]+=f[g-1])}if(m&&h){const t=e,n=a;for(let e=0;e<i;++e)u[e]=e;return[t,[i,d],n,l,u]}{const t=f[c-1],o=vo(n,t*d),h=vo(r,t),p=new Array(c).fill(0);for(let n=0;n<i;++n){const t=e[n*d],r=p[t],s=(0===t?0:f[t-1])+r;p[t]++;for(let a=0;a<d;++a)o[s*d+a]=e[n*d+a];h[s]=a[n],u[n]=s}for(let e=0;e<c;++e){if(0===p[e]){const t=0===e?0:f[e-1];o[t*d+0]=e;for(let e=1;e<d;++e)o[t*d+e]=0;h[t]=s}}return[o,[t,d],h,l,u]}}const HA={kernelName:Ec,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{indices:a,values:r,denseShape:o,defaultValue:s}=t;if(1!==o.shape.length)throw new Error("Dense shape must be a vector, saw:\n        ".concat(o.shape));if(2!==a.shape.length)throw new Error("Indices must be a matrix, saw:\n        ".concat(a.shape));if(1!==r.shape.length)throw new Error("Values must be a vector, saw:\n        ".concat(r.shape));if(0!==s.shape.length)throw new Error("Default value must be a scalar, saw:\n        ".concat(s.shape));const i=n.data.get(a.dataId).values,c=n.data.get(r.dataId).values,l=n.data.get(o.dataId).values,u=n.data.get(s.dataId).values[0],[d,h,p,f,m]=GA(i,a.shape,a.dtype,c,r.dtype,l,u);return[n.makeTensorInfo(h,a.dtype,d),n.makeTensorInfo([h[0]],r.dtype,p),n.makeTensorInfo([f.length],"bool",new Uint8Array(f.map((e=>Number(e))))),n.makeTensorInfo([m.length],a.dtype,new Int32Array(m))]}};function jA(e,t,n,a,r){const o=lo(a),s=t[0],i=r.length,c=[];let l=1,u=-1;for(let m=0;m<i;++m){const e=r[m];if(-1===e){if(-1!==u)throw new Error(Pg(u,m));u=m,c.push(1)}else{if(e<0)throw new Error(zg(m,e));l*=e,c.push(e)}}if(-1!==u){if(l<=0)throw new Error("reshape cannot infer the missing input size for an empty tensor unless all specified input sizes are non-zero");const e=Math.trunc(o/l);if(l*e!==o)throw new Error(Wg(a,c));c[u]=e}if(lo(c)!==o)throw new Error(Vg(a,c));const d=a.length,h=[];if(d>0){h[d-1]=1;for(let e=d-2;e>=0;--e)h[e]=h[e+1]*a[e+1]}const p=[];if(i>0){p[i-1]=1;for(let e=i-2;e>=0;--e)p[e]=p[e+1]*c[e+1]}const f=vo(n,s*i);for(let m=0;m<s;++m){let t=0;for(let n=0;n<d;++n)t+=e[m*d+n]*h[n];for(let e=0;e<i;++e)f[m*i+e]=Math.trunc(t/p[e]),t%=p[e]}return[f,[s,i],c]}const KA={kernelName:Rc,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{inputIndices:a,inputShape:r,newShape:o}=t;if(2!==a.shape.length)throw new Error("Input indices should be a matrix but received shape\n        ".concat(a.shape));if(1!==r.shape.length)throw new Error("Input shape should be a vector but received shape\n        ".concat(r.shape));if(1!==o.shape.length)throw new Error("Target shape should be a vector but received shape ".concat(o.shape));const s=Array.from(n.data.get(r.dataId).values),i=n.data.get(a.dataId).values,c=Array.from(n.data.get(o.dataId).values),[l,u,d]=jA(i,a.shape,a.dtype,s,c);return[n.makeTensorInfo(u,a.dtype,l),n.makeTensorInfo([d.length],o.dtype,new Int32Array(d))]}};function qA(e,t,n,a,r){let o=arguments.length>5&&void 0!==arguments[5]&&arguments[5],s=arguments.length>6&&void 0!==arguments[6]?arguments[6]:0;const i=a.length,c=[t[0],e.length/t[0]],l=c[1],u=i>0?r[i-1]+1:0;if(u<0)throw new Error("segment ids must be >= 0");const d=t.slice();d[0]=u;const h=vo(n,d.reduce(((e,t)=>e*t),1));if(0===i)return u>0&&h.fill(s),[h,d];if(u<=0)throw new Error("segment ids must be >= 0");let p=0,f=1,m=0,g=r[p];for(;;){let t=0;if(f<i){if(t=r[f],g===t){++f;continue}if(g>=t)throw new Error("segment ids are not increasing")}if(g<0||g>=u)throw new Error(Hg(g,u));g>m&&h.fill(s,m*l,g*l);for(let n=p;n<f;++n){const t=a[n];if(t<0||t>=c[0])throw new Error(jg(n,a[n],c[0]));for(let n=0;n<l;n++)h[g*l+n]+=e[t*l+n]}if(o)for(let e=0;e<l;e++)h[g*l+e]/=f-p;if(p=f,++f,m=g+1,g=t,f>i)break}return m<u&&h.fill(s,m*l,u*l),[h,d]}const XA={kernelName:_c,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{data:a,indices:r,segmentIds:o}=t;if(a.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==r.shape.length)throw new Error("Indices should be a vector but received shape\n          ".concat(r.shape));if(1!==o.shape.length)throw new Error("Segment ids should be a vector but received shape\n          ".concat(o.shape));if(r.shape[0]!==o.shape[0])throw new Error("segmentIds and indices should have same size.");const s=n.data.get(a.dataId).values,i=n.data.get(r.dataId).values,c=n.data.get(o.dataId).values,[l,u]=qA(s,a.shape,a.dtype,i,c,!0);return n.makeTensorInfo(u,a.dtype,l)}};const YA={kernelName:Ac,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{data:a,indices:r,segmentIds:o}=t;if(a.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==r.shape.length)throw new Error("Indices should be a vector but received shape\n         ".concat(r.shape));if(1!==o.shape.length)throw new Error("Segment ids should be a vector but received shape\n         ".concat(o.shape));if(r.shape[0]!==o.shape[0])throw new Error("segmentIds and indices should have same size.");const s=n.data.get(a.dataId).values,i=n.data.get(r.dataId).values,c=n.data.get(o.dataId).values,[l,u]=qA(s,a.shape,a.dtype,i,c);return n.makeTensorInfo(u,a.dtype,l)}};const QA={kernelName:Fc,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{sparseIndices:r,sparseValues:o,defaultValue:s}=t,{outputShape:i}=a,{sliceRank:c,numUpdates:l,sliceSize:u,strides:d,outputSize:h}=sg(0,r,i),p=!1,f=n.bufferSync(r);let m;switch(o.dtype){case"bool":m=IA(f,n.bufferSync(o),i,h,u,l,c,d,Boolean(n.data.get(s.dataId).values[0]),p);break;case"float32":m=IA(f,n.bufferSync(o),i,h,u,l,c,d,n.data.get(s.dataId).values[0],p);break;case"int32":m=IA(f,n.bufferSync(o),i,h,u,l,c,d,n.data.get(s.dataId).values[0],p);break;case"string":m=IA(f,n.bufferSync(o),i,h,u,l,c,d,Ol(n.data.get(s.dataId).values[0]),p);break;default:throw new Error("Unsupported type ".concat(o.dtype))}return n.makeTensorInfo(i,m.dtype,m.values)}};const JA={kernelName:Cc,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{numOrSizeSplits:o,axis:s}=a,i=bo(s,r.shape)[0],c=Og(r,o,i),l=new Array(r.shape.length).fill(0),u=r.shape.slice();return c.map((e=>{const t=[...u];t[i]=e;const a=_T({inputs:{x:r},backend:n,attrs:{begin:l,size:t}});return l[i]+=e,a}))}},ZA=uC((e=>Math.sqrt(e))),$A=dC(Ic,(e=>Math.sqrt(e))),eF={kernelName:Ic,backendName:"cpu",kernelFunc:$A},tF={kernelName:Dc,backendName:"cpu",kernelFunc:e=>{let{inputs:t,backend:n}=e;const{x:a}=t,r=n;iC(a,"square");const o=r.data.get(a.dataId).values,s=new Float32Array(o.length);for(let i=0;i<o.length;++i){const e=o[i];s[i]=e*e}return{dataId:r.write(s,a.shape,a.dtype),shape:a.shape,dtype:a.dtype}}},nF=xC(((e,t)=>{const n=e-t;return n*n})),aF=BC(Oc,nF),rF={kernelName:Oc,backendName:"cpu",kernelFunc:aF},oF=uC(((e,t)=>{const{pattern:n,replaceGlobal:a,rewrite:r}=t;return e.replace(new RegExp(n,a?"g":""),r)})),sF=hC(Mc,oF),iF={kernelName:Mc,backendName:"cpu",kernelFunc:sF},cF=dC(Jc,((e,t)=>{const n=t;return isNaN(e)?NaN:e>0?1:n.alpha})),lF={kernelName:Jc,backendName:"cpu",kernelFunc:cF};function uF(e,t,n,a){const r=Nd(e,t.dtype);for(let o=0;o<r.size;o++){const e=r.indexToLoc(o),s=new Array(e.length);for(let t=0;t<s.length;t++)s[t]=e[t]*n[t]+a[t];r.set(t.get(...s),...e)}return r}const dF={kernelName:Lc,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{begin:o,end:s,strides:i,beginMask:c,endMask:l,ellipsisMask:u,newAxisMask:d,shrinkAxisMask:h}=a;iC(r,"stridedSlice");const{finalShapeSparse:p,finalShape:f,isIdentity:m,sliceDim0:g,isSimpleSlice:b,begin:y,end:x,strides:v}=_h(r.shape,o,s,i,c,l,u,d,h);let w;if(m)w=jC({inputs:{x:r},backend:n,attrs:{shape:f}});else if(g||b){so(r.shape.length>=1,(()=>"Input must have rank at least 1, got: ".concat(r.shape.length)));const e=bh(y,x,v),t=_T({inputs:{x:r},backend:n,attrs:{begin:y,size:e}});w=jC({inputs:{x:t},backend:n,attrs:{shape:f}}),n.disposeIntermediateTensorInfo(t)}else{const e=uF(p,n.bufferSync(r),v,y);w=n.makeTensorInfo(f,e.dtype,e.values)}return w}};class hF{constructor(e,t,n,a,r,o){this.separator=Fl(e),this.nGramWidths=t,this.leftPad=Fl(n),this.rightPad=Fl(a),this.padWidth=r,this.preserveShort=o}getPadWidth(e){return Math.min(this.padWidth<0?e-1:this.padWidth,e-1)}getNumNGrams(e,t){const n=this.getPadWidth(t);return Math.max(0,e+2*n-t+1)}createNGrams(e,t,n,a,r,o){for(let s=0;s<r;++s){const i=this.getPadWidth(o),c=Math.max(0,i-s),l=Math.max(0,i-(r-(s+1))),u=o-(c+l),d=t+(c>0?0:s-i);let h=0;h+=c*this.leftPad.length;for(let t=0;t<u;++t)h+=e[d+t].length;h+=l*this.rightPad.length;h+=(c+l+u-1)*this.separator.length,n[a+s]=new Uint8Array(h);const p=n[a+s];let f=0;const m=e=>e.forEach((e=>p[f++]=e));for(let e=0;e<c;++e)m(this.leftPad),m(this.separator);for(let t=0;t<u-1;++t)m(e[d+t]),m(this.separator);if(u>0){m(e[d+u-1]);for(let e=0;e<l;++e)m(this.separator),m(this.rightPad)}else{for(let e=0;e<l-1;++e)m(this.rightPad),m(this.separator);m(this.rightPad)}}}compute(e,t){const n=e.length,a=t.length;if(a>0){let e=t[0];if(0!==e)throw new Error("First split value must be 0, got ".concat(e));for(let r=1;r<a;++r){let a=t[r]>=e;if(a=a&&t[r]<=n,!a)throw new Error("Invalid split value ".concat(t[r],", must be in [").concat(e,", ").concat(n,"]"));e=t[r]}if(e!==n)throw new Error("Last split value must be data size. Expected ".concat(n,", got ").concat(e))}const r=a-1,o=vo("int32",a);if(0===n||0===a){const e=new Array(n);for(let t=0;t<=r;++t)o[t]=0;return[e,o]}o[0]=0;for(let i=1;i<=r;++i){const e=t[i]-t[i-1];let n=0;this.nGramWidths.forEach((t=>{n+=this.getNumNGrams(e,t)})),this.preserveShort&&e>0&&0===n&&(n=1),o[i]=o[i-1]+n}const s=new Array(o[r]);for(let i=0;i<r;++i){const n=t[i];let a=o[i];if(this.nGramWidths.forEach((r=>{const o=t[i+1]-t[i],c=this.getNumNGrams(o,r);this.createNGrams(e,n,s,a,c,r),a+=c})),this.preserveShort&&a===o[i]){const r=t[i+1]-t[i];if(0===r)continue;const o=r+2*this.padWidth,c=1;this.createNGrams(e,n,s,a,c,o)}}return[s,o]}}function pF(e,t,n,a,r,o,s,i){return new hF(n,a,r,o,s,i).compute(e,t)}const fF={kernelName:Pc,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{separator:r,nGramWidths:o,leftPad:s,rightPad:i,padWidth:c,preserveShortSequences:l}=a,{data:u,dataSplits:d}=t,h=n.data.get(u.dataId).values,p=n.data.get(d.dataId).values,[f,m]=pF(h,p,r,o,s,i,c,l);return[n.makeTensorInfo([f.length],"string",f),n.makeTensorInfo(d.shape,"int32",m)]}};function mF(e,t,n,a){if(!e.length)return;if(0===t.length){for(let t=0;t<e.length;++t)a.push(e.subarray(t,t+1));return}if(1===t.length){const r=t[0];let o=e.indexOf(r);for(;-1!==o;){const t=e.subarray(0,o);n&&0===t.length||a.push(t),o=(e=e.subarray(o+1)).indexOf(r)}return void(n&&0===e.length||a.push(e))}let r=0;for(let o=0;o<e.length+1;o++)if(o===e.length||-1!==t.indexOf(e[o])){const t=e.subarray(r,o);n&&0===t.length||a.push(t),r=o+1}}function gF(e,t,n){const a=e.length,r=[];let o=0,s=0;const i=new Array(a);for(let h=0;h<a;++h){const a=r.length;mF(e[h],t,n,r);const c=r.length-a;i[h]=c,o+=c,s=Math.max(s,c)}const c=vo("int32",2*o),l=new Array(o),u=[a,s];let d=0;for(let h=0;h<a;++h)for(let e=0;e<i[h];++e)c[2*d]=h,c[2*d+1]=e,l[d]=r[d],++d;return[c,l,u]}const bF={kernelName:zc,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{skipEmpty:r}=a,{input:o,delimiter:s}=t;if("string"!==o.dtype)throw new Error("Input must be of datatype string");if(1!==o.shape.length)throw new Error("Input must be a vector, got shape: ".concat(o.shape));if(0!==s.shape.length)throw new Error("Delimiter must be a scalar, got shape: ".concat(s.shape));const i=n.data.get(o.dataId).values,c=n.data.get(s.dataId).values[0],[l,u,d]=gF(i,c,r),h=u.length;return[n.makeTensorInfo([h,2],"int32",l),n.makeTensorInfo([h],"string",u),n.makeTensorInfo([2],"int32",new Int32Array(d))]}};function yF(e,t){const n=vo("int32",e.length);for(let a=0;a<e.length;++a)n[a]=El(e[a]).modulo(t).getLowBitsUnsigned();return n}const xF={kernelName:Bc,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{numBuckets:r}=a,{input:o}=t;if("string"!==o.dtype)throw new Error("Input must be of datatype string");if(r<=0)throw new Error("Number of buckets must be at least 1");const s=yF(n.data.get(o.dataId).values,r);return n.makeTensorInfo(o.shape,"int32",s)}},vF=dC(Vc,(e=>Math.tan(e))),wF={kernelName:Vc,backendName:"cpu",kernelFunc:vF},kF=dC(Uc,(e=>Math.tanh(e)));const IF={kernelName:pc,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{tensor:a,indices:r,updates:o}=t,{sliceRank:s,numUpdates:i,sliceSize:c,strides:l,outputSize:u}=sg(0,r,a.shape),d=n.bufferSync(r),h=n.bufferSync(o),p=n.bufferSync(a),f=IA(d,h,a.shape,u,c,i,s,l,p,!1);return n.makeTensorInfo(a.shape,f.dtype,f.values)}};function SF(e,t){const n=new Array(e.rank);for(let r=0;r<n.length;r++)n[r]=e.shape[r]*t[r];const a=Nd(n,e.dtype);for(let r=0;r<a.values.length;++r){const t=a.indexToLoc(r),n=new Array(e.rank);for(let a=0;a<n.length;a++)n[a]=t[a]%e.shape[a];const o=e.locToIndex(n);a.values[r]=e.values[o]}return a}const NF={kernelName:Gc,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{reps:o}=a;iC(r,"tile");const s=SF(n.bufferSync(r),o);return n.makeTensorInfo(s.shape,s.dtype,s.values)}},CF=(e,t)=>{const n=t.value-e.value;return 0===n?e.index-t.index:n};function TF(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:e.length-1;for(;a>n;){if(a-n>600){const r=a-n+1,o=t-n+1,s=Math.log(r),i=.5*Math.exp(2*s/3),c=.5*Math.sqrt(s*i*(r-i)/r)*Math.sign(o-r/2);TF(e,t,Math.max(n,Math.floor(t-o*i/r+c)),Math.min(a,Math.floor(t+(r-o)*i/r+c)))}const r=e[t];let o=n,s=a;for(oo(e,n,t),CF(e[a],r)>0&&oo(e,n,a);o<s;){for(oo(e,o,s),o++,s--;CF(e[o],r)<0;)o+=1;for(;CF(e[s],r)>0;)s-=1}0===CF(e[n],r)?oo(e,n,s):(s+=1,oo(e,s,a)),s<=t&&(n=s+1),t<=s&&(a=s-1)}}function EF(e,t,n,a,r){const o=t[t.length-1],[s,i]=[e.length/o,o],c=xo(n,s*a),l=xo("int32",s*a);for(let d=0;d<s;d++){const t=d*i,n=e.subarray(t,t+i);let o=new Array(n.length);n.forEach(((e,t)=>o[t]={value:e,index:t})),a<o.length&&(TF(o,a),o=o.slice(0,a)),r&&o.sort(CF);const s=d*a,u=c.subarray(s,s+a),h=l.subarray(s,s+a);for(let e=0;e<a;e++)u[e]=o[e].value,h[e]=o[e].index}const u=t.slice();return u[u.length-1]=a,[Nd(u,n,c),Nd(u,"int32",l)]}const RF={kernelName:Hc,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{k:o,sorted:s}=a;iC(r,"topk");const i=n.data.get(r.dataId).values,[c,l]=EF(i,r.shape,r.dtype,o,s);return[n.makeTensorInfo(c.shape,c.dtype,c.values),n.makeTensorInfo(l.shape,l.dtype,l.values)]}};const _F={kernelName:jc,backendName:"cpu",kernelFunc:function(e){const{inputs:t,attrs:n,backend:a}=e,{image:r,transforms:o}=t,{interpolation:s,fillMode:i,fillValue:c,outputShape:l}=n,[u,d,h,p]=r.shape,[f,m]=null!=l?l:[d,h],g=[u,f,m,p],b=Eo(r.shape),y=b[0],x=b[1],v=b[2],w=Eo(g),k=w[0],I=w[1],S=w[2],N=xo(r.dtype,lo(g));N.fill(c);const C=a.data.get(r.dataId).values,T=a.data.get(o.dataId).values;for(let E=0;E<u;++E){const e=1===o.shape[0]?T:T.subarray(8*E,8*E+8);for(let t=0;t<f;++t)for(let n=0;n<m;++n)for(let a=0;a<p;++a){let r;const o=e[6]*n+e[7]*t+1;if(0===o)continue;const l=(e[0]*n+e[1]*t+e[2])/o,u=(e[3]*n+e[4]*t+e[5])/o,p=AF(l,h,i),f=AF(u,d,i);switch(s){case"nearest":r=OF(C,d,h,y,x,v,E,f,p,a,c);break;case"bilinear":r=DF(C,d,h,y,x,v,E,f,p,a,c);break;default:throw new Error("Error in Transform: Expect 'nearest' or "+"'bilinear', but got ".concat(s))}N[E*k+t*I+n*S+a]=r}return a.makeTensorInfo(g,r.dtype,N)}return{dataId:a.write(N,g,r.dtype),shape:r.shape,dtype:r.dtype}}};function AF(e,t,n){switch(n){case"reflect":return function(e,t){let n=e;if(n<0)if(t<=1)n=0;else{const e=2*t;n<e&&(n=e*Math.trunc(-n/e)+n),n=n<-t?n+e:-n-1}else if(n>t-1)if(t<=1)n=0;else{const e=2*t;n-=e*Math.trunc(n/e),n>=t&&(n=e-n-1)}return ao(0,n,t-1)}(e,t);case"wrap":return function(e,t){let n=e;if(n<0)if(t<=1)n=0;else{const e=t-1;n+=t*(Math.trunc(-n/e)+1)}else if(n>t-1)if(t<=1)n=0;else{const e=t-1;n-=t*Math.trunc(n/e)}return ao(0,n,t-1)}(e,t);case"nearest":return function(e,t){return ao(0,e,t-1)}(e,t);default:return function(e,t){return e}(e)}}function FF(e,t,n,a,r,o,s,i,c,l,u){return 0<=i&&i<t&&0<=c&&c<n?e[s*a+i*r+c*o+l]:u}function OF(e,t,n,a,r,o,s,i,c,l,u){return FF(e,t,n,a,r,o,s,Math.round(i),Math.round(c),l,u)}function DF(e,t,n,a,r,o,s,i,c,l,u){const d=Math.floor(i),h=Math.floor(c),p=d+1,f=h+1;return(p-i)*((f-c)*FF(e,t,n,a,r,o,s,d,h,l,u)+(c-h)*FF(e,t,n,a,r,o,s,d,f,l,u))+(i-d)*((f-c)*FF(e,t,n,a,r,o,s,p,h,l,u)+(c-h)*FF(e,t,n,a,r,o,s,p,f,l,u))}function MF(e,t,n,a){const r=bo(t,n)[0],o=[1,n[0],1];for(let f=0;f<r;f++)o[0]*=n[f];o[1]=n[r];for(let f=r+1;f<n.length;f++)o[2]*=n[f];const s=new Map,i=new Int32Array(n[r]),c=new ql(o,a,e),l=[],u=1===o[0]&&1===o[2];for(let f=0;f<n[r];f++){let t;if(u)t=e[f].toString();else{const e=[];for(let t=0;t<o[0];t++)for(let n=0;n<o[2];n++)e.push(c.get(t,f,n));t=e.join(",")}const n=s.get(t);if(null!=n)i[f]=n;else{const e=s.size;s.set(t,e),i[f]=e,l.push(f)}}const d=o.slice();d[1]=s.size;const h=new ql(d,a);l.forEach(((e,t)=>{for(let n=0;n<o[0];n++)for(let a=0;a<o[2];a++)h.set(c.get(n,e,a),n,t,a)}));const p=n.slice();return p[r]=d[1],{outputValues:h.values,outputShape:p,indices:i}}const LF={kernelName:qc,backendName:"cpu",kernelFunc:function(e){const{inputs:t,attrs:n,backend:a}=e,{axis:r}=n,{x:o}=t;iC(o,"unique");const s=a.data.get(o.dataId).values,{outputValues:i,outputShape:c,indices:l}=MF(s,r,o.shape,o.dtype);return[a.makeTensorInfo(c,o.dtype,i),a.makeTensorInfo([l.length],"int32",l)]}};const PF={kernelName:Xc,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{value:r}=t;let{axis:o}=a;o<0&&(o+=r.shape.length);const s=r.shape.length,i=r.shape[o],c=new Array(s-1);let l=0;for(let p=0;p<s;p++)p!==o&&(c[l++]=r.shape[p]);const u=new Array(s).fill(0),d=r.shape.slice();d[o]=1;const h=new Array(i);for(let p=0;p<h.length;p++){u[o]=p;const e=_T({inputs:{x:r},backend:n,attrs:{begin:u,size:d}});h[p]=jC({inputs:{x:e},backend:n,attrs:{shape:c}}),n.disposeIntermediateTensorInfo(e)}return h}};const zF={kernelName:Yc,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r,segmentIds:o}=t,{numSegments:s}=a;iC(r,"unsortedSegmentSum");const i=[],c=[],l=r.shape.length-o.shape.length;let u=o;for(let h=0;h<l;++h){const e=GE({inputs:{input:u},backend:n,attrs:{dim:h+1}});u=e,c.push(e)}for(let h=0;h<s;++h){const e=Rl(h,"int32"),t=n.makeTensorInfo([],"int32",e),a=_E({inputs:{a:t,b:u},backend:n}),o=PC({inputs:{x:a},backend:n,attrs:{dtype:"float32"}}),s=IE({inputs:{a:o,b:r},backend:n}),l=NE({inputs:{x:s},backend:n,attrs:{axis:0,keepDims:!1}});i.push(l),c.push(t),c.push(a),c.push(o),c.push(s),c.push(l)}const d=W_({inputs:i,backend:n,attrs:{axis:0}});return c.forEach((e=>n.disposeIntermediateTensorInfo(e))),d}},BF=[YC,JC,$C,tT,HC,nT,sT,iT,cT,lT,dT,pT,mT,yT,vT,ST,NT,CT,TT,XC,ET,FT,MT,PT,zT,zC,VT,GT,FC,HT,YT,JT,ZT,$T,eE,tE,nE,rE,sE,iE,cE,lE,uE,dE,pE,fE,mE,gE,bE,yE,xE,vE,TE,fC,EE,AE,BE,UE,HE,qE,rR,sR,iR,uR,pR,fR,mR,bR,xR,kR,NR,gC,CR,qT,ER,_R,FR,yC,MR,zR,WR,GR,jR,XR,QR,$R,e_,t_,r_,i_,c_,l_,u_,d_,h_,p_,f_,b_,y_,w_,S_,SE,C_,E_,__,F_,M_,L_,B_,V_,U_,j_,kC,q_,Z_,tA,iA,lA,MC,QE,dA,SC,CC,KC,hA,pA,fA,mA,gA,bA,xA,kA,SA,TA,EA,FA,RC,DA,LA,zA,AT,I_,VA,UA,HA,KA,XA,YA,QA,JA,eF,tF,rF,iF,lF,dF,fF,bF,xF,eR,CE,wF,{kernelName:Uc,backendName:"cpu",kernelFunc:kF},IF,NF,RF,_F,oT,LF,PF,zF,z_];for(const n of BF)ul(n);const WF={},VF={alpha:!1,antialias:!1,premultipliedAlpha:!1,preserveDrawingBuffer:!1,depth:!1,stencil:!1,failIfMajorPerformanceCaveat:!0};function UF(e,t){if(!(e in WF)||null!=t){const n=function(e,t){if(1!==e&&2!==e)throw new Error("Cannot get WebGL rendering context, WebGL is disabled.");const n=null==t?function(e){if(Vo().getBool("IS_SAFARI")||"undefined"===typeof OffscreenCanvas||2!==e){if("undefined"!==typeof document)return document.createElement("canvas");throw new Error("Cannot create a canvas in this context")}return new OffscreenCanvas(300,150)}(e):t;n.addEventListener("webglcontextlost",(t=>{t.preventDefault(),delete WF[e]}),!1),Vo().getBool("SOFTWARE_WEBGL_ENABLED")&&(VF.failIfMajorPerformanceCaveat=!1);if(1===e)return n.getContext("webgl",VF)||n.getContext("experimental-webgl",VF);return n.getContext("webgl2",VF)}(e,t);if(null===n)return console.log("Could not get context for WebGL version",e),null;WF[e]=n}const n=WF[e];return null==n||n.isContextLost()?(delete WF[e],UF(e)):(n.disable(n.DEPTH_TEST),n.disable(n.STENCIL_TEST),n.disable(n.BLEND),n.disable(n.DITHER),n.disable(n.POLYGON_OFFSET_FILL),n.disable(n.SAMPLE_COVERAGE),n.enable(n.SCISSOR_TEST),n.enable(n.CULL_FACE),n.cullFace(n.BACK),WF[e])}var GF,HF,jF;function KF(e,t){return[t,e]}function qF(e){const t=lo(e);return po(Math.ceil(t/4))}function XF(e,t){return[Math.max(1,Math.ceil(t/2)),Math.max(1,Math.ceil(e/2))]}function YF(e,t){const n=e;let a,r,o,s,i,c,l,u,d,h;return 2===Vo().getNumber("WEBGL_VERSION")?(a=n.R32F,r=n.R16F,o=n.RGBA16F,s=n.RGBA32F,i=n.RED,l=4,u=1,d=n.HALF_FLOAT,h=n.FLOAT,c=n.RGBA8):(a=e.RGBA,r=e.RGBA,o=e.RGBA,s=n.RGBA,i=e.RGBA,l=4,u=4,d=null!=t?t.HALF_FLOAT_OES:null,h=e.FLOAT,c=e.RGBA),{internalFormatFloat:a,internalFormatHalfFloat:r,internalFormatPackedHalfFloat:o,internalFormatPackedFloat:s,textureFormatFloat:i,downloadTextureFormat:c,downloadUnpackNumChannels:l,defaultNumChannels:u,textureTypeHalfFloat:d,textureTypeFloat:h}}function QF(e,t){const n=t();return Vo().getBool("DEBUG")&&function(e){const t=e.getError();if(t!==e.NO_ERROR)throw new Error("WebGL Error: "+function(e,t){switch(t){case e.NO_ERROR:return"NO_ERROR";case e.INVALID_ENUM:return"INVALID_ENUM";case e.INVALID_VALUE:return"INVALID_VALUE";case e.INVALID_OPERATION:return"INVALID_OPERATION";case e.INVALID_FRAMEBUFFER_OPERATION:return"INVALID_FRAMEBUFFER_OPERATION";case e.OUT_OF_MEMORY:return"OUT_OF_MEMORY";case e.CONTEXT_LOST_WEBGL:return"CONTEXT_LOST_WEBGL";default:return"Unknown error code ".concat(t)}}(e,t))}(e),n}!function(e){e[e.DENSE=0]="DENSE",e[e.SHARED_BATCH=1]="SHARED_BATCH"}(GF||(GF={})),function(e){e[e.RENDER=0]="RENDER",e[e.UPLOAD=1]="UPLOAD",e[e.PIXELS=2]="PIXELS",e[e.DOWNLOAD=3]="DOWNLOAD"}(HF||(HF={})),function(e){e[e.UNPACKED_FLOAT16=0]="UNPACKED_FLOAT16",e[e.UNPACKED_FLOAT32=1]="UNPACKED_FLOAT32",e[e.PACKED_4X1_UNSIGNED_BYTE=2]="PACKED_4X1_UNSIGNED_BYTE",e[e.PACKED_2X2_FLOAT32=3]="PACKED_2X2_FLOAT32",e[e.PACKED_2X2_FLOAT16=4]="PACKED_2X2_FLOAT16"}(jF||(jF={}));function JF(e){return!!(Vo().getBool("WEBGL_RENDER_FLOAT32_ENABLED")||0===e||5.96e-8<Math.abs(e)&&Math.abs(e)<65504)}function ZF(e,t){return iO(e,(()=>e.getExtension(t)),'Extension "'+t+'" not supported on this browser.')}const $F=/ERROR: [0-9]+:([0-9]+):/g;function eO(e,t){const n=$F.exec(t);if(null==n)return console.log("Couldn't parse line number in error: ".concat(t)),void console.log(e);const a=+n[1],r=e.split("\n"),o=r.length.toString().length+2,s=r.map(((e,t)=>fo((t+1).toString(),o)+e));let i=0;for(let d=0;d<s.length;d++)i=Math.max(s[d].length,i);const c=s.slice(0,a-1),l=s.slice(a-1,a),u=s.slice(a);console.log(c.join("\n")),console.log(t.split("\n")[0]),console.log("%c ".concat(fo(l[0],i)),"border:1px solid red; background-color:#e3d2d2; color:#a61717"),console.log(u.join("\n"))}function tO(e,t){if(QF(e,(()=>e.validateProgram(t))),!1===e.getProgramParameter(t,e.VALIDATE_STATUS))throw console.log(e.getProgramInfoLog(t)),new Error("Shader program validation failed.")}function nO(e,t,n,a,r,o,s){const i=e.getAttribLocation(t,n);return-1!==i&&(QF(e,(()=>e.bindBuffer(e.ARRAY_BUFFER,a))),QF(e,(()=>e.vertexAttribPointer(i,r,e.FLOAT,!1,o,s))),QF(e,(()=>e.enableVertexAttribArray(i))),!0)}function aO(e,t,n,a){QF(e,(()=>function(e,t,n){cO(e,n),QF(e,(()=>e.activeTexture(e.TEXTURE0+n))),QF(e,(()=>e.bindTexture(e.TEXTURE_2D,t)))}(e,t,a))),QF(e,(()=>e.uniform1i(n,a)))}function rO(e,t,n){QF(e,(()=>e.bindFramebuffer(e.FRAMEBUFFER,n))),QF(e,(()=>e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,t,0)))}function oO(e,t){QF(e,(()=>e.bindFramebuffer(e.FRAMEBUFFER,t))),QF(e,(()=>e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,null,0)))}function sO(e){const t=e.checkFramebufferStatus(e.FRAMEBUFFER);if(t!==e.FRAMEBUFFER_COMPLETE)throw new Error("Error binding framebuffer: "+function(e,t){switch(t){case e.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_ATTACHMENT";case e.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT";case e.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:return"FRAMEBUFFER_INCOMPLETE_DIMENSIONS";case e.FRAMEBUFFER_UNSUPPORTED:return"FRAMEBUFFER_UNSUPPORTED";default:return"unknown error ".concat(t)}}(e,t))}function iO(e,t,n){const a=QF(e,(()=>t()));if(null==a)throw new Error(n);return a}function cO(e,t){const n=e.MAX_COMBINED_TEXTURE_IMAGE_UNITS-1,a=t+e.TEXTURE0;if(a<e.TEXTURE0||a>n){const e="[gl.TEXTURE0, gl.TEXTURE".concat(n,"]");throw new Error("textureUnit must be in ".concat(e,"."))}}function lO(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:2;return lo(e.slice(0,e.length-t))}function uO(e){if(0===e.length)throw Error("Cannot get rows and columns of an empty shape array.");return[e.length>1?e[e.length-2]:1,e[e.length-1]]}function dO(e){let t=[1,1,1];return 0===e.length||1===e.length&&1===e[0]||(t=[lO(e),...uO(e)]),t}function hO(e){return e%2===0}function pO(e,t){if(uo(e=e.slice(-2),t=t.slice(-2)))return!0;if(!e.length||!t.length)return!0;if(0===e[0]||0===e[1]||0===t[0]||0===t[1])return!0;if(e.length!==t.length){const n=e[e.length-1],a=t[t.length-1];if(n===a)return!0;if(hO(n)&&hO(a)&&(1===e[0]||1===t[0]))return!0}return e[1]===t[1]&&hO(e[0])&&hO(t[0])}let fO,mO;function gO(e,t){return null!=e.getExtension(t)}function bO(e){try{if(null!=UF(e))return!0}catch(D){return console.log("Error when getting WebGL context: ",D),!1}return!1}function yO(e){if(0===e)return!1;const t=UF(e);if(1!==e){if(gO(t,"EXT_color_buffer_float"))return xO(t);const e="EXT_color_buffer_half_float";if(gO(t,e)){const n=t.getExtension(e);return function(e,t){const n=YF(e,t),a=e.createTexture();e.bindTexture(e.TEXTURE_2D,a);const r=1,o=1;e.texImage2D(e.TEXTURE_2D,0,n.internalFormatHalfFloat,r,o,0,n.textureFormatFloat,n.textureTypeHalfFloat,null);const s=e.createFramebuffer();e.bindFramebuffer(e.FRAMEBUFFER,s),e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,a,0);const i=e.checkFramebufferStatus(e.FRAMEBUFFER)===e.FRAMEBUFFER_COMPLETE;return e.bindTexture(e.TEXTURE_2D,null),e.bindFramebuffer(e.FRAMEBUFFER,null),e.deleteTexture(a),e.deleteFramebuffer(s),i}(t,n)}return!1}if(!gO(t,"OES_texture_float"))return!1;if(!gO(t,"WEBGL_color_buffer_float"))return!1;return xO(t)}function xO(e){const t=YF(e),n=e.createTexture();e.bindTexture(e.TEXTURE_2D,n);e.texImage2D(e.TEXTURE_2D,0,t.internalFormatFloat,1,1,0,t.textureFormatFloat,t.textureTypeFloat,null);const a=e.createFramebuffer();e.bindFramebuffer(e.FRAMEBUFFER,a),e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,n,0);const r=e.checkFramebufferStatus(e.FRAMEBUFFER)===e.FRAMEBUFFER_COMPLETE;return e.bindTexture(e.TEXTURE_2D,null),e.bindFramebuffer(e.FRAMEBUFFER,null),e.deleteTexture(n),e.deleteFramebuffer(a),r}function vO(e,t){Array.isArray(e)||(e=[e]),e.forEach((e=>{null!=e&&so("complex64"!==e.dtype,(()=>"".concat(t," does not support complex64 tensors ")+"in the WebGL backend."))}))}const wO=Vo();function kO(){let e,t,n,a,r,o,s,i,c,l;return 2===Vo().getNumber("WEBGL_VERSION")?(e="#version 300 es",t="in",n="out",a="in",r="texture",o="outputColor",s="out vec4 outputColor;",i=Vo().getBool("WEBGL2_ISNAN_CUSTOM")?"\n      bool isnan_custom(float val) {\n        uint floatToUint = floatBitsToUint(val);\n        return (floatToUint & 0x7fffffffu) > 0x7f800000u;\n      }\n\n      bvec4 isnan_custom(vec4 val) {\n        return bvec4(isnan_custom(val.x),\n          isnan_custom(val.y), isnan_custom(val.z), isnan_custom(val.w));\n      }\n\n      #define isnan(value) isnan_custom(value)\n    ":"",c="",l="\n      #define round(value) newRound(value)\n      int newRound(float value) {\n        return int(floor(value + 0.5));\n      }\n\n      ivec4 newRound(vec4 value) {\n        return ivec4(floor(value + vec4(0.5)));\n      }\n    "):(e="",t="attribute",n="varying",a="varying",r="texture2D",o="gl_FragColor",s="",i="\n      #define isnan(value) isnan_custom(value)\n      bool isnan_custom(float val) {\n        return (val > 0. || val < 1. || val == 0.) ? false : true;\n      }\n      bvec4 isnan_custom(vec4 val) {\n        return bvec4(isnan(val.x), isnan(val.y), isnan(val.z), isnan(val.w));\n      }\n    ",c="\n      uniform float INFINITY;\n\n      bool isinf(float val) {\n        return abs(val) == INFINITY;\n      }\n      bvec4 isinf(vec4 val) {\n        return equal(abs(val), vec4(INFINITY));\n      }\n    ",l="\n      int round(float value) {\n        return int(floor(value + 0.5));\n      }\n\n      ivec4 round(vec4 value) {\n        return ivec4(floor(value + vec4(0.5)));\n      }\n    "),{version:e,attribute:t,varyingVs:n,varyingFs:a,texture2D:r,output:o,defineOutput:s,defineSpecialNaN:i,defineSpecialInf:c,defineRound:l}}function IO(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"index";const a=Eo(t);return a.map(((t,r)=>{const o="int ".concat(e[r]," = ").concat(n," / ").concat(t),s=r===a.length-1?"int ".concat(e[r+1]," = ").concat(n," - ").concat(e[r]," * ").concat(t):"index -= ".concat(e[r]," * ").concat(t);return"".concat(o,"; ").concat(s,";")})).join("")}function SO(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"index";const a=Eo(t);return a.map(((t,r)=>{const o="int ".concat(e[r]," = ").concat(n," / outShapeStrides[").concat(r,"]"),s=r===a.length-1?"int ".concat(e[r+1]," = ").concat(n," - ").concat(e[r]," * outShapeStrides[").concat(r,"]"):"index -= ".concat(e[r]," * outShapeStrides[").concat(r,"]");return"".concat(o,"; ").concat(s,";")})).join("")}function NO(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"index";const a=e.map(((e,t)=>t)),r=function(e,t){const n=e.length,a=e.map((e=>"".concat(t,"[").concat(e,"]"))),r=new Array(n-1);r[n-2]=a[n-1];for(let o=n-3;o>=0;--o)r[o]="(".concat(r[o+1]," * ").concat(a[o+1],")");return r}(a,t);return r.map(((t,a)=>{const o="int ".concat(e[a]," = ").concat(n," / ").concat(r[a]),s=a===r.length-1?"int ".concat(e[a+1]," = ").concat(n," - ").concat(e[a]," * ").concat(r[a]):"index -= ".concat(e[a]," * ").concat(r[a]);return"".concat(o,"; ").concat(s,";")})).join("")}function CO(e){const t=Eo(e).map((e=>e.toString()));return"\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * ".concat(t[0]," + coords.y * ").concat(t[1]," + coords.z;\n  }\n")}wO.registerFlag("HAS_WEBGL",(()=>wO.getNumber("WEBGL_VERSION")>0)),wO.registerFlag("WEBGL_VERSION",(()=>bO(2)?2:bO(1)?1:0)),wO.registerFlag("WEBGL_CHECK_NUMERICAL_PROBLEMS",(()=>!1)),wO.registerFlag("WEBGL_BUFFER_SUPPORTED",(()=>2===wO.get("WEBGL_VERSION"))),wO.registerFlag("WEBGL_CPU_FORWARD",(()=>!0)),wO.registerFlag("WEBGL_FORCE_F16_TEXTURES",(()=>!1)),wO.registerFlag("WEBGL_PACK",(()=>wO.getBool("HAS_WEBGL"))),wO.registerFlag("WEBGL_PACK_NORMALIZATION",(()=>wO.getBool("WEBGL_PACK"))),wO.registerFlag("WEBGL_PACK_CLIP",(()=>wO.getBool("WEBGL_PACK"))),wO.registerFlag("WEBGL_PACK_DEPTHWISECONV",(()=>wO.getBool("WEBGL_PACK"))),wO.registerFlag("WEBGL_PACK_BINARY_OPERATIONS",(()=>wO.getBool("WEBGL_PACK"))),wO.registerFlag("WEBGL_PACK_UNARY_OPERATIONS",(()=>wO.getBool("WEBGL_PACK"))),wO.registerFlag("WEBGL_PACK_ARRAY_OPERATIONS",(()=>wO.getBool("WEBGL_PACK"))),wO.registerFlag("WEBGL_PACK_IMAGE_OPERATIONS",(()=>wO.getBool("WEBGL_PACK"))),wO.registerFlag("WEBGL_PACK_REDUCE",(()=>wO.getBool("WEBGL_PACK"))),wO.registerFlag("WEBGL_LAZILY_UNPACK",(()=>wO.getBool("WEBGL_PACK"))),wO.registerFlag("WEBGL_CONV_IM2COL",(()=>wO.getBool("WEBGL_PACK"))),wO.registerFlag("WEBGL_PACK_CONV2DTRANSPOSE",(()=>wO.getBool("WEBGL_PACK"))),wO.registerFlag("WEBGL_MAX_TEXTURE_SIZE",(()=>function(e){if(null==fO){const t=UF(e);fO=t.getParameter(t.MAX_TEXTURE_SIZE)}return fO}(wO.getNumber("WEBGL_VERSION")))),wO.registerFlag("WEBGL_MAX_TEXTURES_IN_SHADER",(()=>function(e){if(null==mO){const t=UF(e);mO=t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS)}return Math.min(16,mO)}(wO.getNumber("WEBGL_VERSION")))),wO.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION",(()=>{const e=wO.getNumber("WEBGL_VERSION");return 0===e?0:function(e){if(0===e)return 0;let t;const n=UF(e);return t=gO(n,"EXT_disjoint_timer_query_webgl2")&&2===e?2:gO(n,"EXT_disjoint_timer_query")?1:0,t}(e)})),wO.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE",(()=>wO.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0&&!wu())),wO.registerFlag("WEBGL_RENDER_FLOAT32_CAPABLE",(()=>function(e){if(0===e)return!1;const t=UF(e);if(1===e){if(!gO(t,"OES_texture_float"))return!1}else if(!gO(t,"EXT_color_buffer_float"))return!1;return xO(t)}(wO.getNumber("WEBGL_VERSION")))),wO.registerFlag("WEBGL_RENDER_FLOAT32_ENABLED",(()=>!wO.getBool("WEBGL_FORCE_F16_TEXTURES")&&wO.getBool("WEBGL_RENDER_FLOAT32_CAPABLE"))),wO.registerFlag("WEBGL_DOWNLOAD_FLOAT_ENABLED",(()=>yO(wO.getNumber("WEBGL_VERSION")))),wO.registerFlag("WEBGL_FENCE_API_ENABLED",(()=>{return 2===(e=wO.getNumber("WEBGL_VERSION"))&&null!=UF(e).fenceSync;var e})),wO.registerFlag("WEBGL_SIZE_UPLOAD_UNIFORM",(()=>wO.getBool("WEBGL_RENDER_FLOAT32_ENABLED")?4:0)),wO.registerFlag("WEBGL_DELETE_TEXTURE_THRESHOLD",(()=>-1),(e=>{if("number"!==typeof e)throw new Error("WEBGL_DELETE_TEXTURE_THRESHOLD must be a number but "+"got ".concat(e,"."));if(e<0&&-1!==e)throw new Error("WEBGL_DELETE_TEXTURE_THRESHOLD must be -1 (indicating never "+"delete) or at least 0, but got ".concat(e,"."))})),wO.registerFlag("WEBGL_FLUSH_THRESHOLD",(()=>wu()?1:-1),(e=>{if("number"!==typeof e)throw new Error("WEBGL_FLUSH_THRESHOLD must be a number but got "+"".concat(e,"."));if(e<0&&-1!==e)throw new Error("WEBGL_FLUSH_THRESHOLD must be -1 (indicating never "+"manual flush) or at least 0, but got ".concat(e,"."))})),wO.registerFlag("CPU_HANDOFF_SIZE_THRESHOLD",(()=>128)),wO.registerFlag("WEBGL_USE_SHAPES_UNIFORMS",(()=>!1)),wO.registerFlag("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD",(()=>1e5)),wO.registerFlag("TOPK_K_CPU_HANDOFF_THRESHOLD",(()=>128)),wO.registerFlag("WEBGL_EXP_CONV",(()=>!1)),wO.registerFlag("SOFTWARE_WEBGL_ENABLED",(()=>wO.getBool("IS_TEST"))),wO.registerFlag("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE",(()=>1/0)),wO.registerFlag("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE",(()=>!1)),wO.registerFlag("WEBGL2_ISNAN_CUSTOM",(()=>!1)),wO.registerFlag("ENGINE_COMPILE_ONLY",(()=>!1));const TO="\n  const float FLOAT_MAX = 1.70141184e38;\n  const float FLOAT_MIN = 1.17549435e-38;\n\n  lowp vec4 encode_float(highp float v) {\n    if (isnan(v)) {\n      return vec4(255, 255, 255, 255);\n    }\n\n    highp float av = abs(v);\n\n    if(av < FLOAT_MIN) {\n      return vec4(0.0, 0.0, 0.0, 0.0);\n    } else if(v > FLOAT_MAX) {\n      return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;\n    } else if(v < -FLOAT_MAX) {\n      return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;\n    }\n\n    highp vec4 c = vec4(0,0,0,0);\n\n    highp float e = floor(log2(av));\n    highp float m = exp2(fract(log2(av))) - 1.0;\n\n    c[2] = floor(128.0 * m);\n    m -= c[2] / 128.0;\n    c[1] = floor(32768.0 * m);\n    m -= c[1] / 32768.0;\n    c[0] = floor(8388608.0 * m);\n\n    highp float ebias = e + 127.0;\n    c[3] = floor(ebias / 2.0);\n    ebias -= c[3] * 2.0;\n    c[2] += floor(ebias) * 128.0;\n\n    c[3] += 128.0 * step(0.0, -v);\n\n    return c / 255.0;\n  }\n",{getBroadcastDims:EO}=a;function RO(e,t,n){const a=[];if(e.forEach((e=>{const t=lo(e.shapeInfo.logicalShape);if(e.shapeInfo.isUniform?a.push("uniform float ".concat(e.name).concat(t>1?"[".concat(t,"]"):"",";")):(a.push("uniform sampler2D ".concat(e.name,";")),a.push("uniform int offset".concat(e.name,";"))),n.enableShapeUniforms){const{uniformShape:t}=BO(n.packedInputs,e.shapeInfo.logicalShape,e.shapeInfo.texShape);switch(t.length){case 1:a.push("uniform int ".concat(e.name,"Shape;"));break;case 2:a.push("uniform ivec2 ".concat(e.name,"Shape;"));break;case 3:a.push("uniform ivec3 ".concat(e.name,"Shape;"));break;case 4:a.push("uniform ivec4 ".concat(e.name,"Shape;"))}a.push("uniform ivec2 ".concat(e.name,"TexShape;"))}})),n.enableShapeUniforms){switch(t.logicalShape.length){case 1:a.push("uniform int outShape;");break;case 2:a.push("uniform ivec2 outShape;"),a.push("uniform int outShapeStrides;");break;case 3:a.push("uniform ivec3 outShape;"),a.push("uniform ivec2 outShapeStrides;");break;case 4:a.push("uniform ivec4 outShape;"),a.push("uniform ivec3 outShapeStrides;")}a.push("uniform ivec2 outTexShape;")}n.customUniforms&&n.customUniforms.forEach((e=>{a.push("uniform ".concat(e.type," ").concat(e.name).concat(e.arrayIndex?"[".concat(e.arrayIndex,"]"):"",";"))}));const r=a.join("\n"),o=e.map((e=>function(e,t){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],a=arguments.length>3?arguments[3]:void 0,r="";r+=n?AO(e,a):_O(e,a);const o=e.shapeInfo.logicalShape,s=t.logicalShape;o.length<=s.length&&(r+=n?function(e,t){const n=e.name,a=n.charAt(0).toUpperCase()+n.slice(1),r="get"+a+"AtOutCoords",o=e.shapeInfo.logicalShape.length,s=t.logicalShape.length,i=EO(e.shapeInfo.logicalShape,t.logicalShape),c=zO(s),l=s-o;let u;const d=["x","y","z","w","u","v"];u=0===o?"":s<2&&i.length>=1?"coords = 0;":i.map((e=>"coords.".concat(d[e+l]," = 0;"))).join("\n");let h="";h=s<2&&o>0?"coords":e.shapeInfo.logicalShape.map(((e,t)=>"coords.".concat(d[t+l]))).join(", ");let p="return outputValue;";const f=1===lo(e.shapeInfo.logicalShape),m=lo(t.logicalShape),g=1===m;if(1!==o||f||g){if(f&&!g)p=1===s?"\n        return vec4(outputValue.x, outputValue.x, 0., 0.);\n      ":"\n        return vec4(outputValue.x);\n      ";else if(i.length){const e=o-2,t=o-1;i.indexOf(e)>-1&&i.indexOf(t)>-1?p="return vec4(outputValue.x);":i.indexOf(e)>-1?p="return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);":i.indexOf(t)>-1&&(p="return vec4(outputValue.xx, outputValue.zz);")}}else p="\n      return vec4(outputValue.xy, outputValue.xy);\n    ";return"\n    vec4 ".concat(r,"() {\n      ").concat(c," coords = getOutputCoords();\n      ").concat(u,"\n      vec4 outputValue = get").concat(a,"(").concat(h,");\n      ").concat(p,"\n    }\n  ")}(e,t):function(e,t){const n=e.name,a=n.charAt(0).toUpperCase()+n.slice(1),r="get"+a+"AtOutCoords",o=t.texShape,s=e.shapeInfo.texShape,i=e.shapeInfo.logicalShape.length,c=t.logicalShape.length;if(!e.shapeInfo.isUniform&&i===c&&null==e.shapeInfo.flatOffset&&uo(s,o))return"\n      float ".concat(r,"() {\n        return sampleTexture(").concat(n,", resultUV);\n      }\n    ");const l=zO(c),u=EO(e.shapeInfo.logicalShape,t.logicalShape),d=c-i;let h;const p=["x","y","z","w","u","v"];h=0===i?"":c<2&&u.length>=1?"coords = 0;":u.map((e=>"coords.".concat(p[e+d]," = 0;"))).join("\n");let f="";f=c<2&&i>0?"coords":e.shapeInfo.logicalShape.map(((e,t)=>"coords.".concat(p[t+d]))).join(", ");return"\n    float ".concat(r,"() {\n      ").concat(l," coords = getOutputCoords();\n      ").concat(h,"\n      return get").concat(a,"(").concat(f,");\n    }\n  ")}(e,t));return r}(e,t,n.packedInputs,n.enableShapeUniforms))).join("\n"),s=t.texShape,i=kO(),c=function(e){return"\n    float sampleTexture(sampler2D textureSampler, vec2 uv) {\n      return ".concat(e.texture2D,"(textureSampler, uv).r;\n    }\n  ")}(i);let l,u,d=function(e){const t="".concat(e.version,"\n    precision highp float;\n    precision highp int;\n    precision highp sampler2D;\n    ").concat(e.varyingFs," vec2 resultUV;\n    ").concat(e.defineOutput,"\n    const vec2 halfCR = vec2(0.5, 0.5);\n\n    struct ivec5\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n    };\n\n    struct ivec6\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n      int v;\n    };\n\n    uniform float NAN;\n    ").concat(e.defineSpecialNaN,"\n    ").concat(e.defineSpecialInf,"\n    ").concat(e.defineRound,"\n\n    int imod(int x, int y) {\n      return x - y * (x / y);\n    }\n\n    int idiv(int a, int b, float sign) {\n      int res = a / b;\n      int mod = imod(a, b);\n      if (sign < 0. && mod != 0) {\n        res -= 1;\n      }\n      return res;\n    }\n\n    //Based on the work of Dave Hoskins\n    //https://www.shadertoy.com/view/4djSRW\n    #define HASHSCALE1 443.8975\n    float random(float seed){\n      vec2 p = resultUV * seed;\n      vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);\n      p3 += dot(p3, p3.yzx + 19.19);\n      return fract((p3.x + p3.y) * p3.z);\n    }\n\n    ").concat(FO,"\n    ").concat(OO,"\n    ").concat(DO,"\n  ");return t}(i);t.isPacked?(l=function(e,t,n){switch(e.length){case 0:return"\n    int getOutputCoords() {\n      return 0;\n    }\n  ";case 1:return function(e,t,n){const a=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)];if(1===a[0])return n?"\n      int getOutputCoords() {\n        return 2 * int(resultUV.x * ceil(float(outTexShape[1]) / 2.0));\n      }\n    ":"\n      int getOutputCoords() {\n        return 2 * int(resultUV.x * ".concat(a[1],".0);\n      }\n    ");if(1===a[1])return n?"\n      int getOutputCoords() {\n        return 2 * int(resultUV.y * ceil(float(outTexShape[0]) / 2.0));\n      }\n    ":"\n      int getOutputCoords() {\n        return 2 * int(resultUV.y * ".concat(a[0],".0);\n      }\n    ");if(n)return"\n    int getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n      return 2 * (resTexRC.x * packedTexShape[1] + resTexRC.y);\n    }\n  ";return"\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(".concat(a[0],", ").concat(a[1],"));\n      return 2 * (resTexRC.x * ").concat(a[1]," + resTexRC.y);\n    }\n  ")}(0,t,n);case 2:return function(e,t,n){const a=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)];if(uo(e,t))return n?"\n      ivec2 getOutputCoords() {\n        ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n        return 2 * ivec2(resultUV.yx * vec2(packedTexShape[0], packedTexShape[1]));\n      }\n    ":"\n      ivec2 getOutputCoords() {\n        return 2 * ivec2(resultUV.yx * vec2(".concat(a[0],", ").concat(a[1],"));\n      }\n    ");const r=Math.ceil(e[1]/2);if(n)return"\n    ivec2 getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      int texelsInLogicalRow = int(ceil(float(outShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n\n      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;\n      int r = 2 * (index / texelsInLogicalRow);\n      int c = imod(index, texelsInLogicalRow) * 2;\n\n      return ivec2(r, c);\n    }\n  ";return"\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(".concat(a[0],", ").concat(a[1],"));\n\n      int index = resTexRC.x * ").concat(a[1]," + resTexRC.y;\n      int r = 2 * (index / ").concat(r,");\n      int c = imod(index, ").concat(r,") * 2;\n\n      return ivec2(r, c);\n    }\n  ")}(e,t,n);case 3:return function(e,t,n){if(n)return"\n    ivec3 getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      int texelsInLogicalRow = int(ceil(float(outShape[2]) / 2.0));\n      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;\n\n      int b = index / texelsInBatch;\n      index -= b * texelsInBatch;\n\n      int r = 2 * (index / texelsInLogicalRow);\n      int c = imod(index, texelsInLogicalRow) * 2;\n\n      return ivec3(b, r, c);\n    }\n  ";const a=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)],r=Math.ceil(e[2]/2),o=r*Math.ceil(e[1]/2);return"\n    ivec3 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(".concat(a[0],", ").concat(a[1],"));\n      int index = resTexRC.x * ").concat(a[1]," + resTexRC.y;\n\n      int b = index / ").concat(o,";\n      index -= b * ").concat(o,";\n\n      int r = 2 * (index / ").concat(r,");\n      int c = imod(index, ").concat(r,") * 2;\n\n      return ivec3(b, r, c);\n    }\n  ")}(e,t,n);default:return function(e,t,n){if(n)return"\n    ivec4 getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;\n\n      int texelsInLogicalRow = int(ceil(float(outShape[3]) / 2.0));\n      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[2]) / 2.0));\n      int texelsInBatchN = texelsInBatch * outShape[1];\n\n      int b2 = index / texelsInBatchN;\n      index -= b2 * texelsInBatchN;\n\n      int b = index / texelsInBatch;\n      index -= b * texelsInBatch;\n\n      int r = 2 * (index / texelsInLogicalRow);\n      int c = imod(index, texelsInLogicalRow) * 2;\n\n      return ivec4(b2, b, r, c);\n    }\n  ";const a=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)],r=Math.ceil(e[e.length-1]/2),o=r*Math.ceil(e[e.length-2]/2);let s=o,i="",c="b, r, c";for(let l=2;l<e.length-1;l++)s*=e[e.length-l-1],i="\n      int b".concat(l," = index / ").concat(s,";\n      index -= b").concat(l," * ").concat(s,";\n    ")+i,c="b".concat(l,", ")+c;return"\n    ivec".concat(e.length," getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(").concat(a[0],", ").concat(a[1],"));\n      int index = resTexRC.x * ").concat(a[1]," + resTexRC.y;\n\n      ").concat(i,"\n\n      int b = index / ").concat(o,";\n      index -= b * ").concat(o,";\n\n      int r = 2 * (index / ").concat(r,");\n      int c = imod(index, ").concat(r,") * 2;\n\n      return ivec").concat(e.length,"(").concat(c,");\n    }\n  ")}(e,t,n)}}(t.logicalShape,s,n.enableShapeUniforms),u=function(e){return"\n    void setOutput(vec4 val) {\n      ".concat(e.output," = val;\n    }\n  ")}(i)):(l=function(e,t,n){switch(e.length){case 0:return"\n    int getOutputCoords() {\n      return 0;\n    }\n  ";case 1:return function(e,t,n){if(1===t[0])return n?"\n      int getOutputCoords() {\n        return int(resultUV.x * float(outTexShape[1]));\n      }\n    ":"\n      int getOutputCoords() {\n        return int(resultUV.x * ".concat(t[1],".0);\n      }\n    ");if(1===t[1])return n?"\n      int getOutputCoords() {\n        return int(resultUV.y * float(outTexShape[0]));\n      }\n    ":"\n      int getOutputCoords() {\n        return int(resultUV.y * ".concat(t[0],".0);\n      }\n    ");if(n)return"\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(outTexShape[0], outTexShape[1]));\n      return resTexRC.x * outTexShape[1] + resTexRC.y;\n    }\n  ";return"\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(".concat(t[0],", ").concat(t[1],"));\n      return resTexRC.x * ").concat(t[1]," + resTexRC.y;\n    }\n  ")}(0,t,n);case 2:return function(e,t,n){if(uo(e,t))return n?"\n      ivec2 getOutputCoords() {\n        return ivec2(resultUV.yx * vec2(outTexShape[0], outTexShape[1]));\n      }\n    ":"\n      ivec2 getOutputCoords() {\n        return ivec2(resultUV.yx * vec2(".concat(t[0],", ").concat(t[1],"));\n      }\n    ");if(1===e[1])return n?"\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(outTexShape[0], outTexShape[1]));\n        int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n        return ivec2(index, 0);\n      }\n    ":"\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(".concat(t[0],", ").concat(t[1],"));\n        int index = resTexRC.x * ").concat(t[1]," + resTexRC.y;\n        return ivec2(index, 0);\n      }\n    ");if(1===e[0])return n?"\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(outTexShape[0], outTexShape[1]));\n        int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n        return ivec2(0, index);\n      }\n    ":"\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(".concat(t[0],", ").concat(t[1],"));\n        int index = resTexRC.x * ").concat(t[1]," + resTexRC.y;\n        return ivec2(0, index);\n      }\n    ");if(n)return"\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(outTexShape[0], outTexShape[1]));\n      int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n      int r = index / outShape[1];\n      int c = index - r * outShape[1];\n      return ivec2(r, c);\n    }\n  ";return"\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(".concat(t[0],", ").concat(t[1],"));\n      int index = resTexRC.x * ").concat(t[1]," + resTexRC.y;\n      int r = index / ").concat(e[1],";\n      int c = index - r * ").concat(e[1],";\n      return ivec2(r, c);\n    }\n  ")}(e,t,n);case 3:return function(e,t,n){if(n){const t=SO(["r","c","d"],e);return"\n  ivec3 getOutputCoords() {\n    ivec2 resTexRC = ivec2(resultUV.yx *\n                           vec2(outTexShape[0], outTexShape[1]));\n    int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n    ".concat(t,"\n    return ivec3(r, c, d);\n  }\n")}const a=IO(["r","c","d"],e);return"\n    ivec3 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(".concat(t[0],", ").concat(t[1],"));\n      int index = resTexRC.x * ").concat(t[1]," + resTexRC.y;\n      ").concat(a,"\n      return ivec3(r, c, d);\n    }\n  ")}(e,t,n);case 4:return function(e,t,n){if(n){const t=SO(["r","c","d","d2"],e);return"\n    ivec4 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(outTexShape[0], outTexShape[1]));\n      int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n      ".concat(t,"\n      return ivec4(r, c, d, d2);\n    }\n  ")}const a=IO(["r","c","d","d2"],e);return"\n    ivec4 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(".concat(t[0],", ").concat(t[1],"));\n      int index = resTexRC.x * ").concat(t[1]," + resTexRC.y;\n      ").concat(a,"\n      return ivec4(r, c, d, d2);\n    }\n  ")}(e,t,n);case 5:return function(e,t){const n=IO(["r","c","d","d2","d3"],e);return"\n    ivec5 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx * vec2(".concat(t[0],",\n                             ").concat(t[1],"));\n\n      int index = resTexRC.x * ").concat(t[1]," + resTexRC.y;\n\n      ").concat(n,"\n\n      ivec5 outShape = ivec5(r, c, d, d2, d3);\n      return outShape;\n    }\n  ")}(e,t);case 6:return function(e,t){const n=IO(["r","c","d","d2","d3","d4"],e);return"\n    ivec6 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(".concat(t[0],", ").concat(t[1],"));\n      int index = resTexRC.x * ").concat(t[1]," + resTexRC.y;\n\n      ").concat(n,"\n\n      ivec6 result = ivec6(r, c, d, d2, d3, d4);\n      return result;\n    }\n  ")}(e,t);default:throw new Error("".concat(e.length,"-D output sampling is not yet supported"))}}(t.logicalShape,s,n.enableShapeUniforms),u=function(e){return"\n    void setOutput(float val) {\n      ".concat(e.output," = vec4(val, 0, 0, 0);\n    }\n  ")}(i)),n.packedInputs&&(d+=MO);return[d,c,u,r,l,o,n.userCode].join("\n")}function _O(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];const n=e.shapeInfo.logicalShape;switch(n.length){case 0:return function(e,t){const n=e.name,a="get"+n.charAt(0).toUpperCase()+n.slice(1);if(e.shapeInfo.isUniform)return"float ".concat(a,"() {return ").concat(n,";}");const[r,o]=e.shapeInfo.texShape;if(1===r&&1===o)return"\n      float ".concat(a,"() {\n        return sampleTexture(").concat(n,", halfCR);\n      }\n    ");const s=LO(n);if(t)return"\n    float ".concat(a,"() {\n      vec2 uv = uvFromFlat(").concat(n,"TexShape[0], ").concat(n,"TexShape[1], ").concat(s,");\n      return sampleTexture(").concat(n,", uv);\n    }\n  ");const[i,c]=e.shapeInfo.texShape;return"\n    float ".concat(a,"() {\n      vec2 uv = uvFromFlat(").concat(i,", ").concat(c,", ").concat(s,");\n      return sampleTexture(").concat(n,", uv);\n    }\n  ")}(e,t);case 1:return function(e,t){const n=e.name,a="get"+n.charAt(0).toUpperCase()+n.slice(1);if(e.shapeInfo.isUniform)return"\n      float ".concat(a,"(int index) {\n        ").concat(PO(e),"\n      }\n    ");const r=e.shapeInfo.texShape,o=r[0],s=r[1];if(1===s&&1===o)return"\n      float ".concat(a,"(int index) {\n        return sampleTexture(").concat(n,", halfCR);\n      }\n    ");const i=LO(n);if(1===s)return t?"\n      float ".concat(a,"(int index) {\n        vec2 uv = vec2(0.5, (float(index + ").concat(i,") + 0.5) / float(").concat(n,"TexShape[0]));\n        return sampleTexture(").concat(n,", uv);\n      }\n    "):"\n      float ".concat(a,"(int index) {\n        vec2 uv = vec2(0.5, (float(index + ").concat(i,") + 0.5) / ").concat(o,".0);\n        return sampleTexture(").concat(n,", uv);\n      }\n    ");if(1===o)return t?"\n      float ".concat(a,"(int index) {\n        vec2 uv = vec2((float(index + ").concat(i,") + 0.5) / float(").concat(n,"TexShape[1]), 0.5);\n        return sampleTexture(").concat(n,", uv);\n      }\n    "):"\n      float ".concat(a,"(int index) {\n        vec2 uv = vec2((float(index + ").concat(i,") + 0.5) / ").concat(s,".0, 0.5);\n        return sampleTexture(").concat(n,", uv);\n      }\n    ");if(t)return"\n    float ".concat(a,"(int index) {\n      vec2 uv = uvFromFlat(").concat(n,"TexShape[0], ").concat(n,"TexShape[1], index + ").concat(i,");\n      return sampleTexture(").concat(n,", uv);\n    }\n  ");return"\n    float ".concat(a,"(int index) {\n      vec2 uv = uvFromFlat(").concat(o,", ").concat(s,", index + ").concat(i,");\n      return sampleTexture(").concat(n,", uv);\n    }\n  ")}(e,t);case 2:return function(e,t){const n=e.shapeInfo.logicalShape,a=e.name,r="get"+a.charAt(0).toUpperCase()+a.slice(1),o=e.shapeInfo.texShape;if(null!=o&&uo(n,o)){if(t)return"\n      float ".concat(r,"(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(").concat(a,"TexShape[1], ").concat(a,"TexShape[0]);\n        return sampleTexture(").concat(a,", uv);\n      }\n    ");const e=o[0],n=o[1];return"\n    float ".concat(r,"(int row, int col) {\n      vec2 uv = (vec2(col, row) + halfCR) / vec2(").concat(n,".0, ").concat(e,".0);\n      return sampleTexture(").concat(a,", uv);\n    }\n  ")}const{newShape:s,keptDims:i}=yo(n),c=s;if(c.length<n.length){const n=WO(e,c),a=["row","col"];return"\n      ".concat(_O(n,t),"\n      float ").concat(r,"(int row, int col) {\n        return ").concat(r,"(").concat(VO(a,i),");\n      }\n    ")}if(e.shapeInfo.isUniform)return"\n      float ".concat(r,"(int row, int col) {\n        int index = round(dot(vec2(row, col), vec2(").concat(n[1],", 1)));\n        ").concat(PO(e),"\n      }\n    ");const l=o[0],u=o[1],d=LO(a);if(1===u)return t?"\n      float ".concat(r,"(int row, int col) {\n        float index = dot(vec3(row, col, ").concat(d,"), vec3(").concat(a,"Shape[1], 1, 1));\n        vec2 uv = vec2(0.5, (index + 0.5) / float(").concat(a,"TexShape[0]));\n        return sampleTexture(").concat(a,", uv);\n      }\n    "):"\n    float ".concat(r,"(int row, int col) {\n      float index = dot(vec3(row, col, ").concat(d,"), vec3(").concat(n[1],", 1, 1));\n      vec2 uv = vec2(0.5, (index + 0.5) / ").concat(l,".0);\n      return sampleTexture(").concat(a,", uv);\n    }\n  ");if(1===l)return t?"\n      float ".concat(r,"(int row, int col) {\n        float index = dot(vec3(row, col, ").concat(d,"), vec3(").concat(a,"Shape[1], 1, 1));\n        vec2 uv = vec2((index + 0.5) / float(").concat(a,"TexShape[1]), 0.5);\n        return sampleTexture(").concat(a,", uv);\n      }\n    "):"\n    float ".concat(r,"(int row, int col) {\n      float index = dot(vec3(row, col, ").concat(d,"), vec3(").concat(n[1],", 1, 1));\n      vec2 uv = vec2((index + 0.5) / ").concat(u,".0, 0.5);\n      return sampleTexture(").concat(a,", uv);\n    }\n  ");if(t)return"\n      float ".concat(r,"(int row, int col) {\n        // Explicitly use integer operations as dot() only works on floats.\n        int index = row * ").concat(a,"Shape[1] + col + ").concat(d,";\n        vec2 uv = uvFromFlat(").concat(a,"TexShape[0], ").concat(a,"TexShape[1], index);\n        return sampleTexture(").concat(a,", uv);\n      }\n    ");return"\n  float ".concat(r,"(int row, int col) {\n    // Explicitly use integer operations as dot() only works on floats.\n    int index = row * ").concat(n[1]," + col + ").concat(d,";\n    vec2 uv = uvFromFlat(").concat(l,", ").concat(u,", index);\n    return sampleTexture(").concat(a,", uv);\n  }\n")}(e,t);case 3:return function(e,t){const n=e.shapeInfo.logicalShape,a=e.name,r="get"+a.charAt(0).toUpperCase()+a.slice(1),o=n[1]*n[2],s=n[2],{newShape:i,keptDims:c}=yo(n),l=i;if(l.length<n.length){const n=WO(e,l),a=["row","col","depth"];return"\n        ".concat(_O(n,t),"\n        float ").concat(r,"(int row, int col, int depth) {\n          return ").concat(r,"(").concat(VO(a,c),");\n        }\n      ")}if(e.shapeInfo.isUniform)return"\n      float ".concat(r,"(int row, int col, int depth) {\n        int index = round(dot(vec3(row, col, depth),\n                          vec3(").concat(o,", ").concat(s,", 1)));\n        ").concat(PO(e),"\n      }\n    ");const u=e.shapeInfo.texShape,d=u[0],h=u[1],p=e.shapeInfo.flatOffset;if(h===o&&null==p)return t?"\n      float ".concat(r,"(int row, int col, int depth) {\n        int stride1 = ").concat(a,"Shape[2];\n        float texR = float(row);\n        float texC = dot(vec2(col, depth), vec2(stride1, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(").concat(a,"TexShape[1], ").concat(a,"TexShape[0]);\n        return sampleTexture(").concat(a,", uv);\n      }\n    "):"\n        float ".concat(r,"(int row, int col, int depth) {\n          float texR = float(row);\n          float texC = dot(vec2(col, depth), vec2(").concat(s,", 1));\n          vec2 uv = (vec2(texC, texR) + halfCR) /\n                     vec2(").concat(h,".0, ").concat(d,".0);\n          return sampleTexture(").concat(a,", uv);\n        }\n      ");if(h===s&&null==p)return t?"\n      float ".concat(r,"(int row, int col, int depth) {\n        float texR = dot(vec2(row, col), vec2(").concat(a,"Shape[1], 1));\n        float texC = float(depth);\n        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(").concat(a,"TexShape[1], ").concat(a,"TexShape[0]);\n        return sampleTexture(").concat(a,", uv);\n      }\n    "):"\n    float ".concat(r,"(int row, int col, int depth) {\n      float texR = dot(vec2(row, col), vec2(").concat(n[1],", 1));\n      float texC = float(depth);\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(").concat(h,".0, ").concat(d,".0);\n      return sampleTexture(").concat(a,", uv);\n    }\n  ");const f=LO(a);if(t)return"\n    float ".concat(r,"(int row, int col, int depth) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int stride0 = ").concat(a,"Shape[1] * ").concat(a,"Shape[2];\n      int stride1 = ").concat(a,"Shape[2];\n      int index = row * stride0 + col * stride1 + depth + ").concat(f,";\n      vec2 uv = uvFromFlat(").concat(a,"TexShape[0], ").concat(a,"TexShape[1], index);\n      return sampleTexture(").concat(a,", uv);\n    }\n    ");return"\n      float ".concat(r,"(int row, int col, int depth) {\n        // Explicitly use integer operations as dot() only works on floats.\n        int index = row * ").concat(o," + col * ").concat(s," + depth + ").concat(f,";\n        vec2 uv = uvFromFlat(").concat(d,", ").concat(h,", index);\n        return sampleTexture(").concat(a,", uv);\n      }\n  ")}(e,t);case 4:return function(e,t){const n=e.shapeInfo.logicalShape,a=e.name,r="get"+a.charAt(0).toUpperCase()+a.slice(1),o=n[3],s=n[2]*o,i=n[1]*s,{newShape:c,keptDims:l}=yo(n);if(c.length<n.length){const n=WO(e,c),a=["row","col","depth","depth2"];return"\n      ".concat(_O(n,t),"\n      float ").concat(r,"(int row, int col, int depth, int depth2) {\n        return ").concat(r,"(").concat(VO(a,l),");\n      }\n    ")}if(e.shapeInfo.isUniform)return"\n      float ".concat(r,"(int row, int col, int depth, int depth2) {\n        int index = round(dot(vec4(row, col, depth, depth2),\n                          vec4(").concat(i,", ").concat(s,", ").concat(o,", 1)));\n        ").concat(PO(e),"\n      }\n    ");const u=e.shapeInfo.flatOffset,d=e.shapeInfo.texShape,h=d[0],p=d[1],f="int stride2 = ".concat(a,"Shape[3];"),m="int stride1 = ".concat(a,"Shape[2] * stride2;"),g="int stride0 = ".concat(a,"Shape[1] * stride1;");if(p===i&&null==u)return t?"\n      float ".concat(r,"(int row, int col, int depth, int depth2) {\n        ").concat(f,"\n        ").concat(m,"\n        float texR = float(row);\n        float texC =\n            dot(vec3(col, depth, depth2),\n                vec3(stride1, stride2, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(").concat(a,"TexShape[1], ").concat(a,"TexShape[0]);\n        return sampleTexture(").concat(a,", uv);\n      }\n    "):"\n      float ".concat(r,"(int row, int col, int depth, int depth2) {\n        float texR = float(row);\n        float texC =\n            dot(vec3(col, depth, depth2),\n                vec3(").concat(s,", ").concat(o,", 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(").concat(p,".0, ").concat(h,".0);\n        return sampleTexture(").concat(a,", uv);\n      }\n    ");if(p===o&&null==u)return t?"\n      float ".concat(r,"(int row, int col, int depth, int depth2) {\n        float texR = dot(vec3(row, col, depth),\n                         vec3(").concat(a,"Shape[1] * ").concat(a,"Shape[2], ").concat(a,"Shape[2], 1));\n        float texC = float(depth2);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(").concat(a,"TexShape[1], ").concat(a,"TexShape[0]);\n        return sampleTexture(").concat(a,", uv);\n      }\n    "):"\n      float ".concat(r,"(int row, int col, int depth, int depth2) {\n        float texR = dot(vec3(row, col, depth),\n                         vec3(").concat(n[1]*n[2],", ").concat(n[2],", 1));\n        float texC = float(depth2);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(").concat(p,".0, ").concat(h,".0);\n        return sampleTexture(").concat(a,", uv);\n      }\n    ");const b=LO(a);if(t)return"\n    float ".concat(r,"(int row, int col, int depth, int depth2) {\n      // Explicitly use integer operations as dot() only works on floats.\n      ").concat(f,"\n      ").concat(m,"\n      ").concat(g,"\n      int index = row * stride0 + col * stride1 +\n          depth * stride2 + depth2;\n      vec2 uv = uvFromFlat(").concat(a,"TexShape[0], ").concat(a,"TexShape[1], index + ").concat(b,");\n      return sampleTexture(").concat(a,", uv);\n    }\n  ");return"\n    float ".concat(r,"(int row, int col, int depth, int depth2) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ").concat(i," + col * ").concat(s," +\n          depth * ").concat(o," + depth2;\n      vec2 uv = uvFromFlat(").concat(h,", ").concat(p,", index + ").concat(b,");\n      return sampleTexture(").concat(a,", uv);\n    }\n  ")}(e,t);case 5:return function(e){const t=e.shapeInfo.logicalShape,n=e.name,a="get"+n.charAt(0).toUpperCase()+n.slice(1),r=t[4],o=t[3]*r,s=t[2]*o,i=t[1]*s,{newShape:c,keptDims:l}=yo(t);if(c.length<t.length){const t=WO(e,c),n=["row","col","depth","depth2","depth3"];return"\n      ".concat(_O(t),"\n      float ").concat(a,"(int row, int col, int depth, int depth2, int depth3) {\n        return ").concat(a,"(").concat(VO(n,l),");\n      }\n    ")}if(e.shapeInfo.isUniform)return"\n      float ".concat(a,"(int row, int col, int depth, int depth2, int depth3) {\n        float index = dot(\n          vec4(row, col, depth, depth2),\n          vec4(").concat(i,", ").concat(s,", ").concat(o,", ").concat(r,")) +\n          depth3;\n        ").concat(PO(e),"\n      }\n    ");const u=e.shapeInfo.flatOffset,d=e.shapeInfo.texShape,h=d[0],p=d[1];if(p===i&&null==u)return"\n      float ".concat(a,"(int row, int col, int depth, int depth2, int depth3) {\n        int texR = row;\n        float texC = dot(vec4(col, depth, depth2, depth3),\n                         vec4(").concat(s,", ").concat(o,", ").concat(r,", 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(").concat(p,".0, ").concat(h,".0);\n        return sampleTexture(").concat(n,", uv);\n      }\n    ");if(p===r&&null==u)return"\n      float ".concat(a,"(int row, int col, int depth, int depth2, int depth3) {\n        float texR = dot(\n          vec4(row, col, depth, depth2),\n          vec4(").concat(t[1]*t[2]*t[3],",\n               ").concat(t[2]*t[3],", ").concat(t[3],", 1));\n        int texC = depth3;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(").concat(p,".0, ").concat(h,".0);\n        return sampleTexture(").concat(n,", uv);\n      }\n    ");const f=LO(n);return"\n    float ".concat(a,"(int row, int col, int depth, int depth2, int depth3) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ").concat(i," + col * ").concat(s," + depth * ").concat(o," +\n          depth2 * ").concat(r," + depth3 + ").concat(f,";\n      vec2 uv = uvFromFlat(").concat(h,", ").concat(p,", index);\n      return sampleTexture(").concat(n,", uv);\n    }\n  ")}(e);case 6:return function(e){const t=e.shapeInfo.logicalShape,n=e.name,a="get"+n.charAt(0).toUpperCase()+n.slice(1),{newShape:r,keptDims:o}=yo(t);if(r.length<t.length){const t=WO(e,r),n=["row","col","depth","depth2","depth3","depth4"];return"\n      ".concat(_O(t),"\n      float ").concat(a,"(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        return ").concat(a,"(").concat(VO(n,o),");\n      }\n    ")}const s=t[5],i=t[4]*s,c=t[3]*i,l=t[2]*c,u=t[1]*l;if(e.shapeInfo.isUniform)return"\n      float ".concat(a,"(int row, int col, int depth,\n                  int depth2, int depth3, int depth4) {\n        int index = round(dot(\n          vec4(row, col, depth, depth2),\n          vec4(").concat(u,", ").concat(l,", ").concat(c,", ").concat(i,")) +\n          dot(\n            vec2(depth3, depth4),\n            vec2(").concat(s,", 1)));\n        ").concat(PO(e),"\n      }\n    ");const d=e.shapeInfo.flatOffset,h=e.shapeInfo.texShape,p=h[0],f=h[1];if(f===u&&null==d)return"\n      float ".concat(a,"(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        int texR = row;\n        float texC = dot(vec4(col, depth, depth2, depth3),\n          vec4(").concat(l,", ").concat(c,", ").concat(i,", ").concat(s,")) +\n               float(depth4);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(").concat(f,".0, ").concat(p,".0);\n        return sampleTexture(").concat(n,", uv);\n      }\n    ");if(f===s&&null==d)return"\n      float ".concat(a,"(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        float texR = dot(vec4(row, col, depth, depth2),\n          vec4(").concat(t[1]*t[2]*t[3]*t[4],",\n               ").concat(t[2]*t[3]*t[4],",\n               ").concat(t[3]*t[4],",\n               ").concat(t[4],")) + float(depth3);\n        int texC = depth4;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(").concat(f,".0, ").concat(p,".0);\n        return sampleTexture(").concat(n,", uv);\n      }\n    ");const m=LO(n);return"\n    float ".concat(a,"(int row, int col, int depth,\n                  int depth2, int depth3, int depth4) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ").concat(u," + col * ").concat(l," + depth * ").concat(c," +\n          depth2 * ").concat(i," + depth3 * ").concat(s," + depth4 + ").concat(m,";\n      vec2 uv = uvFromFlat(").concat(p,", ").concat(f,", index);\n      return sampleTexture(").concat(n,", uv);\n    }\n  ")}(e);default:throw new Error("".concat(n.length,"-D input sampling")+" is not yet supported")}}function AO(e,t){switch(e.shapeInfo.logicalShape.length){case 0:return function(e){const t=e.name,n="get"+t.charAt(0).toUpperCase()+t.slice(1),a=kO();return"\n    vec4 ".concat(n,"() {\n      return ").concat(a.texture2D,"(").concat(t,", halfCR);\n    }\n  ")}(e);case 1:return function(e,t){const n=e.name,a="get"+n.charAt(0).toUpperCase()+n.slice(1),r=e.shapeInfo.texShape,o=kO();if(t)return"\n    vec4 ".concat(a,"(int index) {\n      ivec2 packedTexShape = ivec2(ceil(float(").concat(n,"TexShape[0]) / 2.0), ceil(float(").concat(n,"TexShape[1]) / 2.0));\n      vec2 uv = packedUVfrom1D(\n        packedTexShape[0], packedTexShape[1], index);\n      return ").concat(o.texture2D,"(").concat(n,", uv);\n    }\n  ");const s=[Math.ceil(r[0]/2),Math.ceil(r[1]/2)];return"\n    vec4 ".concat(a,"(int index) {\n      vec2 uv = packedUVfrom1D(\n        ").concat(s[0],", ").concat(s[1],", index);\n      return ").concat(o.texture2D,"(").concat(n,", uv);\n    }\n  ")}(e,t);case 2:return function(e,t){const n=e.shapeInfo.logicalShape,a=e.name,r="get"+a.charAt(0).toUpperCase()+a.slice(1),o=e.shapeInfo.texShape,s=o[0],i=o[1],c=kO();if(null!=o&&uo(n,o))return t?"\n      vec4 ".concat(r,"(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(").concat(a,"TexShape[1], ").concat(a,"TexShape[0]);\n\n        return ").concat(c.texture2D,"(").concat(a,", uv);\n      }\n    "):"\n      vec4 ".concat(r,"(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(").concat(i,".0, ").concat(s,".0);\n\n        return ").concat(c.texture2D,"(").concat(a,", uv);\n      }\n    ");if(t)return"\n    vec4 ".concat(r,"(int row, int col) {\n      ivec2 packedTexShape = ivec2(ceil(float(").concat(a,"TexShape[0]) / 2.0), ceil(float(").concat(a,"TexShape[1]) / 2.0));\n      int valuesPerRow = int(ceil(float(").concat(a,"Shape[1]) / 2.0));\n      vec2 uv = packedUVfrom2D(valuesPerRow, packedTexShape[0], packedTexShape[1], row, col);\n      return ").concat(c.texture2D,"(").concat(a,", uv);\n    }\n  ");const l=[Math.ceil(o[0]/2),Math.ceil(o[1]/2)],u=Math.ceil(n[1]/2);return"\n    vec4 ".concat(r,"(int row, int col) {\n      vec2 uv = packedUVfrom2D(").concat(u,", ").concat(l[0],", ").concat(l[1],", row, col);\n      return ").concat(c.texture2D,"(").concat(a,", uv);\n    }\n  ")}(e,t);case 3:return function(e,t){const n=e.shapeInfo.logicalShape,a=e.name,r="get"+a.charAt(0).toUpperCase()+a.slice(1),o=e.shapeInfo.texShape,s=[Math.ceil(o[0]/2),Math.ceil(o[1]/2)];if(1===n[0]){const a=[1,2],o=WO(e,n.slice(1)),s=["b","row","col"];return"\n        ".concat(AO(o,t),"\n        vec4 ").concat(r,"(int b, int row, int col) {\n          return ").concat(r,"(").concat(VO(s,a),");\n        }\n      ")}const i=kO();if(t)return"\n    vec4 ".concat(r,"(int b, int row, int col) {\n      ivec2 packedTexShape = ivec2(ceil(float(").concat(a,"TexShape[0]) / 2.0), ceil(float(").concat(a,"TexShape[1]) / 2.0));\n      int valuesPerRow = int(ceil(float(").concat(a,"Shape[2]) / 2.0));\n      int texelsInBatch = valuesPerRow * int(ceil(float(").concat(a,"Shape[1]) / 2.0));\n      vec2 uv = packedUVfrom3D(\n        packedTexShape[0], packedTexShape[1], texelsInBatch, valuesPerRow, b, row, col);\n      return ").concat(i.texture2D,"(").concat(a,", uv);\n    }\n  ");const c=s[0],l=s[1],u=Math.ceil(n[2]/2),d=u*Math.ceil(n[1]/2);return"\n    vec4 ".concat(r,"(int b, int row, int col) {\n      vec2 uv = packedUVfrom3D(\n        ").concat(c,", ").concat(l,", ").concat(d,", ").concat(u,", b, row, col);\n      return ").concat(i.texture2D,"(").concat(a,", uv);\n    }\n  ")}(e,t);default:return function(e,t){const n=e.name,a="get"+n.charAt(0).toUpperCase()+n.slice(1),r=kO();if(t)return"\n    vec4 ".concat(a,"(int b2, int b, int row, int col) {\n      int valuesPerRow = int(ceil(float(").concat(n,"Shape[3]) / 2.0));\n      int texelsInBatch = valuesPerRow * int(ceil(float(").concat(n,"Shape[2]) / 2.0));\n      int index = b * texelsInBatch + (row / 2) * valuesPerRow + (col / 2);\n      texelsInBatch *= ").concat(n,"Shape[1];\n      index = b2 * texelsInBatch + index;\n      ivec2 packedTexShape = ivec2(ceil(float(").concat(n,"TexShape[0]) / 2.0), ceil(float(").concat(n,"TexShape[1]) / 2.0));\n      int texR = index / packedTexShape[1];\n      int texC = index - texR * packedTexShape[1];\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(packedTexShape[1], packedTexShape[0]); return ").concat(r.texture2D,"(").concat(n,", uv);\n    }\n  ");const o=e.shapeInfo.logicalShape,s=o.length,i=e.shapeInfo.texShape,c=[Math.ceil(i[0]/2),Math.ceil(i[1]/2)],l=c[0],u=c[1],d=Math.ceil(o[s-1]/2);let h=d*Math.ceil(o[s-2]/2),p="int b, int row, int col",f="b * ".concat(h," + (row / 2) * ").concat(d," + (col / 2)");for(let m=2;m<s-1;m++)p="int b".concat(m,", ")+p,h*=o[s-m-1],f="b".concat(m," * ").concat(h," + ")+f;return"\n    vec4 ".concat(a,"(").concat(p,") {\n      int index = ").concat(f,";\n      int texR = index / ").concat(u,";\n      int texC = index - texR * ").concat(u,";\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(").concat(u,", ").concat(l,");\n      return ").concat(r.texture2D,"(").concat(n,", uv);\n    }\n  ")}(e,t)}}const FO="\nvec2 uvFromFlat(int texNumR, int texNumC, int index) {\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\nvec2 packedUVfrom1D(int texNumR, int texNumC, int index) {\n  int texelIndex = index / 2;\n  int texR = texelIndex / texNumC;\n  int texC = texelIndex - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",OO="\nvec2 packedUVfrom2D(int texelsInLogicalRow, int texNumR,\n  int texNumC, int row, int col) {\n  int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);\n  int texR = texelIndex / texNumC;\n  int texC = texelIndex - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",DO="\nvec2 packedUVfrom3D(int texNumR, int texNumC,\n    int texelsInBatch, int texelsInLogicalRow, int b,\n    int row, int col) {\n  int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",MO="\n  float getChannel(vec4 frag, vec2 innerDims) {\n    vec2 modCoord = mod(innerDims, 2.);\n    return modCoord.x == 0. ?\n      (modCoord.y == 0. ? frag.r : frag.g) :\n      (modCoord.y == 0. ? frag.b : frag.a);\n  }\n  float getChannel(vec4 frag, int dim) {\n    float modCoord = mod(float(dim), 2.);\n    return modCoord == 0. ? frag.r : frag.g;\n  }\n";function LO(e){return"offset".concat(e)}function PO(e){const t=e.name,n=lo(e.shapeInfo.logicalShape);return n<2?"return ".concat(t,";"):"\n    for (int i = 0; i < ".concat(n,"; i++) {\n      if (i == index) {\n        return ").concat(t,"[i];\n      }\n    }\n  ")}function zO(e){if(e<=1)return"int";if(2===e)return"ivec2";if(3===e)return"ivec3";if(4===e)return"ivec4";if(5===e)return"ivec5";if(6===e)return"ivec6";throw Error("GPU for rank ".concat(e," is not yet supported"))}function BO(e,t,n){const{newShape:a,keptDims:r}=yo(t),o=t.length,s=e&&3===o&&1===t[0],i=s?t.slice(1):a,c=!e&&o>1&&!uo(t,n)&&a.length<o||s;return{useSqueezeShape:c,uniformShape:c?i:t,keptDims:r}}function WO(e,t){const n=JSON.parse(JSON.stringify(e));return n.shapeInfo.logicalShape=t,n}function VO(e,t){return t.map((t=>e[t])).join(", ")}function UO(e,t,n,a){const r=n.map(((e,n)=>{const a={logicalShape:e.shape,texShape:e.isUniform?null:e.texData.texShape,isUniform:e.isUniform,isPacked:!e.isUniform&&e.texData.isPacked,flatOffset:null};return null!=e.texData&&null!=e.texData.slice&&e.texData.slice.flatOffset>0&&(a.flatOffset=e.texData.slice.flatOffset),{name:t.variableNames[n],shapeInfo:a}})),o=r.map((e=>e.shapeInfo)),s={logicalShape:a.shape,texShape:a.texData.texShape,isUniform:!1,isPacked:a.texData.isPacked,flatOffset:null},i=RO(r,s,t),c=function(e,t){const n=iO(e,(()=>e.createShader(e.FRAGMENT_SHADER)),"Unable to create fragment WebGLShader.");if(QF(e,(()=>e.shaderSource(n,t))),QF(e,(()=>e.compileShader(n))),Vo().get("ENGINE_COMPILE_ONLY"))return n;if(!1===e.getShaderParameter(n,e.COMPILE_STATUS))throw eO(t,e.getShaderInfoLog(n)),new Error("Failed to compile fragment shader.");return n}(e.gl,i),l=e.createProgram(c);return Vo().get("ENGINE_COMPILE_ONLY")?{program:t,fragmentShader:c,source:i,webGLProgram:l,inShapeInfos:o,outShapeInfo:s,variablesLocations:null,customUniformLocations:null,infLoc:null,nanLoc:null,outShapeLocation:null,outShapeStridesLocation:null,outTexShapeLocation:null}:(e.buildVao(l),Object.assign({program:t,fragmentShader:c,source:i,webGLProgram:l,inShapeInfos:o,outShapeInfo:s},GO(e,t,l)))}function GO(e,t,n){const a=[],r=[];let o,s,i,c=null,l=null;l=e.getUniformLocation(n,"NAN",!1),1===Vo().getNumber("WEBGL_VERSION")&&(c=e.getUniformLocation(n,"INFINITY",!1));const u=!1;for(const d of t.variableNames){const r={name:d,uniform:e.getUniformLocation(n,d,u),offset:e.getUniformLocation(n,"offset".concat(d),u)};t.enableShapeUniforms&&(r.shape=e.getUniformLocation(n,"".concat(d,"Shape"),u),r.texShape=e.getUniformLocation(n,"".concat(d,"TexShape"),u)),a.push(r)}if(t.enableShapeUniforms&&(o=e.getUniformLocation(n,"outShape",u),i=e.getUniformLocation(n,"outShapeStrides",u),s=e.getUniformLocation(n,"outTexShape",u)),t.customUniforms)for(const d of t.customUniforms)r.push(e.getUniformLocation(n,d.name,u));return{variablesLocations:a,customUniformLocations:r,infLoc:c,nanLoc:l,outShapeLocation:o,outShapeStridesLocation:i,outTexShapeLocation:s}}function HO(e,t){if(e.length!==t.length)throw Error("Binary was compiled with ".concat(e.length," inputs, but ")+"was executed with ".concat(t.length," inputs"));e.forEach(((e,n)=>{const a=e.logicalShape,r=t[n],o=r.shape;if(!uo(a,o))throw Error("Binary was compiled with different shapes than "+"the current args. Shapes ".concat(a," and ").concat(o," must match"));if(e.isUniform&&r.isUniform)return;const s=e.texShape,i=r.isUniform?null:r.texData.texShape;if(!uo(s,i))throw Error("Binary was compiled with different texture shapes than the"+" current args. Shape ".concat(s," and ").concat(i," must match"))}))}function jO(e){return Vo().getBool("WEBGL_USE_SHAPES_UNIFORMS")&&e<=4}class KO{constructor(e){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outPackingScheme=GF.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];const t=kO();this.outputShape=e,this.enableShapeUniforms=jO(this.outputShape.length),this.userCode="\n      ivec3 outCoordsFromFlatIndex(int index) {\n        ".concat(this.enableShapeUniforms?SO(["r","c","d"],e):IO(["r","c","d"],e),"\n        return ivec3(r, c, d);\n      }\n\n      void main() {\n        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));\n        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);\n\n        vec4 result = vec4(0.);\n\n        for (int i=0; i<4; i++) {\n          int flatIndex = index + i;\n          ivec3 rc = outCoordsFromFlatIndex(flatIndex);\n          result[i] = getA(rc.x, rc.y, rc.z);\n        }\n\n        ").concat(t.output," = result;\n      }\n    ")}}class qO{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outPackingScheme=GF.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];const t=kO();this.outputShape=e,this.enableShapeUniforms=jO(this.outputShape.length),this.userCode="\n      ivec3 outCoordsFromFlatIndex(int index) {\n        ".concat(this.enableShapeUniforms?SO(["r","c","d"],e):IO(["r","c","d"],e),"\n        return ivec3(r, c, d);\n      }\n\n      void main() {\n        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));\n        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);\n\n        vec4 result = vec4(0.);\n\n        for (int i=0; i<4; i++) {\n          int flatIndex = index + i;\n          ivec3 rc = outCoordsFromFlatIndex(flatIndex);\n          result[i] = getChannel(getA(rc.x, rc.y, rc.z), vec2(rc.y, rc.z));\n        }\n\n        ").concat(t.output," = result;\n      }\n    ")}}class XO{constructor(e){this.variableNames=["A"],this.outTexUsage=HF.DOWNLOAD;const t=kO();this.outputShape=e,this.userCode="\n      ".concat(TO,"\n\n      void main() {\n        float x = getAAtOutCoords();\n        ").concat(t.output," = encode_float(x);\n      }\n    ")}}class YO{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outTexUsage=HF.DOWNLOAD;const t=kO();this.outputShape=e,this.userCode="\n      ".concat(TO,"\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n        float x = getChannel(getAAtOutCoords(), vec2(coords.y, coords.z));\n        ").concat(t.output," = encode_float(x);\n      }\n    ")}}const QO={R:0,G:1,B:2,A:3};class JO{constructor(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1],n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"RGBA";this.variableNames=["A"],this.customUniforms=[{name:"texShape",type:"ivec2"}];const a=kO();this.outputShape=e,this.enableShapeUniforms=jO(this.outputShape.length);let r="result";t&&(r="floor(result * 255. + 0.5)");let o="";for(let s=0;s<n.length;s++){const e=n[s];o+="\n          if(offset == ".concat(s,") {\n            result = values[").concat(QO[e],"];\n          }")}this.userCode="\n      ".concat(this.enableShapeUniforms?"\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;\n  }\n":CO(e),"\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int flatIndex = getFlatIndex(coords);\n        float result = 0.;\n        int offset = imod(flatIndex, ").concat(n.length,");\n\n        flatIndex = idiv(flatIndex, ").concat(n.length,", 1.);\n\n        int r = flatIndex / texShape[1];\n        if (r < texShape[0]) {\n          int c = imod(flatIndex, texShape[1]);\n          vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);\n          vec4 values = ").concat(a.texture2D,"(A, uv);\n          ").concat(o,"\n        }\n        ").concat(a.output," = vec4(").concat(r,", 0., 0., 0.);\n      }\n    ")}}class ZO{constructor(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.customUniforms=[{name:"texShape",type:"ivec2"}];const n=kO();this.outputShape=e,this.enableShapeUniforms=jO(this.outputShape.length);let a="",r="result";t&&(r="floor(result * 255. + 0.5)");for(let o=0;o<=1;o++)for(let t=0;t<=1;t++){const r=2*o+t;a+="\n          localCoords = coords;\n          if(localCoords[2] + ".concat(t," < ").concat(this.enableShapeUniforms?"outShape[2]":"".concat(e[2]),") {\n          localCoords[2] += ").concat(t,";\n          if (localCoords[1] + ").concat(o," < ").concat(this.enableShapeUniforms?"outShape[1]":"".concat(e[1]),") {\n            localCoords[1] += ").concat(o,";\n\n            flatIndex = getFlatIndex(localCoords);\n            offset = imod(flatIndex, 4);\n\n            flatIndex = idiv(flatIndex, 4, 1.);\n\n            int r = flatIndex / texShape[1];\n            int c = imod(flatIndex, texShape[1]);\n            vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);\n            values = ").concat(n.texture2D,"(A, uv);\n\n            if (offset == 0) {\n              result[").concat(r,"] = values[0];\n            } else if (offset == 1) {\n              result[").concat(r,"] = values[1];\n            } else if (offset == 2) {\n              result[").concat(r,"] = values[2];\n            } else {\n              result[").concat(r,"] = values[3];\n            }\n          }\n        }\n        ")}this.userCode="\n        ".concat(this.enableShapeUniforms?"\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;\n  }\n":CO(e),"\n\n        void main() {\n          ivec3 coords = getOutputCoords();\n\n          vec4 result = vec4(0.);\n          int flatIndex, r, c, offset;\n          ivec3 localCoords;\n          vec2 uv;\n          vec4 values;\n\n          ").concat(a,"\n\n          ").concat(n.output," = ").concat(r,";\n        }\n    ")}}function $O(e){const t=kO();return function(e,t){const n=iO(e,(()=>e.createShader(e.VERTEX_SHADER)),"Unable to create vertex WebGLShader.");if(QF(e,(()=>e.shaderSource(n,t))),QF(e,(()=>e.compileShader(n))),!1===e.getShaderParameter(n,e.COMPILE_STATUS))throw console.log(e.getShaderInfoLog(n)),new Error("Failed to compile vertex shader.");return n}(e,"".concat(t.version,"\n    precision highp float;\n    ").concat(t.attribute," vec3 clipSpacePos;\n    ").concat(t.attribute," vec2 uv;\n    ").concat(t.varyingVs," vec2 resultUV;\n\n    void main() {\n      gl_Position = vec4(clipSpacePos, 1);\n      resultUV = uv;\n    }"))}function eD(e){return function(e,t){const n=iO(e,(()=>e.createBuffer()),"Unable to create WebGLBuffer");return QF(e,(()=>e.bindBuffer(e.ARRAY_BUFFER,n))),QF(e,(()=>e.bufferData(e.ARRAY_BUFFER,t,e.STATIC_DRAW))),n}(e,new Float32Array([-1,1,0,0,1,-1,-1,0,0,0,1,1,0,1,1,1,-1,0,1,0]))}function tD(e){return function(e,t){const n=iO(e,(()=>e.createBuffer()),"Unable to create WebGLBuffer");return QF(e,(()=>e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,n))),QF(e,(()=>e.bufferData(e.ELEMENT_ARRAY_BUFFER,t,e.STATIC_DRAW))),n}(e,new Uint16Array([0,1,2,2,1,3]))}function nD(e,t,n,a,r,o){!function(e,t){const n=Vo().getNumber("WEBGL_MAX_TEXTURE_SIZE");if(e<=0||t<=0){const n="[".concat(e,"x").concat(t,"]");throw new Error("Requested texture size "+n+" is invalid.")}if(e>n||t>n){const a="[".concat(e,"x").concat(t,"]"),r="[".concat(n,"x").concat(n,"]");throw new Error("Requested texture size "+a+" greater than WebGL maximum on this browser / GPU "+r+".")}}(t,n);const s=function(e){return iO(e,(()=>e.createTexture()),"Unable to create WebGLTexture.")}(e),i=e.TEXTURE_2D;return QF(e,(()=>e.bindTexture(i,s))),QF(e,(()=>e.texParameteri(i,e.TEXTURE_WRAP_S,e.CLAMP_TO_EDGE))),QF(e,(()=>e.texParameteri(i,e.TEXTURE_WRAP_T,e.CLAMP_TO_EDGE))),QF(e,(()=>e.texParameteri(i,e.TEXTURE_MIN_FILTER,e.NEAREST))),QF(e,(()=>e.texParameteri(i,e.TEXTURE_MAG_FILTER,e.NEAREST))),1===Vo().getNumber("WEBGL_VERSION")?QF(e,(()=>e.texImage2D(i,0,a,t,n,0,r,o,null))):QF(e,(()=>e.texStorage2D(i,1,a,t,n))),QF(e,(()=>e.bindTexture(e.TEXTURE_2D,null))),{texture:s,texShape:[n,t]}}function aD(e){return e.internalFormatFloat}function rD(e){return e.internalFormatHalfFloat}function oD(e){return e.downloadTextureFormat}function sD(e){return e.internalFormatPackedFloat}function iD(e){return e.internalFormatPackedHalfFloat}function cD(e,t,n,a,r,o,s,i){const c=e,l=new Float32Array(function(e,t){const[n,a]=XF(e,t);return n*a*4}(o,s));return c.bindBuffer(c.PIXEL_PACK_BUFFER,t),c.getBufferSubData(c.PIXEL_PACK_BUFFER,0,l),c.bindBuffer(c.PIXEL_PACK_BUFFER,null),l}class lD{constructor(e){this.outputTexture=null,this.program=null,this.disposed=!1,this.itemsToPoll=[];const t=Vo().getNumber("WEBGL_VERSION");if(null!=e?(this.gl=e,function(e,t){WF[e]=t}(t,e)):this.gl=UF(t),e=this.gl,2===Vo().getNumber("WEBGL_VERSION")){const t=e;this.createVertexArray=()=>QF(t,(()=>t.createVertexArray())),this.bindVertexArray=e=>QF(t,(()=>t.bindVertexArray(e))),this.deleteVertexArray=e=>QF(t,(()=>t.deleteVertexArray(e))),this.getVertexArray=()=>QF(t,(()=>t.getParameter(t.VERTEX_ARRAY_BINDING)))}else if(null!=e){const t=e.getExtension("OES_vertex_array_object");if(null==t)throw new Error("All WebGL1 implementations are expected to offer OES_vertex_array_object.");this.createVertexArray=()=>QF(e,(()=>t.createVertexArrayOES())),this.bindVertexArray=n=>QF(e,(()=>t.bindVertexArrayOES(n))),this.deleteVertexArray=n=>QF(e,(()=>t.deleteVertexArrayOES(n))),this.getVertexArray=()=>QF(e,(()=>e.getParameter(t.VERTEX_ARRAY_BINDING_OES)))}let n="WEBGL_color_buffer_float";const a="EXT_color_buffer_half_float";if(this.parallelCompilationExtension=this.gl.getExtension("KHR_parallel_shader_compile"),1===Vo().getNumber("WEBGL_VERSION")){const e="OES_texture_float",t="OES_texture_half_float";if(this.textureFloatExtension=ZF(this.gl,e),gO(this.gl,t))this.textureHalfFloatExtension=ZF(this.gl,t);else if(Vo().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support half float textures, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.");if(this.colorBufferFloatExtension=this.gl.getExtension(n),gO(this.gl,a))this.colorBufferHalfFloatExtension=ZF(this.gl,a);else if(Vo().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support color renderable half floats, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.")}else if(n="EXT_color_buffer_float",gO(this.gl,n))this.colorBufferFloatExtension=this.gl.getExtension(n);else{if(!gO(this.gl,a))throw new Error("GL context does not support color renderable floats");this.colorBufferHalfFloatExtension=this.gl.getExtension(a)}this.vertexBuffer=eD(this.gl),this.indexBuffer=tD(this.gl),this.framebuffer=function(e){return iO(e,(()=>e.createFramebuffer()),"Unable to create WebGLFramebuffer.")}(this.gl),this.textureConfig=YF(this.gl,this.textureHalfFloatExtension)}get debug(){return Vo().getBool("DEBUG")}dispose(){if(this.disposed)return;null!=this.program&&console.warn("Disposing a GPGPUContext that still has a bound WebGLProgram. This is probably a resource leak, delete the program with GPGPUContext.deleteProgram before disposing."),null!=this.outputTexture&&console.warn("Disposing a GPGPUContext that still has a bound output matrix texture.  This is probably a resource leak, delete the output matrix texture with GPGPUContext.deleteMatrixTexture before disposing.");const e=this.gl;QF(e,(()=>e.finish())),QF(e,(()=>e.bindFramebuffer(e.FRAMEBUFFER,null))),QF(e,(()=>e.deleteFramebuffer(this.framebuffer))),QF(e,(()=>e.bindBuffer(e.ARRAY_BUFFER,null))),QF(e,(()=>e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,null))),QF(e,(()=>e.deleteBuffer(this.indexBuffer))),this.disposed=!0}createFloat32MatrixTexture(e,t){return this.throwIfDisposed(),function(e,t,n,a){const[r,o]=KF(t,n);return nD(e,r,o,aD(a),a.textureFormatFloat,e.FLOAT)}(this.gl,e,t,this.textureConfig)}createFloat16MatrixTexture(e,t){return this.throwIfDisposed(),function(e,t,n,a){const[r,o]=KF(t,n);return nD(e,r,o,rD(a),a.textureFormatFloat,a.textureTypeHalfFloat)}(this.gl,e,t,this.textureConfig)}createUnsignedBytesMatrixTexture(e,t){return this.throwIfDisposed(),function(e,t,n,a){const[r,o]=KF(t,n);return nD(e,r,o,oD(a),e.RGBA,e.UNSIGNED_BYTE)}(this.gl,e,t,this.textureConfig)}uploadPixelDataToTexture(e,t){this.throwIfDisposed(),function(e,t,n){QF(e,(()=>e.bindTexture(e.TEXTURE_2D,t))),n.data instanceof Uint8Array?2===Vo().getNumber("WEBGL_VERSION")?QF(e,(()=>e.texSubImage2D(e.TEXTURE_2D,0,0,0,n.width,n.height,e.RGBA,e.UNSIGNED_BYTE,n.data))):QF(e,(()=>e.texImage2D(e.TEXTURE_2D,0,e.RGBA,n.width,n.height,0,e.RGBA,e.UNSIGNED_BYTE,n.data))):2===Vo().getNumber("WEBGL_VERSION")?QF(e,(()=>e.texSubImage2D(e.TEXTURE_2D,0,0,0,e.RGBA,e.UNSIGNED_BYTE,n))):QF(e,(()=>e.texImage2D(e.TEXTURE_2D,0,e.RGBA,e.RGBA,e.UNSIGNED_BYTE,n))),QF(e,(()=>e.bindTexture(e.TEXTURE_2D,null)))}(this.gl,e,t)}uploadDenseMatrixToTexture(e,t,n,a){this.throwIfDisposed(),function(e,t,n,a,r,o){let s,i,c;QF(e,(()=>e.bindTexture(e.TEXTURE_2D,t))),r instanceof Uint8Array?(s=new Uint8Array(n*a*4),i=e.UNSIGNED_BYTE,c=e.RGBA):(s=new Float32Array(n*a*4),i=e.FLOAT,c=o.internalFormatPackedFloat),s.set(r),2===Vo().getNumber("WEBGL_VERSION")?QF(e,(()=>e.texSubImage2D(e.TEXTURE_2D,0,0,0,n,a,e.RGBA,i,s))):QF(e,(()=>e.texImage2D(e.TEXTURE_2D,0,c,n,a,0,e.RGBA,i,s))),QF(e,(()=>e.bindTexture(e.TEXTURE_2D,null)))}(this.gl,e,t,n,a,this.textureConfig)}createFloat16PackedMatrixTexture(e,t){return this.throwIfDisposed(),function(e,t,n,a){const[r,o]=XF(t,n);return nD(e,r,o,iD(a),e.RGBA,a.textureTypeHalfFloat)}(this.gl,e,t,this.textureConfig)}createPackedMatrixTexture(e,t){return this.throwIfDisposed(),function(e,t,n,a){const[r,o]=XF(t,n);return nD(e,r,o,sD(a),e.RGBA,e.FLOAT)}(this.gl,e,t,this.textureConfig)}deleteMatrixTexture(e){this.throwIfDisposed(),this.outputTexture===e&&(oO(this.gl,this.framebuffer),this.outputTexture=null),QF(this.gl,(()=>this.gl.deleteTexture(e)))}downloadByteEncodedFloatMatrixFromOutputTexture(e,t,n){return this.downloadMatrixDriver(e,(()=>function(e,t,n,a){const[r,o]=KF(t,n),s=new Uint8Array(t*n*4);return QF(e,(()=>e.readPixels(0,0,r,o,a.downloadTextureFormat,e.UNSIGNED_BYTE,s))),new Float32Array(s.buffer)}(this.gl,t,n,this.textureConfig)))}downloadPackedMatrixFromBuffer(e,t,n,a,r,o){return cD(this.gl,e,0,0,0,r,o,this.textureConfig)}downloadFloat32MatrixFromBuffer(e,t){return function(e,t,n){const a=e,r=new Float32Array(n);return a.bindBuffer(a.PIXEL_PACK_BUFFER,t),a.getBufferSubData(a.PIXEL_PACK_BUFFER,0,r),a.bindBuffer(a.PIXEL_PACK_BUFFER,null),r}(this.gl,e,t)}createBufferFromTexture(e,t,n){this.bindTextureToFrameBuffer(e);const a=function(e,t,n,a){const r=e.createBuffer();QF(e,(()=>e.bindBuffer(e.PIXEL_PACK_BUFFER,r)));const o=16*t*n;return QF(e,(()=>e.bufferData(e.PIXEL_PACK_BUFFER,o,e.STREAM_READ))),QF(e,(()=>e.readPixels(0,0,n,t,e.RGBA,e.FLOAT,0))),QF(e,(()=>e.bindBuffer(e.PIXEL_PACK_BUFFER,null))),r}(this.gl,t,n,this.textureConfig);return this.unbindTextureToFrameBuffer(),a}createAndWaitForFence(){const e=this.createFence(this.gl);return this.pollFence(e)}createFence(e){let t,n;if(Vo().getBool("WEBGL_FENCE_API_ENABLED")){const a=e,r=a.fenceSync(a.SYNC_GPU_COMMANDS_COMPLETE,0);e.flush(),n=()=>{const e=a.clientWaitSync(r,0,0);return e===a.ALREADY_SIGNALED||e===a.CONDITION_SATISFIED},t=r}else Vo().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0?(t=this.beginQuery(),this.endQuery(),n=()=>this.isQueryAvailable(t,Vo().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))):n=()=>!0;return{query:t,isFencePassed:n}}downloadMatrixFromPackedTexture(e,t,n){return this.downloadMatrixDriver(e,(()=>function(e,t,n){const a=new Float32Array(t*n*4);return QF(e,(()=>e.readPixels(0,0,n,t,e.RGBA,e.FLOAT,a))),a}(this.gl,t,n)))}createProgram(e){this.throwIfDisposed();const t=this.gl;null==this.vertexShader&&(this.vertexShader=$O(t));const n=function(e){return iO(e,(()=>e.createProgram()),"Unable to create WebGLProgram.")}(t);QF(t,(()=>t.attachShader(n,this.vertexShader))),QF(t,(()=>t.attachShader(n,e))),function(e,t){if(QF(e,(()=>e.linkProgram(t))),!Vo().get("ENGINE_COMPILE_ONLY")&&!1===e.getProgramParameter(t,e.LINK_STATUS))throw console.log(e.getProgramInfoLog(t)),new Error("Failed to link vertex and fragment shaders.")}(t,n);const a=Object.assign(n,{vao:this.createVertexArray()});return this.debug&&tO(t,a),a}buildVao(e){this.setProgram(e),this.bindVertexArray(e.vao);const t=this.gl;QF(t,(()=>t.bindBuffer(t.ELEMENT_ARRAY_BUFFER,this.indexBuffer))),function(e,t,n){QF(e,(()=>e.bindBuffer(e.ARRAY_BUFFER,n))),nO(e,t,"clipSpacePos",n,3,20,0)&&nO(e,t,"uv",n,2,20,12)}(t,e,this.vertexBuffer)}deleteProgram(e){this.throwIfDisposed(),e===this.program&&(this.program=null),null!=e&&(QF(this.gl,(()=>this.gl.deleteProgram(e))),this.deleteVertexArray(e.vao))}setProgram(e){this.throwIfDisposed(),this.program=e,null!=this.program&&this.debug&&tO(this.gl,this.program),QF(this.gl,(()=>this.gl.useProgram(e)))}getUniformLocation(e,t){let n=!(arguments.length>2&&void 0!==arguments[2])||arguments[2];return this.throwIfDisposed(),n?function(e,t,n){return iO(e,(()=>e.getUniformLocation(t,n)),'uniform "'+n+'" not present in program.')}(this.gl,e,t):function(e,t,n){return e.getUniformLocation(t,n)}(this.gl,e,t)}getAttributeLocation(e,t){return this.throwIfDisposed(),QF(this.gl,(()=>this.gl.getAttribLocation(e,t)))}getUniformLocationNoThrow(e,t){return this.throwIfDisposed(),this.gl.getUniformLocation(e,t)}setInputMatrixTexture(e,t,n){this.throwIfDisposed(),this.throwIfNoProgram(),aO(this.gl,e,t,n)}setOutputMatrixTexture(e,t,n){this.setOutputMatrixTextureDriver(e,n,t)}setOutputPackedMatrixTexture(e,t,n){this.throwIfDisposed();const[a,r]=XF(t,n);this.setOutputMatrixTextureDriver(e,a,r)}setOutputMatrixWriteRegion(e,t,n,a){this.setOutputMatrixWriteRegionDriver(n,e,a,t)}setOutputPackedMatrixWriteRegion(e,t,n,a){throw new Error("setOutputPackedMatrixWriteRegion not implemented.")}debugValidate(){null!=this.program&&tO(this.gl,this.program),sO(this.gl)}executeProgram(){this.throwIfDisposed(),this.throwIfNoProgram();const e=this.gl;if(this.debug){const e=this.getVertexArray();console.assert(e===this.program.vao,"VAO changed between setProgram and executeProgram!"),this.debugValidate()}QF(e,(()=>e.drawElements(e.TRIANGLES,6,e.UNSIGNED_SHORT,0)))}blockUntilAllProgramsCompleted(){this.throwIfDisposed(),QF(this.gl,(()=>this.gl.finish()))}getQueryTimerExtension(){return null==this.disjointQueryTimerExtension&&(this.disjointQueryTimerExtension=ZF(this.gl,2===Vo().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")?"EXT_disjoint_timer_query_webgl2":"EXT_disjoint_timer_query")),this.disjointQueryTimerExtension}getQueryTimerExtensionWebGL2(){return this.getQueryTimerExtension()}getQueryTimerExtensionWebGL1(){return this.getQueryTimerExtension()}beginQuery(){if(2===Vo().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")){const e=this.gl,t=this.getQueryTimerExtensionWebGL2(),n=e.createQuery();return e.beginQuery(t.TIME_ELAPSED_EXT,n),n}const e=this.getQueryTimerExtensionWebGL1(),t=e.createQueryEXT();return e.beginQueryEXT(e.TIME_ELAPSED_EXT,t),t}endQuery(){if(2===Vo().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")){const e=this.gl,t=this.getQueryTimerExtensionWebGL2();return void e.endQuery(t.TIME_ELAPSED_EXT)}const e=this.getQueryTimerExtensionWebGL1();e.endQueryEXT(e.TIME_ELAPSED_EXT)}async waitForQueryAndGetTime(e){return await mo((()=>this.disposed||this.isQueryAvailable(e,Vo().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")))),this.getQueryTime(e,Vo().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))}getQueryTime(e,t){if(0===t)return null;if(2===t){const t=this.gl;return t.getQueryParameter(e,t.QUERY_RESULT)/1e6}{const t=this.getQueryTimerExtensionWebGL1();return t.getQueryObjectEXT(e,t.QUERY_RESULT_EXT)/1e6}}isQueryAvailable(e,t){if(0===t)return!0;if(2===t){const t=this.gl,n=this.getQueryTimerExtensionWebGL2(),a=t.getQueryParameter(e,t.QUERY_RESULT_AVAILABLE);return null==this.disjoint&&(this.disjoint=this.gl.getParameter(n.GPU_DISJOINT_EXT)),a&&!this.disjoint}{const t=this.getQueryTimerExtensionWebGL1(),n=t.getQueryObjectEXT(e,t.QUERY_RESULT_AVAILABLE_EXT);return null==this.disjoint&&(this.disjoint=this.gl.getParameter(t.GPU_DISJOINT_EXT)),n&&!this.disjoint}}pollFence(e){return new Promise((t=>{this.addItemToPoll((()=>e.isFencePassed()),(()=>t()))}))}pollItems(){const e=function(e){let t=0;for(;t<e.length;++t){if(!e[t]())break}return t-1}(this.itemsToPoll.map((e=>e.isDoneFn)));for(let t=0;t<=e;++t){const{resolveFn:e}=this.itemsToPoll[t];e()}this.itemsToPoll=this.itemsToPoll.slice(e+1)}addItemToPoll(e,t){if(this.itemsToPoll.push({isDoneFn:e,resolveFn:t}),this.itemsToPoll.length>1)return;let n;"setTimeoutCustom"in Vo().platform&&(n=Vo().platform.setTimeoutCustom.bind(Vo().platform)),mo((()=>(this.pollItems(),0===this.itemsToPoll.length)),(()=>0),null,n)}bindTextureToFrameBuffer(e){this.throwIfDisposed(),rO(this.gl,e,this.framebuffer),this.debug&&sO(this.gl)}unbindTextureToFrameBuffer(){null!=this.outputTexture?(rO(this.gl,this.outputTexture,this.framebuffer),this.debug&&sO(this.gl)):oO(this.gl,this.framebuffer)}downloadMatrixDriver(e,t){this.bindTextureToFrameBuffer(e);const n=t();return this.unbindTextureToFrameBuffer(),n}setOutputMatrixTextureDriver(e,t,n){this.throwIfDisposed();const a=this.gl;rO(a,e,this.framebuffer),this.debug&&sO(a),this.outputTexture=e,QF(a,(()=>a.viewport(0,0,t,n))),QF(a,(()=>a.scissor(0,0,t,n)))}setOutputMatrixWriteRegionDriver(e,t,n,a){this.throwIfDisposed(),QF(this.gl,(()=>this.gl.scissor(e,t,n,a)))}throwIfDisposed(){if(this.disposed)throw new Error("Attempted to use disposed GPGPUContext.")}throwIfNoProgram(){if(null==this.program)throw new Error("No GPU program is currently set.")}}const{addImpl:uD,bincountImpl:dD,bincountReduceImpl:hD,bitwiseAndImpl:pD,castImpl:fD,ceilImpl:mD,concatImpl:gD,equalImpl:bD,expImpl:yD,expm1Impl:xD,floorImpl:vD,gatherNdImpl:wD,gatherV2Impl:kD,greaterImpl:ID,greaterEqualImpl:SD,lessImpl:ND,lessEqualImpl:CD,linSpaceImpl:TD,logImpl:ED,maxImpl:RD,maximumImpl:_D,minimumImpl:AD,multiplyImpl:FD,negImpl:OD,notEqualImpl:DD,prodImpl:MD,raggedGatherImpl:LD,raggedRangeImpl:PD,raggedTensorToTensorImpl:zD,rangeImpl:BD,rsqrtImpl:WD,scatterImpl:VD,sigmoidImpl:UD,simpleAbsImpl:GD,sliceImpl:HD,sparseFillEmptyRowsImpl:jD,sparseReshapeImpl:KD,sparseSegmentReductionImpl:qD,sqrtImpl:XD,staticRegexReplaceImpl:YD,stridedSliceImpl:QD,stringNGramsImpl:JD,stringSplitImpl:ZD,stringToHashBucketFastImpl:$D,subImpl:eM,tileImpl:tM,topKImpl:nM,transposeImpl:aM,uniqueImpl:rM}=r;function oM(e,t){return["x","y","z","w","u","v"].slice(0,t).map((t=>"".concat(e,".").concat(t)))}function sM(e,t){return 1===t?[e]:oM(e,t)}class iM{constructor(e){if(this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outputShape=e,this.rank=e.length,this.enableShapeUniforms=jO(this.outputShape.length),0===this.rank)this.userCode="\n        void main() {\n          setOutput(vec4(getA(), 0., 0., 0.));\n        }\n      ";else{const e=sM("rc",this.rank),t=zO(this.rank),n=this.getOutOfBoundsCondition(e),a=this.getSetup(e),r=this.getOutput(e);this.userCode="\n        void main() {\n          ".concat(t," rc = getOutputCoords();\n\n          if(").concat(n,") {\n            setOutput(vec4(0));\n          } else {\n            ").concat(a,"\n\n            setOutput(vec4(").concat(r,"));\n          }\n        }\n      ")}}getSourceCoordsArr(e){const t=[];for(let n=0;n<=1;n++)for(let a=0;a<=1;a++){let r="".concat(0===n?"r":"rp1",", ").concat(0===a?"c":"cp1");for(let t=2;t<this.rank;t++)r="".concat(e[e.length-1-t],",")+r;t.push(r)}return t}getOutOfBoundsCondition(e){if(1===this.rank)return"rc > ".concat(this.enableShapeUniforms?"outShape":this.outputShape[0]);let t="";for(let n=this.rank-2;n<this.rank;n++)t+="".concat(e[n]," >= ").concat(this.enableShapeUniforms?"outShape[".concat(n,"]"):this.outputShape[n]),n<this.rank-1&&(t+="||");return t}getSetup(e){if(1===this.rank)return"";const t=e.slice(-2),n=this.enableShapeUniforms?"outShape[".concat(this.rank," - 1]"):this.outputShape[this.rank-1],a=this.enableShapeUniforms?"outShape[".concat(this.rank," - 2]"):this.outputShape[this.rank-2];return"\n      int r = ".concat(t[0],";\n      int c = ").concat(t[1],";\n      int rp1 = r + 1;\n      int cp1 = c + 1;\n\n      bool cEdge = cp1 >= ").concat(n,";\n      bool rEdge = rp1 >= ").concat(a,";\n    ")}getOutput(e){const t=this.getSourceCoordsArr(e);if(1===this.rank){const e=this.enableShapeUniforms?"outShape":this.outputShape[0];return"getA(rc), (rc + 1 >= ".concat(e," ? 0. : getA(rc + 1)), 0, 0")}return"getA(".concat(t[0],"),\n            cEdge ? 0. : getA(").concat(t[1],"),\n            rEdge ? 0. : getA(").concat(t[2],"),\n            rEdge || cEdge ? 0. : getA(").concat(t[3],")")}}class cM{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec3"}],this.outputShape=e,this.enableShapeUniforms=jO(this.outputShape.length);let n="";for(let a=0;a<4;a++){let e="thisRC = rc;";a%2===1&&(e+="thisRC.z += 1;"),a>1&&(e+="thisRC.y += 1;"),n+="\n        ".concat(e,"\n        ").concat(a>0?"if(thisRC.y < rows && thisRC.z < cols){":"","\n          int flatIndex = getFlatIndex(thisRC);\n\n          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flatIndex);\n          vec2 inputRCInnerDims = vec2(float(inputRC.y),float(inputRC.z));\n\n          result[").concat(a,"] =\n            getChannel(getA(inputRC.x, inputRC.y, inputRC.z), inputRCInnerDims);\n        ").concat(a>0?"}":"","\n      ")}this.userCode="\n      ".concat(function(e,t){const n=t?NO(["r","c","d"],"inputShape"):IO(["r","c","d"],e);return"\n    ivec3 inputCoordsFromReshapedOutCoords(int index) {\n      ".concat(n,"\n      return ivec3(r, c, d);\n    }\n  ")}(t,this.enableShapeUniforms),"\n      ").concat(this.enableShapeUniforms?"\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;\n  }\n":CO(e),"\n\n      void main() {\n        ivec3 rc = getOutputCoords();\n\n        vec4 result = vec4(0.);\n\n        ivec3 thisRC;\n        int rows = ").concat(this.enableShapeUniforms?"outShape[1]":e[1],";\n        int cols = ").concat(this.enableShapeUniforms?"outShape[2]":e[2],";\n\n        ").concat(n,"\n\n        setOutput(result);\n      }\n    ")}}class lM{constructor(e){this.gpgpu=e,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0,this.freeTextures={},this.usedTextures={},this.logEnabled=!1}acquireTexture(e,t,n){const a=dM(t,n),r=hM(e,a,n);r in this.freeTextures||(this.freeTextures[r]=[]),r in this.usedTextures||(this.usedTextures[r]=[]);const o=uM(e,a,this.gpgpu.gl,this.gpgpu.textureConfig,n);if(this.freeTextures[r].length>0){this.numFreeTextures--,this.numUsedTextures++,this._numBytesFree-=o,this.log();const e=this.freeTextures[r].pop();return this.usedTextures[r].push(e),e}let s;return a===jF.PACKED_2X2_FLOAT32?s=this.gpgpu.createPackedMatrixTexture(e[0],e[1]):a===jF.PACKED_2X2_FLOAT16?s=this.gpgpu.createFloat16PackedMatrixTexture(e[0],e[1]):a===jF.UNPACKED_FLOAT32?s=this.gpgpu.createFloat32MatrixTexture(e[0],e[1]):a===jF.UNPACKED_FLOAT16?s=this.gpgpu.createFloat16MatrixTexture(e[0],e[1]):a===jF.PACKED_4X1_UNSIGNED_BYTE&&(s=this.gpgpu.createUnsignedBytesMatrixTexture(e[0],e[1])),this.usedTextures[r].push(s),this.numUsedTextures++,this._numBytesAllocated+=o,this.log(),s}releaseTexture(e,t,n,a){if(null==this.freeTextures)return;const r=dM(n,a),o=hM(t,r,a);o in this.freeTextures||(this.freeTextures[o]=[]);const s=uM(t,r,this.gpgpu.gl,this.gpgpu.textureConfig,a),i=Vo().getNumber("WEBGL_DELETE_TEXTURE_THRESHOLD");-1!==i&&this._numBytesAllocated>i?(this.gpgpu.deleteMatrixTexture(e.texture),this._numBytesAllocated-=s):(this.freeTextures[o].push(e),this.numFreeTextures++,this._numBytesFree+=s),this.numUsedTextures--;const c=this.usedTextures[o],l=c&&c.indexOf(e);if(null==l||l<0)throw new Error("Cannot release a texture that was never provided by this texture manager");c[l]=c[c.length-1],c.pop(),this.log()}log(){if(!this.logEnabled)return;const e=this.numFreeTextures+this.numUsedTextures;console.log("Free/Used","".concat(this.numFreeTextures," / ").concat(this.numUsedTextures),"(".concat(e,")"));const t=this._numBytesFree/this._numBytesAllocated;console.log("Bytes allocated: ".concat(this._numBytesAllocated)),console.log("Bytes unused: ".concat(this._numBytesFree," (").concat(Math.round(100*t),"%)"))}get numBytesAllocated(){return this._numBytesAllocated}get numBytesFree(){return this._numBytesFree}getNumUsedTextures(){return this.numUsedTextures}getNumFreeTextures(){return this.numFreeTextures}dispose(){if(null!=this.freeTextures){for(const e in this.freeTextures)this.freeTextures[e].forEach((e=>{this.gpgpu.deleteMatrixTexture(e.texture)}));for(const e in this.usedTextures)this.usedTextures[e].forEach((e=>{this.gpgpu.deleteMatrixTexture(e.texture)}));this.freeTextures=null,this.usedTextures=null,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0}}}function uM(e,t,n,a,r){const o=function(e,t){switch(e){case jF.PACKED_2X2_FLOAT32:return sD(t);case jF.PACKED_2X2_FLOAT16:return iD(t);case jF.UNPACKED_FLOAT32:return aD(t);case jF.UNPACKED_FLOAT16:return rD(t);case jF.PACKED_4X1_UNSIGNED_BYTE:return oD(t);default:throw new Error("Unknown physical texture type ".concat(e))}}(t,a);let s;if(r){const[t,n]=XF(e[0],e[1]);s=t*n}else{const[t,n]=KF(e[0],e[1]);s=t*n}const i=function(e,t){const n=e;if(t===n.R32F)return 4;if(t===n.R16F)return 2;if(t===n.RGBA32F)return 16;if(t===e.RGBA)return 16;if(t===n.RGBA16F)return 8;if(t===n.RGBA8)return 4;throw new Error("Unknown internal format ".concat(t))}(n,o);return s*i}function dM(e,t){if(e===HF.UPLOAD)return jF.PACKED_2X2_FLOAT32;if(e===HF.RENDER||null==e)return function(e){return Vo().getBool("WEBGL_RENDER_FLOAT32_ENABLED")?e?jF.PACKED_2X2_FLOAT32:jF.UNPACKED_FLOAT32:e?jF.PACKED_2X2_FLOAT16:jF.UNPACKED_FLOAT16}(t);if(e===HF.DOWNLOAD||e===HF.PIXELS)return jF.PACKED_4X1_UNSIGNED_BYTE;throw new Error("Unknown logical texture type ".concat(e))}function hM(e,t,n){return"".concat(e[0],"_").concat(e[1],"_").concat(t,"_").concat(n)}class pM{constructor(e,t){this.variableNames=["A"],this.outputShape=e,this.enableShapeUniforms=jO(this.outputShape.length),this.userCode="\n      float unaryOperation(float x) {\n        ".concat(t,"\n      }\n\n      void main() {\n        float x = getAAtOutCoords();\n        float y = unaryOperation(x);\n\n        setOutput(y);\n      }\n    ")}}const fM="if (isnan(x)) return x;",mM="return x;",gM="return abs(x);";const bM="return (x >= 0.0) ? x : (exp(x) - 1.0);",yM=fM+"\n  return (x < 0.0) ? 0.0 : x;\n",xM=fM+"\n  return (x < 0.0) ? 0.0 : min(6.0, x);\n",vM="return x;",wM="return 1.0 / (1.0 + exp(-1.0 * x));",kM="return x;",IM="\n  vec4 result;\n\n  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);\n  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);\n  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);\n  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);\n\n  return result;\n",SM="\n  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n",NM="\n  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n",CM="return 1.0 / (1.0 + exp(-1.0 * x));";class TM{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.enableShapeUniforms=jO(this.outputShape.length),this.userCode="\n      vec4 unaryOperation(vec4 x) {\n        ".concat(t,"\n      }\n\n      void main() {\n        vec4 x = getAAtOutCoords();\n        vec4 y = unaryOperation(x);\n\n        setOutput(y);\n      }\n    ")}}class EM{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outputShape=e,this.enableShapeUniforms=jO(this.outputShape.length);const t=e.length,n=sM("rc",t),a=zO(t),r=function(e,t){if(1===e)return"rc";let n="";for(let a=0;a<e;a++)n+=t[a],a<e-1&&(n+=",");return n}(t,n),o=n.slice(-2),s=t<=1?"rc":"vec2(".concat(o.join(","),")");this.userCode="\n      void main() {\n        ".concat(a," rc = getOutputCoords();\n        vec4 packedInput = getA(").concat(r,");\n\n        setOutput(getChannel(packedInput, ").concat(s,"));\n      }\n    ")}}const RM=Jg,_M={};const AM=Vo().getNumber("CPU_HANDOFF_SIZE_THRESHOLD");class FM extends eo{nextDataId(){return FM.nextDataId++}constructor(e){if(super(),this.pendingRead=new WeakMap,this.pendingDisposal=new WeakSet,this.dataRefCount=new WeakMap,this.numBytesInGPU=0,this.uploadWaitMs=0,this.downloadWaitMs=0,this.lastGlFlushTime=0,this.warnedAboutMemory=!1,this.pendingDeletes=0,this.disposed=!1,!Vo().getBool("HAS_WEBGL"))throw new Error("WebGL is not supported on this device");let t;if(null!=e){if(e instanceof lD)t=e;else{const n=UF(Vo().getNumber("WEBGL_VERSION"),e);t=new lD(n)}this.binaryCache={},this.gpgpuCreatedLocally=!1}else{const e=UF(Vo().getNumber("WEBGL_VERSION"));t=new lD(e),this.binaryCache=((n=Vo().getNumber("WEBGL_VERSION"))in _M||(_M[n]={}),_M[n]),this.gpgpuCreatedLocally=!0}var n;this.gpgpu=t,this.canvas=this.gpgpu.gl.canvas,this.textureManager=new lM(this.gpgpu),this.numMBBeforeWarning=null==Vo().global.screen?1024:Vo().global.screen.height*Vo().global.screen.width*window.devicePixelRatio*600/1024/1024,this.texData=new $r(this,Du())}numDataIds(){return this.texData.numDataIds()-this.pendingDeletes}writeTexture(e,t,n,a,r,o){const s=this.makeTensorInfo(t,n),i=this.texData.get(s.dataId);i.isPacked=!1,i.texture={texture:e,texShape:[a,r]},i.texShape=[a,r];const c=dO(t),l=new JO(c,!1,o),u=this.runWebGLProgram(l,[s],n,[[a,r]]);return u.shape=t,i.texture=null,this.disposeIntermediateTensorInfo(s),u.dataId}write(e,t,n){if((Vo().getBool("WEBGL_CHECK_NUMERICAL_PROBLEMS")||Vo().getBool("DEBUG"))&&this.checkNumericalProblems(e),"complex64"===n&&null!=e)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");const a={id:this.nextDataId()};return this.texData.set(a,{shape:t,dtype:n,values:e,usage:HF.UPLOAD,refCount:1}),a}refCount(e){if(this.texData.has(e)){return this.texData.get(e).refCount}return 0}incRef(e){this.texData.get(e).refCount++}decRef(e){if(this.texData.has(e)){this.texData.get(e).refCount--}}move(e,t,n,a,r){if(Vo().getBool("DEBUG")&&this.checkNumericalProblems(t),"complex64"===a)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");this.texData.set(e,{shape:n,dtype:a,values:t,usage:HF.UPLOAD,refCount:r})}disposeIntermediateTensorInfo(e){this.disposeData(e.dataId)}readSync(e){const t=this.texData.get(e),{values:n,dtype:a,complexTensorInfos:r,slice:o,shape:s,isPacked:i}=t;if(null!=o){let t;t=i?new TM(s,vM):new pM(s,vM);const n=this.runWebGLProgram(t,[{dataId:e,shape:s,dtype:a}],a),r=this.readSync(n.dataId);return this.disposeIntermediateTensorInfo(n),r}if(null!=n)return this.convertAndCacheOnCPU(e);if("string"===a)return n;const c=null!=this.activeTimers;let l,u;if(c&&(l=Al()),"complex64"===a){u=mg(this.readSync(r.real.dataId),this.readSync(r.imag.dataId))}else u=this.getValuesFromTexture(e);return c&&(this.downloadWaitMs+=Al()-l),this.convertAndCacheOnCPU(e,u)}async read(e){if(this.pendingRead.has(e)){const t=this.pendingRead.get(e);return new Promise((e=>t.push(e)))}const t=this.texData.get(e),{values:n,shape:a,slice:r,dtype:o,complexTensorInfos:s,isPacked:i}=t;if(null!=r){let t;t=i?new TM(a,vM):new pM(a,vM);const n=this.runWebGLProgram(t,[{dataId:e,shape:a,dtype:o}],o),r=this.read(n.dataId);return this.disposeIntermediateTensorInfo(n),r}if(null!=n)return this.convertAndCacheOnCPU(e);if(Vo().getBool("DEBUG")&&!Vo().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")&&2===Vo().getNumber("WEBGL_VERSION"))throw new Error("tensor.data() with WEBGL_DOWNLOAD_FLOAT_ENABLED=false and WEBGL_VERSION=2 not yet supported.");let c,l,u=null;if("complex64"!==o&&Vo().get("WEBGL_BUFFER_SUPPORTED")){c=this.decode(e);const t=this.texData.get(c.dataId);u=this.gpgpu.createBufferFromTexture(t.texture.texture,...qF(a))}if(this.pendingRead.set(e,[]),"complex64"!==o&&await this.gpgpu.createAndWaitForFence(),"complex64"===o){const e=await Promise.all([this.read(s.real.dataId),this.read(s.imag.dataId)]);l=mg(e[0],e[1])}else if(null==u)l=this.getValuesFromTexture(e);else{const e=lo(a);l=this.gpgpu.downloadFloat32MatrixFromBuffer(u,e)}if(null!=c&&this.disposeIntermediateTensorInfo(c),null!=u){const e=this.gpgpu.gl;QF(e,(()=>e.deleteBuffer(u)))}const d=this.convertAndCacheOnCPU(e,l),h=this.pendingRead.get(e);return this.pendingRead.delete(e),h.forEach((e=>e(d))),this.pendingDisposal.has(e)&&(this.pendingDisposal.delete(e),this.disposeData(e)&&Du().removeDataId(e,this),this.pendingDeletes--),d}readToGPU(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const n=this.texData.get(e),{values:a,shape:r,slice:o,dtype:s,isPacked:i,texture:c}=n;if("complex64"===s)throw new Error("Does not support reading texture for complex64 dtype.");if(null!=o){let n;n=i?new TM(r,vM):new pM(r,vM);const a=this.runWebGLProgram(n,[{dataId:e,shape:r,dtype:s}],s),o=this.readToGPU(a,t);return this.disposeIntermediateTensorInfo(a),o}if(null==c)throw null!=a?new Error("Data is not on GPU but on CPU."):new Error("There is no data on GPU or CPU.");const l=this.decode(e,t.customTexShape),u=Du().makeTensorFromTensorInfo(l),d=this.texData.get(l.dataId);return Object.assign({tensorRef:u},d.texture)}bufferSync(e){const t=this.readSync(e.dataId);if("string"===e.dtype)try{const n=t.map((e=>Ol(e)));return Nd(e.shape,e.dtype,n)}catch(n){throw new Error("Failed to decode encoded string bytes into utf-8")}return Nd(e.shape,e.dtype,t)}checkNumericalProblems(e){if(null!=e)for(let t=0;t<e.length;t++){const n=e[t];if(!JF(n)){if(Vo().getBool("WEBGL_RENDER_FLOAT32_CAPABLE"))throw Error("The value ".concat(n," cannot be represented with your ")+"current settings. Consider enabling float32 rendering: 'tf.env().set('WEBGL_RENDER_FLOAT32_ENABLED', true);'");throw Error("The value ".concat(n," cannot be represented on this device."))}}}getValuesFromTexture(e){const{shape:t,dtype:n,isPacked:a}=this.texData.get(e),r=lo(t);if(Vo().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")){const n=this.decode(e),a=this.texData.get(n.dataId),o=this.gpgpu.downloadMatrixFromPackedTexture(a.texture.texture,...qF(t)).subarray(0,r);return this.disposeIntermediateTensorInfo(n),o}const o=Vo().getBool("WEBGL_PACK")&&!0===a,s=o?dO(t):t,i=o?new YO(s):new XO(s),c=this.runWebGLProgram(i,[{shape:s,dtype:n,dataId:e}],"float32"),l=this.texData.get(c.dataId),u=this.gpgpu.downloadByteEncodedFloatMatrixFromOutputTexture(l.texture.texture,l.texShape[0],l.texShape[1]).subarray(0,r);return this.disposeIntermediateTensorInfo(c),u}timerAvailable(){return Vo().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0}time(e){const t=this.activeTimers,n=[];let a=!1;null==this.programTimersStack?(this.programTimersStack=n,a=!0):this.activeTimers.push(n),this.activeTimers=n,e();const r=Ml(this.activeTimers.map((e=>e.query))).filter((e=>null!=e)),o=Ml(this.activeTimers.map((e=>e.name))).filter((e=>null!=e));this.activeTimers=t,a&&(this.programTimersStack=null);const s={uploadWaitMs:this.uploadWaitMs,downloadWaitMs:this.downloadWaitMs,kernelMs:null,wallMs:null};return(async()=>{if(Vo().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0){const e=await Promise.all(r);s.kernelMs=function(e){let t=0;for(let n=0;n<e.length;n++)t+=e[n];return t}(e),s.getExtraProfileInfo=()=>e.map(((e,t)=>({name:o[t],ms:e}))).map((e=>"".concat(e.name,": ").concat(e.ms))).join(", ")}else s.kernelMs={error:"WebGL query timers are not supported in this environment."};return this.uploadWaitMs=0,this.downloadWaitMs=0,s})()}memory(){return{unreliable:!1,numBytesInGPU:this.numBytesInGPU,numBytesInGPUAllocated:this.textureManager.numBytesAllocated,numBytesInGPUFree:this.textureManager.numBytesFree}}startTimer(){return Vo().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?this.gpgpu.beginQuery():{startMs:Al(),endMs:null}}endTimer(e){return Vo().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?(this.gpgpu.endQuery(),e):(e.endMs=Al(),e)}async getQueryTime(e){if(Vo().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0)return this.gpgpu.waitForQueryAndGetTime(e);const t=e;return t.endMs-t.startMs}disposeData(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];if(this.pendingDisposal.has(e))return!1;if(!this.texData.has(e))return!0;if(t?this.texData.get(e).refCount=0:this.texData.get(e).refCount--,!t&&this.texData.get(e).refCount>0)return!1;if(this.pendingRead.has(e))return this.pendingDisposal.add(e),this.pendingDeletes++,!1;this.releaseGPUData(e);const{complexTensorInfos:n}=this.texData.get(e);return null!=n&&(this.disposeData(n.real.dataId,t),this.disposeData(n.imag.dataId,t)),this.texData.delete(e),!0}releaseGPUData(e){const{texture:t,dtype:n,texShape:a,usage:r,isPacked:o,slice:s}=this.texData.get(e),i=s&&s.origDataId||e,c=this.dataRefCount.get(i);c>1?this.dataRefCount.set(i,c-1):(this.dataRefCount.delete(i),null!=t&&(this.numBytesInGPU-=this.computeBytes(a,n),this.textureManager.releaseTexture(t,a,r,o)));const l=this.texData.get(e);l.texture=null,l.texShape=null,l.isPacked=!1,l.slice=null}getTexture(e){return this.uploadToGPU(e),this.texData.get(e).texture.texture}getDataInfo(e){return this.texData.get(e)}shouldExecuteOnCPU(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:AM;return Vo().getBool("WEBGL_CPU_FORWARD")&&e.every((e=>null==this.texData.get(e.dataId).texture&&lo(e.shape)<t))}getGPGPUContext(){return this.gpgpu}where(e){al("tf.where() in webgl locks the UI thread. Call tf.whereAsync() instead");const t=e.dataSync();return RM(e.shape,t)}packedUnaryOp(e,t,n){const a=new TM(e.shape,t),r=this.compileAndRun(a,[e],n);return Du().makeTensorFromTensorInfo(r)}abs(e){if(this.shouldExecuteOnCPU([e])&&"complex64"!==e.dtype){const t=GD(this.texData.get(e.dataId).values);return this.makeOutput(e.shape,e.dtype,t)}if(Vo().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(e,gM,e.dtype);const t=new pM(e.shape,gM),n=this.compileAndRun(t,[e]);return Du().makeTensorFromTensorInfo(n)}makeTensorInfo(e,t,n){let a;if("string"===t&&null!=n&&n.length>0&&Io(n[0])){const r=n.map((e=>Fl(e)));a=this.write(r,e,t)}else a=this.write(n,e,t);return this.texData.get(a).usage=null,{dataId:a,shape:e,dtype:t}}makeOutput(e,t,n){return Du().makeTensorFromTensorInfo(this.makeTensorInfo(e,t,n),this)}unpackTensor(e){const t=new EM(e.shape);return this.runWebGLProgram(t,[e],e.dtype)}packTensor(e){const t=new iM(e.shape);return this.runWebGLProgram(t,[e],e.dtype,null,!0)}packedReshape(e,t){const n=[lO(e.shape),...uO(e.shape)],a={dtype:e.dtype,shape:n,dataId:e.dataId},r=[lO(t),...uO(t)],o=new cM(r,n),s=[n],i=this.runWebGLProgram(o,[a],e.dtype,s,!0);return{dataId:i.dataId,shape:t,dtype:i.dtype}}decode(e,t){const n=this.texData.get(e),{isPacked:a,shape:r,dtype:o}=n;if(null!=t){so(lo(r)<=t[0]*t[1]*4,(()=>"customTexShape is too small. Row * Column * 4 should be equal or larger than the size of the tensor data."))}const s=dO(r);let i;i=a?new qO(s):new KO(s);const c=[null!=t?t:qF(s)];return{dtype:o,shape:r,dataId:this.runWebGLProgram(i,[{shape:s,dtype:o,dataId:e}],o,c,!0,t).dataId}}runWebGLProgram(e,t,n,a){let r=arguments.length>4&&void 0!==arguments[4]&&arguments[4],o=arguments.length>5?arguments[5]:void 0;const s=this.makeTensorInfo(e.outputShape,n),i=this.texData.get(s.dataId);if(e.packedOutput&&(i.isPacked=!0),e.outPackingScheme===GF.DENSE){const t=null!=o?o:qF(e.outputShape);i.texShape=t.map((e=>2*e))}if(null!=e.outTexUsage&&(i.usage=e.outTexUsage),0===lo(s.shape))return i.values=xo(s.dtype,0),s;const c=[],l=t.map((t=>{if("complex64"===t.dtype)throw new Error("GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.");let n=this.texData.get(t.dataId);if(null==n.texture){if(!e.packedInputs&&lo(t.shape)<=Vo().getNumber("WEBGL_SIZE_UPLOAD_UNIFORM"))return{shape:t.shape,texData:null,isUniform:!0,uniformValues:n.values};e.packedInputs&&(n.isPacked=!0,n.shape=t.shape)}if(this.uploadToGPU(t.dataId),!!n.isPacked!==!!e.packedInputs)t=n.isPacked?this.unpackTensor(t):this.packTensor(t),c.push(t),n=this.texData.get(t.dataId);else if(n.isPacked&&!pO(n.shape,t.shape)){const e=t,a=t.shape;t.shape=n.shape,t=this.packedReshape(t,a),c.push(t),n=this.texData.get(t.dataId),e.shape=a}return{shape:t.shape,texData:n,isUniform:!1}}));this.uploadToGPU(s.dataId);const u={shape:s.shape,texData:i,isUniform:!1},d=function(e,t,n){let a="";t.concat(n).forEach((t=>{const r=null!=t.texData&&null!=t.texData.slice&&t.texData.slice.flatOffset>0;if(e.enableShapeUniforms&&!t.isUniform){const o=t.texData.texShape,{useSqueezeShape:s,uniformShape:i,keptDims:c}=BO(e.packedInputs,t.shape,o);let l="",u="",d="";if(1===i.length&&e.packedInputs){const e=[Math.ceil(o[0]/2),Math.ceil(o[1]/2)];l="".concat(e[0]>1,"_").concat(e[1]>1)}else if(2!==i.length||e.packedInputs){if(i.length>2&&!e.packedInputs){const e=Eo(i);d="".concat(e[0]===o[1],"_").concat(e[e.length-1]===o[1])}}else u="".concat(i[0]>1,"_").concat(i[1]>1);const h=t.shape.length,p=2===i.length&&uo(t.shape,o),f=1===lo(t.shape),m=Qd(t.shape,n.shape),g=!e.packedInputs&&h===n.shape.length&&uo(o,n.texData.texShape),b=e.packedInputs||i.length>2?"":"".concat(o[0]>1,"_").concat(o[1]>1);a+="".concat(h,"_").concat(g,"_").concat(s?c:"","_").concat(i.length,"_").concat(f,"_").concat(m,"_").concat(p,"_").concat(l,"_").concat(u,"_").concat(d,"_").concat(b,"_").concat(r)}else{const e=t.isUniform?"uniform":t.texData.texShape;a+="".concat(t.shape,"_").concat(e,"_").concat(r)}}));const r=e.userCode;let o=e.constructor.name;return o+="_"+a+"_"+r+"".concat(Vo().getNumber("WEBGL_VERSION")),o}(e,l,u),h=this.getAndSaveBinary(d,(()=>UO(this.gpgpu,e,l,u))),p=null!=this.activeTimers;let f;p&&(f=this.startTimer()),Vo().get("ENGINE_COMPILE_ONLY")||function(e,t,n,a,r){t.program.enableShapeUniforms||(HO(t.inShapeInfos,n),HO([t.outShapeInfo],[a]));const o=a.texData.texture,s=a.texData.texShape;a.texData.isPacked?e.setOutputPackedMatrixTexture(o.texture,s[0],s[1]):e.setOutputMatrixTexture(o.texture,s[0],s[1]),e.setProgram(t.webGLProgram),e.bindVertexArray(t.webGLProgram.vao),1===Vo().getNumber("WEBGL_VERSION")&&null!==t.infLoc&&e.gl.uniform1f(t.infLoc,1/0),null!==t.nanLoc&&e.gl.uniform1f(t.nanLoc,NaN);for(let c=0;c<n.length;++c){const a=n[c],{uniform:r,offset:o,shape:s,texShape:i}=t.variablesLocations[c];if(s){const{uniformShape:n}=BO(t.program.packedInputs,a.shape,a.texData.texShape);switch(n.length){case 1:e.gl.uniform1iv(s,new Int32Array(n));break;case 2:e.gl.uniform2iv(s,new Int32Array(n));break;case 3:e.gl.uniform3iv(s,new Int32Array(n));break;case 4:e.gl.uniform4iv(s,new Int32Array(n))}}if(i&&e.gl.uniform2i(i,a.texData.texShape[0],a.texData.texShape[1]),null!=r)if(a.isUniform)if(lo(a.shape)<2)e.gl.uniform1f(r,a.uniformValues[0]);else{let t=a.uniformValues;t instanceof Float32Array||(t=new Float32Array(t)),e.gl.uniform1fv(r,t)}else null!=a.texData.slice&&null!=o&&e.gl.uniform1i(o,a.texData.slice.flatOffset),e.setInputMatrixTexture(a.texData.texture.texture,r,c)}const i=t.outShapeLocation;if(i)switch(a.shape.length){case 1:e.gl.uniform1iv(i,new Int32Array(a.shape));break;case 2:e.gl.uniform2iv(i,new Int32Array(a.shape));break;case 3:e.gl.uniform3iv(i,new Int32Array(a.shape));break;case 4:e.gl.uniform4iv(i,new Int32Array(a.shape))}if(t.outShapeStridesLocation){const n=Eo(a.shape);switch(a.shape.length){case 2:e.gl.uniform1iv(t.outShapeStridesLocation,new Int32Array(n));break;case 3:e.gl.uniform2iv(t.outShapeStridesLocation,new Int32Array(n));break;case 4:e.gl.uniform3iv(t.outShapeStridesLocation,new Int32Array(n))}}if(t.outTexShapeLocation&&e.gl.uniform2i(t.outTexShapeLocation,a.texData.texShape[0],a.texData.texShape[1]),t.program.customUniforms&&r)for(let c=0;c<t.program.customUniforms.length;++c){const n=t.program.customUniforms[c],a=t.customUniformLocations[c],o=r[c];if("float"===n.type)e.gl.uniform1fv(a,o);else if("vec2"===n.type)e.gl.uniform2fv(a,o);else if("vec3"===n.type)e.gl.uniform3fv(a,o);else if("vec4"===n.type)e.gl.uniform4fv(a,o);else if("int"===n.type)e.gl.uniform1iv(a,o);else if("ivec2"===n.type)e.gl.uniform2iv(a,o);else if("ivec3"===n.type)e.gl.uniform3iv(a,o);else{if("ivec4"!==n.type)throw Error("uniform type ".concat(n.type," is not supported yet."));e.gl.uniform4iv(a,o)}}e.executeProgram()}(this.gpgpu,h,l,u,a),c.forEach((e=>this.disposeIntermediateTensorInfo(e))),p&&(f=this.endTimer(f),this.activeTimers.push({name:e.constructor.name,query:this.getQueryTime(f)}));const m=Vo().getNumber("WEBGL_FLUSH_THRESHOLD");if(m>0){const e=Al();e-this.lastGlFlushTime>m&&(this.gpgpu.gl.flush(),this.lastGlFlushTime=e)}if(!Vo().getBool("WEBGL_LAZILY_UNPACK")&&i.isPacked&&!1===r){const e=this.unpackTensor(s);return this.disposeIntermediateTensorInfo(s),e}return s}compileAndRun(e,t,n,a){let r=arguments.length>4&&void 0!==arguments[4]&&arguments[4];n=n||t[0].dtype;return this.runWebGLProgram(e,t,n,a,r)}getAndSaveBinary(e,t){return e in this.binaryCache||(this.binaryCache[e]=t()),this.binaryCache[e]}getTextureManager(){return this.textureManager}dispose(){if(!this.disposed){if(!Vo().getBool("IS_TEST")){Object.keys(this.binaryCache).forEach((e=>{this.gpgpu.deleteProgram(this.binaryCache[e].webGLProgram),delete this.binaryCache[e]}))}this.textureManager.dispose(),null!=this.canvas&&"undefined"!==typeof HTMLCanvasElement&&this.canvas instanceof HTMLCanvasElement?this.canvas.remove():this.canvas=null,this.gpgpuCreatedLocally&&(this.gpgpu.program=null,this.gpgpu.dispose()),this.disposed=!0}}floatPrecision(){return null==this.floatPrecisionValue&&(this.floatPrecisionValue=Lu((()=>{if(!Vo().get("WEBGL_RENDER_FLOAT32_ENABLED")){const e=Vo().getBool("DEBUG");Vo().set("DEBUG",!1);const t=this.abs(Ld(1e-8)).dataSync()[0];if(Vo().set("DEBUG",e),t>0)return 32}return 16}))),this.floatPrecisionValue}epsilon(){return 32===this.floatPrecision()?1e-7:1e-4}uploadToGPU(e){const t=this.texData.get(e),{shape:n,dtype:a,values:r,texture:o,usage:s,isPacked:i}=t;if(null!=o)return;const c=null!=this.activeTimers;let l;c&&(l=Al());let u=t.texShape;if(null==u&&(u=function(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1],n=Vo().getNumber("WEBGL_MAX_TEXTURE_SIZE"),a=Vo().getNumber("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE");if(a===1/0&&Vo().getBool("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE")&&(a=n/2),t&&(n*=2,a*=2,e=e.map(((t,n)=>n>=e.length-2?ro(e[n]):e[n])),1===e.length&&(e=[2,e[0]])),2!==e.length){const t=yo(e);e=t.newShape}let r=lo(e),o=null;e.length<=1&&r<=n?o=[1,r]:2===e.length&&e[0]<=n&&e[1]<=n?o=e:3===e.length&&e[0]*e[1]<=n&&e[2]<=n?o=[e[0]*e[1],e[2]]:3===e.length&&e[0]<=n&&e[1]*e[2]<=n?o=[e[0],e[1]*e[2]]:4===e.length&&e[0]*e[1]*e[2]<=n&&e[3]<=n?o=[e[0]*e[1]*e[2],e[3]]:4===e.length&&e[0]<=n&&e[1]*e[2]*e[3]<=n&&(o=[e[0],e[1]*e[2]*e[3]]);const s=null!=o&&Math.max(...o)>a&&Math.min(...o)<=(t?2:1)&&Math.min(...o)>0;if(null==o||s)if(t){const t=lO(e);let n=2,a=2;e.length&&([n,a]=uO(e)),r=t*(n/2)*(a/2),o=po(r).map((e=>2*e))}else o=po(r);return o}(n,i),t.texShape=u),null!=r){const e=dO(n);let o,s=u[1],d=u[0];const h=r instanceof Uint8Array||r instanceof Uint8ClampedArray;!i&&h||([s,d]=XF(u[0],u[1])),o=i?new ZO(e,h):new JO(e,h);const p=h?[d,s]:u,f=this.makeTensorInfo(p,a),m=this.texData.get(f.dataId);m.usage=h?HF.PIXELS:HF.UPLOAD,m.texShape=p,this.gpgpu.uploadDenseMatrixToTexture(this.getTexture(f.dataId),s,d,r);const g=[[d,s]],b=!0,y=this.runWebGLProgram(o,[f],a,g,b),x=this.texData.get(y.dataId);t.texShape=x.texShape,t.isPacked=x.isPacked,t.usage=x.usage,Vo().get("ENGINE_COMPILE_ONLY")?this.disposeData(y.dataId):(t.texture=x.texture,t.values=null,this.texData.delete(y.dataId)),this.disposeIntermediateTensorInfo(f),c&&(this.uploadWaitMs+=Al()-l)}else{const e=this.acquireTexture(u,s,a,i);t.texture=e}}convertAndCacheOnCPU(e,t){const n=this.texData.get(e),{dtype:a}=n;return null!=t&&(n.values=function(e,t){if("float32"===t||"complex64"===t)return e;if("int32"===t||"bool"===t){const n="int32"===t?new Int32Array(e.length):new Uint8Array(e.length);for(let t=0;t<n.length;++t)n[t]=Math.round(e[t]);return n}throw new Error("Unknown dtype ".concat(t))}(t,a)),n.values}acquireTexture(e,t,n,a){if(this.numBytesInGPU+=this.computeBytes(e,n),!this.warnedAboutMemory&&this.numBytesInGPU>1024*this.numMBBeforeWarning*1024){const e=(this.numBytesInGPU/1024/1024).toFixed(2);this.warnedAboutMemory=!0,console.warn("High memory usage in GPU: ".concat(e," MB, ")+"most likely due to a memory leak")}return this.textureManager.acquireTexture(e,t,a)}computeBytes(e,t){return e[0]*e[1]*ko(t)}checkCompileCompletion(){for(const[,e]of Object.entries(this.binaryCache))this.checkCompletion_(e)}async checkCompileCompletionAsync(){const e=[];if(this.gpgpu.parallelCompilationExtension){for(const[,t]of Object.entries(this.binaryCache))e.push(this.checkCompletionAsync_(t));return Promise.all(e)}for(const[,t]of Object.entries(this.binaryCache)){const n=new Promise((e=>{try{this.checkCompletion_(t),e(!0)}catch(n){throw n}}));e.push(n)}return Promise.all(e)}async checkCompletionAsync_(e){return this.gpgpu.gl.getProgramParameter(e.webGLProgram,this.gpgpu.parallelCompilationExtension.COMPLETION_STATUS_KHR)?this.checkCompletion_(e):(await Vm(),this.checkCompletionAsync_(e))}checkCompletion_(e){if(!1===this.gpgpu.gl.getProgramParameter(e.webGLProgram,this.gpgpu.gl.LINK_STATUS)){if(console.log(this.gpgpu.gl.getProgramInfoLog(e.webGLProgram)),!1===this.gpgpu.gl.getShaderParameter(e.fragmentShader,this.gpgpu.gl.COMPILE_STATUS))throw eO(e.source,this.gpgpu.gl.getShaderInfoLog(e.fragmentShader)),new Error("Failed to compile fragment shader.");throw new Error("Failed to link vertex and fragment shaders.")}return!0}getUniformLocations(){for(const e of Object.values(this.binaryCache)){this.gpgpu.buildVao(e.webGLProgram);const{variablesLocations:t,customUniformLocations:n,infLoc:a,nanLoc:r,outShapeLocation:o,outShapeStridesLocation:s,outTexShapeLocation:i}=GO(this.gpgpu,e.program,e.webGLProgram);e.variablesLocations=t,e.customUniformLocations=n,e.infLoc=a,e.nanLoc=r,e.outShapeLocation=o,e.outShapeStridesLocation=s,e.outTexShapeLocation=i}}createTensorFromGPUData(e,t,n){e.channels=e.channels||"RGBA";const{texture:a,height:r,width:o,channels:s}=e,i=Du().backend;if(!i.gpgpu.gl.isTexture(a))throw new Error("The texture is invalid. Also, please make sure the texture and the TFJS WebGL backend are using the same canvas. If you want to use your own custom canvas, you have to create and use the custom TFJS WebGL backend created from the canvas through 'new tf.MathBackendWebGL(customCanvas)'.");const c=i.writeTexture(a,t,n,r,o,s);return Du().makeTensorFromDataId(c,t,n,i)}}FM.nextDataId=0;ku()&&Wu("webgl",(()=>new FM),2);const OM="\n  if (isnan(a)) return a;\n  if (isnan(b)) return b;\n";class DM{constructor(e,t,n){this.variableNames=["A","B"],this.outputShape=Zd(t,n),this.enableShapeUniforms=jO(this.outputShape.length),this.userCode="\n      float binaryOperation(float a, float b) {\n        ".concat(e,"\n      }\n\n      void main() {\n        float a = getAAtOutCoords();\n        float b = getBAtOutCoords();\n        setOutput(binaryOperation(a, b));\n      }\n    ")}}const MM="\n  result.r = isNaN.r ? NAN : result.r;\n  result.g = isNaN.g ? NAN : result.g;\n  result.b = isNaN.b ? NAN : result.b;\n  result.a = isNaN.a ? NAN : result.a;\n";class LM{constructor(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]&&arguments[3];this.variableNames=["A","B"],this.supportsBroadcasting=!0,this.packedInputs=!0,this.packedOutput=!0,this.outputShape=Zd(t,n);const r=this.outputShape.length;this.enableShapeUniforms=jO(r);let o="";if(a)if(0===r||1===lo(this.outputShape))o="\n          result.y = 0.;\n          result.z = 0.;\n          result.w = 0.;\n        ";else{const e=zO(r);if(o="\n          ".concat(e," coords = getOutputCoords();\n        "),1===r)this.enableShapeUniforms?o+="\n            result.y = (coords + 1) >= outShape ? 0. : result.y;\n            result.z = 0.;\n            result.w = 0.;\n          ":o+="\n            result.y = (coords + 1) >= ".concat(this.outputShape[0]," ? 0. : result.y;\n            result.z = 0.;\n            result.w = 0.;\n          ");else{const e=sM("coords",r);this.enableShapeUniforms?o+="\n            bool nextRowOutOfBounds =\n              (".concat(e[r-2]," + 1) >= outShape[").concat(r," - 2];\n            bool nextColOutOfBounds =\n              (").concat(e[r-1]," + 1) >= outShape[").concat(r," - 1];\n            result.y = nextColOutOfBounds ? 0. : result.y;\n            result.z = nextRowOutOfBounds ? 0. : result.z;\n            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;\n          "):o+="\n            bool nextRowOutOfBounds =\n              (".concat(e[r-2]," + 1) >= ").concat(this.outputShape[r-2],";\n            bool nextColOutOfBounds =\n              (").concat(e[r-1]," + 1) >= ").concat(this.outputShape[r-1],";\n            result.y = nextColOutOfBounds ? 0. : result.y;\n            result.z = nextRowOutOfBounds ? 0. : result.z;\n            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;\n          ")}}this.userCode="\n      vec4 binaryOperation(vec4 a, vec4 b) {\n        ".concat(e,"\n      }\n\n      void main() {\n        vec4 a = getAAtOutCoords();\n        vec4 b = getBAtOutCoords();\n\n        vec4 result = binaryOperation(a, b);\n        ").concat(o,"\n\n        setOutput(result);\n      }\n    ")}}function PM(e){const{inputs:t,backend:n}=e,{x:a}=t;return n.incRef(a.dataId),{dataId:a.dataId,shape:a.shape,dtype:a.dtype}}const zM={kernelName:ii,backendName:"webgl",kernelFunc:PM};function BM(e){const{inputs:t,backend:n}=e,{real:a,imag:r}=t,o=n.makeTensorInfo(a.shape,"complex64"),s=n.texData.get(o.dataId),i=PM({inputs:{x:a},backend:n}),c=PM({inputs:{x:r},backend:n});return s.complexTensorInfos={real:i,imag:c},o}const WM={kernelName:ys,backendName:"webgl",kernelFunc:BM},VM="return (a < 0.) ? b * a : a;",UM="\n  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));\n  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);\n";const GM={kernelName:pi,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{alpha:o}=a,s=n.makeTensorInfo([],"float32",Rl(o,"float32")),i=Vo().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new LM(UM,r.shape,s.shape):new DM(VM,r.shape,s.shape),c=n.runWebGLProgram(i,[r,s],"float32");return n.disposeIntermediateTensorInfo(s),c}},HM="return (a < 0.) ? b * a : a;",jM="\n  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));\n  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);\n";const KM={kernelName:Xi,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{x:a,alpha:r}=t,o=Vo().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new LM(jM,a.shape,r.shape):new DM(HM,a.shape,r.shape);return n.runWebGLProgram(o,[a,r],"float32")}},qM="if (isnan(x)) return x;";function XM(e){let{opSnippet:t,packedOpSnippet:n,cpuKernelImpl:a,dtype:r}=e;return e=>{let{inputs:o,backend:s}=e;const{x:i}=o,c=s,l=r||i.dtype;if(c.shouldExecuteOnCPU([i])&&null!=a){const e=c.texData.get(i.dataId),t=a(e.values,l);return c.makeTensorInfo(i.shape,l,t)}let u;return u=Vo().getBool("WEBGL_PACK_UNARY_OPERATIONS")&&null!=n?new TM(i.shape,n):new pM(i.shape,t),c.runWebGLProgram(u,[i],l)}}function YM(e){let{opSnippet:t,packedOpSnippet:n,checkOutOfBounds:a=!1,supportsComplex:r=!1,cpuKernelImpl:o,dtype:s}=e;return e=>{let{inputs:i,backend:c}=e;const{a:l,b:u}=i,d=c;if(r&&"complex64"===l.dtype){const e=d.texData.get(l.dataId),n=d.texData.get(u.dataId),[a,r]=[[e.complexTensorInfos.real,n.complexTensorInfos.real],[e.complexTensorInfos.imag,n.complexTensorInfos.imag]].map((e=>{const[n,a]=e,r={dataId:n.dataId,dtype:n.dtype,shape:l.shape},o={dataId:a.dataId,dtype:a.dtype,shape:u.shape},s=new DM(t,l.shape,u.shape);return d.runWebGLProgram(s,[r,o],su(n.dtype,a.dtype))})),o=BM({inputs:{real:a,imag:r},backend:d});return d.disposeIntermediateTensorInfo(a),d.disposeIntermediateTensorInfo(r),o}const h=s||su(l.dtype,u.dtype);if(("string"===l.dtype||"string"===u.dtype||d.shouldExecuteOnCPU([l,u]))&&null!=o){const e=d.texData.get(l.dataId).values,t=d.texData.get(u.dataId).values,n="string"===l.dtype?Yg(e):e,a="string"===l.dtype?Yg(t):t,[r,s]=o(l.shape,u.shape,n,a,h),i=d.makeTensorInfo(s,h);return d.texData.get(i.dataId).values=r,i}let p;return p=Vo().getBool("WEBGL_PACK_BINARY_OPERATIONS")&&null!=n?new LM(n,l.shape,u.shape,a):new DM(t,l.shape,u.shape),d.runWebGLProgram(p,[l,u],h)}}function QM(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];if("linear"===e)return t?kM:mM;if("relu"===e)return t?SM:yM;if("elu"===e)return t?IM:bM;if("relu6"===e)return t?NM:xM;if("prelu"===e)return t?jM:HM;if("leakyrelu"===e)return t?UM:VM;if("sigmoid"===e)return t?CM:wM;throw new Error("Activation ".concat(e," has not been implemented for the WebGL backend."))}class JM{constructor(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]&&arguments[3],r=arguments.length>4&&void 0!==arguments[4]&&arguments[4],o=arguments.length>5&&void 0!==arguments[5]&&arguments[5],s=arguments.length>6&&void 0!==arguments[6]?arguments[6]:null,i=arguments.length>7&&void 0!==arguments[7]&&arguments[7],c=arguments.length>8&&void 0!==arguments[8]&&arguments[8];this.variableNames=["matrixA","matrixB"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=n,this.enableShapeUniforms=jO(this.outputShape.length);const l=a?e[1]:e[2],u=Math.ceil(l/2),d=a?"i * 2, rc.y":"rc.y, i * 2",h=r?"rc.z, i * 2":"i * 2, rc.z",p=a?["a.xxyy","a.zzww"]:["a.xxzz","a.yyww"],f=r?["b.xzxz","b.ywyw"]:["b.xyxy","b.zwzw"];let m="",g="";s&&(m=i?"vec4 activation(vec4 a) {\n          vec4 b = getPreluActivationWeightsAtOutCoords();\n          ".concat(s,"\n        }"):c?"vec4 activation(vec4 a) {\n          vec4 b = getLeakyreluAlphaAtOutCoords();\n          ".concat(s,"\n        }"):"vec4 activation(vec4 x) {\n          ".concat(s,"\n        }"),g="result = activation(result);");const b=o?"result += getBiasAtOutCoords();":"";o&&this.variableNames.push("bias"),i&&this.variableNames.push("preluActivationWeights"),c&&this.variableNames.push("leakyreluAlpha");let y="rc.x",x="rc.x";e[0]<t[0]?y="imod(rc.x, ".concat(e[0],")"):t[0]<e[0]&&(x="imod(rc.x, ".concat(t[0],")")),this.userCode="\n      ".concat(m,"\n      // Don't use uniform for sharedDimensionPacked for performance.\n      const float sharedDimension = ").concat(u,".0;\n\n      vec4 dot2x2ARowBCol(ivec3 rc) {\n        vec4 result = vec4(0);\n        int batchA = ").concat(y,";\n        int batchB = ").concat(x,";\n        for (int i = 0; i < ").concat(u,"; i++) {\n          vec4 a = getMatrixA(batchA, ").concat(d,");\n          vec4 b = getMatrixB(batchB, ").concat(h,");\n\n          // These swizzled products need to be separately added.\n          // See: https://github.com/tensorflow/tfjs/issues/1735\n          result += (").concat(p[0]," * ").concat(f[0],");\n          result += (").concat(p[1]," * ").concat(f[1],");\n        }\n        return result;\n      }\n\n      void main() {\n        ivec3 rc = getOutputCoords();\n        vec4 result = dot2x2ARowBCol(rc);\n\n        ").concat(b,"\n\n        ").concat(g,"\n\n        setOutput(result);\n      }\n    ")}}const ZM={REAL:"return areal * breal - aimag * bimag;",IMAG:"return areal * bimag + aimag * breal;"};class $M{constructor(e,t,n){this.variableNames=["AReal","AImag","BReal","BImag"],this.outputShape=Zd(t,n),this.userCode="\n      float binaryOpComplex(\n          float areal, float aimag, float breal, float bimag) {\n        ".concat(e,"\n      }\n\n      void main() {\n        float areal = getARealAtOutCoords();\n        float aimag = getAImagAtOutCoords();\n        float breal = getBRealAtOutCoords();\n        float bimag = getBImagAtOutCoords();\n        setOutput(binaryOpComplex(areal, aimag, breal, bimag));\n      }\n    ")}}const eL="return a * b;";function tL(e){const{inputs:t,backend:n}=e,{a:a,b:r}=t,o=su(a.dtype,r.dtype);if("complex64"===a.dtype){const e=n.texData.get(a.dataId),t=n.texData.get(r.dataId),o=new $M(ZM.REAL,a.shape,r.shape),s=new $M(ZM.IMAG,a.shape,r.shape),i=[{dataId:e.complexTensorInfos.real.dataId,dtype:e.complexTensorInfos.real.dtype,shape:a.shape},{dataId:e.complexTensorInfos.imag.dataId,dtype:e.complexTensorInfos.imag.dtype,shape:a.shape},{dataId:t.complexTensorInfos.real.dataId,dtype:t.complexTensorInfos.real.dtype,shape:r.shape},{dataId:t.complexTensorInfos.imag.dataId,dtype:t.complexTensorInfos.imag.dtype,shape:r.shape}],c=n.runWebGLProgram(o,i,"float32"),l=n.runWebGLProgram(s,i,"float32"),u=BM({inputs:{real:c,imag:l},backend:n});return n.disposeIntermediateTensorInfo(c),n.disposeIntermediateTensorInfo(l),u}if(n.shouldExecuteOnCPU([a,r])){const e=n.texData.get(a.dataId),t=n.texData.get(r.dataId),[s,i]=FD(a.shape,r.shape,e.values,t.values,o),c=n.makeTensorInfo(i,o);return n.texData.get(c.dataId).values=s,c}let s;return s=Vo().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new LM(eL,a.shape,r.shape):new DM(eL,a.shape,r.shape),n.runWebGLProgram(s,[a,r],o)}const nL={kernelName:Pi,backendName:"webgl",kernelFunc:tL};function aL(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{shape:o}=a,s=n,i=lo(r.shape),c=go(o,i),l=lo(c);so(i===l,(()=>"The new shape (".concat(c,") has ").concat(l," elements and the old ")+"shape (".concat(r.shape,") has ").concat(i," elements. The new shape and old ")+"shape must have the same number of elements."));const u=s.texData.get(r.dataId);return!u.isPacked||pO(r.shape,c)||null!==u.texture&&pO(u.shape,c)?(s.incRef(r.dataId),{dataId:r.dataId,shape:c,dtype:r.dtype}):function(e,t,n){const a=[lO(e.shape),...uO(e.shape)],r={dtype:e.dtype,shape:a,dataId:e.dataId},o=[lO(t),...uO(t)],s=new cM(o,a),i=[a],c=n.runWebGLProgram(s,[r],e.dtype,i,!0);return{dataId:c.dataId,shape:t,dtype:c.dtype}}(r,c,s)}const rL={kernelName:ac,backendName:"webgl",kernelFunc:aL};class oL{constructor(e,t){this.variableNames=["x"];const{windowSize:n,batchSize:a,inSize:r,outSize:o}=e;this.outputShape=[a,o];const s=4*Math.floor(n/4),i=n%4;let c="sumValue += dot(values, ones);";if(null!=t){const e=1/t;c="sumValue += dot(values * ".concat(ho(e)?e.toPrecision(2):e,", ones);")}let l="";r%n>0&&(l="\n        if (inIdx < 0 || inIdx >= ".concat(r,") {\n          return 0.0;\n        }\n      ")),this.userCode="\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float getValue(int batch, int inIdx) {\n        ".concat(l,"\n        return getX(batch, inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ").concat(n,";\n\n        float sumValue = 0.0;\n\n        for (int i = 0; i < ").concat(s,"; i += 4) {\n          int inIdx = inOffset + i;\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          ").concat(c,"\n        }\n\n        int inIdx = inOffset + ").concat(s,";\n        if (").concat(1===i,") {\n          vec4 values = vec4(getValue(batch, inIdx), 0.0, 0.0, 0.0);\n\n          ").concat(c,"\n        } else if (").concat(2===i,") {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1), 0.0, 0.0);\n\n          ").concat(c,"\n        } else if (").concat(3===i,") {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2), 0.0);\n\n          ").concat(c,"\n        }\n        setOutput(sumValue);\n      }\n    ")}}class sL{constructor(e,t){this.variableNames=["x"];const{windowSize:n,batchSize:a,inSize:r,outSize:o}=e;this.outputShape=[a,o];let s="0.0",i="";"prod"===t?s="1.0":"min"===t?(s="1.0 / 1e-20",i="min"):"max"===t&&(s="-1.0 / 1e-20",i="max");let c="".concat(t,"(").concat(t,"(").concat(t,"(")+"minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])";"sum"===t?c="sumValue":"prod"===t?c="prodValue":"all"===t?c="allValue":"any"===t&&(c="anyValue");const l=4*Math.floor(n/4),u=n%4;let d="\n      if (".concat("sum"===t,") {\n        sumValue += dot(values, ones);\n      } else if (").concat("prod"===t,") {\n        vec2 tmp = vec2(values[0], values[1]) * vec2(values[2], values[3]);\n        prodValue *= tmp[0] * tmp[1];\n      } else {\n        minMaxValue = ").concat(i,"(values, minMaxValue);\n        if (").concat("min"===t," || ").concat("max"===t,") {\n          minMaxValue = ").concat(i,"(values, minMaxValue);\n          bvec4 isNaN = isnan(values);\n          if (isNaN.r || isNaN.g || isNaN.b || isNaN.a) {\n            minMaxValue = vec4(NAN);\n          }\n        }\n      }\n    "),h="vec4";"all"===t?(s="1.0",d="\n        bool reducedAllValue = all(values);\n        float floatedReducedAllValue = float(reducedAllValue);\n        allValue = float(allValue >= 1.0 && floatedReducedAllValue >= 1.0);\n      ",h="bvec4"):"any"===t&&(s="0.0",d="\n        bool reducedAnyValue = any(values);\n        float floatedReducedAnyValue = float(reducedAnyValue);\n        anyValue = float(anyValue >= 1.0 || floatedReducedAnyValue >= 1.0);\n      ",h="bvec4");let p="";r%n>0&&(p="\n        if (inIdx < 0 || inIdx >= ".concat(r,") {\n          return initializationValue;\n        }\n      ")),this.userCode="\n      const float initializationValue = ".concat(s,";\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float getValue(int batch, int inIdx) {\n        ").concat(p,"\n        return getX(batch, inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ").concat(n,";\n\n        vec4 minMaxValue = vec4(").concat(s,");\n        float prodValue = 1.0;\n        float sumValue = 0.0;\n        float allValue = 1.0;\n        float anyValue = 0.0;\n\n        for (int i = 0; i < ").concat(l,"; i += 4) {\n          int inIdx = inOffset + i;\n          ").concat(h," values = ").concat(h,"(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          ").concat(d,"\n        }\n\n        int inIdx = inOffset + ").concat(l,";\n        if (").concat(1===u,") {\n          ").concat(h," values = ").concat(h,"(\n            getValue(batch, inIdx),\n            initializationValue,\n            initializationValue,\n            initializationValue\n          );\n\n          ").concat(d,"\n        } else if (").concat(2===u,") {\n          ").concat(h," values = ").concat(h,"(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            initializationValue,\n            initializationValue\n          );\n\n          ").concat(d,"\n        } else if (").concat(3===u,") {\n          ").concat(h," values = ").concat(h,"(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            initializationValue\n          );\n\n          ").concat(d,"\n        }\n        setOutput(").concat(c,");\n      }\n    ")}}function iL(e,t,n,a){const r=function(e){const t=[];for(;0===t.length||1!==t[t.length-1].outSize;){const n=t.length?t[t.length-1].outSize:e[1],a=Qm(n);t.push({inSize:n,windowSize:a,outSize:Math.ceil(n/a)})}return t}(e.shape);let o=e;for(let s=0;s<r.length;s++){const{inSize:i,windowSize:c,outSize:l}=r[s];let u,d;u="mean"===n?0===s?new oL({windowSize:c,inSize:i,batchSize:e.shape[0],outSize:l},i):new oL({windowSize:c,inSize:i,batchSize:e.shape[0],outSize:l}):new sL({windowSize:c,inSize:i,batchSize:e.shape[0],outSize:l},n),d=o,o=a.runWebGLProgram(u,[o],t),d.dataId!==e.dataId&&a.disposeIntermediateTensorInfo(d)}return o}class cL{constructor(e,t){this.variableNames=["A"];const n=new Array(e.length);for(let o=0;o<n.length;o++)n[o]=e[t[o]];this.outputShape=n,this.rank=n.length;const a=zO(this.rank),r=function(e){const t=e.length;if(t>6)throw Error("Transpose for rank ".concat(t," is not yet supported"));const n=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u","resRC.v"],a=new Array(t);for(let r=0;r<e.length;r++)a[e[r]]=n[r];return a.join()}(t);this.userCode="\n    void main() {\n      ".concat(a," resRC = getOutputCoords();\n      setOutput(getA(").concat(r,"));\n    }\n    ")}}class lL{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0;const n=new Array(e.length);for(let l=0;l<n.length;l++)n[l]=e[t[l]];if(this.outputShape=n,this.rank=n.length,this.rank>6)throw Error("Packed transpose for rank ".concat(this.rank," is not yet supported."));const a=zO(this.rank),r=oM("rc",this.rank),o=new Array(this.rank);for(let l=0;l<t.length;l++)o[t[l]]=r[l];const s="vec2(".concat(o.slice(-2).join(),")"),i="++".concat(r[this.rank-1]," < ").concat(n[this.rank-1]),c="getChannel(getA(".concat(o.join(),"), ").concat(s,")");this.userCode="\n    void main() {\n      ".concat(a," rc = getOutputCoords();\n      vec4 result = vec4(0.);\n      result[0] = ").concat(c,";\n      if(").concat(i,") {\n        result[1] = ").concat(c,";\n      }\n      --").concat(r[this.rank-1],";\n      if(++").concat(r[this.rank-2]," < ").concat(n[this.rank-2],") {\n        result[2] = ").concat(c,";\n        if(").concat(i,") {\n          result[3] = ").concat(c,";\n        }\n      }\n      setOutput(result);\n    }\n    ")}}function uL(e,t,n){const a=Vo().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new lL(e.shape,t):new cL(e.shape,t);return n.runWebGLProgram(a,[e],e.dtype)}function dL(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{axis:o,keepDims:s}=a;return function(e,t,n,a){const r=t,o=e.shape.length,s=bo(r,e.shape);let i=s;const c=Wp(i,o),l=null!=c;let u=e;l&&(u=uL(e,c,a),i=Up(i.length,o)),Bp("sum",i,o);const[d,h]=Pp(u.shape,i);let p=d;n&&(p=zp(d,s));const f=lo(h),m=aL({inputs:{x:u},attrs:{shape:[lo(e.shape)/f,f]},backend:a}),g=iL(m,iu(e.dtype),"sum",a),b=aL({inputs:{x:g},attrs:{shape:p},backend:a});return a.disposeIntermediateTensorInfo(m),a.disposeIntermediateTensorInfo(g),l&&a.disposeIntermediateTensorInfo(u),b}(r,o,s,n)}const hL={kernelName:Sc,backendName:"webgl",kernelFunc:dL};function pL(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{perm:o}=a,s=n,i=r.shape.length,c=new Array(i);for(let u=0;u<c.length;u++)c[u]=r.shape[o[u]];let l;if(s.shouldExecuteOnCPU([r])){const e=s.texData.get(r.dataId).values,t=aM(e,r.shape,r.dtype,o,c);l=s.makeTensorInfo(c,r.dtype);s.texData.get(l.dataId).values=t}else l=uL(r,o,s);return l}const fL={kernelName:Kc,backendName:"webgl",kernelFunc:pL},mL=1e3;function gL(e){let{a:t,b:n,transposeA:a,transposeB:r,backend:o,bias:s=null,preluActivationWeights:i=null,leakyreluAlpha:c=0,activation:l=null}=e;const u=t.shape.length,d=n.shape.length,h=a?t.shape[u-2]:t.shape[u-1],p=r?n.shape[d-1]:n.shape[d-2],f=a?t.shape[u-1]:t.shape[u-2],m=r?n.shape[d-2]:n.shape[d-1],g=t.shape.slice(0,-2),b=n.shape.slice(0,-2),y=lo(g),x=lo(b),v=Zd(t.shape.slice(0,-2),n.shape.slice(0,-2)).concat([f,m]);so(h===p,(()=>"Error in matMul: inner shapes (".concat(h,") and (")+"".concat(p,") of Tensors with shapes ").concat(t.shape," and ")+"".concat(n.shape," and transposeA=").concat(a)+" and transposeB=".concat(r," must match.")));const w=a?[y,h,f]:[y,f,h],k=r?[x,m,p]:[x,p,m],I=aL({inputs:{x:t},backend:o,attrs:{shape:w}}),S=aL({inputs:{x:n},backend:o,attrs:{shape:k}}),N=[I,S],C=Math.max(y,x),T=a?I.shape[1]:I.shape[2],E=null!=s,R=null!=i,_="leakyrelu"===l,A=null!=l?QM(l,!0):null;let F;if((1===f||1===m)&&T>mL&&!1===(E||R||_||null!=A)){let e=I,t=S;a&&(e=pL({inputs:{x:I},backend:o,attrs:{perm:[0,2,1]}}),N.push(e)),r&&(t=pL({inputs:{x:S},backend:o,attrs:{perm:[0,2,1]}}),N.push(t));const n=1===m;let s=e;1!==m&&(s=aL({inputs:{x:e},backend:o,attrs:{shape:[C,T,1]}}),N.push(s));const i=1===m?2:1;let c=t;n&&(c=aL({inputs:{x:t},backend:o,attrs:{shape:[C,1,T]}}),N.push(c));const l=tL({inputs:{a:s,b:c},backend:o});F=dL({inputs:{x:l},backend:o,attrs:{axis:i,keepDims:!0}}),N.push(l)}else{const e=su(t.dtype,n.dtype),l=new JM(w,k,[C,f,m],a,r,E,A,R,_),u=[I,S];if(null!=s&&u.push(s),R&&u.push(i),_){const e=o.makeTensorInfo([],"float32",Rl(c,"float32"));u.push(e),N.push(e)}F=o.runWebGLProgram(l,u,e)}const O=aL({inputs:{x:F},backend:o,attrs:{shape:v}});N.push(F);for(const D of N)o.disposeIntermediateTensorInfo(D);return O}const bL={kernelName:el,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{a:r,b:o,bias:s,preluActivationWeights:i}=t,{transposeA:c,transposeB:l,activation:u,leakyreluAlpha:d}=a;return gL({a:r,b:o,transposeA:c,transposeB:l,backend:n,bias:s,preluActivationWeights:i,leakyreluAlpha:d,activation:u})}},yL="return abs(x);";const xL={kernelName:Ko,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{x:a}=t;if(n.shouldExecuteOnCPU([a])&&"complex64"!==a.dtype){const e=n.texData.get(a.dataId),t=GD(e.values);return n.makeTensorInfo(a.shape,a.dtype,t)}let r;return r=Vo().getBool("WEBGL_PACK_UNARY_OPERATIONS")?new TM(a.shape,yL):new pM(a.shape,yL),n.runWebGLProgram(r,[a],a.dtype)}},vL=XM({opSnippet:fM+"\n  if (abs(x) > 1.) {\n    return NAN;\n  }\n  return acos(x);\n"}),wL={kernelName:qo,backendName:"webgl",kernelFunc:vL},kL=XM({opSnippet:fM+"\n  if (x < 1.0) return NAN;\nreturn log(x + sqrt(x * x - 1.0));"}),IL={kernelName:Xo,backendName:"webgl",kernelFunc:kL},SL="return a + b;",NL=YM({opSnippet:SL,packedOpSnippet:SL,supportsComplex:!0,cpuKernelImpl:uD}),CL={kernelName:Yo,backendName:"webgl",kernelFunc:NL};class TL{constructor(e,t){this.outputShape=[],this.outputShape=e,this.variableNames=t.map(((e,t)=>"T".concat(t)));const n=[];this.variableNames.forEach((e=>{n.push("float v".concat(e," = get").concat(e,"AtOutCoords();"))}));const a=this.variableNames.map((e=>"v".concat(e))).join(" + ");this.userCode="\n      void main() {\n        ".concat(n.join("\n        "),"\n\n        float result = ").concat(a,";\n        setOutput(result);\n      }\n    ")}}class EL{constructor(e,t){this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.variableNames=t.map(((e,t)=>"T".concat(t)));const n=[];this.variableNames.forEach((e=>{n.push("vec4 v".concat(e," = get").concat(e,"AtOutCoords();"))}));const a=this.variableNames.map((e=>"v".concat(e))).join(" + ");this.userCode="\n      void main() {\n        ".concat(n.join("\n        "),"\n\n        vec4 result = ").concat(a,";\n        setOutput(result);\n      }\n    ")}}const RL={kernelName:Qo,backendName:"webgl",kernelFunc:function e(t){const{inputs:n,backend:a}=t,r=n;if(1===r.length)return PM({inputs:{x:r[0]},backend:a});if(r.length>Vo().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER")){const t=Math.floor(r.length/2),n=e({inputs:r.slice(0,t),backend:a}),o=e({inputs:r.slice(t),backend:a});return e({inputs:[n,o],backend:a})}const o=r.map((e=>e.dtype)).reduce(((e,t)=>su(e,t))),s=r.map((e=>e.shape)),i=Vo().getBool("WEBGL_PACK")?new EL(r[0].shape,s):new TL(r[0].shape,s);return a.runWebGLProgram(i,r,o)}};const _L={kernelName:Jo,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{axis:o,keepDims:s}=a,i=r.shape.length,c=bo(o,r.shape);let l=c;const u=Wp(l,i);let d=r;null!=u&&(d=pL({inputs:{x:r},backend:n,attrs:{perm:u}}),l=Up(l.length,i)),Bp("all",l,i);const[h,p]=Pp(d.shape,l),f=aL({inputs:{x:d},backend:n,attrs:{shape:[-1,lo(p)]}}),m=iL(f,f.dtype,"all",n);let g;if(s){g=aL({inputs:{x:m},backend:n,attrs:{shape:zp(h,c)}})}else g=aL({inputs:{x:m},backend:n,attrs:{shape:h}});return n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),null!=u&&n.disposeIntermediateTensorInfo(d),g}};const AL={kernelName:Zo,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{axis:o,keepDims:s}=a,i=r.shape.length,c=bo(o,r.shape);let l=c;const u=Wp(l,i);let d=r;null!=u&&(d=pL({inputs:{x:r},backend:n,attrs:{perm:u}}),l=Up(l.length,i)),Bp("any",l,i);const[h,p]=Pp(d.shape,l),f=aL({inputs:{x:d},backend:n,attrs:{shape:[-1,lo(p)]}}),m=iL(f,f.dtype,"any",n);let g;if(s){g=aL({inputs:{x:m},backend:n,attrs:{shape:zp(h,c)}})}else g=aL({inputs:{x:m},backend:n,attrs:{shape:h}});return n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),null!=u&&n.disposeIntermediateTensorInfo(d),g}};class FL{constructor(e,t,n){this.variableNames=["A"];const{windowSize:a,batchSize:r,outSize:o}=e;n||this.variableNames.push("bestIndicesA"),this.outputShape=[r,o];const s="max"===t?">":"<",i=n?"inOffset + i;":"round(getBestIndicesA(batch, inOffset + i));";this.userCode="\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ".concat(a,";\n\n        int bestIndex = inOffset;\n        float bestValue = getA(batch, bestIndex);\n\n        for (int i = 0; i < ").concat(a,"; i++) {\n          int inIdx = ").concat(i,";\n          float candidate = getA(batch, inIdx);\n          if (candidate ").concat(s," bestValue) {\n            bestValue = candidate;\n            bestIndex = inIdx;\n          }\n        }\n        setOutput(float(bestIndex));\n      }\n    ")}}class OL{constructor(e,t,n,a){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,so(e.length>2,(()=>"Packed arg".concat(n.charAt(0).toUpperCase()+n.slice(1)," supports only inputs with rank above 2.")));const r=e[e.length-1],o=Math.ceil(r/t);this.outputShape=e.slice(0,-1),o>1&&this.outputShape.push(o),a||this.variableNames.push("bestIndicesA");const s=this.outputShape,i=s.length,c=zO(i),l=sM("coords",i);let u,d;if(1===o){d=i+1;const e=zO(d);u="\n        ".concat(e," sourceLocR = ").concat(e,"(").concat(l.join(),", 0);\n        ++").concat(l[i-1],";\n        ").concat(e," sourceLocG = ").concat(e,"(").concat(l.join(),", 0);\n        ++").concat(l[i-2],";\n        ").concat(e," sourceLocA = ").concat(e,"(").concat(l.join(),", 0);\n        --").concat(l[i-1],";\n        ").concat(e," sourceLocB = ").concat(e,"(").concat(l.join(),", 0);\n        --").concat(l[i-2],";")}else d=i,u="\n        ".concat(c," sourceLocR = coords;\n        ++").concat(l[i-1],";\n        ").concat(c," sourceLocG = coords;\n        ++").concat(l[i-2],";\n        ").concat(c," sourceLocA = coords;\n        --").concat(l[i-1],";\n        ").concat(c," sourceLocB = coords;\n        --").concat(l[i-2],";");const h=["x","y","z","w","u","v"].slice(0,d),p="."+h[d-1],f=h.map((e=>"int "+e)),m=sM("sourceLocR",d-1).concat("inIdx.r"),g=sM("sourceLocG",d-1).concat("inIdx.g"),b=sM("sourceLocB",d-1).concat("inIdx.b"),y=sM("sourceLocA",d-1).concat("inIdx.a"),x="max"===n?"greaterThan":"lessThan",v=a?"":"\n          inIdx = round(vec4(getBestIndicesAChannel(".concat(m.join(),"),\n                             getBestIndicesAChannel(").concat(g.join(),"),\n                             getBestIndicesAChannel(").concat(b.join(),"),\n                             getBestIndicesAChannel(").concat(y.join(),")));"),w="vec4(\n            getAChannel(".concat(m.join(),"),\n            hasNextCol ? getAChannel(").concat(g.join(),") : 0.,\n            hasNextRow ? getAChannel(").concat(b.join(),") : 0.,\n            hasNextRow && hasNextCol ? getAChannel(").concat(y.join(),") : 0.)"),k=a?"":"\n      float getBestIndicesAChannel(".concat(f.join(),") {\n        return getChannel(getBestIndicesA(").concat(h.join(),"),\n                                          vec2(").concat(h.slice(-2).join(),"));\n      }");this.userCode="\n      float getAChannel(".concat(f.join(),") {\n        return getChannel(getA(").concat(h.join(),"),\n                               vec2(").concat(h.slice(-2).join(),"));\n      }\n      ").concat(k,"\n      void main() {\n        ").concat(c," coords = getOutputCoords();\n        bool hasNextCol = ").concat(l[i-1]," < ").concat(s[i-1]-1,";\n        bool hasNextRow = ").concat(l[i-2]," < ").concat(s[i-2]-1,";\n        ").concat(u,"\n        ivec4 srcIdx = ivec4(sourceLocR").concat(p,", sourceLocG").concat(p,",\n          sourceLocB").concat(p,", sourceLocA").concat(p,") * ").concat(t,";\n        ivec4 inIdx = srcIdx;\n        vec4 bestIndex = vec4(inIdx);\n        vec4 bestValue = ").concat(w,";\n\n        for (int i = 0; i < ").concat(t,"; i++) {\n          inIdx = srcIdx;\n          ").concat(v,"\n          vec4 candidate = ").concat(w,";\n          bvec4 nan = isnan(candidate);\n          bvec4 replace = bvec4(\n            vec4(").concat(x,"(candidate, bestValue)) * (vec4(1.0) - vec4(nan)));\n\n          bestValue = vec4(replace.x  ? candidate.x : bestValue.x,\n                           replace.y  ? candidate.y : bestValue.y,\n                           replace.z  ? candidate.z : bestValue.z,\n                           replace.w  ? candidate.w : bestValue.w);\n          bestIndex = mix(bestIndex, vec4(inIdx), vec4(replace));\n          srcIdx++;\n        }\n        setOutput(bestIndex);\n      }\n    ")}}function DL(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:null,r=t.shape[0],o=t.shape[1];null!=a&&(r=a.shape[0],o=a.shape[1]);const s=Qm(o),i={windowSize:s,inSize:o,batchSize:r,outSize:Math.ceil(o/s)},c=new FL(i,n,null==a),l=[t];null!=a&&l.push(a);const u=e.runWebGLProgram(c,l,"int32");if(1===u.shape[1])return u;const d=DL(e,t,n,u);return e.disposeIntermediateTensorInfo(u),d}function ML(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:null;const r=null!=a?a.shape:t.shape,o=Qm(r[r.length-1]),s=new OL(r,o,n,null==a),i=null==a?[t]:[t,a],c=e.runWebGLProgram(s,i,"int32");if(c.shape.length===t.shape.length){const a=ML(e,t,n,c);return e.disposeIntermediateTensorInfo(c),a}return c}function LL(e,t,n,a){const r=[n];if(Bp("arg"+a.charAt(0).toUpperCase()+a.slice(1),r,t.shape.length),!Vo().getBool("WEBGL_PACK_REDUCE")||t.shape.length<=2){const n=[],o=e.texData.get(t.dataId);let s=t;null!==o&&o.isPacked&&(s=e.unpackTensor(t),n.push(s));const[i,c]=Pp(s.shape,r),l=lo(c),u=aL({inputs:{x:s},backend:e,attrs:{shape:[-1,l]}});n.push(u);const d=DL(e,u,a);n.push(d);const h=aL({inputs:{x:d},backend:e,attrs:{shape:i}});return n.forEach((t=>e.disposeIntermediateTensorInfo(t))),h}return ML(e,t,a)}const PL={kernelName:$o,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{axis:o}=a;let s=bo(o,r.shape);const i=Wp(s,r.shape.length);let c=r;const l=[];null!=i&&(c=pL({inputs:{x:r},backend:n,attrs:{perm:i}}),l.push(c),s=Up(s.length,c.shape.length)),Bp("argMax",[s[0]],c.shape.length);const u=LL(n,c,s[0],"max");return l.forEach((e=>n.disposeIntermediateTensorInfo(e))),u}};const zL={kernelName:es,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{axis:o}=a;let s=bo(o,r.shape);const i=Wp(s,r.shape.length);let c=r;const l=[];null!=i&&(c=pL({inputs:{x:r},backend:n,attrs:{perm:i}}),l.push(c),s=Up(s.length,c.shape.length)),Bp("argMin",[s[0]],c.shape.length);const u=LL(n,c,s[0],"min");return l.forEach((e=>n.disposeIntermediateTensorInfo(e))),u}},BL=XM({opSnippet:fM+"\n  if (abs(x) > 1.) {\n    return NAN;\n  }\n  return asin(x);\n"}),WL={kernelName:ts,backendName:"webgl",kernelFunc:BL},VL=XM({opSnippet:fM+"return log(x + sqrt(x * x + 1.0));"}),UL={kernelName:ns,backendName:"webgl",kernelFunc:VL},GL=XM({opSnippet:fM+"\n  return atan(x);\n"}),HL={kernelName:as,backendName:"webgl",kernelFunc:GL},jL=YM({opSnippet:OM+"\n  return atan(a, b);\n",packedOpSnippet:"\n  vec4 result = atan(a, b);\n  bvec4 isNaNA = isnan(a);\n  bvec4 isNaNB = isnan(b);\n  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);\n  "+MM+"\n  return result;\n"}),KL={kernelName:os,backendName:"webgl",kernelFunc:jL},qL=XM({opSnippet:fM+"\n  if ((x < -1.0) || (x > 1.0)) return NAN;\nreturn (log(1.0 + x) - log(1.0 - x)) / 2.0;"}),XL={kernelName:rs,backendName:"webgl",kernelFunc:qL};class YL{constructor(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]&&arguments[3],r=arguments.length>4&&void 0!==arguments[4]&&arguments[4];if(this.variableNames=["x"],"avg"===t&&n)throw new Error("Cannot compute positions for average pool.");const o=e.filterWidth,s=e.strideHeight,i=e.strideWidth,c=e.dilationHeight,l=e.dilationWidth,u=e.effectiveFilterHeight,d=e.effectiveFilterWidth,h=e.padInfo.top,p=e.padInfo.left;this.outputShape=e.outShape;const f="avg"===t,m="((batch  * ".concat(e.inHeight," + xR) * ").concat(e.inWidth," + xC) * ").concat(e.inChannels," + d"),g="(xR * ".concat(e.inWidth," + xC) * ").concat(e.inChannels," + d");let b="0.0";if(f||(b="-1.0 / 1e-20"),n){const t=">=";return void(this.userCode="\n        const ivec2 strides = ivec2(".concat(s,", ").concat(i,");\n        const ivec2 pads = ivec2(").concat(h,", ").concat(p,");\n\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int batch = coords[0];\n          int d = coords[3];\n\n          ivec2 xRCCorner = coords.yz * strides - pads;\n          int xRCorner = xRCCorner.x;\n          int xCCorner = xRCCorner.y;\n\n          // max/min x(?, ?, d) to get y(yR, yC, d).\n          // ? = to be determined\n          float minMaxValue = 0.0;\n          float minMaxValueFound = 0.0;\n          int minMaxPosition = 0;\n          float avgValue = 0.0;\n\n          for (int wR = 0; wR < ").concat(u,";\n              wR += ").concat(c,") {\n            int xR = xRCorner + wR;\n\n            if (xR < 0 || xR >= ").concat(e.inHeight,") {\n              continue;\n            }\n\n            for (int wC = 0; wC < ").concat(d,";\n                wC += ").concat(l,") {\n              int xC = xCCorner + wC;\n\n              if (xC < 0 || xC >= ").concat(e.inWidth,") {\n                continue;\n              }\n\n              float value = getX(batch, xR, xC, d);\n\n              // If a min / max value has already been found, use it. If not,\n              // use the current value.\n              float currMinMaxValue = mix(\n                  value, minMaxValue, minMaxValueFound);\n              if (value ").concat(t," currMinMaxValue) {\n                minMaxValue = value;\n                minMaxValueFound = 1.0;\n                minMaxPosition = ").concat(a?r?m:g:"wR * ".concat(d," + wC"),";\n              }\n            }\n          }\n          setOutput(float(minMaxPosition));\n        }\n      "))}let y="".concat(t,"(").concat(t,"(").concat(t,"(")+"minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])";"avg"===t&&(y="avgValue / max(count, 1.0)");const x=4*Math.floor(o/4),v=o%4,w="\n      if (".concat(f,") {\n        avgValue += dot(values, ones);\n      } else {\n        minMaxValue = ").concat("max","(values, minMaxValue);\n      }\n    ");this.userCode="\n      const ivec2 strides = ivec2(".concat(s,", ").concat(i,");\n      const ivec2 pads = ivec2(").concat(h,", ").concat(p,");\n      const float initializationValue = ").concat(b,";\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float count = 0.0;\n\n      float getValue(int batch, int xR, int xC, int d) {\n        if (xC < 0 || xC >= ").concat(e.inWidth,") {\n          return initializationValue;\n        }\n        count += 1.0;\n        return getX(batch, xR, xC, d);\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d = coords[3];\n\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // max/min x(?, ?, d) to get y(yR, yC, d).\n        // ? = to be determined\n        vec4 minMaxValue = vec4(").concat(b,");\n        float avgValue = 0.0;\n        count = 0.0;\n\n        for (int wR = 0; wR < ").concat(u,";\n            wR += ").concat(c,") {\n          int xR = xRCorner + wR;\n\n          if (xR < 0 || xR >= ").concat(e.inHeight,") {\n            continue;\n          }\n\n          for (int wC = 0; wC < ").concat(x,"; wC += 4) {\n            int xC = xCCorner + wC * ").concat(l,";\n\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ").concat(l,", d),\n              getValue(batch, xR, xC + 2 * ").concat(l,", d),\n              getValue(batch, xR, xC + 3 * ").concat(l,", d)\n            );\n\n            ").concat(w,"\n          }\n\n          int xC = xCCorner + ").concat(x,";\n          if (").concat(1===v,") {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              initializationValue,\n              initializationValue,\n              initializationValue\n            );\n\n            ").concat(w,"\n          } else if (").concat(2===v,") {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ").concat(l,", d),\n              initializationValue,\n              initializationValue\n            );\n\n            ").concat(w,"\n          } else if (").concat(3===v,") {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ").concat(l,", d),\n              getValue(batch, xR, xC + 2 * ").concat(l,", d),\n              initializationValue\n            );\n\n            ").concat(w,"\n          }\n        }\n        setOutput(").concat(y,");\n      }\n    ")}}class QL{constructor(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]&&arguments[3],r=arguments.length>4&&void 0!==arguments[4]&&arguments[4];if(this.variableNames=["x"],"avg"===t&&n)throw new Error("Cannot compute positions for average pool.");const o=e.filterWidth,s=e.strideDepth,i=e.strideHeight,c=e.strideWidth,l=e.dilationDepth,u=e.dilationHeight,d=e.dilationWidth,h=e.effectiveFilterDepth,p=e.effectiveFilterHeight,f=e.effectiveFilterWidth,m=e.padInfo.front,g=e.padInfo.top,b=e.padInfo.left;this.outputShape=e.outShape;const y="avg"===t;let x="0.0";if(y||(x="-1.0 / 1e-20"),n){const t=">=";return void(this.userCode="\n        const ivec3 strides =\n            ivec3(".concat(s,", ").concat(i,", ").concat(c,");\n        const ivec3 pads = ivec3(").concat(m,", ").concat(g,", ").concat(b,");\n\n        void main() {\n          ivec5 coords = getOutputCoords();\n          int batch = coords.x;\n          int ch = coords.u;\n\n          ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n          int xDCorner = xCorner.x;\n          int xRCorner = xCorner.y;\n          int xCCorner = xCorner.z;\n\n          // max/min x(?, ?, ?, ch) to get y(yD, yR, yC, ch).\n          // ? = to be determined\n          float minMaxValue = 0.0;\n          float minMaxValueFound = 0.0;\n          int minMaxPosition = 0;\n\n          for (int wD = 0; wD < ").concat(h,";\n              wD += ").concat(l,") {\n            int xD = xDCorner + wD;\n\n            if (xD < 0 || xD >= ").concat(e.inDepth,") {\n              continue;\n            }\n\n            for (int wR = 0; wR < ").concat(p,";\n                wR += ").concat(u,") {\n              int xR = xRCorner + wR;\n\n              if (xR < 0 || xR >= ").concat(e.inHeight,") {\n                continue;\n              }\n\n              for (int wC = 0; wC < ").concat(f,";\n                  wC += ").concat(d,") {\n                int xC = xCCorner + wC;\n\n                if (xC < 0 || xC >= ").concat(e.inWidth,") {\n                  continue;\n                }\n\n                float value = getX(batch, xD, xR, xC, ch);\n\n                // If a min / max value has already been found, use it. If not,\n                // use the current value.\n                float currMinMaxValue = mix(\n                    value, minMaxValue, minMaxValueFound);\n                if (value ").concat(t," currMinMaxValue) {\n                  minMaxValue = value;\n                  minMaxValueFound = 1.0;\n                  minMaxPosition = ").concat(a?r?"(((batch * ".concat(e.inDepth," + xD) * ").concat(e.inHeight," + xR) * ").concat(e.inWidth," + xC) * ").concat(e.inChannels," + ch"):"((xD * ".concat(e.inHeight," + xR) * ").concat(e.inWidth," + xC) * ").concat(e.inChannels," + ch"):"wD * ".concat(p," * ").concat(f," +\n                      wR * ").concat(f," + wC"),";\n                }\n              }\n            }\n          }\n          setOutput(float(minMaxPosition));\n        }\n      "))}let v="".concat(t,"(").concat(t,"(").concat(t,"(")+"minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])";"avg"===t&&(v="avgValue / max(count, 1.0)");const w=4*Math.floor(o/4),k=o%4,I="\n      if (".concat(y,") {\n        avgValue += dot(values, ones);\n      } else {\n        minMaxValue = ").concat("max","(values, minMaxValue);\n      }\n    ");this.userCode="\n      const ivec3 strides =\n        ivec3(".concat(s,", ").concat(i,", ").concat(c,");\n      const ivec3 pads = ivec3(").concat(m,", ").concat(g,", ").concat(b,");\n      const float initializationValue = ").concat(x,";\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float count = 0.0;\n\n      float getValue(int batch, int xD, int xR, int xC, int ch) {\n        if (xC < 0 || xC >= ").concat(e.inWidth,") {\n          return initializationValue;\n        }\n        count += 1.0;\n        return getX(batch, xD, xR, xC, ch);\n      }\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n        int xDCorner = xCorner.x;\n        int xRCorner = xCorner.y;\n        int xCCorner = xCorner.z;\n\n        // max/min x(?, ?, ?, d) to get y(yD, yR, yC, ch).\n        // ? = to be determined\n        vec4 minMaxValue = vec4(").concat(x,");\n        float avgValue = 0.0;\n        count = 0.0;\n\n        for (int wD = 0; wD < ").concat(h,";\n            wD += ").concat(l,") {\n          int xD = xDCorner + wD;\n\n          if (xD < 0 || xD >= ").concat(e.inDepth,") {\n            continue;\n          }\n\n          for (int wR = 0; wR < ").concat(p,";\n            wR += ").concat(u,") {\n            int xR = xRCorner + wR;\n\n            if (xR < 0 || xR >= ").concat(e.inHeight,") {\n              continue;\n            }\n\n            for (int wC = 0; wC < ").concat(w,"; wC += 4) {\n              int xC = xCCorner + wC * ").concat(d,";\n\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ").concat(d,", ch),\n                getValue(batch, xD, xR, xC + 2 * ").concat(d,", ch),\n                getValue(batch, xD, xR, xC + 3 * ").concat(d,", ch)\n              );\n\n              ").concat(I,"\n            }\n\n            int xC = xCCorner + ").concat(w,";\n            if (").concat(1===k,") {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                initializationValue,\n                initializationValue,\n                initializationValue\n              );\n\n              ").concat(I,"\n            } else if (").concat(2===k,") {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ").concat(d,", ch),\n                initializationValue,\n                initializationValue\n              );\n\n              ").concat(I,"\n            } else if (").concat(3===k,") {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ").concat(d,", ch),\n                getValue(batch, xD, xR, xC + 2 * ").concat(d,", ch),\n                initializationValue\n              );\n\n              ").concat(I,"\n            }\n          }\n        }\n        setOutput(").concat(v,");\n      }\n    ")}}const JL={kernelName:ss,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t;vO(r,"avgPool");const{filterSize:o,strides:s,pad:i,dimRoundingMode:c}=a;so(Kh(s,1),(()=>"Error in avgPool: Either strides or dilations must be 1. "+"Got strides ".concat(s," and dilations '").concat(1,"'")));const l=Lh(r.shape,o,s,1,i,c);if(1===l.filterWidth&&1===l.filterHeight&&uo(l.inShape,l.outShape))return PM({inputs:{x:r},backend:n});const u=new YL(l,"avg",!1);return n.runWebGLProgram(u,[r],"float32")}};const ZL={kernelName:cs,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{filterSize:o,strides:s,pad:i,dimRoundingMode:c,dataFormat:l}=a,u=Ph(r.shape,o,s,[1,1,1],i,c,l),d=new QL(u,"avg",!1);return n.runWebGLProgram(d,[r],"float32")}};class $L{constructor(e){this.variableNames=["dy"],this.outputShape=e.inShape;const t=e.filterHeight,n=e.filterWidth,a=e.strideHeight,r=e.strideWidth,o=e.dilationHeight,s=e.dilationWidth,i=e.effectiveFilterHeight,c=e.effectiveFilterWidth,l=i-1-e.padInfo.top,u=c-1-e.padInfo.left,d=1/(t*n);this.userCode="\n      const ivec2 pads = ivec2(".concat(l,", ").concat(u,");\n      const float avgMultiplier = float(").concat(d,");\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n\n        ivec2 dyRCCorner = coords.yz - pads;\n        int dyRCorner = dyRCCorner.x;\n        int dyCCorner = dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ").concat(i,";\n            wR += ").concat(o,") {\n          float dyR = float(dyRCorner + wR) / ").concat(a,".0;\n\n          if (dyR < 0.0 || dyR >= ").concat(e.outHeight,".0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          for (int wC = 0; wC < ").concat(c,";\n            wC+= ").concat(s,") {\n            float dyC = float(dyCCorner + wC) / ").concat(r,".0;\n\n            if (dyC < 0.0 || dyC >= ").concat(e.outWidth,".0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            float dyValue = getDy(b, idyR, idyC, d);\n\n            dotProd += dyValue * avgMultiplier;\n          }\n        }\n        setOutput(dotProd);\n      }\n    ")}}class eP{constructor(e){this.variableNames=["dy"],this.outputShape=e.inShape;const t=e.filterDepth,n=e.filterHeight,a=e.filterWidth,r=e.strideDepth,o=e.strideHeight,s=e.strideWidth,i=e.dilationDepth,c=e.dilationHeight,l=e.dilationWidth,u=e.effectiveFilterDepth,d=e.effectiveFilterHeight,h=e.effectiveFilterWidth,p=u-1-e.padInfo.front,f=d-1-e.padInfo.top,m=h-1-e.padInfo.left,g=1/(t*n*a);this.userCode="\n      const ivec3 pads = ivec3(".concat(p,", ").concat(f,", ").concat(m,");\n      const float avgMultiplier = float(").concat(g,");\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyDCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        // Convolve dy(?, ?, ?, d) with pos mask(:, :, :, ch) to get\n        // dx(xD, xR, xC, ch).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int wD = 0; wD < ").concat(u,";\n            wD += ").concat(i,") {\n          float dyD = float(dyDCorner + wD) / ").concat(r,".0;\n\n          if (dyD < 0.0 || dyD >= ").concat(e.outDepth,".0 || fract(dyD) > 0.0) {\n            continue;\n          }\n          int idyD = int(dyD);\n\n          for (int wR = 0; wR < ").concat(d,";\n              wR += ").concat(c,") {\n            float dyR = float(dyRCorner + wR) / ").concat(o,".0;\n\n            if (dyR < 0.0 || dyR >= ").concat(e.outHeight,".0 ||\n                fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            for (int wC = 0; wC < ").concat(h,";\n                wC += ").concat(l,") {\n              float dyC = float(dyCCorner + wC) / ").concat(s,".0;\n\n              if (dyC < 0.0 || dyC >= ").concat(e.outWidth,".0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              float dyValue = getDy(batch, idyD, idyR, idyC, ch);\n\n              dotProd += dyValue * avgMultiplier;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    ")}}const tP={kernelName:ls,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{dy:r,input:o}=t,s=o,{filterSize:i,strides:c,pad:l,dimRoundingMode:u}=a,d=Ph(s.shape,i,c,[1,1,1],l,u),h=new eP(d);return n.runWebGLProgram(h,[r],s.dtype)}};const nP={kernelName:is,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{dy:r,input:o}=t,s=o;vO([r,o],"avgPoolGrad");const{filterSize:i,strides:c,pad:l}=a,u=Lh(s.shape,i,c,1,l),d=new $L(u);return n.runWebGLProgram(d,[r],s.dtype)}};const aP={kernelName:us,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{a:r,b:o}=t,{transposeA:s,transposeB:i}=a;return gL({a:r,b:o,transposeA:s,transposeB:i,backend:n})}};class rP{constructor(e,t,n,a,r,o){this.outputShape=[],this.variableNames=["x","mean","variance"],Zd(e,t),Zd(e,n);let s="0.0";null!=a&&(Zd(e,a),this.variableNames.push("offset"),s="getOffsetAtOutCoords()");let i="1.0";null!=r&&(Zd(e,r),this.variableNames.push("scale"),i="getScaleAtOutCoords()"),this.outputShape=e,this.userCode="\n      void main() {\n        float x = getXAtOutCoords();\n        float mean = getMeanAtOutCoords();\n        float variance = getVarianceAtOutCoords();\n        float offset = ".concat(s,";\n        float scale = ").concat(i,";\n        float inv = scale * inversesqrt(variance + float(").concat(o,"));\n        setOutput(dot(vec3(x, -mean, offset), vec3(inv, inv, 1)));\n      }\n    ")}}class oP{constructor(e,t,n,a,r,o){this.packedInputs=!0,this.packedOutput=!0,this.variableNames=["x","mean","variance"],Zd(e,t),Zd(e,n);let s="vec4(0.0)";null!=a&&(Zd(e,a),this.variableNames.push("offset"),s="getOffsetAtOutCoords()");let i="vec4(1.0)";null!=r&&(Zd(e,r),this.variableNames.push("scale"),i="getScaleAtOutCoords()"),this.outputShape=e,this.userCode="\n      void main() {\n        vec4 offset = ".concat(s,";\n        vec4 scale = ").concat(i,";\n\n        vec4 x = getXAtOutCoords();\n        vec4 mean = getMeanAtOutCoords();\n        vec4 variance = getVarianceAtOutCoords();\n\n        vec4 inv = scale * inversesqrt(variance + vec4(").concat(o,"));\n\n        setOutput((x - mean) * inv + offset);\n      }\n    ")}}const sP={kernelName:ni,backendName:"webgl",kernelFunc:e=>{let{inputs:t,backend:n,attrs:a}=e;const{x:r,mean:o,variance:s,offset:i,scale:c}=t;so(o.shape.length===s.shape.length,(()=>"Batch normalization gradient requires mean and variance to have equal ranks.")),so(null==i||o.shape.length===i.shape.length,(()=>"Batch normalization gradient requires mean and offset to have equal ranks.")),so(null==c||o.shape.length===c.shape.length,(()=>"Batch normalization gradient requires mean and scale to have equal ranks."));let{varianceEpsilon:l}=a;null==l&&(l=.001);const u=[r,o,s];let d=null;null!=i&&(d=i.shape,u.push(i));let h=null;null!=c&&(h=c.shape,u.push(c));const p=Vo().getBool("WEBGL_PACK_NORMALIZATION")?new oP(r.shape,o.shape,s.shape,d,h,l):new rP(r.shape,o.shape,s.shape,d,h,l);return n.runWebGLProgram(p,u,u[0].dtype)}};class iP{constructor(e){this.variableNames=["source"],this.outputShape=e,this.rank=e.length;const t=zO(this.rank);this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];const n=function(e){if(1===e)return"sourceLoc";if(e<=6)return cP.slice(0,e).map((e=>"sourceLoc."+e)).join(",");throw Error("Slicing for rank ".concat(e," is not yet supported"))}(this.rank);let a;const r=e.map(((e,t)=>"sourceLoc.".concat(cP[t]," = start[").concat(t,"] + coords.").concat(cP[t],";")));a="\n        ".concat(t," sourceLoc;\n        ").concat(t," coords = getOutputCoords();\n        ").concat(r.join("\n"),"\n      "),this.userCode="\n      void main() {\n        ".concat(a,"\n        setOutput(getSource(").concat(n,"));\n      }\n    ")}}const cP=["x","y","z","w","u","v"];class lP{constructor(e){this.variableNames=["source"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.rank=e.length,this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];const t=zO(this.rank),n=sM("coords",this.rank),a=sM("sourceLoc",this.rank),r=1===this.rank?"sourceLoc":"vec2(".concat(a.slice(-2).join(),")"),o="getChannel(getSource(".concat(a.join(),"), ").concat(r,")"),s="\n      result.x = ".concat(o,";\n      if (++").concat(n[this.rank-1]," < ").concat(e[this.rank-1],") {\n        ++").concat(a[this.rank-1],";\n        result.y = ").concat(o,";\n        --").concat(a[this.rank-1],";\n      }\n    "),i=1===this.rank?"":"\n      --".concat(n[this.rank-1],";\n      if (++").concat(n[this.rank-2]," < ").concat(e[this.rank-2],") {\n        ++").concat(a[this.rank-2],";\n        result.z = ").concat(o,";\n        if (++").concat(n[this.rank-1]," < ").concat(e[this.rank-1],") {\n          ++").concat(a[this.rank-1],";\n          result.w = ").concat(o,";\n        }\n      }\n    "),c=this.rank<=4?"sourceLoc = coords +\n            ".concat(t,"(").concat(e.map(((e,t)=>"start[".concat(t,"]"))).join(),");"):e.map(((e,t)=>"".concat(a[t]," = ").concat(n[t]," + start[").concat(t,"];"))).join("\n");this.userCode="\n      void main() {\n        ".concat(t," coords = getOutputCoords();\n        ").concat(t," sourceLoc;\n        ").concat(c,"\n        vec4 result = vec4(0.);\n        ").concat(s,"\n        ").concat(i,"\n        setOutput(result);\n      }\n    ")}}function uP(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{begin:o,size:s}=a,[i,c]=Rh(r,o,s);if(mh(r,i,c),0===lo(c))return n.makeTensorInfo(c,r.dtype,[]);if(n.shouldExecuteOnCPU([r])||"string"===r.dtype){const e=n.texData.get(r.dataId),t=HD(e.values,i,c,r.shape,r.dtype);return n.makeTensorInfo(c,r.dtype,t)}const{isPacked:l}=n.texData.get(r.dataId),u=Th(r.shape,i,c);if(l||!u){const e=Vo().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new lP(c):new iP(c),t=[i];return n.runWebGLProgram(e,[r],r.dtype,t)}return n.uploadToGPU(r.dataId),function(e,t,n,a){const r=a.texData.get(e.dataId),o=a.makeTensorInfo(n,e.dtype),s=a.texData.get(o.dataId);Object.assign(s,r),s.refCount=1,s.shape=n,s.dtype=e.dtype;let i=Eh(t,Eo(e.shape));r.slice&&(i+=r.slice.flatOffset),s.slice={flatOffset:i,origDataId:r.slice&&r.slice.origDataId||e.dataId};const c=a.dataRefCount.get(s.slice.origDataId)||1;return a.dataRefCount.set(s.slice.origDataId,c+1),o}(r,i,c,n)}const dP={kernelName:bc,backendName:"webgl",kernelFunc:uP},hP={kernelName:ds,backendName:"webgl",kernelFunc:e=>{const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{blockShape:o,crops:s}=a;so(r.shape.length<=4,(()=>"batchToSpaceND for rank > 4 with a WebGL backend not implemented yet"));const i=o.reduce(((e,t)=>e*t)),c=Zm(r.shape,o,i),l=$m(c.length,o.length),u=eg(r.shape,o,i),d=tg(s,o.length),h=ng(u,s,o.length),p=[],f=aL({inputs:{x:r},backend:n,attrs:{shape:c}}),m=pL({inputs:{x:f},backend:n,attrs:{perm:l}}),g=aL({inputs:{x:m},backend:n,attrs:{shape:u}}),b=uP({inputs:{x:g},backend:n,attrs:{begin:d,size:h}});return p.push(f),p.push(m),p.push(g),p.forEach((e=>n.disposeIntermediateTensorInfo(e))),b}};const pP={kernelName:hs,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r,weights:o}=t,{size:s}=a,i=n.readSync(r.dataId),c=n.readSync(o.dataId),l=dD(i,c,o.dtype,o.shape,s);return n.makeTensorInfo([s],o.dtype,l)}};const fP={kernelName:ps,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{a:a,b:r}=t,o=Vo().getBool("WEBGL_PACK_BINARY_OPERATIONS"),s=Vo().getNumber("WEBGL_VERSION");if(n.shouldExecuteOnCPU([a,r])||1===s){const e=n.texData.get(a.dataId).values,t=n.texData.get(r.dataId).values,[o,s]=pD(a.shape,r.shape,e,t,a.dtype),i=n.makeTensorInfo(s,a.dtype);return n.texData.get(i.dataId).values=o,i}let i;return i=o?new LM("\n  int r = int(a.r) & int(b.r);\n  int g = int(a.g) & int(b.g);\n  int rb = int(a.b) & int(b.b);\n  int ra = int(a.a) & int(b.a);\n  return vec4(r, g, rb, ra);\n",a.shape,r.shape,!1):new DM("\n  return float(int(a.r) & int(b.r));\n",a.shape,r.shape),n.runWebGLProgram(i,[a,r],a.dtype)}};const mP={kernelName:fs,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{s0:a,s1:r}=t,o=n.readSync(a.dataId),s=n.readSync(r.dataId),i=Zd(Array.from(o),Array.from(s));return n.makeTensorInfo([i.length],"int32",Int32Array.from(i))}},gP=YM({opSnippet:"return float(a != b);",cpuKernelImpl:DD,dtype:"bool"}),bP={kernelName:Bi,backendName:"webgl",kernelFunc:gP};function yP(e){const{inputs:t,backend:n}=e,{input:a}=t;return PM({inputs:{x:n.texData.get(a.dataId).complexTensorInfos.real},backend:n})}const xP={kernelName:ec,backendName:"webgl",kernelFunc:yP},vP="return float(int(x));";const wP={kernelName:ms,backendName:"webgl",kernelFunc:function e(t){const{inputs:n,backend:a,attrs:r}=t,{x:o}=n,{dtype:s}=r;if("complex64"===s){if("complex64"===o.dtype)return PM({inputs:{x:o},backend:a});const t=tf(o.shape),n=e({inputs:{x:o},backend:a,attrs:{dtype:"float32"}}),r=BM({inputs:{real:n,imag:t},backend:a});return t.dispose(),a.disposeIntermediateTensorInfo(n),r}if("complex64"===o.dtype){const t=yP({inputs:{input:o},backend:a}),n=e({inputs:{x:t},backend:a,attrs:{dtype:s}});return a.disposeIntermediateTensorInfo(t),n}if(!wo(o.dtype,s)){const e=PM({inputs:{x:o},backend:a});return{dataId:e.dataId,shape:e.shape,dtype:s}}if(a.shouldExecuteOnCPU([o])){const e=a.texData.get(o.dataId).values,[t,n,r]=fD(e,o.shape,o.dtype,s);return a.makeTensorInfo(t,n,r)}if("int32"===s)return function(e,t){const n=new pM(e.shape,vP),a=t.runWebGLProgram(n,[e],"int32");return{dataId:a.dataId,shape:a.shape,dtype:a.dtype}}(o,a);if("bool"===s){const e=a.makeTensorInfo([],"bool",xo("bool",1)),t=gP({inputs:{a:o,b:e},backend:a});return a.disposeIntermediateTensorInfo(e),t}throw new Error("Error in Cast: failed to cast ".concat(o.dtype," to ").concat(s))}},kP="return ceil(x);",IP=XM({opSnippet:kP,packedOpSnippet:kP,cpuKernelImpl:mD}),SP={kernelName:gs,backendName:"webgl",kernelFunc:IP};class NP{constructor(e){this.variableNames=["A"],this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=e,this.userCode="\n\n      void main() {\n        float value = getAAtOutCoords();\n        if (isnan(value)) {\n          setOutput(value);\n          return;\n        }\n\n        setOutput(clamp(value, minVal, maxVal));\n      }\n    "}}class CP{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=e,this.userCode="\n      void main() {\n        vec4 value = getAAtOutCoords();\n\n        if (any(isnan(value))) {\n          setOutput(value);\n          return;\n        }\n\n        setOutput(clamp(value, vec4(minVal), vec4(maxVal)));\n      }\n    "}}const TP={kernelName:bs,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{clipValueMin:o,clipValueMax:s}=a;let i;i=Vo().getBool("WEBGL_PACK_CLIP")?new CP(r.shape):new NP(r.shape);const c=[[o],[s]];return n.runWebGLProgram(i,[r],r.dtype,c)}};class EP{constructor(e){this.variableNames=["real","imag"],this.outputShape=e,this.userCode="\n      void main() {\n        float re = abs(getRealAtOutCoords());\n        float im = abs(getImagAtOutCoords());\n        float mx = max(re, im);\n\n        // sadly the length function in glsl is not underflow-safe\n        // (at least not on Intel GPUs). So the safe solution is\n        // to ensure underflow-safety in all cases.\n        setOutput(\n          mx == 0.0 ? 0.0 : mx * length(vec2(1, min(re, im)/mx))\n        );\n      }\n    "}}function RP(e,t){return{dataId:t.dataId,dtype:t.dtype,shape:e.shape}}const _P={kernelName:xs,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{x:a}=t,r=n.texData.get(a.dataId),o=new EP(a.shape),s=[RP(a,r.complexTensorInfos.real),RP(a,r.complexTensorInfos.imag)];return n.runWebGLProgram(o,s,s[0].dtype)}};class AP{constructor(e){this.outputShape=[],this.outputShape=Gm(e,1),this.variableNames=e.map(((e,t)=>"T".concat(t)));const t=new Array(e.length-1);t[0]=e[0][1];for(let o=1;o<t.length;o++)t[o]=t[o-1]+e[o][1];const n=["if (yC < ".concat(t[0],") setOutput(getT0(yR, yC));")];for(let o=1;o<t.length;o++){const e=t[o-1];n.push("else if (yC < ".concat(t[o],") ")+"setOutput(getT".concat(o,"(yR, yC-").concat(e,"));"))}const a=t.length,r=t[t.length-1];n.push("else setOutput(getT".concat(a,"(yR, yC-").concat(r,"));")),this.userCode="\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int yR = coords.x;\n        int yC = coords.y;\n\n        ".concat(n.join("\n        "),"\n      }\n    ")}}class FP{constructor(e,t){this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[],this.outputShape=Gm(e,t);const n=this.outputShape,a=n.length,r=zO(a),o=sM("coords",a),s=["x","y","z","w","u","v"].slice(0,a);this.variableNames=e.map(((e,t)=>"T".concat(t)));const i=new Array(e.length-1);i[0]=e[0][t];for(let f=1;f<i.length;f++)i[f]=i[f-1]+e[f][t];const c=s[t],l=s.slice(-2),u=s.join();let d="if (".concat(c," < ").concat(i[0],") {\n        return getChannel(\n            getT0(").concat(u,"), vec2(").concat(l.join(),"));\n        }");for(let f=1;f<i.length;f++){const e=i[f-1];d+="\n        if (".concat(c," < ").concat(i[f],"  && ").concat(c," >= ").concat(i[f-1],") {\n          return getChannel(\n            getT").concat(f,"(").concat(OP(s,c,e),"),\n            vec2(").concat(OP(l,c,e),"));\n        }")}const h=i.length,p=i[i.length-1];d+="\n        return getChannel(\n          getT".concat(h,"(").concat(OP(s,c,p),"),\n          vec2(").concat(OP(l,c,p),"));"),this.userCode="\n      float getValue(".concat(s.map((e=>"int "+e)),") {\n        ").concat(d,"\n      }\n\n      void main() {\n        ").concat(r," coords = getOutputCoords();\n        vec4 result = vec4(getValue(").concat(o,"), 0., 0., 0.);\n\n        ").concat(o[a-1]," = ").concat(o[a-1]," + 1;\n        if (").concat(o[a-1]," < ").concat(n[a-1],") {\n          result.g = getValue(").concat(o,");\n        }\n\n        ").concat(o[a-2]," = ").concat(o[a-2]," + 1;\n        if (").concat(o[a-2]," < ").concat(n[a-2],") {\n          result.a = getValue(").concat(o,");\n        }\n\n        ").concat(o[a-1]," = ").concat(o[a-1]," - 1;\n        if (").concat(o[a-2]," < ").concat(n[a-2]," &&\n            ").concat(o[a-1]," < ").concat(n[a-1],") {\n          result.b = getValue(").concat(o,");\n        }\n        setOutput(result);\n      }\n    ")}}function OP(e,t,n){const a=e.indexOf(t),r=e.map(((e,t)=>t===a?"".concat(e," - ").concat(n):e));return r.join()}function DP(e){const{inputs:t,backend:n}=e,{input:a}=t;return PM({inputs:{x:n.texData.get(a.dataId).complexTensorInfos.imag},backend:n})}const MP={kernelName:li,backendName:"webgl",kernelFunc:DP};function LP(e,t,n){const a=e[0].dtype;if("complex64"===a){const a=e.map((e=>yP({inputs:{input:e},backend:n}))),r=e.map((e=>DP({inputs:{input:e},backend:n}))),o=LP(a,t,n),s=LP(r,t,n),i=BM({inputs:{real:o,imag:s},backend:n});return a.forEach((e=>n.disposeIntermediateTensorInfo(e))),r.forEach((e=>n.disposeIntermediateTensorInfo(e))),n.disposeIntermediateTensorInfo(o),n.disposeIntermediateTensorInfo(s),i}let r=n.shouldExecuteOnCPU(e);if("string"===a&&(r=!0),r){const r=e.map((e=>{const a=lo(e.shape.slice(t));return aL({inputs:{x:e},backend:n,attrs:{shape:[-1,a]}})})),o=r.map((e=>({vals:n.readSync(e.dataId),shape:e.shape}))),s=Gm(r.map((e=>e.shape)),1),i=1===r[0].shape[0],c=gD(o,s,a,i),l=Gm(e.map((e=>e.shape)),t),u=n.makeTensorInfo(l,a,c);return r.forEach((e=>n.disposeIntermediateTensorInfo(e))),u}const o=e.filter((e=>lo(e.shape)>0)),s=Vo().getBool("WEBGL_PACK_ARRAY_OPERATIONS")&&o[0].shape.length>1;if(1===o.length){const t=s?new pM(e[0].shape,vM):new TM(e[0].shape,vM);return n.runWebGLProgram(t,e,a)}const i=Vo().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER");if(o.length>i){const e=[];for(let r=0;r<o.length;r+=i){const a=o.slice(r,r+i);e.push(LP(a,t,n))}const a=LP(e,t,n);for(const t of e)n.disposeIntermediateTensorInfo(t);return a}if(s){const e=new FP(o.map((e=>e.shape)),t);return n.runWebGLProgram(e,o,a)}const{tensors2D:c,outShape:l}=function(e,t,n){const a=Gm(e.map((e=>e.shape)),t),r=e.map((e=>aL({inputs:{x:e},attrs:{shape:[-1,lo(e.shape.slice(t))]},backend:n})));return{tensors2D:r,outShape:a}}(o,t,n),u=new AP(c.map((e=>e.shape))),d=n.runWebGLProgram(u,c,a);c.forEach((e=>n.disposeIntermediateTensorInfo(e)));const h=aL({inputs:{x:d},attrs:{shape:l},backend:n});return n.disposeIntermediateTensorInfo(d),h}function PP(e){const{inputs:t,backend:n,attrs:a}=e,{axis:r}=a,o=bo(r,t[0].shape)[0],s=t.map((e=>e.shape));Um(s,o);const i=Gm(t.map((e=>e.shape)),o);if(0===lo(i))return n.makeTensorInfo(i,t[0].dtype,[]);const c=t.filter((e=>lo(e.shape)>0));return 1===c.length?PM({inputs:{x:c[0]},backend:n}):LP(c,o,n)}const zP={kernelName:vs,backendName:"webgl",kernelFunc:PP};class BP{constructor(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1],n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null,a=arguments.length>3&&void 0!==arguments[3]&&arguments[3],r=arguments.length>4&&void 0!==arguments[4]&&arguments[4];this.variableNames=["x","W"],this.outputShape=e.outShape;const o=e.padInfo.top,s=e.padInfo.left,i=e.strideHeight,c=e.strideWidth,l=e.dilationHeight,u=e.dilationWidth,d=e.filterHeight,h=e.filterWidth,p=4*Math.floor(e.inChannels/4),f=e.inChannels%4,m="channelsLast"===e.dataFormat,g=m?1:2,b=m?2:3,y=m?3:1;let x="",v="";n&&(x=a?"float activation(float a) {\n          float b = getPreluActivationWeightsAtOutCoords();\n          ".concat(n,"\n        }"):r?"float activation(float a) {\n          float b = getLeakyreluAlphaAtOutCoords();\n          ".concat(n,"\n        }"):"\n          float activation(float x) {\n            ".concat(n,"\n          }\n        "),v="result = activation(result);");const w=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),a&&this.variableNames.push("preluActivationWeights"),r&&this.variableNames.push("leakyreluAlpha"),this.userCode="\n      ".concat(x,"\n\n      const ivec2 strides = ivec2(").concat(i,", ").concat(c,");\n      const ivec2 pads = ivec2(").concat(o,", ").concat(s,");\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d2 = coords[").concat(y,"];\n\n        ivec2 xRCCorner =\n            ivec2(coords[").concat(g,"], coords[").concat(b,"]) * strides - pads;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // Convolve x(?, ?, d1) with w(:, :, d1, d2) to get y(yR, yC, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ").concat(d,"; wR++) {\n          int xR = xRCorner + wR * ").concat(l,";\n\n          if (xR < 0 || xR >= ").concat(e.inHeight,") {\n            continue;\n          }\n\n          for (int wC = 0; wC < ").concat(h,"; wC++) {\n            int xC = xCCorner + wC * ").concat(u,";\n\n            if (xC < 0 || xC >= ").concat(e.inWidth,") {\n              continue;\n            }\n\n            for (int d1 = 0; d1 < ").concat(p,"; d1 += 4) {\n              vec4 wValues = vec4(\n                getW(wR, wC, d1, d2),\n                getW(wR, wC, d1 + 1, d2),\n                getW(wR, wC, d1 + 2, d2),\n                getW(wR, wC, d1 + 3, d2)\n              );\n\n              if (").concat(m,") {\n                vec4 xValues = vec4(\n                  getX(batch, xR, xC, d1),\n                  getX(batch, xR, xC, d1 + 1),\n                  getX(batch, xR, xC, d1 + 2),\n                  getX(batch, xR, xC, d1 + 3)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec4 xValues = vec4(\n                  getX(batch, d1, xR, xC),\n                  getX(batch, d1 + 1, xR, xC),\n                  getX(batch, d1 + 2, xR, xC),\n                  getX(batch, d1 + 3, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n            }\n\n            if (").concat(1===f,") {\n\n              if (").concat(m,") {\n                dotProd +=\n                    getX(batch, xR, xC, ").concat(p,") *\n                    getW(wR, wC, ").concat(p,", d2);\n              } else {\n                dotProd +=\n                    getX(batch, ").concat(p,", xR, xC) *\n                    getW(wR, wC, ").concat(p,", d2);\n              }\n\n            } else if (").concat(2===f,") {\n              vec2 wValues = vec2(\n                getW(wR, wC, ").concat(p,", d2),\n                getW(wR, wC, ").concat(p," + 1, d2)\n              );\n\n              if (").concat(m,") {\n                vec2 xValues = vec2(\n                  getX(batch, xR, xC, ").concat(p,"),\n                  getX(batch, xR, xC, ").concat(p," + 1)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec2 xValues = vec2(\n                  getX(batch, ").concat(p,", xR, xC),\n                  getX(batch, ").concat(p," + 1, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n\n            } else if (").concat(3===f,") {\n              vec3 wValues = vec3(\n                getW(wR, wC, ").concat(p,", d2),\n                getW(wR, wC, ").concat(p," + 1, d2),\n                getW(wR, wC, ").concat(p," + 2, d2)\n              );\n\n              if (").concat(m,") {\n                vec3 xValues = vec3(\n                  getX(batch, xR, xC, ").concat(p,"),\n                  getX(batch, xR, xC, ").concat(p," + 1),\n                  getX(batch, xR, xC, ").concat(p," + 2)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec3 xValues = vec3(\n                  getX(batch, ").concat(p,", xR, xC),\n                  getX(batch, ").concat(p," + 1, xR, xC),\n                  getX(batch, ").concat(p," + 2, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n\n            }\n          }\n        }\n\n        float result = dotProd;\n        ").concat(w,"\n        ").concat(v,"\n        setOutput(result);\n      }\n    ")}}class WP{constructor(e){this.variableNames=["x","W"],this.outputShape=e.outShape;const t=e.padInfo.front,n=e.padInfo.top,a=e.padInfo.left,r=e.strideDepth,o=e.strideHeight,s=e.strideWidth,i=e.dilationDepth,c=e.dilationHeight,l=e.dilationWidth,u=e.filterDepth,d=e.filterHeight,h=e.filterWidth,p=4*Math.floor(e.inChannels/4),f=e.inChannels%4;this.userCode="\n      const ivec3 strides = ivec3(".concat(r,", ").concat(o,", ").concat(s,");\n      const ivec3 pads = ivec3(").concat(t,", ").concat(n,", ").concat(a,");\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int d2 = coords.u;\n\n        ivec3 xFRCCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n        int xFCorner = xFRCCorner.x;\n        int xRCorner = xFRCCorner.y;\n        int xCCorner = xFRCCorner.z;\n\n        // Convolve x(?, ?, ?, d1) with w(:, :, :, d1, d2) to get\n        // y(yF, yR, yC, d2). ? = to be determined. : = across all\n        // values in that axis.\n        float dotProd = 0.0;\n        for (int wF = 0; wF < ").concat(u,"; wF++) {\n          int xF = xFCorner + wF * ").concat(i,";\n\n          if (xF < 0 || xF >= ").concat(e.inDepth,") {\n            continue;\n          }\n\n          for (int wR = 0; wR < ").concat(d,"; wR++) {\n            int xR = xRCorner + wR * ").concat(c,";\n\n            if (xR < 0 || xR >= ").concat(e.inHeight,") {\n              continue;\n            }\n\n            for (int wC = 0; wC < ").concat(h,"; wC++) {\n              int xC = xCCorner + wC * ").concat(l,";\n\n              if (xC < 0 || xC >= ").concat(e.inWidth,") {\n                continue;\n              }\n\n              for (int d1 = 0; d1 < ").concat(p,"; d1 += 4) {\n                vec4 xValues = vec4(\n                  getX(batch, xF, xR, xC, d1),\n                  getX(batch, xF, xR, xC, d1 + 1),\n                  getX(batch, xF, xR, xC, d1 + 2),\n                  getX(batch, xF, xR, xC, d1 + 3)\n                );\n                vec4 wValues = vec4(\n                  getW(wF, wR, wC, d1, d2),\n                  getW(wF, wR, wC, d1 + 1, d2),\n                  getW(wF, wR, wC, d1 + 2, d2),\n                  getW(wF, wR, wC, d1 + 3, d2)\n                );\n\n                dotProd += dot(xValues, wValues);\n              }\n\n              if (").concat(1===f,") {\n                dotProd +=\n                  getX(batch, xF, xR, xC, ").concat(p,") *\n                  getW(wF, wR, wC, ").concat(p,", d2);\n              } else if (").concat(2===f,") {\n                vec2 xValues = vec2(\n                  getX(batch, xF, xR, xC, ").concat(p,"),\n                  getX(batch, xF, xR, xC, ").concat(p," + 1)\n                );\n                vec2 wValues = vec2(\n                  getW(wF, wR, wC, ").concat(p,", d2),\n                  getW(wF, wR, wC, ").concat(p," + 1, d2)\n                );\n                dotProd += dot(xValues, wValues);\n              } else if (").concat(3===f,") {\n                vec3 xValues = vec3(\n                  getX(batch, xF, xR, xC, ").concat(p,"),\n                  getX(batch, xF, xR, xC, ").concat(p," + 1),\n                  getX(batch, xF, xR, xC, ").concat(p," + 2)\n                );\n                vec3 wValues = vec3(\n                  getW(wF, wR, wC, ").concat(p,", d2),\n                  getW(wF, wR, wC, ").concat(p," + 1, d2),\n                  getW(wF, wR, wC, ").concat(p," + 2, d2)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    ")}}class VP{constructor(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1],n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null,a=arguments.length>3&&void 0!==arguments[3]&&arguments[3],r=arguments.length>4&&void 0!==arguments[4]&&arguments[4];this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=jO(this.outputShape.length);const o=e.padInfo.left,s=e.strideWidth,i=e.dilationWidth,c=e.filterHeight,l=e.filterWidth,u=l;let d="\n       int xR; int xC; int xCOffset;\n       vec4 wTexel; vec4 previous; vec4 final;";for(let m=0;m<l;m++)d+="\n           vec4 xTexelC".concat(2*m,";\n           int xTexelC").concat(2*m,"Ready;\n           vec4 xTexelC").concat(2*m+1,";\n           int xTexelC").concat(2*m+1,"Ready;\n           vec4 xC").concat(m,";");d+="\n     for (int r = 0; r < ".concat(c,"; r++) {\n      for (int d1 = 0; d1 < ").concat(e.inChannels,"; d1 += 2) {\n       ");for(let m=0;m<l;m++)d+="\n           xTexelC".concat(2*m," = vec4(0.0);\n           xTexelC").concat(2*m,"Ready = 0;\n           xTexelC").concat(2*m+1," = vec4(0.0);\n           xTexelC").concat(2*m+1,"Ready = 0;\n           xC").concat(m," = vec4(0.0);");d+="\n         xR = xRCorner + r * dilations[0];\n         if (xR >=0 && xR < inDims[0]) {\n       ";for(let m=0;m<(u+1)/2;m++){const t=2*m;if(d+="\n           xC = xCCorner + ".concat(t*i,";\n           "),1===s){if(t<l&&(o%2===1?(d+="\n                 xCOffset = xC + 1;\n                 if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC".concat(t,"Ready == 0) {\n                   xTexelC").concat(t," = getX(batch, xR, xCOffset, d1);\n\n                   // Need to manually clear unused channels in case\n                   // we're reading from recycled texture.\n                   if (xCOffset + 1 >= inDims[1]) {\n                     xTexelC").concat(t,".zw = vec2(0.0);\n                   }\n                   xTexelC").concat(t,"Ready = 1;\n                 }\n               "),d+=1===i&&t>0?"\n                 xC".concat(t," = vec4(xTexelC").concat(t-2,".zw, xTexelC").concat(t,".xy);\n                 "):"\n                   xCOffset = xC + 1 - 2;\n\n                   if (xCOffset >= 0 && xCOffset < inDims[1]) {\n                     previous = getX(batch, xR, xCOffset, d1);\n\n                     // Need to manually clear unused channels in case\n                     // we're reading from recycled texture.\n                     if (xCOffset + 1 >= inDims[1]) {\n                       previous.zw = vec2(0.0);\n                     }\n\n                     xC".concat(t," = vec4(previous.zw, xTexelC").concat(t,".xy);\n                   } else {\n                     xC").concat(t," = vec4(0.0, 0.0, xTexelC").concat(t,".xy);\n                   }\n                   ")):d+="\n                 if (xC >= 0 && xC < inDims[1] && xTexelC".concat(t,"Ready == 0) {\n                   xTexelC").concat(t," = getX(batch, xR, xC, d1);\n                   if (xC + 1 >= inDims[1]) {\n                     xTexelC").concat(t,".zw = vec2(0.0);\n                   }\n                   xTexelC").concat(t,"Ready = 1;\n                 }\n\n                 xC").concat(t," = xTexelC").concat(t,";\n                 "),t+1<l)){const e=o%2===0?ro(i):i;i%2===0&&o%2===1||i%2!==0&&o%2!==1?(d+="\n                   xCOffset = xC + imod(pads[1], 2) + ".concat(e,";\n\n                   if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC").concat(t+1,"Ready == 0) {\n                     xTexelC").concat(t+1," = getX(batch, xR, xCOffset, d1);\n\n                     // Need to manually clear unused channels in case\n                     // we're reading from recycled texture.\n                     if (xCOffset + 1 >= inDims[1]) {\n                       xTexelC").concat(t+1,".zw = vec2(0.0);\n                     }\n                     xTexelC").concat(t+1,"Ready = 1;\n                   }\n                   "),d+=i>1?"\n                     xCOffset -= 2;\n                     if (xCOffset >= 0 && xCOffset < inDims[1]) {\n                      previous = getX(batch, xR, xCOffset, d1);\n                      xC".concat(t+1," = vec4(previous.zw, xTexelC").concat(t+1,".xy);\n                     } else {\n                      xC").concat(t+1," = vec4(0.0, 0.0, xTexelC").concat(t+1,".xy);\n                     }\n                     "):"\n                     xC".concat(t+1," = vec4(xTexelC").concat(t,".zw, xTexelC").concat(t+1,".xy);\n                     ")):d+=1===e?"\n                     xC".concat(t+1," = xTexelC").concat(t,";\n                     "):"\n                     xCOffset = xC + ".concat(e,";\n\n                     if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC").concat(t+1,"Ready == 0) {\n                       xTexelC").concat(t+1," = getX(batch, xR, xCOffset, d1);\n                       if (xCOffset + 1 >= inDims[1]) {\n                         xTexelC").concat(t+1,".zw = vec2(0.0);\n                       }\n                       xTexelC").concat(t+1,"Ready = 1;\n                     }\n\n                     xC").concat(t+1," = xTexelC").concat(t+1,";\n                     ")}}else t<l&&(o%2===1?(d+="\n                 xCOffset = xC + 1 - strides[1];\n                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC".concat(t,"Ready == 0) {\n                   xTexelC").concat(t," = getX(batch, xR, xCOffset, d1);\n                   // Need to manually clear unused channels in case\n                   // we're reading from recycled texture.\n                   if (xCOffset + 1 >= inDims[1]) {\n                     xTexelC").concat(t,".zw = vec2(0.0);\n                   }\n                   xTexelC").concat(t,"Ready = 1;\n                 }\n\n                 if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC").concat(t+1,"Ready == 0) {\n                   xTexelC").concat(t+1," = getX(batch, xR, xC + 1, d1);\n                   // Need to manually clear unused channels in case\n                   // we're reading from recycled texture.\n                   if (xC + 2 >= inDims[1]) {\n                     xTexelC").concat(t+1,".zw = vec2(0.0);\n                   }\n                   xTexelC").concat(t+1,"Ready = 1;\n                 }\n\n                 xC").concat(t," = vec4(xTexelC").concat(t,".zw, xTexelC").concat(t+1,".zw);\n               "),t+1<l&&(d+="\n                   final = vec4(0.0);\n                   xCOffset = xC + 1 + strides[1];\n                   if(xCOffset >= 0 && xCOffset < inDims[1]) {\n                     final = getX(batch, xR, xCOffset, d1);\n                   }\n                   xC".concat(t+1," = vec4(xTexelC").concat(t+1,".xy, final.xy);\n                 "))):(d+="\n                 if(xC >= 0 && xC < inDims[1] && xTexelC".concat(t,"Ready == 0) {\n                   xTexelC").concat(t," = getX(batch, xR, xC, d1);\n                   if (xC + 1 >= inDims[1]) {\n                     xTexelC").concat(t,".zw = vec2(0.0);\n                   }\n                   xTexelC").concat(t,"Ready = 1;\n                 }\n\n                 xCOffset = xC + strides[1];\n                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC").concat(t+1,"Ready == 0) {\n                   xTexelC").concat(t+1," = getX(batch, xR, xCOffset, d1);\n                   if (xCOffset + 1 >= inDims[1]) {\n                     xTexelC").concat(t+1,".zw = vec2(0.);\n                   }\n                   xTexelC").concat(t+1,"Ready = 1;\n                 }\n\n                 xC").concat(t," = vec4(\n                   xTexelC").concat(t,".xy, xTexelC").concat(t+1,".xy);\n               "),t+1<l&&(d+="\n                   xC".concat(t+1," = vec4(xTexelC").concat(t,".zw, xTexelC").concat(t+1,".zw);\n                 "))));t<l&&(d+="\n             wTexel = getW(r, ".concat(t,", d1, d2);\n             dotProd += xC").concat(t,".xxzz * vec4(wTexel.xy, wTexel.xy);\n             if(d1 + 1 < ").concat(e.inChannels,") {\n               dotProd += xC").concat(t,".yyww * vec4(wTexel.zw, wTexel.zw);\n             }\n           "),t+1<l&&(d+="\n               wTexel = getW(r, ".concat(t+1,", d1, d2);\n               dotProd += xC").concat(t+1,".xxzz * vec4(wTexel.xy, wTexel.xy);\n               if(d1 + 1 < ").concat(e.inChannels,") {\n                 dotProd += xC").concat(t+1,".yyww * vec4(wTexel.zw, wTexel.zw);\n               }\n             ")))}d+="\n     }\n   ",d+="\n     }\n   ",d+="\n     }\n   ";let h="",p="";n&&(h=a?"vec4 activation(vec4 a) {\n           vec4 b = getPreluActivationWeightsAtOutCoords();\n           ".concat(n,"\n         }"):r?"vec4 activation(vec4 a) {\n           vec4 b = getLeakyreluAlphaAtOutCoords();\n           ".concat(n,"\n         }"):"vec4 activation(vec4 x) {\n           ".concat(n,"\n         }"),p="result = activation(result);");const f=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),a&&this.variableNames.push("preluActivationWeights"),r&&this.variableNames.push("leakyreluAlpha"),this.userCode="\n       ".concat(h,"\n\n       void main() {\n         ivec4 coords = getOutputCoords();\n         int batch = coords.x;\n         ivec2 xRCCorner = coords.yz * strides - pads;\n         int d2 = coords.w;\n         int xRCorner = xRCCorner.x;\n         int xCCorner = xRCCorner.y;\n\n         //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.\n         vec4 dotProd = vec4(0.000000000000001);\n\n         ").concat(d,"\n\n         vec4 result = dotProd - vec4(0.000000000000001);\n         ").concat(f,"\n         ").concat(p,"\n         setOutput(result);\n       }\n     ")}}class UP{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec4"},{name:"pad",type:"ivec2"},{name:"stride",type:"ivec2"},{name:"dilation",type:"ivec2"},{name:"inChannels",type:"int"},{name:"itemsPerBlockRow",type:"int"},{name:"outWidth",type:"int"}],this.outputShape=e,this.enableShapeUniforms=jO(this.outputShape.length);const{dataFormat:n}=t,a=kO(),r="channelsLast"===n,o=r?1:2,s=r?2:3,i=this.enableShapeUniforms?"if(blockIndex < outShape[2] && pos < outShape[1]) {":"if(blockIndex < ".concat(e[2]," && pos < ").concat(e[1],") {");let c="";for(let l=0;l<=1;l++)for(let e=0;e<=1;e++)c+="\n          blockIndex = rc.z + ".concat(e,";\n          pos = rc.y + ").concat(l,";\n\n          ").concat(i,"\n            offsetY = int(blockIndex / outWidth) * stride[0] - pad[0];\n            d0 = offsetY + dilation[0] * (pos / itemsPerBlockRow);\n\n            if(d0 < inputShape[").concat(o,"] && d0 >= 0) {\n              // Use custom imod instead mod. On Intel GPU, mod may generate\n              // unexpected value.\n              // https://github.com/tensorflow/tfjs/issues/5447\n              offsetX = imod(blockIndex, outWidth) * stride[1] - pad[1];\n              d1 = offsetX + dilation[1] * (imod(pos, itemsPerBlockRow) /\n                  inChannels);\n\n              if(d1 < inputShape[").concat(s,"] && d1 >= 0) {\n\n                ch = imod(pos, inChannels);\n\n                if (").concat(r,") {\n                  innerDims = vec2(d1, ch);\n                  result[").concat(2*l+e,"] = getChannel(\n                    getA(rc.x, d0, int(innerDims.x),\n                    int(innerDims.y)), innerDims);\n                } else {\n                  innerDims = vec2(d0, d1);\n                  result[").concat(2*l+e,"] = getChannel(\n                    getA(rc.x, ch, int(innerDims.x),\n                    int(innerDims.y)), innerDims);\n                }\n              }\n            }\n          }\n        ");this.userCode="\n      void main() {\n        ivec3 rc = getOutputCoords();\n\n        vec4 result = vec4(0);\n\n        int blockIndex, pos, offsetY, d0, offsetX, d1, ch;\n        vec2 innerDims;\n\n        ".concat(c,"\n\n        ").concat(a.output," = result;\n      }\n    ")}}function GP(e,t){const n=e.length;return n>=3?t?[...e.slice(0,-3),e[n-3]*e[n-2],e[n-1]]:[...e.slice(0,-3),e[n-3],e[n-2]*e[n-1]]:!t&&1===n&&e[0]>1?[e[0],1]:null}function HP(e){let{x:t,filter:n,convInfo:a,backend:r,bias:o=null,preluActivationWeights:s=null,leakyreluAlpha:i=0,activation:c=null}=e;const l=t.shape,u=r.texData.get(t.dataId),d=a.inChannels,h=l[0]*l[1]*l[2],p=a.outChannels,f="channelsLast"===a.dataFormat,m=!1;let g;const b=[];if(null!=s){const e=GP(s.shape,f);null!=e&&(s=aL({inputs:{x:s},backend:r,attrs:{shape:e}}),b.push(s))}if(null!=o){const e=GP(o.shape,f);null!=e&&(o=aL({inputs:{x:o},backend:r,attrs:{shape:e}}),b.push(o))}if(!((1===h||1===p)&&d>mL)&&u.isPacked&&f&&null!=u.texture&&l[2]%2!==0&&uo(u.shape.slice(-3),l.slice(-3))){const e=l[0]*l[1]*(l[2]+1),d={dataId:t.dataId,shape:[1,e,a.inChannels],dtype:t.dtype},h=u.shape;u.shape=u.shape.slice(),u.shape[u.shape.length-2]++,so(pO(u.shape,d.shape),(()=>"packed reshape ".concat(u.shape," to ").concat(d.shape," isn't free")));const p=aL({inputs:{x:n},backend:r,attrs:{shape:[1,a.inChannels,a.outChannels]}});b.push(p);const f=gL({a:d,b:p,backend:r,transposeA:false,transposeB:m,bias:o,activation:c,preluActivationWeights:s,leakyreluAlpha:i}),y=r.texData.get(f.dataId);so(y.isPacked,(()=>"batchMatMul result is expected to be packed")),u.shape=h,y.shape=a.outShape,g=PM({inputs:{x:f},backend:r}),g.shape=a.outShape,b.push(f)}else{const e=a.outHeight*a.outWidth,l=aL({inputs:{x:t},backend:r,attrs:{shape:f?[a.batchSize,e,a.inChannels]:[a.batchSize,a.inChannels,e]}}),u=aL({inputs:{x:n},backend:r,attrs:{shape:[1,a.inChannels,a.outChannels]}}),d=gL({a:f?l:u,b:f?u:l,transposeA:!f,transposeB:m,backend:r,bias:o,activation:c,preluActivationWeights:s,leakyreluAlpha:i});g=aL({inputs:{x:d},backend:r,attrs:{shape:a.outShape}}),b.push(l),b.push(u),b.push(d)}for(const y of b)r.disposeIntermediateTensorInfo(y);return g}function jP(e){let{x:t,filter:n,convInfo:a,backend:r,bias:o=null,preluActivationWeights:s=null,leakyreluAlpha:i=0,activation:c=null}=e;const{filterWidth:l,filterHeight:u,inChannels:d,outWidth:h,outHeight:p,dataFormat:f}=a,m="channelsLast"===f,g=l*u*d,b=p*h,y=[a.batchSize,g,b],x=[];if(null!=s){const e=GP(s.shape,m);null!=e&&(s=aL({inputs:{x:s},backend:r,attrs:{shape:e}}),x.push(s))}if(null!=o){const e=GP(o.shape,m);null!=e&&(o=aL({inputs:{x:o},backend:r,attrs:{shape:e}}),x.push(o))}const v=aL({inputs:{x:n},backend:r,attrs:{shape:[1,g,lo(n.shape)/g]}});x.push(v);const w=new UP(y,a),k=[t.shape,[a.padInfo.top,a.padInfo.left],[a.strideHeight,a.strideWidth],[a.dilationHeight,a.dilationWidth],[a.inChannels],[a.filterWidth*a.inChannels],[a.outWidth]],I=r.runWebGLProgram(w,[t],"float32",k),S=aL({inputs:{x:I},backend:r,attrs:{shape:y}});x.push(I),x.push(S);const N=null!=o,C=null!=s,T="leakyrelu"===c,E=c?QM(c,!0):null,R=new JM(m?S.shape:v.shape,m?v.shape:S.shape,m?[a.batchSize,b,a.outChannels]:[a.batchSize,a.outChannels,b],!0,!1,N,E,C,T),_=m?[S,v]:[v,S];if(o&&_.push(o),C&&_.push(s),T){const e=r.makeTensorInfo([],"float32",Rl(i,"float32"));_.push(e),x.push(e)}const A=r.runWebGLProgram(R,_,"float32"),F=aL({inputs:{x:A},backend:r,attrs:{shape:a.outShape}});x.push(A);for(const O of x)r.disposeIntermediateTensorInfo(O);return F}const KP={kernelName:ws,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r,filter:o}=t,{strides:s,pad:i,dataFormat:c,dilations:l,dimRoundingMode:u}=a,d=Xh(c),h=zh(r.shape,o.shape,s,l,i,u,!1,d);let p;if(1!==h.filterHeight||1!==h.filterWidth||1!==h.dilationHeight||1!==h.dilationWidth||1!==h.strideHeight||1!==h.strideWidth||"SAME"!==h.padInfo.type&&"VALID"!==h.padInfo.type)if(h.strideWidth<=2&&"channelsLast"===d&&Vo().getBool("WEBGL_EXP_CONV")){const e=new VP(h),t=[[h.padInfo.top,h.padInfo.left],[h.strideHeight,h.strideWidth],[h.dilationHeight,h.dilationWidth],[h.inHeight,h.inWidth]];p=n.runWebGLProgram(e,[r,o],"float32",t)}else if(Vo().getBool("WEBGL_CONV_IM2COL"))p=jP({x:r,filter:o,convInfo:h,backend:n});else{const e=new BP(h);p=n.runWebGLProgram(e,[r,o],"float32")}else p=HP({x:r,filter:o,convInfo:h,backend:n});const f=aL({inputs:{x:p},backend:n,attrs:{shape:h.outShape}});return n.disposeIntermediateTensorInfo(p),f}};class qP{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;const t=e.strideHeight,n=e.strideWidth,a=e.padInfo.top,r=e.padInfo.left,o="channelsLast"===e.dataFormat;this.userCode="\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int wR = coords.x;\n        int wC = coords.y;\n        int d1 = coords.z;\n        int d2 = coords.w;\n\n        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int b = 0; b < ".concat(e.batchSize,"; b++) {\n          for (int yR = 0; yR < ").concat(e.outHeight,"; yR++) {\n            int xR = wR + yR * ").concat(t," - ").concat(a,";\n\n            if (xR < 0 || xR >= ").concat(e.inHeight,") {\n              continue;\n            }\n\n            for (int yC = 0; yC < ").concat(e.outWidth,"; yC++) {\n              int xC = wC + yC * ").concat(n," - ").concat(r,";\n\n              if (xC < 0 || xC >= ").concat(e.inWidth,") {\n                continue;\n              }\n\n              ").concat(o?"float dyValue = getDy(b, yR, yC, d2);\n              float xValue = getX(b, xR, xC, d1);\n              dotProd += (xValue * dyValue);":"float dyValue = getDy(b, d2, yR, yC);\n              float xValue = getX(b, d1, xR, xC);\n              dotProd += (xValue * dyValue);","\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    ")}}class XP{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;const t=e.filterHeight,n=e.filterWidth,a=e.strideHeight,r=e.strideWidth,o="channelsLast"===e.dataFormat,s=t-1-e.padInfo.top,i=n-1-e.padInfo.left,c=o?1:2,l=o?2:3,u=o?3:1;this.userCode="\n      const ivec2 pads = ivec2(".concat(s,", ").concat(i,");\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[").concat(u,"];\n\n        ivec2 dyCorner = ivec2(coords[").concat(c,"], coords[").concat(l,"]) - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ").concat(t,"; wR++) {\n          float dyR = float(dyRCorner + wR) / ").concat(a,".0;\n\n          if (dyR < 0.0 || dyR >= ").concat(e.outHeight,".0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          int wRPerm = ").concat(t," - 1 - wR;\n\n          for (int wC = 0; wC < ").concat(n,"; wC++) {\n            float dyC = float(dyCCorner + wC) / ").concat(r,".0;\n\n            if (dyC < 0.0 || dyC >= ").concat(e.outWidth,".0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            int wCPerm = ").concat(n," - 1 - wC;\n\n            for (int d2 = 0; d2 < ").concat(e.outChannels,"; d2++) {\n\n              if (").concat(o,") {\n                float xValue = getDy(batch, idyR, idyC, d2);\n                float wValue = getW(wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              } else {\n                float xValue = getDy(batch, d2, idyR, idyC);\n                float wValue = getW(wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              }\n\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    ")}}class YP{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;const t=e.strideDepth,n=e.strideHeight,a=e.strideWidth,r=e.padInfo.front,o=e.padInfo.top,s=e.padInfo.left;this.userCode="\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int wF = coords.x;\n        int wR = coords.y;\n        int wC = coords.z;\n        int d1 = coords.w;\n        int d2 = coords.u;\n\n        float dotProd = 0.0;\n\n        for (int b = 0; b < ".concat(e.batchSize,"; b++) {\n          for (int yF = 0; yF < ").concat(e.outDepth,"; yF++) {\n            int xF = wF + yF * ").concat(t," - ").concat(r,";\n\n            if (xF < 0 || xF >= ").concat(e.inDepth,") {\n              continue;\n            }\n\n            for (int yR = 0; yR < ").concat(e.outHeight,"; yR++) {\n              int xR = wR + yR * ").concat(n," - ").concat(o,";\n\n              if (xR < 0 || xR >= ").concat(e.inHeight,") {\n                continue;\n              }\n\n              for (int yC = 0; yC < ").concat(e.outWidth,"; yC++) {\n                int xC = wC + yC * ").concat(a," - ").concat(s,";\n\n                if (xC < 0 || xC >= ").concat(e.inWidth,") {\n                  continue;\n                }\n\n                float dyValue = getDy(b, yF, yR, yC, d2);\n                float xValue = getX(b, xF, xR, xC, d1);\n                dotProd += (xValue * dyValue);\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    ")}}class QP{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;const t=e.filterDepth,n=e.filterHeight,a=e.filterWidth,r=e.strideDepth,o=e.strideHeight,s=e.strideWidth,i=t-1-e.padInfo.front,c=n-1-e.padInfo.top,l=a-1-e.padInfo.left;this.userCode="\n      const ivec3 pads = ivec3(".concat(i,", ").concat(c,", ").concat(l,");\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int d1 = coords.u;\n\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyFCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        float dotProd = 0.0;\n        for (int wF = 0; wF < ").concat(t,"; wF++) {\n          float dyF = float(dyFCorner + wF) / ").concat(r,".0;\n\n          if (dyF < 0.0 || dyF >= ").concat(e.outDepth,".0 || fract(dyF) > 0.0) {\n            continue;\n          }\n          int idyF = int(dyF);\n\n          int wFPerm = ").concat(t," - 1 - wF;\n\n          for (int wR = 0; wR < ").concat(n,"; wR++) {\n            float dyR = float(dyRCorner + wR) / ").concat(o,".0;\n\n            if (dyR < 0.0 || dyR >= ").concat(e.outHeight,".0 ||\n              fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            int wRPerm = ").concat(n," - 1 - wR;\n\n            for (int wC = 0; wC < ").concat(a,"; wC++) {\n              float dyC = float(dyCCorner + wC) / ").concat(s,".0;\n\n              if (dyC < 0.0 || dyC >= ").concat(e.outWidth,".0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              int wCPerm = ").concat(a," - 1 - wC;\n\n              for (int d2 = 0; d2 < ").concat(e.outChannels,"; d2++) {\n                float xValue = getDy(batch, idyF, idyR, idyC, d2);\n                float wValue = getW(wFPerm, wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    ")}}const JP={kernelName:ks,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r,dy:o}=t,{strides:s,pad:i,dataFormat:c,dimRoundingMode:l,filterShape:u}=a,d=Xh(c),h=zh(r.shape,u,s,1,i,l,!1,d),p=new qP(h);return n.runWebGLProgram(p,[r,o],"float32")}};class ZP{constructor(e){this.variableNames=["dy","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"strides",type:"vec2"}],this.outputShape=e.inShape,this.enableShapeUniforms=jO(this.outputShape.length);const t=e.filterHeight,n=e.filterWidth,a=t-1-e.padInfo.top,r=n-1-e.padInfo.left;this.userCode="\n      const ivec2 pads = ivec2(".concat(a,", ").concat(r,");\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[3];\n\n        ivec2 dyCorner = ivec2(coords[1], coords[2]) - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        vec4 result = vec4(0.);\n        for (int wR = 0; wR < ").concat(t,"; wR++) {\n          float dyR = float(dyRCorner + wR) / strides[0];\n          if (dyR < 0.0 || dyR >= ").concat(e.outHeight,".0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n          int wRPerm = ").concat(t," - 1 - wR;\n\n          for (int wC = 0; wC < ").concat(n,"; wC++) {\n            int wCPerm = ").concat(n," - 1 - wC;\n\n            float dyC = float(dyCCorner + wC) / strides[1];\n            bool idyCVal = (dyC >= 0.0) && (dyC < ").concat(e.outWidth,".0)\n              && (fract(dyC) == 0.0);\n            int idyC = int(dyC);\n\n            float dyC2 = float(dyCCorner + wC + 1) / strides[1];\n            bool idyCVal2 = (dyC2 >= 0.0) && (dyC2 < ").concat(e.outWidth,".0)\n              && (fract(dyC2) == 0.0);\n            int idyC2 = int(dyC2);\n\n            if (idyCVal && idyCVal2) {\n              for (int d2 = 0; d2 < ").concat(e.outChannels,"; d2 += 2) {\n                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);\n                vec4 dySample = getDy(batch, idyR, idyC, d2);\n                vec4 dySample2 = (idyC / 2 == idyC2 / 2) ?\n                  dySample : getDy(batch, idyR, idyC2, d2);\n\n                vec2 dyValue = mod(float(idyC), 2.) == 0. ?\n                  dySample.xy : dySample.zw;\n                result.xy += vec2(dot(dyValue, wValue.xy),\n                  dot(dyValue, wValue.zw));\n\n                dyValue = mod(float(idyC2), 2.) == 0. ?\n                  dySample2.xy : dySample2.zw;\n                result.zw += vec2(dot(dyValue, wValue.xy),\n                  dot(dyValue, wValue.zw));\n              }\n            } else if (idyCVal) {\n              for (int d2 = 0; d2 < ").concat(e.outChannels,"; d2 += 2) {\n                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);\n                vec4 dySample = getDy(batch, idyR, idyC, d2);\n                vec2 dyValue = mod(float(idyC), 2.) == 0. ?\n                  dySample.xy : dySample.zw;\n                result.xy += vec2(dot(dyValue, wValue.xy),\n                  dot(dyValue, wValue.zw));\n              }\n            } else if (idyCVal2) {\n              for (int d2 = 0; d2 < ").concat(e.outChannels,"; d2 += 2) {\n                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);\n                vec4 dySample = getDy(batch, idyR, idyC2, d2);\n                vec2 dyValue = mod(float(idyC2), 2.) == 0. ?\n                  dySample.xy : dySample.zw;\n                result.zw += vec2(dot(dyValue, wValue.xy),\n                  dot(dyValue, wValue.zw));\n              }\n            }\n          }\n        }\n        setOutput(result);\n      }\n    ")}}const $P={kernelName:Is,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{dy:r,filter:o}=t,{inputShape:s,strides:i,pad:c,dataFormat:l,dimRoundingMode:u}=a,d=Xh(l),h=zh(s,o.shape,i,1,c,u,!1,d);if(Vo().getBool("WEBGL_PACK_CONV2DTRANSPOSE")&&"channelsLast"===d){const e=[[h.strideHeight,h.strideWidth]],t=new ZP(h);return n.runWebGLProgram(t,[r,o],"float32",e)}{const e=new XP(h);return n.runWebGLProgram(e,[r,o],"float32")}}};const ez={kernelName:Ss,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r,filter:o}=t,{strides:s,pad:i,dilations:c}=a,l=Bh(r.shape,o.shape,s,c,i),u=new WP(l);return n.runWebGLProgram(u,[r,o],"float32")}};const tz={kernelName:Ns,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r,dy:o}=t,{strides:s,pad:i,filterShape:c}=a,l=Bh(r.shape,c,s,1,i),u=new YP(l);return n.runWebGLProgram(u,[r,o],"float32")}};const nz={kernelName:Cs,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{dy:r,filter:o}=t,{pad:s,strides:i,inputShape:c}=a,l=Bh(c,o.shape,i,1,s),u=new QP(l);return n.runWebGLProgram(u,[r,o],"float32")}},az=XM({opSnippet:qM+"\n  return cos(x);\n",packedOpSnippet:"\n  vec4 result = cos(x);\n  bvec4 isNaN = isnan(x);\n  ".concat(MM,"\n  return result;\n")}),rz={kernelName:Ts,backendName:"webgl",kernelFunc:az},oz=XM({opSnippet:"\n  float e2x = exp(-x);\n  return (e2x + 1.0 / e2x) / 2.0;\n"}),sz={kernelName:Es,backendName:"webgl",kernelFunc:oz};class iz{constructor(e,t,n,a,r){this.variableNames=["Image","Boxes","BoxInd"],this.outputShape=[];const[o,s,i,c]=e,[l]=t,[u,d]=n;this.outputShape=[l,u,d,c];const h="bilinear"===a?1:0,[p,f]=["".concat(s-1,".0"),"".concat(i-1,".0")],[m,g,b]=u>1?["".concat((s-1)/(u-1)),"(y2-y1) * height_ratio","y1*".concat(p," + float(y)*(height_scale)")]:["0.0","0.0","0.5 * (y1+y2) * ".concat(p)],[y,x,v]=d>1?["".concat((i-1)/(d-1)),"(x2-x1) * width_ratio","x1*".concat(f," + float(x)*(width_scale)")]:["0.0","0.0","0.5 * (x1+x2) * ".concat(f)];this.userCode="\n      const float height_ratio = float(".concat(m,");\n      const float width_ratio = float(").concat(y,");\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int y = coords[1];\n        int x = coords[2];\n        int d = coords[3];\n\n        // get box vals\n        float y1 = getBoxes(b,0);\n        float x1 = getBoxes(b,1);\n        float y2 = getBoxes(b,2);\n        float x2 = getBoxes(b,3);\n\n        // get image in batch index\n        int bInd = round(getBoxInd(b));\n        if(bInd < 0 || bInd >= ").concat(o,") {\n          return;\n        }\n\n        float height_scale = ").concat(g,";\n        float width_scale = ").concat(x,";\n\n        float in_y = ").concat(b,";\n        if( in_y < 0.0 || in_y > ").concat(p," ) {\n          setOutput(float(").concat(r,"));\n          return;\n        }\n        float in_x = ").concat(v,";\n        if( in_x < 0.0 || in_x > ").concat(f," ) {\n          setOutput(float(").concat(r,"));\n          return;\n        }\n\n        vec2 sourceFracIndexCR = vec2(in_x,in_y);\n        if(").concat(h," == 1) {\n          // Compute the four integer indices.\n          ivec2 sourceFloorCR = ivec2(sourceFracIndexCR);\n          ivec2 sourceCeilCR = ivec2(ceil(sourceFracIndexCR));\n\n          float topLeft = getImage(b, sourceFloorCR.y, sourceFloorCR.x, d);\n          float bottomLeft = getImage(b, sourceCeilCR.y, sourceFloorCR.x, d);\n          float topRight = getImage(b, sourceFloorCR.y, sourceCeilCR.x, d);\n          float bottomRight = getImage(b, sourceCeilCR.y, sourceCeilCR.x, d);\n\n          vec2 fracCR = sourceFracIndexCR - vec2(sourceFloorCR);\n\n          float top = topLeft + (topRight - topLeft) * fracCR.x;\n          float bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;\n          float newValue = top + (bottom - top) * fracCR.y;\n          setOutput(newValue);\n        } else {\n          // Compute the coordinators of nearest neighbor point.\n          ivec2 sourceNearestCR = ivec2(floor(\n            sourceFracIndexCR + vec2(0.5,0.5)));\n          float newValue = getImage(b, sourceNearestCR.y, sourceNearestCR.x, d);\n          setOutput(newValue);\n        }\n      }\n    ")}}const cz={kernelName:As,backendName:"webgl",kernelFunc:e=>{const{inputs:t,backend:n,attrs:a}=e,{image:r,boxes:o,boxInd:s}=t,{cropSize:i,method:c,extrapolationValue:l}=a,u=new iz(r.shape,o.shape,i,c,l);return n.runWebGLProgram(u,[r,o,s],"float32")}};var lz;!function(e){e.Prod="*",e.Sum="+"}(lz||(lz={}));class uz{constructor(e,t,n,a){this.op=e,this.outputShape=t,this.variableNames=["x"],this.customUniforms=[{name:"index",type:"float"}];const r=this.outputShape.length,o=this.op===lz.Prod?"1.0":"0.0",s=n?o:"getX(".concat(dz(r,"coords",this.op),")"),i=this.outputShape[this.outputShape.length-1];let c="",l="";n?(c=a?"end != ".concat(i-1):"end != 0",l=a?"end + 1":"end - 1"):(c=a?"end + pow2 < ".concat(i):"end >= pow2",l=a?"end + pow2":"end - pow2"),this.userCode="\n      void main() {\n        ".concat(zO(r)," coords = getOutputCoords();\n        int end = ").concat(hz(r,"coords",this.op),";\n        float val = ").concat(s,";\n        int pow2 = int(pow(2.0, index));\n        if (").concat(c,") {\n          int idx = ").concat(l,";\n          ").concat(hz(r,"coords",this.op)," = idx;\n          val ").concat(this.op,"= getX(").concat(dz(r,"coords",this.op),");\n        }\n        setOutput(val);\n      }\n    ")}}function dz(e,t,n){if(1===e)return"".concat(t);if(2===e)return"".concat(t,".x, ").concat(t,".y");if(3===e)return"".concat(t,".x, ").concat(t,".y, ").concat(t,".z");if(4===e)return"".concat(t,".x, ").concat(t,".y, ").concat(t,".z, ").concat(t,".w");throw new Error("Cumulative ".concat(n," for rank ").concat(e," is not yet supported"))}function hz(e,t,n){if(1===e)return"".concat(t);if(2===e)return"".concat(t,".y");if(3===e)return"".concat(t,".z");if(4===e)return"".concat(t,".w");throw new Error("Cumulative ".concat(n," for rank ").concat(e," is not yet supported"))}function pz(e,t,n,a,r,o){const s=t.shape.length,i=Wp([a],s);let c=t;null!=i&&(c=pL({inputs:{x:t},backend:n,attrs:{perm:i}}));const l=Up(1,s)[0];if(l!==s-1)throw new Error("WebGL cumprod shader expects an inner-most axis=".concat(t.shape.length-1," ")+"but got axis=".concat(a));const u=c.shape[l];let d=PM({inputs:{x:c},backend:n});for(let h=0;h<=Math.ceil(Math.log2(u))-1;h++){const t=new uz(e,c.shape,!1,o),a=[[h]],r=d;d=n.runWebGLProgram(t,[d],d.dtype,a),n.disposeIntermediateTensorInfo(r)}if(r){const t=new uz(e,c.shape,r,o),a=d;d=n.runWebGLProgram(t,[d],d.dtype),n.disposeIntermediateTensorInfo(a)}if(null!=i){const e=pL({inputs:{x:d},backend:n,attrs:{perm:Vp(i)}});return n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(c),e}return d}const fz={kernelName:Rs,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{axis:o,exclusive:s,reverse:i}=a;return pz(lz.Prod,r,n,o,s,i)}};const mz={kernelName:_s,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{axis:o,exclusive:s,reverse:i}=a;return pz(lz.Sum,r,n,o,s,i)}};const gz={kernelName:Fs,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r,weights:o}=t,{size:s,binaryOutput:i}=a;if(1===r.shape.length){const e=n.readSync(r.dataId),t=n.readSync(o.dataId),a=dD(e,t,o.dtype,o.shape,s);return n.makeTensorInfo([s],o.dtype,a)}if(2===r.shape.length){const e=n.bufferSync(r),t=n.bufferSync(o),a=hD(e,t,s,i);return n.makeTensorInfo(a.shape,o.dtype,a.values)}throw new Error("Error in denseBincount: input must be at most rank 2, but got rank"+"".concat(r.shape.length,"."))}};class bz{constructor(e,t,n){this.variableNames=["x"],this.outputShape=[],this.outputShape=e,this.blockSize=t,this.dataFormat=n,this.userCode="\n    void main() {\n      ivec4 coords = getOutputCoords();\n      int b = coords[0];\n      int h = ".concat(this.getHeightCoordString(),";\n      int w = ").concat(this.getWidthCoordString(),";\n      int d = ").concat(this.getDepthCoordString(),";\n\n      int in_h = h / ").concat(t,";\n      int offset_h = imod(h, ").concat(t,");\n      int in_w = w / ").concat(t,";\n      int offset_w = imod(w, ").concat(t,");\n      int offset_d = (offset_h * ").concat(t," + offset_w) *\n        ").concat(this.getOutputDepthSize(),";\n      int in_d = d + offset_d;\n\n      float result = ").concat(this.getInputSamplingString(),";\n      setOutput(result);\n    }\n  ")}getHeightCoordString(){return"NHWC"===this.dataFormat?"coords[1]":"coords[2]"}getWidthCoordString(){return"NHWC"===this.dataFormat?"coords[2]":"coords[3]"}getDepthCoordString(){return"NHWC"===this.dataFormat?"coords[3]":"coords[1]"}getOutputDepthSize(){return"NHWC"===this.dataFormat?this.outputShape[3]:this.outputShape[1]}getInputSamplingString(){return"NHWC"===this.dataFormat?"getX(b, in_h, in_w, in_d)":"getX(b, in_d, in_h, in_w)"}}const yz={kernelName:Os,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{blockSize:o,dataFormat:s}=a,i=r.shape[0],c=("NHWC"===s?r.shape[1]:r.shape[2])*o,l=("NHWC"===s?r.shape[2]:r.shape[3])*o,u=("NHWC"===s?r.shape[3]:r.shape[1])/(o*o),d=new bz("NHWC"===s?[i,c,l,u]:[i,u,c,l],o,s);return n.runWebGLProgram(d,[r],r.dtype)}};class xz{constructor(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1],n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null,a=arguments.length>3&&void 0!==arguments[3]&&arguments[3],r=arguments.length>4&&void 0!==arguments[4]&&arguments[4];this.variableNames=["x","W"],this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=jO(this.outputShape.length);const o=e.filterHeight,s=e.filterWidth,i=e.outChannels/e.inChannels;let c="",l="";n&&(c=a?"float activation(float a) {\n          float b = getPreluActivationWeightsAtOutCoords();\n          ".concat(n,"\n        }"):r?"float activation(float a) {\n          float b = getLeakyreluAlphaAtOutCoords();\n          ".concat(n,"\n        }"):"\n          float activation(float x) {\n            ".concat(n,"\n          }\n        "),l="result = activation(result);");const u=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),a&&this.variableNames.push("preluActivationWeights"),r&&this.variableNames.push("leakyreluAlpha"),this.userCode="\n      ".concat(c,"\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int d2 = coords.w;\n        int d1 = d2 / ").concat(i,";\n        int q = d2 - d1 * ").concat(i,";\n\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // Convolve x(?, ?, d1) with w(:, :, d1, q) to get y(yR, yC, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        // TO DO(dsmilkov): Flatten the two for loops and vec4 the operations.\n        for (int wR = 0; wR < ").concat(o,"; wR++) {\n          int xR = xRCorner + wR * dilations[0];\n\n          if (xR < 0 || xR >= inDims[0]) {\n            continue;\n          }\n\n          for (int wC = 0; wC < ").concat(s,"; wC++) {\n            int xC = xCCorner + wC * dilations[1];\n\n            if (xC < 0 || xC >= inDims[1]) {\n              continue;\n            }\n\n            float xVal = getX(batch, xR, xC, d1);\n            float wVal = getW(wR, wC, d1, q);\n            dotProd += xVal * wVal;\n          }\n        }\n\n        float result = dotProd;\n        ").concat(u,"\n        ").concat(l,"\n        setOutput(result);\n      }\n    ")}}class vz{constructor(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1],n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null,a=arguments.length>3&&void 0!==arguments[3]&&arguments[3],r=arguments.length>4&&void 0!==arguments[4]&&arguments[4];this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=jO(this.outputShape.length);const o=e.outChannels/e.inChannels,s=e.padInfo.left,i=e.strideWidth,c=e.dilationWidth,l=e.filterHeight,u=e.filterWidth,d=u;let h="\n      int xR; int xC; int xCOffset;\n      vec4 wTexel; vec4 previous; vec4 final;";for(let g=0;g<u;g++)h+="\n          vec4 xTexelC".concat(2*g,";\n          int xTexelC").concat(2*g,"Ready;\n          vec4 xTexelC").concat(2*g+1,";\n          int xTexelC").concat(2*g+1,"Ready;\n          vec4 xC").concat(g,";");h+="\n    for (int r = 0; r < ".concat(l,"; r++) {\n      ");for(let g=0;g<u;g++)h+="\n          xTexelC".concat(2*g," = vec4(0.0);\n          xTexelC").concat(2*g,"Ready = 0;\n          xTexelC").concat(2*g+1," = vec4(0.0);\n          xTexelC").concat(2*g+1,"Ready = 0;\n          xC").concat(g," = vec4(0.0);");h+="\n        xR = xRCorner + r * dilations[0];\n        if (xR >=0 && xR < inDims[0]) {\n      ";for(let g=0;g<(d+1)/2;g++){const e=2*g;if(h+="\n          xC = xCCorner + ".concat(e*c,";\n          "),1===i){if(e<u&&(s%2===1?(h+="\n                xCOffset = xC + 1;\n                if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC".concat(e,"Ready == 0) {\n                  xTexelC").concat(e," = getX(batch, xR, xCOffset, d1);\n\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if (xCOffset + 1 >= inDims[1]) {\n                    xTexelC").concat(e,".zw = vec2(0.0);\n                  }\n                  xTexelC").concat(e,"Ready = 1;\n                }\n              "),h+=1===c&&e>0?"\n                xC".concat(e," = vec4(xTexelC").concat(e-2,".zw, xTexelC").concat(e,".xy);\n                "):"\n                  xCOffset = xC + 1 - 2;\n\n                  if (xCOffset >= 0 && xCOffset < inDims[1]) {\n                    previous = getX(batch, xR, xCOffset, d1);\n\n                    // Need to manually clear unused channels in case\n                    // we're reading from recycled texture.\n                    if (xCOffset + 1 >= inDims[1]) {\n                      previous.zw = vec2(0.0);\n                    }\n\n                    xC".concat(e," = vec4(previous.zw, xTexelC").concat(e,".xy);\n                  } else {\n                    xC").concat(e," = vec4(0.0, 0.0, xTexelC").concat(e,".xy);\n                  }\n                  ")):h+="\n                if (xC >= 0 && xC < inDims[1] && xTexelC".concat(e,"Ready == 0) {\n                  xTexelC").concat(e," = getX(batch, xR, xC, d1);\n                  if (xC + 1 >= inDims[1]) {\n                    xTexelC").concat(e,".zw = vec2(0.0);\n                  }\n                  xTexelC").concat(e,"Ready = 1;\n                }\n\n                xC").concat(e," = xTexelC").concat(e,";\n                "),e+1<u)){const t=s%2===0?ro(c):c;c%2===0&&s%2===1||c%2!==0&&s%2!==1?(h+="\n                  xCOffset = xC + imod(pads[1], 2) + ".concat(t,";\n\n                  if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC").concat(e+1,"Ready == 0) {\n                    xTexelC").concat(e+1," = getX(batch, xR, xCOffset, d1);\n\n                    // Need to manually clear unused channels in case\n                    // we're reading from recycled texture.\n                    if (xCOffset + 1 >= inDims[1]) {\n                      xTexelC").concat(e+1,".zw = vec2(0.0);\n                    }\n                    xTexelC").concat(e+1,"Ready = 1;\n                  }\n                  "),h+=c>1?"\n                    xCOffset -= 2;\n                    if (xCOffset >= 0 && xCOffset < inDims[1]) {\n                     previous = getX(batch, xR, xCOffset, d1);\n                     xC".concat(e+1," = vec4(previous.zw, xTexelC").concat(e+1,".xy);\n                    } else {\n                     xC").concat(e+1," = vec4(0.0, 0.0, xTexelC").concat(e+1,".xy);\n                    }\n                    "):"\n                    xC".concat(e+1," = vec4(xTexelC").concat(e,".zw, xTexelC").concat(e+1,".xy);\n                    ")):h+=1===t?"\n                    xC".concat(e+1," = xTexelC").concat(e,";\n                    "):"\n                    xCOffset = xC + ".concat(t,";\n\n                    if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC").concat(e+1,"Ready == 0) {\n                      xTexelC").concat(e+1," = getX(batch, xR, xCOffset, d1);\n                      if (xCOffset + 1 >= inDims[1]) {\n                        xTexelC").concat(e+1,".zw = vec2(0.0);\n                      }\n                      xTexelC").concat(e+1,"Ready = 1;\n                    }\n\n                    xC").concat(e+1," = xTexelC").concat(e+1,";\n                    ")}}else e<u&&(s%2===1?(h+="\n                xCOffset = xC + 1 - strides[1];\n                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC".concat(e,"Ready == 0) {\n                  xTexelC").concat(e," = getX(batch, xR, xCOffset, d1);\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if (xCOffset + 1 >= inDims[1]) {\n                    xTexelC").concat(e,".zw = vec2(0.0);\n                  }\n                  xTexelC").concat(e,"Ready = 1;\n                }\n\n                if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC").concat(e+1,"Ready == 0) {\n                  xTexelC").concat(e+1," = getX(batch, xR, xC + 1, d1);\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if (xC + 2 >= inDims[1]) {\n                    xTexelC").concat(e+1,".zw = vec2(0.0);\n                  }\n                  xTexelC").concat(e+1,"Ready = 1;\n                }\n\n                xC").concat(e," = vec4(xTexelC").concat(e,".zw, xTexelC").concat(e+1,".zw);\n              "),e+1<u&&(h+="\n                  final = vec4(0.0);\n                  xCOffset = xC + 1 + strides[1];\n                  if(xCOffset >= 0 && xCOffset < inDims[1]) {\n                    final = getX(batch, xR, xCOffset, d1);\n                  }\n                  xC".concat(e+1," = vec4(xTexelC").concat(e+1,".xy, final.xy);\n                "))):(h+="\n                if(xC >= 0 && xC < inDims[1] && xTexelC".concat(e,"Ready == 0) {\n                  xTexelC").concat(e," = getX(batch, xR, xC, d1);\n                  if (xC + 1 >= inDims[1]) {\n                    xTexelC").concat(e,".zw = vec2(0.0);\n                  }\n                  xTexelC").concat(e,"Ready = 1;\n                }\n\n                xCOffset = xC + strides[1];\n                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC").concat(e+1,"Ready == 0) {\n                  xTexelC").concat(e+1," = getX(batch, xR, xCOffset, d1);\n                  if (xCOffset + 1 >= inDims[1]) {\n                    xTexelC").concat(e+1,".zw = vec2(0.);\n                  }\n                  xTexelC").concat(e+1,"Ready = 1;\n                }\n\n                xC").concat(e," = vec4(\n                  xTexelC").concat(e,".xy, xTexelC").concat(e+1,".xy);\n              "),e+1<u&&(h+="\n                  xC".concat(e+1," = vec4(xTexelC").concat(e,".zw, xTexelC").concat(e+1,".zw);\n                "))));e<u&&(h+="\n            wTexel = getW(r, ".concat(e,", d1, q);\n            dotProd += xC").concat(e," * vec4(wTexel.xz, wTexel.xz);\n          "),e+1<u&&(h+="\n              wTexel = getW(r, ".concat(e+1,", d1, q);\n              dotProd += xC").concat(e+1," * vec4(wTexel.xz, wTexel.xz);\n            ")))}h+="\n    }\n  ",h+="\n      }\n    ";let p="",f="";n&&(p=a?"vec4 activation(vec4 a) {\n          vec4 b = getPreluActivationWeightsAtOutCoords();\n          ".concat(n,"\n        }"):r?"vec4 activation(vec4 a) {\n          vec4 b = getLeakyreluAlphaAtOutCoords();\n          ".concat(n,"\n        }"):"vec4 activation(vec4 x) {\n          ".concat(n,"\n        }"),f="result = activation(result);");const m=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),a&&this.variableNames.push("preluActivationWeights"),r&&this.variableNames.push("leakyreluAlpha"),this.userCode="\n      ".concat(p,"\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int d2 = coords.w;\n        int d1 = d2 / ").concat(o,";\n        int q = d2 - d1 * ").concat(o,";\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.\n        vec4 dotProd = vec4(0.000000000000001);\n\n        ").concat(h,"\n\n        vec4 result = dotProd - vec4(0.000000000000001);\n        ").concat(m,"\n        ").concat(f,"\n        setOutput(result);\n      }\n    ")}}const wz={kernelName:Ds,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r,filter:o}=t,{strides:s,pad:i,dilations:c,dimRoundingMode:l}=a;let u=c;null==u&&(u=[1,1]),so(Kh(s,u),(()=>"Error in depthwiseConv2d: Either strides or dilations must be "+"1. Got strides ".concat(s," and dilations '").concat(u,"'")));const d=zh(r.shape,o.shape,s,u,i,l,!0);let h;h=Vo().getBool("WEBGL_PACK_DEPTHWISECONV")&&d.strideWidth<=2&&d.outChannels/d.inChannels===1?new vz(d):new xz(d);const p=[[d.padInfo.top,d.padInfo.left],[d.strideHeight,d.strideWidth],[d.dilationHeight,d.dilationWidth],[d.inHeight,d.inWidth]];return n.runWebGLProgram(h,[r,o],"float32",p)}};class kz{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;const t=e.strideHeight,n=e.strideWidth,a=e.padInfo.top,r=e.padInfo.left,o=e.outChannels/e.inChannels;this.userCode="\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int wR = coords.x;\n        int wC = coords.y;\n        int d1 = coords.z;\n        int dm = coords.w;\n        int d2 = d1 * ".concat(o," + dm;\n\n        float dotProd = 0.0;\n\n        // TO DO: Vec4 over the batch size\n        for (int b = 0; b < ").concat(e.batchSize,"; b++) {\n          for (int yR = 0; yR < ").concat(e.outHeight,"; yR++) {\n            int xR = wR + yR * ").concat(t," - ").concat(a,";\n\n            if (xR < 0 || xR >= ").concat(e.inHeight,") {\n              continue;\n            }\n\n            for (int yC = 0; yC < ").concat(e.outWidth,"; yC++) {\n              int xC = wC + yC * ").concat(n," - ").concat(r,";\n\n              if (xC < 0 || xC >= ").concat(e.inWidth,") {\n                continue;\n              }\n\n              float dyValue = getDy(b, yR, yC, d2);\n              float xValue = getX(b, xR, xC, d1);\n              dotProd += (xValue * dyValue);\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    ")}}class Iz{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;const t=e.filterHeight,n=e.filterWidth,a=e.strideHeight,r=e.strideWidth,o=t-1-e.padInfo.top,s=n-1-e.padInfo.left,i=e.outChannels/e.inChannels;this.userCode="\n      const ivec2 pads = ivec2(".concat(o,", ").concat(s,");\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[3];\n        ivec2 dyCorner = coords.yz - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        float dotProd = 0.0;\n\n        for (int wR = 0; wR < ").concat(t,"; wR++) {\n          float dyR = float(dyRCorner + wR) / ").concat(a,".0;\n\n          if (dyR < 0.0 || dyR >= ").concat(e.outHeight,".0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          int wRPerm = ").concat(t," - 1 - wR;\n\n          for (int wC = 0; wC < ").concat(n,"; wC++) {\n            float dyC = float(dyCCorner + wC) / ").concat(r,".0;\n\n            if (dyC < 0.0 || dyC >= ").concat(e.outWidth,".0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            int wCPerm = ").concat(n," - 1 - wC;\n\n            // TO DO: Vec4 over the channelMul\n            for (int dm = 0; dm < ").concat(i,"; dm++) {\n              int d2 = d1 * ").concat(i," + dm;\n              float xValue = getDy(batch, idyR, idyC, d2);\n              float wValue = getW(wRPerm, wCPerm, d1, dm);\n              dotProd += xValue * wValue;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    ")}}const Sz={kernelName:Ms,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r,dy:o}=t,{strides:s,dilations:i,pad:c,dimRoundingMode:l,filterShape:u}=a,d=zh(r.shape,u,s,i,c,l,!0),h=new kz(d);return n.runWebGLProgram(h,[r,o],"float32")}};const Nz={kernelName:Ls,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{dy:r,filter:o}=t,{strides:s,dilations:i,pad:c,dimRoundingMode:l,inputShape:u}=a,d=zh(u,o.shape,s,i,c,l,!0),h=new Iz(d);return n.runWebGLProgram(h,[r,o],"float32")}};class Cz{constructor(e){this.variableNames=["X"],this.outputShape=[e,e],this.userCode="\n      void main() {\n          ivec2 coords = getOutputCoords();\n          float val = coords[0] == coords[1] ? getX(coords[0]) : 0.0;\n          setOutput(val);\n      }\n    "}}const Tz={kernelName:Ps,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{x:a}=t,r=[...a.shape,...a.shape],o=lo(a.shape),s=aL({inputs:{x:a},backend:n,attrs:{shape:[o]}}),i=new Cz(o),c=n.runWebGLProgram(i,[s],s.dtype),l=aL({inputs:{x:c},backend:n,attrs:{shape:r}});return n.disposeIntermediateTensorInfo(s),n.disposeIntermediateTensorInfo(c),l}};class Ez{constructor(e){this.variableNames=["x","W"],this.outputShape=e.outShape;const{inHeight:t,inWidth:n,padInfo:a,strideHeight:r,strideWidth:o,filterHeight:s,filterWidth:i,dilationHeight:c,dilationWidth:l}=e,{top:u,left:d}=a;this.userCode="\n      const ivec2 strides = ivec2(".concat(r,", ").concat(o,");\n      const ivec2 pads = ivec2(").concat(u,", ").concat(d,");\n      const float neg_infinity = -3.4e38;\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        int d1 = coords.w;\n        ivec2 outTopLeftCorner =\n            coords.yz * strides - pads;\n        int hBeg = outTopLeftCorner.x;\n        int wBeg = outTopLeftCorner.y;\n\n        float curVal = neg_infinity;\n        for (int h = 0; h < ").concat(s,"; h++) {\n          int hIn = hBeg + h * ").concat(c,";\n\n          if (hIn >= 0 && hIn < ").concat(t,") {\n            for (int w = 0; w < ").concat(i,"; w++) {\n              int wIn = wBeg + w * ").concat(l,";\n\n              if (wIn >= 0 && wIn < ").concat(n,") {\n                float xVal = getX(batch, hIn, wIn, d1);\n                float wVal = getW(h, w, d1);\n\n                float val = xVal + wVal;\n                if (val > curVal) {\n                  curVal = val;\n                }\n              }\n            }\n          }\n        }\n\n        float result = curVal;\n        setOutput(result);\n      }\n    ")}}const Rz={kernelName:zs,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r,filter:o}=t,{strides:s,pad:i,dilations:c}=a,l=Mh(r.shape,o.shape,s,i,"NHWC",c);let u;const d=new Ez(l);u=n.runWebGLProgram(d,[r,o],"float32");const h=aL({inputs:{x:u},backend:n,attrs:{shape:l.outShape}});return n.disposeIntermediateTensorInfo(u),h}};const _z={kernelName:Gs,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{equation:r}=a,o=t,{allDims:s,summedDims:i,idDims:c}=Tg(r,o.length);Rg(s.length,c,o);const{path:l,steps:u}=_g(i,c),d=u.length;let h=null,p=s.length;const f=[];for(let m=0;m<d;++m){for(const e of u[m]){const{permutationIndices:t,expandDims:a}=Eg(p,c[e]);let r;Ag(t)?r=o[e]:(r=pL({inputs:{x:o[e]},backend:n,attrs:{perm:t}}),f.push(r));const s=r.shape.slice();for(let e=0;e<a.length;++e)s.splice(a[e],0,1);uo(r.shape,s)||(r=aL({inputs:{x:r},backend:n,attrs:{shape:s}}),f.push(r)),null===h?h=r:(h=tL({inputs:{a:r,b:h},backend:n}),f.push(h))}m<d-1&&(l[m]>=0&&(h=dL({inputs:{x:h},backend:n,attrs:{axis:l[m]-(s.length-p),keepDims:!1}}),f.push(h)),p--)}for(const m of f)m!==h&&n.disposeIntermediateTensorInfo(m);return h}},Az=XM({opSnippet:"return (x >= 0.0) ? x : (exp(x) - 1.0);",packedOpSnippet:"\n  vec4 result;\n\n  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);\n  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);\n  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);\n  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);\n\n  return result;\n"}),Fz={kernelName:Hs,backendName:"webgl",kernelFunc:Az},Oz={kernelName:js,backendName:"webgl",kernelFunc:e=>{const{inputs:t,backend:n}=e,{dy:a,y:r}=t,o=Vo().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new LM("\n  vec4 bGTEZero = vec4(greaterThanEqual(b, vec4(0.)));\n  return (bGTEZero * a) + ((vec4(1.0) - bGTEZero) * (a * (b + vec4(1.0))));\n",a.shape,r.shape):new DM("return (b >= 0.0) ? a : a * (b + 1.0);",a.shape,r.shape);return n.runWebGLProgram(o,[a,r],a.dtype)}},Dz=YM({opSnippet:"return float(a == b);",packedOpSnippet:"\n  return vec4(equal(a, b));\n",dtype:"bool",cpuKernelImpl:bD}),Mz={kernelName:qs,backendName:"webgl",kernelFunc:Dz},Lz=XM({opSnippet:'\n  // Error function is calculated approximately with elementary function.\n  // See "Handbook of Mathematical Functions with Formulas,\n  // Graphs, and Mathematical Tables", Abramowitz and Stegun.\n  float p = '.concat(lg,";\n  float a1 = ").concat(ug,";\n  float a2 = ").concat(dg,";\n  float a3 = ").concat(hg,";\n  float a4 = ").concat(pg,";\n  float a5 = ").concat(fg,";\n\n  float sign = sign(x);\n  x = abs(x);\n  float t = 1.0 / (1.0 + p * x);\n  return sign * (1.0 - (((((a5*t + a4)*t) + a3)*t + a2)*t + a1)*t*exp(-x*x));\n")}),Pz={kernelName:Ks,backendName:"webgl",kernelFunc:Lz},zz=XM({opSnippet:qM+"\n  return exp(x);\n",packedOpSnippet:"\n  vec4 result = exp(x);\n  bvec4 isNaN = isnan(x);\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n",cpuKernelImpl:yD,dtype:"float32"}),Bz={kernelName:Xs,backendName:"webgl",kernelFunc:zz};function Wz(e){const{inputs:t,attrs:n,backend:a}=e,{dim:r}=n,{input:o}=t,s=o.shape.length,i=o.shape.slice();let c=r;return r<0&&(so(-(s+1)<=r,(()=>"Axis must be in the interval [".concat(-(s+1),", ").concat(s,"]"))),c=s+r+1),i.splice(c,0,1),aL({inputs:{x:o},backend:a,attrs:{shape:i}})}const Vz={kernelName:Ys,backendName:"webgl",kernelFunc:Wz},Uz="return exp(x) - 1.0;",Gz=XM({opSnippet:Uz,packedOpSnippet:Uz,cpuKernelImpl:xD}),Hz={kernelName:Qs,backendName:"webgl",kernelFunc:Gz};class jz{constructor(e,t,n){this.variableNames=["real","imag"];const a=t[1];this.outputShape=t;const r=n?"2.0 * ".concat(Math.PI):"-2.0 * ".concat(Math.PI),o=n?"".concat(a,".0"):"1.0";let s;if("real"===e)s="return real * expR - imag * expI;";else{if("imag"!==e)throw new Error('FFT component must be either "real" or "imag", got '.concat(e,"."));s="return real * expI + imag * expR;"}this.userCode="\n      const float exponentMultiplier = ".concat(r,";\n\n      float unaryOpComplex(float real, float expR, float imag, float expI) {\n        ").concat(s,"\n      }\n\n      float mulMatDFT(int batch, int index) {\n        float indexRatio = float(index) / float(").concat(a,");\n        float exponentMultiplierTimesIndexRatio =\n            exponentMultiplier * indexRatio;\n\n        float result = 0.0;\n\n        for (int i = 0; i < ").concat(a,"; i++) {\n          // x = (-2|2 * PI / N) * index * i;\n          float x = exponentMultiplierTimesIndexRatio * float(i);\n          float expR = cos(x);\n          float expI = sin(x);\n          float real = getReal(batch, i);\n          float imag = getImag(batch, i);\n\n          result +=\n              unaryOpComplex(real, expR, imag, expI) / ").concat(o,";\n        }\n\n        return result;\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        setOutput(mulMatDFT(coords[0], coords[1]));\n      }\n    ")}}function Kz(e,t,n){const a=n.texData.get(e.dataId),r=lo(e.shape),o=e.shape[e.shape.length-1],s=aL({inputs:{x:e},backend:n,attrs:{shape:[r/o,o]}}),i=s.shape,c=new jz("real",i,t),l=new jz("imag",i,t),u=[{dataId:a.complexTensorInfos.real.dataId,dtype:a.complexTensorInfos.real.dtype,shape:i},{dataId:a.complexTensorInfos.imag.dataId,dtype:a.complexTensorInfos.imag.dtype,shape:i}],d=n.runWebGLProgram(c,u,"float32"),h=n.runWebGLProgram(l,u,"float32"),p=BM({inputs:{real:d,imag:h},backend:n});n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(h);const f=aL({inputs:{x:p},backend:n,attrs:{shape:e.shape}});return n.disposeIntermediateTensorInfo(s),n.disposeIntermediateTensorInfo(p),f}const qz={kernelName:Js,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{input:a}=t;return Kz(a,!1,n)}};class Xz{constructor(e,t){this.outputShape=[],this.customUniforms=[{name:"value",type:"float"}],this.variableNames=["x"],this.outputShape=e,this.userCode="\n      void main() {\n        // Input can be obtained from uniform value.\n        setOutput(value);\n      }\n    "}}function Yz(e){const{backend:t,attrs:n}=e,{shape:a,value:r}=n;let{dtype:o}=n;if(o=o||No(r),"string"===o){const e=vo(o,lo(a));return e.fill(r),t.makeTensorInfo(a,o,e)}{const e=new Xz(a,r),n=[[r]];return t.runWebGLProgram(e,[],o,n)}}const Qz={kernelName:Zs,backendName:"webgl",kernelFunc:Yz};class Jz{constructor(e){this.variableNames=["Image"],this.outputShape=[];const t=e[2];this.outputShape=e,this.userCode="\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int x = coords[2];\n\n          int coordX = ".concat(t," - x - 1;\n          float outputValue;\n          if(coordX >= 0 && coordX < ").concat(t,") {\n            outputValue = getImage(coords[0], coords[1], coordX, coords[3]);\n          } else {\n            outputValue = getImage(coords[0], coords[1], coords[2], coords[3]);\n          }\n          setOutput(outputValue);\n        }\n    ")}}const Zz={kernelName:$s,backendName:"webgl",kernelFunc:e=>{let{inputs:t,backend:n}=e;const{image:a}=t,r=n,o=new Jz(a.shape);return r.runWebGLProgram(o,[a],a.dtype)}},$z="return floor(x);",eB=XM({opSnippet:$z,packedOpSnippet:$z,cpuKernelImpl:vD}),tB={kernelName:ei,backendName:"webgl",kernelFunc:eB},nB=YM({opSnippet:"\n  float s = sign(a) * sign(b);\n  int ia = round(a);\n  int ib = round(b);\n  if (ib != 0) {\n    // Windows (D3D) wants guaranteed non-zero int division at compile-time.\n    return float(idiv(ia, ib, s));\n  } else {\n    return NAN;\n  }\n",packedOpSnippet:"\n  ivec4 ia = round(a);\n  ivec4 ib = round(b);\n  bvec4 cond = notEqual(ib, ivec4(0));\n  ivec4 result = ivec4(0);\n  vec4 s = sign(a) * sign(b);\n\n  // Windows (D3D) wants guaranteed non-zero int division at compile-time.\n  if (cond[0]) {\n    result[0] = idiv(ia[0], ib[0], s[0]);\n  }\n  if (cond[1]) {\n    result[1] = idiv(ia[1], ib[1], s[1]);\n  }\n  if (cond[2]) {\n    result[2] = idiv(ia[2], ib[2], s[2]);\n  }\n  if (cond[3]) {\n    result[3] = idiv(ia[3], ib[3], s[3]);\n  }\n  return vec4(result);\n",dtype:"int32"}),aB={kernelName:ti,backendName:"webgl",kernelFunc:nB};class rB{constructor(e){this.variableNames=["A"];const t=kO(),[n,a]=e;this.outputShape=e,this.userCode="\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int texR = coords[0];\n        int texC = coords[1];\n        int depth = coords[2];\n        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(".concat(a,".0, ").concat(n,".0);\n\n        vec4 values = ").concat(t.texture2D,"(A, uv);\n        float value;\n        if (depth == 0) {\n          value = values.r;\n        } else if (depth == 1) {\n          value = values.g;\n        } else if (depth == 2) {\n          value = values.b;\n        } else if (depth == 3) {\n          value = values.a;\n        }\n\n        setOutput(floor(value * 255.0 + 0.5));\n      }\n    ")}}class oB{constructor(e){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0;const t=kO(),[n,a]=e;this.outputShape=e,this.userCode="\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int texR = coords[0];\n        int texC = coords[1];\n        int depth = coords[2];\n\n        vec4 result = vec4(0.);\n\n        for(int row=0; row<=1; row++) {\n          for(int col=0; col<=1; col++) {\n            texC = coords[1] + row;\n            depth = coords[2] + col;\n\n            vec2 uv = (vec2(texC, texR) + halfCR) /\n                       vec2(".concat(a,".0, ").concat(n,".0);\n            vec4 values = ").concat(t.texture2D,"(A, uv);\n            float value;\n            if (depth == 0) {\n              value = values.r;\n            } else if (depth == 1) {\n              value = values.g;\n            } else if (depth == 2) {\n              value = values.b;\n            } else if (depth == 3) {\n              value = values.a;\n            }\n\n            result[row * 2 + col] = floor(value * 255.0 + 0.5);\n          }\n        }\n\n        ").concat(t.output," = result;\n      }\n    ")}}const sB={kernelName:Zc,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e;let{pixels:r}=t;const{numChannels:o}=a,s="undefined"!==typeof HTMLVideoElement&&r instanceof HTMLVideoElement,i="undefined"!==typeof HTMLImageElement&&r instanceof HTMLImageElement,[c,l]=s?[r.videoWidth,r.videoHeight]:[r.width,r.height],u=[l,c],d=[l,c,o];if(i||s){const e=Vo().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");null!=iB&&e===cB||(cB=e,iB=document.createElement("canvas").getContext("2d",{willReadFrequently:cB})),iB.canvas.width=c,iB.canvas.height=l,iB.drawImage(r,0,0,c,l),r=iB.canvas}const h=n.makeTensorInfo(u,"int32");n.texData.get(h.dataId).usage=HF.PIXELS,n.gpgpu.uploadPixelDataToTexture(n.getTexture(h.dataId),r);const p=Vo().getBool("WEBGL_PACK")?new oB(d):new rB(d),f=n.runWebGLProgram(p,[h],"int32");return n.disposeData(h.dataId),f}};let iB,cB=Vo().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");const lB={kernelName:tl,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r,filter:o,bias:s,preluActivationWeights:i}=t,{strides:c,pad:l,dataFormat:u,dilations:d,dimRoundingMode:h,activation:p,leakyreluAlpha:f}=a,m=Xh(u),g=zh(r.shape,o.shape,c,d,l,h,!1,m);let b;const y=[],x=null!=s,v=null!=i,w="leakyrelu"===p,k=()=>{const e=[r,o],t=(e,t)=>{if("NCHW"===t&&1===e.shape.length&&1!==e.shape[0]){const t=aL({inputs:{x:e},backend:n,attrs:{shape:[e.shape[0],1,1]}});return y.push(t),t}return e};if(x&&e.push(t(s,u)),v&&e.push(t(i,u)),w){const t=n.makeTensorInfo([],"float32",Rl(f,"float32"));e.push(t),y.push(t)}return e};if(1!==g.filterHeight||1!==g.filterWidth||1!==g.dilationHeight||1!==g.dilationWidth||1!==g.strideHeight||1!==g.strideWidth||"SAME"!==g.padInfo.type&&"VALID"!==g.padInfo.type)if(g.strideWidth<=2&&"channelsLast"===m&&Vo().getBool("WEBGL_EXP_CONV")){const e=p?QM(p,!0):null,t=new VP(g,x,e,v,w),a=[[g.padInfo.top,g.padInfo.left],[g.strideHeight,g.strideWidth],[g.dilationHeight,g.dilationWidth],[g.inHeight,g.inWidth]],r=k();b=n.runWebGLProgram(t,r,"float32",a)}else if(Vo().getBool("WEBGL_CONV_IM2COL"))b=jP({x:r,filter:o,convInfo:g,backend:n,bias:s,activation:p,preluActivationWeights:i,leakyreluAlpha:f});else{const e=p?QM(p,!1):null,t=new BP(g,x,e,v,w),a=k();b=n.runWebGLProgram(t,a,"float32")}else b=HP({x:r,filter:o,convInfo:g,backend:n,bias:s,activation:p,preluActivationWeights:i,leakyreluAlpha:f});const I=aL({inputs:{x:b},backend:n,attrs:{shape:g.outShape}});return y.push(b),y.forEach((e=>n.disposeIntermediateTensorInfo(e))),I}};const uB={kernelName:nl,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r,filter:o,bias:s,preluActivationWeights:i}=t,{strides:c,pad:l,dilations:u,dimRoundingMode:d,activation:h,leakyreluAlpha:p}=a,f=[];let m=u;null==m&&(m=[1,1]),so(Kh(c,m),(()=>"Error in depthwiseConv2d: Either strides or dilations must be "+"1. Got strides ".concat(c," and dilations '").concat(m,"'")));const g=zh(r.shape,o.shape,c,m,l,d,!0),b=Vo().getBool("WEBGL_PACK_DEPTHWISECONV")&&g.strideWidth<=2&&g.outChannels/g.inChannels===1,y=h?QM(h,b):null,x=[r,o],v=null!=s,w=null!=i,k="leakyrelu"===h;if(v&&x.push(s),w&&x.push(i),k){const e=n.makeTensorInfo([],"float32",Rl(p,"float32"));x.push(e),f.push(e)}let I;I=b?new vz(g,v,y,w,k):new xz(g,v,y,w,k);const S=[[g.padInfo.top,g.padInfo.left],[g.strideHeight,g.strideWidth],[g.dilationHeight,g.dilationWidth],[g.inHeight,g.inWidth]],N=n.runWebGLProgram(I,x,"float32",S);return f.forEach((e=>n.disposeIntermediateTensorInfo(e))),N}};class dB{constructor(e,t,n,a){this.sliceDim=e,this.strides=t,this.paramsShape=a,this.variableNames=["x","indices"],this.outputShape=n;const r=zO(n.length);let o="\n    int index;";for(let s=0;s<this.sliceDim;s++)o+="\n          index = round(getIndices(coords[0], ".concat(s,"));\n          out_of_bounds = out_of_bounds || index < 0;\n          out_of_bounds = out_of_bounds || index >= ").concat(this.paramsShape[s],";\n          flattenIndex += index * ").concat(this.strides[s],";");this.userCode="\n         void main() {\n          ".concat(r," coords = getOutputCoords();\n          int flattenIndex = 0;\n          bool out_of_bounds = false;\n\n          ").concat(o,"\n\n          setOutput(out_of_bounds ? 0.0 : getX(flattenIndex, coords[1]));\n        }\n      ")}}const hB={kernelName:ri,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{params:a,indices:r}=t,o=r.shape,s=o[o.length-1],i=lo(a.shape),[c,l,u,d]=ag(a,r),h=aL({inputs:{x:r},backend:n,attrs:{shape:[l,s]}}),p=aL({inputs:{x:a},backend:n,attrs:{shape:[lo(a.shape)/u,u]}});if(n.shouldExecuteOnCPU([a,r])||"string"===a.dtype){const e=n.readSync(r.dataId),t=n.bufferSync(a),o=wD(e,t,a.dtype,l,s,u,d,a.shape,i);return n.makeTensorInfo(c,a.dtype,o.values)}const f=new dB(s,d,[l,u],a.shape),m=n.runWebGLProgram(f,[p,h],p.dtype),g=aL({inputs:{x:m},backend:n,attrs:{shape:c}});return n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(m),g}};class pB{constructor(e,t){this.variableNames=["A","indices"],this.outputShape=t,this.rank=t.length;const n=zO(this.rank),a=function(e,t){const n=["resRC.x","resRC.y","resRC.z","resRC.w"],a=[];for(let r=0;r<e.length;r++)2===r?a.push("index"):a.push("".concat(n[r]));return a.join()}(e);this.userCode="\n      void main() {\n        ".concat(n," resRC = getOutputCoords();\n        int index = int(getIndices(resRC.x, resRC.z));\n        float inBounds = (index >= 0) && (index < ").concat(e[2],") ? 1.0 : 0.0;\n        setOutput(inBounds * getA(").concat(a,"));\n      }\n    ")}}function fB(e){const{inputs:t,backend:n,attrs:a}=e,{x:r,indices:o}=t,{axis:s,batchDims:i}=a,c=bo(s,r.shape)[0];if(Vo().get("DEBUG")){const e=n.readSync(o.dataId),t=r.shape[c];for(let n=0;n<e.length;++n){const a=e[n];so(a<=t-1&&a>=0,(()=>"GatherV2: the index value ".concat(a," is not in [0, ").concat(t-1,"]")))}}const l=Xg(r,o,c,i),u=lo(o.shape),d=[],h=aL({inputs:{x:r},backend:n,attrs:{shape:[l.batchSize,l.outerSize,l.dimSize,l.sliceSize]}}),p=aL({inputs:{x:o},backend:n,attrs:{shape:[l.batchSize,u/l.batchSize]}});d.push(h),d.push(p);const f=[l.batchSize,l.outerSize,u/l.batchSize,l.sliceSize];if(n.shouldExecuteOnCPU([r,o])||"string"===r.dtype){const e=n.bufferSync(p),t=n.bufferSync(h),a=kD(t,e,f);return d.forEach((e=>n.disposeIntermediateTensorInfo(e))),n.makeTensorInfo(l.outputShape,a.dtype,a.values)}const m=new pB(h.shape,f),g=n.runWebGLProgram(m,[h,p],h.dtype);d.push(g);const b=aL({inputs:{x:g},backend:n,attrs:{shape:l.outputShape}});return d.forEach((e=>n.disposeIntermediateTensorInfo(e))),b}const mB={kernelName:ai,backendName:"webgl",kernelFunc:fB},gB=YM({opSnippet:"return float(a > b);",packedOpSnippet:"\n  return vec4(greaterThan(a, b));\n",cpuKernelImpl:ID,dtype:"bool"}),bB={kernelName:oi,backendName:"webgl",kernelFunc:gB},yB=YM({opSnippet:"return float(a >= b);",packedOpSnippet:"\n  return vec4(greaterThanEqual(a, b));\n",dtype:"bool",cpuKernelImpl:SD}),xB={kernelName:si,backendName:"webgl",kernelFunc:yB};const vB={kernelName:ci,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{input:a}=t;return Kz(a,!0,n)}},wB=XM({opSnippet:"return float(!isnan(x) && !isinf(x));",dtype:"bool"}),kB={kernelName:ui,backendName:"webgl",kernelFunc:wB},IB=XM({opSnippet:"return float(isinf(x));",dtype:"bool"}),SB={kernelName:di,backendName:"webgl",kernelFunc:IB},NB=XM({opSnippet:"return float(isnan(x));",dtype:"bool"}),CB={kernelName:hi,backendName:"webgl",kernelFunc:NB},TB=YM({opSnippet:"return float(a < b);",packedOpSnippet:"\n  return vec4(lessThan(a, b));\n",cpuKernelImpl:ND,dtype:"bool"}),EB={kernelName:fi,backendName:"webgl",kernelFunc:TB},RB=YM({opSnippet:"return float(a <= b);",packedOpSnippet:"\n  return vec4(lessThanEqual(a, b));\n",cpuKernelImpl:CD,dtype:"bool"}),_B={kernelName:mi,backendName:"webgl",kernelFunc:RB};const AB={kernelName:gi,backendName:"webgl",kernelFunc:function(e){const{backend:t,attrs:n}=e,{start:a,stop:r,num:o}=n,s=TD(a,r,o);return t.makeTensorInfo([s.length],"float32",s)}},FB=XM({opSnippet:qM+"\n  return x < 0.0 ? 0./0. : log(x);\n",packedOpSnippet:"\n  vec4 result = log(x);\n  bvec4 isNaN = isnan(x);\n  result.r = isNaN.r ? x.r : (x.r < 0.0 ? 0./0. : result.r);\n  result.g = isNaN.g ? x.g : (x.g < 0.0 ? 0./0. : result.g);\n  result.b = isNaN.b ? x.b : (x.b < 0.0 ? 0./0. : result.b);\n  result.a = isNaN.a ? x.a : (x.a < 0.0 ? 0./0. : result.a);\n  return result;\n",cpuKernelImpl:ED}),OB={kernelName:bi,backendName:"webgl",kernelFunc:FB},DB=XM({opSnippet:qM+"\n  return log(1.0 + x);\n"}),MB={kernelName:yi,backendName:"webgl",kernelFunc:DB},LB=YM({opSnippet:"return float(a >= 1.0 && b >= 1.0);",packedOpSnippet:"\n  return vec4(\n    vec4(greaterThanEqual(a, vec4(1.0))) *\n    vec4(greaterThanEqual(b, vec4(1.0))));\n",dtype:"bool"}),PB={kernelName:xi,backendName:"webgl",kernelFunc:LB},zB=XM({opSnippet:"return float(!(x >= 1.0));"}),BB={kernelName:vi,backendName:"webgl",kernelFunc:zB},WB=YM({opSnippet:"return float(a >= 1.0 || b >= 1.0);",packedOpSnippet:"\n  return min(\n    vec4(greaterThanEqual(a, vec4(1.0))) +\n    vec4(greaterThanEqual(b, vec4(1.0))),\n    vec4(1.0));\n",dtype:"bool"}),VB={kernelName:wi,backendName:"webgl",kernelFunc:WB};class UB{constructor(e,t,n,a,r){this.variableNames=["x"],this.outputShape=[];const o=t,s=e[3]-1;let i;this.outputShape=e;const c="float(".concat(n,") + float(").concat(a,") * sum");i=.5===r?"inversesqrt(".concat(c,")"):1===r?"1.0/(".concat(c,")"):"exp(log(".concat(c,") * float(-").concat(r,"));"),this.userCode="\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int r = coords[1];\n        int c = coords[2];\n        int d = coords[3];\n        float x = getX(b, r, c, d);\n        float sum = 0.0;\n        for (int j = -".concat(o,"; j <= ").concat(o,"; j++) {\n          int idx = d + j;\n          if (idx >= 0 && idx <=  ").concat(s,") {\n            float z = getX(b, r, c, idx);\n            sum += z * z;\n          }\n        }\n        float val = x * ").concat(i,";\n        setOutput(val);\n      }\n    ")}}class GB{constructor(e,t,n,a,r){this.variableNames=["x"],this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0;const o=t,s=e[3]-1;let i;this.outputShape=e;const c="float(".concat(n,") + float(").concat(a,") * sum");i=.5===r?"inversesqrt(".concat(c,")"):1===r?"1.0/(".concat(c,")"):"exp(log(".concat(c,") * float(-").concat(r,"));"),this.userCode="\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords.x;\n        int r = coords.y;\n        int c = coords.z;\n        int d = coords.w;\n\n        bool hasNextCol = d < ".concat(this.outputShape[3],";\n        bool hasNextRow = c < ").concat(this.outputShape[2],";\n\n        vec4 sum = vec4(0.);\n        vec4 xFragAtOutputCoords = getX(b, r, c, d);\n\n        vec4 xAtOutputCoords = vec4(\n          getChannel(xFragAtOutputCoords, vec2(c, d)),\n          hasNextCol ?\n            getChannel(xFragAtOutputCoords, vec2(c, d + 1)) : 0.0,\n          hasNextRow ?\n            getChannel(xFragAtOutputCoords , vec2(c + 1, d)) : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getChannel(xFragAtOutputCoords, vec2(c + 1, d + 1)) : 0.0\n        );\n\n        int firstChannel = d - ").concat(o,";\n        vec2 cache = vec2(0.);\n        if(firstChannel >= 0){\n          vec4 firstChannelFrag = getX(b, r, c, firstChannel);\n          cache.x = getChannel(firstChannelFrag, vec2(c, firstChannel));\n            if(hasNextRow){\n              cache.y = getChannel(firstChannelFrag, vec2(c + 1, firstChannel));\n            }\n        }\n\n        ivec2 depth = ivec2(d, d + 1);\n        for (int j = - ").concat(o,"; j <= ").concat(o,"; j++) {\n          ivec2 idx = depth + j;\n          bvec2 aboveLowerBound = greaterThanEqual(idx, ivec2(0));\n          bvec2 belowUpperBound = lessThanEqual(idx, ivec2(").concat(s,"));\n\n          bool depthInRange = aboveLowerBound.x && belowUpperBound.x;\n          bool depthPlusOneInRange = aboveLowerBound.y && belowUpperBound.y;\n\n          if(depthInRange || depthPlusOneInRange){\n            vec4 z = vec4(0.);\n            vec4 xFragAtCurrentDepth;\n            z.xz = cache.xy;\n            if(depthPlusOneInRange && hasNextCol){\n              xFragAtCurrentDepth = idx.y != d ?\n                getX(b, r, c, idx.y) : xFragAtOutputCoords;\n              z.y = getChannel(xFragAtCurrentDepth, vec2(c, idx.y));\n              if(hasNextRow){\n                z.w = getChannel(xFragAtCurrentDepth, vec2(c + 1, idx.y));\n              }\n            }\n            cache.xy = z.yw;\n            sum += z * z;\n          }\n        }\n        vec4 result = xAtOutputCoords * ").concat(i,";\n        setOutput(result);\n      }\n    ")}}const HB={kernelName:ki,backendName:"webgl",kernelFunc:e=>{const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{depthRadius:o,bias:s,alpha:i,beta:c}=a,l=Vo().getBool("WEBGL_PACK_NORMALIZATION")?new GB(r.shape,o,s,i,c):new UB(r.shape,o,s,i,c);return n.runWebGLProgram(l,[r],r.dtype)}};class jB{constructor(e,t,n,a,r){this.variableNames=["inputImage","outputImage","dy"],this.outputShape=[],this.outputShape=e,this.depth=e[3],this.depthRadius=t,this.bias=n,this.alpha=a,this.beta=r,this.userCode="\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int r = coords[1];\n        int c = coords[2];\n\n        float result = 0.0;\n        for (int d = 0; d < ".concat(this.depth,"; ++d) {\n          int depthBegin = int(max(0.0, float(d - ").concat(t,")));\n          int depthEnd = int(min(float(").concat(this.depth,"),\n              float(d + ").concat(t," + 1)));\n\n          const int MIN_DEPTH_BEGIN = 0;\n          const int MAX_DEPTH_END = ").concat(this.depth,";\n\n          float norm = 0.0;\n          for (int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k) {\n            if (k < depthBegin){\n              continue;\n            }\n            else if (k >= depthBegin && k < depthEnd) {\n              norm += getInputImage(b, r, c, k) * getInputImage(b, r, c, k);\n            }\n            else {\n              break;\n            }\n          }\n\n          norm = float(").concat(a,") * norm + float(").concat(n,");\n\n          for(int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k){\n            if (k < depthBegin){\n              continue;\n            }\n            else if (k >= depthBegin && k < depthEnd){\n              float dyi = -2.0 * float(").concat(a,")\n                * float(").concat(r,")\n                * getInputImage(b, r, c, k) * getOutputImage(b, r, c, d)\n                / norm;\n              if (k == d) {\n                dyi += pow(norm, -1.0 * ").concat(r,");\n              }\n              if (k == coords[3]) {\n                dyi *= getDy(b, r, c, d);\n                result += dyi;\n              }\n            }\n            else {\n              break;\n            }\n          }\n      }\n      setOutput(result);\n      }\n    ")}}const KB={kernelName:Ii,backendName:"webgl",kernelFunc:e=>{const{inputs:t,backend:n,attrs:a}=e,{x:r,y:o,dy:s}=t,{depthRadius:i,bias:c,alpha:l,beta:u}=a,d=new jB(r.shape,i,c,l,u);return n.runWebGLProgram(d,[r,o,s],r.dtype)}};function qB(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{reductionIndices:o,keepDims:s}=a,i=r.shape.length,c=bo(o,r.shape);let l=c;const u=Wp(l,i),d=null!=u,h=n.shouldExecuteOnCPU([r]);let p=r;if(d){if(h){const e=n.texData.get(p.dataId).values,t=new Array(i);for(let n=0;n<t.length;n++)t[n]=r.shape[u[n]];const a=aM(e,r.shape,r.dtype,u,t);p=n.makeTensorInfo(t,r.dtype);n.texData.get(p.dataId).values=a}else p=uL(r,u,n);l=Up(l.length,i)}Bp("max",l,i);const[f,m]=Pp(p.shape,l);let g,b=f;if(s&&(b=zp(f,c)),h){const e=n.texData.get(p.dataId).values,t=RD(e,lo(m),b,r.dtype);g=n.makeTensorInfo(b,r.dtype);n.texData.get(g.dataId).values=t}else g=function(e,t,n,a){const r=lo(t),o=aL({inputs:{x:e},attrs:{shape:[lo(e.shape)/r,r]},backend:a}),s=iL(o,e.dtype,"max",a),i=aL({inputs:{x:s},attrs:{shape:n},backend:a});return a.disposeIntermediateTensorInfo(o),a.disposeIntermediateTensorInfo(s),i}(p,m,b,n);return d&&n.disposeIntermediateTensorInfo(p),g}const XB={kernelName:Si,backendName:"webgl",kernelFunc:qB},YB=YM({opSnippet:OM+"\n  return max(a, b);\n",packedOpSnippet:"\n  vec4 result = vec4(max(a, b));\n  bvec4 isNaNA = isnan(a);\n  bvec4 isNaNB = isnan(b);\n  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);\n  "+MM+"\n  return result;\n",cpuKernelImpl:_D}),QB={kernelName:Ni,backendName:"webgl",kernelFunc:YB};const JB={kernelName:Ci,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t;vO(r,"maxPool");const{filterSize:o,strides:s,pad:i,dimRoundingMode:c}=a;so(Kh(s,1),(()=>"Error in maxPool: Either strides or dilations must be 1. "+"Got strides ".concat(s," and dilations '").concat(1,"'")));const l=Lh(r.shape,o,s,1,i,c);if(1===l.filterWidth&&1===l.filterHeight&&uo(l.inShape,l.outShape))return PM({inputs:{x:r},backend:n});const u=new YL(l,"max",!1);return n.runWebGLProgram(u,[r],r.dtype)}};const ZB={kernelName:Ei,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{filterSize:o,strides:s,pad:i,dataFormat:c,dimRoundingMode:l}=a,u=Ph(r.shape,o,s,[1,1,1],i,l,c),d=new QL(u,"max",!1);return n.runWebGLProgram(d,[r],r.dtype)}};class $B{constructor(e){this.variableNames=["dy","maxPos"],this.outputShape=e.inShape;const t=e.strideHeight,n=e.strideWidth,a=e.dilationHeight,r=e.effectiveFilterHeight,o=e.effectiveFilterWidth,s=r-1-e.padInfo.top,i=o-1-e.padInfo.left,c=r*o-1;this.userCode="\n      const ivec2 pads = ivec2(".concat(s,", ").concat(i,");\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n\n        ivec2 dyRCCorner = coords.yz - pads;\n        int dyRCorner = dyRCCorner.x;\n        int dyCCorner = dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ").concat(r,";\n          wR += ").concat(a,") {\n          float dyR = float(dyRCorner + wR) / ").concat(t,".0;\n\n          if (dyR < 0.0 || dyR >= ").concat(e.outHeight,".0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          for (int wC = 0; wC < ").concat(o,"; wC++) {\n            float dyC = float(dyCCorner + wC) / ").concat(n,".0;\n\n            if (dyC < 0.0 || dyC >= ").concat(e.outWidth,".0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            float dyValue = getDy(b, idyR, idyC, d);\n            int maxPosValue = ").concat(c," - int(getMaxPos(b, idyR, idyC, d));\n\n            // Get the current value, check it against the value from the\n            // position matrix.\n            int curPosValue = wR * ").concat(o," + wC;\n            float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);\n\n            dotProd += dyValue * mask;\n          }\n        }\n        setOutput(dotProd);\n      }\n    ")}}class eW{constructor(e){this.variableNames=["dy","maxPos"],this.outputShape=e.inShape;const t=e.strideDepth,n=e.strideHeight,a=e.strideWidth,r=e.dilationDepth,o=e.dilationHeight,s=e.dilationWidth,i=e.effectiveFilterDepth,c=e.effectiveFilterHeight,l=e.effectiveFilterWidth,u=i-1-e.padInfo.front,d=c-1-e.padInfo.top,h=l-1-e.padInfo.left,p=i*c*l-1;this.userCode="\n      const ivec3 pads = ivec3(".concat(u,", ").concat(d,", ").concat(h,");\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyDCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        // Convolve dy(?, ?, ?, ch) with pos mask(:, :, :, d) to get\n        // dx(xD, xR, xC, ch).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int wD = 0; wD < ").concat(i,";\n           wD += ").concat(r,") {\n          float dyD = float(dyDCorner + wD) / ").concat(t,".0;\n\n          if (dyD < 0.0 || dyD >= ").concat(e.outDepth,".0 || fract(dyD) > 0.0) {\n            continue;\n          }\n          int idyD = int(dyD);\n\n          for (int wR = 0; wR < ").concat(c,";\n              wR += ").concat(o,") {\n            float dyR = float(dyRCorner + wR) / ").concat(n,".0;\n\n            if (dyR < 0.0 || dyR >= ").concat(e.outHeight,".0 ||\n                fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            for (int wC = 0; wC < ").concat(l,";\n                wC += ").concat(s,") {\n              float dyC = float(dyCCorner + wC) / ").concat(a,".0;\n\n              if (dyC < 0.0 || dyC >= ").concat(e.outWidth,".0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              float dyValue = getDy(batch, idyD, idyR, idyC, ch);\n              int maxPosValue = ").concat(p," -\n                  int(getMaxPos(batch, idyD, idyR, idyC, ch));\n\n              // Get the current value, check it against the value from the\n              // position matrix.\n              int curPosValue =\n                  wD * ").concat(c," * ").concat(l," +\n                  wR * ").concat(l," + wC;\n              float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);\n\n              dotProd += dyValue * mask;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    ")}}const tW={kernelName:Ri,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{dy:r,input:o}=t,s=o,{filterSize:i,strides:c,pad:l,dimRoundingMode:u}=a,d=Ph(s.shape,i,c,[1,1,1],l,u),h=new QL(d,"max",!0),p=n.runWebGLProgram(h,[s],s.dtype),f=new eW(d),m=n.runWebGLProgram(f,[r,p],s.dtype);return n.disposeIntermediateTensorInfo(p),m}};const nW={kernelName:Ti,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{dy:r,input:o,output:s}=t,i=o;vO([o,s],"maxPoolGrad");const{filterSize:c,strides:l,pad:u,dimRoundingMode:d}=a,h=Lh(i.shape,c,l,1,u,d),p=new YL(h,"max",!0),f=n.runWebGLProgram(p,[i],i.dtype),m=new $B(h),g=n.runWebGLProgram(m,[r,f],i.dtype);return n.disposeIntermediateTensorInfo(f),g}};const aW={kernelName:_i,backendName:"webgl",kernelFunc:e=>{let{inputs:t,attrs:n,backend:a}=e;const{x:r}=t,{filterSize:o,strides:s,pad:i,includeBatchInIndex:c}=n,l=a;so(4===r.shape.length,(()=>"Error in maxPool: input must be rank 4 but got rank ".concat(r.shape.length,".")));const u=[1,1];so(Kh(s,u),(()=>"Error in maxPool: Either strides or dilations must be 1. "+"Got strides ".concat(s," and dilations '").concat(u,"'")));const d=Lh(r.shape,o,s,u,i),[h,p]=function(e,t,n,a){let r=new YL(n,"max",!1);const o=a.runWebGLProgram(r,[e],"float32");return r=new YL(n,"max",!0,!0,t),[o,a.runWebGLProgram(r,[e],"float32")]}(r,c,d,l);return[h,p]}};const rW={kernelName:Ai,backendName:"webgl",kernelFunc:e=>{let{inputs:t,attrs:n,backend:a}=e;const{x:r}=t,{keepDims:o,axis:s}=n,i=a,c=r.shape.length,l=bo(s,r.shape);let u=l;const d=Wp(u,c),h=null!=d,p=i.shouldExecuteOnCPU([r]),f=[];let m=r;if(h){if(p){const e=i.texData.get(m.dataId).values,t=new Array(c);for(let a=0;a<t.length;a++)t[a]=r.shape[d[a]];const n=aM(e,r.shape,r.dtype,d,t);m=i.makeTensorInfo(t,r.dtype);i.texData.get(m.dataId).values=n}else m=uL(r,d,i);f.push(m),u=Up(u.length,c)}Bp("sum",u,c);const[g,b]=Pp(m.shape,u);let y=g;o&&(y=zp(g,l));const x=function(e,t,n,a){const r=lo(t),o=aL({inputs:{x:e},attrs:{shape:[lo(e.shape)/r,r]},backend:a}),s=iL(o,"float32","mean",a),i=aL({inputs:{x:s},attrs:{shape:n},backend:a});return a.disposeIntermediateTensorInfo(o),a.disposeIntermediateTensorInfo(s),i}(m,b,y,i);for(const v of f)i.disposeIntermediateTensorInfo(v);return x}};const oW={kernelName:Fi,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{axis:o,keepDims:s}=a,i=r.shape.length,c=bo(o,r.shape);let l=c;const u=Wp(l,i);let d=r;null!=u&&(d=pL({inputs:{x:r},backend:n,attrs:{perm:u}}),l=Up(l.length,r.shape.length)),Bp("min",l,i);const[h,p]=Pp(d.shape,l),f=aL({inputs:{x:d},backend:n,attrs:{shape:[-1,lo(p)]}}),m=iL(f,f.dtype,"min",n);let g;if(s){g=aL({inputs:{x:m},backend:n,attrs:{shape:zp(h,c)}})}else g=aL({inputs:{x:m},backend:n,attrs:{shape:h}});return n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),null!=u&&n.disposeIntermediateTensorInfo(d),g}},sW=YM({opSnippet:OM+"\n  return min(a, b);\n",packedOpSnippet:"\n  vec4 result = vec4(min(a, b));\n  bvec4 isNaNA = isnan(a);\n  bvec4 isNaNB = isnan(b);\n  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);\n  "+MM+"\n  return result;\n",cpuKernelImpl:AD}),iW={kernelName:Oi,backendName:"webgl",kernelFunc:sW};class cW{constructor(e,t,n){this.variableNames=["x"],this.outputShape=t.map(((t,n)=>t[0]+e[n]+t[1]));const a=e.length,r=zO(a),o=t.map((e=>e[0])).join(","),s=t.map(((t,n)=>t[0]+e[n])).join(","),i=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,a),c="reflect"===n?0:1;this.userCode=1!==a?"\n      ".concat(r," start = ").concat(r,"(").concat(o,");\n      ").concat(r," end = ").concat(r,"(").concat(s,");\n\n      void main() {\n        ").concat(r," outC = getOutputCoords();\n        for (int i = 0; i < ").concat(a,"; i++) {\n          if (outC[i] < start[i]) {\n            outC[i] = start[i] * 2 - outC[i] - ").concat(c,";\n          } else if(outC[i] >= end[i]) {\n            outC[i] = (end[i] - 1) * 2 - outC[i] + ").concat(c,";\n          }\n        }\n        ").concat(r," coords = outC - start;\n        setOutput(getX(").concat(i,"));\n      }\n    "):"\n        int start = ".concat(o,";\n        int end = ").concat(s,";\n\n        void main() {\n          int outC = getOutputCoords();\n          if (outC < start) {\n            outC = start * 2 - outC - ").concat(c,";\n          } else if(outC >= end) {\n            outC = (end - 1) * 2 - outC + ").concat(c,";\n          }\n          setOutput(getX(outC - start));\n        }\n      ")}}class lW{constructor(e,t,n){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t.map(((t,n)=>t[0]+e[n]+t[1]));const a=e.length,r=zO(a),o=t.map((e=>e[0])).join(","),s=t.map(((t,n)=>t[0]+e[n])).join(","),i=sM("rc",a),c=sM("source",a),l="".concat(i[a-1]," < ").concat(this.outputShape[a-1]),u=1===a?"source":"vec2(".concat(c.slice(-2).join(),")"),d="reflect"===n?0:1;let h="";if(1===a){const e="\n        ".concat(r," source = rc;\n        if (source < start) {\n          source = start * 2 - source - ").concat(d,";\n        } else if (source >= end) {\n          source = (end - 1) * 2 - source + ").concat(d,";\n        }\n        source -= start;\n      ");h="\n        ".concat(r," rc = outputLoc;\n        ").concat(e,"\n        result[0] = getChannel(getX(").concat(c.join(),"), ").concat(u,");\n        ").concat(i[a-1]," += 1;\n        if(").concat(l,") {\n          ").concat(e,"\n          result[1] = getChannel(getX(").concat(c.join(),"), ").concat(u,");\n        }\n      ")}else{const e="\n        ".concat(r," source = rc;\n        ").concat(r," lt = ").concat(r,"(lessThan(source, start));\n        ").concat(r," gte = ").concat(r,"(greaterThanEqual(source, end));\n        ").concat(r," orig = 1 - (lt + gte);\n        source = orig * source +\n                lt * (start * 2 - source - ").concat(d,") +\n                gte * ((end - 1) * 2 - source + ").concat(d,");\n        source -= start;\n      ");h="\n        ".concat(r," rc = outputLoc;\n        ").concat(e,"\n        result[0] = getChannel(getX(").concat(c.join(),"), ").concat(u,");\n        ").concat(i[a-1]," += 1;\n        if(").concat(l,") {\n          ").concat(e,"\n          result[1] = getChannel(getX(").concat(c.join(),"), ").concat(u,");\n        }\n        rc = outputLoc;\n        ").concat(i[a-2]," += 1;\n        if(").concat(i[a-2]," < ").concat(this.outputShape[a-2],") {\n          ").concat(e,"\n          result[2] = getChannel(getX(").concat(c.join(),"), ").concat(u,");\n          ").concat(i[a-1]," += 1;\n          if(").concat(l,") {\n            ").concat(e,"\n            result[3] = getChannel(getX(").concat(c.join(),"), ").concat(u,");\n          }\n        }\n      ")}this.userCode="\n      const ".concat(r," start = ").concat(r,"(").concat(o,");\n      const ").concat(r," end = ").concat(r,"(").concat(s,");\n\n      void main() {\n        ").concat(r," outputLoc = getOutputCoords();\n        vec4 result = vec4(0.);\n        ").concat(h,"\n        setOutput(result);\n      }\n    ")}}const uW={kernelName:Di,backendName:"webgl",kernelFunc:e=>{let{inputs:t,backend:n,attrs:a}=e;const{x:r}=t,{paddings:o,mode:s}=a,i=Vo().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new lW(r.shape,o,s):new cW(r.shape,o,s);return n.runWebGLProgram(i,[r],r.dtype)}},dW=YM({opSnippet:"if (b == 0.0) return NAN;\n  return mod(a, b);",packedOpSnippet:"\n  vec4 result = mod(a, b);\n  bvec4 isNaN = equal(b, vec4(0.0));\n  "+MM+"\n  return result;\n"}),hW={kernelName:Mi,backendName:"webgl",kernelFunc:dW};class pW{constructor(e,t,n){this.variableNames=["probs"],this.customUniforms=[{name:"seed",type:"float"}],this.outputShape=[e,n],this.userCode="\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n\n        float r = random(seed);\n        float cdf = 0.0;\n\n        for (int i = 0; i < ".concat(t-1,"; i++) {\n          cdf += getProbs(batch, i);\n\n          if (r < cdf) {\n            setOutput(float(i));\n            return;\n          }\n        }\n\n        // If no other event happened, last event happened.\n        setOutput(float(").concat(t-1,"));\n      }\n    ")}}const fW=YM({opSnippet:"\nif (a == b) {\n  return 1.0;\n};\nreturn a / b;",packedOpSnippet:"\n  // vec4 one = vec4(equal(a, b));\n  // return one + (vec4(1.0) - one) * a / b;\n  vec4 result = a / b;\n  if(a.x == b.x) {\n    result.x = 1.;\n  }\n  if(a.y == b.y) {\n    result.y = 1.;\n  }\n  if(a.z == b.z) {\n    result.z = 1.;\n  }\n  if(a.w == b.w) {\n    result.w = 1.;\n  }\n\n  return result;\n",checkOutOfBounds:!0}),mW={kernelName:Us,backendName:"webgl",kernelFunc:fW},gW="return a - b;",bW=YM({opSnippet:gW,packedOpSnippet:gW,supportsComplex:!0,cpuKernelImpl:eM}),yW={kernelName:Wc,backendName:"webgl",kernelFunc:bW};function xW(e){const{inputs:t,backend:n,attrs:a}=e,{logits:r}=t,{dim:o}=a,s=bo([o],r.shape),i=qB({inputs:{x:r},backend:n,attrs:{reductionIndices:s,keepDims:!1}}),c=zp(i.shape,s),l=aL({inputs:{x:i},backend:n,attrs:{shape:c}}),u=bW({inputs:{a:r,b:l},backend:n}),d=zz({inputs:{x:u},backend:n}),h=dL({inputs:{x:d},backend:n,attrs:{axis:s,keepDims:!1}}),p=aL({inputs:{x:h},backend:n,attrs:{shape:c}}),f=fW({inputs:{a:d,b:p},backend:n});return n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(l),n.disposeIntermediateTensorInfo(u),n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(p),f}const vW={kernelName:Tc,backendName:"webgl",kernelFunc:xW};const wW={kernelName:Li,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{logits:r}=t,{numSamples:o,seed:s,normalized:i}=a,c=i?r:xW({inputs:{logits:r},backend:n,attrs:{dim:r.shape.length-1}}),l=c.shape[0],u=c.shape[1],d=new pW(l,u,o),h=[[s]],p=n.runWebGLProgram(d,[c],"int32",h);return i||n.disposeIntermediateTensorInfo(c),p}},kW=fM+"\n  return -x;\n";const IW={kernelName:zi,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{x:a}=t;if(n.shouldExecuteOnCPU([a])){const e=n.texData.get(a.dataId),[t,r]=OD(e.values,a.shape,a.dtype);return n.makeTensorInfo(r,a.dtype,t)}let r;return r=Vo().getBool("WEBGL_PACK_UNARY_OPERATIONS")?new TM(a.shape,"\n  vec4 result = -x;\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n"):new pM(a.shape,kW),n.runWebGLProgram(r,[a],a.dtype)}},SW=lm;const NW={kernelName:Wi,backendName:"webgl",kernelFunc:function(e){al("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:t,backend:n,attrs:a}=e,{boxes:r,scores:o}=t,{maxOutputSize:s,iouThreshold:i,scoreThreshold:c}=a,l=n.readSync(r.dataId),u=n.readSync(o.dataId),{selectedIndices:d}=SW(l,u,s,i,c);return n.makeTensorInfo([d.length],"int32",new Int32Array(d))}},CW=um;const TW={kernelName:Vi,backendName:"webgl",kernelFunc:function(e){al("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:t,backend:n,attrs:a}=e,{boxes:r,scores:o}=t,{maxOutputSize:s,iouThreshold:i,scoreThreshold:c,padToMaxOutputSize:l}=a,u=n.readSync(r.dataId),d=n.readSync(o.dataId),{selectedIndices:h,validOutputs:p}=CW(u,d,s,i,c,l);return[n.makeTensorInfo([h.length],"int32",new Int32Array(h)),n.makeTensorInfo([],"int32",new Int32Array([p]))]}},EW=dm;const RW={kernelName:Ui,backendName:"webgl",kernelFunc:function(e){al("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:t,backend:n,attrs:a}=e,{boxes:r,scores:o}=t,{maxOutputSize:s,iouThreshold:i,scoreThreshold:c,softNmsSigma:l}=a,u=n.readSync(r.dataId),d=n.readSync(o.dataId),h=s,p=i,f=c,m=l,{selectedIndices:g,selectedScores:b}=EW(u,d,h,p,f,m);return[n.makeTensorInfo([g.length],"int32",new Int32Array(g)),n.makeTensorInfo([b.length],"float32",new Float32Array(b))]}};class _W{constructor(e,t,n,a){this.variableNames=["indices"],this.outputShape=[e,t],this.userCode="\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int index = round(getIndices(coords.x));\n        setOutput(mix(float(".concat(a,"), float(").concat(n,"),\n                      float(index == coords.y)));\n      }\n    ")}}const AW={kernelName:Hi,backendName:"webgl",kernelFunc:e=>{const{inputs:t,backend:n,attrs:a}=e,{indices:r}=t,{dtype:o,depth:s,onValue:i,offValue:c}=a,l=lo(r.shape),u=new _W(l,s,i,c),d=aL({inputs:{x:r},backend:n,attrs:{shape:[l]}}),h=n.runWebGLProgram(u,[d],o);n.disposeIntermediateTensorInfo(d);const p=aL({inputs:{x:h},backend:n,attrs:{shape:[...r.shape,s]}});return n.disposeIntermediateTensorInfo(h),p}};function FW(e){const{inputs:t,backend:n}=e,{x:a}=t;if("complex64"===a.dtype){const e=yP({inputs:{input:a},backend:n}),t=FW({inputs:{x:e},backend:n}),r=DP({inputs:{input:a},backend:n}),o=FW({inputs:{x:r},backend:n}),s=BM({inputs:{real:t,imag:o},backend:n});return n.disposeIntermediateTensorInfo(e),n.disposeIntermediateTensorInfo(t),n.disposeIntermediateTensorInfo(r),n.disposeIntermediateTensorInfo(o),s}return Yz({attrs:{shape:a.shape,dtype:a.dtype,value:"string"===a.dtype?"":0},backend:n})}const OW={kernelName:Qc,backendName:"webgl",kernelFunc:FW};const DW={kernelName:Gi,backendName:"webgl",kernelFunc:function e(t){const{inputs:n,backend:a}=t,{x:r}=n;if("string"===r.dtype)throw new Error("onesLike is not supported under string dtype");if("complex64"===r.dtype){const t=yP({inputs:{input:r},backend:a}),n=e({inputs:{x:t},backend:a}),o=DP({inputs:{input:r},backend:a}),s=FW({inputs:{x:o},backend:a}),i=BM({inputs:{real:n,imag:s},backend:a});return a.disposeIntermediateTensorInfo(t),a.disposeIntermediateTensorInfo(n),a.disposeIntermediateTensorInfo(o),a.disposeIntermediateTensorInfo(s),i}return Yz({attrs:{shape:r.shape,dtype:r.dtype,value:1},backend:a})}};const MW={kernelName:ji,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{axis:r}=a;if(1===t.length)return Wz({inputs:{input:t[0]},backend:n,attrs:{dim:r}});const o=t[0].shape,s=t[0].dtype;t.forEach((e=>{io(o,e.shape,"All tensors passed to stack must have matching shapes"),so(s===e.dtype,(()=>"All tensors passed to stack must have matching dtypes"))}));const i=[],c=t.map((e=>{const t=Wz({inputs:{input:e},backend:n,attrs:{dim:r}});return i.push(t),t})),l=PP({inputs:c,backend:n,attrs:{axis:r}});return i.forEach((e=>n.disposeIntermediateTensorInfo(e))),l}};class LW{constructor(e,t,n){this.variableNames=["x"],this.customUniforms=[{name:"value",type:"float"}],this.outputShape=t.map(((t,n)=>t[0]+e[n]+t[1]));const a=e.length,r=zO(a),o=t.map((e=>e[0])).join(","),s=t.map(((t,n)=>t[0]+e[n])).join(","),i=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,a);this.userCode=1!==a?"\n      ".concat(r," start = ").concat(r,"(").concat(o,");\n      ").concat(r," end = ").concat(r,"(").concat(s,");\n\n      void main() {\n        ").concat(r," outC = getOutputCoords();\n        if (any(lessThan(outC, start)) || any(greaterThanEqual(outC, end))) {\n          setOutput(value);\n        } else {\n          ").concat(r," coords = outC - start;\n          setOutput(getX(").concat(i,"));\n        }\n      }\n    "):"\n        int start = ".concat(o,";\n        int end = ").concat(s,";\n\n        void main() {\n          int outC = getOutputCoords();\n          if (outC < start || outC >= end) {\n            setOutput(value);\n          } else {\n            setOutput(getX(outC - start));\n          }\n        }\n      ")}}class PW{constructor(e,t,n){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"value",type:"float"}],this.outputShape=t.map(((t,n)=>t[0]+e[n]+t[1]));const a=e.length,r=zO(a),o=t.map((e=>e[0])).join(","),s=t.map(((t,n)=>t[0]+e[n])).join(","),i=sM("rc",a),c=sM("source",a),l="".concat(i[a-1]," < ").concat(this.outputShape[a-1]),u=1===a?"source":"vec2(".concat(c.slice(-2).join(),")"),d=["".concat(r," rc = outputLoc;"),"".concat(i[a-1]," += 1;\n       if(").concat(l,") {\n      "),1===a?"":"}\n       rc = outputLoc;\n       ".concat(i[a-2]," += 1;\n       if(").concat(i[a-2]," < ").concat(this.outputShape[a-2],") {"),1===a?"":"  ".concat(i[a-1]," += 1;\n         if(").concat(l,") {")],h=1===a?"rc < start || rc >= end":"any(lessThan(rc, start)) || any(greaterThanEqual(rc, end))";let p="";for(let f=0,m=1===a?2:4;f<m;f++)p+="\n        ".concat(d[f],"\n        if (").concat(h,") {\n          result[").concat(f,"] = float(value);\n        } else {\n          ").concat(r," source = rc - start;\n          result[").concat(f,"] = getChannel(getX(").concat(c.join(),"), ").concat(u,");\n        }\n      ");p+=1===a?"} ":"}}",this.userCode="\n      const ".concat(r," start = ").concat(r,"(").concat(o,");\n      const ").concat(r," end = ").concat(r,"(").concat(s,");\n\n      void main() {\n        ").concat(r," outputLoc = getOutputCoords();\n        vec4 result = vec4(0.);\n        ").concat(p,"\n        setOutput(result);\n      }\n    ")}}const zW=e=>{const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{paddings:o,constantValue:s}=a;if(0===lo(r.shape)){const e=o.map(((e,t)=>e[0]+r.shape[t]+e[1]));return Yz({backend:n,attrs:{shape:e,value:s,dtype:r.dtype}})}const i=Vo().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new PW(r.shape,o,s):new LW(r.shape,o,s),c=[[s]];return n.runWebGLProgram(i,[r],r.dtype,c)},BW={kernelName:Ki,backendName:"webgl",kernelFunc:zW},WW=YM({opSnippet:"\n  if(a < 0.0 && floor(b) < b){\n    return NAN;\n  }\n  if (b == 0.0) {\n    return 1.0;\n  }\n  return (round(mod(b, 2.0)) != 1) ?\n      pow(abs(a), b) : sign(a) * pow(abs(a), b);\n",packedOpSnippet:"\n  // isModRound1 has 1 for components with round(mod(b, 2.0)) == 1, 0 otherwise.\n  vec4 isModRound1 = vec4(equal(round(mod(b, 2.0)), ivec4(1)));\n  vec4 multiplier = sign(a) * isModRound1 + (vec4(1.0) - isModRound1);\n  vec4 result = multiplier * pow(abs(a), b);\n\n  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS\n  bvec4 isExpZero = equal(b, vec4(0.0));\n  result.r = isExpZero.r ? 1.0 : result.r;\n  result.g = isExpZero.g ? 1.0 : result.g;\n  result.b = isExpZero.b ? 1.0 : result.b;\n  result.a = isExpZero.a ? 1.0 : result.a;\n\n  bvec4 isNaN1 = lessThan(a, vec4(0.0));\n  bvec4 isNaN2 = lessThan(floor(b), b);\n  bvec4 isNaN = bvec4(isNaN1.x && isNaN2.x, isNaN1.y && isNaN2.y, isNaN1.z && isNaN2.z, isNaN1.w && isNaN2.w);\n  "+MM+"\n  return result;\n"}),VW={kernelName:qi,backendName:"webgl",kernelFunc:WW};const UW={kernelName:Yi,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{axis:o,keepDims:s}=a,i=r.shape.length,c=[],l=bo(o,r.shape);let u=l;const d=Wp(u,i);let h,p=r;if(null!=d&&(p=pL({inputs:{x:r},backend:n,attrs:{perm:d}}),u=Up(u.length,i),c.push(p)),Bp("prod",u,i),n.shouldExecuteOnCPU([p])){const e=n.texData.get(p.dataId).values,{outVals:t,outShape:a,outDtype:r}=MD(p.shape,p.dtype,e,u);h=n.makeTensorInfo(a,r,t)}else{const[e,t]=Pp(p.shape,u),a=lo(t),o=aL({inputs:{x:p},backend:n,attrs:{shape:[-1,a]}}),s=iL(o,iu(r.dtype),"prod",n);h=aL({inputs:{x:s},backend:n,attrs:{shape:e}}),c.push(o),c.push(s)}if(s){c.push(h);const e=zp(h.shape,l);h=aL({inputs:{x:h},backend:n,attrs:{shape:e}})}return c.forEach((e=>n.disposeIntermediateTensorInfo(e))),h}};const GW={kernelName:Qi,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{paramsNestedSplits:r,paramsDenseValues:o,indices:s}=t,{outputRaggedRank:i}=a,c=r.map((e=>n.readSync(e.dataId))),l=r.map((e=>e.shape)),u=n.readSync(o.dataId),d=n.readSync(s.dataId),[h,p,f]=LD(c,l,u,o.shape,o.dtype,d,s.shape,i),m=h.map((e=>n.makeTensorInfo([e.length],"int32",e))),g=n.makeTensorInfo(f,o.dtype,p);return m.concat([g])}};const HW={kernelName:Ji,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{starts:a,limits:r,deltas:o}=t,s=n.readSync(a.dataId),i=n.readSync(r.dataId),c=n.readSync(o.dataId),[l,u]=PD(s,a.shape,a.dtype,i,r.shape,c,o.shape);return[n.makeTensorInfo([l.length],"int32",l),n.makeTensorInfo([u.length],a.dtype,u)]}};const jW={kernelName:Zi,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{shape:r,values:o,defaultValue:s,rowPartitionTensors:i}=t,{rowPartitionTypes:c}=a,l=n.readSync(r.dataId),u=n.readSync(o.dataId),d=n.readSync(s.dataId),h=i.map((e=>n.readSync(e.dataId))),p=i.map((e=>e.shape)),[f,m]=zD(l,r.shape,u,o.shape,o.dtype,d,s.shape,h,p,c);return n.makeTensorInfo(f,o.dtype,m)}},KW=e=>{const{backend:t,attrs:n}=e,{start:a,stop:r,step:o,dtype:s}=n,i=BD(a,r,o,s);return t.makeTensorInfo([i.length],s,i)},qW={kernelName:$i,backendName:"webgl",kernelFunc:KW},XW=XM({opSnippet:"return 1.0 / x;"}),YW={kernelName:tc,backendName:"webgl",kernelFunc:XW},QW=XM({opSnippet:fM+"\n  return (x < 0.0) ? 0.0 : x;\n",packedOpSnippet:"\n  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n"}),JW={kernelName:nc,backendName:"webgl",kernelFunc:QW},ZW=XM({opSnippet:fM+"\n  return (x < 0.0) ? 0.0 : min(6.0, x);\n",packedOpSnippet:"\n  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n"}),$W={kernelName:cc,backendName:"webgl",kernelFunc:ZW};class eV{constructor(e,t,n,a,r){this.variableNames=["A"],this.outputShape=[];const[o,s,i,c]=e;this.outputShape=[o,t,n,c];const l=[a&&t>1?s-1:s,a&&n>1?i-1:i],u=[a&&t>1?t-1:t,a&&n>1?n-1:n];let d;d=r?"(vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC - vec2(0.5)":"vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode="\n      const vec2 effectiveInputOverOutputRatioRC = vec2(\n          ".concat(l[0]/u[0],",\n          ").concat(l[1]/u[1],");\n      const vec2 inputShapeRC = vec2(").concat(s,".0, ").concat(i,".0);\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        ivec2 yRC = coords.yz;\n\n        // Fractional source index.\n        vec2 sourceFracIndexRC = ").concat(d,";\n\n        // Compute the four integer indices.\n        ivec2 sourceFloorRC = ivec2(max(sourceFracIndexRC, vec2(0.0)));\n        ivec2 sourceCeilRC = ivec2(\n          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));\n\n        float topLeft = getA(b, sourceFloorRC.x, sourceFloorRC.y, d);\n        float bottomLeft = getA(b, sourceCeilRC.x, sourceFloorRC.y, d);\n        float topRight = getA(b, sourceFloorRC.x, sourceCeilRC.y, d);\n        float bottomRight = getA(b, sourceCeilRC.x, sourceCeilRC.y, d);\n\n        vec2 fracRC = sourceFracIndexRC - vec2(sourceFloorRC);\n\n        float top = topLeft + (topRight - topLeft) * fracRC.y;\n        float bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;\n        float newValue = top + (bottom - top) * fracRC.x;\n\n        setOutput(newValue);\n      }\n    ")}}class tV{constructor(e,t,n,a,r){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];const[o,s,i,c]=e;this.outputShape=[o,t,n,c];const l=[a&&t>1?s-1:s,a&&n>1?i-1:i],u=[a&&t>1?t-1:t,a&&n>1?n-1:n];let d;d=r?"(vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC - vec3(0.5)":"vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode="\n      const vec3 effectiveInputOverOutputRatioRC = vec3(\n          ".concat(l[0]/u[0],",\n          ").concat(l[1]/u[1],",\n          ").concat(l[1]/u[1],");\n      const vec3 inputShapeRC = vec3(").concat(s,".0, ").concat(i,".0,\n                                     ").concat(i,".0);\n\n      float getAValue(int b, int r, int c, int d) {\n        return getChannel(getA(b, r, c, d), vec2(c, d));\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        // Calculate values for next column in yRC.z.\n        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);\n\n        // Fractional source index.\n        vec3 sourceFracIndexRC = ").concat(d,";\n\n        // Compute the four integer indices.\n        ivec3 sourceFloorRC = ivec3(max(sourceFracIndexRC, vec3(0.0)));\n        ivec3 sourceCeilRC = ivec3(\n          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));\n\n        // Should we calculate next column and row elements in 2x2 packed cell.\n        bool hasNextCol = d < ").concat(c-1,";\n        bool hasNextRow = coords.z < ").concat(n-1,";\n\n        // In parallel, construct four corners for all four components in\n        // packed 2x2 cell.\n        vec4 topLeft = vec4(\n          getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d),\n          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d + 1) : 0.0);\n\n        vec4 bottomLeft = vec4(\n          getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d),\n          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d + 1) : 0.0);\n\n        vec4 topRight = vec4(\n          getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d),\n          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d + 1) : 0.0);\n\n        vec4 bottomRight = vec4(\n          getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d),\n          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d + 1) : 0.0);\n\n        vec3 fracRC = sourceFracIndexRC - vec3(sourceFloorRC);\n\n        vec4 top = mix(topLeft, topRight, fracRC.yyzz);\n        vec4 bottom = mix(bottomLeft, bottomRight, fracRC.yyzz);\n        vec4 newValue = mix(top, bottom, fracRC.x);\n\n        setOutput(newValue);\n      }\n    ")}}const nV={kernelName:sc,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{images:r}=t,{alignCorners:o,halfPixelCenters:s,size:i}=a,[c,l]=i,u=Vo().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new tV(r.shape,c,l,o,s):new eV(r.shape,c,l,o,s);return n.runWebGLProgram(u,[r],"float32")}};class aV{constructor(e,t,n){this.variableNames=["dy"],this.outputShape=[],this.outputShape=t;const[,a,r]=t,[,o,s]=e,i=[n&&o>1?a-1:a,n&&s>1?r-1:r],c=[n&&o>1?o-1:o,n&&s>1?s-1:s],l=i[0]/c[0],u=i[1]/c[1],d=1/l,h=1/u,p=2*Math.ceil(d)+2,f=2*Math.ceil(h)+2;this.userCode="\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        int r = coords[1];\n        int c = coords[2];\n\n        float accumulator = 0.0;\n\n        const float heightScale = float(".concat(l,");\n        const float widthScale = float(").concat(u,");\n\n        const float invHeightScale = float(").concat(d,");\n        const float invWidthScale = float(").concat(h,");\n\n        const int winHeight = int(").concat(p,");\n        const int winWidth = int(").concat(f,");\n\n        // Compute bounds for where in dy we will look\n        float startRLerp = floor(float(r) * invHeightScale);\n        int startDyR = int(startRLerp - float(winHeight / 2));\n\n        float startCLerp = floor(float(c) * invWidthScale);\n        int startDyC = int(startCLerp - float(winWidth / 2));\n\n        // Loop over dy\n        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {\n          int dyR = dyROffset + startDyR;\n\n          // Guard against the window exceeding the bounds of dy\n          if (dyR < 0 || dyR >= ").concat(o,") {\n            continue;\n          }\n\n          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {\n            int dyC = dyCOffset + startDyC;\n\n            // Guard against the window exceeding the bounds of dy\n            if (dyC < 0 || dyC >= ").concat(s,") {\n              continue;\n            }\n\n            float dxR = float(dyR) * heightScale;\n            int topDxRIndex = int(floor(dxR));\n            int bottomDxRIndex = int(min(ceil(dxR), ").concat(a-1,".0));\n            float dxRLerp = dxR - float(topDxRIndex);\n            float inverseDxRLerp = 1.0 - dxRLerp;\n\n            float dxC = float(dyC) * widthScale;\n            int leftDxCIndex = int(floor(dxC));\n            int rightDxCIndex = int(min(ceil(dxC), ").concat(r-1,".0));\n            float dxCLerp = dxC - float(leftDxCIndex);\n            float inverseDxCLerp = 1.0 - dxCLerp;\n\n            if (r == topDxRIndex && c == leftDxCIndex) {\n              // topLeft\n              accumulator +=\n                getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;\n            }\n\n            if (r == topDxRIndex && c == rightDxCIndex) {\n              // topRight\n              accumulator += getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;\n            }\n\n            if (r == bottomDxRIndex && c == leftDxCIndex) {\n              // bottomLeft\n              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;\n            }\n\n            if (r == bottomDxRIndex && c == rightDxCIndex) {\n              // bottomRight\n              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;\n            }\n          }\n        }\n        // End loop over dy\n\n        setOutput(accumulator);\n      }\n    ")}}const rV={kernelName:ic,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{images:r,dy:o}=t,{alignCorners:s}=a,i=new aV(o.shape,r.shape,s);return n.runWebGLProgram(i,[o],o.dtype)}};class oV{constructor(e,t,n,a,r){this.variableNames=["A"],this.outputShape=[];const[o,s,i,c]=e;this.outputShape=[o,t,n,c];const l=[a&&t>1?s-1:s,a&&n>1?i-1:i],u=[a&&t>1?t-1:t,a&&n>1?n-1:n],d=a?"0.5":"0.0";let h;h=r?"max((vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC, vec2(0.0))":"vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode="\n      const vec2 effectiveInputOverOutputRatioRC = vec2(\n          ".concat(l[0]/u[0],",\n          ").concat(l[1]/u[1],");\n      const vec2 inputShapeRC = vec2(").concat(s,".0, ").concat(i,".0);\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        ivec2 yRC = coords.yz;\n\n        // Fractional source index.\n        vec2 sourceFracIndexRC = ").concat(h,";\n\n        // Compute the coordinators of nearest neighbor point.\n        ivec2 sourceNearestRC = ivec2(\n          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ").concat(d,")));\n        float newValue = getA(b, sourceNearestRC.x, sourceNearestRC.y, d);\n\n        setOutput(newValue);\n      }\n    ")}}class sV{constructor(e,t,n,a,r){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];const[o,s,i,c]=e;this.outputShape=[o,t,n,c];const l=[a&&t>1?s-1:s,a&&n>1?i-1:i],u=[a&&t>1?t-1:t,a&&n>1?n-1:n],d=a?"0.5":"0.0";let h;h=r?"max((vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC, vec3(0.0))":"vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode="\n      const vec3 effectiveInputOverOutputRatioRC = vec3(\n          ".concat(l[0]/u[0],",\n          ").concat(l[1]/u[1],",\n          ").concat(l[1]/u[1],");\n      const vec3 inputShapeRC = vec3(").concat(s,".0, ").concat(i,".0,\n                                     ").concat(i,".0);\n\n      float getAValue(int b, int r, int c, int d) {\n        return getChannel(getA(b, r, c, d), vec2(c, d));\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        // Calculate values for next column in yRC.z.\n        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);\n\n        // Fractional source index.\n        vec3 sourceFracIndexRC = ").concat(h,";\n\n        // Compute the coordinators of nearest neighbor point.\n        ivec3 sourceNearestRC = ivec3(\n          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ").concat(d,")));\n\n        // Should we calculate next column and row elements in 2x2 packed cell.\n        bool hasNextCol = d < ").concat(c-1,";\n        bool hasNextRow = coords.z < ").concat(n-1,";\n\n        vec4 newValue = vec4(\n          getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d),\n          hasNextCol ? getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d + 1) : 0.0);\n\n        setOutput(newValue);\n      }\n    ")}}const iV={kernelName:rc,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{images:r}=t,{alignCorners:o,halfPixelCenters:s,size:i}=a,[c,l]=i,u=Vo().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new sV(r.shape,c,l,o,s):new oV(r.shape,c,l,o,s);return n.runWebGLProgram(u,[r],r.dtype)}};class cV{constructor(e,t,n){this.variableNames=["dy"],this.outputShape=[],this.outputShape=t;const[,a,r]=t,[,o,s]=e,i=[n&&o>1?a-1:a,n&&s>1?r-1:r],c=[n&&o>1?o-1:o,n&&s>1?s-1:s],l=i[0]/c[0],u=i[1]/c[1],d=1/l,h=1/u,p=2*Math.ceil(d)+2,f=2*Math.ceil(h)+2;this.userCode="\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        int r = coords[1];\n        int c = coords[2];\n\n        float accumulator = 0.0;\n\n        const float heightScale = float(".concat(l,");\n        const float widthScale = float(").concat(u,");\n\n        const float invHeightScale = float(").concat(d,");\n        const float invWidthScale = float(").concat(h,");\n\n        const int winHeight = int(").concat(p,");\n        const int winWidth = int(").concat(f,");\n\n        // Compute bounds for where in dy we will look\n        float startRLerp = floor(float(r) * invHeightScale);\n        int startDyR = int(floor(startRLerp - float(winHeight / 2)));\n\n        float startCLerp = floor(float(c) * invWidthScale);\n        int startDyC = int(floor(startCLerp - float(winWidth / 2)));\n\n        // Loop over dy\n        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {\n          int dyR = dyROffset + startDyR;\n\n          // Guard against the window exceeding the bounds of dy\n          if (dyR < 0 || dyR >= ").concat(o,") {\n            continue;\n          }\n\n          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {\n            int dyC = dyCOffset + startDyC;\n\n            // Guard against the window exceeding the bounds of dy\n            if (dyC < 0 || dyC >= ").concat(s,") {\n              continue;\n            }\n\n            float sourceFracRow =\n              float(").concat(i[0],") *\n                (float(dyR) / float(").concat(c[0],"));\n\n            float sourceFracCol =\n                float(").concat(i[1],") *\n                  (float(dyC) / float(").concat(c[1],"));\n\n            int sourceNearestRow = int(min(\n                float(int(").concat(a,") - 1),\n                ").concat(n," ? float(round(sourceFracRow)) :\n                                  float(floor(sourceFracRow))));\n\n            int sourceNearestCol = int(min(\n                float(int(").concat(r,") - 1),\n                ").concat(n," ? float(round(sourceFracCol)) :\n                                  float(floor(sourceFracCol))));\n\n            if (r == sourceNearestRow && c == sourceNearestCol) {\n              accumulator += getDy(b, dyR, dyC, d);\n            }\n          }\n        }\n        // End loop over dy\n\n        setOutput(accumulator);\n      }\n    ")}}const lV={kernelName:oc,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{images:r,dy:o}=t,{alignCorners:s}=a,i=new cV(o.shape,r.shape,s);return n.runWebGLProgram(i,[o],o.dtype)}};class uV{constructor(e,t){this.variableNames=["x"];const n=e.length;if(n>4)throw new Error("WebGL backend: Reverse of rank-".concat(n," tensor is not yet supported"));if(this.outputShape=e,1===n)return void(this.userCode="\n        void main() {\n          int coord = getOutputCoords();\n          setOutput(getX(".concat(e[0]," - coord - 1));\n        }\n      "));const a=e.map(((n,a)=>(n=>-1!==t.indexOf(n)&&1!==e[n]?"".concat(e[n]," - coords[").concat(n,"] - 1"):"coords[".concat(n,"]"))(a))).join(","),r=zO(n);this.userCode="\n      void main() {\n        ".concat(r," coords = getOutputCoords();\n        setOutput(getX(").concat(a,"));\n      }\n    ")}}class dV{constructor(e,t){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0;const n=e.length;if(n>4)throw new Error("WebGL backend: Reverse of rank-".concat(n," tensor is not yet supported"));this.outputShape=e;const a=sM("rc",n),r="".concat(a[n-1]," + 1 < ").concat(this.outputShape[n-1]),o="".concat(a[n-2]," + 1 < ").concat(this.outputShape[n-2]),s=zO(n);function i(n){const a=e.map(((a,r)=>function(n,a){return-1!==t.indexOf(n)&&1!==e[n]?"".concat(e[n]," - ").concat(a[n]," - 1"):"".concat(a[n])}(r,n))),r=a.join(","),o=a.slice(-2).join(",");return"getChannel(getX(".concat(r,"), vec2(").concat(o,"))")}this.userCode=1===n?"\n        void main(){\n          int rc = getOutputCoords();\n          vec4 result = vec4(0.);\n          result.r = getChannel(getX(".concat(e[0]," - rc - 1),\n            ").concat(e[0]," - rc - 1);\n          if(").concat(r,"){\n              result.g = getChannel(getX(").concat(e[0]," - (rc  + 1) - 1),\n                ").concat(e[0]," - (rc  + 1) - 1);\n          }\n          setOutput(result);\n        }\n      "):"\n        void main() {\n          ".concat(s," rc = getOutputCoords();\n          vec4 result = vec4(0.);\n          result.r = ").concat(function(e){return i(e)}(a.slice()),";\n          if(").concat(r,"){\n            result.g = ").concat(function(e){return e[n-1]="("+e[n-1]+" + 1)",i(e)}(a.slice()),";\n          }\n          if(").concat(o,") {\n            result.b = ").concat(function(e){return e[n-2]="("+e[n-2]+" + 1)",i(e)}(a.slice()),";\n            if(").concat(r,") {\n              result.a = ").concat(function(e){return e[n-1]="("+e[n-1]+" + 1)",e[n-2]="("+e[n-2]+" + 1)",i(e)}(a.slice()),";\n            }\n          }\n          setOutput(result);\n        }\n    ")}}const hV={kernelName:lc,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{dims:o}=a,s=r.shape.length,i=bo(o,r.shape);if(0===s)return PM({inputs:{x:r},backend:n});const c=Vo().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new dV(r.shape,i):new uV(r.shape,i);return n.runWebGLProgram(c,[r],r.dtype)}};class pV{constructor(e,t){this.variableNames=["Image"],this.outputShape=[],this.customUniforms=[{name:"params",type:"vec4"}];const n=e[1],a=e[2];this.outputShape=e;let r="";r="number"===typeof t?"float outputValue = ".concat(t.toFixed(2),";"):"\n        vec3 fill = vec3(".concat(t.join(","),");\n        float outputValue = fill[coords[3]];"),this.userCode="\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int x = coords[2];\n          int y = coords[1];\n          float coordXFloat = (float(x) - params[0]) * params[3] -\n            (float(y) - params[1]) * params[2];\n          float coordYFloat = (float(x) - params[0]) * params[2] +\n            (float(y) - params[1]) * params[3];\n          int coordX = int(round(coordXFloat + params[0]));\n          int coordY = int(round(coordYFloat + params[1]));\n          ".concat(r,"\n          if(coordX >= 0 && coordX < ").concat(a," && coordY >= 0 && coordY < ").concat(n,") {\n            outputValue = getImage(coords[0], coordY, coordX, coords[3]);\n          }\n          setOutput(outputValue);\n        }\n    ")}}const fV={kernelName:$c,backendName:"webgl",kernelFunc:e=>{let{inputs:t,attrs:n,backend:a}=e;const{image:r}=t,{radians:o,fillValue:s,center:i}=n,c=a,l=new pV(r.shape,s),[u,d]=Jm(i,r.shape[1],r.shape[2]),h=[[u,d,Math.sin(o),Math.cos(o)]];return c.runWebGLProgram(l,[r],r.dtype,h)}},mV=XM({opSnippet:"\n  // OpenGL ES does not support round function.\n  // The algorithm is based on banker's rounding.\n  float base = floor(x);\n  if ((x - base) < 0.5) {\n    return floor(x);\n  } else if ((x - base) > 0.5) {\n    return ceil(x);\n  } else {\n    if (mod(base, 2.0) == 0.0) {\n      return base;\n    } else {\n      return base + 1.0;\n    }\n  }\n"}),gV={kernelName:uc,backendName:"webgl",kernelFunc:mV},bV=XM({opSnippet:"return inversesqrt(x);",cpuKernelImpl:WD}),yV={kernelName:dc,backendName:"webgl",kernelFunc:bV};class xV{constructor(e,t,n,a,r,o){let s=arguments.length>7&&void 0!==arguments[7]&&arguments[7];this.variableNames=["updates","indices","defaultValue"],this.outputShape=o;const i=zO(r.length),c=zO(o.length);let l="";1===n?l="i":2===n&&(l="i, j");const u="getIndices(".concat(l,")");let d="";1===a?d="i":2===a&&(d="i, coords[1]");const h="getUpdates(".concat(d,")");let p="";s&&(p="coords[0], coords[1]");const f="getDefaultValue(".concat(p,")"),m=t>1?"strides[j]":"strides";this.userCode="\n        ".concat(i," strides = ").concat(i,"(").concat(r,");\n\n        void main() {\n          ").concat(c," coords = getOutputCoords();\n          float sum = 0.0;\n          bool found = false;\n          for (int i = 0; i < ").concat(e,"; i++) {\n            int flattenedIndex = 0;\n            for (int j = 0; j < ").concat(t,"; j++) {\n              int index = round(").concat(u,");\n              flattenedIndex += index * ").concat(m,";\n            }\n            if (flattenedIndex == coords[0]) {\n              sum += ").concat(h,";\n              found = true;\n            }\n          }\n          setOutput(mix(").concat(f,", sum, float(found)));\n        }\n      ")}}class vV{constructor(e,t,n,a,r,o){let s=arguments.length>7&&void 0!==arguments[7]&&arguments[7];this.variableNames=["updates","indices","defaultValue"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=o;const i=zO(r.length),c=zO(o.length);let l="";1===n?l="i":2===n&&(l="i, j");const u="getIndices(".concat(l,")");let d="";1===a?d="i":2===a&&(d="i, coords[1]");const h="getUpdates(".concat(d,")");let p="";s&&(p="coords[0], coords[1]");const f="getDefaultValue(".concat(p,")"),m=t>1?"strides[j]":"strides",g=t>1?"strides[j + 1]":"strides";this.userCode="\n        ".concat(i," strides = ").concat(i,"(").concat(r,");\n\n        void main() {\n          ").concat(c," coords = getOutputCoords();\n          vec4 sum = vec4(0.);\n          vec4 found = vec4(0.);\n          for (int i = 0; i < ").concat(e,"; i+=2) {\n            ivec2 flattenedIndex = ivec2(0);\n            for (int j = 0; j < ").concat(t,"; j+=2) {\n              ivec4 index = round(").concat(u,");\n              flattenedIndex += index.xz * ").concat(m,";\n              if (j + 1 < ").concat(t,") {\n                flattenedIndex += index.yw * ").concat(g,";\n              }\n            }\n            if (flattenedIndex[0] == coords[0] || flattenedIndex[1] == coords[0] ||\n                flattenedIndex[0] == coords[0] + 1 || flattenedIndex[1] == coords[0] + 1) {\n              vec4 updVals = ").concat(h,";\n              if (flattenedIndex[0] == coords[0]) {\n                sum.xy += updVals.xy;\n                found.xy = vec2(1.);\n              } else if (flattenedIndex[0] == coords[0] + 1) {\n                sum.zw += updVals.xy;\n                found.zw = vec2(1.);\n              }\n              if (flattenedIndex[1] == coords[0]) {\n                sum.xy += updVals.zw;\n                found.xy = vec2(1.);\n              } else if (flattenedIndex[1] == coords[0] + 1) {\n                sum.zw += updVals.zw;\n                found.zw = vec2(1.);\n              }\n            }\n          }\n          setOutput(mix(").concat(f,", sum, found));\n        }\n      ")}}const wV={kernelName:hc,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{indices:r,updates:o}=t,{shape:s}=a,{sliceRank:i,numUpdates:c,sliceSize:l,strides:u,outputSize:d}=sg(0,r,s),h=[d/l,l];if(0===d)return n.makeTensorInfo(s,r.dtype);const p=aL({inputs:{x:r},backend:n,attrs:{shape:[c,i]}}),f=aL({inputs:{x:o},backend:n,attrs:{shape:[c,l]}}),m=n.makeTensorInfo([],"float32",new Float32Array([0]));let g;g=Vo().getBool("WEBGL_PACK")?new vV(c,i,p.shape.length,f.shape.length,u,h):new xV(c,i,p.shape.length,f.shape.length,u,h);const b=n.runWebGLProgram(g,[f,p,m],f.dtype),y=aL({inputs:{x:b},backend:n,attrs:{shape:s}});return n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(b),n.disposeIntermediateTensorInfo(m),y}};class kV{constructor(e,t,n,a){this.variableNames=["sortedSequence","values"],this.customUniforms=[{name:"numInputs",type:"int"}],this.outputShape=[e,n];const r="for (int i = 0; i < ".concat(Math.ceil(Math.log2(t+1)),"; ++i) { if (left >= right) break;"),o=2===Vo().getNumber("WEBGL_VERSION")?"while (left < right) {":r,s="left"===a?"<":"<=";this.userCode="\n       int findBound(int batch, float value) {\n         int left = 0;\n         int right = numInputs;\n         int mid;\n         ".concat(o,"\n           mid = (left + right) / 2;\n           if (getSortedSequence(batch, mid) ").concat(s," value) {\n             left = mid + 1;\n           } else {\n             right = mid;\n           }\n         }\n         return right;\n       }\n\n       void main() {\n         ivec2 coords = getOutputCoords();\n         int batch = coords[0];\n         int valueIndex = coords[1];\n\n         float value = getValues(batch, valueIndex);\n\n         setOutput(float(findBound(batch, value)));\n       }\n     ")}}const IV={kernelName:fc,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{sortedSequence:r,values:o}=t,{side:s}=a,i=new kV(r.shape[0],r.shape[1],o.shape[1],s),c=[[r.shape[1]]];return n.runWebGLProgram(i,[r,o],"int32",c)}};class SV{constructor(e,t,n){let a,r;if(this.variableNames=["c","a","b"],this.outputShape=t,n>4)throw Error("Where for rank ".concat(n," is not yet supported"));if(1===n)r="resRC",a="resRC";else{const n=["resRC.x","resRC.y","resRC.z","resRC.w"],o=[],s=[];for(let a=0;a<t.length;a++)s.push("".concat(n[a])),a<e&&o.push("".concat(n[a]));a=o.join(),r=s.join()}const o=zO(n);this.userCode="\n      void main() {\n        ".concat(o," resRC = getOutputCoords();\n        float cVal = getC(").concat(a,");\n        if (cVal >= 1.0) {\n          setOutput(getA(").concat(r,"));\n        } else {\n          setOutput(getB(").concat(r,"));\n        }\n      }\n    ")}}const NV={kernelName:mc,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{condition:a,t:r,e:o}=t,s=new SV(a.shape.length,r.shape,r.shape.length);return n.runWebGLProgram(s,[a,r,o],su(r.dtype,o.dtype))}},CV=XM({opSnippet:"\n  // Stable and Attracting Fixed Point (0, 1) for Normalized Weights.\n  // see: https://arxiv.org/abs/1706.02515\n  float scaleAlpha = ".concat(ig,";\n  float scale = ").concat(cg,";\n  return (x >= 0.0) ? scale * x : scaleAlpha * (exp(x) - 1.0);\n")}),TV={kernelName:gc,backendName:"webgl",kernelFunc:CV},EV=XM({opSnippet:qM+"\n  return 1.0 / (1.0 + exp(-1.0 * x));\n",packedOpSnippet:"\n  vec4 result = 1.0 / (1.0 + exp(-1.0 * x));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n",cpuKernelImpl:UD}),RV={kernelName:wc,backendName:"webgl",kernelFunc:EV},_V=XM({opSnippet:"\n  if (isnan(x)) { return 0.0; }\n  return sign(x);\n"}),AV={kernelName:vc,backendName:"webgl",kernelFunc:_V},FV=XM({opSnippet:qM+"\n  return sin(x);\n",packedOpSnippet:"\n  vec4 result = sin(x);\n  bvec4 isNaN = isnan(x);\n  ".concat(MM,"\n  return result;\n")}),OV={kernelName:yc,backendName:"webgl",kernelFunc:FV},DV=XM({opSnippet:"\n  float e2x = exp(x);\n  return (e2x - 1.0 / e2x) / 2.0;\n"}),MV={kernelName:xc,backendName:"webgl",kernelFunc:DV},LV=XM({opSnippet:"\n  float epsilon = 1.1920928955078125e-7;\n  float threshold = log(epsilon) + 2.0;\n\n  bool too_large = x > -threshold;\n  bool too_small = x < threshold;\n\n  float result;\n  float exp_x = exp(x);\n\n  if (too_large){\n    result = x;\n  }\n  else if (too_small){\n    result = exp_x;\n  }\n  else{\n    result = log(exp_x + 1.0);\n  }\n  return result;\n"}),PV={kernelName:kc,backendName:"webgl",kernelFunc:LV},zV={kernelName:Nc,backendName:"webgl",kernelFunc:e=>{const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{blockShape:o,paddings:s}=a;so(r.shape.length<=4,(()=>"spaceToBatchND for rank > 4 with a WebGL backend not implemented yet"));const i=o.reduce(((e,t)=>e*t)),c=[[0,0]];c.push(...s);for(let b=1+o.length;b<r.shape.length;++b)c.push([0,0]);const l=[],u=zW({inputs:{x:r},backend:n,attrs:{paddings:c,constantValue:0}}),d=Zm(u.shape,o,i,!1),h=$m(d.length,o.length,!1),p=eg(u.shape,o,i,!1),f=aL({inputs:{x:u},backend:n,attrs:{shape:d}}),m=pL({inputs:{x:f},backend:n,attrs:{perm:h}}),g=aL({inputs:{x:m},backend:n,attrs:{shape:p}});return l.push(u),l.push(f),l.push(m),l.forEach((e=>n.disposeIntermediateTensorInfo(e))),g}};const BV={kernelName:Ec,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{indices:a,values:r,denseShape:o,defaultValue:s}=t;if(1!==o.shape.length)throw new Error("Dense shape must be a vector, saw:\n         ".concat(o.shape));if(2!==a.shape.length)throw new Error("Indices must be a matrix, saw:\n         ".concat(a.shape));if(1!==r.shape.length)throw new Error("Values must be a vector, saw:\n         ".concat(r.shape));if(0!==s.shape.length)throw new Error("Default value must be a scalar, saw:\n        ".concat(s.shape));const i=n.readSync(a.dataId),c=n.readSync(r.dataId),l=n.readSync(o.dataId),u=n.readSync(s.dataId)[0],[d,h,p,f,m]=jD(i,a.shape,a.dtype,c,r.dtype,l,u);return[n.makeTensorInfo(h,a.dtype,d),n.makeTensorInfo([h[0]],r.dtype,p),n.makeTensorInfo([f.length],"bool",new Uint8Array(f.map((e=>Number(e))))),n.makeTensorInfo([m.length],a.dtype,new Int32Array(m))]}};const WV={kernelName:Rc,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{inputIndices:a,inputShape:r,newShape:o}=t;if(2!==a.shape.length)throw new Error("Input indices should be a matrix but received shape ".concat(a.shape));if(1!==r.shape.length)throw new Error("Input shape should be a vector but received shape ".concat(r.shape));if(1!==o.shape.length)throw new Error("Target shape should be a vector but received shape ".concat(o.shape));const s=Array.from(n.readSync(r.dataId)),i=n.readSync(a.dataId),c=Array.from(n.readSync(o.dataId)),[l,u,d]=KD(i,a.shape,a.dtype,s,c);return[n.makeTensorInfo(u,a.dtype,l),n.makeTensorInfo([d.length],o.dtype,new Int32Array(d))]}};const VV={kernelName:_c,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{data:a,indices:r,segmentIds:o}=t;if(a.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==r.shape.length)throw new Error("Indices should be a vector but received shape\n              ".concat(r.shape));if(1!==o.shape.length)throw new Error("Segment ids should be a vector but received shape\n              ".concat(o.shape));const s=n.readSync(a.dataId),i=n.readSync(r.dataId),c=n.readSync(o.dataId),[l,u]=qD(s,a.shape,a.dtype,i,c,!0);return n.makeTensorInfo(u,a.dtype,l)}};const UV={kernelName:Ac,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{data:a,indices:r,segmentIds:o}=t;if(a.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==r.shape.length)throw new Error("Indices should be a vector but received shape\n             ".concat(r.shape));if(1!==o.shape.length)throw new Error("Segment ids should be a vector but received shape\n             ".concat(o.shape));const s=n.readSync(a.dataId),i=n.readSync(r.dataId),c=n.readSync(o.dataId),[l,u]=qD(s,a.shape,a.dtype,i,c);return n.makeTensorInfo(u,a.dtype,l)}};const GV={kernelName:Fc,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{sparseIndices:r,sparseValues:o,defaultValue:s}=t,{outputShape:i}=a,{sliceRank:c,numUpdates:l,sliceSize:u,strides:d,outputSize:h}=sg(0,r,i),p=!1;if("string"===o.dtype){const e=n.bufferSync(r),t=n.bufferSync(o),a=Ol(n.readSync(s.dataId)[0]),f=VD(e,t,i,h,u,l,c,d,a,p);return n.makeTensorInfo(i,f.dtype,f.values)}const f=new xV(l,c,r.shape.length,o.shape.length,d,[h,1],p),m=n.runWebGLProgram(f,[o,r,s],o.dtype),g=aL({inputs:{x:m},backend:n,attrs:{shape:i}});return n.disposeIntermediateTensorInfo(m),g}};const HV={kernelName:Cc,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{numOrSizeSplits:o,axis:s}=a,i=bo(s,r.shape)[0],c=Og(r,o,i),l=r.shape.length,u=new Array(l).fill(0),d=r.shape.slice();return c.map((e=>{const t=[...d];t[i]=e;const a=uP({inputs:{x:r},backend:n,attrs:{begin:u,size:t}});return u[i]+=e,a}))}},jV="return sqrt(x);",KV=XM({opSnippet:jV,packedOpSnippet:jV,cpuKernelImpl:XD}),qV={kernelName:Ic,backendName:"webgl",kernelFunc:KV},XV={kernelName:Dc,backendName:"webgl",kernelFunc:XM({opSnippet:"return x * x;"})},YV="return (a - b) * (a - b);",QV=YM({opSnippet:YV,packedOpSnippet:YV}),JV={kernelName:Oc,backendName:"webgl",kernelFunc:QV};const ZV={kernelName:Mc,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t;if("string"!==r.dtype)throw new Error("Input must be of datatype string");const o=Yg(n.readSync(r.dataId)),s=YD(o,"string",a);return n.makeTensorInfo(r.shape,"string",s)}};const $V={kernelName:Jc,backendName:"webgl",kernelFunc:function(e){let{inputs:t,attrs:n,backend:a}=e;const{x:r}=t,o=fM+"\n    return x > 0.0 ? 1.0 : float(".concat(n.alpha,");\n  "),s=new pM(r.shape,o);return a.runWebGLProgram(s,[r],r.dtype)}};class eU{constructor(e,t,n){this.variableNames=["x"],this.outputShape=n;const a=n.length,r=zO(n.length),o=zO(n.length);let s="";if(1===a)s="coords * strides + begin";else{let e=0;s=n.map(((t,a)=>(e++,1===n.length?"coords * strides[".concat(a,"] + begin[").concat(a,"]"):"coords[".concat(e-1,"] * strides[").concat(a,"] + begin[").concat(a,"]")))).join(",")}this.userCode="\n      ".concat(r," begin = ").concat(r,"(").concat(e,");\n      ").concat(r," strides = ").concat(r,"(").concat(t,");\n\n      void main() {\n        ").concat(o," coords = getOutputCoords();\n        setOutput(getX(").concat(s,"));\n      }\n    ")}}const tU={kernelName:Lc,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{begin:o,end:s,strides:i,beginMask:c,endMask:l,ellipsisMask:u,newAxisMask:d,shrinkAxisMask:h}=a,{finalShapeSparse:p,finalShape:f,isIdentity:m,sliceDim0:g,isSimpleSlice:b,begin:y,end:x,strides:v}=_h(r.shape,o,s,i,c,l,u,d,h);let w;if(m)w=aL({inputs:{x:r},backend:n,attrs:{shape:f}});else if(g||b){so(r.shape.length>=1,(()=>"Input must have rank at least 1, got: ".concat(r.shape.length)));const e=bh(y,x,v),t=uP({inputs:{x:r},backend:n,attrs:{begin:y,size:e}});w=aL({inputs:{x:t},backend:n,attrs:{shape:f}}),n.disposeIntermediateTensorInfo(t)}else{if(n.shouldExecuteOnCPU([r])){const e=n.readSync(r.dataId),t=Nd(r.shape,r.dtype,e),a=QD(p,t,v,y);w=n.makeTensorInfo(f,r.dtype,a.values)}else{const e=new eU(y,v,p);w=n.runWebGLProgram(e,[r],r.dtype)}}const k=aL({inputs:{x:w},backend:n,attrs:{shape:f}});return n.disposeIntermediateTensorInfo(w),k}};const nU={kernelName:Pc,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{separator:r,nGramWidths:o,leftPad:s,rightPad:i,padWidth:c,preserveShortSequences:l}=a,{data:u,dataSplits:d}=t,h=n.readSync(u.dataId),p=n.readSync(d.dataId),[f,m]=JD(h,p,r,o,s,i,c,l);return[n.makeTensorInfo([f.length],"string",f),n.makeTensorInfo(d.shape,"int32",m)]}};const aU={kernelName:zc,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{skipEmpty:r}=a,{input:o,delimiter:s}=t;if("string"!==o.dtype)throw new Error("Input must be of datatype string");if(1!==o.shape.length)throw new Error("Input must be a vector, got shape: ".concat(o.shape));if(0!==s.shape.length)throw new Error("Delimiter must be a scalar, got shape: ".concat(s.shape));const i=n.readSync(o.dataId),c=n.readSync(s.dataId)[0],[l,u,d]=ZD(i,c,r),h=u.length;return[n.makeTensorInfo([h,2],"int32",l),n.makeTensorInfo([h],"string",u),n.makeTensorInfo([2],"int32",new Int32Array(d))]}};const rU={kernelName:Bc,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{numBuckets:r}=a,{input:o}=t;if("string"!==o.dtype)throw new Error("Input must be of datatype string");if(r<=0)throw new Error("Number of buckets must be at least 1");const s=n.readSync(o.dataId),i=$D(s,r);return n.makeTensorInfo(o.shape,"int32",i)}},oU=XM({opSnippet:"return tan(x);"}),sU={kernelName:Vc,backendName:"webgl",kernelFunc:oU},iU=XM({opSnippet:"\n  float e2x = exp(-2.0 * abs(x));\n  return sign(x) * (1.0 - e2x) / (1.0 + e2x);\n"}),cU={kernelName:Uc,backendName:"webgl",kernelFunc:iU};const lU={kernelName:pc,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{tensor:r,indices:o,updates:s}=t,{}=a,{sliceRank:i,numUpdates:c,sliceSize:l,strides:u,outputSize:d}=sg(0,o,r.shape),h=[d/l,l];if(0===d)return n.makeTensorInfo(r.shape,o.dtype);const p=aL({inputs:{x:o},backend:n,attrs:{shape:[c,i]}}),f=aL({inputs:{x:s},backend:n,attrs:{shape:[c,l]}}),m=aL({inputs:{x:r},backend:n,attrs:{shape:h}}),g=new xV(c,i,p.shape.length,f.shape.length,u,h,!1,!0),b=n.runWebGLProgram(g,[f,p,m],m.dtype),y=aL({inputs:{x:b},backend:n,attrs:{shape:r.shape}});return n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),n.disposeIntermediateTensorInfo(b),y}};class uU{constructor(e,t){this.variableNames=["A"];const n=new Array(e.length);for(let o=0;o<n.length;o++)n[o]=e[o]*t[o];this.outputShape=n,this.rank=n.length;const a=zO(this.rank),r=function(e){const t=e.length;if(t>5)throw Error("Tile for rank ".concat(t," is not yet supported"));if(1===t)return"imod(resRC, ".concat(e[0],")");const n=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u"],a=[];for(let r=0;r<e.length;r++)a.push("imod(".concat(n[r],", ").concat(e[r],")"));return a.join()}(e);this.userCode="\n      void main() {\n        ".concat(a," resRC = getOutputCoords();\n        setOutput(getA(").concat(r,"));\n      }\n    ")}}function dU(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{reps:o}=a;if("string"===r.dtype||r.shape.length>5){const e=n.readSync(r.dataId),t="string"===r.dtype?e.map((e=>Ol(e))):e,a=Nd(r.shape,r.dtype,t),s=tM(a,o);return n.makeTensorInfo(s.shape,s.dtype,s.values)}const s=new uU(r.shape,o);return n.runWebGLProgram(s,[r],r.dtype)}const hU={kernelName:Gc,backendName:"webgl",kernelFunc:dU};class pU{constructor(e){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"negativeInf",type:"float"},{name:"dir",type:"int"},{name:"inc",type:"int"}],this.outputShape=e,this.userCode="\n       void main() {\n         ivec2 coords = getOutputCoords();\n         int batch = coords[0];\n         int elemIdx = coords[1];\n\n         // We compare elements pair-wise within a group of size 2 * inc.\n         // The comparing rule for each group alternates between ascending\n         // and descending. Within each group, we compare each pair at\n         // positions i and i+inc. To decide whether an element at position i\n         // is x0 or x1, we mod it by 2 * inc, if the result is smaller than\n         // inc, it is in the first half of the group, we denote it as x0,\n         // otherwise we denote it as x1.\n         // For example, as shown in the Bitonic top K paper referenced above,\n         // Figure5(a) shows that element[1] is in the\n         // second half of the group when group size is 2, but it is in the\n         // first half of the group when group size is 4.\n\n         bool isFirstInPair = imod(elemIdx, 2 * inc) < inc;\n         int i = isFirstInPair ? elemIdx : elemIdx - inc;\n\n         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));\n         int i1 = firstPass == 1 ? i + inc : int(getIndices(batch, i + inc));\n         float x0 = i0 < n ? getX(batch, i0) : negativeInf;\n         float x1 = i1 < n ? getX(batch, i1) : negativeInf;\n\n         // Denotes which direction indices are in (ascending or descending).\n         bool reverse = imod(elemIdx, 2 * dir) >= dir;\n         bool isGreater = x0 > x1 || (x0 == x1 && i1 > i0);\n         if (reverse == isGreater) { // Elements in opposite order of direction\n           int iTemp = i0;\n           i0 = i1;\n           i1 = iTemp;\n         }\n         if (isFirstInPair) {\n            setOutput(float(i0));\n         } else {\n            setOutput(float(i1));\n         }\n       }\n     "}}class fU{constructor(e){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"k",type:"int"}],this.outputShape=e,this.userCode="\n    void main() {\n         // Takes max of indices (0, k), (1, k + 1), (2, k + 2) ...\n         ivec2 coords = getOutputCoords();\n         int batch = coords[0];\n         int elemIdx = coords[1];\n\n         // The output size is half of the previous size.\n         // If the previous sequence is | | | | _ _ _ _  | | | |  _ _ _ _ (k=4),\n         // we only need to output the indices at positions |, the indices at\n         // positions _ can be thrown away, see Figure5(b) After Phase 2\n         // (Merge phase) in the Bitonic Top K paper referenced above.\n         // For example, the paper shows we only need to output the orange bars.\n         // The output sequence should look like this | | | | | | | |.\n         // Because the sequence is halved, to map the output index back\n         // to the previous sequence to find the corresponding value,\n         // we need to double the index. When we double the index,\n         // we basically interpolate a position, so 2i looks like\n         // | _ | _ | _ | _ | _ | _ | _. We move the | to the first k position\n         // of each 2k positions by - elemIdx % k. E.g. for output at\n         // index 4,5,6,7, we want to get the corresponding element at\n         // original index 8,9,10,11, for output at index 8,9,10,11,\n         // we want to get the corresponding element at original index\n         // 16,17,18,19, so on and so forth.\n\n         int i = elemIdx < k ? elemIdx : (elemIdx * 2 - imod(elemIdx, k));\n         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));\n         int i1 = firstPass == 1 ? i + k : int(getIndices(batch, i + k));\n\n         float x0 = getX(batch, i0);\n         float x1 = i1 < n ? getX(batch, i1) : x0;\n\n         setOutput(x0 >= x1 ? float(i0) : float(i1));\n       }\n     "}}function mU(e,t){null!==t&&e.disposeIntermediateTensorInfo(t)}function gU(e){let t=1;for(;t<e;)t*=2;return t}const bU={kernelName:Hc,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{k:o,sorted:s}=a,i=Vo().getNumber("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD"),c=Vo().getNumber("TOPK_K_CPU_HANDOFF_THRESHOLD"),l=r.shape,u=l[l.length-1];if(n.shouldExecuteOnCPU([r])||u<i||o>c){const e=n.readSync(r.dataId),[t,a]=nM(e,l,r.dtype,o,s);return[n.makeTensorInfo(t.shape,t.dtype,t.values),n.makeTensorInfo(a.shape,a.dtype,a.values)]}if(0===o)return l[l.length-1]=0,[n.makeTensorInfo(l,r.dtype,[]),n.makeTensorInfo(l,"int32",[])];if(1===u)return[r,Yz({attrs:{shape:l,dtype:"int32",value:0},backend:n})];const d=n.texData.get(r.dataId),h=null!==d&&d.isPacked,p=h?n.unpackTensor(r):r,f=lo(l)/u,m=aL({inputs:{x:p},attrs:{shape:[f,u]},backend:n});h&&mU(n,p);const g=gU(o),b=gU(u);let y=null;const x=()=>null===y?[m,m]:[m,y],v=(e,t,a)=>{const r=x(),o=new pU(a),s=[[u],[null===y?1:0],[Number.NEGATIVE_INFINITY],[e],[t]],i=y;y=n.runWebGLProgram(o,r,"int32",s),mU(n,i)};for(let N=1;N<g;N*=2){const e=2*N;for(let t=N;t>=1;t/=2)v(e,t,[f,b])}for(let N=b;N>g;N/=2){const e=x(),t=new fU([f,N/2]),a=[[u],[null===y?1:0],[g]],r=y;y=n.runWebGLProgram(t,e,"int32",a),mU(n,r);const o=g/2,s=2*o;for(let n=o;n>=1;n/=2)v(s,n,y.shape)}let w=y;y=uP({inputs:{x:y},backend:n,attrs:{begin:0,size:[f,o]}}),mU(n,w);let k=fB({inputs:{x:m,indices:y},backend:n,attrs:{axis:1,batchDims:1}});mU(n,m);const I=l.slice(0,-1);I.push(o),w=y,y=aL({inputs:{x:y},attrs:{shape:I},backend:n}),mU(n,w);const S=k;return k=aL({inputs:{x:k},attrs:{shape:I},backend:n}),mU(n,S),[k,y]}};class yU{constructor(e,t,n,a,r,o){this.variableNames=["Image","Transforms"],this.outputShape=o;const s="nearest"===n?1:2;let i;switch(a){case"constant":default:i=1;break;case"reflect":i=2;break;case"wrap":i=3;break;case"nearest":i=4}this.userCode="\n            float mapCoord(float outCoord, float len) {\n              float inCoord = outCoord;\n              if(".concat(i," == 2) {\n                if (inCoord < 0.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz2 = 2.0 * len;\n                    if (inCoord < sz2) {\n                      inCoord = sz2 * float(int(float(-inCoord / sz2))) +\n                      inCoord;\n                    }\n                    inCoord = inCoord < -len ? inCoord + sz2 : -inCoord - 1.0;\n                  }\n                } else if (inCoord > len - 1.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz2 = 2.0 * len;\n                    inCoord -= sz2 * float(int(float(inCoord / sz2)));\n                    if (inCoord >= len) {\n                      inCoord = sz2 - inCoord - 1.0;\n                    }\n                  }\n                }\n                return clamp(inCoord, 0.0, len - 1.0);\n              } else if (").concat(i," == 3) {\n                if (inCoord < 0.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz = len - 1.0;\n                    inCoord += len * (float(int(float(-inCoord / sz))) + 1.0);\n                  }\n                } else if (inCoord > len - 1.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz = len - 1.0;\n                    inCoord -= len * float(int(float(inCoord / sz)));\n                  }\n                }\n                return clamp(inCoord, 0.0, len - 1.0);\n              } else if (").concat(i," == 4) {\n                return clamp(outCoord, 0.0, len - 1.0);\n              } else {\n                return outCoord;\n              }\n            }\n\n            float readWithFillValue(int batch, int coordY, int coordX,\n              int channel) {\n              float outputValue;\n              if (0 <= coordY && coordY < ").concat(e," && 0 <= coordX && coordX < ").concat(t,") {\n                  outputValue = getImage(batch, coordY, coordX, channel);\n              } else {\n                outputValue = float(").concat(r,");\n              }\n              return outputValue;\n            }\n\n            void main() {\n              ivec4 coords = getOutputCoords();\n              float outputValue;\n              int batch = coords[0];\n              int x = coords[2];\n              int y = coords[1];\n              int channel = coords[3];\n              float xf = float(x);\n              float yf = float(y);\n              float a1 = getTransforms(batch, 0);\n              float a2 = getTransforms(batch, 1);\n              float a3 = getTransforms(batch, 2);\n              float b1 = getTransforms(batch, 3);\n              float b2 = getTransforms(batch, 4);\n              float b3 = getTransforms(batch, 5);\n              float c1 = getTransforms(batch, 6);\n              float c2 = getTransforms(batch, 7);\n              float projection = c1 * xf + c2 * yf + 1.0;\n              if (projection == 0.0) {\n                outputValue = float(").concat(r,");\n              } else {\n                float inX = (a1 * xf + a2 * yf + a3) / projection;\n                float inY = (b1 * xf + b2 * yf + b3) / projection;\n                float mapX = mapCoord(inX, float(").concat(t,"));\n                float mapY = mapCoord(inY, float(").concat(e,"));\n\n                if (").concat(s," == 1) {\n                  int coordY = int(round(mapY));\n                  int coordX = int(round(mapX));\n                  outputValue = readWithFillValue(batch, coordY, coordX,\n                    channel);\n                } else {\n                  float yFloor = floor(mapY);\n                  float xFloor = floor(mapX);\n                  float yCeil = yFloor + 1.0;\n                  float xCeil = xFloor + 1.0;\n                  float valueYFloor = (xCeil - mapX) *\n                  readWithFillValue(batch, int(yFloor), int(xFloor), channel) +\n                  (mapX - xFloor) *\n                  readWithFillValue(batch, int(yFloor), int(xCeil), channel);\n                  float valueYCeil = (xCeil - mapX) *\n                  readWithFillValue(batch, int(yCeil), int(xFloor), channel) +\n                  (mapX - xFloor) *\n                  readWithFillValue(batch, int(yCeil), int(xCeil), channel);\n                  outputValue = (yCeil - mapY) * valueYFloor +\n                  (mapY - yFloor) * valueYCeil;\n                }\n              }\n              setOutput(outputValue);\n            }\n        ")}}const xU={kernelName:jc,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{image:r,transforms:o}=t,{interpolation:s,fillMode:i,fillValue:c,outputShape:l}=a,[u,d,h,p]=r.shape,[f,m]=null!=l?l:[d,h],g=new yU(d,h,s,i,c,[u,f,m,p]);return n.runWebGLProgram(g,[r,o],"float32")}};const vU={kernelName:qc,backendName:"webgl",kernelFunc:function(e){const{inputs:t,attrs:n,backend:a}=e,{axis:r}=n,{x:o}=t;vO(o,"unique"),console.warn("WARNING: ","UI might be locked temporarily as data is being downloaded");const s=a.readSync(o.dataId),{outputValues:i,outputShape:c,indices:l}=rM(s,r,o.shape,o.dtype);return[a.makeTensorInfo(c,o.dtype,i),a.makeTensorInfo([l.length],"int32",l)]}};const wU={kernelName:Xc,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{value:r}=t;let{axis:o}=a;o<0&&(o+=r.shape.length);const s=r,i=s.shape.length,c=r.shape[o],l=new Array(i-1);let u=0;for(let m=0;m<i;m++)m!==o&&(l[u++]=s.shape[m]);const d=[],h=new Array(i).fill(0),p=s.shape.slice();p[o]=1;const f=new Array(c);for(let m=0;m<f.length;m++){h[o]=m;const e=uP({inputs:{x:s},backend:n,attrs:{begin:h,size:p}}),t=aL({inputs:{x:e},backend:n,attrs:{shape:l}});f[m]=t,d.push(e)}return d.forEach((e=>n.disposeIntermediateTensorInfo(e))),f}};class kU{constructor(e,t){this.variableNames=["x","segmentIds"];const n=e.windowSize,a=e.batchSize,r=e.inSize,o=e.numSegments,s=o*Math.ceil(r/n);this.outputShape=[a,s];const i=4*Math.floor(n/4),c=n%4,l="\n        sumValue += dot(values, segFilter);\n    ";let u="";r%n>0&&(u="\n        if (inIdx < 0 || inIdx >= ".concat(r,") {\n          return initializationValue;\n        }\n      "));let d="";r%n>0&&(d="\n        if (inIdx < 0 || inIdx >= ".concat(r,") {\n          return -1.0;\n        }\n      ")),this.userCode="\n      const float initializationValue = ".concat("0.0",";\n\n      float getValue(int batch, int inIdx) {\n        ").concat(u,"\n        return getX(batch, inIdx);\n      }\n\n      float getSegmentIdAtIndex(int inIdx) {\n        ").concat(d,"\n        return getSegmentIds(inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = int(floor(float(outIdx) / float(\n          ").concat(o,")) * float(").concat(n,"));\n        int currentSeg = int(mod(float(outIdx), float(").concat(o,")));\n\n        float sumValue = 0.0;\n\n        for (int i = 0; i < ").concat(i,"; i += 4) {\n          int inIdx = inOffset + i;\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 3)) == currentSeg ? 1 : 0\n          );\n\n          ").concat(l,"\n        }\n\n        int inIdx = inOffset + ").concat(i,";\n        if (").concat(1===c,") {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            initializationValue,\n            initializationValue,\n            initializationValue\n          );\n\n          int inIdxSeg = int(getSegmentIdAtIndex(inIdx));\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            0,\n            0,\n            0\n          );\n\n          ").concat(l,"\n        } else if (").concat(2===c,") {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            initializationValue,\n            initializationValue\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n              0,\n              0\n          );\n\n          ").concat(l,"\n        } else if (").concat(3===c,") {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            initializationValue\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,\n            0\n          );\n\n          ").concat(l,"\n        }\n        setOutput(").concat("sumValue",");\n      }\n    ")}}const IU={kernelName:Yc,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r,segmentIds:o}=t,{numSegments:s}=a,i=r.shape.length,c=[];let l=0;const u=Wp([l],i);let d=r;null!=u&&(d=pL({inputs:{x:r},backend:n,attrs:{perm:u}}),c.push(d),l=Up(1,i)[0]);const h=qg(d.shape,l,s),p=lo([d.shape[l]]),f=aL({inputs:{x:d},backend:n,attrs:{shape:[-1,p]}});c.push(f);const m=iu(r.dtype),g=(e,t,a,r,o)=>{const s=e.shape[0],i=e.shape[1],l=Kg(i,o),u=new kU({windowSize:l,inSize:i,batchSize:s,numSegments:o},t),d=n.compileAndRun(u,[e,a],r);if(c.push(d),d.shape[1]===o)return d;const h=KW({backend:n,attrs:{start:0,stop:o,step:1,dtype:"float32"}}),p=dU({inputs:{x:h},backend:n,attrs:{reps:[i/l]}});c.push(h),c.push(p);return g(d,t,p,r,o)},b=aL({inputs:{x:g(f,"unsortedSegmentSum",o,m,s)},backend:n,attrs:{shape:h}});let y=b;if(null!=u){c.push(b);const e=Vp(u);y=pL({inputs:{x:y},backend:n,attrs:{perm:e}})}return c.forEach((e=>n.disposeIntermediateTensorInfo(e))),y}},SU=[bL,xL,wL,IL,CL,RL,_L,AL,PL,zL,WL,UL,HL,KL,XL,JL,ZL,tP,nP,aP,sP,hP,pP,fP,mP,wP,SP,TP,WM,_P,zP,KP,JP,$P,ez,tz,nz,rz,sz,cz,fz,mz,gz,yz,wz,Sz,Nz,Tz,Rz,_z,Fz,Oz,Mz,Pz,Bz,Vz,Hz,qz,Qz,Zz,tB,aB,sB,lB,uB,hB,mB,bB,xB,zM,vB,MP,kB,SB,CB,GM,EB,_B,AB,OB,MB,PB,BB,VB,HB,KB,XB,QB,JB,ZB,tW,nW,aW,rW,oW,iW,uW,hW,wW,nL,IW,NW,TW,RW,bP,AW,DW,MW,BW,VW,KM,UW,GW,HW,jW,qW,xP,mW,YW,JW,$W,rL,nV,rV,iV,lV,hV,fV,gV,yV,wV,IV,NV,TV,RV,AV,OV,MV,dP,vW,PV,zV,BV,WV,VV,UV,GV,HV,qV,XV,JV,ZV,$V,tU,nU,aU,rU,yW,hL,sU,cU,lU,hU,bU,xU,fL,vU,wU,IU,OW];for(const n of SU)ul(n);class NU{constructor(e,t){this.backend=e,this.dataMover=t,this.data=new WeakMap,this.dataIdsCount=0}get(e){return this.data.has(e)||this.dataMover.moveData(this.backend,e),this.data.get(e)}set(e,t){this.dataIdsCount++,this.data.set(e,t)}has(e){return this.data.has(e)}delete(e){return this.dataIdsCount--,this.data.delete(e)}numDataIds(){return this.dataIdsCount}}class CU{refCount(e){return TU("refCount")}incRef(e){return TU("incRef")}timerAvailable(){return!0}time(e){return TU("time")}read(e){return TU("read")}readSync(e){return TU("readSync")}readToGPU(e,t){return TU("readToGPU")}numDataIds(){return TU("numDataIds")}disposeData(e,t){return TU("disposeData")}write(e,t,n){return TU("write")}move(e,t,n,a,r){return TU("move")}createTensorFromGPUData(e,t,n){return TU("createTensorFromGPUData")}memory(){return TU("memory")}floatPrecision(){return TU("floatPrecision")}epsilon(){return 32===this.floatPrecision()?1e-7:1e-4}dispose(){return TU("dispose")}}function TU(e){throw new Error("'".concat(e,"' not yet implemented or not found in the registry. ")+"This kernel may not be supported by the tfjs backend you have chosen")}function EU(e,t,n){return Math.max(e,Math.min(t,n))}function RU(e){return e%2===0?e:e+1}function _U(e,t,n){const a=e[t];e[t]=e[n],e[n]=a}function AU(e,t){if(!e)throw new Error("string"===typeof t?t:t())}function FU(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"";AU(MU(e,t),(()=>n+" Shapes ".concat(e," and ").concat(t," must match")))}function OU(e){AU(null!=e,(()=>"The input to the tensor constructor must be a non-null value."))}function DU(e){if(0===e.length)return 1;let t=e[0];for(let n=1;n<e.length;n++)t*=e[n];return t}function MU(e,t){if(e===t)return!0;if(null==e||null==t)return!1;if(e.length!==t.length)return!1;for(let n=0;n<e.length;n++)if(e[n]!==t[n])return!1;return!0}function LU(e){return e%1===0}function PU(e){const t=Math.ceil(Math.sqrt(e));return[t,Math.ceil(e/t)]}function zU(e,t){return t<=e.length?e:e+" ".repeat(t-e.length)}function BU(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:e=>0,n=arguments.length>2?arguments[2]:void 0,a=arguments.length>3?arguments[3]:void 0;return new Promise(((r,o)=>{let s=0;const i=()=>{if(e())return void r();s++;const c=t(s);null!=n&&s>=n?o():null!=a?a(i,c):setTimeout(i,c)};i()}))}function WU(e,t){let n=1,a=-1;for(let o=0;o<e.length;++o)if(e[o]>=0)n*=e[o];else if(-1===e[o]){if(-1!==a)throw Error("Shapes can only have 1 implicit size. "+"Found -1 at dim ".concat(a," and dim ").concat(o));a=o}else if(e[o]<0)throw Error("Shapes can not be < 0. Found ".concat(e[o]," at dim ").concat(o));if(-1===a){if(t>0&&t!==n)throw Error("Size(".concat(t,") must match the product of shape ").concat(e));return e}if(0===n)throw Error("Cannot infer the missing size in [".concat(e,"] when ")+"there are 0 elements");if(t%n!==0)throw Error("The implicit shape can't be a fractional number. "+"Got ".concat(t," / ").concat(n));const r=e.slice();return r[a]=t/n,r}function VU(e,t){const n=t.length;return e=null==e?t.map(((e,t)=>t)):[].concat(e),AU(e.every((e=>e>=-n&&e<n)),(()=>"All values in axis param must be in range [-".concat(n,", ").concat(n,") but ")+"got axis ".concat(e))),AU(e.every((e=>LU(e))),(()=>"All values in axis param must be integers but "+"got axis ".concat(e))),e.map((e=>e<0?n+e:e))}function UU(e,t){const n=[],a=[],r=null!=t&&Array.isArray(t)&&0===t.length,o=null==t||r?null:VU(t,e).sort();let s=0;for(let i=0;i<e.length;++i){if(null!=o){if(o[s]===i&&1!==e[i])throw new Error("Can't squeeze axis ".concat(i," since its dim '").concat(e[i],"' is not 1"));(null==o[s]||o[s]>i)&&1===e[i]&&(n.push(e[i]),a.push(i)),o[s]<=i&&s++}1!==e[i]&&(n.push(e[i]),a.push(i))}return{newShape:n,keptDims:a}}function GU(e,t){return HU(e,t)}function HU(e,t){let n=null;if(null==e||"float32"===e)n=new Float32Array(t);else if("int32"===e)n=new Int32Array(t);else if("bool"===e)n=new Uint8Array(t);else{if("string"!==e)throw new Error("Unknown data type ".concat(e));n=new Array(t)}return n}function jU(e,t){return"complex64"!==t&&(("float32"!==t||"complex64"===e)&&(("int32"!==t||"float32"===e||"complex64"===e)&&("bool"!==t||"bool"!==e)))}function KU(e){if("float32"===e||"int32"===e)return 4;if("complex64"===e)return 8;if("bool"===e)return 1;throw new Error("Unknown dtype ".concat(e))}function qU(e){return"string"===typeof e||e instanceof String}function XU(e){return Array.isArray(e)?XU(e[0]):e instanceof Float32Array?"float32":e instanceof Int32Array||e instanceof Uint8Array||e instanceof Uint8ClampedArray?"int32":"number"===typeof e?"float32":qU(e)?"string":function(e){return"boolean"===typeof e}(e)?"bool":"float32"}function YU(e){return!!(e&&e.constructor&&e.call&&e.apply)}function QU(e,t){for(let n=t;n<e;++n)if(e%n===0)return n;return e}function JU(e){const t=e.length;if(t<2)return[];const n=new Array(t-1);n[t-2]=e[t-1];for(let a=t-3;a>=0;--a)n[a]=n[a+1]*e[a+1];return n}function ZU(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const r=new Array;if(1===t.length){const o=t[0]*(a?2:1);for(let t=0;t<o;t++)r[t]=n[e+t]}else{const o=t[0],s=t.slice(1),i=s.reduce(((e,t)=>e*t))*(a?2:1);for(let t=0;t<o;t++)r[t]=ZU(e+t*i,s,n,a)}return r}function $U(e,t){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];if(0===e.length)return t[0];const a=e.reduce(((e,t)=>e*t))*(n?2:1);if(0===a)return[];if(a!==t.length)throw new Error("[".concat(e,"] does not match the input size ").concat(t.length).concat(n?" for a complex tensor":"","."));return ZU(0,e,t,n)}function eG(e,t){const n=tG(e,t);for(let a=0;a<n.length;a++)n[a]=1;return n}function tG(e,t){if(null==t||"float32"===t||"complex64"===t)return new Float32Array(e);if("int32"===t)return new Int32Array(e);if("bool"===t)return new Uint8Array(e);throw new Error("Unknown data type ".concat(t))}function nG(e,t){const n=e.reduce(((e,t)=>e*t),1);if(null==t||"float32"===t)return $U(e,new Float32Array(n));if("int32"===t)return $U(e,new Int32Array(n));if("bool"===t)return $U(e,new Uint8Array(n));throw new Error("Unknown data type ".concat(t))}function aG(e){e.forEach((t=>{AU(Number.isInteger(t)&&t>=0,(()=>"Tensor must have a shape comprised of positive integers but got "+"shape [".concat(e,"].")))}))}function rG(e,t,n){if(0===t)return 0;if(1===t)return e[0];let a=e[e.length-1];for(let r=0;r<e.length-1;++r)a+=n[r]*e[r];return a}function oG(e,t,n){if(0===t)return[];if(1===t)return[e];const a=new Array(t);for(let r=0;r<a.length-1;++r)a[r]=Math.floor(e/n[r]),e-=a[r]*n[r];return a[a.length-1]=e,a}function sG(e){return e&&e.then&&"function"===typeof e.then}const iG="tfjsflags";class cG{constructor(e){this.global=e,this.flags={},this.flagRegistry={},this.urlFlags={},this.getQueryParams=lG,this.populateURLFlags()}setPlatform(e,t){null!=this.platform&&(uG().getBool("IS_TEST")||uG().getBool("PROD")||console.warn("Platform ".concat(this.platformName," has already been set. ")+"Overwriting the platform with ".concat(e,"."))),this.platformName=e,this.platform=t}registerFlag(e,t,n){if(this.flagRegistry[e]={evaluationFn:t,setHook:n},null!=this.urlFlags[e]){const t=this.urlFlags[e];uG().getBool("IS_TEST")||uG().getBool("PROD")||console.warn("Setting feature override from URL ".concat(e,": ").concat(t,".")),this.set(e,t)}}async getAsync(e){return e in this.flags||(this.flags[e]=await this.evaluateFlag(e)),this.flags[e]}get(e){if(e in this.flags)return this.flags[e];const t=this.evaluateFlag(e);if(sG(t))throw new Error("Flag ".concat(e," cannot be synchronously evaluated. ")+"Please use getAsync() instead.");return this.flags[e]=t,this.flags[e]}getNumber(e){return this.get(e)}getBool(e){return this.get(e)}getString(e){return this.get(e)}getFlags(){return this.flags}get features(){return this.flags}set(e,t){if(null==this.flagRegistry[e])throw new Error("Cannot set flag ".concat(e," as it has not been registered."));this.flags[e]=t,null!=this.flagRegistry[e].setHook&&this.flagRegistry[e].setHook(t)}evaluateFlag(e){if(null==this.flagRegistry[e])throw new Error("Cannot evaluate flag '".concat(e,"': no evaluation function found."));return this.flagRegistry[e].evaluationFn()}setFlags(e){this.flags=Object.assign({},e)}reset(){this.flags={},this.urlFlags={},this.populateURLFlags()}populateURLFlags(){if("undefined"===typeof this.global||"undefined"===typeof this.global.location||"undefined"===typeof this.global.location.search)return;const e=this.getQueryParams(this.global.location.search);if(iG in e){e[iG].split(",").forEach((e=>{const[t,n]=e.split(":");this.urlFlags[t]=function(e,t){const n=t.toLowerCase();return"true"===n||"false"===n?"true"===n:"".concat(+n)===n?+n:t}(0,n)}))}}}function lG(e){const t={};return e.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g,(function(e){for(var n=arguments.length,a=new Array(n>1?n-1:0),r=1;r<n;r++)a[r-1]=arguments[r];return function(e,t,n){e[decodeURIComponent(t)]=decodeURIComponent(n||"")}(t,a[0],a[1]),a.join("=")})),t}function uG(){return hG}let dG,hG=null;function pG(){if(null==dG){let e;if("undefined"!==typeof window)e=window;else if("undefined"!==typeof n.g)e=n.g;else if("undefined"!==typeof process)e=process;else{if("undefined"===typeof self)throw new Error("Could not find a global object");e=self}dG=e}return dG}function fG(e,t){const n=function(){const e=pG();return null==e._tfGlobals&&(e._tfGlobals=new Map),e._tfGlobals}();if(n.has(e))return n.get(e);{const a=t();return n.set(e,a),n.get(e)}}const mG="Abs",gG="Acos",bG="Acosh",yG="Add",xG="AddN",vG="All",wG="Any",kG="ArgMax",IG="ArgMin",SG="Asin",NG="Asinh",CG="Atan",TG="Atanh",EG="Atan2",RG="AvgPool",_G="AvgPoolGrad",AG="AvgPool3D",FG="AvgPool3DGrad",OG="BatchMatMul",DG="BatchToSpaceND",MG="Bincount",LG="BitwiseAnd",PG="BroadcastArgs",zG="Cast",BG="Ceil",WG="ClipByValue",VG="Complex",UG="ComplexAbs",GG="Concat",HG="Conv2D",jG="Conv2DBackpropFilter",KG="Conv2DBackpropInput",qG="Conv3D",XG="Conv3DBackpropFilterV2",YG="Conv3DBackpropInputV2",QG="Cos",JG="Cosh",ZG="Cumprod",$G="Cumsum",eH="CropAndResize",tH="DenseBincount",nH="DepthToSpace",aH="DepthwiseConv2dNative",rH="DepthwiseConv2dNativeBackpropFilter",oH="DepthwiseConv2dNativeBackpropInput",sH="Diag",iH="Dilation2D",cH="Dilation2DBackpropInput",lH="Dilation2DBackpropFilter",uH="Draw",dH="RealDiv",hH="Einsum",pH="Elu",fH="EluGrad",mH="Erf",gH="Equal",bH="Exp",yH="ExpandDims",xH="Expm1",vH="FFT",wH="Fill",kH="FlipLeftRight",IH="Floor",SH="FloorDiv",NH="FusedBatchNorm",CH="GatherV2",TH="GatherNd",EH="Greater",RH="GreaterEqual",_H="Identity",AH="IFFT",FH="Imag",OH="IsFinite",DH="IsInf",MH="IsNan",LH="LeakyRelu",PH="Less",zH="LessEqual",BH="LinSpace",WH="Log",VH="Log1p",UH="LogicalAnd",GH="LogicalNot",HH="LogicalOr",jH="LRN",KH="LRNGrad",qH="Max",XH="Maximum",YH="MaxPool",QH="MaxPoolGrad",JH="MaxPool3D",ZH="MaxPool3DGrad",$H="MaxPoolWithArgmax",ej="Mean",tj="Min",nj="Minimum",aj="MirrorPad",rj="Mod",oj="Multinomial",sj="Multiply",ij="Neg",cj="NotEqual",lj="NonMaxSuppressionV3",uj="NonMaxSuppressionV4",dj="NonMaxSuppressionV5",hj="OnesLike",pj="OneHot",fj="Pack",mj="PadV2",gj="Pow",bj="Prelu",yj="Prod",xj="RaggedGather",vj="RaggedRange",wj="RaggedTensorToTensor",kj="Range",Ij="Real",Sj="Reciprocal",Nj="Relu",Cj="Reshape",Tj="ResizeNearestNeighbor",Ej="ResizeNearestNeighborGrad",Rj="ResizeBilinear",_j="ResizeBilinearGrad",Aj="Relu6",Fj="Reverse",Oj="Round",Dj="Rsqrt",Mj="ScatterNd",Lj="TensorScatterUpdate",Pj="SearchSorted",zj="Select",Bj="Selu",Wj="Slice",Vj="Sin",Uj="Sinh",Gj="Sign",Hj="Sigmoid",jj="Softplus",Kj="Sqrt",qj="Sum",Xj="SpaceToBatchND",Yj="SplitV",Qj="Softmax",Jj="SparseFillEmptyRows",Zj="SparseReshape",$j="SparseSegmentMean",eK="SparseSegmentSum",tK="SparseToDense",nK="SquaredDifference",aK="Square",rK="StaticRegexReplace",oK="StridedSlice",sK="StringNGrams",iK="StringSplit",cK="StringToHashBucketFast",lK="Sub",uK="Tan",dK="Tanh",hK="Tile",pK="TopK",fK="Transform",mK="Transpose",gK="Unique",bK="Unpack",yK="UnsortedSegmentSum",xK="ZerosLike",vK="Step",wK="FromPixels",kK="RotateWithOffset",IK="_FusedMatMul",SK="FusedConv2D",NK="FusedDepthwiseConv2D";function CK(){uG().getBool("IS_TEST")||uG().getBool("PROD")||console.warn(...arguments)}function TK(){uG().getBool("IS_TEST")||uG().getBool("PROD")||console.log(...arguments)}const EK=fG("kernelRegistry",(()=>new Map)),RK=fG("gradRegistry",(()=>new Map));function _K(e,t){const n=DK(e,t);return EK.get(n)}function AK(e){return RK.get(e)}function FK(e){const t=EK.entries(),n=[];for(;;){const{done:a,value:r}=t.next();if(a)break;const[o,s]=r,[i]=o.split("_");i===e&&n.push(s)}return n}function OK(e){const{kernelName:t,backendName:n}=e,a=DK(t,n);EK.has(a)&&CK("The kernel '".concat(t,"' for backend ")+"'".concat(n,"' is already registered")),EK.set(a,e)}function DK(e,t){return"".concat(t,"_").concat(e)}function MK(e){return e instanceof Float32Array||e instanceof Int32Array||e instanceof Uint8Array||e instanceof Uint8ClampedArray}const LK=ml()||fl;function PK(e){return LK.fromString(e,!0,16)}const zK=PK("c3a5c85c97cb3127"),BK=PK("b492b66fbe98f273"),WK=PK("9ae16a3b2f90404f");function VK(e){return e.xor(e.shru(47))}function UK(e,t,n){const a=e.slice(t,t+n);return LK.fromBytes(Array.from(a),!0,!0)}function GK(e,t){return UK(e,t,8)}function HK(e,t){return UK(e,t,4)}function jK(e,t){return 0===t?e:e.shru(t).or(e.shl(64-t))}function KK(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:PK("9ddfea08eb382d69"),a=e.xor(t).mul(n);a=a.xor(a.shru(47));let r=t.xor(a).mul(n);return r=r.xor(r.shru(47)),r=r.mul(n),r}function qK(e,t,n,a){return function(e,t,n,a,r,o){r=r.add(e),o=jK(o.add(r).add(a),21);const s=r;return r=(r=r.add(t)).add(n),o=o.add(jK(r,44)),[r.add(a),o.add(s)]}(GK(e,t),GK(e,t+8),GK(e,t+16),GK(e,t+24),n,a)}function XK(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:e.length;const n=LK.fromNumber(81,!0);if(t<=32)return t<=16?function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:e.length;if(t>=8){const n=WK.add(2*t),a=GK(e,0).add(WK),r=GK(e,t-8);return KK(jK(r,37).mul(n).add(a),jK(a,25).add(r).mul(n),n)}if(t>=4){const n=WK.add(2*t);return KK(HK(e,0).shl(3).add(t),HK(e,t-4),n)}if(t>0){const n=e[0]+(e[t>>1]<<8),a=t+(e[t-1]<<2);return VK(WK.mul(n).xor(zK.mul(a))).mul(WK)}return WK}(e,t):function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:e.length;const n=WK.add(2*t),a=GK(e,0).mul(BK),r=GK(e,8),o=GK(e,t-8).mul(n),s=GK(e,t-16).mul(WK);return KK(jK(a.add(r),43).add(jK(o,30)).add(s),a.add(jK(r.add(WK),18)).add(o),n)}(e,t);if(t<=64)return function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:e.length;const n=WK.add(2*t),a=GK(e,0).mul(WK),r=GK(e,8),o=GK(e,t-8).mul(n),s=GK(e,t-16).mul(WK),i=jK(a.add(r),43).add(jK(o,30)).add(s),c=KK(i,a.add(jK(r.add(WK),18)).add(o),n),l=GK(e,16).mul(n),u=GK(e,24),d=i.add(GK(e,t-32)).mul(n),h=c.add(GK(e,t-24)).mul(n);return KK(jK(l.add(u),43).add(jK(d,30)).add(h),l.add(jK(u.add(a),18)).add(d),n)}(e,t);let a=n,r=n.mul(BK).add(113),o=VK(r.mul(WK).add(113)).mul(WK),s=[LK.UZERO,LK.UZERO],i=[LK.UZERO,LK.UZERO];a=a.mul(WK).add(GK(e,0));let c=0;const l=64*(t-1>>6),u=l+(t-1&63)-63;do{a=jK(a.add(r).add(s[0]).add(GK(e,c+8)),37).mul(BK),r=jK(r.add(s[1]).add(GK(e,c+48)),42).mul(BK),a=a.xor(i[1]),r=r.add(s[0]).add(GK(e,c+40)),o=jK(o.add(i[0]),33).mul(BK),s=qK(e,c,s[1].mul(BK),a.add(i[0])),i=qK(e,c+32,o.add(i[1]),r.add(GK(e,c+16))),[o,a]=[a,o],c+=64}while(c!==l);const d=BK.add(o.and(255).shl(1));return c=u,i[0]=i[0].add(t-1&63),s[0]=s[0].add(i[0]),i[0]=i[0].add(s[0]),a=jK(a.add(r).add(s[0]).add(GK(e,c+8)),37).mul(d),r=jK(r.add(s[1]).add(GK(e,c+48)),42).mul(d),a=a.xor(i[1].mul(9)),r=r.add(s[0].mul(9).add(GK(e,c+40))),o=jK(o.add(i[0]),33).mul(d),s=qK(e,c,s[1].mul(d),a.add(i[0])),i=qK(e,c+32,o.add(i[1]),r.add(GK(e,c+16))),[o,a]=[a,o],KK(KK(s[0],i[0],d).add(VK(r).mul(zK)).add(o),KK(s[1],i[1],d).add(a),d)}function YK(e,t){return"string"===t?ZK(e):QK([e],t)}function QK(e,t){if("string"===t)throw new Error("Cannot convert a string[] to a TypedArray");if(Array.isArray(e)&&(e=tq(e)),uG().getBool("DEBUG")&&function(e,t){for(let n=0;n<e.length;n++){const a=e[n];if(isNaN(a)||!isFinite(a))throw Error("A tensor of type ".concat(t," being uploaded contains ").concat(a,"."))}}(e,t),function(e,t){return e instanceof Float32Array&&"float32"===t||e instanceof Int32Array&&"int32"===t||e instanceof Uint8Array&&"bool"===t}(e,t))return e;if(null==t||"float32"===t||"complex64"===t)return new Float32Array(e);if("int32"===t)return new Int32Array(e);if("bool"===t){const t=new Uint8Array(e.length);for(let n=0;n<t.length;++n)0!==Math.round(e[n])&&(t[n]=1);return t}throw new Error("Unknown data type ".concat(t))}function JK(){return uG().platform.now()}function ZK(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"utf-8";return t=t||"utf-8",uG().platform.encode(e,t)}function $K(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"utf-8";return t=t||"utf-8",uG().platform.decode(e,t)}function eq(e){return null!=uG().platform.isTypedArray?uG().platform.isTypedArray(e):MK(e)}function tq(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[],n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];if(null==t&&(t=[]),"boolean"===typeof e||"number"===typeof e||"string"===typeof e||sG(e)||null==e||eq(e)&&n)t.push(e);else if(Array.isArray(e)||eq(e))for(let a=0;a<e.length;++a)tq(e[a],t,n);else{let a=-1;for(const t of Object.keys(e))/^([1-9]+[0-9]*|0)$/.test(t)&&(a=Math.max(a,Number(t)));for(let r=0;r<=a;r++)tq(e[r],t,n)}return t}class nq{constructor(e,t){this.backendTimer=e,this.logger=t,null==t&&(this.logger=new rq)}profileKernel(e,t,n){let a;const r=()=>{a=n()};let o;const s=JK();if(this.backendTimer.timerAvailable())o=this.backendTimer.time(r);else{r();for(const e of a)e.dataSync();o=Promise.resolve({kernelMs:JK()-s})}if(uG().getBool("CHECK_COMPUTATION_FOR_ERRORS"))for(let i=0;i<a.length;i++){const t=a[i];t.data().then((n=>{aq(n,t.dtype,e)}))}return{kernelName:e,outputs:a,inputs:t,timeMs:o.then((e=>e.kernelMs)),extraInfo:o.then((e=>null!=e.getExtraProfileInfo?e.getExtraProfileInfo():""))}}logKernelProfile(e){const{kernelName:t,outputs:n,timeMs:a,inputs:r,extraInfo:o}=e;n.forEach((e=>{Promise.all([e.data(),a,o]).then((n=>{this.logger.logKernelProfile(t,e,n[0],n[1],r,n[2])}))}))}}function aq(e,t,n){if("float32"!==t)return!1;for(let a=0;a<e.length;a++){const t=e[a];if(isNaN(t)||!isFinite(t))return console.warn("Found ".concat(t," in the result of '").concat(n,"'")),!0}return!1}class rq{logKernelProfile(e,t,n,a,r,o){const s="number"===typeof a?zU("".concat(a,"ms"),9):a.error,i=zU(e,25),c=t.rank,l=t.size,u=zU(t.shape.toString(),14);let d="";for(const h in r){const e=r[h];if(null!=e){const n=e.shape||t.shape,a=n.length;d+="".concat(h,": ").concat(a,"D ").concat(a>0?n:""," ")}}console.log("%c".concat(i,"\t%c").concat(s,"\t%c").concat(c,"D ").concat(u,"\t%c").concat(l,"\t%c").concat(d,"\t%c").concat(o),"font-weight:bold","color:red","color:blue","color: orange","color: green","color: steelblue")}}const oq=20,sq=3,iq=7;function cq(e,t,n,a){const r=JU(t),o=function(e,t,n,a){const r=DU(t),o=a[a.length-1],s=new Array(o).fill(0),i=t.length,c="complex64"===n?hq(e):e;if(i>1)for(let l=0;l<r/o;l++){const e=l*o;for(let t=0;t<o;t++)s[t]=Math.max(s[t],lq(c[e+t],0,n).length)}return s}(e,t,n,r),s=t.length,i=dq(e,t,n,r,o),c=["Tensor"];return a&&(c.push("  dtype: ".concat(n)),c.push("  rank: ".concat(s)),c.push("  shape: [".concat(t,"]")),c.push("  values:")),c.push(i.map((e=>"    "+e)).join("\n")),c.join("\n")}function lq(e,t,n){let a;return a=Array.isArray(e)?"".concat(parseFloat(e[0].toFixed(iq))," + ")+"".concat(parseFloat(e[1].toFixed(iq)),"j"):qU(e)?"'".concat(e,"'"):"bool"===n?uq(e):parseFloat(e.toFixed(iq)).toString(),zU(a,t)}function uq(e){return 0===e?"false":"true"}function dq(e,t,n,a,r){let o=!(arguments.length>5&&void 0!==arguments[5])||arguments[5];const s="complex64"===n?2:1,i=t[0],c=t.length;if(0===c){if("complex64"===n){return[lq(hq(e)[0],0,n)]}return"bool"===n?[uq(e[0])]:[e[0].toString()]}if(1===c){if(i>oq){const t=sq*s;let a=Array.from(e.slice(0,t)),o=Array.from(e.slice((i-sq)*s,i*s));return"complex64"===n&&(a=hq(a),o=hq(o)),["["+a.map(((e,t)=>lq(e,r[t],n))).join(", ")+", ..., "+o.map(((e,t)=>lq(e,r[i-sq+t],n))).join(", ")+"]"]}return["["+("complex64"===n?hq(e):Array.from(e)).map(((e,t)=>lq(e,r[t],n))).join(", ")+"]"]}const l=t.slice(1),u=a.slice(1),d=a[0]*s,h=[];if(i>oq){for(let t=0;t<sq;t++){const a=t*d,o=a+d;h.push(...dq(e.slice(a,o),l,n,u,r,!1))}h.push("...");for(let t=i-sq;t<i;t++){const a=t*d,o=a+d;h.push(...dq(e.slice(a,o),l,n,u,r,t===i-1))}}else for(let m=0;m<i;m++){const t=m*d,a=t+d;h.push(...dq(e.slice(t,a),l,n,u,r,m===i-1))}const p=2===c?",":"";h[0]="["+(i>0?h[0]+p:"");for(let m=1;m<h.length-1;m++)h[m]=" "+h[m]+p;let f=",\n";for(let m=2;m<c;m++)f+="\n";return h[h.length-1]=" "+h[h.length-1]+"]"+(o?"":f),h}function hq(e){const t=[];for(let n=0;n<e.length;n+=2)t.push([e[n],e[n+1]]);return t}class pq{constructor(e,t,n){if(this.dtype=t,this.shape=e.slice(),this.size=DU(e),null!=n){const e=n.length;AU(e===this.size,(()=>"Length of values '".concat(e,"' does not match the size ")+"inferred by the shape '".concat(this.size,"'.")))}if("complex64"===t)throw new Error("complex64 dtype TensorBuffers are not supported. Please create a TensorBuffer for the real and imaginary parts separately and call tf.complex(real, imag).");this.values=n||HU(t,this.size),this.strides=JU(e)}set(e){for(var t=arguments.length,n=new Array(t>1?t-1:0),a=1;a<t;a++)n[a-1]=arguments[a];0===n.length&&(n=[0]),AU(n.length===this.rank,(()=>"The number of provided coordinates (".concat(n.length,") must ")+"match the rank (".concat(this.rank,")")));const r=this.locToIndex(n);this.values[r]=e}get(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];0===t.length&&(t=[0]);let a=0;for(const o of t){if(o<0||o>=this.shape[a]){const e="Requested out of range element at ".concat(t,". ")+"  Buffer shape=".concat(this.shape);throw new Error(e)}a++}let r=t[t.length-1];for(let o=0;o<t.length-1;++o)r+=this.strides[o]*t[o];return this.values[r]}locToIndex(e){if(0===this.rank)return 0;if(1===this.rank)return e[0];let t=e[e.length-1];for(let n=0;n<e.length-1;++n)t+=this.strides[n]*e[n];return t}indexToLoc(e){if(0===this.rank)return[];if(1===this.rank)return[e];const t=new Array(this.shape.length);for(let n=0;n<t.length-1;++n)t[n]=Math.floor(e/this.strides[n]),e-=t[n]*this.strides[n];return t[t.length-1]=e,t}get rank(){return this.shape.length}toTensor(){return fq().makeTensor(this.values,this.shape,this.dtype)}}let fq=null,mq=null,gq=null;class bq{constructor(e,t,n,a){this.kept=!1,this.isDisposedInternal=!1,this.shape=e.slice(),this.dtype=t||"float32",this.size=DU(e),this.strides=JU(e),this.dataId=n,this.id=a,this.rankType=this.rank<5?this.rank.toString():"higher"}get rank(){return this.shape.length}async buffer(){const e=await this.data();return mq.buffer(this.shape,this.dtype,e)}bufferSync(){return mq.buffer(this.shape,this.dtype,this.dataSync())}async array(){const e=await this.data();return $U(this.shape,e,"complex64"===this.dtype)}arraySync(){return $U(this.shape,this.dataSync(),"complex64"===this.dtype)}async data(){this.throwIfDisposed();const e=fq().read(this.dataId);if("string"===this.dtype){const n=await e;try{return n.map((e=>$K(e)))}catch(t){throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}}return e}dataToGPU(e){return this.throwIfDisposed(),fq().readToGPU(this.dataId,e)}dataSync(){this.throwIfDisposed();const e=fq().readSync(this.dataId);if("string"===this.dtype)try{return e.map((e=>$K(e)))}catch(t){throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}return e}async bytes(){this.throwIfDisposed();const e=await fq().read(this.dataId);return"string"===this.dtype?e:new Uint8Array(e.buffer)}dispose(){this.isDisposed||(this.kerasMask&&this.kerasMask.dispose(),fq().disposeTensor(this),this.isDisposedInternal=!0)}get isDisposed(){return this.isDisposedInternal}throwIfDisposed(){if(this.isDisposed)throw new Error("Tensor is disposed.")}print(){let e=arguments.length>0&&void 0!==arguments[0]&&arguments[0];return mq.print(this,e)}clone(){return this.throwIfDisposed(),mq.clone(this)}toString(){let e=arguments.length>0&&void 0!==arguments[0]&&arguments[0];return cq(this.dataSync(),this.shape,this.dtype,e)}cast(e){return this.throwIfDisposed(),mq.cast(this,e)}variable(){let e=!(arguments.length>0&&void 0!==arguments[0])||arguments[0],t=arguments.length>1?arguments[1]:void 0,n=arguments.length>2?arguments[2]:void 0;return this.throwIfDisposed(),fq().makeVariable(this,e,t,n)}}function yq(){return fG("Tensor",(()=>bq))}Object.defineProperty(bq,Symbol.hasInstance,{value:e=>!!e&&null!=e.data&&null!=e.dataSync&&null!=e.throwIfDisposed}),yq();class xq extends bq{constructor(e,t,n,a){super(e.shape,e.dtype,e.dataId,a),this.trainable=t,this.name=n}assign(e){if(e.dtype!==this.dtype)throw new Error("dtype of the new value (".concat(e.dtype,") and ")+"previous value (".concat(this.dtype,") must match"));if(!MU(e.shape,this.shape))throw new Error("shape of the new value (".concat(e.shape,") and ")+"previous value (".concat(this.shape,") must match"));fq().disposeTensor(this),this.dataId=e.dataId,fq().incRef(this,null)}dispose(){fq().disposeVariable(this),this.isDisposedInternal=!0}}var vq,wq,kq,Iq,Sq;Object.defineProperty(xq,Symbol.hasInstance,{value:e=>e instanceof bq&&null!=e.assign&&e.assign instanceof Function}),function(e){e.R0="R0",e.R1="R1",e.R2="R2",e.R3="R3",e.R4="R4",e.R5="R5",e.R6="R6"}(vq||(vq={})),function(e){e.float32="float32",e.int32="int32",e.bool="int32",e.complex64="complex64"}(wq||(wq={})),function(e){e.float32="float32",e.int32="int32",e.bool="bool",e.complex64="complex64"}(kq||(kq={})),function(e){e.float32="float32",e.int32="float32",e.bool="float32",e.complex64="complex64"}(Iq||(Iq={})),function(e){e.float32="complex64",e.int32="complex64",e.bool="complex64",e.complex64="complex64"}(Sq||(Sq={}));const Nq={float32:Iq,int32:wq,bool:kq,complex64:Sq};function Cq(e,t){if("string"===e||"string"===t){if("string"===e&&"string"===t)return"string";throw new Error("Can not upcast ".concat(e," with ").concat(t))}return Nq[e][t]}function Tq(e){return Cq(e,"int32")}function Eq(e){return null!=e&&"object"===typeof e&&"texture"in e&&e.texture instanceof WebGLTexture}function Rq(e){return"undefined"!==typeof GPUBuffer&&null!=e&&"object"===typeof e&&"buffer"in e&&e.buffer instanceof GPUBuffer}function _q(e,t){if(e.dtype===t.dtype)return[e,t];const n=Cq(e.dtype,t.dtype);return[e.cast(n),t.cast(n)]}function Aq(e){const t=[];return Fq(e,t,new Set),t}function Fq(e,t,n){if(null==e)return;if(e instanceof bq)return void t.push(e);if(a=e,!Array.isArray(a)&&"object"!==typeof a)return;var a;const r=e;for(const o in r){const e=r[o];n.has(e)||(n.add(e),Fq(e,t,n))}}function Oq(e){return null!=e.kernelName}class Dq{constructor(){this.registeredVariables={},this.nextTapeNodeId=0,this.numBytes=0,this.numTensors=0,this.numStringTensors=0,this.numDataBuffers=0,this.gradientDepth=0,this.kernelDepth=0,this.scopeStack=[],this.numDataMovesStack=[],this.nextScopeId=0,this.tensorInfo=new WeakMap,this.profiling=!1,this.activeProfile={newBytes:0,newTensors:0,peakBytes:0,kernels:[],result:null,get kernelNames(){return Array.from(new Set(this.kernels.map((e=>e.name))))}}}dispose(){for(const e in this.registeredVariables)this.registeredVariables[e].dispose()}}class Mq{constructor(e){this.ENV=e,this.registry={},this.registryFactory={},this.pendingBackendInitId=0,this.state=new Dq}async ready(){if(null!=this.pendingBackendInit)return this.pendingBackendInit.then((()=>{}));if(null!=this.backendInstance)return;const e=this.getSortedBackends();for(let t=0;t<e.length;t++){const n=e[t];if(await this.initializeBackend(n).success)return void await this.setBackend(n)}throw new Error("Could not initialize any backends, all backend initializations failed.")}get backend(){if(null!=this.pendingBackendInit)throw new Error("Backend '".concat(this.backendName,"' has not yet been initialized. Make ")+"sure to await tf.ready() or await tf.setBackend() before calling other methods");if(null==this.backendInstance){const{name:e,asyncInit:t}=this.initializeBackendsAndReturnBest();if(t)throw new Error("The highest priority backend '".concat(e,"' has not yet been ")+"initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods");this.setBackend(e)}return this.backendInstance}backendNames(){return Object.keys(this.registryFactory)}findBackend(e){if(!(e in this.registry)){if(!(e in this.registryFactory))return null;{const{asyncInit:t}=this.initializeBackend(e);if(t)return null}}return this.registry[e]}findBackendFactory(e){return e in this.registryFactory?this.registryFactory[e].factory:null}registerBackend(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1;return e in this.registryFactory?(CK("".concat(e," backend was already registered. ")+"Reusing existing backend factory."),!1):(this.registryFactory[e]={factory:t,priority:n},!0)}async setBackend(e){if(null==this.registryFactory[e])throw new Error("Backend name '".concat(e,"' not found in registry"));if(this.backendName=e,null==this.registry[e]){this.backendInstance=null;const{success:t,asyncInit:n}=this.initializeBackend(e);if(!(n?await t:t))return!1}return this.backendInstance=this.registry[e],this.setupRegisteredKernels(),this.profiler=new nq(this.backendInstance),!0}setupRegisteredKernels(){FK(this.backendName).forEach((e=>{null!=e.setupFunc&&e.setupFunc(this.backendInstance)}))}disposeRegisteredKernels(e){FK(e).forEach((t=>{null!=t.disposeFunc&&t.disposeFunc(this.registry[e])}))}initializeBackend(e){const t=this.registryFactory[e];if(null==t)throw new Error("Cannot initialize backend ".concat(e,", no registration found."));try{const n=t.factory();if(!n||n instanceof CU||"function"!==typeof n.then)return this.registry[e]=n,{success:!0,asyncInit:!1};{const t=++this.pendingBackendInitId,a=n.then((n=>!(t<this.pendingBackendInitId)&&(this.registry[e]=n,this.pendingBackendInit=null,!0))).catch((n=>(t<this.pendingBackendInitId||(this.pendingBackendInit=null,CK("Initialization of backend ".concat(e," failed")),CK(n.stack||n.message)),!1)));return this.pendingBackendInit=a,{success:a,asyncInit:!0}}}catch(Yue){return CK("Initialization of backend ".concat(e," failed")),CK(Yue.stack||Yue.message),{success:!1,asyncInit:!1}}}removeBackend(e){if(!(e in this.registryFactory))throw new Error("".concat(e," backend not found in registry"));this.backendName===e&&null!=this.pendingBackendInit&&this.pendingBackendInitId++,e in this.registry&&(this.disposeRegisteredKernels(e),this.registry[e].dispose(),delete this.registry[e]),delete this.registryFactory[e],this.backendName===e&&(this.pendingBackendInit=null,this.backendName=null,this.backendInstance=null)}getSortedBackends(){if(0===Object.keys(this.registryFactory).length)throw new Error("No backend found in registry.");return Object.keys(this.registryFactory).sort(((e,t)=>this.registryFactory[t].priority-this.registryFactory[e].priority))}initializeBackendsAndReturnBest(){const e=this.getSortedBackends();for(let t=0;t<e.length;t++){const n=e[t],{success:a,asyncInit:r}=this.initializeBackend(n);if(r||a)return{name:n,asyncInit:r}}throw new Error("Could not initialize any backends, all backend initializations failed.")}moveData(e,t){const n=this.state.tensorInfo.get(t),a=n.backend,r=this.readSync(t),o=a.refCount(t);a.disposeData(t,!0),n.backend=e,e.move(t,r,n.shape,n.dtype,o),this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack[this.state.numDataMovesStack.length-1]++}tidy(e,t){let n,a=null;if(null==t){if("function"!==typeof e)throw new Error("Please provide a function to tidy()");t=e}else{if("string"!==typeof e&&!(e instanceof String))throw new Error("When calling with two arguments, the first argument to tidy() must be a string");if("function"!==typeof t)throw new Error("When calling with two arguments, the 2nd argument to tidy() must be a function");a=e}return this.scopedRun((()=>this.startScope(a)),(()=>this.endScope(n)),(()=>(n=t(),n instanceof Promise&&console.error("Cannot return a Promise inside of tidy."),n)))}scopedRun(e,t,n){e();try{const e=n();return t(),e}catch(a){throw t(),a}}nextTensorId(){return Mq.nextTensorId++}nextVariableId(){return Mq.nextVariableId++}clone(e){const t=Pq.runKernel(_H,{x:e}),n={x:e};return this.addTapeNode(this.state.activeScope.name,n,[t],(e=>({x:()=>{const t={x:e},n={dtype:"float32"};return Pq.runKernel(zG,t,n)}})),[],{}),t}runKernel(e,t,n){null==this.backendName&&this.backend;if(!(null!=_K(e,this.backendName)))throw new Error("Kernel '".concat(e,"' not registered for backend '").concat(this.backendName,"'"));return this.runKernelFunc({kernelName:e,inputs:t,attrs:n})}shouldCheckForMemLeaks(){return this.ENV.getBool("IS_TEST")}checkKernelForMemLeak(e,t,n){const a=this.backend.numDataIds();let r=0;n.forEach((e=>{r+="complex64"===e.dtype?3:1}));const o=this.state.numDataMovesStack[this.state.numDataMovesStack.length-1],s=a-t-r-o;if(s>0)throw new Error("Backend '".concat(this.backendName,"' has an internal memory leak ")+"(".concat(s," data ids) after running '").concat(e,"'"))}runKernelFunc(e){let t,n=[];const a=this.isTapeOn(),r=this.state.numBytes,o=this.state.numTensors;let s,i;this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack.push(0),null==this.backendName&&this.backend;const c=Oq(e)?e.kernelName:null!=this.state.activeScope?this.state.activeScope.name:"";if(Oq(e)){const{kernelName:t,inputs:r,attrs:o}=e;null==this.backendName&&this.backend;const c=_K(t,this.backendName);AU(null!=c,(()=>"Cannot find registered kernel '".concat(t,"' for backend '").concat(this.backendName,"'"))),s=()=>{const e=this.backend.numDataIds();i=c.kernelFunc({inputs:r,attrs:o,backend:this.backend});const s=Array.isArray(i)?i:[i];this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(t,e,s);const l=s.map((e=>null!=e.rank?e:this.makeTensorFromTensorInfo(e)));if(a){const e=this.getTensorsForGradient(t,r,l);n=this.saveTensorsForBackwardMode(e)}return l}}else{const{forwardFunc:t}=e,r=e=>{a&&(n=e.map((e=>this.keep(this.clone(e)))))};s=()=>{const e=this.backend.numDataIds();i=this.tidy((()=>t(this.backend,r)));const n=Array.isArray(i)?i:[i];return this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(c,e,n),n}}const{inputs:l,attrs:u}=e,d=Oq(e)?null:e.backwardsFunc;let h;return this.scopedRun((()=>this.state.kernelDepth++),(()=>this.state.kernelDepth--),(()=>{this.ENV.getBool("DEBUG")||this.state.profiling?(h=this.profiler.profileKernel(c,l,(()=>s())),this.ENV.getBool("DEBUG")&&this.profiler.logKernelProfile(h),t=h.outputs):t=s()})),a&&this.addTapeNode(c,l,t,d,n,u),this.state.profiling&&this.state.activeProfile.kernels.push({name:c,bytesAdded:this.state.numBytes-r,totalBytesSnapshot:this.state.numBytes,tensorsAdded:this.state.numTensors-o,totalTensorsSnapshot:this.state.numTensors,inputShapes:Object.keys(l).map((e=>null!=l[e]?l[e].shape:null)),outputShapes:t.map((e=>e.shape)),kernelTimeMs:h.timeMs,extraInfo:h.extraInfo}),Array.isArray(i)?t:t[0]}saveTensorsForBackwardMode(e){return e.map((e=>this.keep(this.clone(e))))}getTensorsForGradient(e,t,n){const a=AK(e);if(null!=a){const e=a.inputsToSave||[],r=a.outputsToSave||[];let o;a.saveAllInputs?(AU(Array.isArray(t),(()=>"saveAllInputs is true, expected inputs to be an array.")),o=Object.keys(t).map((e=>t[e]))):o=e.map((e=>t[e]));const s=n.filter(((e,t)=>r[t]));return o.concat(s)}return[]}makeTensor(e,t,n,a){if(null==e)throw new Error("Values passed to engine.makeTensor() are null");n=n||"float32",a=a||this.backend;let r=e;"string"===n&&qU(e[0])&&(r=e.map((e=>ZK(e))));const o=a.write(r,t,n),s=new bq(t,n,o,this.nextTensorId());if(this.trackTensor(s,a),"string"===n){const e=this.state.tensorInfo.get(o),t=function(e){if(null==e)return 0;let t=0;return e.forEach((e=>t+=e.length)),t}(r);this.state.numBytes+=t-e.bytes,e.bytes=t}return s}makeTensorFromDataId(e,t,n,a){const r={dataId:e,shape:t,dtype:n=n||"float32"};return this.makeTensorFromTensorInfo(r,a)}makeTensorFromTensorInfo(e,t){const{dataId:n,shape:a,dtype:r}=e,o=new bq(a,r,n,this.nextTensorId());return this.trackTensor(o,t),o}makeVariable(e){let t=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],n=arguments.length>2?arguments[2]:void 0,a=arguments.length>3?arguments[3]:void 0;n=n||this.nextVariableId().toString(),null!=a&&a!==e.dtype&&(e=e.cast(a));const r=new xq(e,t,n,this.nextTensorId());if(null!=this.state.registeredVariables[r.name])throw new Error("Variable with name ".concat(r.name," was already registered"));return this.state.registeredVariables[r.name]=r,this.incRef(r,this.backend),r}trackTensor(e,t){this.state.numTensors++,"string"===e.dtype&&this.state.numStringTensors++;let n=0;"complex64"!==e.dtype&&"string"!==e.dtype&&(n=e.size*KU(e.dtype)),this.state.numBytes+=n,this.state.tensorInfo.has(e.dataId)||(this.state.numDataBuffers++,this.state.tensorInfo.set(e.dataId,{backend:t||this.backend,dtype:e.dtype,shape:e.shape,bytes:n})),e instanceof xq||this.track(e)}incRef(e,t){this.trackTensor(e,t),this.backend.incRef(e.dataId)}removeDataId(e,t){this.state.tensorInfo.has(e)&&this.state.tensorInfo.get(e).backend===t&&(this.state.tensorInfo.delete(e),this.state.numDataBuffers--)}disposeTensor(e){if(!this.state.tensorInfo.has(e.dataId))return;const t=this.state.tensorInfo.get(e.dataId);if(this.state.numTensors--,"string"===e.dtype&&(this.state.numStringTensors--,this.state.numBytes-=t.bytes),"complex64"!==e.dtype&&"string"!==e.dtype){const t=e.size*KU(e.dtype);this.state.numBytes-=t}t.backend.disposeData(e.dataId)&&this.removeDataId(e.dataId,t.backend)}disposeVariables(){for(const e in this.state.registeredVariables){const t=this.state.registeredVariables[e];this.disposeVariable(t)}}disposeVariable(e){this.disposeTensor(e),null!=this.state.registeredVariables[e.name]&&delete this.state.registeredVariables[e.name]}memory(){const e=this.backend.memory();return e.numTensors=this.state.numTensors,e.numDataBuffers=this.state.numDataBuffers,e.numBytes=this.state.numBytes,this.state.numStringTensors>0&&(e.unreliable=!0,null==e.reasons&&(e.reasons=[]),e.reasons.push("Memory usage by string tensors is approximate (2 bytes per character)")),e}async profile(e){this.state.profiling=!0;const t=this.state.numBytes,n=this.state.numTensors;this.state.activeProfile.kernels=[],this.state.activeProfile.result=await e(),this.state.profiling=!1,this.state.activeProfile.peakBytes=Math.max(...this.state.activeProfile.kernels.map((e=>e.totalBytesSnapshot))),this.state.activeProfile.newBytes=this.state.numBytes-t,this.state.activeProfile.newTensors=this.state.numTensors-n;for(const a of this.state.activeProfile.kernels)a.kernelTimeMs=await a.kernelTimeMs,a.extraInfo=await a.extraInfo;return this.state.activeProfile}isTapeOn(){return this.state.gradientDepth>0&&0===this.state.kernelDepth}addTapeNode(e,t,n,a,r,o){const s={id:this.state.nextTapeNodeId++,kernelName:e,inputs:t,outputs:n,saved:r},i=AK(e);null!=i&&(a=i.gradFunc),null!=a&&(s.gradient=e=>(e=e.map(((e,t)=>{if(null==e){const e=n[t],a=tG(e.size,e.dtype);return this.makeTensor(a,e.shape,e.dtype)}return e})),a(e.length>1?e:e[0],r,o))),this.state.activeTape.push(s)}keep(e){return e.kept=!0,e}startTape(){0===this.state.gradientDepth&&(this.state.activeTape=[]),this.state.gradientDepth++}endTape(){this.state.gradientDepth--}startScope(e){const t={track:[],name:"unnamed scope",id:this.state.nextScopeId++};e&&(t.name=e),this.state.scopeStack.push(t),this.state.activeScope=t}endScope(e){const t=Aq(e),n=new Set(t.map((e=>e.id)));for(let r=0;r<this.state.activeScope.track.length;r++){const e=this.state.activeScope.track[r];e.kept||n.has(e.id)||e.dispose()}const a=this.state.scopeStack.pop();this.state.activeScope=0===this.state.scopeStack.length?null:this.state.scopeStack[this.state.scopeStack.length-1],t.forEach((e=>{e.kept||e.scopeId!==a.id||this.track(e)}))}gradients(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]&&arguments[3];if(AU(t.length>0,(()=>"gradients() received an empty list of xs.")),null!=n&&"float32"!==n.dtype)throw new Error("dy must have 'float32' dtype, but has '".concat(n.dtype,"'"));const r=this.scopedRun((()=>this.startTape()),(()=>this.endTape()),(()=>this.tidy("forward",e)));AU(r instanceof bq,(()=>"The result y returned by f() must be a tensor."));const o=function(e,t,n){const a={},r={};for(let c=0;c<t.length;c++)a[t[c].id]=!0;for(let c=0;c<e.length;c++){const n=e[c],o=n.inputs;for(const e in o){const s=o[e];let i=!1;for(let e=0;e<t.length;e++)if(a[s.id]){n.outputs.forEach((e=>a[e.id]=!0)),i=!0,r[n.id]=!0;break}if(i)break}}const o={};o[n.id]=!0;const s={};for(let c=e.length-1;c>=0;c--){const t=e[c],n=t.inputs;for(let e=0;e<t.outputs.length;e++)if(o[t.outputs[e].id]){for(const e in n)o[n[e].id]=!0,s[t.id]=!0;break}}const i=[];for(let c=0;c<e.length;c++){const t=e[c];if(r[t.id]&&s[t.id]){const e={};for(const r in t.inputs){const n=t.inputs[r];a[n.id]&&(e[r]=n)}const n=Object.assign({},t);n.inputs=e,n.outputs=t.outputs,i.push(n)}}return i}(this.state.activeTape,t,r);if(!a&&0===o.length&&t.length>0)throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that the f you passed encloses all operations that lead from x to y.");return this.tidy("backward",(()=>{const e={};e[r.id]=null==n?function(e){const t=eG(DU(e),"float32");return Pq.makeTensor(t,e,"float32")}(r.shape):n,function(e,t,n,a){for(let r=t.length-1;r>=0;r--){const o=t[r],s=[];if(o.outputs.forEach((t=>{const n=e[t.id];null!=n?s.push(n):s.push(null)})),null==o.gradient)throw new Error("Cannot compute gradient: gradient function not found "+"for ".concat(o.kernelName,"."));const i=o.gradient(s);for(const t in o.inputs){if(!(t in i))throw new Error("Cannot backprop through input ".concat(t,". ")+"Available gradients found: ".concat(Object.keys(i),"."));const r=n((()=>i[t]()));if("float32"!==r.dtype)throw new Error("Error in gradient for op ".concat(o.kernelName,". The gradient of input ")+"".concat(t," must have 'float32' dtype, but has '").concat(r.dtype,"'"));const s=o.inputs[t];if(!MU(r.shape,s.shape))throw new Error("Error in gradient for op ".concat(o.kernelName,". The gradient of input ")+"'".concat(t,"' has shape '").concat(r.shape,"', which does not match ")+"the shape of the input '".concat(s.shape,"'"));if(null==e[s.id])e[s.id]=r;else{const t=e[s.id];e[s.id]=a(t,r),t.dispose()}}}}(e,o,(e=>this.tidy(e)),zq);const a=t.map((t=>e[t.id]));return 0===this.state.gradientDepth&&(this.state.activeTape.forEach((e=>{for(const t of e.saved)t.dispose()})),this.state.activeTape=null),{value:r,grads:a}}))}customGrad(e){var t=this;return AU(YU(e),(()=>"The f passed in customGrad(f) must be a function.")),function(){for(var n=arguments.length,a=new Array(n),r=0;r<n;r++)a[r]=arguments[r];let o;AU(a.every((e=>e instanceof bq)),(()=>"The args passed in customGrad(f)(x1, x2,...) must all be tensors"));const s={};a.forEach(((e,t)=>{s[t]=e}));return t.runKernelFunc({forwardFunc:(t,n)=>(o=e(...a,n),AU(o.value instanceof bq,(()=>"The function f passed in customGrad(f) must return an object where `obj.value` is a tensor")),AU(YU(o.gradFunc),(()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function.")),o.value),backwardsFunc:(e,t)=>{const n=o.gradFunc(e,t),r=Array.isArray(n)?n:[n];AU(r.length===a.length,(()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns the same number of tensors as inputs passed to f(...).")),AU(r.every((e=>e instanceof bq)),(()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns a list of only tensors."));const s={};return r.forEach(((e,t)=>{s[t]=()=>e})),s},inputs:s})}}readSync(e){return this.state.tensorInfo.get(e).backend.readSync(e)}read(e){return this.state.tensorInfo.get(e).backend.read(e)}readToGPU(e,t){return this.state.tensorInfo.get(e).backend.readToGPU(e,t)}async time(e){const t=JK(),n=await this.backend.time(e);return n.wallMs=JK()-t,n}track(e){return null!=this.state.activeScope&&(e.scopeId=this.state.activeScope.id,this.state.activeScope.track.push(e)),e}get registeredVariables(){return this.state.registeredVariables}reset(){this.pendingBackendInitId++,this.state.dispose(),this.ENV.reset(),this.state=new Dq;for(const e in this.registry)this.disposeRegisteredKernels(e),this.registry[e].dispose(),delete this.registry[e];this.backendName=null,this.backendInstance=null,this.pendingBackendInit=null}}function Lq(){const e=pG();if(null==e._tfengine){const t=new cG(e);e._tfengine=new Mq(t)}var t;return t=e._tfengine.ENV,hG=t,function(e){fq=e}((()=>e._tfengine)),e._tfengine}Mq.nextTensorId=0,Mq.nextVariableId=0;const Pq=Lq();function zq(e,t){const n={a:e,b:t};return Pq.runKernel(yG,n)}let Bq;function Wq(e){if(void 0!==Bq)return Bq;if(e||"undefined"!==typeof navigator&&null!=navigator){if(e||(e=navigator),"ReactNative"===e.product)return!0;const t=e.userAgent||e.vendor||("undefined"!==typeof window?window.opera:"");if(!t){const t=e;return t.userAgentData&&t.userAgentData.mobile}return/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(t)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(t.substr(0,4))}return!1}function Vq(){return"undefined"!==typeof window&&null!=window.document||"undefined"!==typeof WorkerGlobalScope}const Uq=uG();function Gq(e,t){let n=e;if(eq(e))return"string"===t?[]:[e.length];if(Eq(e)){const t=e.channels||"RGBA";return[e.height,e.width*t.length]}if(Rq(e))return[e.buffer.size/(null==t?4:KU(t))];if(!Array.isArray(e))return[];const a=[];for(;Array.isArray(n)||eq(n)&&"string"!==t;)a.push(n.length),n=n[0];return Array.isArray(e)&&uG().getBool("TENSORLIKE_CHECK_SHAPE_CONSISTENCY")&&Hq(e,a,[]),a}function Hq(e,t,n){if(n=n||[],!Array.isArray(e)&&!eq(e))return void AU(0===t.length,(()=>"Element arr[".concat(n.join("]["),"] is a primitive, ")+"but should be an array/TypedArray of ".concat(t[0]," elements")));AU(t.length>0,(()=>"Element arr[".concat(n.join("]["),"] should be a primitive, ")+"but is an array of ".concat(e.length," elements"))),AU(e.length===t[0],(()=>"Element arr[".concat(n.join("]["),"] should have ").concat(t[0]," ")+"elements, but has ".concat(e.length," elements")));const a=t.slice(1);for(let r=0;r<e.length;++r)Hq(e[r],a,n.concat(r))}function jq(e,t,n,a){if("string_or_numeric"!==e){if(null==e)throw new Error("Expected dtype cannot be null.");if("numeric"!==e&&e!==t||"numeric"===e&&"string"===t)throw new Error("Argument '".concat(n,"' passed to '").concat(a,"' must ")+"be ".concat(e," tensor, but got ").concat(t," tensor"))}}function Kq(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"numeric";if(e instanceof yq())return jq(a,e.dtype,t,n),e;let r=XU(e);if("string"!==r&&["bool","int32","float32"].indexOf(a)>=0&&(r=a),jq(a,r,t,n),null==e||!eq(e)&&!Array.isArray(e)&&"number"!==typeof e&&"boolean"!==typeof e&&"string"!==typeof e){const a=null==e?"null":e.constructor.name;throw new Error("Argument '".concat(t,"' passed to '").concat(n,"' must be a ")+"Tensor or TensorLike, but got '".concat(a,"'"))}const o=Gq(e,r);eq(e)||Array.isArray(e)||(e=[e]);const s="string"!==r?QK(e,r):tq(e,[],!0);return Pq.makeTensor(s,o,r)}function qq(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"numeric";if(!Array.isArray(e))throw new Error("Argument ".concat(t," passed to ").concat(n," must be a ")+"`Tensor[]` or `TensorLike[]`");return e.map(((e,r)=>Kq(e,"".concat(t,"[").concat(r,"]"),n,a)))}Uq.registerFlag("DEBUG",(()=>!1),(e=>{e&&console.warn("Debugging mode is ON. The output of every math call will be downloaded to CPU and checked for NaNs. This significantly impacts performance.")})),Uq.registerFlag("IS_BROWSER",(()=>Vq())),Uq.registerFlag("IS_NODE",(()=>"undefined"!==typeof process&&"undefined"!==typeof process.versions&&"undefined"!==typeof process.versions.node)),Uq.registerFlag("IS_CHROME",(()=>"undefined"!==typeof navigator&&null!=navigator&&null!=navigator.userAgent&&/Chrome/.test(navigator.userAgent)&&/Google Inc/.test(navigator.vendor))),Uq.registerFlag("IS_SAFARI",(()=>"undefined"!==typeof navigator&&null!=navigator&&null!=navigator.userAgent&&/Safari/.test(navigator.userAgent)&&/Apple/.test(navigator.vendor))),Uq.registerFlag("PROD",(()=>!1)),Uq.registerFlag("TENSORLIKE_CHECK_SHAPE_CONSISTENCY",(()=>Uq.getBool("DEBUG"))),Uq.registerFlag("DEPRECATION_WARNINGS_ENABLED",(()=>!0)),Uq.registerFlag("IS_TEST",(()=>!1)),Uq.registerFlag("CHECK_COMPUTATION_FOR_ERRORS",(()=>Uq.getBool("DEBUG"))),Uq.registerFlag("WRAP_TO_IMAGEBITMAP",(()=>!1)),Uq.registerFlag("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU",(()=>!1)),Uq.registerFlag("USE_SETTIMEOUTCUSTOM",(()=>!1));const Xq="__op";function Yq(e){const t=Object.keys(e);if(1!==t.length)throw new Error("Please provide an object with a single key (operation name) mapping to a function. Got an object with "+"".concat(t.length," keys."));let n=t[0];const a=e[n];n.endsWith("_")&&(n=n.substring(0,n.length-1)),n+=Xq;const r=function(){Pq.startScope(n);try{const e=a(...arguments);return sG(e)&&console.error("Cannot return a Promise inside of tidy."),Pq.endScope(e),e}catch(e){throw Pq.endScope(null),e}};return Object.defineProperty(r,"name",{value:n,configurable:!0}),r}const Qq=Yq({complex_:function(e,t){const n=Kq(e,"real","complex"),a=Kq(t,"imag","complex");FU(n.shape,a.shape,"real and imag shapes, ".concat(n.shape," and ").concat(a.shape,", ")+"must match in call to tf.complex().");const r={real:n,imag:a};return Pq.runKernel(VG,r)}});function Jq(e,t,n,a){if(null==a)a=XU(e);else if("complex64"===a)throw new Error("Cannot construct a complex64 tensor directly. Please use tf.complex(real, imag).");if(Rq(e)||Eq(e)){if("float32"!==a&&"int32"!==a)throw new Error("Creating tensor from GPU data only supports "+"'float32'|'int32' dtype, while the dtype is ".concat(a,"."));return Pq.backend.createTensorFromGPUData(e,t||n,a)}if(!eq(e)&&!Array.isArray(e)&&"number"!==typeof e&&"boolean"!==typeof e&&"string"!==typeof e)throw new Error("values passed to tensor(values) must be a number/boolean/string or an array of numbers/booleans/strings, or a TypedArray");if(null!=t){aG(t);const e=DU(t),a=DU(n);AU(e===a,(()=>"Based on the provided shape, [".concat(t,"], the tensor should have ")+"".concat(e," values but has ").concat(a)));for(let r=0;r<n.length;++r){const e=n[r],a=r!==n.length-1||e!==DU(t.slice(r));AU(n[r]===t[r]||!a,(()=>"Error creating a new Tensor. Inferred shape "+"(".concat(n,") does not match the provided ")+"shape (".concat(t,"). ")))}}return eq(e)||Array.isArray(e)||(e=[e]),t=t||n,e="string"!==a?QK(e,a):tq(e,[],!0),Pq.makeTensor(e,t,a)}function Zq(e,t,n){return Jq(e,t,Gq(e,n),n)}const $q={float32:4,float16:2,int32:4,uint16:2,uint8:1,bool:1,complex64:8};class eX{static join(e){return new eX(e).slice()}constructor(e){if(this.shards=[],this.previousShardIndex=0,null==e)return;if(e instanceof Array||(e=[e]),0===(e=e.map((e=>eq(e)?e.buffer:e))).length)return;this.bufferUniformSize=e[0].byteLength;let t=0;for(let n=0;n<e.length;n++){const a=e[n];n!==e.length-1&&a.byteLength!==this.bufferUniformSize&&(this.bufferUniformSize=void 0);const r=t+a.byteLength;this.shards.push({buffer:a,start:t,end:r}),t=r}0===this.shards.length&&(this.byteLength=0),this.byteLength=this.shards[this.shards.length-1].end}slice(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:this.byteLength;if(0===this.shards.length)return new ArrayBuffer(0);if(e=isNaN(Number(e))?0:e,t=isNaN(Number(t))?0:t,e=Math.max(0,e),t=Math.min(this.byteLength,t),t<=e)return new ArrayBuffer(0);const n=this.findShardForByte(e);if(-1===n)throw new Error("Could not find start shard for byte ".concat(e));const a=new ArrayBuffer(t-e),r=new Uint8Array(a);let o=0;for(let s=n;s<this.shards.length;s++){const n=this.shards[s],a=e+o-n.start,i=o,c=Math.min(t,n.end)-n.start,l=new Uint8Array(n.buffer,a,c-a);if(r.set(l,i),o+=l.length,t<n.end)break}return a}findShardForByte(e){if(0===this.shards.length||e<0||e>=this.byteLength)return-1;if(null!=this.bufferUniformSize)return this.previousShardIndex=Math.floor(e/this.bufferUniformSize),this.previousShardIndex;function t(t){return e<t.start?-1:e>=t.end?1:0}if(0===t(this.shards[this.previousShardIndex]))return this.previousShardIndex;const n=function(e,t){let n=0,a=e.length;for(;n<=a;){const r=Math.floor((a-n)/2)+n,o=t(e[r]);if(0===o)return r;o<0?a=r:n=r+1}return-1}(this.shards,t);return-1===n?-1:(this.previousShardIndex=n,this.previousShardIndex)}}function tX(){return Pq}function nX(e,t){return Pq.tidy(e,t)}function aX(e){Aq(e).forEach((e=>e.dispose()))}function rX(e){return Pq.keep(e)}function oX(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1;return Pq.registerBackend(e,t,n)}!function(e){gq=e}((function(e){uG().getBool("DEPRECATION_WARNINGS_ENABLED")&&console.warn(e+" You can disable deprecation warnings with tf.disableDeprecationWarnings().")}));const sX=4;async function iX(e,t){const n=[],a=[],r=Array.isArray(e)?e.map((e=>e.name)):Object.keys(e);for(let o=0;o<r.length;++o){const s=r[o],i=Array.isArray(e)?e[o].tensor:e[s];if("float32"!==i.dtype&&"int32"!==i.dtype&&"bool"!==i.dtype&&"string"!==i.dtype&&"complex64"!==i.dtype)throw new Error("Unsupported dtype in weight '".concat(s,"': ").concat(i.dtype));const c={name:s,shape:i.shape,dtype:i.dtype};if("string"===i.dtype){const e=new Promise((async e=>{const t=await i.bytes(),n=t.reduce(((e,t)=>e+t.length),0)+sX*t.length,a=new Uint8Array(n);let r=0;for(let o=0;o<t.length;o++){const e=t[o],n=new Uint8Array(new Uint32Array([e.length]).buffer);a.set(n,r),r+=sX,a.set(e,r),r+=e.length}e(a)}));a.push(e)}else a.push(i.data());null!=t&&(c.group=t),n.push(c)}return{data:fX(await Promise.all(a)),specs:n}}function cX(e,t){const n=new eX(e),a={};let r=0;for(const o of t){const e=lX(o,((e,t)=>n.slice(r+e,r+t)));a[o.name]=dX(o,n.slice(r,r+e)),r+=e}return a}function lX(e,t){const n=DU(e.shape);let a;if("quantization"in e){const t=e.quantization;a=$q[t.dtype]}else{if("string"===e.dtype){let e=0;for(let a=0;a<n;a++)e+=sX+new Uint32Array(t(e,e+sX))[0];return e}a=$q[e.dtype]}return n*a}async function uX(e,t){const n=DU(e.shape);let a;if("quantization"in e){const t=e.quantization;a=$q[t.dtype]}else{if("string"===e.dtype){let e=0;for(let a=0;a<n;a++)e+=sX+new Uint32Array(await t(e,e+sX))[0];return e}a=$q[e.dtype]}return n*a}function dX(e,t){const n=e.name,a=e.dtype,r=e.shape,o=DU(r);let s,i=0;if("quantization"in e){const r=e.quantization;if("uint8"===r.dtype||"uint16"===r.dtype){if(!("min"in r)||!("scale"in r))throw new Error("Weight ".concat(e.name," with quantization ").concat(r.dtype," ")+"doesn't have corresponding metadata min and scale.")}else{if("float16"!==r.dtype)throw new Error("Weight ".concat(e.name," has unknown ")+"quantization dtype ".concat(r.dtype,". ")+"Supported quantization dtypes are: 'uint8', 'uint16', and 'float16'.");if("float32"!==a)throw new Error("Weight ".concat(e.name," is quantized with ").concat(r.dtype," ")+"which only supports weights of type float32 not ".concat(a,"."))}const c=$q[r.dtype],l="uint8"===r.dtype?new Uint8Array(t):new Uint16Array(t);if("float32"===a)if("uint8"===r.dtype||"uint16"===r.dtype){s=new Float32Array(l.length);for(let e=0;e<l.length;e++){const t=l[e];s[e]=t*r.scale+r.min}}else{if("float16"!==r.dtype)throw new Error("Unsupported quantization type ".concat(r.dtype," ")+"for weight type float32.");{const e=function(){const e=function(){const e=e=>{let t=e<<13,n=0;for(;0===(8388608&t);)n-=8388608,t<<=1;return t&=-8388609,n+=947912704,t|n},t=new Uint32Array(2048);t[0]=0;for(let n=1;n<1024;n++)t[n]=e(n);for(let n=1024;n<2048;n++)t[n]=939524096+(n-1024<<13);return t}(),t=function(){const e=new Uint32Array(64);e[0]=0,e[31]=1199570944,e[32]=2147483648,e[63]=3347054592;for(let t=1;t<31;t++)e[t]=t<<23;for(let t=33;t<63;t++)e[t]=2147483648+(t-32<<23);return e}(),n=function(){const e=new Uint32Array(64);for(let t=0;t<64;t++)e[t]=1024;return e[0]=e[32]=0,e}();return a=>{const r=new ArrayBuffer(4*a.length),o=new Uint32Array(r);for(let s=0;s<a.length;s++){const r=a[s],i=e[n[r>>10]+(1023&r)]+t[r>>10];o[s]=i}return new Float32Array(r)}}();s=e(l)}}else{if("int32"!==a)throw new Error("Unsupported dtype in weight '".concat(n,"': ").concat(a));if("uint8"!==r.dtype&&"uint16"!==r.dtype)throw new Error("Unsupported quantization type ".concat(r.dtype," ")+"for weight type int32.");s=new Int32Array(l.length);for(let e=0;e<l.length;e++){const t=l[e];s[e]=Math.round(t*r.scale+r.min)}}i+=o*c}else if("string"===a){const n=DU(e.shape);s=[];for(let e=0;e<n;e++){const e=new Uint32Array(t.slice(i,i+sX))[0];i+=sX;const n=new Uint8Array(t.slice(i,i+e));s.push(n),i+=e}}else{const e=$q[a];if("float32"===a)s=new Float32Array(t);else if("int32"===a)s=new Int32Array(t);else{if("bool"!==a){if("complex64"===a){s=new Float32Array(t);const e=new Float32Array(s.length/2),n=new Float32Array(s.length/2);for(let t=0;t<e.length;t++)e[t]=s[2*t],n[t]=s[2*t+1];const a=Zq(e,r,"float32"),o=Zq(n,r,"float32"),i=Qq(a,o);return a.dispose(),o.dispose(),i}throw new Error("Unsupported dtype in weight '".concat(n,"': ").concat(a))}s=new Uint8Array(t)}i+=o*e}return Zq(s,r,a)}async function hX(e,t,n){let a=new Uint8Array(t);for(;a.byteLength<n;){const{done:t,value:r}=await e.read();if(t&&null==r){const e=n-a.byteLength;throw new Error("Reader is done but ".concat(e," bytes are still expected"))}const o=new Uint8Array(a.length+r.byteLength);o.set(a,0),o.set(new Uint8Array(r),a.length),a=o}return a.buffer}async function pX(e,t){const n={},a=e.getReader();let r=new ArrayBuffer(0);for(const o of t){const e=await uX(o,(async(e,t)=>(r=await hX(a,r,t),r.slice(e,t))));r=await hX(a,r,e);const t=r.slice(0,e);r=r.slice(e);const s=dX(o,t);if(n[o.name]=s,"webgpu"===Pq.backendName){const e=Pq.backend;"uploadToGPU"in e&&DU(s.shape)>=uG().get("WEBGPU_CPU_HANDOFF_SIZE_THRESHOLD")&&e.uploadToGPU(s.dataId)}}return n}function fX(e){if(null===e)throw new Error("Invalid input value: ".concat(JSON.stringify(e)));let t=0;const n=[];e.forEach((e=>{if(t+=e.byteLength,n.push(e.byteLength===e.buffer.byteLength?e:new e.constructor(e)),!(e instanceof Float32Array||e instanceof Int32Array||e instanceof Uint8Array))throw new Error("Unsupported TypedArray subtype: ".concat(e.constructor.name))}));const a=new Uint8Array(t);let r=0;return n.forEach((e=>{a.set(new Uint8Array(e.buffer),r),r+=e.byteLength})),a.buffer}const mX="undefined"!==typeof Buffer&&("undefined"===typeof Blob||"undefined"===typeof atob||"undefined"===typeof btoa);function gX(e){return mX?Buffer.byteLength(e,"utf8"):new Blob([e]).size}function bX(e){return eX.join(e)}function yX(e){for(e=e.trim();e.endsWith("/");)e=e.slice(0,e.length-1);const t=e.split("/");return t[t.length-1]}function xX(e,t){const n={modelTopology:e.modelTopology,format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy,weightsManifest:t};return null!=e.signature&&(n.signature=e.signature),null!=e.userDefinedMetadata&&(n.userDefinedMetadata=e.userDefinedMetadata),null!=e.modelInitializer&&(n.modelInitializer=e.modelInitializer),null!=e.initializerSignature&&(n.initializerSignature=e.initializerSignature),null!=e.trainingConfig&&(n.trainingConfig=e.trainingConfig),n}function vX(e,t,n){const a={modelTopology:e.modelTopology,format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy};if(null!=e.trainingConfig&&(a.trainingConfig=e.trainingConfig),null!=e.weightsManifest){if(!t)throw new Error("modelJSON has weightsManifest but weightSpecs is null");if(!n)throw new Error("modelJSON has weightsManifest but weightData is null");a.weightSpecs=t,a.weightData=n}return null!=e.signature&&(a.signature=e.signature),null!=e.userDefinedMetadata&&(a.userDefinedMetadata=e.userDefinedMetadata),null!=e.modelInitializer&&(a.modelInitializer=e.modelInitializer),null!=e.initializerSignature&&(a.initializerSignature=e.initializerSignature),a}async function wX(e,t){let n,a;return null!=e.weightsManifest&&([n,a]=await t(e.weightsManifest)),vX(e,n,a)}function kX(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("Expected JSON model topology, received ArrayBuffer.");return{dateSaved:new Date,modelTopologyType:"JSON",modelTopologyBytes:null==e.modelTopology?0:gX(JSON.stringify(e.modelTopology)),weightSpecsBytes:null==e.weightSpecs?0:gX(JSON.stringify(e.weightSpecs)),weightDataBytes:null==e.weightData?0:new eX(e.weightData).byteLength}}function IX(e){const t=[];for(const n of e)t.push(...n.weights);return t}class SX{constructor(){this.saveRouters=[],this.loadRouters=[]}static getInstance(){return null==SX.instance&&(SX.instance=new SX),SX.instance}static registerSaveRouter(e){SX.getInstance().saveRouters.push(e)}static registerLoadRouter(e){SX.getInstance().loadRouters.push(e)}static getSaveHandlers(e){return SX.getHandlers(e,"save")}static getLoadHandlers(e,t){return SX.getHandlers(e,"load",t)}static getHandlers(e,t,n){const a=[];return("load"===t?SX.getInstance().loadRouters:SX.getInstance().saveRouters).forEach((t=>{const r=t(e,n);null!==r&&a.push(r)})),a}}const NX=e=>SX.registerSaveRouter(e),CX=e=>SX.registerLoadRouter(e),TX=e=>SX.getSaveHandlers(e),EX=(e,t)=>SX.getLoadHandlers(e,t),RX="tensorflowjs",_X="models_store",AX="model_info_store";function FX(){if(!uG().getBool("IS_BROWSER"))throw new Error("Failed to obtain IndexedDB factory because the current environmentis not a web browser.");const e="undefined"===typeof window?self:window,t=e.indexedDB||e.mozIndexedDB||e.webkitIndexedDB||e.msIndexedDB||e.shimIndexedDB;if(null==t)throw new Error("The current browser does not appear to support IndexedDB.");return t}function OX(e){const t=e.result;t.createObjectStore(_X,{keyPath:"modelPath"}),t.createObjectStore(AX,{keyPath:"modelPath"})}class DX{constructor(e){if(this.indexedDB=FX(),null==e||!e)throw new Error("For IndexedDB, modelPath must not be null, undefined or empty.");this.modelPath=e}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");return this.databaseAction(this.modelPath,e)}async load(){return this.databaseAction(this.modelPath)}databaseAction(e,t){return new Promise(((e,n)=>{const a=this.indexedDB.open(RX,1);a.onupgradeneeded=()=>OX(a),a.onsuccess=()=>{const r=a.result;if(null==t){const t=r.transaction(_X,"readonly"),a=t.objectStore(_X).get(this.modelPath);a.onsuccess=()=>{if(null==a.result)return r.close(),n(new Error("Cannot find model with path '".concat(this.modelPath,"' ")+"in IndexedDB."));e(a.result.modelArtifacts)},a.onerror=e=>(r.close(),n(a.error)),t.oncomplete=()=>r.close()}else{t.weightData=eX.join(t.weightData);const a=kX(t),s=r.transaction(AX,"readwrite");let i,c,l=s.objectStore(AX);try{i=l.put({modelPath:this.modelPath,modelArtifactsInfo:a})}catch(o){return n(o)}i.onsuccess=()=>{c=r.transaction(_X,"readwrite");const i=c.objectStore(_X);let u;try{u=i.put({modelPath:this.modelPath,modelArtifacts:t,modelArtifactsInfo:a})}catch(o){return n(o)}u.onsuccess=()=>e({modelArtifactsInfo:a}),u.onerror=e=>{l=s.objectStore(AX);const t=l.delete(this.modelPath);t.onsuccess=()=>(r.close(),n(u.error)),t.onerror=e=>(r.close(),n(u.error))}},i.onerror=e=>(r.close(),n(i.error)),s.oncomplete=()=>{null==c?r.close():c.oncomplete=()=>r.close()}}},a.onerror=e=>n(a.error)}))}}DX.URL_SCHEME="indexeddb://";const MX=e=>{return uG().getBool("IS_BROWSER")&&!Array.isArray(e)&&e.startsWith(DX.URL_SCHEME)?(t=e.slice(DX.URL_SCHEME.length),new DX(t)):null;var t};SX.registerSaveRouter(MX),SX.registerLoadRouter(MX);class LX{constructor(){this.indexedDB=FX()}async listModels(){return new Promise(((e,t)=>{const n=this.indexedDB.open(RX,1);n.onupgradeneeded=()=>OX(n),n.onsuccess=()=>{const a=n.result,r=a.transaction(AX,"readonly"),o=r.objectStore(AX).getAll();o.onsuccess=()=>{const t={};for(const e of o.result)t[e.modelPath]=e.modelArtifactsInfo;e(t)},o.onerror=e=>(a.close(),t(o.error)),r.oncomplete=()=>a.close()},n.onerror=e=>t(n.error)}))}async removeModel(e){var t;return e=(t=e).startsWith(DX.URL_SCHEME)?t.slice(DX.URL_SCHEME.length):t,new Promise(((t,n)=>{const a=this.indexedDB.open(RX,1);a.onupgradeneeded=()=>OX(a),a.onsuccess=()=>{const r=a.result,o=r.transaction(AX,"readwrite"),s=o.objectStore(AX),i=s.get(e);let c;i.onsuccess=()=>{if(null==i.result)return r.close(),n(new Error("Cannot find model with path '".concat(e,"' ")+"in IndexedDB."));{const a=s.delete(e),o=()=>{c=r.transaction(_X,"readwrite");const a=c.objectStore(_X).delete(e);a.onsuccess=()=>t(i.result.modelArtifactsInfo),a.onerror=e=>n(i.error)};a.onsuccess=o,a.onerror=e=>(o(),r.close(),n(i.error))}},i.onerror=e=>(r.close(),n(i.error)),o.oncomplete=()=>{null==c?r.close():c.oncomplete=()=>r.close()}},a.onerror=e=>n(a.error)}))}}const PX="/",zX="tensorflowjs_models",BX="info",WX="model_topology",VX="weight_specs",UX="weight_data",GX="model_metadata";function HX(e){return{info:[zX,e,BX].join(PX),topology:[zX,e,WX].join(PX),weightSpecs:[zX,e,VX].join(PX),weightData:[zX,e,UX].join(PX),modelMetadata:[zX,e,GX].join(PX)}}function jX(e){for(const t of Object.values(e))window.localStorage.removeItem(t)}function KX(e){const t=e.split(PX);if(t.length<3)throw new Error("Invalid key format: ".concat(e));return t.slice(1,t.length-1).join(PX)}class qX{constructor(e){if(!uG().getBool("IS_BROWSER")||"undefined"===typeof window||"undefined"===typeof window.localStorage)throw new Error("The current environment does not support local storage.");if(this.LS=window.localStorage,null==e||!e)throw new Error("For local storage, modelPath must not be null, undefined or empty.");this.modelPath=e,this.keys=HX(this.modelPath)}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");{const t=JSON.stringify(e.modelTopology),n=JSON.stringify(e.weightSpecs),a=kX(e),r=eX.join(e.weightData);try{this.LS.setItem(this.keys.info,JSON.stringify(a)),this.LS.setItem(this.keys.topology,t),this.LS.setItem(this.keys.weightSpecs,n),this.LS.setItem(this.keys.weightData,function(e){if(mX)return Buffer.from(e).toString("base64");const t=new Uint8Array(e);let n="";for(let a=0,r=t.length;a<r;a++)n+=String.fromCharCode(t[a]);return btoa(n)}(r));const o={format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy,signature:null!=e.signature?e.signature:void 0,userDefinedMetadata:null!=e.userDefinedMetadata?e.userDefinedMetadata:void 0,modelInitializer:null!=e.modelInitializer?e.modelInitializer:void 0,initializerSignature:null!=e.initializerSignature?e.initializerSignature:void 0,trainingConfig:null!=e.trainingConfig?e.trainingConfig:void 0};return this.LS.setItem(this.keys.modelMetadata,JSON.stringify(o)),{modelArtifactsInfo:a}}catch(Yue){throw jX(this.keys),new Error("Failed to save model '".concat(this.modelPath,"' to local storage: ")+"size quota being exceeded is a possible cause of this failure: "+"modelTopologyBytes=".concat(a.modelTopologyBytes,", ")+"weightSpecsBytes=".concat(a.weightSpecsBytes,", ")+"weightDataBytes=".concat(a.weightDataBytes,"."))}}}async load(){const e=JSON.parse(this.LS.getItem(this.keys.info));if(null==e)throw new Error("In local storage, there is no model with name '".concat(this.modelPath,"'"));if("JSON"!==e.modelTopologyType)throw new Error("BrowserLocalStorage does not support loading non-JSON model topology yet.");const t={},n=JSON.parse(this.LS.getItem(this.keys.topology));if(null==n)throw new Error("In local storage, the topology of model '".concat(this.modelPath,"' ")+"is missing.");t.modelTopology=n;const a=JSON.parse(this.LS.getItem(this.keys.weightSpecs));if(null==a)throw new Error("In local storage, the weight specs of model '".concat(this.modelPath,"' ")+"are missing.");t.weightSpecs=a;const r=this.LS.getItem(this.keys.modelMetadata);if(null!=r){const e=JSON.parse(r);t.format=e.format,t.generatedBy=e.generatedBy,t.convertedBy=e.convertedBy,null!=e.signature&&(t.signature=e.signature),null!=e.userDefinedMetadata&&(t.userDefinedMetadata=e.userDefinedMetadata),null!=e.modelInitializer&&(t.modelInitializer=e.modelInitializer),null!=e.initializerSignature&&(t.initializerSignature=e.initializerSignature),null!=e.trainingConfig&&(t.trainingConfig=e.trainingConfig)}const o=this.LS.getItem(this.keys.weightData);if(null==o)throw new Error("In local storage, the binary weight values of model "+"'".concat(this.modelPath,"' are missing."));return t.weightData=function(e){if(mX){const t=Buffer.from(e,"base64");return t.buffer.slice(t.byteOffset,t.byteOffset+t.byteLength)}const t=atob(e),n=new Uint8Array(t.length);for(let a=0;a<t.length;++a)n.set([t.charCodeAt(a)],a);return n.buffer}(o),t}}qX.URL_SCHEME="localstorage://";const XX=e=>{return uG().getBool("IS_BROWSER")&&!Array.isArray(e)&&e.startsWith(qX.URL_SCHEME)?(t=e.slice(qX.URL_SCHEME.length),new qX(t)):null;var t};SX.registerSaveRouter(XX),SX.registerLoadRouter(XX);class YX{constructor(){AU(uG().getBool("IS_BROWSER"),(()=>"Current environment is not a web browser")),AU("undefined"===typeof window||"undefined"!==typeof window.localStorage,(()=>"Current browser does not appear to support localStorage")),this.LS=window.localStorage}async listModels(){const e={},t=zX+PX,n=PX+BX;for(let a=0;a<this.LS.length;++a){const r=this.LS.key(a);if(r.startsWith(t)&&r.endsWith(n)){e[KX(r)]=JSON.parse(this.LS.getItem(r))}}return e}async removeModel(e){var t;const n=HX(e=(t=e).startsWith(qX.URL_SCHEME)?t.slice(qX.URL_SCHEME.length):t);if(null==this.LS.getItem(n.info))throw new Error("Cannot find model at path '".concat(e,"'"));const a=JSON.parse(this.LS.getItem(n.info));return jX(n),a}}const QX="://";class JX{constructor(){this.managers={}}static getInstance(){return null==JX.instance&&(JX.instance=new JX),JX.instance}static registerManager(e,t){AU(null!=e,(()=>"scheme must not be undefined or null.")),e.endsWith(QX)&&(e=e.slice(0,e.indexOf(QX))),AU(e.length>0,(()=>"scheme must not be an empty string."));const n=JX.getInstance();AU(null==n.managers[e],(()=>"A model store manager is already registered for scheme '".concat(e,"'."))),n.managers[e]=t}static getManager(e){const t=JX.getInstance().managers[e];if(null==t)throw new Error("Cannot find model manager for scheme '".concat(e,"'"));return t}static getSchemes(){return Object.keys(JX.getInstance().managers)}}function ZX(e){if(-1===e.indexOf(QX))throw new Error("The url string provided does not contain a scheme. Supported schemes are: "+"".concat(JX.getSchemes().join(",")));return{scheme:e.split(QX)[0],path:e.split(QX)[1]}}async function $X(e,t){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];AU(e!==t,(()=>"Old path and new path are the same: '".concat(e,"'")));const a=SX.getLoadHandlers(e);AU(a.length>0,(()=>"Copying failed because no load handler is found for source URL ".concat(e,"."))),AU(a.length<2,(()=>"Copying failed because more than one (".concat(a.length,") ")+"load handlers for source URL ".concat(e,".")));const r=a[0],o=SX.getSaveHandlers(t);AU(o.length>0,(()=>"Copying failed because no save handler is found for destination "+"URL ".concat(t,"."))),AU(o.length<2,(()=>"Copying failed because more than one (".concat(a.length,") ")+"save handlers for destination URL ".concat(t,".")));const s=o[0],i=ZX(e).scheme,c=ZX(e).path,l=i===ZX(e).scheme,u=await r.load();n&&l&&await JX.getManager(i).removeModel(c);const d=await s.save(u);return n&&!l&&await JX.getManager(i).removeModel(c),d.modelArtifactsInfo}async function eY(){const e=JX.getSchemes(),t={};for(const n of e){const e=await JX.getManager(n).listModels();for(const a in e){t[n+QX+a]=e[a]}}return t}async function tY(e){const t=ZX(e);return JX.getManager(t.scheme).removeModel(t.path)}async function nY(e,t){return $X(e,t,!1)}async function aY(e,t){return $X(e,t,!0)}class rY{constructor(){this.messageName="setTimeoutCustom",this.functionRefs=[],this.handledMessageCount=0,this.hasEventListener=!1}fetch(e,t){return fetch(e,t)}now(){return performance.now()}encode(e,t){if("utf-8"!==t&&"utf8"!==t)throw new Error("Browser's encoder only supports utf-8, but got ".concat(t));return null==this.textEncoder&&(this.textEncoder=new TextEncoder),this.textEncoder.encode(e)}decode(e,t){return new TextDecoder(t).decode(e)}setTimeoutCustom(e,t){"undefined"!==typeof window&&uG().getBool("USE_SETTIMEOUTCUSTOM")?(this.functionRefs.push(e),setTimeout((()=>{window.postMessage({name:this.messageName,index:this.functionRefs.length-1},"*")}),t),this.hasEventListener||(this.hasEventListener=!0,window.addEventListener("message",(e=>{if(e.source===window&&e.data.name===this.messageName){e.stopPropagation();(0,this.functionRefs[e.data.index])(),this.handledMessageCount++,this.handledMessageCount===this.functionRefs.length&&(this.functionRefs=[],this.handledMessageCount=0)}}),!0))):setTimeout(e,t)}isTypedArray(e){return MK(e)}}if(uG().get("IS_BROWSER")){uG().setPlatform("browser",new rY);try{JX.registerManager(qX.URL_SCHEME,new YX)}catch(Yue){}try{JX.registerManager(DX.URL_SCHEME,new LX)}catch(Yue){}}const oY=()=>n(817);let sY;class iY{constructor(){this.util=n(590),this.textEncoder=new this.util.TextEncoder}fetch(e,t){return null!=uG().global.fetch?uG().global.fetch(e,t):(null==sY&&(sY=oY()),sY(e,t))}now(){const e=process.hrtime();return 1e3*e[0]+e[1]/1e6}encode(e,t){if("utf-8"!==t&&"utf8"!==t)throw new Error("Node built-in encoder only supports utf-8, but got ".concat(t));return this.textEncoder.encode(e)}decode(e,t){return 0===e.length?"":new this.util.TextDecoder(t).decode(e)}isTypedArray(e){return this.util.types.isFloat32Array(e)||this.util.types.isInt32Array(e)||this.util.types.isUint8Array(e)||this.util.types.isUint8ClampedArray(e)}}function cY(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"float32",n=arguments.length>2?arguments[2]:void 0;return t=t||"float32",aG(e),new pq(e,t,n)}uG().get("IS_NODE")&&!uG().get("IS_BROWSER")&&uG().setPlatform("node",new iY);const lY=Yq({cast_:function(e,t){const n=Kq(e,"x","cast");if(!function(e){return"bool"===e||"complex64"===e||"float32"===e||"int32"===e||"string"===e}(t))throw new Error("Failed to cast to unknown dtype ".concat(t));if("string"===t&&"string"!==n.dtype||"string"!==t&&"string"===n.dtype)throw new Error("Only strings can be casted to strings");const a={x:n},r={dtype:t};return Pq.runKernel(zG,a,r)}});const uY=Yq({clone_:function(e){const t={x:Kq(e,"x","clone","string_or_numeric")};return Pq.runKernel(_H,t)}});function dY(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];console.log(e.toString(t))}Lq();!function(e){mq=e}({buffer:cY,cast:lY,clone:uY,print:dY});const hY=Yq({add_:function(e,t){let n=Kq(e,"a","add"),a=Kq(t,"b","add");[n,a]=_q(n,a);const r={a:n,b:a};return Pq.runKernel(yG,r)}});const pY=Yq({floorDiv_:function(e,t){let n=Kq(e,"a","floorDiv"),a=Kq(t,"b","floorDiv");[n,a]=_q(n,a);const r={a:n,b:a};return Pq.runKernel(SH,r)}});const fY=Yq({div_:function(e,t){let n=Kq(e,"a","div"),a=Kq(t,"b","div");if([n,a]=_q(n,a),"int32"===n.dtype&&"int32"===a.dtype)return pY(n,a);const r={a:n,b:a};return Pq.runKernel(dH,r,{})}});const mY=Yq({mul_:function(e,t){let n=Kq(e,"a","mul"),a=Kq(t,"b","mul");[n,a]=_q(n,a);const r={a:n,b:a};return Pq.runKernel(sj,r)}});const gY=Yq({sqrt_:function(e){const t={x:Kq(e,"x","sqrt","float32")};return Pq.runKernel(Kj,t)}});const bY=Yq({square_:function(e){const t=Kq(e,"x","square");return Pq.runKernel("Square",{x:t},{})}});const yY=Yq({zerosLike_:function(e){const t={x:Kq(e,"x","zerosLike")};return Pq.runKernel(xK,t)}});function xY(e){return Pq.customGrad(e)}function vY(e,t){if((eq(e)&&"string"!==t||Array.isArray(e))&&"complex64"!==t)throw new Error("Error creating a new Scalar: value must be a primitive (number|boolean|string)");if("string"===t&&eq(e)&&!(e instanceof Uint8Array))throw new Error("When making a scalar from encoded string, the value must be `Uint8Array`.");return Jq(e,[],[],t)}const wY=new Map,kY=new Map;class IY{getClassName(){return this.constructor.className}static fromConfig(e,t){return new e(t)}}class SY{constructor(){this.classNameMap={}}static getMap(){return null==SY.instance&&(SY.instance=new SY),SY.instance}static register(e){SY.getMap().classNameMap[e.className]=[e,e.fromConfig]}}function NY(e,t,n){AU(null!=e.className,(()=>"Class being registered does not have the static className property defined.")),AU("string"===typeof e.className,(()=>"className is required to be a string, but got type "+typeof e.className)),AU(e.className.length>0,(()=>"Class being registered has an empty-string as its className, which is disallowed.")),"undefined"===typeof t&&(t="Custom"),"undefined"===typeof n&&(n=e.className);const a=t+">"+n;return SY.register(e),wY.set(a,e),kY.set(e,a),e}class CY extends IY{minimize(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1],n=arguments.length>2?arguments[2]:void 0;const{value:a,grads:r}=this.computeGradients(e,n);if(null!=n){const e=n.map((e=>({name:e.name,tensor:r[e.name]})));this.applyGradients(e)}else this.applyGradients(r);return aX(r),t?a:(a.dispose(),null)}get iterations(){return null==this.iterations_&&(this.iterations_=0),this.iterations_}incrementIterations(){this.iterations_=this.iterations+1}computeGradients(e,t){return function(e,t){AU(YU(e),(()=>"The f passed in variableGrads(f) must be a function")),AU(null==t||Array.isArray(t)&&t.every((e=>e instanceof xq)),(()=>"The varList passed in variableGrads(f, varList) must be an array of variables"));const n=null!=t;if(!n){t=[];for(const e in Pq.registeredVariables)t.push(Pq.registeredVariables[e])}const a=n?t.filter((e=>!e.trainable)):null,r=t.length;t=t.filter((e=>e.trainable)),AU(t.length>0,(()=>"variableGrads() expects at least one of the input variables to "+"be trainable, but none of the ".concat(r," variables is ")+"trainable."));const{value:o,grads:s}=Pq.gradients(e,t,null,!0);AU(s.some((e=>null!=e)),(()=>"Cannot find a connection between any variable and the result of the loss function y=f(x). Please make sure the operations that use variables are inside the function f passed to minimize().")),AU(0===o.rank,(()=>"The f passed in variableGrads(f) must return a scalar, but it "+"returned a rank-".concat(o.rank," tensor")));const i={};return t.forEach(((e,t)=>{null!=s[t]&&(i[e.name]=s[t])})),null!=a&&a.forEach((e=>i[e.name]=null)),{value:o,grads:i}}(e,t)}dispose(){null!=this.iterations_&&aX(this.iterations_)}async saveIterations(){return null==this.iterations_&&(this.iterations_=0),{name:"iter",tensor:vY(this.iterations_,"int32")}}async getWeights(){throw new Error("getWeights() is not implemented for this optimizer yet.")}async setWeights(e){throw new Error("setWeights() is not implemented for this optimizer class "+"".concat(this.getClassName()))}async extractIterations(e){return this.iterations_=(await e[0].tensor.data())[0],e.slice(1)}}Object.defineProperty(CY,Symbol.hasInstance,{value:e=>null!=e.minimize&&null!=e.computeGradients&&null!=e.applyGradients});function TY(e,t,n){aG(e);const a={shape:e,value:t,dtype:n=n||XU(t)};return Pq.runKernel(wH,{},a)}const EY=Yq({pow_:function(e,t){let n=Kq(e,"base","pow"),a=Kq(t,"exp","pow");[n,a]=_q(n,a);const r={a:n,b:a};return Pq.runKernel(gj,r)}});const RY=Yq({sub_:function(e,t){let n=Kq(e,"a","sub"),a=Kq(t,"b","sub");[n,a]=_q(n,a);const r={a:n,b:a};return Pq.runKernel(lK,r)}});const _Y=Yq({abs_:function(e){const t=Kq(e,"x","abs");if("complex64"===t.dtype){const e={x:t};return Pq.runKernel(UG,e)}{const e={x:t};return Pq.runKernel(mG,e)}}});function AY(e,t){const n=e.length,a=[];for(let r=0;r<n;r++){const o=n-1-r,s=e[o]||1;(t[t.length-1-r]||1)>1&&1===s&&a.unshift(o)}return a}function FY(e,t){const n=[];for(let a=0;a<t.length;a++){const r=e[e.length-a-1],o=t.length-a-1,s=t[o];(null==r||1===r&&s>1)&&n.unshift(o)}return n}function OY(e,t){const n=Math.max(e.length,t.length),a=new Array(n);for(let r=0;r<n;r++){let o=e[e.length-r-1];null==o&&(o=1);let s=t[t.length-r-1];if(null==s&&(s=1),1===o)a[n-r-1]=s;else if(1===s)a[n-r-1]=o;else{if(o!==s){const n="Operands could not be broadcast together with shapes "+"".concat(e," and ").concat(t,".");throw Error(n)}a[n-r-1]=o}}return a}const DY=Yq({maximum_:function(e,t){let n=Kq(e,"a","maximum"),a=Kq(t,"b","maximum");[n,a]=_q(n,a),"bool"===n.dtype&&(n=lY(n,"int32"),a=lY(a,"int32")),OY(n.shape,a.shape);const r={a:n,b:a};return Pq.runKernel(XH,r)}});class MY extends CY{static get className(){return"SGD"}constructor(e){super(),this.learningRate=e,this.setLearningRate(e)}applyGradients(e){const t=Array.isArray(e)?e.map((e=>e.name)):Object.keys(e);t.forEach(((t,n)=>{const a=Array.isArray(e)?e[n].tensor:e[t];if(null==a)return;const r=Pq.registeredVariables[t];nX((()=>{const e=hY(mY(this.c,a),r);r.assign(e)}))})),this.incrementIterations()}setLearningRate(e){this.learningRate=e,null!=this.c&&this.c.dispose(),this.c=rX(vY(-e))}dispose(){this.c.dispose()}async getWeights(){return[await this.saveIterations()]}async setWeights(e){if(0!==(e=await this.extractIterations(e)).length)throw new Error("SGD optimizer does not have settable weights.")}getConfig(){return{learningRate:this.learningRate}}static fromConfig(e,t){return new e(t.learningRate)}}const LY=[class extends CY{static get className(){return"Adadelta"}constructor(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null;super(),this.learningRate=e,this.rho=t,this.epsilon=n,this.accumulatedGrads=[],this.accumulatedUpdates=[],null==n&&(this.epsilon=Pq.backend.epsilon())}applyGradients(e){(Array.isArray(e)?e.map((e=>e.name)):Object.keys(e)).forEach(((t,n)=>{const a=Pq.registeredVariables[t],r=!1;null==this.accumulatedGrads[n]&&(this.accumulatedGrads[n]={originalName:"".concat(t,"/accum_grad"),variable:nX((()=>yY(a).variable(r)))}),null==this.accumulatedUpdates[n]&&(this.accumulatedUpdates[n]={originalName:"".concat(t,"/accum_var"),variable:nX((()=>yY(a).variable(r)))});const o=Array.isArray(e)?e[n].tensor:e[t];if(null==o)return;const s=this.accumulatedGrads[n].variable,i=this.accumulatedUpdates[n].variable;nX((()=>{const e=hY(mY(s,this.rho),mY(bY(o),1-this.rho)),t=mY(fY(gY(hY(i,this.epsilon)),gY(hY(s,this.epsilon))),o),n=hY(mY(i,this.rho),mY(bY(t),1-this.rho));s.assign(e),i.assign(n);const r=hY(mY(t,-this.learningRate),a);a.assign(r)}))})),this.incrementIterations()}dispose(){null!=this.accumulatedUpdates&&(aX(this.accumulatedGrads.map((e=>e.variable))),aX(this.accumulatedUpdates.map((e=>e.variable))))}async getWeights(){const e=[...this.accumulatedGrads,...this.accumulatedUpdates];return[await this.saveIterations()].concat(e.map((e=>({name:e.originalName,tensor:e.variable}))))}async setWeights(e){const t=(e=await this.extractIterations(e)).length/2,n=!1;this.accumulatedGrads=e.slice(0,t).map((e=>({originalName:e.name,variable:e.tensor.variable(n)}))),this.accumulatedUpdates=e.slice(t,2*t).map((e=>({originalName:e.name,variable:e.tensor.variable(n)})))}getConfig(){return{learningRate:this.learningRate,rho:this.rho,epsilon:this.epsilon}}static fromConfig(e,t){return new e(t.learningRate,t.rho,t.epsilon)}},class extends CY{static get className(){return"Adagrad"}constructor(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:.1;super(),this.learningRate=e,this.initialAccumulatorValue=t,this.accumulatedGrads=[]}applyGradients(e){(Array.isArray(e)?e.map((e=>e.name)):Object.keys(e)).forEach(((t,n)=>{const a=Pq.registeredVariables[t];if(null==this.accumulatedGrads[n]){const e=!1;this.accumulatedGrads[n]={originalName:"".concat(t,"/accumulator"),variable:nX((()=>TY(a.shape,this.initialAccumulatorValue).variable(e)))}}const r=Array.isArray(e)?e[n].tensor:e[t];if(null==r)return;const o=this.accumulatedGrads[n].variable;nX((()=>{const e=hY(o,bY(r));o.assign(e);const t=hY(mY(fY(r,gY(hY(e,Pq.backend.epsilon()))),-this.learningRate),a);a.assign(t)}))})),this.incrementIterations()}dispose(){null!=this.accumulatedGrads&&aX(this.accumulatedGrads.map((e=>e.variable)))}async getWeights(){return[await this.saveIterations()].concat(this.accumulatedGrads.map((e=>({name:e.originalName,tensor:e.variable}))))}async setWeights(e){e=await this.extractIterations(e);this.accumulatedGrads=e.map((e=>({originalName:e.name,variable:e.tensor.variable(false)})))}getConfig(){return{learningRate:this.learningRate,initialAccumulatorValue:this.initialAccumulatorValue}}static fromConfig(e,t){return new e(t.learningRate,t.initialAccumulatorValue)}},class extends CY{static get className(){return"Adam"}constructor(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:null;super(),this.learningRate=e,this.beta1=t,this.beta2=n,this.epsilon=a,this.accumulatedFirstMoment=[],this.accumulatedSecondMoment=[],nX((()=>{this.accBeta1=vY(t).variable(),this.accBeta2=vY(n).variable()})),null==a&&(this.epsilon=Pq.backend.epsilon())}applyGradients(e){const t=Array.isArray(e)?e.map((e=>e.name)):Object.keys(e);nX((()=>{const n=RY(1,this.accBeta1),a=RY(1,this.accBeta2);t.forEach(((t,r)=>{const o=Pq.registeredVariables[t],s=!1;null==this.accumulatedFirstMoment[r]&&(this.accumulatedFirstMoment[r]={originalName:"".concat(t,"/m"),variable:nX((()=>yY(o).variable(s)))}),null==this.accumulatedSecondMoment[r]&&(this.accumulatedSecondMoment[r]={originalName:"".concat(t,"/v"),variable:nX((()=>yY(o).variable(s)))});const i=Array.isArray(e)?e[r].tensor:e[t];if(null==i)return;const c=this.accumulatedFirstMoment[r].variable,l=this.accumulatedSecondMoment[r].variable,u=hY(mY(c,this.beta1),mY(i,1-this.beta1)),d=hY(mY(l,this.beta2),mY(bY(i),1-this.beta2)),h=fY(u,n),p=fY(d,a);c.assign(u),l.assign(d);const f=hY(mY(fY(h,hY(gY(p),this.epsilon)),-this.learningRate),o);o.assign(f)})),this.accBeta1.assign(mY(this.accBeta1,this.beta1)),this.accBeta2.assign(mY(this.accBeta2,this.beta2))})),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.accBeta2.dispose(),null!=this.accumulatedFirstMoment&&aX(this.accumulatedFirstMoment.map((e=>e.variable))),null!=this.accumulatedSecondMoment&&aX(this.accumulatedSecondMoment.map((e=>e.variable)))}async getWeights(){const e=[...this.accumulatedFirstMoment,...this.accumulatedSecondMoment];return[await this.saveIterations()].concat(e.map((e=>({name:e.originalName,tensor:e.variable}))))}async setWeights(e){e=await this.extractIterations(e),nX((()=>{this.accBeta1.assign(EY(this.beta1,this.iterations_+1)),this.accBeta2.assign(EY(this.beta2,this.iterations_+1))}));const t=e.length/2,n=!1;this.accumulatedFirstMoment=e.slice(0,t).map((e=>({originalName:e.name,variable:e.tensor.variable(n)}))),this.accumulatedSecondMoment=e.slice(t,2*t).map((e=>({originalName:e.name,variable:e.tensor.variable(n)})))}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon}}static fromConfig(e,t){return new e(t.learningRate,t.beta1,t.beta2,t.epsilon)}},class extends CY{static get className(){return"Adamax"}constructor(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:null,r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:0;super(),this.learningRate=e,this.beta1=t,this.beta2=n,this.epsilon=a,this.decay=r,this.accumulatedFirstMoment=[],this.accumulatedWeightedInfNorm=[],nX((()=>{this.iteration=vY(0).variable(),this.accBeta1=vY(t).variable()})),null==a&&(this.epsilon=Pq.backend.epsilon())}applyGradients(e){const t=Array.isArray(e)?e.map((e=>e.name)):Object.keys(e);nX((()=>{const n=RY(1,this.accBeta1),a=fY(-this.learningRate,hY(mY(this.iteration,this.decay),1));t.forEach(((t,r)=>{const o=Pq.registeredVariables[t],s=!1;null==this.accumulatedFirstMoment[r]&&(this.accumulatedFirstMoment[r]={originalName:"".concat(t,"/m"),variable:yY(o).variable(s)}),null==this.accumulatedWeightedInfNorm[r]&&(this.accumulatedWeightedInfNorm[r]={originalName:"".concat(t,"/v"),variable:yY(o).variable(s)});const i=Array.isArray(e)?e[r].tensor:e[t];if(null==i)return;const c=this.accumulatedFirstMoment[r].variable,l=this.accumulatedWeightedInfNorm[r].variable,u=hY(mY(c,this.beta1),mY(i,1-this.beta1)),d=mY(l,this.beta2),h=_Y(i),p=DY(d,h);c.assign(u),l.assign(p);const f=hY(mY(fY(a,n),fY(u,hY(p,this.epsilon))),o);o.assign(f)})),this.iteration.assign(hY(this.iteration,1)),this.accBeta1.assign(mY(this.accBeta1,this.beta1))})),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.iteration.dispose(),null!=this.accumulatedFirstMoment&&aX(this.accumulatedFirstMoment.map((e=>e.variable))),null!=this.accumulatedWeightedInfNorm&&aX(this.accumulatedWeightedInfNorm.map((e=>e.variable)))}async getWeights(){throw new Error("getWeights() is not implemented for Adamax yet.")}async setWeights(e){throw new Error("setWeights() is not implemented for Adamax yet.")}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon,decay:this.decay}}static fromConfig(e,t){return new e(t.learningRate,t.beta1,t.beta2,t.epsilon,t.decay)}},class extends MY{static get className(){return"Momentum"}constructor(e,t){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];super(e),this.learningRate=e,this.momentum=t,this.useNesterov=n,this.accumulations=[],this.m=vY(this.momentum)}applyGradients(e){(Array.isArray(e)?e.map((e=>e.name)):Object.keys(e)).forEach(((t,n)=>{const a=Pq.registeredVariables[t];if(null==this.accumulations[n]){const e=!1;this.accumulations[n]={originalName:"".concat(t,"/momentum"),variable:nX((()=>yY(a).variable(e)))}}const r=this.accumulations[n].variable,o=Array.isArray(e)?e[n].tensor:e[t];null!=o&&nX((()=>{let e;const t=hY(mY(this.m,r),o);e=this.useNesterov?hY(mY(this.c,hY(o,mY(t,this.m))),a):hY(mY(this.c,t),a),r.assign(t),a.assign(e)}))})),this.incrementIterations()}dispose(){this.m.dispose(),null!=this.accumulations&&aX(this.accumulations.map((e=>e.variable)))}setMomentum(e){this.momentum=e}async getWeights(){return[await this.saveIterations()].concat(this.accumulations.map((e=>({name:e.originalName,tensor:e.variable}))))}async setWeights(e){e=await this.extractIterations(e);this.accumulations=e.map((e=>({originalName:e.name,variable:e.tensor.variable(false)})))}getConfig(){return{learningRate:this.learningRate,momentum:this.momentum,useNesterov:this.useNesterov}}static fromConfig(e,t){return new e(t.learningRate,t.momentum,t.useNesterov)}},class extends CY{static get className(){return"RMSProp"}constructor(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:.9,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:null,r=arguments.length>4&&void 0!==arguments[4]&&arguments[4];if(super(),this.learningRate=e,this.decay=t,this.momentum=n,this.epsilon=a,this.accumulatedMeanSquares=[],this.accumulatedMoments=[],this.accumulatedMeanGrads=[],this.centered=r,null==a&&(this.epsilon=Pq.backend.epsilon()),null==e)throw new Error("learningRate for RMSPropOptimizer must be defined.")}applyGradients(e){(Array.isArray(e)?e.map((e=>e.name)):Object.keys(e)).forEach(((t,n)=>{const a=Pq.registeredVariables[t],r=!1;null==this.accumulatedMeanSquares[n]&&(this.accumulatedMeanSquares[n]={originalName:"".concat(t,"/rms"),variable:nX((()=>yY(a).variable(r)))}),null==this.accumulatedMoments[n]&&(this.accumulatedMoments[n]={originalName:"".concat(t,"/momentum"),variable:nX((()=>yY(a).variable(r)))}),null==this.accumulatedMeanGrads[n]&&this.centered&&(this.accumulatedMeanGrads[n]={originalName:"".concat(t,"/mg"),variable:nX((()=>yY(a).variable(r)))});const o=Array.isArray(e)?e[n].tensor:e[t];if(null==o)return;const s=this.accumulatedMeanSquares[n].variable,i=this.accumulatedMoments[n].variable;nX((()=>{const e=hY(mY(s,this.decay),mY(bY(o),1-this.decay));if(this.centered){const t=this.accumulatedMeanGrads[n].variable,r=hY(mY(t,this.decay),mY(o,1-this.decay)),c=fY(mY(o,this.learningRate),gY(RY(e,hY(bY(r),this.epsilon)))),l=hY(mY(i,this.momentum),c);s.assign(e),t.assign(r),i.assign(l);const u=RY(a,l);a.assign(u)}else{const e=hY(mY(s,this.decay),mY(bY(o),1-this.decay)),t=hY(mY(i,this.momentum),fY(mY(o,this.learningRate),gY(hY(e,this.epsilon))));s.assign(e),i.assign(t);const n=RY(a,t);a.assign(n)}}))})),this.incrementIterations()}dispose(){null!=this.accumulatedMeanSquares&&aX(this.accumulatedMeanSquares.map((e=>e.variable))),null!=this.accumulatedMeanGrads&&this.centered&&aX(this.accumulatedMeanGrads.map((e=>e.variable))),null!=this.accumulatedMoments&&aX(this.accumulatedMoments.map((e=>e.variable)))}async getWeights(){const e=[...this.accumulatedMeanSquares,...this.accumulatedMoments];return this.centered&&e.push(...this.accumulatedMeanGrads),[await this.saveIterations()].concat(e.map((e=>({name:e.originalName,tensor:e.variable}))))}async setWeights(e){e=await this.extractIterations(e);const t=this.centered?e.length/3:e.length/2,n=!1;this.accumulatedMeanSquares=e.slice(0,t).map((e=>({originalName:e.name,variable:e.tensor.variable(n)}))),this.accumulatedMoments=e.slice(t,2*t).map((e=>({originalName:e.name,variable:e.tensor.variable(n)}))),this.centered&&(this.accumulatedMeanGrads=e.slice(2*t,3*t).map((e=>({originalName:e.name,variable:e.tensor.variable(n)}))))}getConfig(){return{learningRate:this.learningRate,decay:this.decay,momentum:this.momentum,epsilon:this.epsilon,centered:this.centered}}static fromConfig(e,t){return new e(t.learningRate,t.decay,t.momentum,t.epsilon,t.centered)}},MY];function PY(e){return new Promise((e=>setTimeout(e))).then(e)}class zY{constructor(e){if(!uG().getBool("IS_BROWSER"))throw new Error("browserDownloads() cannot proceed because the current environment is not a browser.");e.startsWith(zY.URL_SCHEME)&&(e=e.slice(zY.URL_SCHEME.length)),null!=e&&0!==e.length||(e="model"),this.modelJsonFileName=e+".json",this.weightDataFileName=e+".weights.bin"}async save(e){if("undefined"===typeof document)throw new Error("Browser downloads are not supported in this environment since `document` is not present");const t=eX.join(e.weightData),n=window.URL.createObjectURL(new Blob([t],{type:"application/octet-stream"}));if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserDownloads.save() does not support saving model topology in binary formats yet.");{const t=xX(e,[{paths:["./"+this.weightDataFileName],weights:e.weightSpecs}]),a=window.URL.createObjectURL(new Blob([JSON.stringify(t)],{type:"application/json"})),r=null==this.modelJsonAnchor?document.createElement("a"):this.modelJsonAnchor;if(r.download=this.modelJsonFileName,r.href=a,await PY((()=>r.dispatchEvent(new MouseEvent("click")))),null!=e.weightData){const e=null==this.weightDataAnchor?document.createElement("a"):this.weightDataAnchor;e.download=this.weightDataFileName,e.href=n,await PY((()=>e.dispatchEvent(new MouseEvent("click"))))}return{modelArtifactsInfo:kX(e)}}}}zY.URL_SCHEME="downloads://";class BY{constructor(e){if(null==e||e.length<1)throw new Error("When calling browserFiles, at least 1 file is required, "+"but received ".concat(e));this.jsonFile=e[0],this.weightsFiles=e.slice(1)}async load(){return new Promise(((e,t)=>{const n=new FileReader;n.onload=n=>{const a=JSON.parse(n.target.result),r=a.modelTopology;if(null==r)return void t(new Error("modelTopology field is missing from file ".concat(this.jsonFile.name)));if(null==a.weightsManifest)return void t(new Error("weightManifest field is missing from file ".concat(this.jsonFile.name)));if(0===this.weightsFiles.length)return void e({modelTopology:r});const o=wX(a,(e=>this.loadWeights(e)));e(o)},n.onerror=e=>t("Failed to read model topology and weights manifest JSON "+"from file '".concat(this.jsonFile.name,"'. BrowserFiles supports loading ")+"Keras-style tf.Model artifacts only."),n.readAsText(this.jsonFile)}))}loadWeights(e){const t=[],n=[];for(const o of e)t.push(...o.weights),n.push(...o.paths);const a=this.checkManifestAndWeightFiles(e),r=n.map((e=>this.loadWeightsFile(e,a[e])));return Promise.all(r).then((e=>[t,e]))}loadWeightsFile(e,t){return new Promise(((n,a)=>{const r=new FileReader;r.onload=e=>{const t=e.target.result;n(t)},r.onerror=t=>a("Failed to weights data from file of path '".concat(e,"'.")),r.readAsArrayBuffer(t)}))}checkManifestAndWeightFiles(e){const t=[],n=this.weightsFiles.map((e=>yX(e.name))),a={};for(const r of e)r.paths.forEach((e=>{const r=yX(e);if(-1!==t.indexOf(r))throw new Error("Duplicate file basename found in weights manifest: "+"'".concat(r,"'"));if(t.push(r),-1===n.indexOf(r))throw new Error("Weight file with basename '".concat(r,"' is not provided."));a[e]=this.weightsFiles[n.indexOf(r)]}));if(t.length!==this.weightsFiles.length)throw new Error("Mismatch in the number of files in weights manifest "+"(".concat(t.length,") and the number of weight files provided ")+"(".concat(this.weightsFiles.length,")."));return a}}function WY(e){return new BY(e)}function VY(e,t,n,a){!function(e){AU(null!=e&&Array.isArray(e)&&e.length>0,(()=>"promises must be a none empty array"))}(e),function(e,t){AU(e>=0&&e<=1,(()=>"Progress fraction must be in range [0, 1], but "+"got startFraction ".concat(e))),AU(t>=0&&t<=1,(()=>"Progress fraction must be in range [0, 1], but "+"got endFraction ".concat(t))),AU(t>=e,(()=>"startFraction must be no more than endFraction, but "+"got startFraction ".concat(e," and endFraction ")+"".concat(t)))}(n=null==n?0:n,a=null==a?1:a);let r=0;return Promise.all(e.map((o=>(o.then((o=>{const s=n+ ++r/e.length*(a-n);return t(s),o})),o))))}async function UY(e,t){null==t&&(t={});const n=null==t.fetchFunc?uG().platform.fetch:t.fetchFunc,a=e.map((e=>n(e,t.requestInit,{isBinary:!0}))),r=(null==t.onProgress?await Promise.all(a):await VY(a,t.onProgress,0,.5)).map((e=>e.arrayBuffer()));return null==t.onProgress?await Promise.all(r):await VY(r,t.onProgress,.5,1)}async function GY(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"",n=arguments.length>2?arguments[2]:void 0,a=arguments.length>3?arguments[3]:void 0;return HY((e=>UY(e,{requestInit:a})))(e,t,n)}function HY(e){return async function(t){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"",a=arguments.length>2?arguments[2]:void 0;const r=t.map((()=>!1)),o={},s=null!=a?a.map((()=>!1)):[],i=[];if(t.forEach(((e,t)=>{let n=0;e.weights.forEach((e=>{const c="quantization"in e?e.quantization.dtype:e.dtype,l=$q[c]*DU(e.shape),u=()=>{r[t]=!0,null==o[t]&&(o[t]=[]),o[t].push({manifestEntry:e,groupOffset:n,sizeBytes:l})};null!=a?a.forEach(((t,n)=>{t===e.name&&(u(),s[n]=!0)})):u(),i.push(e.name),n+=l}))})),!s.every((e=>e))){const e=a.filter(((e,t)=>!s[t]));throw new Error("Could not find weights in manifest with names: "+"".concat(e.join(", "),". \n")+"Manifest JSON has weights with names: "+"".concat(i.join(", "),"."))}const c=r.reduce(((e,t,n)=>(t&&e.push(n),e)),[]),l=[];c.forEach((e=>{t[e].paths.forEach((e=>{const t=n+(n.endsWith("/")?"":"/")+e;l.push(t)}))}));const u=await e(l),d={};let h=0;return c.forEach((e=>{const n=t[e].paths.length,a=new eX(u.slice(h,h+n));o[e].forEach((e=>{const t=cX(a.slice(e.groupOffset,e.groupOffset+e.sizeBytes),[e.manifestEntry]);for(const n in t)d[n]=t[n]})),h+=n})),d}}SX.registerSaveRouter((e=>uG().getBool("IS_BROWSER")&&!Array.isArray(e)&&e.startsWith(zY.URL_SCHEME)?function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:"model";return new zY(e)}(e.slice(zY.URL_SCHEME.length)):null));class jY{constructor(e,t){if(this.DEFAULT_METHOD="POST",null==t&&(t={}),this.weightPathPrefix=t.weightPathPrefix,this.weightUrlConverter=t.weightUrlConverter,null!=t.fetchFunc?(AU("function"===typeof t.fetchFunc,(()=>"Must pass a function that matches the signature of `fetch` (see https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)")),this.fetch=t.fetchFunc):this.fetch=uG().platform.fetch,AU(null!=e&&e.length>0,(()=>"URL path for http must not be null, undefined or empty.")),Array.isArray(e)&&AU(2===e.length,(()=>"URL paths for http must have a length of 2, "+"(actual length is ".concat(e.length,")."))),this.path=e,null!=t.requestInit&&null!=t.requestInit.body)throw new Error("requestInit is expected to have no pre-existing body, but has one.");this.requestInit=t.requestInit||{},this.loadOptions=t}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserHTTPRequest.save() does not support saving model topology in binary formats yet.");const t=Object.assign({method:this.DEFAULT_METHOD},this.requestInit);t.body=new FormData;const n=xX(e,[{paths:["./model.weights.bin"],weights:e.weightSpecs}]);if(t.body.append("model.json",new Blob([JSON.stringify(n)],{type:"application/json"}),"model.json"),null!=e.weightData){const n=eX.join(e.weightData);t.body.append("model.weights.bin",new Blob([n],{type:"application/octet-stream"}),"model.weights.bin")}const a=await this.fetch(this.path,t);if(a.ok)return{modelArtifactsInfo:kX(e),responses:[a]};throw new Error("BrowserHTTPRequest.save() failed due to HTTP response status "+"".concat(a.status,"."))}async loadModelJSON(){const e=await this.fetch(this.path,this.requestInit);if(!e.ok)throw new Error("Request to ".concat(this.path," failed with status code ")+"".concat(e.status,". Please verify this URL points to ")+"the model JSON of the model to load.");let t;try{t=await e.json()}catch(D){let t="Failed to parse model JSON of response from ".concat(this.path,".");throw this.path.endsWith(".pb")?t+=" Your path contains a .pb file extension. Support for .pb models have been removed in TensorFlow.js 1.0 in favor of .json models. You can re-convert your Python TensorFlow model using the TensorFlow.js 1.0 conversion scripts or you can convert your.pb models with the 'pb2json'NPM script in the tensorflow/tfjs-converter repository.":t+=" Please make sure the server is serving valid JSON for this request.",new Error(t)}const n=t.modelTopology,a=t.weightsManifest;if(null==n&&null==a)throw new Error("The JSON from HTTP path ".concat(this.path," contains neither model ")+"topology or manifest for weights.");return t}async load(){if(this.loadOptions.streamWeights)return this.loadStream();return wX(await this.loadModelJSON(),(e=>this.loadWeights(e)))}async loadStream(){const e=await this.loadModelJSON(),t=await this.getWeightUrls(e.weightsManifest),n=IX(e.weightsManifest);return Object.assign(Object.assign({},e),{weightSpecs:n,getWeightStream:()=>function(e,t){var n;const a=null==t.fetchFunc?uG().platform.fetch:t.fetchFunc;let r,o=0;return null===(n=t.onProgress)||void 0===n||n.call(t,0),new ReadableStream({pull:async n=>{for(var s;o<e.length;){if(!r){const n=(await a(e[o],t.requestInit,{isBinary:!0})).body;r=n.getReader()}const{done:i,value:c}=await r.read();if(!i)return void n.enqueue(c);o++,r=void 0,null===(s=t.onProgress)||void 0===s||s.call(t,o/e.length)}n.close()}})}(t,this.loadOptions)})}async getWeightUrls(e){const t=Array.isArray(this.path)?this.path[1]:this.path,[n,a]=function(e){const t=e.lastIndexOf("/"),n=e.lastIndexOf("?"),a=e.substring(0,t),r=n>t?e.substring(n):"";return[a+"/",r]}(t),r=this.weightPathPrefix||n,o=[],s=[];for(const i of e)for(const e of i.paths)null!=this.weightUrlConverter?s.push(this.weightUrlConverter(e)):o.push(r+e+a);return this.weightUrlConverter&&o.push(...await Promise.all(s)),o}async loadWeights(e){const t=await this.getWeightUrls(e);return[IX(e),await UY(t,this.loadOptions)]}}function KY(e){return null!=e.match(jY.URL_SCHEME_REGEX)}jY.URL_SCHEME_REGEX=/^https?:\/\//;const qY=(e,t)=>{if("undefined"===typeof fetch&&(null==t||null==t.fetchFunc))return null;{let n=!0;if(n=Array.isArray(e)?e.every((e=>KY(e))):KY(e),n)return XY(e,t)}return null};function XY(e,t){return new jY(e,t)}function YY(e,t){return XY(e,t)}SX.registerSaveRouter(qY),SX.registerLoadRouter(qY);class QY{constructor(e){this.modelArtifacts=e}load(){return this.modelArtifacts}}class JY{constructor(e){this.saveHandler=e}save(e){return this.saveHandler(e)}}class ZY{constructor(e){e.load&&(this.load=()=>Promise.resolve(e.load())),e.save&&(this.save=t=>Promise.resolve(e.save(t)))}}function $Y(e,t,n,a){return new ZY(eQ(...arguments))}function eQ(e,t,n,a){if(1===arguments.length){return null!=e.modelTopology||null!=e.weightSpecs?new QY(e):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new QY({modelTopology:e}))}return console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new QY({modelTopology:e,weightSpecs:t,weightData:n,trainingConfig:a})}function tQ(e){return new JY(e)}function nQ(e){return new JY(e)}function aQ(e,t,n){if(OU(e),null!=t&&3!==t.length)throw new Error("tensor3d() requires shape to have three numbers");const a=Gq(e,n);if(3!==a.length&&1!==a.length)throw new Error("tensor3d() requires values to be number[][][] or flat/TypedArray");if(1===a.length&&null==t)throw new Error("tensor3d() requires shape to be provided when `values` are a flat array");return Jq(e,t,a,n)}let rQ;function oQ(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:3;if(t>4)throw new Error("Cannot construct Tensor with more than 4 channels from pixels.");if(null==e)throw new Error("pixels passed to tf.browser.fromPixels() can not be null");let n=!1,a=!1,r=!1,o=!1,s=!1,i=!1;if(e.data instanceof Uint8Array)n=!0;else if("undefined"!==typeof ImageData&&e instanceof ImageData)a=!0;else if("undefined"!==typeof HTMLVideoElement&&e instanceof HTMLVideoElement)r=!0;else if("undefined"!==typeof HTMLImageElement&&e instanceof HTMLImageElement)o=!0;else if(null!=e.getContext)s=!0;else{if(!("undefined"!==typeof ImageBitmap&&e instanceof ImageBitmap))throw new Error("pixels passed to tf.browser.fromPixels() must be either an HTMLVideoElement, HTMLImageElement, HTMLCanvasElement, ImageData in browser, or OffscreenCanvas, ImageData in webworker or {data: Uint32Array, width: number, height: number}, "+"but was ".concat(e.constructor.name));i=!0}if(null!=_K(wK,Pq.backendName)){const n={pixels:e},a={numChannels:t};return Pq.runKernel(wK,n,a)}const[c,l]=r?[e.videoWidth,e.videoHeight]:[e.width,e.height];let u,d;if(s)u=e.getContext("2d").getImageData(0,0,c,l).data;else if(a||n)u=e.data;else if(o||r||i){if(null==rQ)if("undefined"===typeof document){if("undefined"===typeof OffscreenCanvas||"undefined"===typeof OffscreenCanvasRenderingContext2D)throw new Error("Cannot parse input in current context. Reason: OffscreenCanvas Context2D rendering is not supported.");rQ=new OffscreenCanvas(1,1).getContext("2d")}else rQ=document.createElement("canvas").getContext("2d",{willReadFrequently:!0});rQ.canvas.width=c,rQ.canvas.height=l,rQ.drawImage(e,0,0,c,l),u=rQ.getImageData(0,0,c,l).data}if(4===t)d=new Int32Array(u);else{const e=c*l;d=new Int32Array(e*t);for(let n=0;n<e;n++)for(let e=0;e<t;++e)d[n*t+e]=u[4*n+e]}return aQ(d,[l,c,t],"int32")}const sQ=Yq({fromPixels_:oQ}),iQ=-2,cQ=-1;function lQ(e,t,n){const a=e.shape.length;AU(a===t.length,(()=>"Error in slice".concat(a,"D: Length of begin ").concat(t," must ")+"match the rank of the array (".concat(a,")."))),AU(a===n.length,(()=>"Error in slice".concat(a,"D: Length of size ").concat(n," must ")+"match the rank of the array (".concat(a,").")));for(let r=0;r<a;++r)AU(t[r]+n[r]<=e.shape[r],(()=>"Error in slice".concat(a,"D: begin[").concat(r,"] + size[").concat(r,"] ")+"(".concat(t[r]+n[r],") would overflow input.shape[").concat(r,"] (").concat(e.shape[r],")")))}function uQ(e){const t=[];let n=0;for(;e>0;)1&e&&t.push(n),e/=2,n++;return t}function dQ(e,t,n){const a=[];for(let r=0;r<e.length;r++)a[r]=Math.ceil((t[r]-e[r])/n[r]);return a}function hQ(e,t,n,a){const r=[...e];for(let o=r.length;o<a.length;o++)r.push(1);for(let o=0;o<n;o++)0===o?r[t]=1:(r.splice(t,0,1),r.pop());return r}function pQ(e,t,n){return n<=e?n:n-(t-1)}function fQ(e,t){const n=[];for(let a=0;a<e;a++)n.push(t+a);return n}function mQ(e,t,n,a,r,o,s,i,c){const l=e.length;let u=new Array(l),d=new Array(l),h=new Array(l);if(t.length&&n>0){const c=t[0],l=n+1;u=gQ(s,c,l,a,e),d=bQ(i,c,l,r,e),h=hQ(o,c,l,e)}else for(let p=0;p<l;p++)u[p]=xQ(s,a,o,e,p,c),d[p]=vQ(i,r,o,e,p,c),h[p]=yQ(o,p,c);return{begin:u,end:d,strides:h}}function gQ(e,t,n,a,r){const o=[...r],s=fQ(n,t);for(let i=0;i<o.length;i++)if(s.indexOf(i)>-1)o[i]=0;else{const r=pQ(t,n,i);let s=a[r];e&1<<r&&(s=0),o[i]=s}return o}function bQ(e,t,n,a,r){const o=[...r],s=fQ(n,t);for(let i=0;i<o.length;i++)if(s.indexOf(i)>-1)o[i]=Number.MAX_SAFE_INTEGER;else{const r=pQ(t,n,i);let s=a[r];e&1<<r&&(s=Number.MAX_SAFE_INTEGER),o[i]=s}for(let i=0;i<o.length;i++){const e=r[i];o[i]<0&&(o[i]+=e),o[i]=EU(0,o[i],r[i])}return o}function yQ(e,t,n){let a=e[t];return(n&1<<t||null==a)&&(a=1),a}function xQ(e,t,n,a,r,o){let s=t[r];const i=n[r]||1;(e&1<<r||o&1<<r||null==s)&&(s=i>0?Number.MIN_SAFE_INTEGER:Number.MAX_SAFE_INTEGER);const c=a[r];return s<0&&(s+=c),s=EU(0,s,c-1),s}function vQ(e,t,n,a,r,o){let s=t[r];const i=n[r]||1;(e&1<<r||o&1<<r||null==s)&&(s=i>0?Number.MAX_SAFE_INTEGER:Number.MIN_SAFE_INTEGER);const c=a[r];return s<0&&(s+=c),s=i>0?EU(0,s,c):EU(-1,s,c-1),s}function wQ(e,t,n){let a=n.length;for(let r=0;r<n.length;r++)if(n[r]>1){a=r;break}for(let r=a+1;r<n.length;r++)if(t[r]>0||n[r]!==e[r])return!1;return!0}function kQ(e,t){let n=e.length>0?e[e.length-1]:1;for(let a=0;a<e.length-1;a++)n+=e[a]*t[a];return n}function IQ(e,t,n){let a;const r=e.shape.length;let o;return a="number"===typeof t?[t,...new Array(r-1).fill(0)]:t.length<r?t.concat(new Array(r-t.length).fill(0)):t.slice(),a.forEach((e=>{AU(-1!==e,(()=>"slice() does not support negative begin indexing."))})),o=null==n?new Array(r).fill(-1):"number"===typeof n?[n,...new Array(r-1).fill(-1)]:n.length<r?n.concat(new Array(r-n.length).fill(-1)):n,o=o.map(((t,n)=>t>=0?t:(AU(-1===t,(()=>"Negative size values should be exactly -1 but got "+"".concat(t," for the slice() size at index ").concat(n,"."))),e.shape[n]-a[n]))),[a,o]}function SQ(e,t,n,a,r,o,s,i,c){let l;if(null==a?(l=new Array(t.length),l.fill(1)):l=a,null!=s&&0!==(s&s-1))throw new Error("Multiple ellipses in slice is not allowed.");let u=!1;const d={dims:l.length,numAddAxisAfterEllipsis:0,begin:t.slice(),end:n.slice(),strides:l.slice(),beginMask:r,endMask:o,ellipsisMask:s,newAxisMask:i,shrinkAxisMask:c};for(let x=0;x<d.dims;x++)u&&0!==(1<<x&i)&&d.numAddAxisAfterEllipsis++,1<<x&s&&(u=!0);u||(d.ellipsisMask|=1<<d.dims,d.dims++);const h={dims:e.length,beginMask:0,endMask:0,beginValid:!1,endValid:!1};!function(e,t){t.beginMask=0,t.endMask=0,t.shrinkAxisMask=0;let n=0;t.beginValid=null!=e.begin,t.endValid=null!=e.end,t.begin=new Array(t.dims),t.end=new Array(t.dims),t.strides=new Array(t.dims),t.finalShapeGatherIndices=[],t.finalShapeGatherIndicesSparse=[],t.inputShapeGatherIndicesSparse=new Array(t.dims);for(let a=0;a<e.dims;a++)if(1<<a&e.ellipsisMask){const r=Math.min(t.dims-(e.dims-a)+1+e.numAddAxisAfterEllipsis,t.dims);for(;n<r;n++)t.begin[n]=0,t.end[n]=0,t.strides[n]=1,t.beginMask|=1<<n,t.endMask|=1<<n,t.finalShapeGatherIndices.push(n),t.finalShapeGatherIndicesSparse.push(-1),t.inputShapeGatherIndicesSparse[n]=a}else if(1<<a&e.newAxisMask)t.finalShapeGatherIndices.push(iQ),t.finalShapeGatherIndicesSparse.push(-1);else{if(n===t.begin.length)throw Error("Index out of range using input dim ".concat(n,"; input ")+"has only ".concat(t.dims," dims, ").concat(t.begin.length,"."));null!=e.begin&&(t.begin[n]=e.begin[a]),null!=e.end&&(t.end[n]=e.end[a]),t.strides[n]=e.strides[a],e.beginMask&1<<a&&(t.beginMask|=1<<n),e.endMask&1<<a&&(t.endMask|=1<<n),e.shrinkAxisMask&1<<a?(t.finalShapeGatherIndices.push(cQ),t.finalShapeGatherIndicesSparse.push(-1),t.shrinkAxisMask|=1<<n):(t.finalShapeGatherIndices.push(n),t.finalShapeGatherIndicesSparse.push(a)),t.inputShapeGatherIndicesSparse[n]=a,n++}}(d,h);let p=!0,f=!0,m=!0;const g=[],b=[];for(let x=0;x<e.length;++x){if(0===h.strides[x])throw Error("strides[".concat(x,"] must be non-zero"));const t=!!(h.shrinkAxisMask&1<<x),n=e[x];if(-1===n){g.push(t?1:-1);continue}const a=[h.beginMask&1<<x,h.endMask&1<<x],r=[h.strides[x]>0?0:-1,h.strides[x]>0?n:n-1];if(t&&h.strides[x]<=0)throw Error("only stride 1 allowed on non-range indexing.");m=m&&1===h.strides[x];const o=!!(h.beginMask&1<<x&&h.endMask&1<<x);if(h.beginValid&&h.endValid){if(t){const e=h.begin[x]<0?n+h.begin[x]:h.begin[x];if(h.begin[x]=e,h.end[x]=h.begin[x]+1,e<0||e>=n)throw Error("slice index ".concat(h.begin[x]," of dimension ").concat(x," out of bounds."))}else h.begin[x]=NQ(h.begin[x],0,h.strides[x],n,a,r),h.end[x]=NQ(h.end[x],1,h.strides[x],n,a,r);const e=1===h.strides[x]&&0===h.begin[x]&&h.end[x]===n;p=p&&e,f=f&&(0===x&&1===h.strides[x]||e)}else p=p&&1===h.strides[x]&&o,f=f&&(0===x&&1===h.strides[x]||o);let s,i=!1;if(h.beginValid&&h.endValid?(s=h.end[x]-h.begin[x],i=!0):t?(s=1,i=!0):o&&n>=0&&(s=h.strides[x]<0?-n:n,i=!0),i){let e;e=0===s||s<0!==h.strides[x]<0?0:Math.trunc(s/h.strides[x])+(s%h.strides[x]!==0?1:0),g.push(e)}else g.push(-1)}for(let x=0;x<h.finalShapeGatherIndices.length;++x){const e=h.finalShapeGatherIndices[x];e>=0?b.push(g[e]):e===iQ&&b.push(1)}const y=b.filter(((e,t)=>h.finalShapeGatherIndices[t]!==iQ));return{finalShapeSparse:y,finalShape:b,isIdentity:p,sliceDim0:f,isSimpleSlice:m,begin:h.begin,end:h.end,strides:h.strides}}function NQ(e,t,n,a,r,o){if(r[t])return n>0?o[t]:o[t+1&1];{const t=e<0?a+e:e;return t<o[0]?o[0]:t>o[1]?o[1]:t}}const CQ=Yq({acos_:function(e){const t={x:Kq(e,"x","acos")};return Pq.runKernel(gG,t)}});const TQ=Yq({acosh_:function(e){const t={x:Kq(e,"x","acosh")};return Pq.runKernel(bG,t)}});const EQ=Yq({addN_:function(e){AU(Array.isArray(e),(()=>"The argument passed to tf.addN() must be a list of tensors")),AU(e.length>=1,(()=>"Must pass at least one tensor to tf.addN(), but got "+"".concat(e.length)));const t=e.map(((e,t)=>Kq(e,"tensors".concat(t),"addN"))),n=t[0];t.forEach((e=>{if(e.dtype!==n.dtype)throw new Error("All tensors passed to tf.addN() must have the same dtype")})),t.forEach((e=>{if(!MU(e.shape,n.shape))throw new Error("All tensors passed to tf.addN() must have the same shape")}));const a=t;return Pq.runKernel(xG,a)}});const RQ=Yq({all_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const a={x:Kq(e,"x","all","bool")},r={axis:t,keepDims:n};return Pq.runKernel(vG,a,r)}});const _Q=Yq({any_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const a={x:Kq(e,"x","any","bool")},r={axis:t,keepDims:n};return Pq.runKernel(wG,a,r)}});const AQ=Yq({argMax_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const n={x:Kq(e,"x","argMax")},a={axis:t};return Pq.runKernel(kG,n,a)}});const FQ=Yq({argMin_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const n={x:Kq(e,"x","argMin")},a={axis:t};return Pq.runKernel(IG,n,a)}});const OQ=Yq({asin_:function(e){const t={x:Kq(e,"x","asin")};return Pq.runKernel(SG,t)}});const DQ=Yq({asinh_:function(e){const t={x:Kq(e,"x","asinh")};return Pq.runKernel(NG,t)}});const MQ=Yq({atan_:function(e){const t={x:Kq(e,"x","atan")};return Pq.runKernel(CG,t)}});const LQ=Yq({atan2_:function(e,t){let n=Kq(e,"a","atan2"),a=Kq(t,"b","atan2");[n,a]=_q(n,a);const r={a:n,b:a};return Pq.runKernel(EG,r)}});const PQ=Yq({atanh_:function(e){const t={x:Kq(e,"x","atanh")};return Pq.runKernel(TG,t)}});function zQ(e,t,n,a){let r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"NHWC",o=arguments.length>5?arguments[5]:void 0;return VQ(e,[...t,e[3]],n,o,a,null,null,JQ(r))}function BQ(e,t,n,a,r,o){let s=arguments.length>6&&void 0!==arguments[6]?arguments[6]:"channelsLast";const[i,c]=HQ(t);let l;if("channelsLast"===s)l=[i,c,e[3],e[3]];else{if("channelsFirst"!==s)throw new Error("Unknown dataFormat ".concat(s));l=[i,c,e[1],e[1]]}return VQ(e,l,n,a,r,o,!1,s)}function WQ(e,t,n,a,r,o){let s=arguments.length>6&&void 0!==arguments[6]?arguments[6]:"NDHWC";const[i,c,l]=jQ(t);let u,d;if("NDHWC"===s)d="channelsLast",u=[i,c,l,e[4],e[4]];else{if("NCDHW"!==s)throw new Error("Unknown dataFormat ".concat(s));d="channelsFirst",u=[i,c,l,e[1],e[1]]}return UQ(e,u,n,a,r,!1,d,o)}function VQ(e,t,n,a,r,o){let s=arguments.length>6&&void 0!==arguments[6]&&arguments[6],i=arguments.length>7&&void 0!==arguments[7]?arguments[7]:"channelsLast",[c,l,u,d]=[-1,-1,-1,-1];if("channelsLast"===i)[c,l,u,d]=e;else{if("channelsFirst"!==i)throw new Error("Unknown dataFormat ".concat(i));[c,d,l,u]=e}const[h,p,,f]=t,[m,g]=HQ(n),[b,y]=HQ(a),x=KQ(h,b),v=KQ(p,y),{padInfo:w,outHeight:k,outWidth:I}=function(e,t,n,a,r,o,s,i,c){let l,u,d;if("number"===typeof e){l={top:e,bottom:e,left:e,right:e,type:0===e?"VALID":"NUMBER"};const r=function(e,t,n,a,r){null==a&&(a=GQ(e,t,n));const o=e[0],s=e[1],i=qQ((o-t+2*a)/n+1,r),c=qQ((s-t+2*a)/n+1,r);return[i,c]}([t,n],o,a,e,i);u=r[0],d=r[1]}else if("same"===e){u=Math.ceil(t/a),d=Math.ceil(n/r);const e=Math.max(0,(u-1)*a+o-t),i=Math.max(0,(d-1)*r+s-n),c=Math.floor(e/2),h=e-c,p=Math.floor(i/2);l={top:c,bottom:h,left:p,right:i-p,type:"SAME"}}else if("valid"===e)l={top:0,bottom:0,left:0,right:0,type:"VALID"},u=Math.ceil((t-o+1)/a),d=Math.ceil((n-s+1)/r);else{if("object"!==typeof e)throw Error("Unknown padding parameter: ".concat(e));{const h="channelsLast"===c?e[1][0]:e[2][0],p="channelsLast"===c?e[1][1]:e[2][1],f="channelsLast"===c?e[2][0]:e[3][0],m="channelsLast"===c?e[2][1]:e[3][1];l={top:h,bottom:p,left:f,right:m,type:0===h&&0===p&&0===f&&0===m?"VALID":"EXPLICIT"},u=qQ((t-o+h+p)/a+1,i),d=qQ((n-s+f+m)/r+1,i)}}return{padInfo:l,outHeight:u,outWidth:d}}(r,l,u,m,g,x,v,o,i),S=s?f*d:f;let N;return"channelsFirst"===i?N=[c,S,k,I]:"channelsLast"===i&&(N=[c,k,I,S]),{batchSize:c,dataFormat:i,inHeight:l,inWidth:u,inChannels:d,outHeight:k,outWidth:I,outChannels:S,padInfo:w,strideHeight:m,strideWidth:g,filterHeight:h,filterWidth:p,effectiveFilterHeight:x,effectiveFilterWidth:v,dilationHeight:b,dilationWidth:y,inShape:e,outShape:N,filterShape:t}}function UQ(e,t,n,a,r){let o=arguments.length>5&&void 0!==arguments[5]&&arguments[5],s=arguments.length>6&&void 0!==arguments[6]?arguments[6]:"channelsLast",i=arguments.length>7?arguments[7]:void 0,[c,l,u,d,h]=[-1,-1,-1,-1,-1];if("channelsLast"===s)[c,l,u,d,h]=e;else{if("channelsFirst"!==s)throw new Error("Unknown dataFormat ".concat(s));[c,h,l,u,d]=e}const[p,f,m,,g]=t,[b,y,x]=jQ(n),[v,w,k]=jQ(a),I=KQ(p,v),S=KQ(f,w),N=KQ(m,k),{padInfo:C,outDepth:T,outHeight:E,outWidth:R}=function(e,t,n,a,r,o,s,i,c,l,u){let d,h,p,f;"valid"===e&&(e=0);if("number"===typeof e){d={top:e,bottom:e,left:e,right:e,front:e,back:e,type:0===e?"VALID":"NUMBER"};const m=function(e,t,n,a,r,o){null==r&&(r=GQ(e,t[0],a[0]));const s=[0,0,0,n];for(let i=0;i<3;i++)e[i]+2*r>=t[i]&&(s[i]=qQ((e[i]-t[i]+2*r)/a[i]+1,o));return s}([t,n,a,1],[i,c,l],1,[r,o,s],e,u);h=m[0],p=m[1],f=m[2]}else{if("same"!==e)throw Error("Unknown padding parameter: ".concat(e));{h=Math.ceil(t/r),p=Math.ceil(n/o),f=Math.ceil(a/s);const e=(h-1)*r+i-t,u=(p-1)*o+c-n,m=(f-1)*s+l-a,g=Math.floor(e/2),b=e-g,y=Math.floor(u/2),x=u-y,v=Math.floor(m/2);d={top:y,bottom:x,left:v,right:m-v,front:g,back:b,type:"SAME"}}}return{padInfo:d,outDepth:h,outHeight:p,outWidth:f}}(r,l,u,d,b,y,x,I,S,N,i),_=o?g*h:g;let A;return"channelsFirst"===s?A=[c,_,T,E,R]:"channelsLast"===s&&(A=[c,T,E,R,_]),{batchSize:c,dataFormat:s,inDepth:l,inHeight:u,inWidth:d,inChannels:h,outDepth:T,outHeight:E,outWidth:R,outChannels:_,padInfo:C,strideDepth:b,strideHeight:y,strideWidth:x,filterDepth:p,filterHeight:f,filterWidth:m,effectiveFilterDepth:I,effectiveFilterHeight:S,effectiveFilterWidth:N,dilationDepth:v,dilationHeight:w,dilationWidth:k,inShape:e,outShape:A,filterShape:t}}function GQ(e,t,n){const a=KQ(t,arguments.length>3&&void 0!==arguments[3]?arguments[3]:1);return Math.floor((e[0]*(n-1)-n+a)/2)}function HQ(e){return"number"===typeof e?[e,e,e]:2===e.length?[e[0],e[1],1]:e}function jQ(e){return"number"===typeof e?[e,e,e]:e}function KQ(e,t){return t<=1?e:e+(e-1)*(t-1)}function qQ(e,t){if(!t)return Math.trunc(e);switch(t){case"round":return Math.round(e);case"ceil":return Math.ceil(e);case"floor":return Math.floor(e);default:throw new Error("Unknown roundingMode ".concat(t))}}function XQ(e){const[t,n,a]=HQ(e);return 1===t&&1===n&&1===a}function YQ(e,t){return XQ(e)||XQ(t)}function QQ(e){return HQ(e).every((e=>e>0))}function JQ(e){if("NHWC"===e)return"channelsLast";if("NCHW"===e)return"channelsFirst";throw new Error("Unknown dataFormat ".concat(e))}function ZQ(e,t,n){if(null!=n){if("string"===typeof t)throw Error("Error in ".concat(e,": pad must be an integer when using ")+"dimRoundingMode ".concat(n," but got pad ").concat(t,"."));if("number"===typeof t)AU(LU(t),(()=>"Error in ".concat(e,": pad must be an integer when using ")+"dimRoundingMode ".concat(n," but got pad ").concat(t,".")));else{if("object"!==typeof t)throw Error("Error in ".concat(e,": Unknown padding parameter: ").concat(t));t.forEach((t=>{t.forEach((t=>{AU(LU(t),(()=>"Error in ".concat(e,": pad must be an integer when using ")+"dimRoundingMode ".concat(n," but got pad ").concat(t,".")))}))}))}}}const $Q=Yq({reshape_:function(e,t){const n={x:Kq(e,"x","reshape","string_or_numeric")},a={shape:t};return Pq.runKernel(Cj,n,a)}});const eJ=Yq({avgPool_:function(e,t,n,a,r){const o=Kq(e,"x","avgPool","float32");AU(YQ(n,1),(()=>"Error in avgPool: Either strides or dilations must be 1. "+"Got strides ".concat(n," and dilations '").concat(1,"'")));let s=o,i=!1;3===o.rank&&(i=!0,s=$Q(o,[1,o.shape[0],o.shape[1],o.shape[2]])),AU(4===s.rank,(()=>"Error in avgPool: x must be rank 4 but got rank ".concat(s.rank,"."))),ZQ("avgPool",a,r);const c={x:s},l={filterSize:t,strides:n,pad:a,dimRoundingMode:r};let u=Pq.runKernel(RG,c,l);return u=lY(u,o.dtype),i?$Q(u,[u.shape[1],u.shape[2],u.shape[3]]):u}});const tJ=Yq({avgPool3d_:function(e,t,n,a,r){let o=arguments.length>5&&void 0!==arguments[5]?arguments[5]:"NDHWC";const s=Kq(e,"x","avgPool3d","float32");let i=s,c=!1;4===s.rank&&(c=!0,i=$Q(s,[1,s.shape[0],s.shape[1],s.shape[2],s.shape[3]])),AU(5===i.rank,(()=>"Error in avgPool3d: x must be rank 5 but got rank ".concat(i.rank,"."))),AU("NDHWC"===o,(()=>"Error in avgPool3d: Only NDHWC is currently supported, "+"but got dataFormat of ".concat(o))),AU("number"===typeof n&&n>0||Array.isArray(n)&&n[0]>0&&n[1]>0&&n[2]>0,(()=>"Error in avgPool3d: Stride must be > 0, but got '".concat(n,"'"))),ZQ("avgPool3d",a,r);const l={x:i},u={filterSize:t,strides:n,pad:a,dimRoundingMode:r,dataFormat:o};let d=Pq.runKernel(AG,l,u);return d=lY(d,i.dtype),c?$Q(d,[d.shape[1],d.shape[2],d.shape[3],d.shape[4]]):d}});const nJ=Yq({concat_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;AU(e.length>=1,(()=>"Pass at least one tensor to concat"));const n=qq(e,"tensors","concat","string_or_numeric");if("complex64"===n[0].dtype&&n.forEach((e=>{if("complex64"!==e.dtype)throw new Error("Cannot concatenate complex64 tensors with a tensor\n          with dtype ".concat(e.dtype,". "))})),1===n.length)return uY(n[0]);const a=n,r={axis:t};return Pq.runKernel(GG,a,r)}});const aJ=Yq({matMul_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],a=arguments.length>3&&void 0!==arguments[3]&&arguments[3],r=Kq(e,"a","matMul"),o=Kq(t,"b","matMul");[r,o]=_q(r,o);const s={a:r,b:o},i={transposeA:n,transposeB:a};return Pq.runKernel(OG,s,i)}});const rJ=Yq({sigmoid_:function(e){const t={x:Kq(e,"x","sigmoid","float32")};return Pq.runKernel(Hj,t)}});const oJ=Yq({slice_:function(e,t,n){const a=Kq(e,"x","slice","string_or_numeric");if(0===a.rank)throw new Error("Slicing scalar is not possible");const r={x:a},o={begin:t,size:n};return Pq.runKernel(Wj,r,o)}});const sJ=Yq({tanh_:function(e){const t={x:Kq(e,"x","tanh","float32")};return Pq.runKernel(dK,t)}});const iJ=Yq({basicLSTMCell_:function(e,t,n,a,r,o){const s=Kq(e,"forgetBias","basicLSTMCell"),i=Kq(t,"lstmKernel","basicLSTMCell"),c=Kq(n,"lstmBias","basicLSTMCell"),l=Kq(a,"data","basicLSTMCell"),u=Kq(r,"c","basicLSTMCell"),d=Kq(o,"h","basicLSTMCell"),h=nJ([l,d],1),p=aJ(h,i),f=hY(p,c),m=f.shape[0],g=f.shape[1]/4,b=[m,g],y=oJ(f,[0,0],b),x=oJ(f,[0,g],b),v=oJ(f,[0,2*g],b),w=oJ(f,[0,3*g],b),k=hY(mY(rJ(y),sJ(x)),mY(u,rJ(hY(s,v))));return[k,mY(sJ(k),rJ(w))]}});const cJ=Yq({batchToSpaceND_:function(e,t,n){const a=Kq(e,"x","batchToSpaceND"),r=t.reduce(((e,t)=>e*t));AU(a.rank>=1+t.length,(()=>"input rank is ".concat(a.rank," but should be > than blockShape.length ").concat(t.length))),AU(n.length===t.length,(()=>"crops.length is ".concat(n.length," but should be equal to blockShape.length  ").concat(t.length))),AU(a.shape[0]%r===0,(()=>"input tensor batch is ".concat(a.shape[0]," but is not divisible by the product of ")+"the elements of blockShape ".concat(t.join(" * ")," === ").concat(r)));const o={x:a},s={blockShape:t,crops:n};return Pq.runKernel(DG,o,s)}});const lJ=Yq({batchNorm_:function(e,t,n,a,r,o){null==o&&(o=.001);const s=Kq(e,"x","batchNorm"),i=Kq(t,"mean","batchNorm"),c=Kq(n,"variance","batchNorm");let l,u;null!=r&&(l=Kq(r,"scale","batchNorm")),null!=a&&(u=Kq(a,"offset","batchNorm")),AU(i.rank===c.rank,(()=>"Batch normalization gradient requires mean and variance to have equal ranks.")),AU(null==u||i.rank===u.rank,(()=>"Batch normalization gradient requires mean and offset to have equal ranks.")),AU(null==l||i.rank===l.rank,(()=>"Batch normalization gradient requires mean and scale to have equal ranks."));const d={x:function(e){let t;return t=0===e.rank||1===e.rank?$Q(e,[1,1,1,e.size]):2===e.rank?$Q(e,[1,1,e.shape[0],e.shape[1]]):3===e.rank?$Q(e,[1,e.shape[0],e.shape[1],e.shape[2]]):e,t}(s),scale:l,offset:u,mean:i,variance:c},h={varianceEpsilon:o},p=Pq.runKernel(NH,d,h);return $Q(p,s.shape)}});const uJ=Yq({batchNorm2d_:function(e,t,n,a,r,o){const s=Kq(e,"x","batchNorm"),i=Kq(t,"mean","batchNorm"),c=Kq(n,"variance","batchNorm");let l,u;return null!=r&&(l=Kq(r,"scale","batchNorm")),null!=a&&(u=Kq(a,"offset","batchNorm")),AU(2===s.rank,(()=>"Error in batchNorm2D: x must be rank 2 but got rank "+"".concat(s.rank,"."))),AU(2===i.rank||1===i.rank,(()=>"Error in batchNorm2D: mean must be rank 2 or rank 1 but "+"got rank ".concat(i.rank,"."))),AU(2===c.rank||1===c.rank,(()=>"Error in batchNorm2D: variance must be rank 2 or rank 1 "+"but got rank ".concat(c.rank,"."))),null!=l&&AU(2===l.rank||1===l.rank,(()=>"Error in batchNorm2D: scale must be rank 2 or rank 1 "+"but got rank ".concat(l.rank,"."))),null!=u&&AU(2===u.rank||1===u.rank,(()=>"Error in batchNorm2D: offset must be rank 2 or rank 1 "+"but got rank ".concat(u.rank,"."))),lJ(s,i,c,u,l,o)}});const dJ=Yq({batchNorm3d_:function(e,t,n,a,r,o){const s=Kq(e,"x","batchNorm"),i=Kq(t,"mean","batchNorm"),c=Kq(n,"variance","batchNorm");let l,u;return null!=r&&(l=Kq(r,"scale","batchNorm")),null!=a&&(u=Kq(a,"offset","batchNorm")),AU(3===s.rank,(()=>"Error in batchNorm3D: x must be rank 3 but got rank "+"".concat(s.rank,"."))),AU(3===i.rank||1===i.rank,(()=>"Error in batchNorm3D: mean must be rank 3 or rank 1 but "+"got rank ".concat(i.rank,"."))),AU(3===c.rank||1===c.rank,(()=>"Error in batchNorm3D: variance must be rank 3 or rank 1 "+"but got rank ".concat(c.rank,"."))),null!=l&&AU(3===l.rank||1===l.rank,(()=>"Error in batchNorm3D: scale must be rank 3 or rank 1 "+"but got rank ".concat(l.rank,"."))),null!=u&&AU(3===u.rank||1===u.rank,(()=>"Error in batchNorm3D: offset must be rank 3 or rank 1 "+"but got rank ".concat(u.rank,"."))),lJ(s,i,c,u,l,o)}});const hJ=Yq({batchNorm4d_:function(e,t,n,a,r,o){const s=Kq(e,"x","batchNorm"),i=Kq(t,"mean","batchNorm"),c=Kq(n,"variance","batchNorm");let l,u;return null!=r&&(l=Kq(r,"scale","batchNorm")),null!=a&&(u=Kq(a,"offset","batchNorm")),AU(4===s.rank,(()=>"Error in batchNorm4D: x must be rank 4 but got rank "+"".concat(s.rank,"."))),AU(4===i.rank||1===i.rank,(()=>"Error in batchNorm4D: mean must be rank 4 or rank 1 but "+"got rank ".concat(i.rank,"."))),AU(4===c.rank||1===c.rank,(()=>"Error in batchNorm4D: variance must be rank 4 or rank 1 "+"but got rank ".concat(c.rank,"."))),null!=l&&AU(4===l.rank||1===l.rank,(()=>"Error in batchNorm4D: scale must be rank 4 or rank 1 "+"but got rank ".concat(l.rank,"."))),null!=u&&AU(4===u.rank||1===u.rank,(()=>"Error in batchNorm4D: offset must be rank 4 or rank 1 "+"but got rank ".concat(u.rank,"."))),lJ(s,i,c,u,l,o)}});const pJ=Yq({bincount_:function(e,t,n){const a=Kq(e,"x","bincount"),r=Kq(t,"weights","bincount");AU("int32"===a.dtype,(()=>"Error in bincount: input "+"dtype must be int32, but got ".concat(a.dtype))),AU(n>=0,(()=>"size must be non-negative, but got ".concat(n,"."))),AU(r.size===a.size||0===r.size,(()=>"Error in bincount: weights must have the same size as input or"+"0-length, but got input shape: ".concat(a.shape,", weights shape: ")+"".concat(r.shape,".")));const o={x:a,weights:r},s={size:n};return Pq.runKernel(MG,o,s)}});const fJ=Yq({bitwiseAnd_:function(e,t){const n=Kq(e,"x","bitwiseAnd"),a=Kq(t,"y","bitwiseAnd");if(!MU(n.shape,a.shape))throw new Error("BitwiseAnd: Tensors must have the same shape. x: ".concat(n.shape,", y: ").concat(a.shape));if("int32"!==n.dtype||"int32"!==a.dtype)throw new Error("BitwiseAnd: Only supports 'int32' values in tensor, found type of x: ".concat(n.dtype," and type of y: ").concat(a.dtype));const r={a:n,b:a};return Pq.runKernel(LG,r)}});const mJ=Yq({broadcastArgs_:function(e,t){const n=Kq(e,"s0","broadcastArgs","int32"),a=Kq(t,"s1","broadcastArgs","int32");if(1!==n.rank)throw new Error("broadcastArgs(): first input must be a vector (rank=1). "+"Has rank ".concat(n.rank));if(1!==a.rank)throw new Error("broadcastArgs(): second input must be a vector (rank=1). "+"Has rank ".concat(a.rank));const r={s0:n,s1:a};return Pq.runKernel(PG,r)}});const gJ=Yq({broadcastTo_:function(e,t){let n=Kq(e,"broadcastTo","x");const a=n.shape;if(aG(t),t.length<n.rank)throw new Error("broadcastTo(): shape.length=".concat(t.length," < input.rank=").concat(n.rank,"."));if(t.length>n.rank){const e=n.shape.slice();for(;e.length<t.length;)e.unshift(1);n=$Q(n,e)}const r=n.shape,o=Array.from(t);for(let l=t.length-1;l>=0;l--)if(r[l]===t[l])o[l]=1;else if(1!==n.shape[l])throw new Error("broadcastTo(): [".concat(a,"] cannot be broadcast to [").concat(t,"]."));const s=o.map(((e,t)=>e>1?t:-1)).filter((e=>e>=0));if(0===s.length)return uY(n);const i={x:n},c={reps:o};return Pq.runKernel(hK,i,c)}});const bJ=Yq({ceil_:function(e){const t={x:Kq(e,"x","ceil","float32")};return Pq.runKernel(BG,t)}});const yJ=Yq({clipByValue_:function(e,t,n){const a=Kq(e,"x","clipByValue");if(AU(t<=n,(()=>"Error in clip: min (".concat(t,") must be ")+"less than or equal to max (".concat(n,")."))),t===n)return TY(a.shape,t,a.dtype);const r={x:a},o={clipValueMin:t,clipValueMax:n};return Pq.runKernel(WG,r,o)}});const xJ=Yq({concat1d_:function(e){return nJ(e,0)}});const vJ=Yq({concat2d_:function(e,t){return nJ(e,t)}});const wJ=Yq({concat3d_:function(e,t){return nJ(e,t)}});const kJ=Yq({concat4d_:function(e,t){return nJ(e,t)}});const IJ=Yq({conv2d_:function(e,t,n,a){let r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"NHWC",o=arguments.length>5&&void 0!==arguments[5]?arguments[5]:[1,1],s=arguments.length>6?arguments[6]:void 0;const i=Kq(e,"x","conv2d","float32"),c=Kq(t,"filter","conv2d","float32");let l=i,u=!1;3===i.rank&&(u=!0,l=$Q(i,[1,i.shape[0],i.shape[1],i.shape[2]])),AU(4===l.rank,(()=>"Error in conv2d: input must be rank 4, but got rank ".concat(l.rank,"."))),AU(4===c.rank,(()=>"Error in conv2d: filter must be rank 4, but got rank "+"".concat(c.rank,"."))),ZQ("conv2d",a,s);const d="NHWC"===r?l.shape[3]:l.shape[1];AU(d===c.shape[2],(()=>"Error in conv2d: depth of input (".concat(d,") must match ")+"input depth for filter ".concat(c.shape[2],"."))),AU(YQ(n,o),(()=>"Error in conv2D: Either strides or dilations must be 1. "+"Got strides ".concat(n," and dilations '").concat(o,"'"))),AU(QQ(o),(()=>"Error in conv2D: Dilated rates should be larger than 0.")),AU(QQ(n),(()=>"Error in conv2D: Strides should be larger than 0."));const h={x:l,filter:c},p={strides:n,pad:a,dataFormat:r,dilations:o,dimRoundingMode:s},f=Pq.runKernel(HG,h,p);return u?$Q(f,[f.shape[1],f.shape[2],f.shape[3]]):f}});const SJ=Yq({conv1d_:function(e,t,n,a){let r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"NWC",o=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,s=arguments.length>6?arguments[6]:void 0;const i=Kq(e,"x","conv1d"),c=Kq(t,"filter","conv1d");let l=i,u=!1;2===i.rank&&(u=!0,l=$Q(i,[1,i.shape[0],i.shape[1]])),AU(3===l.rank,(()=>"Error in conv1d: input must be rank 3, but got rank ".concat(l.rank,"."))),AU(3===c.rank,(()=>"Error in conv1d: filter must be rank 3, but got rank "+"".concat(c.rank,"."))),ZQ("conv1d",a,s),AU(l.shape[2]===c.shape[1],(()=>"Error in conv1d: depth of input (".concat(l.shape[2],") must match ")+"input depth for filter ".concat(c.shape[1],"."))),AU(YQ(n,o),(()=>"Error in conv1D: Either stride or dilation must be 1. "+"Got stride ".concat(n," and dilation '").concat(o,"'"))),AU(QQ(o),(()=>"Error in conv1D: Dilated rates should be larger than 0.")),AU(QQ(n),(()=>"Error in conv1D: Stride should be larger than 0.")),AU("NWC"===r,(()=>"Error in conv1d: got dataFormat of ".concat(r," but only NWC is currently supported.")));const d=$Q(c,[1,c.shape[0],c.shape[1],c.shape[2]]),h=$Q(l,[l.shape[0],1,l.shape[1],l.shape[2]]),p=IJ(h,d,[1,n],a,"NHWC",[1,o],s);return $Q(p,u?[p.shape[2],p.shape[3]]:[p.shape[0],p.shape[2],p.shape[3]])}});const NJ=Yq({conv2DBackpropInput_:function(e,t,n,a,r){let o=arguments.length>5&&void 0!==arguments[5]?arguments[5]:"NHWC",s=arguments.length>6?arguments[6]:void 0;AU(e.length===t.rank,(()=>"Length of inShape "+"(".concat(e.length,") and rank of dy (").concat(t.rank,") must match")));let i=e,c=t,l=!1;3===t.rank&&(l=!0,c=$Q(t,[1,t.shape[0],t.shape[1],t.shape[2]]),i=[1,e[0],e[1],e[2]]),AU(4===i.length,(()=>"Error in conv2dDerInput: inShape must be length 4, but got length "+"".concat(i.length,"."))),AU(4===c.rank,(()=>"Error in conv2dDerInput: dy must be rank 4, but got "+"rank ".concat(c.rank))),AU(4===n.rank,(()=>"Error in conv2dDerInput: filter must be rank 4, but got "+"rank ".concat(n.rank)));const u="NHWC"===o?i[3]:i[1],d="NHWC"===o?c.shape[3]:c.shape[1];AU(u===n.shape[2],(()=>"Error in conv2dDerInput: depth of input (".concat(u,") must ")+"match input depth for filter ".concat(n.shape[2],"."))),AU(d===n.shape[3],(()=>"Error in conv2dDerInput: depth of output (".concat(d,") must ")+"match output depth for filter ".concat(n.shape[3],"."))),ZQ("conv2dDerInput",r,s);const h={dy:c,filter:n},p={strides:a,pad:r,dataFormat:o,dimRoundingMode:s,inputShape:i},f=Pq.runKernel(KG,h,p);return l?$Q(f,[f.shape[1],f.shape[2],f.shape[3]]):f}});const CJ=Yq({conv2dTranspose_:function(e,t,n,a,r,o){const s=Kq(e,"x","conv2dTranspose"),i=Kq(t,"filter","conv2dTranspose");return NJ(n,s,i,a,r,"NHWC",o)}});const TJ=Yq({conv3d_:function(e,t,n,a){let r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"NDHWC",o=arguments.length>5&&void 0!==arguments[5]?arguments[5]:[1,1,1];const s=Kq(e,"x","conv3d"),i=Kq(t,"filter","conv3d");let c=s,l=!1;4===s.rank&&(l=!0,c=$Q(s,[1,s.shape[0],s.shape[1],s.shape[2],s.shape[3]])),AU(5===c.rank,(()=>"Error in conv3d: input must be rank 5, but got rank ".concat(c.rank,"."))),AU(5===i.rank,(()=>"Error in conv3d: filter must be rank 5, but got rank "+"".concat(i.rank,"."))),AU(c.shape[4]===i.shape[3],(()=>"Error in conv3d: depth of input (".concat(c.shape[4],") must match ")+"input depth for filter ".concat(i.shape[3],"."))),AU(YQ(n,o),(()=>"Error in conv3D: Either strides or dilations must be 1. "+"Got strides ".concat(n," and dilations '").concat(o,"'"))),AU("NDHWC"===r,(()=>"Error in conv3d: got dataFormat of ".concat(r," but only NDHWC is currently supported."))),AU(QQ(o),(()=>"Error in conv3D: Dilated rates should be larger than 0.")),AU(QQ(n),(()=>"Error in conv3D: Strides should be larger than 0."));const u={x:c,filter:i},d={strides:n,pad:a,dataFormat:r,dilations:o},h=Pq.runKernel(qG,u,d);return l?$Q(h,[h.shape[1],h.shape[2],h.shape[3],h.shape[4]]):h}});const EJ=Yq({conv3DBackpropInput_:function(e,t,n,a,r){AU(e.length===t.rank,(()=>"Length of inShape "+"(".concat(e.length,") and rank of dy (").concat(t.rank,") must match")));let o=e,s=t,i=!1;4===t.rank&&(i=!0,s=$Q(t,[1,t.shape[0],t.shape[1],t.shape[2],t.shape[3]]),o=[1,e[0],e[1],e[2],e[3]]);const c=o[4],l=s.shape[4];AU(5===o.length,(()=>"Error in conv3dDerInput: inShape must be length 5, but got length "+"".concat(o.length,"."))),AU(5===s.rank,(()=>"Error in conv3dDerInput: dy must be rank 5, but got "+"rank ".concat(s.rank))),AU(5===n.rank,(()=>"Error in conv3dDerInput: filter must be rank 5, but got "+"rank ".concat(n.rank))),AU(c===n.shape[3],(()=>"Error in conv3dDerInput: depth of input (".concat(c,") must ")+"match input depth for filter ".concat(n.shape[3],"."))),AU(l===n.shape[4],(()=>"Error in conv3dDerInput: depth of output (".concat(l,") must ")+"match output depth for filter ".concat(n.shape[4],".")));const u={dy:s,filter:n},d={pad:r,strides:a,inputShape:o},h=Pq.runKernel(YG,u,d);return i?$Q(h,[h.shape[1],h.shape[2],h.shape[3],h.shape[4]]):h}});const RJ=Yq({conv3dTranspose_:function(e,t,n,a,r){const o=Kq(e,"x","conv3dTranspose"),s=Kq(t,"filter","conv3dTranspose");return EJ(n,o,s,a,r)}});const _J=Yq({cos_:function(e){const t={x:Kq(e,"x","cos","float32")};return Pq.runKernel(QG,t)}});const AJ=Yq({cosh_:function(e){const t={x:Kq(e,"x","cosh","float32")};return Pq.runKernel(JG,t)}});const FJ=Yq({cumprod_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],a=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const r={x:Kq(e,"x","cumprod")},o={axis:t,exclusive:n,reverse:a};return Pq.runKernel(ZG,r,o)}});const OJ=Yq({cumsum_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],a=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const r={x:Kq(e,"x","cumsum")},o={axis:t,exclusive:n,reverse:a};return Pq.runKernel($G,r,o)}});const DJ=Yq({denseBincount_:function(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const r=Kq(e,"x","denseBincount"),o=Kq(t,"weights","denseBincount");AU("int32"===r.dtype,(()=>"Error in denseBincount: input "+"dtype must be int32, but got ".concat(r.dtype))),AU(r.rank<=2,(()=>"Error in denseBincount: input must be at most rank 2, but got "+"rank ".concat(r.rank,"."))),AU(n>=0,(()=>"size must be non-negative, but got ".concat(n,"."))),AU(o.size===r.size||0===o.size,(()=>"Error in denseBincount: weights must have the same shape as x or "+"0-length, but got x shape: ".concat(r.shape,", weights shape: ")+"".concat(o.shape,".")));const s={x:r,weights:o},i={size:n,binaryOutput:a};return Pq.runKernel(tH,s,i)}});const MJ=Yq({depthToSpace_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"NHWC";const a=Kq(e,"x","depthToSpace","float32"),r="NHWC"===n?a.shape[1]:a.shape[2],o="NHWC"===n?a.shape[2]:a.shape[3],s="NHWC"===n?a.shape[3]:a.shape[1];AU(t>1,(()=>"blockSize should be > 1 for depthToSpace, but was: ".concat(t))),AU(r*t>=0,(()=>"Negative dimension size caused by overflow when multiplying\n    ".concat(r," and ").concat(t,"  for depthToSpace with input shape\n    ").concat(a.shape))),AU(o*t>=0,(()=>"Negative dimension size caused by overflow when multiplying\n    ".concat(o," and ").concat(t," for depthToSpace with input shape\n        ").concat(a.shape))),AU(s%(t*t)===0,(()=>"Dimension size must be evenly divisible by ".concat(t*t," but is ").concat(s," for depthToSpace with input shape ").concat(a.shape)));const i={x:a},c={blockSize:t,dataFormat:n};return Pq.runKernel(nH,i,c)}});const LJ=Yq({depthwiseConv2d_:function(e,t,n,a){let r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"NHWC",o=arguments.length>5&&void 0!==arguments[5]?arguments[5]:[1,1],s=arguments.length>6?arguments[6]:void 0;const i=Kq(e,"x","depthwiseConv2d","float32"),c=Kq(t,"filter","depthwiseConv2d","float32");let l=i,u=!1;3===i.rank&&(u=!0,l=$Q(i,[1,i.shape[0],i.shape[1],i.shape[2]])),AU(4===l.rank,(()=>"Error in depthwiseConv2d: input must be rank 4, but got "+"rank ".concat(l.rank,"."))),AU(4===c.rank,(()=>"Error in depthwiseConv2d: filter must be rank 4, but got rank "+"".concat(c.rank,".")));const d="NHWC"===r?l.shape[3]:l.shape[1];AU(d===c.shape[2],(()=>"Error in depthwiseConv2d: number of input channels "+"(".concat(d,") must match the inChannels dimension in ")+"filter ".concat(c.shape[2],"."))),ZQ("depthwiseConv2d",a,s);const h={x:l,filter:c},p={strides:n,pad:a,dataFormat:r,dilations:o,dimRoundingMode:s},f=Pq.runKernel(aH,h,p);return u?$Q(f,[f.shape[1],f.shape[2],f.shape[3]]):f}});const PJ=Yq({diag_:function(e){const t={x:Kq(e,"x","diag")};return Pq.runKernel(sH,t)}});const zJ=Yq({dilation2d_:function(e,t,n,a){let r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:[1,1],o=arguments.length>5&&void 0!==arguments[5]?arguments[5]:"NHWC";const s=Kq(e,"x","dilation2d"),i=Kq(t,"filter","dilation2d");AU(3===s.rank||4===s.rank,(()=>"Error in dilation2d: input must be rank 3 or 4, but got rank "+"".concat(s.rank,"."))),AU(3===i.rank,(()=>"Error in dilation2d: filter must be rank 3, but got rank "+"".concat(i.rank,"."))),AU("NHWC"===o,(()=>"Error in dilation2d: Only NHWC is currently supported, "+"but got dataFormat of ".concat(o)));let c=s,l=!1;3===s.rank&&(c=$Q(s,[1,s.shape[0],s.shape[1],s.shape[2]]),l=!0),AU(c.shape[3]===i.shape[2],(()=>"Error in dilation2d:  input and filter must have the same depth: ".concat(c.shape[3]," vs ").concat(i.shape[2])));const u={x:c,filter:i},d={strides:n,pad:a,dilations:r},h=Pq.runKernel(iH,u,d);return l?$Q(h,[h.shape[1],h.shape[2],h.shape[3]]):h}});const BJ=Yq({equal_:function(e,t){let n=Kq(e,"a","equal","string_or_numeric"),a=Kq(t,"b","equal","string_or_numeric");[n,a]=_q(n,a),OY(n.shape,a.shape);const r={a:n,b:a};return Pq.runKernel(gH,r)}});const WJ=Yq({where_:function(e,t,n){const a=Kq(t,"a","where"),r=Kq(n,"b","where"),o=Kq(e,"condition","where","bool"),s=OY(OY(o.shape,a.shape),r.shape),i={condition:gJ(o,s),t:gJ(a,s),e:gJ(r,s)};return Pq.runKernel(zj,i)}});const VJ=Yq({divNoNan_:function(e,t){let n=Kq(e,"a","div"),a=Kq(t,"b","div");[n,a]=_q(n,a);const r=fY(n,a),o=yY(r),s=BJ(a,o);return WJ(s,o,r)}});const UJ=Yq({dot_:function(e,t){const n=Kq(e,"t1","dot"),a=Kq(t,"t2","dot");AU((1===n.rank||2===n.rank)&&(1===a.rank||2===a.rank),(()=>"Error in dot: inputs must all be rank 1 or 2, but got ranks "+"".concat(n.rank," and ").concat(a.rank,".")));const r=1===n.rank?n.size:n.shape[1],o=1===a.rank?a.size:a.shape[0];if(AU(r===o,(()=>"Error in dot: inner dimensions of inputs must match, but got "+"".concat(r," and ").concat(o,"."))),1===n.rank&&1===a.rank){const e=$Q(n,[1,-1]),t=$Q(a,[-1,1]),r=aJ(e,t);return $Q(r,[])}if(1===n.rank&&2===a.rank){const e=$Q(n,[1,-1]),t=$Q(a,[a.shape[0],a.shape[1]]),r=aJ(e,t);return $Q(r,[r.size])}if(2===n.rank&&1===a.rank){const e=$Q(a,[-1,1]),t=aJ(n,e);return $Q(t,[t.size])}{const e=$Q(a,[a.shape[0],a.shape[1]]);return aJ(n,e)}}});const GJ=Yq({einsum_:function(e){for(var t=arguments.length,n=new Array(t>1?t-1:0),a=1;a<t;a++)n[a-1]=arguments[a];const r=n.map(((e,t)=>Kq(e,"tensors".concat(t),"einsum"))),o={equation:e};return Pq.runKernel(hH,r,o)}});const HJ=Yq({elu_:function(e){const t={x:Kq(e,"x","elu","float32")};return Pq.runKernel(pH,t)}});const jJ=Yq({ensureShape_:function(e,t){const n=Kq(e,"x","ensureShape","string_or_numeric");if(!function(e,t){if(e===t)return!0;if(null==e||null==t)return!1;if(e.length!==t.length)return!1;for(let n=0;n<e.length;n++)if(null!==e[n]&&null!==t[n]&&e[n]!==t[n])return!1;return!0}(n.shape,t))throw new Error("EnsureShape: Shape of tensor ".concat(n.shape," is not compatible with expected shape ").concat(t));return e}});const KJ=Yq({erf_:function(e){let t=Kq(e,"x","erf");AU("int32"===t.dtype||"float32"===t.dtype,(()=>"Input dtype must be `int32` or `float32`.")),"int32"===t.dtype&&(t=lY(t,"float32"));const n={x:t};return Pq.runKernel(mH,n)}});function qJ(e,t){for(let n=0;n<e.length;++n)if(e[e.length-n-1]!==t-1-n)return!1;return!0}function XJ(e,t,n){const a=e.length+t.length,r=[];let o=0,s=0;for(let i=0;i<a;i++)-1===n.indexOf(i)?r.push(e[o++]):r.push(t[s++]);return r}function YJ(e,t){const n=[],a=e.length;for(let r=0;r<a;r++)-1===t.indexOf(r)&&n.push(e[r]);return[n,t.map((t=>e[t]))]}function QJ(e,t){return XJ(e,t.map((e=>1)),t)}function JJ(e,t,n){AU(qJ(t,n),(()=>"".concat(e," supports only inner-most axes for now. ")+"Got axes ".concat(t," and rank-").concat(n," input.")))}function ZJ(e,t){if(qJ(e,t))return null;const n=[];for(let a=0;a<t;++a)-1===e.indexOf(a)&&n.push(a);return e.forEach((e=>n.push(e))),n}function $J(e){return e.map(((e,t)=>[t,e])).sort(((e,t)=>e[1]-t[1])).map((e=>e[0]))}function eZ(e,t){const n=[];for(let a=t-e;a<t;++a)n.push(a);return n}const tZ=Yq({max_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const a={x:Kq(e,"x","max")},r={reductionIndices:t,keepDims:n};return Pq.runKernel(qH,a,r)}});const nZ=Yq({min_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const a={x:Kq(e,"x","min")},r={axis:t,keepDims:n};return Pq.runKernel(tj,a,r)}});const aZ=Yq({sum_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],a=Kq(e,"x","sum");"bool"===a.dtype&&(a=lY(a,"int32"));const r={x:a},o={axis:t,keepDims:n};return Pq.runKernel(qj,r,o)}});function rZ(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null;if(0===e.rank)return _Y(e);if(1!==e.rank&&null===n)return rZ($Q(e,[-1]),t,n);if(1===e.rank||"number"===typeof n||Array.isArray(n)&&1===n.length){if(1===t)return aZ(_Y(e),n);if(t===1/0)return tZ(_Y(e),n);if(t===-1/0)return nZ(_Y(e),n);if("euclidean"===t||2===t)return gY(aZ(EY(_Y(e),vY(2,"int32")),n));throw new Error("Error in norm: invalid ord value: ".concat(t))}if(Array.isArray(n)&&2===n.length){if(1===t)return tZ(aZ(_Y(e),n[0]),n[1]-1);if(t===1/0)return tZ(aZ(_Y(e),n[1]),n[0]);if(t===-1/0)return nZ(aZ(_Y(e),n[1]),n[0]);if("fro"===t||"euclidean"===t)return gY(aZ(bY(e),n));throw new Error("Error in norm: invalid ord value: ".concat(t))}throw new Error("Error in norm: invalid axis: ".concat(n))}const oZ=Yq({norm_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"euclidean",n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null,a=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const r=rZ(e=Kq(e,"x","norm"),t,n);let o=r.shape;if(a){const t=VU(n,e.shape);o=QJ(r.shape,t)}return $Q(r,o)}});const sZ=Yq({euclideanNorm_:function(e){return oZ(e,"euclidean",arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,arguments.length>2&&void 0!==arguments[2]&&arguments[2])}});const iZ=Yq({exp_:function(e){const t={x:Kq(e,"x","exp")};return Pq.runKernel(bH,t)}});const cZ=Yq({expandDims_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const n=Kq(e,"x","expandDims","string_or_numeric");AU(t<=n.rank,(()=>"Axis must be <= rank of the tensor"));const a={input:n},r={dim:t};return Pq.runKernel(yH,a,r)}});const lZ=Yq({expm1_:function(e){const t={x:Kq(e,"x","expm1")};return Pq.runKernel(xH,t)}});const uZ=Yq({tile_:function(e,t){const n=Kq(e,"x","tile","string_or_numeric");AU(n.rank===t.length,(()=>"Error in transpose: rank of input ".concat(n.rank," ")+"must match length of reps ".concat(t,".")));const a={x:n},r={reps:t};return Pq.runKernel(hK,a,r)}});const dZ=Yq({eye_:function(e,t,n){null==t&&(t=e);const a=cY([e,t],arguments.length>3&&void 0!==arguments[3]?arguments[3]:"float32"),r=e<=t?e:t;for(let s=0;s<r;++s)a.set(1,s,s);const o=$Q(a.toTensor(),[e,t]);if(null==n)return o;if(1===n.length)return uZ(cZ(o,0),[n[0],1,1]);if(2===n.length)return uZ(cZ(cZ(o,0),0),[n[0],n[1],1,1]);if(3===n.length)return uZ(cZ(cZ(cZ(o,0),0),0),[n[0],n[1],n[2],1,1]);throw new Error("eye() currently supports only 1D and 2D "+"batchShapes, but received ".concat(n.length,"D."))}});const hZ=Yq({floor_:function(e){const t={x:Kq(e,"x","floor","float32")};return Pq.runKernel(IH,t)}});const pZ=Yq({gather_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;const r={x:Kq(e,"x","gather"),indices:Kq(t,"indices","gather","int32")},o={axis:n,batchDims:a};return Pq.runKernel(CH,r,o)}});const fZ=Yq({greater_:function(e,t){let n=Kq(e,"a","greater","string_or_numeric"),a=Kq(t,"b","greater","string_or_numeric");[n,a]=_q(n,a),OY(n.shape,a.shape);const r={a:n,b:a};return Pq.runKernel(EH,r)}});const mZ=Yq({greaterEqual_:function(e,t){let n=Kq(e,"a","greaterEqual","string_or_numeric"),a=Kq(t,"b","greaterEqual","string_or_numeric");[n,a]=_q(n,a),OY(n.shape,a.shape);const r={a:n,b:a};return Pq.runKernel(RH,r)}});const gZ=Yq({imag_:function(e){const t={input:Kq(e,"input","imag")};return Pq.runKernel(FH,t)}});const bZ=Yq({isFinite_:function(e){const t={x:Kq(e,"x","isFinite")};return Pq.runKernel(OH,t)}});const yZ=Yq({isInf_:function(e){const t={x:Kq(e,"x","isInf")};return Pq.runKernel(DH,t)}});const xZ=Yq({isNaN_:function(e){const t={x:Kq(e,"x","isNaN")};return Pq.runKernel(MH,t)}});const vZ=Yq({leakyRelu_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:.2;const n={x:Kq(e,"x","leakyRelu")},a={alpha:t};return Pq.runKernel(LH,n,a)}});const wZ=Yq({less_:function(e,t){let n=Kq(e,"a","less","string_or_numeric"),a=Kq(t,"b","less","string_or_numeric");[n,a]=_q(n,a),OY(n.shape,a.shape);const r={a:n,b:a};return Pq.runKernel(PH,r)}});const kZ=Yq({lessEqual_:function(e,t){let n=Kq(e,"a","lessEqual","string_or_numeric"),a=Kq(t,"b","lessEqual","string_or_numeric");[n,a]=_q(n,a),OY(n.shape,a.shape);const r={a:n,b:a};return Pq.runKernel(zH,r)}});function IZ(e,t,n){if(n<=0)throw new Error("The number of values should be positive.");const a={start:e,stop:t,num:n};return Pq.runKernel(BH,{},a)}const SZ=Yq({localResponseNormalization_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:5,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1,r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:.5;const o=Kq(e,"x","localResponseNormalization");AU(4===o.rank||3===o.rank,(()=>"Error in localResponseNormalization: x must be rank 3 or 4 but got\n               rank ".concat(o.rank,"."))),AU(LU(t),(()=>"Error in localResponseNormalization: depthRadius must be an "+"integer but got depthRadius ".concat(t,".")));let s=o,i=!1;3===o.rank&&(i=!0,s=$Q(o,[1,o.shape[0],o.shape[1],o.shape[2]]));const c={x:s},l={depthRadius:t,bias:n,alpha:a,beta:r},u=Pq.runKernel(jH,c,l);return i?$Q(u,[u.shape[1],u.shape[2],u.shape[3]]):u}});const NZ=Yq({log_:function(e){const t={x:Kq(e,"x","log","float32")};return Pq.runKernel(WH,t)}});const CZ=Yq({log1p_:function(e){const t={x:Kq(e,"x","log1p")};return Pq.runKernel(VH,t)}});const TZ=Yq({neg_:function(e){const t={x:Kq(e,"x","neg")};return Pq.runKernel(ij,t)}});const EZ=Yq({softplus_:function(e){const t={x:Kq(e,"x","softplus")};return Pq.runKernel(jj,t)}});const RZ=Yq({logSigmoid_:function(e){const t=Kq(e,"x","logSigmoid");return xY((e=>({value:TZ(EZ(TZ(e))),gradFunc:t=>mY(t,rJ(TZ(e)))})))(t)}});const _Z=Yq({logSoftmax_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:-1;const n=Kq(e,"logits","logSoftmax");if(-1===t&&(t=n.rank-1),t!==n.rank-1)throw Error("Log Softmax along a non-last dimension is not yet supported. "+"Logits was rank ".concat(n.rank," and axis was ").concat(t));const a=xY(((e,n)=>{const a=tZ(e,t,!0),r=RY(e,a),o=RY(lY(r,"float32"),NZ(aZ(iZ(r),t,!0)));n([o]);return{value:o,gradFunc:(e,n)=>{const[a]=n,r=iZ(a);return RY(e,mY(aZ(e,t,!0),r))}}}));return a(n)}});const AZ=Yq({logSumExp_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const a=Kq(e,"x","logSumExp"),r=VU(t,a.shape),o=tZ(a,r,!0),s=RY(a,o),i=iZ(s),c=aZ(i,r),l=NZ(c),u=hY($Q(o,l.shape),l);if(n){const e=QJ(u.shape,r);return $Q(u,e)}return u}});const FZ=Yq({logicalAnd_:function(e,t){const n=Kq(e,"a","logicalAnd","bool"),a=Kq(t,"b","logicalAnd","bool");OY(n.shape,a.shape);const r={a:n,b:a};return Pq.runKernel(UH,r)}});const OZ=Yq({logicalNot_:function(e){const t={x:Kq(e,"x","logicalNot","bool")};return Pq.runKernel(GH,t)}});const DZ=Yq({logicalOr_:function(e,t){const n=Kq(e,"a","logicalOr","bool"),a=Kq(t,"b","logicalOr","bool");OY(n.shape,a.shape);const r={a:n,b:a};return Pq.runKernel(HH,r)}});const MZ=Yq({logicalXor_:function(e,t){const n=Kq(e,"a","logicalXor","bool"),a=Kq(t,"b","logicalXor","bool");return OY(n.shape,a.shape),FZ(DZ(e,t),OZ(FZ(e,t)))}}),LZ=2147483648;const PZ=Yq({searchSorted_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"left";const a=Kq(e,"sortedSequence","searchSorted"),r=Kq(t,"values","searchSorted"),o=a.shape[a.shape.length-1],s=r.shape[r.shape.length-1],i=$Q(a,[-1,o]),c=$Q(r,[-1,s]);if(i.rank<2)throw new Error("Sorted input argument must be at least 2-dimensional");if(i.shape[0]!==c.shape[0])throw new Error("Leading dimension of 'sortedSequence' and 'values' must match.");if(DU(c.shape)>=LZ)throw new Error("values tensor size must less than ".concat(LZ));if(i.shape[1]>=LZ)throw new Error("trailing dim_size must less than ".concat(LZ," for int32 output type, was ").concat(i.shape[1]));const l={sortedSequence:i,values:c},u={side:n};return Pq.runKernel(Pj,l,u)}});function zZ(e,t){return PZ(e,t,"left")}const BZ=Yq({maxPool_:function(e,t,n,a,r){const o=Kq(e,"x","maxPool");let s=o,i=!1;3===o.rank&&(i=!0,s=$Q(o,[1,o.shape[0],o.shape[1],o.shape[2]])),AU(4===s.rank,(()=>"Error in maxPool: input must be rank 4 but got rank ".concat(s.rank,"."))),AU(YQ(n,1),(()=>"Error in maxPool: Either strides or dilations must be 1. "+"Got strides ".concat(n," and dilations '").concat(1,"'"))),ZQ("maxPool",a,r);const c={x:s},l={filterSize:t,strides:n,pad:a,dimRoundingMode:r},u=Pq.runKernel(YH,c,l);return i?$Q(u,[u.shape[1],u.shape[2],u.shape[3]]):u}});const WZ=Yq({maxPool3d_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[1,1,1],n=arguments.length>2?arguments[2]:void 0,a=arguments.length>3?arguments[3]:void 0,r=arguments.length>4?arguments[4]:void 0,o=arguments.length>5&&void 0!==arguments[5]?arguments[5]:"NDHWC";const s=Kq(e,"x","maxPool3d");let i=s,c=!1;4===s.rank&&(c=!0,i=$Q(s,[1,s.shape[0],s.shape[1],s.shape[2],s.shape[3]])),AU(5===i.rank,(()=>"Error in maxPool3d: x must be rank 5 but got rank ".concat(i.rank,"."))),AU("NDHWC"===o,(()=>"Error in maxPool3d: Only NDHWC is currently supported, "+"but got dataFormat of ".concat(o))),ZQ("maxPool3d",a,r);const l={x:i},u={filterSize:t,strides:n,pad:a,dimRoundingMode:r,dataFormat:o},d=Pq.runKernel(JH,l,u);return c?$Q(d,[d.shape[1],d.shape[2],d.shape[3],d.shape[4]]):d}});const VZ=Yq({maxPoolWithArgmax_:function(e,t,n,a){let r=arguments.length>4&&void 0!==arguments[4]&&arguments[4];const o={x:Kq(e,"x","maxPoolWithArgmax")},s={filterSize:t,strides:n,pad:a,includeBatchInIndex:r},i=Pq.runKernel($H,o,s);return{result:i[0],indexes:i[1]}}});const UZ=Yq({mean_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const a={x:Kq(e,"x","mean")},r={axis:t,keepDims:n};return Pq.runKernel(ej,a,r)}});function GZ(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"float32";if(aG(e),"complex64"===t){const t=GZ(e,"float32"),n=GZ(e,"float32");return Qq(t,n)}const n=tG(DU(e),t);return Pq.makeTensor(n,e,t)}function HZ(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"float32";if(aG(e),"complex64"===t){const t=HZ(e,"float32"),n=GZ(e,"float32");return Qq(t,n)}const n=eG(DU(e),t);return Pq.makeTensor(n,e,t)}function jZ(e,t){let{indexing:n="xy"}=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};if("xy"!==n&&"ij"!==n)throw new TypeError("".concat(n," is not a valid third argument to meshgrid"));if(void 0===e)return[];let a=Kq(e,"x","meshgrid",e instanceof bq?e.dtype:"float32");if(void 0===t)return[a];let r=Kq(t,"y","meshgrid",t instanceof bq?t.dtype:"float32");const o=DU(a.shape),s=DU(r.shape);return"xy"===n?(a=$Q(a,[1,-1]),r=$Q(r,[-1,1]),[aJ(HZ([s,1],a.dtype),a),aJ(r,HZ([1,o],r.dtype))]):(a=$Q(a,[-1,1]),r=$Q(r,[1,-1]),[aJ(a,HZ([1,s],a.dtype)),aJ(HZ([o,1],r.dtype),r)])}const KZ=Yq({minimum_:function(e,t){let n=Kq(e,"a","minimum"),a=Kq(t,"b","minimum");[n,a]=_q(n,a),"bool"===n.dtype&&(n=lY(n,"int32"),a=lY(a,"int32")),OY(n.shape,a.shape);const r={a:n,b:a};return Pq.runKernel(nj,r)}});const qZ=Yq({mirrorPad_:function(e,t,n){AU("reflect"===n||"symmetric"===n,(()=>"Invalid mode. Mode must be either reflect or symmetric. "+"Got ".concat(n,".")));const a=Kq(e,"x","mirrorPad");if(0===a.rank)throw new Error("mirrorPad(scalar) is not defined. Pass non-scalar to mirrorPad");AU(t.length===a.rank,(()=>"Padding doesn't match input. Must be ".concat(a.rank,". ")+"Got ".concat(t.length,".")));const r="reflect"===n?1:0;for(let i=0;i<a.rank;i++)AU(2===t[i].length,(()=>"Invalid number of paddings. Must be length of 2 each.")),AU(t[i][0]>=0&&t[i][0]<=a.shape[i]-r&&t[i][1]>=0&&t[i][1]<=a.shape[i]-r,(()=>"Padding in dimension ".concat(i," cannot be greater than or equal ")+"to ".concat(a.shape[i]-r," or less than 0 for input of ")+"shape ".concat(a.shape)));const o={paddings:t,mode:n},s={x:a};return Pq.runKernel(aj,s,o)}});const XZ=Yq({mod_:function(e,t){let n=Kq(e,"a","mod"),a=Kq(t,"b","mod");[n,a]=_q(n,a);const r={a:n,b:a};return Pq.runKernel(rj,r)}});const YZ=Yq({moments_:function(e){let t=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const n=VU(arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,(e=Kq(e,"x","moments")).shape),a=UZ(e,n,t);let r=a.shape;t||(r=QJ(a.shape,n));const o=bY(RY(lY(e,"float32"),$Q(a,r)));return{mean:a,variance:UZ(o,n,t)}}});const QZ=Yq({multiRNNCell_:function(e,t,n,a){const r=Kq(t,"data","multiRNNCell"),o=qq(n,"c","multiRNNCell"),s=qq(a,"h","multiRNNCell");let i=r;const c=[];for(let d=0;d<e.length;d++){const t=e[d](i,o[d],s[d]);c.push(t[0]),c.push(t[1]),i=t[1]}const l=[],u=[];for(let d=0;d<c.length;d+=2)l.push(c[d]),u.push(c[d+1]);return[l,u]}});const JZ=Yq({multinomial_:function(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const r=Kq(e,"logits","multinomial"),o=r.size,s=r.rank;if(o<2)throw new Error("Error in multinomial: you need at least 2 outcomes, but got "+"".concat(o,"."));if(s>2)throw new Error("Rank of probabilities must be 1 or 2, but is ".concat(s));n=n||Math.random();const i={logits:1===s?$Q(r,[1,-1]):r},c={numSamples:t,seed:n,normalized:a},l=Pq.runKernel(oj,i,c);return 1===s?$Q(l,[l.size]):l}});const ZZ=Yq({notEqual_:function(e,t){let n=Kq(e,"a","notEqual","string_or_numeric"),a=Kq(t,"b","notEqual","string_or_numeric");[n,a]=_q(n,a),OY(n.shape,a.shape);const r={a:n,b:a};return Pq.runKernel(cj,r)}});const $Z=Yq({oneHot_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0,r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"int32";if(t<2)throw new Error("Error in oneHot: depth must be >=2, but it is ".concat(t));const o={indices:Kq(e,"indices","oneHot","int32")},s={dtype:r,depth:t,onValue:n,offValue:a};return Pq.runKernel(pj,o,s)}});const e$=Yq({onesLike_:function(e){const t={x:Kq(e,"x","onesLike")};return Pq.runKernel(hj,t)}});const t$=Yq({outerProduct_:function(e,t){const n=Kq(e,"v1","outerProduct"),a=Kq(t,"v2","outerProduct");AU(1===n.rank&&1===a.rank,(()=>"Error in outerProduct: inputs must be rank 1, but got ranks "+"".concat(n.rank," and ").concat(a.rank,".")));const r=$Q(n,[-1,1]),o=$Q(a,[1,-1]);return aJ(r,o)}});const n$=Yq({pad_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;const a=Kq(e,"x","pad");if(0===a.rank)throw new Error("pad(scalar) is not defined. Pass non-scalar to pad");const r={paddings:t,constantValue:n},o={x:a};return Pq.runKernel(mj,o,r)}});const a$=Yq({pad1d_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;return AU(2===t.length,(()=>"Invalid number of paddings. Must be length of 2.")),n$(e,[t],n)}});const r$=Yq({pad2d_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;return AU(2===t.length&&2===t[0].length&&2===t[1].length,(()=>"Invalid number of paddings. Must be length of 2 each.")),n$(e,t,n)}});const o$=Yq({pad3d_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;return AU(3===t.length&&2===t[0].length&&2===t[1].length&&2===t[2].length,(()=>"Invalid number of paddings. Must be length of 2 each.")),n$(e,t,n)}});const s$=Yq({pad4d_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;return AU(4===t.length&&2===t[0].length&&2===t[1].length&&2===t[2].length&&2===t[3].length,(()=>"Invalid number of paddings. Must be length of 2 each.")),n$(e,t,n)}});const i$=Yq({spaceToBatchND_:function(e,t,n){const a=Kq(e,"x","spaceToBatchND");AU(a.rank>=1+t.length,(()=>"input rank ".concat(a.rank," should be > than [blockShape] ").concat(t.length))),AU(n.length===t.length,(()=>"paddings.shape[0] ".concat(n.length," must be equal to [blockShape] ").concat(t.length))),AU(a.shape.reduce(((e,a,r)=>r>0&&r<=t.length?e&&(a+n[r-1][0]+n[r-1][1])%t[r-1]===0:e),!0),(()=>"input spatial dimensions ".concat(a.shape.slice(1)," with paddings ").concat(n.toString()," must be divisible by blockShapes ").concat(t.toString())));const r={x:a},o={blockShape:t,paddings:n};return Pq.runKernel(Xj,r,o)}});const c$=Yq({pool_:function(e,t,n,a,r,o,s){null==r&&(r=[1,1]),null==o&&(o=1),0===a&&(a="valid");const i=Kq(e,"x","maxPool");let c=i,l=!1;3===i.rank&&(l=!0,c=$Q(i,[1,i.shape[0],i.shape[1],i.shape[2]])),AU(YQ(o,r),(()=>"Error in pool: Either strides or dilations must be 1. "+"Got strides ".concat(o," and dilations '").concat(r,"'")));const u=BQ(c.shape,t,o,r,a),d=[u.dilationHeight,u.dilationWidth];let h;h="same"===a?function(e,t){const n=e.map(((e,n)=>e+(e-1)*(t[n]-1))),a=n.map((e=>e-1)),r=a.map((e=>Math.floor(e/2))),o=a.map(((e,t)=>e-r[t]));return a.map(((e,t)=>[r[t],o[t]]))}([u.filterHeight,u.filterWidth],d):[[0,0],[0,0]];const p=1===d[0]&&1===d[1],[f,m]=function(e,t,n){const a=n.map((e=>e[0])),r=n.map((e=>e[1])),o=e.concat(a,r),s=t.map(((e,t)=>(e-o[t]%e)%e)),i=r.map(((e,t)=>e+s[t])),c=t.map(((e,t)=>[a[t],i[t]])),l=t.map(((e,t)=>[0,s[t]]));return[c,l]}([u.inHeight,u.inWidth],d,h),g=p?a:"valid",b=p?c:i$(c,d,f),y=("avg"===n?()=>eJ(b,t,o,g,s):()=>BZ(b,t,o,g,s))(),x=p?y:cJ(y,d,m);return l?$Q(x,[x.shape[1],x.shape[2],x.shape[3]]):x}});const l$=Yq({prelu_:function(e,t){const n={x:Kq(e,"x","prelu"),alpha:Kq(t,"alpha","prelu")};return Pq.runKernel(bj,n)}});const u$=Yq({prod_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],a=Kq(e,"x","prod");"bool"===a.dtype&&(a=lY(a,"int32"));const r={x:a},o={axis:t,keepDims:n};return Pq.runKernel(yj,r,o)}});const d$=Yq({raggedGather_:function(e,t,n,a){const r=e.map(((e,t)=>Kq(e,"tensors".concat(t),"raggedGather","int32"))),o={paramsNestedSplits:r,paramsDenseValues:Kq(t,"paramsDenseValues","raggedGather"),indices:Kq(n,"indices","raggedGather","int32")},s={outputRaggedRank:a},i=Pq.runKernel(xj,o,s);return{outputNestedSplits:i.slice(0,i.length-1),outputDenseValues:i[i.length-1]}}});const h$=Yq({raggedRange_:function(e,t,n){const a=Kq(e,"starts","raggedRange"),r={starts:a,limits:Kq(t,"limits","raggedRange",a.dtype),deltas:Kq(n,"deltas","raggedRange",a.dtype)},o=Pq.runKernel(vj,r);return{rtNestedSplits:o[0],rtDenseValues:o[1]}}});const p$=Yq({raggedTensorToTensor_:function(e,t,n,a,r){const o=Kq(e,"shape","raggedTensorToTensor","int32"),s=Kq(t,"values","raggedTensorToTensor"),i=Kq(n,"defaultValue","raggedTensorToTensor",s.dtype),c=a.map(((e,t)=>Kq(e,"tensors".concat(t),"raggedTensorToTensor","int32"))),l={shape:o,values:s,defaultValue:i,rowPartitionTensors:c},u={rowPartitionTypes:r};return Pq.runKernel(wj,l,u)}});const f$=Yq({rand_:function(e,t,n){aG(e);const a=DU(e);let r=null;if(null==n||"float32"===n)r=new Float32Array(a);else if("int32"===n)r=new Int32Array(a);else{if("bool"!==n)throw new Error("Unknown data type ".concat(n));r=new Uint8Array(a)}for(let o=0;o<a;o++)r[o]=t();return Pq.makeTensor(r,e,n)}});class m${constructor(e,t,n,a,r){this.mean=e,this.stdDev=t,this.dtype=n,this.nextVal=NaN,this.truncated=a,this.truncated&&(this.upper=this.mean+2*this.stdDev,this.lower=this.mean-2*this.stdDev);const o=r||Math.random();this.random=sf.alea(o.toString())}nextValue(){if(!isNaN(this.nextVal)){const e=this.nextVal;return this.nextVal=NaN,e}let e,t,n=!1;for(;!n;){let a,r,o;do{a=2*this.random()-1,r=2*this.random()-1,o=a*a+r*r}while(o>=1||0===o);const s=Math.sqrt(-2*Math.log(o)/o);e=this.mean+this.stdDev*a*s,t=this.mean+this.stdDev*r*s,this.truncated&&!this.isValidTruncated(e)||(n=!0)}return this.truncated&&!this.isValidTruncated(t)||(this.nextVal=this.convertValue(t)),this.convertValue(e)}convertValue(e){return null==this.dtype||"float32"===this.dtype?e:Math.round(e)}isValidTruncated(e){return e<=this.upper&&e>=this.lower}}class g${constructor(e,t,n,a){this.alpha=e,this.beta=1/t,this.dtype=n;const r=a||Math.random();this.randu=sf.alea(r.toString()),this.randn=new m$(0,1,n,!1,this.randu()),this.d=e<1?e+2/3:e-1/3,this.c=1/Math.sqrt(9*this.d)}nextValue(){let e,t,n,a,r,o;for(;;){do{a=this.randn.nextValue(),o=1+this.c*a}while(o<=0);if(o*=o*o,e=a*a,t=1-.331*e*e,n=.5*e+this.d*(1-o+Math.log(o)),r=this.randu(),r<t||Math.log(r)<n)break}return o=1/this.beta*this.d*o,this.alpha<1&&(o*=Math.pow(this.randu(),1/this.alpha)),this.convertValue(o)}convertValue(e){return"float32"===this.dtype?e:Math.round(e)}}class b${constructor(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,n=arguments.length>2?arguments[2]:void 0,a=arguments.length>3?arguments[3]:void 0;if(this.canReturnFloat=()=>null==this.dtype||"float32"===this.dtype,this.min=e,this.range=t-e,this.dtype=n,null==a&&(a=Math.random()),"number"===typeof a&&(a=a.toString()),!this.canReturnFloat()&&this.range<=1)throw new Error("The difference between ".concat(e," - ").concat(t," <= 1 and dtype is not float"));this.random=sf.alea(a)}convertValue(e){return this.canReturnFloat()?e:Math.round(e)}nextValue(){return this.convertValue(this.min+this.range*this.random())}}const y$=Yq({randomGamma_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"float32",r=arguments.length>4?arguments[4]:void 0;if(aG(e),null==n&&(n=1),null==a&&(a="float32"),"float32"!==a&&"int32"!==a)throw new Error("Unsupported data type ".concat(a));const o=new g$(t,n,a,r),s=cY(e,a);for(let i=0;i<s.values.length;i++)s.values[i]=o.nextValue();return s.toTensor()}});const x$=Yq({randomNormal_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,a=arguments.length>3?arguments[3]:void 0,r=arguments.length>4?arguments[4]:void 0;if(aG(e),null!=a&&"bool"===a)throw new Error("Unsupported data type ".concat(a));const o=new m$(t,n,a,!1,r),s=cY(e,a);for(let i=0;i<s.values.length;i++)s.values[i]=o.nextValue();return s.toTensor()}});const v$=Yq({randomStandardNormal_:function(e,t,n){if(null!=t&&"bool"===t)throw new Error("Unsupported data type ".concat(t));return x$(e,0,1,t,n)}});const w$=Yq({randomUniform_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"float32",r=arguments.length>4?arguments[4]:void 0;aG(e);const o=cY(e,a),s=new b$(t,n,null,r);for(let i=0;i<o.values.length;i++)o.values[i]=s.nextValue();return o.toTensor()}});const k$=Yq({randomUniformInt_:function(e,t,n,a){return w$(e,t,n,"int32",a)}});function I$(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"float32";if(0===n)throw new Error("Cannot have a step of zero");const r={start:e,stop:t,step:n,dtype:a};return Pq.runKernel(kj,{},r)}const S$=Yq({real_:function(e){const t={input:Kq(e,"input","real")};return Pq.runKernel(Ij,t)}});const N$=Yq({reciprocal_:function(e){const t={x:Kq(e,"x","reciprocal")};return Pq.runKernel(Sj,t)}});const C$=Yq({relu_:function(e){const t={x:Kq(e,"x","relu")};return Pq.runKernel(Nj,t)}});const T$=Yq({relu6_:function(e){const t={x:Kq(e,"x","relu6")};return Pq.runKernel(Aj,t)}});const E$=Yq({reverse_:function(e,t){const n={x:Kq(e,"x","reverse")},a={dims:t};return Pq.runKernel(Fj,n,a)}});const R$=Yq({reverse1d_:function(e){const t=Kq(e,"x","reverse");return AU(1===t.rank,(()=>"Error in reverse1D: x must be rank 1 but got rank ".concat(t.rank,"."))),E$(t,0)}});const _$=Yq({reverse2d_:function(e,t){const n=Kq(e,"x","reverse");return AU(2===n.rank,(()=>"Error in reverse2D: x must be rank 2 but got rank ".concat(n.rank,"."))),E$(n,t)}});const A$=Yq({reverse3d_:function(e,t){const n=Kq(e,"x","reverse");return AU(3===n.rank,(()=>"Error in reverse3D: x must be rank 3 but got rank ".concat(n.rank,"."))),E$(n,t)}});const F$=Yq({reverse4d_:function(e,t){const n=Kq(e,"x","reverse");return AU(4===n.rank,(()=>"Error in reverse4D: x must be rank 4 but got rank ".concat(n.rank,"."))),E$(n,t)}});const O$=Yq({round_:function(e){const t={x:Kq(e,"x","round")};return Pq.runKernel(Oj,t)}});const D$=Yq({rsqrt_:function(e){const t={x:Kq(e,"x","rsqrt","float32")};return Pq.runKernel(Dj,t)}});const M$=Yq({selu_:function(e){const t={x:Kq(e,"x","selu")};return Pq.runKernel(Bj,t)}});const L$=Yq({separableConv2d_:function(e,t,n,a,r){let o=arguments.length>5&&void 0!==arguments[5]?arguments[5]:[1,1],s=arguments.length>6&&void 0!==arguments[6]?arguments[6]:"NHWC";const i=Kq(e,"x","separableConv2d"),c=Kq(t,"depthwiseFilter","separableConv2d"),l=Kq(n,"pointwiseFilter","separableConv2d");let u=i,d=!1;if(3===i.rank&&(d=!0,u=$Q(i,[1,i.shape[0],i.shape[1],i.shape[2]])),"NCHW"===s)throw new Error("separableConv2d currently does not support dataFormat NCHW; only NHWC is supported");AU(4===u.rank,(()=>"Error in separableConv2d: input must be rank 4, but got "+"rank ".concat(u.rank,"."))),AU(4===c.rank,(()=>"Error in separableConv2d: depthwise filter must be rank 4, but "+"got rank ".concat(c.rank,"."))),AU(4===l.rank,(()=>"Error in separableConv2d: pointwise filter must be rank 4, but "+"got rank ".concat(c.rank,"."))),AU(1===l.shape[0],(()=>"Error in separableConv2d: the first dimension of pointwise filter "+" must be 1, but got ".concat(l.shape[0],"."))),AU(1===l.shape[1],(()=>"Error in separableConv2d: the second dimension of pointwise "+"filter must be 1, but got ".concat(l.shape[1],".")));const h=c.shape[2],p=c.shape[3];AU(l.shape[2]===h*p,(()=>"Error in separableConv2d: the third dimension of pointwise filter "+"must be ".concat(h*p,", ")+"but got ".concat(l.shape[2],".")));const f=LJ(u,c,a,r,s,o),m=IJ(f,l,1,"valid",s);return d?$Q(m,[m.shape[1],m.shape[2],m.shape[3]]):m}});const P$=async function(e,t){const n=Kq(e,"x","setdiff1d"),a=Kq(t,"y","setdiff1d");AU(n.dtype===a.dtype,(()=>"x and y should have the same dtype, but got x (".concat(n.dtype,") and y (").concat(a.dtype,")."))),AU(1===n.rank,(()=>"x should be 1D tensor, but got x (".concat(n.shape,")."))),AU(1===a.rank,(()=>"y should be 1D tensor, but got y (".concat(a.shape,").")));const r=await n.data(),o=await a.data(),s=new Set(o);let i=0;for(let u=0;u<r.length;u++)s.has(r[u])||i++;const c=new pq([i],n.dtype),l=new pq([i],"int32");for(let u=0,d=0;u<r.length;u++)s.has(r[u])||(c.values[d]=r[u],l.values[d]=u,d++);return[c.toTensor(),l.toTensor()]};const z$=Yq({sign_:function(e){const t={x:Kq(e,"x","sign")};return Pq.runKernel(Gj,t)}});const B$=Yq({sin_:function(e){const t={x:Kq(e,"x","sin","float32")};return Pq.runKernel(Vj,t)}});const W$=Yq({sinh_:function(e){const t={x:Kq(e,"x","sinh")};return Pq.runKernel(Uj,t)}});const V$=Yq({slice1d_:function(e,t,n){const a=Kq(e,"x","slice1d");return AU(1===a.rank,(()=>"slice1d expects a rank-1 tensor, but got a rank-".concat(a.rank," tensor"))),oJ(a,[t],[n])}});const U$=Yq({slice2d_:function(e,t,n){const a=Kq(e,"x","slice2d");return AU(2===a.rank,(()=>"slice2d expects a rank-2 tensor, but got a rank-".concat(a.rank," tensor"))),oJ(a,t,n)}});const G$=Yq({slice3d_:function(e,t,n){const a=Kq(e,"x","slice3d");return AU(3===a.rank,(()=>"slice3d expects a rank-3 tensor, but got a rank-".concat(a.rank," tensor"))),oJ(a,t,n)}});const H$=Yq({slice4d_:function(e,t,n){const a=Kq(e,"x","slice4d");return AU(4===a.rank,(()=>"slice4d expects a rank-4 tensor, but got a rank-".concat(a.rank," tensor"))),oJ(a,t,n)}});const j$=Yq({softmax_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:-1;const n=Kq(e,"logits","softmax","float32");if(-1===t&&(t=n.rank-1),t!==n.rank-1)throw Error("Softmax along a non-last dimension is not yet supported. "+"Logits was rank ".concat(n.rank," and dim was ").concat(t));const a={logits:n},r={dim:t};return Pq.runKernel(Qj,a,r)}});const K$=Yq({fft_:function(e){AU("complex64"===e.dtype,(()=>"The dtype for tf.spectral.fft() must be complex64 "+"but got ".concat(e.dtype,".")));const t={input:e};return Pq.runKernel(vH,t)}});const q$=Yq({ifft_:function(e){AU("complex64"===e.dtype,(()=>"The dtype for tf.spectral.ifft() must be complex64 "+"but got ".concat(e.dtype,".")));const t={input:e};return Pq.runKernel(AH,t)}});const X$=Yq({irfft_:function(e){const t=e.shape[e.shape.length-1],n=e.size/t;let a;if(t<=2){const r=$Q(e,[n,t]);a=q$(r)}else{const r=[n,2*(t-1)],o=$Q(S$(e),[n,t]),s=$Q(gZ(e),[n,t]),i=E$(oJ(o,[0,1],[n,t-2]),1),c=mY(E$(oJ(s,[0,1],[n,t-2]),1),vY(-1)),l=nJ([o,i],1),u=nJ([s,c],1),d=$Q(Qq(l,u),[r[0],r[1]]);a=q$(d)}if(a=S$(a),3===e.rank&&0!==e.shape[0]){const t=a,n=e.shape[0];a=$Q(a,[n,a.shape[0]/n,a.shape[1]]),t.dispose()}return a}});const Y$=Yq({split_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;const a={x:Kq(e,"x","split")},r={numOrSizeSplits:t,axis:n};return Pq.runKernel(Yj,a,r)}});const Q$=Yq({rfft_:function(e,t){AU("float32"===e.dtype,(()=>"The dtype for rfft() must be real value but got ".concat(e.dtype)));let n=e.shape[e.shape.length-1];const a=e.size/n;let r;if(null!=t&&t<n){const a=e.shape.map((e=>0)),o=e.shape.map((e=>e));o[e.shape.length-1]=t,r=oJ(e,a,o),n=t}else if(null!=t&&t>n){const a=e.shape.map((e=>e));a[e.shape.length-1]=t-n,r=nJ([e,GZ(a)],e.shape.length-1),n=t}else r=e;const o=yY(r),s=$Q(Qq(r,o),[a,n]),i=K$(s),c=Math.floor(n/2)+1,l=S$(i),u=gZ(i),d=Y$(l,[c,n-c],l.shape.length-1),h=Y$(u,[c,n-c],u.shape.length-1),p=r.shape.slice();return p[r.shape.length-1]=c,$Q(Qq(d[0],h[0]),p)}});const J$=Yq({squaredDifference_:function(e,t){let n=Kq(e,"a","squaredDifference"),a=Kq(t,"b","squaredDifference");[n,a]=_q(n,a),OY(n.shape,a.shape);const r={a:n,b:a};return Pq.runKernel(nK,r,{})}});const Z$=Yq({squeeze_:function(e,t){const n=Kq(e,"x","squeeze","string_or_numeric");return $Q(n,UU(n.shape,t).newShape)}});const $$=Yq({stack_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const n=qq(e,"tensors","stack","string_or_numeric");AU(n.length>=1,(()=>"Pass at least one tensor to tf.stack")),n.length>0&&AU(t<=n[0].rank,(()=>"Axis must be <= rank of the tensor"));const a=n,r={axis:t};return Pq.runKernel(fj,a,r)}});const e0=Yq({step_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const n={x:Kq(e,"x","step")},a={alpha:t};return Pq.runKernel(vK,n,a)}});const t0=Yq({stridedSlice_:function(e,t,n,a){let r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:0,o=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0,s=arguments.length>6&&void 0!==arguments[6]?arguments[6]:0,i=arguments.length>7&&void 0!==arguments[7]?arguments[7]:0,c=arguments.length>8&&void 0!==arguments[8]?arguments[8]:0;const l={x:Kq(e,"x","stridedSlice","string_or_numeric")},u={begin:t,end:n,strides:a,beginMask:r,endMask:o,ellipsisMask:s,newAxisMask:i,shrinkAxisMask:c};return Pq.runKernel(oK,l,u)}});const n0=Yq({tan_:function(e){const t={x:Kq(e,"x","tan","float32")};return Pq.runKernel(uK,t)}});function a0(e,t){OU(e);const n=Gq(e,t);if(1!==n.length)throw new Error("tensor1d() requires values to be a flat/TypedArray");return Jq(e,null,n,t)}function r0(e,t,n){if(OU(e),null!=t&&2!==t.length)throw new Error("tensor2d() requires shape to have two numbers");const a=Gq(e,n);if(2!==a.length&&1!==a.length)throw new Error("tensor2d() requires values to be number[][] or flat/TypedArray");if(1===a.length&&null==t)throw new Error("tensor2d() requires shape to be provided when `values` are a flat/TypedArray");return Jq(e,t,a,n)}function o0(e,t,n){if(OU(e),null!=t&&4!==t.length)throw new Error("tensor4d() requires shape to have four numbers");const a=Gq(e,n);if(4!==a.length&&1!==a.length)throw new Error("tensor4d() requires values to be number[][][][] or flat/TypedArray");if(1===a.length&&null==t)throw new Error("tensor4d() requires shape to be provided when `values` are a flat array");return Jq(e,t,a,n)}function s0(e,t,n){if(OU(e),null!=t&&5!==t.length)throw new Error("tensor5d() requires shape to have five numbers");const a=Gq(e,n);if(5!==a.length&&1!==a.length)throw new Error("tensor5d() requires values to be number[][][][][] or flat/TypedArray");if(1===a.length&&null==t)throw new Error("tensor5d() requires shape to be provided when `values` are a flat array");return Jq(e,t,a,n)}function i0(e,t,n){if(OU(e),null!=t&&6!==t.length)throw new Error("tensor6d() requires shape to have six numbers");const a=Gq(e,n);if(6!==a.length&&1!==a.length)throw new Error("tensor6d() requires values to be number[][][][][][] or flat/TypedArray");if(1===a.length&&null==t)throw new Error("tensor6d() requires shape to be provided when `values` are a flat array");return Jq(e,t=t||a,a,n)}function c0(e,t,n){const a=t.rank>1?t.shape[t.rank-1]:1,r=t.rank>1?t.rank-1:1,o="Must have updates.shape = indices.shape[:batchDim] + "+"shape[sliceDim:], got updates.shape: ".concat(n.shape)+", indices.shape: ".concat(t.shape,", shape: ").concat(e)+", sliceDim: ".concat(a,", and batchDim: ").concat(r,".");if(n.rank<r)throw new Error(o+" update.rank < ".concat(r,". "));if(e.length<a+(n.rank-r))throw new Error(o+" Output shape length < ".concat(a+(n.rank-r)));if(n.rank!==r+e.length-a)throw new Error(o+" update.rank != ".concat(r+e.length-a));for(let s=0;s<r;++s)if(n.shape[s]!==t.shape[s])throw new Error(o+" updates.shape[".concat(s,"] (").concat(n.shape[s],") != indices.shape[").concat(s,"] (").concat(t.shape[s],")."));for(let s=0;s<n.rank-r;++s)if(n.shape[s+r]!==e[s+a])throw new Error(o+" updates.shape[".concat(s+r,"] (").concat(n.shape[s+r],") != shape[").concat(s+r,"] (").concat(e[s+r],")"))}function l0(e,t,n){if(t.rank<1)throw new Error("tf.scatterND() expects the indices to be rank 1 or higher,"+" but the rank was ".concat(t.rank,"."));if(e.rank<1)throw new Error("tf.scatterND() expects the updates to be rank 1 or higher,"+" but the rank was ".concat(e.rank,"."));if("int32"!==t.dtype)throw new Error("The dtype of 'indices' should be int32, but got dtype: ".concat(t.dtype));if(n.length<1)throw new Error("Output rank must be greater or equal to 1, but got shape: ".concat(n));if(0===n.length){if(0===t.size)throw new Error("Indices specified for empty output. indices shape: ".concat(t.shape));if(0===e.size)throw new Error("Updates specified for empty output. updates shape: ".concat(e.shape))}c0(n,t,e)}function u0(e,t,n){const a=t.shape.length,r=a>1?t.shape[a-1]:1,o=n.length;let s=1;for(let c=r;c<o;++c)s*=n[c];const i=r<1?1:r;return{sliceRank:r,numUpdates:DU(t.shape)/i,sliceSize:s,strides:[...JU(n.slice(0,r)),1],outputSize:DU(n)}}const d0=Yq({tensorScatterUpdate_:function(e,t,n){const a=Kq(e,"tensor","tensorScatterupdate"),r=Kq(t,"indices","tensorScatterupdate","int32"),o=Kq(n,"updates","tensorScatterupdate");if(l0(o,r,a.shape),a.dtype!==o.dtype)throw new Error("tensor and updates must have the same dtype, instead they are ".concat(a.dtype," and ").concat(o.dtype,"."));const s={tensor:a,indices:r,updates:o};return Pq.runKernel(Lj,s,{})}});const h0=Yq({topk_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,n=!(arguments.length>2&&void 0!==arguments[2])||arguments[2];const a=Kq(e,"x","topk");if(0===a.rank)throw new Error("topk() expects the input to be of rank 1 or higher");const r=a.shape[a.shape.length-1];if(t<0)throw new Error("'k' passed to topk() must be >= 0 but got ".concat(t));if(t>r)throw new Error("'k' passed to topk() must be <= the last dimension (".concat(r,") ")+"but got ".concat(t));const o={x:a},s={k:t,sorted:n},[i,c]=Pq.runKernel(pK,o,s);return{values:i,indices:c}}});const p0=Yq({truncatedNormal_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,a=arguments.length>3?arguments[3]:void 0,r=arguments.length>4?arguments[4]:void 0;if(aG(e),null!=a&&"bool"===a)throw new Error("Unsupported data type $ { dtype }");const o=new m$(t,n,a,!0,r),s=cY(e,a);for(let i=0;i<s.values.length;i++)s.values[i]=o.nextValue();return s.toTensor()}});const f0=Yq({unique_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const n=Kq(e,"x","unique","string_or_numeric");AU(n.rank>0,(()=>"The input tensor must be at least 1D"));const a={x:n},r={axis:t},[o,s]=Pq.runKernel(gK,a,r);return{values:o,indices:s}}});const m0=Yq({unsortedSegmentSum_:function(e,t,n){const a=Kq(e,"x","unsortedSegmentSum"),r=Kq(t,"segmentIds","unsortedSegmentSum","int32");AU(LU(n),(()=>"numSegments must be of dtype int"));const o={x:a,segmentIds:r},s={numSegments:n};return Pq.runKernel(yK,o,s)}});const g0=Yq({unstack_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const n=Kq(e,"x","unstack","string_or_numeric");AU(t>=-n.shape.length&&t<n.shape.length,(()=>"Axis = ".concat(t," is not in [-").concat(n.shape.length,", ").concat(n.shape.length,")")));const a={value:n},r={axis:t};return Pq.runKernel(bK,a,r)}});function b0(e,t){return PZ(e,t,"right")}function y0(e){let t=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],n=arguments.length>2?arguments[2]:void 0,a=arguments.length>3?arguments[3]:void 0;return Pq.makeVariable(e,t,n,a)}function x0(e,t){const n=[];for(let o=0;o<t.length;o++)t[o]&&n.push(o);const a=cY(e,"int32"),r=cY([n.length,e.length],"int32");for(let o=0;o<n.length;o++){const t=a.indexToLoc(n[o]),s=o*e.length;r.values.set(t,s)}return r.toTensor()}const v0=async function(e){const t=Kq(e,"condition","whereAsync","bool"),n=await t.data(),a=x0(t.shape,n);return e!==t&&t.dispose(),a};const w0=async function(e,t,n){const a=Kq(e,"tensor","boolMask"),r=Kq(t,"mask","boolMask","bool"),o=null==n?0:n,s=r.rank,i=a.shape;AU(s>0,(()=>"mask cannot be scalar")),FU(i.slice(o,o+s),r.shape,"mask's shape must match the first K dimensions of tensor's shape,");let c=1;for(let m=o;m<o+s;m++)c*=i[m];const l=i.slice(0,o).concat([c],i.slice(o+s)),u=$Q(a,l),d=$Q(r,[-1]),h=await v0(d),p=Z$(h,[1]),f=pZ(u,p,o);return e!==a&&a.dispose(),t!==r&&r.dispose(),p.dispose(),u.dispose(),d.dispose(),h.dispose(),f};const k0=Yq({transpose_:function(e,t,n){const a=Kq(e,"x","transpose");if(null==t&&(t=a.shape.map(((e,t)=>t)).reverse()),AU(a.rank===t.length,(()=>"Error in transpose: rank of input ".concat(a.rank," ")+"must match length of perm ".concat(t,"."))),t.forEach((e=>{AU(e>=0&&e<a.rank,(()=>"All entries in 'perm' must be between 0 and ".concat(a.rank-1)+" but got ".concat(t)))})),a.rank<=1)return a.clone();const r={x:a},o={perm:t};return"complex64"===a.dtype?nX((()=>{let e=S$(a),t=gZ(a);return e=Pq.runKernel(mK,{x:e},o),t=Pq.runKernel(mK,{x:t},o),n&&(t=TZ(t)),Qq(e,t)})):Pq.runKernel(mK,r,o)}});const I0=Yq({movingAverage_:function(e,t,n,a){let r=!(arguments.length>4&&void 0!==arguments[4])||arguments[4];const o=Kq(e,"v","movingAverage"),s=Kq(t,"x","movingAverage"),i=Kq(n,"decay","movingAverage");!function(e,t){AU(e.dtype===t.dtype,(()=>"The dtypes of the first(".concat(e.dtype,") and")+" second(".concat(t.dtype,") input must match")))}(o,s),AU(MU(o.shape,s.shape),(()=>"Shape mismatch in v and x"));const c=vY(1),l=RY(c,i);let u=mY(RY(s,o),l);if(r){AU(null!=a,(()=>"When using zeroDebias: true, step is required."));const e=Kq(a,"step","movingAverage");u=fY(u,RY(c,EY(i,e)))}return hY(o,u)}});const S0=Yq({scatterND_:function(e,t,n){aG(n);const a=Kq(e,"indices","scatterND","int32"),r=Kq(t,"updates","scatterND");l0(r,a,n);const o={indices:a,updates:r},s={shape:n};return Pq.runKernel(Mj,o,s)}});const N0=Yq({sparseToDense_:function(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;aG(n);const r=Kq(e,"sparseIndices","sparseToDense","int32"),o=Kq(t,"sparseValues","sparseToDense","string_or_numeric"),s=Kq(a,"defaultValue","sparseToDense",o.dtype);!function(e,t,n,a){if("int32"!==e.dtype)throw new Error("tf.sparseToDense() expects the indices to be int32 type,"+" but the dtype was ".concat(e.dtype,"."));if(e.rank>2)throw new Error("sparseIndices should be a scalar, vector, or matrix,"+" but got shape ".concat(e.shape,"."));const r=e.rank>0?e.shape[0]:1,o=e.rank>1?e.shape[1]:1;if(n.length!==o)throw new Error("outputShape has incorrect number of elements:,"+" ".concat(n.length,", should be: ").concat(o,"."));const s=t.size;if(0!==t.rank&&(1!==t.rank||s!==r))throw new Error("sparseValues has incorrect shape "+"".concat(t.shape,", should be [] or [").concat(r,"]"));if(t.dtype!==a.dtype)throw new Error("sparseValues.dtype must match defaultValues.dtype")}(r,o,n,s);const i={sparseIndices:r,sparseValues:o,defaultValue:s},c={outputShape:n};return Pq.runKernel(tK,i,c)}});const C0=Yq({gatherND_:function(e,t){const n=Kq(t,"indices","gatherND","int32"),a={params:Kq(e,"x","gatherND","string_or_numeric"),indices:n};return Pq.runKernel(TH,a)}});const T0=Yq({dropout_:function(e,t,n,a){const r=Kq(e,"x","dropout");if(AU("float32"===r.dtype,(()=>"x has to be a floating point tensor since it's going to be "+"scaled, but got a ".concat(r.dtype," tensor instead."))),AU(t>=0&&t<1,(()=>"rate must be a float in the range [0, 1), but got ".concat(t,"."))),0===t)return e instanceof bq?r.clone():r;const o=function(e,t){if(null==t)return e.shape.slice();if(MU(e.shape,t))return t;if(e.shape.length===t.length){const n=[];for(let a=0;a<e.shape.length;a++)null==t[a]&&null!=e.shape[a]?n.push(e.shape[a]):n.push(t[a]);return n}return t}(r,n),s=1-t,i=fY(hZ(hY(w$(o,0,1,"float32",a),s)),s);return mY(r,i)}});function E0(e){return Math.floor(Math.pow(2,Math.ceil(Math.log(e)/Math.log(2))))}function R0(e,t,n){const a=1-e%2,r=new Float32Array(e);for(let o=0;o<e;++o){const s=2*Math.PI*o/(e+a-1);r[o]=t-n*Math.cos(s)}return a0(r,"float32")}const _0=async function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1;const a=Kq(e,"predictions","inTopK"),r=Kq(t,"targets","inTopK");AU(a.rank>1,(()=>"inTopK() expects the predictions to be of rank 2 or higher, "+"but got ".concat(a.rank))),AU(a.rank-1===r.rank,(()=>"predictions rank should be 1 larger than targets rank, but got predictions rank "+"".concat(a.rank," and targets rank ").concat(r.rank))),FU(a.shape.slice(0,a.shape.length-1),r.shape,"predictions's shape should be align with the targets' shape, except the last dimension.");const o=a.shape[a.shape.length-1];AU(n>0&&n<=o,(()=>"'k' passed to inTopK() must be > 0 && <= the predictions last "+"dimension (".concat(o,"), but got ").concat(n)));const s=await a.data(),i=await r.data(),[c,l]=[s.length/o,o],u=GU("bool",c);for(let d=0;d<c;d++){const e=d*l,t=s.subarray(e,e+l),a=[];for(let n=0;n<t.length;n++)a.push({value:t[n],index:n});a.sort(((e,t)=>t.value-e.value)),u[d]=0;for(let r=0;r<n;r++)if(a[r].index===i[d]){u[d]=1;break}}return e!==a&&a.dispose(),t!==r&&r.dispose(),Zq(u,r.shape,"bool")};const A0=Yq({conv2DBackpropFilter_:function(e,t,n,a,r){let o=arguments.length>5&&void 0!==arguments[5]?arguments[5]:"NHWC",s=arguments.length>6?arguments[6]:void 0,i=e;3===e.rank&&(i=$Q(e,[1,e.shape[0],e.shape[1],e.shape[2]]));let c=t;3===c.rank&&(c=$Q(t,[1,t.shape[0],t.shape[1],t.shape[2]])),AU(4===i.rank,(()=>"Error in conv2dDerFilter: input must be rank 4, but got shape "+"".concat(i.shape,"."))),AU(4===c.rank,(()=>"Error in conv2dDerFilter: dy must be rank 4, but got shape "+"".concat(c.shape,"."))),AU(4===n.length,(()=>"Error in conv2dDerFilter: filterShape must be length 4, but got "+"".concat(n,".")));const l="NHWC"===o?i.shape[3]:i.shape[1],u="NHWC"===o?c.shape[3]:c.shape[1];AU(l===n[2],(()=>"Error in conv2dDerFilter: depth of input ".concat(l,") must ")+"match input depth in filter (".concat(n[2],"."))),AU(u===n[3],(()=>"Error in conv2dDerFilter: depth of dy (".concat(u,") must ")+"match output depth for filter (".concat(n[3],")."))),ZQ("conv2dDerFilter",r,s);const d={x:i,dy:c},h={strides:a,pad:r,dataFormat:o,dimRoundingMode:s,filterShape:n};return Pq.runKernel(jG,d,h)}});function F0(e,t,n){if(null==n||"linear"===n)return e;if("relu"===n)return mY(e,e0(t));throw new Error("Cannot compute gradient for fused activation ".concat(n,"."))}function O0(e,t){let n=t;const a=FY(e.shape,t.shape);return a.length>0&&(n=aZ(n,a)),$Q(n,e.shape)}function D0(e,t,n,a){if("linear"===t)return e;if("relu"===t)return C$(e);if("elu"===t)return HJ(e);if("relu6"===t)return T$(e);if("prelu"===t)return l$(e,n);if("leakyrelu"===t)return vZ(e,a);if("sigmoid"===t)return rJ(e);throw new Error("Unknown fused activation ".concat(t,"."))}const M0=(e,t)=>!(e>0)||"linear"===t;const L0=Yq({fusedConv2d_:function(e){let{x:t,filter:n,strides:a,pad:r,dataFormat:o="NHWC",dilations:s=[1,1],dimRoundingMode:i,bias:c,activation:l="linear",preluActivationWeights:u,leakyreluAlpha:d}=e;if(l=l||"linear",!1===M0(Pq.state.gradientDepth,l)){AU("NHWC"===o,(()=>"Error in fused conv2d: got dataFormat of ".concat(o," but ")+"only NHWC is currently supported for the case of gradient depth is 0 and the activation is not linear."));let e=IJ(t,n,a,r,o,s,i);return null!=c&&(e=hY(e,c)),D0(e,l,u,d)}const h=Kq(t,"x","conv2d","float32"),p=Kq(n,"filter","conv2d","float32");let f=h,m=!1;3===h.rank&&(m=!0,f=$Q(h,[1,h.shape[0],h.shape[1],h.shape[2]])),AU(4===f.rank,(()=>"Error in fused conv2d: input must be rank 4, but got rank "+"".concat(f.rank,"."))),AU(4===p.rank,(()=>"Error in fused conv2d: filter must be rank 4, but got rank "+"".concat(p.rank,"."))),ZQ("fused conv2d",r,i);const g="NHWC"===o?f.shape[3]:f.shape[1];AU(p.shape[2]===g,(()=>"Error in conv2d: depth of input (".concat(g,") must match ")+"input depth for filter ".concat(p.shape[2],"."))),AU(YQ(a,s),(()=>"Error in conv2D: Either strides or dilations must be 1. "+"Got strides ".concat(a," and dilations '").concat(s,"'")));const b=VQ(f.shape,p.shape,a,s,r,i);let y,x;if(null!=c&&(y=Kq(c,"bias","fused conv2d"),[y]=_q(y,h),"NHWC"===o?OY(b.outShape,y.shape):(AU(y.shape.length<=1,(()=>"Error in fused conv2d: only supports scalar or 1-D Tensor bias for NCHW format but got the bias of "+"rank-".concat(y.shape.length,"."))),AU(0===y.shape.length||y.shape[0]===b.outChannels||1===y.shape[0],(()=>"Error in fused conv2d: bias shape (".concat(y.shape,") is not ")+"compatible with the number of output channels "+"(".concat(b.outChannels,")"))))),null!=u){const e=u.shape;if(AU(e.length<=1||3===e.length,(()=>"Error in fused conv2d: only supports scalar, 1-D Tensor or 3-D Tensor PReLU activation weights but got a tensor of "+"rank-".concat(e.length,"."))),1===e.length)AU(1===e[0]||e[0]===b.outChannels,(()=>"Error in fused conv2d: PReLU activation weights "+"(".concat(e,") is not compatible with the number of output ")+"channels (".concat(b.outChannels,").")));else if(3===e.length)try{OY(e,b.outShape)}catch(D){const n="Error in fused conv2d: PReLU activation weights (".concat(e,") ")+"is not compatible with the output shape of the conv2d "+"(".concat(b.outShape,").");throw Error(n)}x=Kq(u,"prelu weights","fused conv2d")}const v=(e,t)=>{AU("NHWC"===o,(()=>"Error in gradient of fused conv2D: got dataFormat of ".concat(o," but only NHWC is currently supported.")));const[n,i,c,u]=t,d=F0(e,c,l);AU(XQ(s),(()=>"Error in gradient of fused conv2D: dilation rates greater than 1 "+"are not yet supported in gradients. Got dilations '".concat(s,"'")));const h=[NJ(i.shape,d,n,a,r),A0(i,d,n.shape,a,r)];if(null!=u){const e=O0(u,d);h.push(e)}return h},w={x:f,filter:p,bias:y,preluActivationWeights:x},k={strides:a,pad:r,dataFormat:o,dilations:s,dimRoundingMode:i,activation:l,leakyreluAlpha:d};if(null==c){const e=xY(((e,t,n)=>{let a=Pq.runKernel(SK,w,k);return n([t,e,a]),m&&(a=$Q(a,[a.shape[1],a.shape[2],a.shape[3]])),{value:a,gradFunc:v}}));return e(f,p)}{const e=xY(((e,t,n,a)=>{let r=Pq.runKernel(SK,w,k);return a([t,e,r,n]),m&&(r=$Q(r,[r.shape[1],r.shape[2],r.shape[3]])),{value:r,gradFunc:v}}));return e(f,p,y)}}});const P0=Yq({depthwiseConv2dNativeBackpropFilter_:function(e,t,n,a,r){let o=arguments.length>5&&void 0!==arguments[5]?arguments[5]:[1,1],s=arguments.length>6?arguments[6]:void 0,i=e;3===e.rank&&(i=$Q(e,[1,e.shape[0],e.shape[1],e.shape[2]]));let c=t;3===c.rank&&(c=$Q(t,[1,t.shape[0],t.shape[1],t.shape[2]]));const l={x:i,dy:c},u={strides:a,pad:r,dimRoundingMode:s,dilations:o,filterShape:n};return Pq.runKernel(rH,l,u)}});const z0=Yq({depthwiseConv2dNativeBackpropInput_:function(e,t,n,a,r){let o=arguments.length>5&&void 0!==arguments[5]?arguments[5]:[1,1],s=arguments.length>6?arguments[6]:void 0,i=t,c=!1;3===t.rank&&(c=!0,i=$Q(t,[1,t.shape[0],t.shape[1],t.shape[2]]));const l={dy:i,filter:n},u={strides:a,pad:r,dimRoundingMode:s,dilations:o,inputShape:e},d=Pq.runKernel(oH,l,u);return c?$Q(d,[d.shape[1],d.shape[2],d.shape[3]]):d}});const B0=Yq({fusedDepthwiseConv2d_:function(e){let{x:t,filter:n,strides:a,pad:r,dataFormat:o="NHWC",dilations:s=[1,1],dimRoundingMode:i,bias:c,activation:l="linear",preluActivationWeights:u,leakyreluAlpha:d}=e;if(!1===M0(Pq.state.gradientDepth,l)){let e=LJ(t,n,a,r,o,s,i);return null!=c&&(e=hY(e,c)),D0(e,l,u,d)}const h=Kq(t,"x","depthwiseConv2d","float32"),p=Kq(n,"filter","depthwiseConv2d","float32");let f=h,m=!1;3===h.rank&&(m=!0,f=$Q(h,[1,h.shape[0],h.shape[1],h.shape[2]])),AU(4===f.rank,(()=>"Error in fused depthwiseConv2d: input must be rank 4, but got "+"rank ".concat(f.rank,"."))),AU(4===p.rank,(()=>"Error in fused depthwiseConv2d: filter must be rank 4, "+"but got rank ".concat(p.rank,"."))),AU(f.shape[3]===p.shape[2],(()=>"Error in fused depthwiseConv2d: number of input channels "+"(".concat(f.shape[3],") must match the inChannels dimension in ")+"filter ".concat(p.shape[2],"."))),null==s&&(s=[1,1]),AU(YQ(a,s),(()=>"Error in fused depthwiseConv2d: Either strides or dilations must "+"be 1. Got strides ".concat(a," and dilations '").concat(s,"'"))),ZQ("fused depthwiseConv2d",r,i);const g=VQ(f.shape,p.shape,a,s,r,i,!0);let b,y;null!=c&&(b=Kq(c,"bias","fused conv2d"),[b]=_q(b,h),OY(g.outShape,b.shape)),null!=u&&(y=Kq(u,"prelu weights","fused depthwiseConv2d"));const x=(e,t)=>{AU(XQ(s),(()=>"Error in gradient of fused depthwiseConv2d: dilation rates greater than 1 are not yet supported. Got dilations "+"'".concat(s,"'")));const[n,o,c,u]=t,d=F0(e,c,l),h=z0(o.shape,d,n,a,r,s,i),p=P0(o,d,n.shape,a,r,s,i);if(null!=u){return[h,p,O0(b,d)]}return[h,p]},v={x:f,filter:p,bias:b,preluActivationWeights:y},w={strides:a,pad:r,dataFormat:o,dilations:s,dimRoundingMode:i,activation:l,leakyreluAlpha:d};if(null==c){const e=xY(((e,t,n)=>{let a=Pq.runKernel(NK,v,w);return n([t,e,a]),m&&(a=$Q(a,[a.shape[1],a.shape[2],a.shape[3]])),{value:a,gradFunc:x}}));return e(f,p)}{const e=xY(((e,t,n,a)=>{let r=Pq.runKernel(NK,v,w);return a([t,e,r,n]),m&&(r=$Q(r,[r.shape[1],r.shape[2],r.shape[3]])),{value:r,gradFunc:x}}));return e(f,p,b)}}});const W0=Yq({fusedMatMul_:function(e){let{a:t,b:n,transposeA:a=!1,transposeB:r=!1,bias:o,activation:s="linear",preluActivationWeights:i,leakyreluAlpha:c=.2}=e;if(!1===M0(Pq.state.gradientDepth,s)){let e=aJ(t,n,a,r);return null!=o&&(e=hY(e,o)),D0(e,s,i,c)}let l=Kq(t,"a","fused matMul"),u=Kq(n,"b","fused matMul");[l,u]=_q(l,u);const d=a?l.shape[l.rank-2]:l.shape[l.rank-1],h=r?u.shape[u.rank-1]:u.shape[u.rank-2],p=a?l.shape[l.rank-1]:l.shape[l.rank-2],f=r?u.shape[u.rank-2]:u.shape[u.rank-1],m=l.shape.slice(0,-2),g=u.shape.slice(0,-2),b=DU(m),y=DU(g);AU(d===h,(()=>"Error in fused matMul: inner shapes (".concat(d,") and (")+"".concat(h,") of Tensors with shapes ").concat(l.shape," and ")+"".concat(u.shape," and transposeA=").concat(a)+" and transposeB=".concat(r," must match.")));const x=OY(l.shape.slice(0,-2),u.shape.slice(0,-2)).concat([p,f]),v=$Q(l,a?[b,d,p]:[b,p,d]),w=$Q(u,r?[y,f,h]:[y,h,f]);let k,I;null!=o&&(k=Kq(o,"bias","fused matMul"),[k]=_q(k,l),OY(x,k.shape)),null!=i&&(I=Kq(i,"prelu weights","fused matMul"));const S=(e,t)=>{const[n,i,c,l]=t,u=F0($Q(e,c.shape),c,s);let d,h;if(a||r?!a&&r?(d=aJ(u,i,!1,!1),h=aJ(u,n,!0,!1)):a&&!r?(d=aJ(i,u,!1,!0),h=aJ(n,u,!1,!1)):(d=aJ(i,u,!0,!0),h=aJ(u,n,!0,!0)):(d=aJ(u,i,!1,!0),h=aJ(n,u,!0,!1)),null!=o){return[d,h,O0(l,u)]}return[d,h]},N={a:v,b:w,bias:k,preluActivationWeights:I},C={transposeA:a,transposeB:r,activation:s,leakyreluAlpha:c};if(null==o){const e=xY(((e,t,n)=>{const a=Pq.runKernel(IK,N,C);return n([e,t,a]),{value:$Q(a,x),gradFunc:S}}));return e(v,w)}{const e=xY(((e,t,n,a)=>{const r=Pq.runKernel(IK,N,C);return a([e,t,r,n]),{value:$Q(r,x),gradFunc:S}}));return e(v,w,k)}}});const V0=Yq({hammingWindow_:function(e){return R0(e,.54,.46)}});const U0=Yq({hannWindow_:function(e){return R0(e,.5,.5)}});const G0=Yq({frame_:function(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]&&arguments[3],r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:0,o=0;const s=[];for(;o+t<=e.size;)s.push(oJ(e,o,t)),o+=n;if(a)for(;o<e.size;){const a=o+t-e.size,i=nJ([oJ(e,o,t-a),TY([a],r)]);s.push(i),o+=n}return 0===s.length?r0([],[0,t]):$Q(nJ(s),[s.length,t])}});const H0=Yq({stft_:function(e,t,n,a){let r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:U0;null==a&&(a=E0(t));const o=G0(e,t,n),s=mY(o,r(t));return Q$(s,a)}});const j0=Yq({cropAndResize_:function(e,t,n,a){let r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"bilinear",o=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0;const s=Kq(e,"image","cropAndResize"),i=Kq(t,"boxes","cropAndResize","float32"),c=Kq(n,"boxInd","cropAndResize","int32"),l=i.shape[0];AU(4===s.rank,(()=>"Error in cropAndResize: image must be rank 4,"+"but got rank ".concat(s.rank,"."))),AU(2===i.rank&&4===i.shape[1],(()=>"Error in cropAndResize: boxes must be have size [".concat(l,",4] ")+"but had shape ".concat(i.shape,"."))),AU(1===c.rank&&c.shape[0]===l,(()=>"Error in cropAndResize: boxInd must be have size [".concat(l,"] ")+"but had shape ".concat(i.shape,"."))),AU(2===a.length,(()=>"Error in cropAndResize: cropSize must be of length 2, but got "+"length ".concat(a.length,"."))),AU(a[0]>=1&&a[1]>=1,(()=>"cropSize must be atleast [1,1], but was ".concat(a))),AU("bilinear"===r||"nearest"===r,(()=>"method must be bilinear or nearest, but was ".concat(r)));const u={image:s,boxes:i,boxInd:c},d={method:r,extrapolationValue:o,cropSize:a};return Pq.runKernel(eH,u,d)}});const K0=Yq({flipLeftRight_:function(e){const t=Kq(e,"image","flipLeftRight","float32");AU(4===t.rank,(()=>"Error in flipLeftRight: image must be rank 4,"+"but got rank ".concat(t.rank,".")));const n={image:t};return Pq.runKernel(kH,n,{})}});const q0=Yq({grayscaleToRGB_:function(e){const t=Kq(e,"image","grayscaleToRGB"),n=t.rank-1,a=t.shape[n];AU(t.rank>=2,(()=>"Error in grayscaleToRGB: images must be at least rank 2, "+"but got rank ".concat(t.rank,"."))),AU(1===a,(()=>"Error in grayscaleToRGB: last dimension of a grayscale image "+"should be size 1, but got size ".concat(a,".")));const r=new Array(t.rank);return r.fill(1,0,n),r[n]=3,uZ(t,r)}});const X0=Yq({rgbToGrayscale_:function(e){const t=Kq(e,"image","RGBToGrayscale"),n=t.rank-1,a=t.shape[n];AU(t.rank>=2,(()=>"Error in RGBToGrayscale: images must be at least rank 2, "+"but got rank ".concat(t.rank,"."))),AU(3===a,(()=>"Error in RGBToGrayscale: last dimension of an RGB image "+"should be size 3, but got size ".concat(a,".")));const r=t.dtype,o=lY(t,"float32"),s=a0([.2989,.587,.114]);let i;switch(t.rank){case 2:i=GJ("ij,j->i",o,s);break;case 3:i=GJ("ijk,k->ij",o,s);break;case 4:i=GJ("ijkl,l->ijk",o,s);break;case 5:i=GJ("ijklm,m->ijkl",o,s);break;case 6:i=GJ("ijklmn,n->ijklm",o,s);break;default:throw new Error("Not a valid tensor rank.")}return i=cZ(i,-1),lY(i,r)}});const Y0=Yq({rotateWithOffset_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:.5;const r=Kq(e,"image","rotateWithOffset","float32");AU(4===r.rank,(()=>"Error in rotateWithOffset: image must be rank 4,"+"but got rank ".concat(r.rank,".")));const o={image:r},s={radians:t,fillValue:n,center:a};return Pq.runKernel(kK,o,s)}});function Q0(e,t,n,a,r,o){null==a&&(a=.5),null==r&&(r=Number.NEGATIVE_INFINITY),null==o&&(o=0);const s=e.shape[0];return n=Math.min(n,s),AU(0<=a&&a<=1,(()=>"iouThreshold must be in [0, 1], but was '".concat(a,"'"))),AU(2===e.rank,(()=>"boxes must be a 2D tensor, but was of rank '".concat(e.rank,"'"))),AU(4===e.shape[1],(()=>"boxes must have 4 columns, but 2nd dimension was ".concat(e.shape[1]))),AU(1===t.rank,(()=>"scores must be a 1D tensor")),AU(t.shape[0]===s,(()=>"scores has incompatible shape with boxes. Expected ".concat(s,", ")+"but was ".concat(t.shape[0]))),AU(0<=o&&o<=1,(()=>"softNmsSigma must be in [0, 1], but was '".concat(o,"'"))),{maxOutputSize:n,iouThreshold:a,scoreThreshold:r,softNmsSigma:o}}const J0=Yq({nonMaxSuppression_:function(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:.5,r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:Number.NEGATIVE_INFINITY;const o=Kq(e,"boxes","nonMaxSuppression","float32"),s=Kq(t,"scores","nonMaxSuppression","float32"),i=Q0(o,s,n,a,r);n=i.maxOutputSize,a=i.iouThreshold,r=i.scoreThreshold;const c={maxOutputSize:n,iouThreshold:a,scoreThreshold:r};return Pq.runKernel(lj,{boxes:o,scores:s},c)}});function Z0(e,t,n){const a=function(e,t,n){return function(e,t,n){let a=0,r=e.length,o=0,s=!1;for(;a<r;){o=a+(r-a>>>1);const i=n(t,e[o]);i>0?a=o+1:(r=o,s=!i)}return s?a:-a-1}(e,t,n||$0)}(e,t,n),r=a<0?-(a+1):a;e.splice(r,0,t)}function $0(e,t){return e>t?1:e<t?-1:0}function e1(e,t,n,a,r){return a1(e,t,n,a,r,0)}function t1(e,t,n,a,r,o){return a1(e,t,n,a,r,0,!1,o,!0)}function n1(e,t,n,a,r,o){return a1(e,t,n,a,r,o,!0)}function a1(e,t,n,a,r,o){let s=arguments.length>6&&void 0!==arguments[6]&&arguments[6],i=arguments.length>7&&void 0!==arguments[7]&&arguments[7],c=arguments.length>8&&void 0!==arguments[8]&&arguments[8];const l=[];for(let g=0;g<t.length;g++)t[g]>r&&l.push({score:t[g],boxIndex:g,suppressBeginIndex:0});l.sort(s1);const u=o>0?-.5/o:0,d=[],h=[];for(;d.length<n&&l.length>0;){const t=l.pop(),{score:n,boxIndex:o,suppressBeginIndex:s}=t;if(n<r)break;let i=!1;for(let c=d.length-1;c>=s;--c){const n=r1(e,o,d[c]);if(n>=a){i=!0;break}if(t.score=t.score*o1(a,u,n),t.score<=r)break}t.suppressBeginIndex=d.length,i||(t.score===n?(d.push(o),h.push(t.score)):t.score>r&&Z0(l,t,s1))}const p=d.length,f=n-p;i&&f>0&&(d.push(...new Array(f).fill(0)),h.push(...new Array(f).fill(0)));const m={selectedIndices:d};return s&&(m.selectedScores=h),c&&(m.validOutputs=p),m}function r1(e,t,n){const a=e.subarray(4*t,4*t+4),r=e.subarray(4*n,4*n+4),o=Math.min(a[0],a[2]),s=Math.min(a[1],a[3]),i=Math.max(a[0],a[2]),c=Math.max(a[1],a[3]),l=Math.min(r[0],r[2]),u=Math.min(r[1],r[3]),d=Math.max(r[0],r[2]),h=Math.max(r[1],r[3]),p=(i-o)*(c-s),f=(d-l)*(h-u);if(p<=0||f<=0)return 0;const m=Math.max(o,l),g=Math.max(s,u),b=Math.min(i,d),y=Math.min(c,h),x=Math.max(b-m,0)*Math.max(y-g,0);return x/(p+f-x)}function o1(e,t,n){const a=Math.exp(t*n*n);return n<=e?a:0}function s1(e,t){return e.score-t.score||e.score===t.score&&t.boxIndex-e.boxIndex}const i1=async function(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:.5,r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:Number.NEGATIVE_INFINITY;const o=Kq(e,"boxes","nonMaxSuppressionAsync"),s=Kq(t,"scores","nonMaxSuppressionAsync"),i=Q0(o,s,n,a,r);n=i.maxOutputSize,a=i.iouThreshold,r=i.scoreThreshold;const c=await Promise.all([o.data(),s.data()]),l=c[0],u=c[1],{selectedIndices:d}=e1(l,u,n,a,r);return o!==e&&o.dispose(),s!==t&&s.dispose(),a0(d,"int32")};const c1=Yq({nonMaxSuppressionWithScore_:function(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:.5,r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:Number.NEGATIVE_INFINITY,o=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0;const s=Kq(e,"boxes","nonMaxSuppression"),i=Kq(t,"scores","nonMaxSuppression"),c=Q0(s,i,n,a,r,o);n=c.maxOutputSize,a=c.iouThreshold,r=c.scoreThreshold,o=c.softNmsSigma;const l={boxes:s,scores:i},u={maxOutputSize:n,iouThreshold:a,scoreThreshold:r,softNmsSigma:o},d=Pq.runKernel(dj,l,u);return{selectedIndices:d[0],selectedScores:d[1]}}});const l1=async function(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:.5,r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:Number.NEGATIVE_INFINITY,o=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0;const s=Kq(e,"boxes","nonMaxSuppressionAsync"),i=Kq(t,"scores","nonMaxSuppressionAsync"),c=Q0(s,i,n,a,r,o);n=c.maxOutputSize,a=c.iouThreshold,r=c.scoreThreshold,o=c.softNmsSigma;const l=await Promise.all([s.data(),i.data()]),u=l[0],d=l[1],{selectedIndices:h,selectedScores:p}=n1(u,d,n,a,r,o);return s!==e&&s.dispose(),i!==t&&i.dispose(),{selectedIndices:a0(h,"int32"),selectedScores:a0(p)}};const u1=Yq({nonMaxSuppressionPadded_:function(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:.5,r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:Number.NEGATIVE_INFINITY,o=arguments.length>5&&void 0!==arguments[5]&&arguments[5];const s=Kq(e,"boxes","nonMaxSuppression"),i=Kq(t,"scores","nonMaxSuppression"),c=Q0(s,i,n,a,r,null),l={boxes:s,scores:i},u={maxOutputSize:c.maxOutputSize,iouThreshold:c.iouThreshold,scoreThreshold:c.scoreThreshold,padToMaxOutputSize:o},d=Pq.runKernel(uj,l,u);return{selectedIndices:d[0],validOutputs:d[1]}}});const d1=async function(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:.5,r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:Number.NEGATIVE_INFINITY,o=arguments.length>5&&void 0!==arguments[5]&&arguments[5];const s=Kq(e,"boxes","nonMaxSuppressionAsync"),i=Kq(t,"scores","nonMaxSuppressionAsync"),c=Q0(s,i,n,a,r,null),l=c.maxOutputSize,u=c.iouThreshold,d=c.scoreThreshold,[h,p]=await Promise.all([s.data(),i.data()]),{selectedIndices:f,validOutputs:m}=t1(h,p,l,u,d,o);return s!==e&&s.dispose(),i!==t&&i.dispose(),{selectedIndices:a0(f,"int32"),validOutputs:vY(m,"int32")}};const h1=Yq({resizeBilinear_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],a=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const r=Kq(e,"images","resizeBilinear");AU(3===r.rank||4===r.rank,(()=>"Error in resizeBilinear: x must be rank 3 or 4, but got "+"rank ".concat(r.rank,"."))),AU(2===t.length,(()=>"Error in resizeBilinear: new shape must 2D, but got shape "+"".concat(t,"."))),AU(!1===a||!1===n,(()=>"Error in resizeBilinear: If halfPixelCenters is true, alignCorners must be false."));let o=r,s=!1;3===r.rank&&(s=!0,o=$Q(r,[1,r.shape[0],r.shape[1],r.shape[2]]));const[]=t,i={images:o},c={alignCorners:n,halfPixelCenters:a,size:t},l=Pq.runKernel(Rj,i,c);return s?$Q(l,[l.shape[1],l.shape[2],l.shape[3]]):l}});const p1=Yq({resizeNearestNeighbor_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],a=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const r=Kq(e,"images","resizeNearestNeighbor");AU(3===r.rank||4===r.rank,(()=>"Error in resizeNearestNeighbor: x must be rank 3 or 4, but got "+"rank ".concat(r.rank,"."))),AU(2===t.length,(()=>"Error in resizeNearestNeighbor: new shape must 2D, but got shape "+"".concat(t,"."))),AU("float32"===r.dtype||"int32"===r.dtype,(()=>"`images` must have `int32` or `float32` as dtype")),AU(!1===a||!1===n,(()=>"Error in resizeNearestNeighbor: If halfPixelCenters is true, alignCorners must be false."));let o=r,s=!1;3===r.rank&&(s=!0,o=$Q(r,[1,r.shape[0],r.shape[1],r.shape[2]]));const[]=t,i={images:o},c={alignCorners:n,halfPixelCenters:a,size:t},l=Pq.runKernel(Tj,i,c);return s?$Q(l,[l.shape[1],l.shape[2],l.shape[3]]):l}});const f1=Yq({threshold_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"binary",n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:.5;const r=Kq(e,"image","threshold"),o=r.shape[0]*r.shape[1];let s,i,c,l,u=mY(a0([a]),255);if(AU(3===r.rank,(()=>"Error in threshold: image must be rank 3,"+"but got rank ".concat(r.rank,"."))),AU(3===r.shape[2]||1===r.shape[2],(()=>"Error in threshold: image color channel must be equal to 3 or 1"+"but got ".concat(r.shape[2],"."))),AU("int32"===r.dtype||"float32"===r.dtype,(()=>"Error in dtype: image dtype must be int32 or float32,"+"but got dtype ".concat(r.dtype,"."))),AU("otsu"===t||"binary"===t,(()=>"Method must be binary or otsu, but was ".concat(t))),3===r.shape[2]){[s,i,c]=Y$(r,[1,1,1],-1);const e=mY(s,.2989),t=mY(i,.587),n=mY(c,.114);l=hY(hY(e,t),n)}else l=e;if("otsu"===t){u=function(e,t){let n,a,r,o,s,i,c=a0([-1]),l=a0([0]),u=a0([0]);for(let d=0;d<e.size-1;d++){n=oJ(e,0,d+1),a=oJ(e,d+1),s=fY(aZ(n),t),i=fY(aZ(a),t);const h=aZ(mY(n,I$(0,n.size)));r=fY(h,aZ(n));const p=TY(a.shape,n.size),f=hY(I$(0,a.size),p),m=mY(a,f);o=fY(aZ(m),aZ(a));const g=RY(r,o),b=RY(r,o),y=mY(s,i);u=mY(mY(y,g),b);const x=fZ(u,l);l=WJ(x,u,l),c=WJ(x,a0([d]),c)}return c}(pJ(lY(O$(l),"int32"),Zq([]),256),o)}const d=n?kZ(l,u):fZ(l,u);return lY(mY(d,255),"int32")}});const m1=Yq({transform_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"nearest",a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"constant",r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:0,o=arguments.length>5?arguments[5]:void 0;const s=Kq(e,"image","transform","float32"),i=Kq(t,"transforms","transform","float32");AU(4===s.rank,(()=>"Error in transform: image must be rank 4,"+"but got rank ".concat(s.rank,"."))),AU(2===i.rank&&(i.shape[0]===s.shape[0]||1===i.shape[0])&&8===i.shape[1],(()=>"Error in transform: Input transform should be batch x 8 or 1 x 8")),AU(null==o||2===o.length,(()=>"Error in transform: outputShape must be [height, width] or null, "+"but got ".concat(o,".")));const c={image:s,transforms:i},l={interpolation:n,fillMode:a,fillValue:r,outputShape:o};return Pq.runKernel(fK,c,l)}});const g1=Yq({bandPart_:function(e,t,n){const a=Kq(e,"a","bandPart");AU(a.rank>=2,(()=>"bandPart(): Rank must be at least 2, got ".concat(a.rank,".")));const r=a.shape,[o,s]=a.shape.slice(-2);let i,c;"number"===typeof t?(AU(t%1===0,(()=>"bandPart(): numLower must be an integer, got ".concat(t,"."))),AU(t<=o,(()=>"bandPart(): numLower (".concat(t,")")+" must not be greater than the number of rows (".concat(o,")."))),i=Kq(t<0?o:t,"numLower","bandPart")):(AU("int32"===t.dtype,(()=>"bandPart(): numLower's dtype must be an int32.")),i=WJ(wZ(t,0),o,KZ(t,o))),"number"===typeof n?(AU(n%1===0,(()=>"bandPart(): numUpper must be an integer, got ".concat(n,"."))),AU(n<=s,(()=>"bandPart(): numUpper (".concat(n,")")+" must not be greater than the number of columns (".concat(s,")."))),c=Kq(n<0?s:n,"numUpper","bandPart")):(AU("int32"===n.dtype,(()=>"bandPart(): numUpper's dtype must be an int32.")),c=WJ(wZ(n,0),s,KZ(n,s)));const l=$Q(I$(0,o,1,"int32"),[-1,1]),u=I$(0,s,1,"int32"),d=RY(l,u),h=FZ(kZ(d,i),mZ(d,TZ(c))),p=GZ([o,s],a.dtype);return $Q($$(g0($Q(a,[-1,o,s])).map((e=>WJ(h,e,p)))),r)}});const b1=Yq({gramSchmidt_:function(e){let t;if(Array.isArray(e)){t=!1,AU(null!=e&&e.length>0,(()=>"Gram-Schmidt process: input must not be null, undefined, or empty"));const n=e[0].shape[0];for(let t=1;t<e.length;++t)AU(e[t].shape[0]===n,(()=>"Gram-Schmidt: Non-unique lengths found in the input vectors: "+"(".concat(e[t].shape[0]," vs. ").concat(n,")")))}else t=!0,e=Y$(e,e.shape[0],0).map((e=>Z$(e,[0])));AU(e.length<=e[0].shape[0],(()=>"Gram-Schmidt: Number of vectors (".concat(e.length,") exceeds ")+"number of dimensions (".concat(e[0].shape[0],").")));const n=[],a=e;for(let r=0;r<e.length;++r)n.push(Pq.tidy((()=>{let e=a[r];if(r>0)for(let t=0;t<r;++t){const a=mY(aZ(mY(n[t],e)),n[t]);e=RY(e,a)}return fY(e,oZ(e,"euclidean"))})));return t?$$(n,0):n}});function y1(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];return Pq.tidy((()=>{AU(2===e.shape.length,(()=>"qr2d() requires a 2D Tensor, but got a ".concat(e.shape.length,"D Tensor.")));const n=e.shape[0],a=e.shape[1];let r=dZ(n),o=uY(e);const s=r0([[1]],[1,1]);let i=uY(s);const c=n>=a?a:n;for(let e=0;e<c;++e){const t=o,c=i,l=r;[i,o,r]=Pq.tidy((()=>{const t=oJ(o,[e,e],[n-e,1]),c=oZ(t),l=oJ(o,[e,e],[1,1]),u=WJ(fZ(l,0),r0([[-1]]),r0([[1]])),d=RY(l,mY(u,c)),h=fY(t,d);i=1===h.shape[0]?uY(s):nJ([s,oJ(h,[1,0],[h.shape[0]-1,h.shape[1]])],0);const p=TZ(fY(aJ(u,d),c)),f=oJ(o,[e,0],[n-e,a]),m=mY(p,i),g=k0(i);if(0===e)o=RY(f,aJ(m,aJ(g,f)));else{const t=RY(f,aJ(m,aJ(g,f)));o=nJ([oJ(o,[0,0],[e,a]),t],0)}const b=k0(m),y=oJ(r,[0,e],[n,r.shape[1]-e]);if(0===e)r=RY(y,aJ(aJ(y,i),b));else{const t=RY(y,aJ(aJ(y,i),b));r=nJ([oJ(r,[0,0],[n,e]),t],1)}return[i,o,r]})),aX([t,c,l])}return!t&&n>a&&(r=oJ(r,[0,0],[n,a]),o=oJ(o,[0,0],[a,a])),[r,o]}))}const x1=Yq({qr_:function(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];if(AU(e.rank>=2,(()=>"qr() requires input tensor to have a rank >= 2, but got rank ".concat(e.rank))),2===e.rank)return y1(e,t);{const n=e.shape.slice(0,e.shape.length-2).reduce(((e,t)=>e*t)),a=g0($Q(e,[n,e.shape[e.shape.length-2],e.shape[e.shape.length-1]]),0),r=[],o=[];a.forEach((e=>{const[n,a]=y1(e,t);r.push(n),o.push(a)}));return[$Q($$(r,0),e.shape),$Q($$(o,0),e.shape)]}}});var v1;!function(e){e[e.NONE=0]="NONE",e[e.MEAN=1]="MEAN",e[e.SUM=2]="SUM",e[e.SUM_BY_NONZERO_WEIGHTS=3]="SUM_BY_NONZERO_WEIGHTS"}(v1||(v1={}));const w1=Yq({computeWeightedLoss_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:v1.SUM_BY_NONZERO_WEIGHTS;const a=Kq(e,"losses","computeWeightedLoss");let r=null;null!=t&&(r=Kq(t,"weights","computeWeightedLoss"));const o=null==r?a:mY(a,r);if(n===v1.NONE)return o;if(n===v1.SUM)return aZ(o);if(n===v1.MEAN){if(null==r)return UZ(o);{const e=a.size/r.size,t=fY(aZ(o),aZ(r));return e>1?fY(t,vY(e)):t}}if(n===v1.SUM_BY_NONZERO_WEIGHTS){if(null==r)return fY(aZ(o),vY(a.size));{const e=mY(r,HZ(a.shape)),t=lY(aZ(ZZ(e,vY(0))),"float32");return fY(aZ(o),t)}}throw Error("Unknown reduction: ".concat(n))}});const k1=Yq({absoluteDifference_:function(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:v1.SUM_BY_NONZERO_WEIGHTS;const r=Kq(e,"labels","absoluteDifference"),o=Kq(t,"predictions","absoluteDifference");let s=null;null!=n&&(s=Kq(n,"weights","absoluteDifference")),FU(r.shape,o.shape,"Error in absoluteDifference: ");const i=_Y(RY(r,o));return w1(i,s,a)}});const I1=Yq({cosineDistance_:function(e,t,n,a){let r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:v1.SUM_BY_NONZERO_WEIGHTS;const o=Kq(e,"labels","cosineDistance"),s=Kq(t,"predictions","cosineDistance");let i=null;null!=a&&(i=Kq(a,"weights","cosineDistance")),FU(o.shape,s.shape,"Error in cosineDistance: ");const c=vY(1),l=RY(c,aZ(mY(o,s),n,!0));return w1(l,i,r)}});const S1=Yq({hingeLoss_:function(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:v1.SUM_BY_NONZERO_WEIGHTS,r=Kq(e,"labels","hingeLoss");const o=Kq(t,"predictions","hingeLoss");let s=null;null!=n&&(s=Kq(n,"weights","hingeLoss")),FU(r.shape,o.shape,"Error in hingeLoss: ");const i=vY(1);r=RY(mY(vY(2),r),i);const c=C$(RY(i,mY(r,o)));return w1(c,s,a)}});const N1=Yq({huberLoss_:function(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1,r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:v1.SUM_BY_NONZERO_WEIGHTS;const o=Kq(e,"labels","huberLoss"),s=Kq(t,"predictions","huberLoss");let i=null;null!=n&&(i=Kq(n,"weights","huberLoss")),FU(o.shape,s.shape,"Error in huberLoss: ");const c=vY(a),l=_Y(RY(s,o)),u=KZ(l,c),d=RY(l,u),h=hY(mY(vY(.5),bY(u)),mY(c,d));return w1(h,i,r)}});const C1=Yq({logLoss_:function(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1e-7,r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:v1.SUM_BY_NONZERO_WEIGHTS;const o=Kq(e,"labels","logLoss"),s=Kq(t,"predictions","logLoss");let i=null;null!=n&&(i=Kq(n,"weights","logLoss")),FU(o.shape,s.shape,"Error in logLoss: ");const c=vY(1),l=vY(a),u=TZ(mY(o,NZ(hY(s,l)))),d=mY(RY(c,o),NZ(hY(RY(c,s),l))),h=RY(u,d);return w1(h,i,r)}});const T1=Yq({meanSquaredError_:function(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:v1.SUM_BY_NONZERO_WEIGHTS;const r=Kq(e,"labels","meanSquaredError"),o=Kq(t,"predictions","meanSquaredError");let s=null;null!=n&&(s=Kq(n,"weights","meanSquaredError")),FU(r.shape,o.shape,"Error in meanSquaredError: ");const i=J$(r,o);return w1(i,s,a)}});const E1=Yq({sigmoidCrossEntropy_:function(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0,r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:v1.SUM_BY_NONZERO_WEIGHTS,o=Kq(e,"multiClassLabels","sigmoidCrossEntropy");const s=Kq(t,"logits","sigmoidCrossEntropy");let i=null;if(null!=n&&(i=Kq(n,"weights","sigmoidCrossEntropy")),FU(o.shape,s.shape,"Error in sigmoidCrossEntropy: "),a>0){const e=vY(a),t=vY(1),n=vY(.5);o=hY(mY(o,RY(t,e)),mY(n,e))}const c=function(e,t){const n=Kq(e,"labels","sigmoidCrossEntropyWithLogits"),a=Kq(t,"logits","sigmoidCrossEntropyWithLogits");FU(n.shape,a.shape,"Error in sigmoidCrossEntropyWithLogits: ");const r=C$(a),o=mY(a,n),s=CZ(iZ(TZ(_Y(a))));return hY(RY(r,o),s)}(o,s);return w1(c,i,r)}});const R1=Yq({softmaxCrossEntropy_:function(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0,r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:v1.SUM_BY_NONZERO_WEIGHTS,o=Kq(e,"onehotLabels","softmaxCrossEntropy");const s=Kq(t,"logits","softmaxCrossEntropy");let i=null;if(null!=n&&(i=Kq(n,"weights","softmaxCrossEntropy")),FU(o.shape,s.shape,"Error in softmaxCrossEntropy: "),a>0){const e=vY(a),t=vY(1),n=vY(o.shape[1]);o=hY(mY(o,RY(t,e)),fY(e,n))}const c=function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:-1;if(-1===n&&(n=t.rank-1),n!==t.rank-1)throw Error("Softmax cross entropy along a non-last dimension is not yet "+"supported. Labels / logits was rank ".concat(t.rank," ")+"and dim was ".concat(n));const a=xY(((e,t,a)=>{const r=AZ(t,[n],!0),o=RY(lY(t,"float32"),r);a([e,o]);const s=TZ(mY(o,e));return{value:aZ(s,[n]),gradFunc:(e,t)=>{const[a,r]=t,o=QJ(e.shape,[n]);return[mY($Q(e,o),RY(lY(a,"float32"),iZ(r))),mY($Q(e,o),RY(iZ(r),lY(a,"float32")))]}}}));return a(e,t)}(o,s);return w1(c,i,r)}});const _1=Yq({sparseFillEmptyRows_:function(e,t,n,a){const r=Kq(e,"indices","sparseFillEmptyRows","int32"),o=Kq(t,"values","sparseFillEmptyRows"),s=Kq(n,"denseShape","sparseFillEmptyRows","int32"),i=Kq(a,"defaultValue","sparseFillEmptyRows",o.dtype);if(2!==r.rank)throw new Error("Indices should be Tensor2D but received shape\n        ".concat(r.shape));if(1!==o.rank)throw new Error("Values should be Tensor1D but received shape ".concat(o.shape));if(1!==s.rank)throw new Error("Dense shape should be Tensor1D but received shape ".concat(s.shape));if(0!==i.rank)throw new Error("Default value should be a scalar but received shape ".concat(i.shape));const c={indices:r,values:o,denseShape:s,defaultValue:i},l=Pq.runKernel(Jj,c);return{outputIndices:l[0],outputValues:l[1],emptyRowIndicator:l[2],reverseIndexMap:l[3]}}});const A1=Yq({sparseReshape_:function(e,t,n){const a=Kq(e,"inputIndices","sparseReshape","int32"),r=Kq(t,"inputShape","sparseReshape","int32"),o=Kq(n,"newShape","sparseReshape","int32");if(2!==a.rank)throw new Error("Input indices should be Tensor2D but received shape\n        ".concat(a.shape));if(1!==r.rank)throw new Error("Input shape should be Tensor1D but received shape ".concat(r.shape));if(1!==o.rank)throw new Error("New shape should be Tensor1D but received shape ".concat(o.shape));const s={inputIndices:a,inputShape:r,newShape:o},i=Pq.runKernel(Zj,s);return{outputIndices:i[0],outputShape:i[1]}}});const F1=Yq({sparseSegmentMean_:function(e,t,n){const a=Kq(e,"data","sparseSegmentMean"),r=Kq(t,"indices","sparseSegmentMean","int32"),o=Kq(n,"segmentIds","sparseSegmentMean","int32");if(a.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==r.rank)throw new Error("Indices should be Tensor1D but received shape\n          ".concat(r.shape));if(1!==o.rank)throw new Error("Segment ids should be Tensor1D but received shape\n          ".concat(o.shape));const s={data:a,indices:r,segmentIds:o};return Pq.runKernel($j,s)}});const O1=Yq({sparseSegmentSum_:function(e,t,n){const a=Kq(e,"data","sparseSegmentSum"),r=Kq(t,"indices","sparseSegmentSum","int32"),o=Kq(n,"segmentIds","sparseSegmentSum","int32");if(a.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==r.rank)throw new Error("Indices should be Tensor1D but received shape\n         ".concat(r.shape));if(1!==o.rank)throw new Error("Segment ids should be Tensor1D but received shape\n         ".concat(o.shape));const s={data:a,indices:r,segmentIds:o};return Pq.runKernel(eK,s)}});const D1=Yq({stringNGrams_:function(e,t,n,a,r,o,s,i){const c=Kq(e,"data","stringNGrams","string");if("string"!==c.dtype)throw new Error("Data must be of datatype string");if(1!==c.shape.length)throw new Error("Data must be a vector, saw: ".concat(c.shape));const l=Kq(t,"dataSplits","stringNGrams");if("int32"!==l.dtype)throw new Error("Data splits must be of datatype int32");const u={separator:n,nGramWidths:a,leftPad:r,rightPad:o,padWidth:s,preserveShortSequences:i},d={data:c,dataSplits:l},h=Pq.runKernel(sK,d,u);return{nGrams:h[0],nGramsSplits:h[1]}}});const M1=Yq({stringSplit_:function(e,t){let n=!(arguments.length>2&&void 0!==arguments[2])||arguments[2];const a=Kq(e,"input","stringSplit","string"),r=Kq(t,"delimiter","stringSplit","string");if(1!==a.rank)throw new Error("Input should be Tensor1D but received shape ".concat(a.shape));if(0!==r.rank)throw new Error("Delimiter should be a scalar but received shape ".concat(r.shape));const o={skipEmpty:n},s={input:a,delimiter:r},i=Pq.runKernel(iK,s,o);return{indices:i[0],values:i[1],shape:i[2]}}});const L1=Yq({stringToHashBucketFast_:function(e,t){const n=Kq(e,"input","stringToHashBucketFast","string"),a={numBuckets:t};if(t<=0)throw new Error("Number of buckets must be at least 1");const r={input:n};return Pq.runKernel(cK,r,a)}});const P1=Yq({staticRegexReplace_:function(e,t,n){let a=!(arguments.length>3&&void 0!==arguments[3])||arguments[3];const r=Kq(e,"input","staticRegexReplace","string"),o={pattern:t,rewrite:n,replaceGlobal:a};return Pq.runKernel(rK,{x:r},o)}}),z1={fft:K$,ifft:q$,rfft:Q$,irfft:X$},B1={hammingWindow:V0,hannWindow:U0,frame:G0,stft:H0},W1={flipLeftRight:K0,grayscaleToRGB:q0,resizeNearestNeighbor:p1,resizeBilinear:h1,rgbToGrayscale:X0,rotateWithOffset:Y0,cropAndResize:j0,nonMaxSuppression:J0,nonMaxSuppressionAsync:i1,nonMaxSuppressionWithScore:c1,nonMaxSuppressionWithScoreAsync:l1,nonMaxSuppressionPadded:u1,nonMaxSuppressionPaddedAsync:d1,threshold:f1,transform:m1},V1={bandPart:g1,gramSchmidt:b1,qr:x1},U1={absoluteDifference:k1,computeWeightedLoss:w1,cosineDistance:I1,hingeLoss:S1,huberLoss:N1,logLoss:C1,meanSquaredError:T1,sigmoidCrossEntropy:E1,softmaxCrossEntropy:R1},G1={sparseFillEmptyRows:_1,sparseReshape:A1,sparseSegmentMean:F1,sparseSegmentSum:O1},H1={stringNGrams:D1,stringSplit:M1,stringToHashBucketFast:L1,staticRegexReplace:P1},j1="undefined"!==typeof requestAnimationFrame?requestAnimationFrame:"undefined"!==typeof setImmediate?setImmediate:e=>e();function K1(e,t){const n=e[0].length;e.forEach(((e,t)=>{AU(e.length===n,(()=>"Error in concat".concat(n,"D: rank of tensors[").concat(t,"] must be the same ")+"as the rank of the rest (".concat(n,")")))})),AU(t>=0&&t<n,(()=>"Error in concat".concat(n,"D: axis must be between 0 and ").concat(n-1,".")));const a=e[0];e.forEach(((e,r)=>{for(let o=0;o<n;o++)AU(o===t||e[o]===a[o],(()=>"Error in concat".concat(n,"D: Shape of tensors[").concat(r,"] (").concat(e,") ")+"does not match the shape of the rest (".concat(a,") ")+"along the non-concatenated axis ".concat(r,".")))}))}function q1(e,t){const n=e[0].slice();for(let a=1;a<e.length;a++)n[t]+=e[a][t];return n}var X1;function Y1(e,t,n){let a=new Array;if(null==n&&null==t)return a;if(null==t)for(;a.length<e+n.length;)a.push(-1);else a=t.slice();if(null==n)return a;if(e+n.length!==a.length)throw new Error("rt input.shape and shape=".concat(t," are incompatible: rt input.rank = ").concat(e+n.length,", but shape.rank = ").concat(a.length));for(let r=1;r<n.length;++r){const o=n[r],s=a[a.length-n.length+r],i=a[s];if(o>=0)if(i>=0){if(i!==o)throw new Error("rt input.shape and shape=".concat(t," are incompatible: rt input.shape[").concat(r+e,"] = ").concat(o," but shape[").concat(r+e,"] = ").concat(i))}else a[s]=o}return a}function Q1(e){const t={FIRST_DIM_SIZE:X1.FIRST_DIM_SIZE,VALUE_ROWIDS:X1.VALUE_ROWIDS,ROW_LENGTHS:X1.ROW_LENGTHS,ROW_SPLITS:X1.ROW_SPLITS,ROW_LIMITS:X1.ROW_LIMITS,ROW_STARTS:X1.ROW_STARTS},n=[];for(const a of e){if(!(a in t))break;n.push(t[a])}return n}function J1(e){return 0===e.length?0:e[0]===X1.FIRST_DIM_SIZE?e.length-1:e.length}function Z1(e,t){if(null==e||null==t)return;const n=e.length,a=t.length;if(n>=a)throw new Error("defaultValue.shape=".concat(e," and ragged tensor flatValues.shape=").concat(t,", are incompatible: defaultValue.rank = ").concat(n," must be less than ragged tensor input flatValues.rank = ").concat(a,")"));for(let r=0;r<Math.min(n,a-1);++r){const n=e[r],a=t[r+1];if(n>=0&&a>=0&&1!==n&&n!==a)throw new Error("defaultValue.shape=".concat(e,", and ragged tensor input flatValues.shape=").concat(t," are incompatible: defaultValue.shape[").concat(r-e.length,"] = ").concat(n," but ragged tensor input.flatValues.shape[").concat(r-e.length,"] = ").concat(a))}}!function(e){e[e.FIRST_DIM_SIZE=0]="FIRST_DIM_SIZE",e[e.VALUE_ROWIDS=1]="VALUE_ROWIDS",e[e.ROW_LENGTHS=2]="ROW_LENGTHS",e[e.ROW_SPLITS=3]="ROW_SPLITS",e[e.ROW_LIMITS=4]="ROW_LIMITS",e[e.ROW_STARTS=5]="ROW_STARTS"}(X1||(X1={}));const $1=30;function e2(e){return e<=$1?e:QU(e,Math.floor(Math.sqrt(e)))}function t2(e,t,n){return[n*("number"===typeof e?e:e[0]),t*("number"===typeof e?e:e[1])]}function n2(e,t,n){let a=[];if(!(arguments.length>3&&void 0!==arguments[3])||arguments[3])a=a.concat(t.slice(0)),a.push(e[0]/n),a=a.concat(e.slice(1));else{a=a.concat(e[0]);const n=t.length;for(let r=0;r<n;++r)a=a.concat([e[r+1]/t[r],t[r]]);a=a.concat(e.slice(n+1))}return a}function a2(e,t){const n=[];if(!(arguments.length>2&&void 0!==arguments[2])||arguments[2]){n.push(t);for(let a=t+1;a<e;++a)a<=2*t?(n.push(a),n.push(a-(t+1))):n.push(a)}else{const a=[],r=[];for(let n=1;n<e;++n)n>=2*t+1||n%2===1?r.push(n):a.push(n);n.push(...a),n.push(0),n.push(...r)}return n}function r2(e,t,n){let a=!(arguments.length>3&&void 0!==arguments[3])||arguments[3];const r=[];a?r.push(e[0]/n):r.push(e[0]*n);for(let o=1;o<e.length;++o)o<=t.length?a?r.push(t[o-1]*e[o]):r.push(e[o]/t[o-1]):r.push(e[o]);return r}function o2(e,t){const n=[0];for(let a=0;a<t;++a)n.push(e[a][0]);return n}function s2(e,t,n){const a=e.slice(0,1);for(let r=0;r<n;++r)a.push(e[r+1]-t[r][0]-t[r][1]);return a}function i2(e,t){const n=e.shape.length,a=t.shape.length;if(n<1)throw new Error("tf.gatherND() expects the input to be rank 1 or higher,"+" but the rank was ".concat(n,"."));if(a<1)throw new Error("tf.gatherND() expects the indices to be rank 1 or higher,"+" but the rank was ".concat(a,"."));if("int32"!==t.dtype)throw new Error("tf.gatherND() expects the indices to be int32 type,"+" but the dtype was ".concat(t.dtype,"."));if(t.shape[a-1]>n)throw new Error("index innermost dimension length must be <= tensor rank; saw: "+"".concat(t.shape[a-1]," vs. ").concat(n));if(0===DU(e.shape))throw new Error("Requested more than 0 entries, but input is empty."+" Input shape: ".concat(e.shape,"."));const r=t.shape,o=r[r.length-1];let s=1;for(let d=0;d<r.length-1;++d)s*=r[d];const i=e.shape,c=r.slice();c.pop();let l=1;for(let d=o;d<n;++d)l*=i[d],c.push(i[d]);const u=[...JU(e.shape).map((e=>e/l)),1].slice(0,o);return[c,s,l,u]}const c2=1.7580993408473768,l2=1.0507009873554805,u2=.3275911,d2=.254829592,h2=-.284496736,p2=1.421413741,f2=-1.453152027,m2=1.061405429;function g2(e,t){if(e.length!==t.length)throw new Error("Cannot merge real and imag arrays of different lengths. real:"+"".concat(e.length,", imag: ").concat(t.length,"."));const n=new Float32Array(2*e.length);for(let a=0;a<n.length;a+=2)n[a]=e[a/2],n[a+1]=t[a/2];return n}function b2(e){const t=new Float32Array(e.length/2),n=new Float32Array(e.length/2);for(let a=0;a<e.length;a+=2)t[a/2]=e[a],n[a/2]=e[a+1];return{real:t,imag:n}}function y2(e){const t=Math.ceil(e.length/4),n=new Float32Array(t),a=new Float32Array(t);for(let r=0;r<e.length;r+=4)n[Math.floor(r/4)]=e[r],a[Math.floor(r/4)]=e[r+1];return{real:n,imag:a}}function x2(e){const t=Math.floor(e.length/4),n=new Float32Array(t),a=new Float32Array(t);for(let r=2;r<e.length;r+=4)n[Math.floor(r/4)]=e[r],a[Math.floor(r/4)]=e[r+1];return{real:n,imag:a}}function v2(e,t){return{real:e[2*t],imag:e[2*t+1]}}function w2(e,t,n,a){e[2*a]=t,e[2*a+1]=n}function k2(e,t){const n=new Float32Array(e/2),a=new Float32Array(e/2);for(let r=0;r<Math.ceil(e/2);r++){const o=(t?2:-2)*Math.PI*(r/e);n[r]=Math.cos(o),a[r]=Math.sin(o)}return{real:n,imag:a}}function I2(e,t,n){const a=(n?2:-2)*Math.PI*(e/t);return{real:Math.cos(a),imag:Math.sin(a)}}const S2="->",N2=/->/g,C2=",",T2="...";function E2(e,t){const n=((e=e.replace(/\s/g,"")).length-e.replace(N2,"").length)/S2.length;if(n<1)throw new Error("Equations without an arrow are not supported.");if(n>1)throw new Error('Equation must contain exactly one arrow ("'.concat(S2,'").'));const[a,r]=e.split(S2);AU(-1===a.indexOf(T2),(()=>'The ellipsis notation ("'.concat(T2,'") is not supported yet.')));const o=a.split(C2),s=o.length;if(t!==s)throw new Error("Expected ".concat(s," input tensors, received ").concat(t));if(s>2)throw new Error("Support for more than 2 input tensors is not implemented yet.");const i=[];for(let d=0;d<r.length;++d){const e=r[d];if(!o.some((t=>-1!==t.indexOf(e))))throw new Error("Output subscripts contain the label ".concat(e," ")+"not present in the input subscripts.");-1===i.indexOf(e)&&i.push(e)}for(let d=0;d<a.length;++d){const e=a[d];-1===i.indexOf(e)&&e!==C2&&i.push(e)}const c=new Array(o.length);for(let d=0;d<s;++d){if(new Set(o[d].split("")).size!==o[d].length)throw new Error("Found duplicate axes in input component ".concat(o[d],". ")+"Support for duplicate axes in input is not implemented yet.");c[d]=[];for(let e=0;e<o[d].length;++e)c[d].push(i.indexOf(o[d][e]))}const l=i.length,u=[];for(let d=r.length;d<l;++d)u.push(d);return{allDims:i,summedDims:u,idDims:c}}function R2(e,t){let n=new Array(e);n.fill(-1);for(let r=0;r<t.length;++r)n[t[r]]=r;const a=[];for(let r=0;r<e;++r)-1===n[r]&&a.push(r);return n=n.filter((e=>-1!==e)),{permutationIndices:n,expandDims:a}}function _2(e,t,n){const a=new Array(e);for(let r=0;r<n.length;++r){const e=n[r].shape;for(let n=0;n<t[r].length;++n)void 0===a[t[r][n]]?a[t[r][n]]=e[n]:AU(a[t[r][n]]===e[n],(()=>"Expected dimension ".concat(a[t[r][n]]," at axis ").concat(n," ")+"of input shaped ".concat(JSON.stringify(e),", ")+"but got dimension ".concat(e[n])))}}function A2(e,t){const n=e,a=[];let r=0;0===e.length&&n.push(-1),r=e.length+1;for(let s=0;s<r;++s)a.push([]);const o=[];for(let s=0;s<n.length;++s){const e=O2(t,n[s]);for(const t of e)-1===o.indexOf(t)&&(a[s].push(t),o.push(t))}return{path:n,steps:a}}function F2(e){return e.every(((e,t)=>e===t))}function O2(e,t){const n=[];for(let a=0;a<e.length;++a)0!==e[a].length&&-1===e[a].indexOf(t)&&-1!==t||n.push(a);return n}function D2(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,a=[];if("number"===typeof t)AU(e.shape[n]%t===0,(()=>"Number of splits must evenly divide the axis.")),a=new Array(t).fill(e.shape[n]/t);else{const r=t.reduce(((e,t)=>(-1===t&&(e+=1),e)),0);AU(r<=1,(()=>"There should be only one negative value in split array."));const o=t.indexOf(-1);if(-1!==o){const a=t.reduce(((e,t)=>t>0?e+t:e));t[o]=e.shape[n]-a}AU(e.shape[n]===t.reduce(((e,t)=>e+t)),(()=>"The sum of sizes must match the size of the axis dimension.")),a=t}return a}function M2(e){return"Received SparseTensor with denseShape[0] = 0 but\n  indices.shape[0] = ".concat(e)}function L2(e,t){return"indices(".concat(e,", 0) is invalid: ").concat(t," < 0")}function P2(e,t,n){return"indices(".concat(e,", 0) is invalid: ").concat(t," >= ").concat(n)}function z2(e,t){return"only one output dimension may be -1, not both ".concat(e," and ").concat(t)}function B2(e,t){return"size ".concat(e," must be non-negative, not ").concat(t)}function W2(){return"reshape cannot infer the missing input size for an empty tensor unless all specified input sizes are non-zero"}function V2(e,t){const n=DU(e),a=DU(t);return"Input to reshape is a SparseTensor with ".concat(n,"\n  dense values, but the requested shape requires a multiple of ").concat(a,". inputShape=").concat(e," outputShape= ").concat(t)}function U2(e,t){const n=DU(e),a=DU(t);return"Input to reshape is a tensor with ".concat(n," dense values, but the requested shape has ").concat(a,". inputShape=").concat(e," outputShape=").concat(t)}function G2(){return"segment ids must be >= 0"}function H2(){return"segment ids are not increasing"}function j2(e,t){return"Segment id ".concat(e," out of range [0, ").concat(t,"), possibly because segmentIds input is not sorted.")}function K2(e,t,n){return"Bad: indices[".concat(e,"] == ").concat(t," out of range [0, ").concat(n,")")}function q2(e,t){let n,a=!1;for(e<=$1?(n=e,a=!0):n=QU(e,Math.floor(Math.sqrt(e)));!a;)n>t||n===e?a=!0:n=QU(e,n+1);return n}function X2(e,t,n){const a=[],r=e.length;for(let o=0;o<r;o++)o!==t?a.push(e[o]):a.push(n);return a}function Y2(e,t,n,a){const r=t.shape.length,o=e.shape.length;if(0!==a&&(a<-r||a>r))throw new Error("Expect batchDims in the range of [-".concat(r,", ").concat(r,"], but got ").concat(a));if(a<0&&(a+=r),a>o)throw new Error("batchDims (".concat(a,") must be less than rank(x) (\n    ").concat(o,")."));if(n<a)throw new Error("batchDims (".concat(a,") must be less than or equal to axis (").concat(n,")."));for(let d=0;d<a;++d)if(e.shape[d]!==t.shape[d])throw new Error("x.shape[".concat(d,"]: ").concat(e.shape[d]," should be equal to indices.shape[").concat(d,"]: ").concat(t.shape[d],"."));const s=e.shape[n],i=[];let c=1,l=1,u=1;for(let d=0;d<a;++d)i.push(e.shape[d]),c*=e.shape[d];for(let d=a;d<n;d++)i.push(e.shape[d]),l*=e.shape[d];for(let d=a;d<r;d++)i.push(t.shape[d]);for(let d=n+1;d<o;d++)i.push(e.shape[d]),u*=e.shape[d];return{batchSize:c,sliceSize:u,outerSize:l,dimSize:s,outputShape:i}}function Q2(e){try{return e.map((e=>$K(e)))}catch(Yue){throw new Error("Failed to decode encoded string bytes into utf-8, error: ".concat(Yue))}}function J2(e){return e.map((e=>ZK(e)))}function Z2(e,t){Array.isArray(e)||(e=[e]),e.forEach((e=>{null!=e&&AU("complex64"!==e.dtype,(()=>"".concat(t," does not support complex64 tensors in the CPU backend.")))}))}!function(){for(const e of LY)NY(e)}();const $2=x0;class e3 extends CU{nextDataId(){return e3.nextDataId++}constructor(){super(),this.blockSize=48,this.firstUse=!0,this.data=new NU(this,tX())}write(e,t,n){this.firstUse&&(this.firstUse=!1,uG().get("IS_NODE")&&CK("\n============================\nHi, looks like you are running TensorFlow.js in Node.js. To speed things up dramatically, install our node backend, visit https://github.com/tensorflow/tfjs-node for more details. \n============================"));const a={id:this.nextDataId()};return this.data.set(a,{values:e,dtype:n,refCount:1}),a}makeTensorInfo(e,t,n){let a;if("string"===t&&null!=n&&n.length>0&&qU(n[0])){const r=n.map((e=>ZK(e)));a=this.write(r,e,t)}else a=this.write(n,e,t);return{dataId:a,shape:e,dtype:t}}refCount(e){if(this.data.has(e)){return this.data.get(e).refCount}return 0}incRef(e){this.data.get(e).refCount++}decRef(e){if(this.data.has(e)){this.data.get(e).refCount--}}move(e,t,n,a,r){this.data.set(e,{values:t,dtype:a,refCount:r})}numDataIds(){return this.data.numDataIds()}async read(e){return this.readSync(e)}readSync(e){const{dtype:t,complexTensorInfos:n}=this.data.get(e);if("complex64"===t){return g2(this.readSync(n.real.dataId),this.readSync(n.imag.dataId))}return function(e,t){if(Array.isArray(e))return e;if("float32"===t)return e instanceof Float32Array?e:new Float32Array(e);if("int32"===t)return e instanceof Int32Array?e:new Int32Array(e);if("bool"===t||"string"===t)return Uint8Array.from(new Int32Array(e));throw new Error("Unknown dtype ".concat(t))}(this.data.get(e).values,t)}bufferSync(e){const t=this.readSync(e.dataId);if("string"===e.dtype)try{const n=t.map((e=>$K(e)));return cY(e.shape,e.dtype,n)}catch(n){throw new Error("Failed to decode encoded string bytes into utf-8")}return cY(e.shape,e.dtype,t)}makeOutput(e,t,n){return tX().makeTensorFromTensorInfo(this.makeTensorInfo(t,n,e),this)}disposeData(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];if(this.data.has(e)){if(this.data.get(e).refCount--,!t&&this.data.get(e).refCount>0)return!1;const{complexTensorInfos:n}=this.data.get(e);null!=n&&(this.disposeData(n.real.dataId,!0),this.disposeData(n.imag.dataId,!0)),this.data.delete(e)}return!0}disposeIntermediateTensorInfo(e){this.disposeData(e.dataId)}async time(e){const t=JK();e();return{kernelMs:JK()-t}}memory(){return{unreliable:!0,reasons:["The reported memory is an upper bound. Due to automatic garbage collection, the true allocated memory may be less."]}}where(e){Z2([e],"where");const t=this.readSync(e.dataId);return $2(e.shape,t)}dispose(){}floatPrecision(){return 32}epsilon(){return super.epsilon()}}function t3(e){return(t,n,a)=>{const r=HU(n,t.length);for(let o=0;o<t.length;++o)r[o]=e(t[o],a);return r}}function n3(e,t,n){return a3(e,t3(t),n)}function a3(e,t,n){return a=>{let{inputs:r,attrs:o,backend:s}=a;const{x:i}=r;Z2(i,e);const c=s,l=c.data.get(i.dataId).values;let u;if("string"===i.dtype){if(!Array.isArray(l))throw new Error("String tensor's value was not an instance of Array");u=Q2(l)}else u=l;const d=n||i.dtype,h=t(u,d,o);return c.makeTensorInfo(i.shape,d,h)}}e3.nextDataId=0,oX("cpu",(()=>new e3),1);const r3=n3(pH,(e=>e>=0?e:Math.exp(e)-1)),o3={kernelName:pH,backendName:"cpu",kernelFunc:r3};function s3(e){const{inputs:t,backend:n}=e,{x:a}=t;return n.incRef(a.dataId),{dataId:a.dataId,shape:a.shape,dtype:a.dtype}}const i3={kernelName:_H,backendName:"cpu",kernelFunc:s3};function c3(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{alpha:o}=a;Z2([r],"leakyRelu");const s=DU(r.shape),i=n.data.get(r.dataId).values,c=GU("float32",s);for(let l=0;l<i.length;l++)c[l]=i[l]<0?o*i[l]:i[l];return n.makeTensorInfo(r.shape,"float32",c)}const l3={kernelName:LH,backendName:"cpu",kernelFunc:c3};function u3(e){return(t,n,a,r,o)=>{const s=OY(t,n),i=s.length,c=JU(s),l=GU(o,DU(s)),u=t.length,d=n.length,h=JU(t),p=JU(n),f=AY(t,s),m=AY(n,s);if(f.length+m.length===0)for(let g=0;g<l.length;++g)l[g]=e(a[g%a.length],r[g%r.length]);else for(let g=0;g<l.length;++g){const t=oG(g,i,c),n=t.slice(-u);f.forEach((e=>n[e]=0));const o=rG(n,u,h),s=t.slice(-d);m.forEach((e=>s[e]=0));const b=rG(s,d,p);l[g]=e(a[o],r[b])}return[l,s]}}const d3=u3(((e,t)=>e<0?t*e:e));function h3(e){const{inputs:t,backend:n}=e,{x:a,alpha:r}=t;Z2([a,r],"prelu");const o=n.data.get(a.dataId).values,s=n.data.get(r.dataId).values,[i,c]=d3(a.shape,r.shape,o,s,"float32");return n.makeTensorInfo(c,"float32",i)}const p3={kernelName:bj,backendName:"cpu",kernelFunc:h3},f3=n3(Nj,(e=>Math.max(0,e))),m3={kernelName:Nj,backendName:"cpu",kernelFunc:f3},g3=n3(Aj,(e=>Math.min(Math.max(0,e),6))),b3={kernelName:Aj,backendName:"cpu",kernelFunc:g3},y3=t3((e=>1/(1+Math.exp(-e)))),x3=n3(Hj,(e=>1/(1+Math.exp(-e)))),v3={kernelName:Hj,backendName:"cpu",kernelFunc:x3};function w3(e,t,n,a,r){if("linear"===n)return s3({inputs:{x:t},backend:e});if("relu"===n)return f3({inputs:{x:t},backend:e});if("elu"===n)return r3({inputs:{x:t},backend:e});if("relu6"===n)return g3({inputs:{x:t},backend:e});if("prelu"===n)return h3({inputs:{x:t,alpha:a},backend:e});if("leakyrelu"===n)return c3({inputs:{x:t},backend:e,attrs:{alpha:r}});if("sigmoid"===n)return x3({inputs:{x:t},backend:e});throw new Error("Activation ".concat(n," has not been implemented for the CPU backend."))}function k3(e){const{inputs:t,backend:n}=e,{real:a,imag:r}=t,o=n.data.get(a.dataId).values,s=n.data.get(r.dataId).values,i=n.makeTensorInfo(a.shape,"complex64");return n.data.get(i.dataId).complexTensorInfos={real:n.makeTensorInfo(a.shape,"float32",o),imag:n.makeTensorInfo(r.shape,"float32",s)},i}const I3={kernelName:VG,backendName:"cpu",kernelFunc:k3};function S3(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"float32";if("complex64"===n){return k3({inputs:{real:S3(e,t,"float32"),imag:S3(e,t,"float32")},backend:e})}const a=tG(DU(t),n);return e.makeTensorInfo(t,n,a)}function N3(e){const{inputs:t,backend:n}=e,{input:a}=t,r=n.data.get(a.dataId).complexTensorInfos.real,o=n.data.get(r.dataId).values;return n.makeTensorInfo(r.shape,r.dtype,o)}const C3={kernelName:Ij,backendName:"cpu",kernelFunc:N3};function T3(e,t,n,a){if("int32"===a){return[t,"int32",Int32Array.from(e)]}if("bool"===a){const a=QK([0],n),[r,o]=u3(((e,t)=>e!==t?1:0))(t,[],e,a,"bool");return[o,"bool",r]}throw new Error("Error in Cast: failed to cast ".concat(n," to ").concat(a))}function E3(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{dtype:o}=a;if("complex64"===o){if("complex64"===r.dtype)return s3({inputs:{x:r},backend:n});const e=S3(n,r.shape,r.dtype),t=E3({inputs:{x:r},backend:n,attrs:{dtype:"float32"}}),a=k3({inputs:{real:t,imag:e},backend:n});return n.disposeIntermediateTensorInfo(e),n.disposeIntermediateTensorInfo(t),a}if("complex64"===r.dtype){const e=N3({inputs:{input:r},backend:n}),t=E3({inputs:{x:e},backend:n,attrs:{dtype:o}});return n.disposeIntermediateTensorInfo(e),t}if(!jU(r.dtype,o)){const e=s3({inputs:{x:r},backend:n});return{dataId:e.dataId,shape:e.shape,dtype:o}}const s=n.data.get(r.dataId).values,[i,c,l]=T3(s,r.shape,r.dtype,o);return n.makeTensorInfo(i,c,l)}const R3={kernelName:zG,backendName:"cpu",kernelFunc:E3};function _3(e,t,n,a){return null==n?n=>{let{inputs:r,backend:o}=n;const{a:s,b:i}=r,c=o;Z2([s,i],e);const l=c.data.get(s.dataId).values,u=c.data.get(i.dataId).values,d="string"===s.dtype?Q2(l):l,h="string"===s.dtype?Q2(u):u,p=a||s.dtype,[f,m]=t(s.shape,i.shape,d,h,p);return c.makeTensorInfo(m,p,f)}:e=>{let{inputs:r,backend:o}=e;const{a:s,b:i}=r,c=o;if("complex64"===s.dtype||"complex64"===i.dtype){const e=E3({inputs:{x:s},backend:c,attrs:{dtype:"complex64"}}),t=c.data.get(e.dataId),a=t.complexTensorInfos.real,r=t.complexTensorInfos.imag,o=c.data.get(a.dataId).values,l=c.data.get(r.dataId).values,u=E3({inputs:{x:i},backend:c,attrs:{dtype:"complex64"}}),d=c.data.get(u.dataId),h=d.complexTensorInfos.real,p=d.complexTensorInfos.imag,f=c.data.get(h.dataId).values,m=c.data.get(p.dataId).values,[g,b,y]=n(s.shape,i.shape,o,l,f,m),x=c.makeTensorInfo(y,"float32",g),v=c.makeTensorInfo(y,"float32",b),w=k3({inputs:{real:x,imag:v},backend:c});return c.disposeIntermediateTensorInfo(e),c.disposeIntermediateTensorInfo(u),c.disposeIntermediateTensorInfo(x),c.disposeIntermediateTensorInfo(v),w}{const e=c.data.get(s.dataId).values,n=c.data.get(i.dataId).values,r=a||s.dtype,[o,l]=t(s.shape,i.shape,e,n,r);return c.makeTensorInfo(l,r,o)}}}function A3(e){return(t,n,a,r,o,s)=>{const i=OY(t,n),c=DU(i),l=i.length,u=JU(i),d=GU("float32",c),h=GU("float32",c),p=AY(t,i),f=AY(n,i),m=g2(a,r),g=g2(o,s),b=t.length,y=JU(t),x=n.length,v=JU(n);if(p.length+f.length===0)for(let w=0;w<d.length;w++){const t=w%m.length,n=w%g.length,a=e(m[2*t],m[2*t+1],g[2*n],g[2*n+1]);d[w]=a.real,h[w]=a.imag}else for(let w=0;w<d.length;w++){const t=oG(w,l,u),n=t.slice(-b);p.forEach((e=>n[e]=0));const a=rG(n,b,y),r=t.slice(-x);f.forEach((e=>r[e]=0));const o=rG(r,x,v),s=e(m[2*a],m[2*a+1],g[2*o],g[2*o+1]);d[w]=s.real,h[w]=s.imag}return[d,h,i]}}const F3=u3(((e,t)=>e+t)),O3=A3(((e,t,n,a)=>({real:e+n,imag:t+a}))),D3=_3(yG,F3,O3),M3={kernelName:yG,backendName:"cpu",kernelFunc:D3};function L3(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{shape:o}=a,s=DU(r.shape),i=WU(o,s),c=DU(i);AU(s===c,(()=>"The new shape (".concat(i,") has ").concat(c," elements and the old ")+"shape (".concat(r.shape,") has ").concat(s," elements. The new shape and old ")+"shape must have the same number of elements.")),n.incRef(r.dataId);const l=n.data.get(r.dataId);if(null!=l.complexTensorInfos){const e=l.complexTensorInfos.real,t=l.complexTensorInfos.imag;e.shape=i,t.shape=i}return{dataId:r.dataId,shape:i,dtype:r.dtype}}const P3={kernelName:Cj,backendName:"cpu",kernelFunc:L3};function z3(e){const{inputs:t,backend:n,attrs:a}=e,{a:r,b:o}=t,{transposeA:s,transposeB:i}=a;Z2([r,o],"matMul");const c=r.shape.length,l=o.shape.length,u=s?r.shape[c-2]:r.shape[c-1],d=i?o.shape[l-1]:o.shape[l-2],h=s?r.shape[c-1]:r.shape[c-2],p=i?o.shape[l-2]:o.shape[l-1],f=r.shape.slice(0,-2),m=o.shape.slice(0,-2),g=DU(f),b=DU(m),y=OY(r.shape.slice(0,-2),o.shape.slice(0,-2)).concat([h,p]);AU(u===d,(()=>"Error in matMul: inner shapes (".concat(u,") and (")+"".concat(d,") of Tensors with shapes ").concat(r.shape," and ")+"".concat(o.shape," and transposeA=").concat(s)+" and transposeB=".concat(i," must match.")));const x=i?[b,p,d]:[b,d,p],v=L3({inputs:{x:r},backend:n,attrs:{shape:s?[g,u,h]:[g,h,u]}}),w=L3({inputs:{x:o},backend:n,attrs:{shape:x}}),k=s?v.shape[1]:v.shape[2],I=s?v.shape[2]:v.shape[1],S=i?w.shape[1]:w.shape[2],N=Math.max(g,b),C=n.data.get(v.dataId).values,T=n.data.get(w.dataId).values,E=JU(v.shape),R=JU(w.shape),[_,A,F]=s?[E[0],1,E[1]]:[E[0],E[1],1],[O,D,M]=i?[1,R[1],R[0]]:[R[1],1,R[0]],L=I*S,P=cY([N,I,S],v.dtype),z=P.values,B=n.blockSize;for(let W=0;W<N;W++){const e=W%g,t=W%b;for(let n=0;n<I;n+=B){const a=Math.min(n+B,I);for(let r=0;r<S;r+=B){const o=Math.min(r+B,S);for(let s=0;s<k;s+=B){const i=Math.min(s+B,k);for(let c=n;c<a;c++)for(let n=r;n<o;n++){let a=0;for(let r=s;r<i;r++){a+=C[e*_+c*A+r*F]*T[r*O+n*D+t*M]}z[W*L+(c*S+n)]+=a}}}}}return n.disposeIntermediateTensorInfo(v),n.disposeIntermediateTensorInfo(w),n.makeTensorInfo(y,P.dtype,P.values)}const B3={kernelName:OG,backendName:"cpu",kernelFunc:z3};const W3={kernelName:IK,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{a:r,b:o,bias:s,preluActivationWeights:i}=t,{transposeA:c,transposeB:l,activation:u,leakyreluAlpha:d}=a;let h,p,f;const m=[];h=z3({inputs:{a:r,b:o},attrs:{transposeA:c,transposeB:l},backend:n}),s&&(p=D3({inputs:{a:h,b:s},backend:n}),m.push(h),h=p),u&&(f=w3(n,h,u,i,d),m.push(h),h=f);for(const g of m)n.disposeIntermediateTensorInfo(g);return h}};function V3(e){const t=new Float32Array(e.length);for(let n=0;n<e.length;++n)t[n]=Math.abs(e[n]);return t}const U3={kernelName:mG,backendName:"cpu",kernelFunc:e=>{const{x:t}=e.inputs,n=e.backend;Z2(t,"abs");let a=new Float32Array(DU(t.shape));return a=V3(n.data.get(t.dataId).values),n.makeOutput(a,t.shape,t.dtype)}},G3=n3(gG,(e=>Math.acos(e))),H3={kernelName:gG,backendName:"cpu",kernelFunc:G3},j3=n3(bG,(e=>Math.acosh(e))),K3={kernelName:bG,backendName:"cpu",kernelFunc:j3};const q3={kernelName:xG,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,a=t;Z2(t,"addN");const r=a.map((e=>n.data.get(e.dataId).values)),o=cY(a[0].shape,a[0].dtype),s=o.values;for(let i=0;i<a.length;i++){const e=r[i];for(let t=0;t<s.length;t++)s[t]+=e[t]}return n.makeTensorInfo(o.shape,o.dtype,o.values)}};function X3(e,t,n,a,r){const o=t.length,s=DU(t),i=JU(t),c=JU(r),l=GU(n,DU(r));for(let u=0;u<s;++u){const t=oG(u,o,i),n=new Array(t.length);for(let e=0;e<n.length;e++)n[e]=t[a[e]];l[rG(n,o,c)]=e[u]}return l}function Y3(e){const{inputs:t,attrs:n,backend:a}=e,{x:r}=t,{perm:o}=n;Z2(r,"transpose");const s=r.shape.length,i=new Array(s);for(let l=0;l<i.length;l++)i[l]=r.shape[o[l]];const c=X3(a.data.get(r.dataId).values,r.shape,r.dtype,o,i);return{dataId:a.write(c,i,r.dtype),shape:i,dtype:r.dtype}}const Q3={kernelName:mK,backendName:"cpu",kernelFunc:Y3};const J3={kernelName:vG,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{axis:o,keepDims:s}=a;Z2(r,"all");const i=VU(o,r.shape);let c=i;const l=ZJ(c,r.shape.length);let u=r;null!=l&&(u=Y3({inputs:{x:r},backend:n,attrs:{perm:l}}),c=eZ(c.length,r.shape.length)),JJ("all",c,u.shape.length);const[d,h]=YJ(u.shape,c),p=DU(h),f=tG(DU(d),u.dtype),m=n.data.get(u.dataId).values;for(let b=0;b<f.length;++b){const e=b*p;let t=m[e];for(let n=0;n<p;++n){const a=m[e+n];t=t&&a}f[b]=t}null!=l&&n.disposeIntermediateTensorInfo(u);const g=n.makeTensorInfo(d,u.dtype,f);if(s){const e=L3({inputs:{x:g},backend:n,attrs:{shape:QJ(d,i)}});return n.disposeIntermediateTensorInfo(g),e}return g}};const Z3={kernelName:wG,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{axis:o,keepDims:s}=a;Z2(r,"any");const i=VU(o,r.shape);let c=i;const l=ZJ(c,r.shape.length);let u=r;null!=l&&(u=Y3({inputs:{x:r},backend:n,attrs:{perm:l}}),c=eZ(c.length,r.shape.length)),JJ("any",c,u.shape.length);const[d,h]=YJ(u.shape,c),p=DU(h),f=tG(DU(d),u.dtype),m=n.data.get(u.dataId).values;for(let b=0;b<f.length;++b){const e=b*p;let t=m[e];for(let n=0;n<p;++n){const a=m[e+n];t=t||a}f[b]=t}null!=l&&n.disposeIntermediateTensorInfo(u);const g=n.makeTensorInfo(d,u.dtype,f);if(s){const e=L3({inputs:{x:g},backend:n,attrs:{shape:QJ(d,i)}});return n.disposeIntermediateTensorInfo(g),e}return g}};const $3={kernelName:kG,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{axis:o}=a;Z2(r,"argMax");let s=VU(o,r.shape);const i=ZJ(s,r.shape.length);let c=r;const l=[];null!=i&&(c=Y3({inputs:{x:r},backend:n,attrs:{perm:i}}),l.push(c),s=eZ(s.length,c.shape.length)),s=[s[0]],JJ("argMax",s,c.shape.length);const[u,d]=YJ(c.shape,s),h=tG(DU(u),"int32"),p=DU(d),f=n.data.get(c.dataId).values;for(let m=0;m<h.length;++m){const e=m*p;let t=f[e],n=0;for(let a=0;a<p;++a){const r=f[e+a];r>t&&(t=r,n=a)}h[m]=n}return l.forEach((e=>n.disposeIntermediateTensorInfo(e))),n.makeTensorInfo(u,"int32",h)}};const e4={kernelName:IG,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{axis:o}=a;Z2(r,"argMin");let s=VU(o,r.shape);const i=ZJ(s,r.shape.length);let c=r;const l=[];null!=i&&(c=Y3({inputs:{x:r},backend:n,attrs:{perm:i}}),l.push(c),s=eZ(s.length,c.shape.length)),s=[s[0]],JJ("argMin",s,c.shape.length);const[u,d]=YJ(c.shape,s),h=tG(DU(u),"int32"),p=DU(d),f=n.data.get(c.dataId).values;for(let m=0;m<h.length;++m){const e=m*p;let t=f[e],n=0;for(let a=0;a<p;++a){const r=f[e+a];r<t&&(t=r,n=a)}h[m]=n}return l.forEach((e=>n.disposeIntermediateTensorInfo(e))),n.makeTensorInfo(u,"int32",h)}},t4=n3(SG,(e=>Math.asin(e))),n4={kernelName:SG,backendName:"cpu",kernelFunc:t4},a4=n3(NG,(e=>Math.asinh(e))),r4={kernelName:NG,backendName:"cpu",kernelFunc:a4},o4=n3(CG,(e=>Math.atan(e))),s4={kernelName:CG,backendName:"cpu",kernelFunc:o4},i4=u3(((e,t)=>Math.atan2(e,t))),c4=_3(EG,i4),l4={kernelName:EG,backendName:"cpu",kernelFunc:c4},u4=n3(TG,(e=>Math.atanh(e))),d4={kernelName:TG,backendName:"cpu",kernelFunc:u4};function h4(e,t,n,a,r,o){const s=r.strideHeight,i=r.strideWidth,c=r.dilationHeight,l=r.dilationWidth,u=r.effectiveFilterHeight,d=r.effectiveFilterWidth,h=r.padInfo.top,p=r.padInfo.left,f="max"===o?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,m=cY(r.outShape,n),g=m.values,b=r.outShape[1]*r.outShape[2]*r.outShape[3],y=r.outShape[2]*r.outShape[3],x=r.outShape[3];for(let v=0;v<r.batchSize;++v){const t=v*b,n=v*a[0];for(let m=0;m<r.inChannels;++m)for(let b=0;b<r.outHeight;++b){const v=b*s-h,w=Math.max(0,v),k=Math.min(r.inHeight,u+v),I=t+b*y;for(let t=0;t<r.outWidth;++t){const s=t*i-p,u=Math.max(0,s),h=Math.min(r.inWidth,d+s);let b=f,y=0,v=0;for(let t=w;t<k;t+=c){const r=n+t*a[1];for(let t=u;t<h;t+=l){const n=e[r+t*a[2]+m];"max"===o&&n>b?b=n:"avg"===o&&(y+=n,v++)}if(isNaN(b))break}g[I+t*x+m]="avg"===o?y/v:b}}}return m}function p4(e,t,n,a){let r=arguments.length>4&&void 0!==arguments[4]&&arguments[4],o=arguments.length>5&&void 0!==arguments[5]&&arguments[5];const s=cY(a.outShape,"int32"),i=a.strideHeight,c=a.strideWidth,l=a.dilationHeight,u=a.dilationWidth,d=a.effectiveFilterHeight,h=a.effectiveFilterWidth,p=a.padInfo.top,f=a.padInfo.left,m=cY(t,n,e);for(let g=0;g<a.batchSize;++g)for(let e=0;e<a.inChannels;++e)for(let t=0;t<a.outHeight;++t){const n=t*i-p;let b=n;for(;b<0;)b+=l;const y=Math.min(a.inHeight,d+n);for(let i=0;i<a.outWidth;++i){const d=i*c-f;let p=d;for(;p<0;)p+=u;const x=Math.min(a.inWidth,h+d);let v=Number.NEGATIVE_INFINITY,w=-1;for(let t=b;t<y;t+=l){const s=t-n;for(let n=p;n<x;n+=u){const i=n-d,c=m.get(g,t,n,e);c>v&&(v=c,w=r?o?((g*a.inHeight+t)*a.inWidth+n)*a.inChannels+e:(t*a.inWidth+n)*a.inChannels+e:s*h+i)}}s.set(w,g,t,i,e)}}return s}function f4(e,t,n,a,r,o){const s=r.strideDepth,i=r.strideHeight,c=r.strideWidth,l=r.dilationDepth,u=r.dilationHeight,d=r.dilationWidth,h=r.effectiveFilterDepth,p=r.effectiveFilterHeight,f=r.effectiveFilterWidth,m=r.padInfo.front,g=r.padInfo.top,b=r.padInfo.left,y="max"===o?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,x=cY(r.outShape,n),v=x.values,w=r.outShape[1]*r.outShape[2]*r.outShape[3]*r.outShape[4],k=r.outShape[2]*r.outShape[3]*r.outShape[4],I=r.outShape[3]*r.outShape[4],S=r.outShape[4];for(let N=0;N<r.batchSize;++N){const t=N*w,n=N*a[0];for(let x=0;x<r.inChannels;++x)for(let w=0;w<r.outDepth;++w){const N=w*s-m;let C=N;for(;C<0;)C+=l;const T=Math.min(r.inDepth,h+N),E=t+w*k;for(let t=0;t<r.outHeight;++t){const s=t*i-g;let h=s;for(;h<0;)h+=u;const m=Math.min(r.inHeight,p+s),w=E+t*I;for(let t=0;t<r.outWidth;++t){const s=t*c-b;let i=s;for(;i<0;)i+=d;const p=Math.min(r.inWidth,f+s),g=w+t*S;let k=y,I=0,N=0;for(let t=C;t<T;t+=l){const r=n+t*a[1];for(let t=h;t<m;t+=u){const n=r+t*a[2];for(let t=i;t<p;t+=d){const r=e[n+t*a[3]+x];if("max"===o&&r>k?k=r:"avg"===o&&(I+=r,N++),isNaN(k))break}if(isNaN(k))break}if(isNaN(k))break}v[g+x]="avg"===o?I/Math.max(N,1):k}}}}return x}const m4={kernelName:RG,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t;Z2(r,"avgPool");const{filterSize:o,strides:s,pad:i,dimRoundingMode:c}=a;AU(YQ(s,1),(()=>"Error in avgPool: Either strides or dilations must be 1. "+"Got strides ".concat(s," and dilations '").concat(1,"'")));const l=BQ(r.shape,o,s,1,i,c);let u;if(1===l.filterWidth&&1===l.filterHeight&&MU(l.inShape,l.outShape))u=s3({inputs:{x:r},backend:n});else{const e=n.data.get(r.dataId).values,t=JU(r.shape),a=h4(e,r.shape,r.dtype,t,l,"avg");u=n.makeTensorInfo(l.outShape,r.dtype,a.values)}return u}};const g4={kernelName:AG,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{filterSize:o,strides:s,pad:i,dimRoundingMode:c,dataFormat:l}=a;Z2(r,"avgPool3d");const u=WQ(r.shape,o,s,1,i,c,l),d=f4(n.data.get(r.dataId).values,r.shape,r.dtype,JU(r.shape),u,"avg");return n.makeTensorInfo(d.shape,"float32",d.values)}};const b4={kernelName:FG,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{dy:r,input:o}=t,{filterSize:s,strides:i,pad:c,dimRoundingMode:l}=a;Z2([r,o],"avgPool3DGrad");const u=WQ(o.shape,s,i,1,c,l),d=u.strideDepth,h=u.strideHeight,p=u.strideWidth,f=u.filterDepth,m=u.filterHeight,g=u.filterWidth,b=u.dilationDepth,y=u.dilationHeight,x=u.dilationWidth,v=u.effectiveFilterDepth,w=u.effectiveFilterHeight,k=u.effectiveFilterWidth,I=v-1-u.padInfo.front,S=k-1-u.padInfo.left,N=w-1-u.padInfo.top,C=cY(o.shape,"float32"),T=1/(f*m*g),E=n.bufferSync(r);for(let R=0;R<u.batchSize;++R)for(let e=0;e<u.inChannels;++e)for(let t=0;t<u.inDepth;++t)for(let n=0;n<u.inHeight;++n)for(let a=0;a<u.inWidth;++a){const r=t-I,o=n-N,s=a-S;let i=0;for(let t=0;t<v;t+=b){const n=(r+t)/d;if(!(n<0||n>=u.outDepth||Math.floor(n)!==n))for(let t=0;t<w;t+=y){const a=(o+t)/h;if(!(a<0||a>=u.outHeight||Math.floor(a)!==a))for(let t=0;t<k;t+=x){const r=(s+t)/p;if(r<0||r>=u.outWidth||Math.floor(r)!==r)continue;i+=E.get(R,n,a,r,e)}}}C.set(i*T,R,t,n,a,e)}return n.makeTensorInfo(C.shape,C.dtype,C.values)}};const y4={kernelName:_G,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{dy:r,input:o}=t,s=o;Z2([r,o],"avgPoolGrad");const{filterSize:i,strides:c,pad:l}=a,u=BQ(s.shape,i,c,1,l),d=u.strideHeight,h=u.strideWidth,p=u.filterHeight,f=u.filterWidth,m=u.dilationHeight,g=u.dilationWidth,b=u.effectiveFilterHeight,y=u.effectiveFilterWidth,x=y-1-u.padInfo.left,v=b-1-u.padInfo.top,w=cY(s.shape,"float32"),k=1/(p*f),I=n.data.get(r.dataId).values,S=cY(r.shape,"float32",I);for(let N=0;N<u.batchSize;++N)for(let e=0;e<u.inChannels;++e)for(let t=0;t<u.inHeight;++t)for(let n=0;n<u.inWidth;++n){const a=t-v,r=n-x;let o=0;for(let t=0;t<b;t+=m){const n=(a+t)/d;if(!(n<0||n>=u.outHeight||Math.floor(n)!==n))for(let t=0;t<y;t+=g){const a=(r+t)/h;if(a<0||a>=u.outWidth||Math.floor(a)!==a)continue;o+=S.get(N,n,a,e)}}w.set(o*k,N,t,n,e)}return n.makeTensorInfo(w.shape,w.dtype,w.values)}};const x4={kernelName:NH,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r,scale:o,offset:s,mean:i,variance:c}=t;AU(i.shape.length===c.shape.length,(()=>"Batch normalization gradient requires mean and variance to have equal ranks.")),AU(null==s||i.shape.length===s.shape.length,(()=>"Batch normalization gradient requires mean and offset to have equal ranks.")),AU(null==o||i.shape.length===o.shape.length,(()=>"Batch normalization gradient requires mean and scale to have equal ranks.")),Z2([r,i,c,o,s],"batchNorm");let{varianceEpsilon:l}=a;null==l&&(l=.001);const u=n.data.get(r.dataId).values,d=n.data.get(i.dataId).values,h=n.data.get(c.dataId).values,p=o?n.data.get(o.dataId).values:new Float32Array([1]),f=s?n.data.get(s.dataId).values:new Float32Array([0]),m=new Float32Array(u.length),g=f.length,b=p.length,y=h.length,x=d.length;let v=0,w=0,k=0,I=0;for(let S=0;S<u.length;++S)m[S]=f[v++]+(u[S]-d[w++])*p[k++]/Math.sqrt(h[I++]+l),v>=g&&(v=0),w>=x&&(w=0),k>=b&&(k=0),I>=y&&(I=0);return n.makeTensorInfo(r.shape,r.dtype,m)}};function v4(e,t,n,a,r){const o=wQ(a,t,n),s=DU(n),i=JU(a);if(o){const n=kQ(t,i);return"string"===r?e.slice(n,n+s):e.subarray(n,n+s)}const c=cY(a,r,"string"===r?Q2(e):e),l=cY(n,r);for(let u=0;u<l.size;++u){const e=l.indexToLoc(u),n=e.map(((e,n)=>e+t[n]));l.set(c.get(...n),...e)}return"string"===r?J2(l.values):l.values}function w4(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{begin:o,size:s}=a;Z2(r,"slice");const[i,c]=IQ(r,o,s);lQ(r,i,c);const l=v4(n.data.get(r.dataId).values,i,c,r.shape,r.dtype);return n.makeTensorInfo(c,r.dtype,l)}const k4={kernelName:Wj,backendName:"cpu",kernelFunc:w4};const I4={kernelName:DG,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{blockShape:o,crops:s}=a;Z2([r],"batchToSpaceND");const i=o.reduce(((e,t)=>e*t)),c=n2(r.shape,o,i),l=a2(c.length,o.length),u=r2(r.shape,o,i),d=o2(s,o.length),h=s2(u,s,o.length),p=L3({inputs:{x:r},backend:n,attrs:{shape:c}}),f=Y3({inputs:{x:p},backend:n,attrs:{perm:l}}),m=L3({inputs:{x:f},backend:n,attrs:{shape:u}}),g=w4({inputs:{x:m},backend:n,attrs:{begin:d,size:h}});return n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),g}};function S4(e,t,n,a,r){const o=DU(a),s=tG(r,n);for(let i=0;i<e.length;i++){const n=e[i];if(n<0)throw new Error("Input x must be non-negative!");n>=r||(s[n]+=o>0?t[i]:1)}return s}function N4(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const r=e.shape[0],o=e.shape[1],s=cY([r,n],t.dtype);for(let i=0;i<r;i++)for(let r=0;r<o;r++){const o=e.get(i,r);if(o<0)throw new Error("Input x must be non-negative!");o>=n||(a?s.set(1,i,o):t.size>0?s.set(s.get(i,o)+t.get(i,r),i,o):s.set(s.get(i,o)+1,i,o))}return s}const C4={kernelName:MG,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r,weights:o}=t,{size:s}=a,i=S4(n.data.get(r.dataId).values,n.data.get(o.dataId).values,o.dtype,o.shape,s);return n.makeTensorInfo([s],o.dtype,i)}},T4=u3(((e,t)=>e&t)),E4=_3(LG,T4),R4={kernelName:LG,backendName:"cpu",kernelFunc:E4};const _4={kernelName:PG,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{s0:a,s1:r}=t,o=n.data.get(a.dataId).values,s=n.data.get(r.dataId).values,i=OY(Array.from(o),Array.from(s));return n.makeTensorInfo([i.length],"int32",Int32Array.from(i))}},A4=t3((e=>Math.ceil(e))),F4=a3(BG,A4),O4={kernelName:BG,backendName:"cpu",kernelFunc:F4},D4=n3(WG,((e,t)=>{const n=t;return e>n.clipValueMax?n.clipValueMax:e<n.clipValueMin?n.clipValueMin:e})),M4={kernelName:WG,backendName:"cpu",kernelFunc:D4},L4={kernelName:UG,backendName:"cpu",kernelFunc:e=>{const{x:t}=e.inputs,n=e.backend,a=new Float32Array(DU(t.shape)),r=n.data.get(t.dataId),o=r.complexTensorInfos.real,s=r.complexTensorInfos.imag,i=n.data.get(o.dataId).values,c=n.data.get(s.dataId).values;for(let l=0;l<i.length;l++){const e=i[l],t=c[l];a[l]=Math.hypot(e,t)}return n.makeOutput(a,t.shape,"float32")}};function P4(e,t,n,a){const r=HU(n,DU(t));if(a&&"string"!==n){let t=0;e.forEach((e=>{const n=DU(e.shape);r.set(e.vals,t),t+=n}))}else{let a=0;e.forEach((e=>{const o="string"===n?Q2(e.vals):e.vals;let s=0;for(let n=0;n<e.shape[0];++n){const i=n*t[1]+a;for(let t=0;t<e.shape[1];++t)r[i+t]=o[s++]}a+=e.shape[1]}))}return r}function z4(e){const{inputs:t,backend:n}=e,{input:a}=t,r=n.data.get(a.dataId).complexTensorInfos.imag,o=n.data.get(r.dataId).values;return n.makeTensorInfo(r.shape,r.dtype,o)}const B4={kernelName:FH,backendName:"cpu",kernelFunc:z4};function W4(e){const{inputs:t,backend:n,attrs:a}=e,{axis:r}=a,o=VU(r,t[0].shape)[0],s=t.map((e=>e.shape));K1(s,o);let i=q1(t.map((e=>e.shape)),o);if(0===DU(i))return n.makeTensorInfo(i,t[0].dtype,[]);const c=t.filter((e=>DU(e.shape)>0));if(1===c.length)return s3({inputs:{x:c[0]},backend:n});if("complex64"===c[0].dtype){const e=c.map((e=>N3({inputs:{input:e},backend:n}))),t=c.map((e=>z4({inputs:{input:e},backend:n}))),a=W4({inputs:e,backend:n,attrs:{axis:o}}),r=W4({inputs:t,backend:n,attrs:{axis:o}}),s=k3({inputs:{real:a,imag:r},backend:n});return e.forEach((e=>n.disposeIntermediateTensorInfo(e))),t.forEach((e=>n.disposeIntermediateTensorInfo(e))),n.disposeIntermediateTensorInfo(a),n.disposeIntermediateTensorInfo(r),s}const l=c.map((e=>{const t=DU(e.shape.slice(o));return L3({inputs:{x:e},backend:n,attrs:{shape:[-1,t]}})})),u=l.map((e=>({vals:n.data.get(e.dataId).values,shape:e.shape})));i=q1(l.map((e=>e.shape)),1);const d=1===l[0].shape[0],h=P4(u,i,t[0].dtype,d),p=q1(c.map((e=>e.shape)),o),f=n.makeTensorInfo(p,t[0].dtype,h);return l.forEach((e=>n.disposeIntermediateTensorInfo(e))),f}const V4={kernelName:GG,backendName:"cpu",kernelFunc:W4};function U4(e){const{inputs:t,backend:n,attrs:a}=e,{x:r,filter:o}=t,{strides:s,pad:i,dataFormat:c,dilations:l,dimRoundingMode:u}=a;Z2([r,o],"conv2d");const d=JQ(c),h=VQ(r.shape,o.shape,s,l,i,u,!1,d),p=h.filterHeight,f=h.filterWidth,m=h.dilationHeight,g=h.dilationWidth,b=h.padInfo.left,y=h.padInfo.top,x="channelsLast"===h.dataFormat,v=new pq(h.outShape,r.dtype),w=JU(r.shape),k=JU(o.shape),I=w[0],S=x?w[1]:w[2],N=x?w[2]:1,C=x?1:w[1],T=v.strides[0],E=x?v.strides[1]:v.strides[2],R=x?v.strides[2]:1,_=x?1:v.strides[1],A=n.data.get(r.dataId).values,F=n.data.get(o.dataId).values,O=v.values;for(let D=0;D<h.batchSize;++D){const e=D*I,t=D*T;for(let n=0;n<h.outHeight;++n){const a=t+n*E,r=n*h.strideHeight-y;for(let t=0;t<p;++t){const n=r+t*m;if(n<0||n>=h.inHeight)continue;const o=t*k[0],s=e+n*S;for(let e=0;e<h.outWidth;++e){const t=a+e*R,n=e*h.strideWidth-b;for(let e=0;e<f;++e){const a=n+e*g;if(a<0||a>=h.inWidth)continue;const r=s+a*N;let i=o+e*k[1];for(let e=0;e<h.inChannels;++e){const n=A[r+e*C];for(let e=0;e<h.outChannels;++e)O[t+e*_]+=n*F[i+e];i+=h.outChannels}}}}}}return n.makeTensorInfo(v.shape,v.dtype,O)}const G4={kernelName:HG,backendName:"cpu",kernelFunc:U4};const H4={kernelName:jG,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r,dy:o}=t,{strides:s,pad:i,dataFormat:c,dimRoundingMode:l,filterShape:u}=a;Z2([r,o],"conv2dBackpropFilter");const d=JQ(c),h=VQ(r.shape,u,s,1,i,l,!1,d),{strideHeight:p,strideWidth:f,filterHeight:m,filterWidth:g}=h,b="channelsLast"===h.dataFormat,y=new pq(h.filterShape,"float32"),x=h.padInfo.left,v=h.padInfo.top,w=n.data.get(r.dataId).values,k=n.data.get(o.dataId).values,I=new pq(r.shape,r.dtype,w),S=new pq(o.shape,o.dtype,k);for(let N=0;N<m;++N){const e=Math.max(0,Math.ceil((v-N)/p)),t=Math.min(h.outHeight,(h.inHeight+v-N)/p);for(let n=0;n<g;++n){const a=Math.max(0,Math.ceil((x-n)/f)),r=Math.min(h.outWidth,(h.inWidth+x-n)/f);for(let o=0;o<h.inChannels;++o)for(let s=0;s<h.outChannels;++s){let i=0;for(let c=0;c<h.batchSize;++c)for(let l=e;l<t;++l){const e=N+l*p-v;for(let t=a;t<r;++t){const a=n+t*f-x;i+=b?I.get(c,e,a,o)*S.get(c,l,t,s):I.get(c,o,e,a)*S.get(c,s,l,t)}}y.set(i,N,n,o,s)}}}return n.makeTensorInfo(y.shape,y.dtype,y.values)}};const j4={kernelName:KG,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{dy:r,filter:o}=t,{inputShape:s,strides:i,pad:c,dataFormat:l,dimRoundingMode:u}=a;Z2([r,o],"conv2dBackpropInput");const d=JU(o.shape),h=JU(r.shape);let p=JQ(l);const f=VQ(s,o.shape,i,1,c,u,!1,p),m=new pq(f.inShape,"float32"),g=m.values,b=n.data.get(r.dataId).values,y=n.data.get(o.dataId).values,[x,v,w]=d,{batchSize:k,filterHeight:I,filterWidth:S,inChannels:N,inHeight:C,inWidth:T,outChannels:E,outHeight:R,outWidth:_,strideHeight:A,strideWidth:F}=f;p=f.dataFormat;const O=I-1-f.padInfo.top,D=S-1-f.padInfo.left,M="channelsLast"===p,L=m.strides[0],P=M?m.strides[1]:m.strides[2],z=M?m.strides[2]:1,B=M?1:m.strides[1],W=h[0],V=M?h[1]:h[2],U=M?h[2]:1,G=M?1:h[1];for(let H=0;H<k;++H)for(let e=0;e<N;++e)for(let t=0;t<C;++t){const n=t-O,a=Math.max(0,Math.ceil(n/A)),r=Math.min(R,(I+n)/A);for(let o=0;o<T;++o){const s=o-D,i=Math.max(0,Math.ceil(s/F)),c=Math.min(_,(S+s)/F);let l=0;for(let t=a;t<r;++t){const a=t*A-n;for(let n=i;n<c;++n){const r=W*H+V*t+U*n,o=x*(I-1-a)+v*(S-1-(n*F-s))+w*e;for(let e=0;e<E;++e){l+=b[r+G*e]*y[o+e]}}}g[L*H+P*t+z*o+B*e]=l}}return n.makeTensorInfo(m.shape,m.dtype,m.values)}};const K4={kernelName:qG,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r,filter:o}=t,{strides:s,pad:i,dilations:c}=a;Z2([r,o],"conv3d");const l=UQ(r.shape,o.shape,s,c,i),{filterDepth:u,filterHeight:d,filterWidth:h,dilationDepth:p,dilationHeight:f,dilationWidth:m,padInfo:g}=l,b=g.front,y=g.left,x=g.top,v=new pq(l.outShape,r.dtype),w=n.data.get(r.dataId).values,k=n.data.get(o.dataId).values,I=v.values,S=JU(r.shape),N=JU(o.shape);for(let C=0;C<l.batchSize;++C){const e=C*S[0],t=C*v.strides[0];for(let n=0;n<l.outDepth;++n){const a=t+n*v.strides[1],r=n*l.strideDepth-b;for(let t=0;t<u;++t){const n=r+t*p;if(n<0||n>=l.inDepth)continue;const o=t*N[0],s=e+n*S[1];for(let e=0;e<l.outHeight;++e){const t=a+e*v.strides[2],n=e*l.strideHeight-x;for(let e=0;e<d;++e){const a=n+e*f;if(a<0||a>=l.inHeight)continue;const r=o+e*N[1],i=s+a*S[2];for(let e=0;e<l.outWidth;++e){const n=t+e*l.outChannels,a=e*l.strideWidth-y;for(let e=0;e<h;++e){const t=a+e*m;if(t<0||t>=l.inWidth)continue;const o=r+e*N[2],s=i+t*l.inChannels;let c=o;for(let e=0;e<l.inChannels;++e){const t=w[s+e];for(let e=0;e<l.outChannels;++e)I[n+e]+=t*k[c+e];c+=l.outChannels}}}}}}}}return n.makeTensorInfo(v.shape,v.dtype,v.values)}};const q4={kernelName:XG,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r,dy:o}=t,{strides:s,pad:i,filterShape:c}=a;Z2([r,o],"conv3dBackpropFilterV2");const l=JU(r.shape),u=JU(o.shape),d=UQ(r.shape,c,s,1,i),h=d.strideDepth,p=d.strideHeight,f=d.strideWidth,m=d.filterDepth,g=d.filterHeight,b=d.filterWidth,y=new pq(d.filterShape,"float32"),x=y.values,[v,w,k,I]=y.strides,S=n.data.get(o.dataId).values,[N,C,T,E]=u,R=n.data.get(r.dataId).values,[_,A,F,O]=l,D=d.padInfo.front,M=d.padInfo.left,L=d.padInfo.top;for(let P=0;P<m;++P){const e=Math.max(0,Math.ceil((D-P)/h)),t=Math.min(d.outDepth,(d.inDepth+D-P)/h),n=P*v;for(let a=0;a<g;++a){const r=Math.max(0,Math.ceil((L-a)/p)),o=Math.min(d.outHeight,(d.inHeight+L-a)/p),s=a*w+n;for(let n=0;n<b;++n){const i=Math.max(0,Math.ceil((M-n)/f)),c=Math.min(d.outWidth,(d.inWidth+M-n)/f),l=n*k+s;for(let s=0;s<d.inChannels;++s){const u=s*I+l;for(let l=0;l<d.outChannels;++l){let m=0;for(let u=0;u<d.batchSize;++u){const d=u*_,g=u*N;for(let u=e;u<t;++u){const e=(P+u*h-D)*A+d,t=u*C+g;for(let u=r;u<o;++u){const r=(a+u*p-L)*F+e,o=u*T+t;for(let e=i;e<c;++e){const t=e*E+o;m+=R[(n+e*f-M)*O+r+s]*S[t+l]}}}}x[u+l]=m}}}}}return n.makeTensorInfo(y.shape,y.dtype,y.values)}};const X4={kernelName:YG,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{dy:r,filter:o}=t,{pad:s,strides:i,inputShape:c}=a;Z2([r],"conv3dBackpropInputV2");const l=JU(r.shape),u=JU(o.shape),d=UQ(c,o.shape,i,1,s),h=new pq(d.inShape,"float32"),p=h.values,[f,m,g,b]=h.strides,y=n.data.get(r.dataId).values,[x,v,w,k]=l,I=n.data.get(o.dataId).values,[S,N,C,T]=u,{batchSize:E,filterDepth:R,filterHeight:_,filterWidth:A,inChannels:F,inDepth:O,inHeight:D,inWidth:M,outChannels:L,outDepth:P,outHeight:z,outWidth:B,strideDepth:W,strideHeight:V,strideWidth:U}=d,G=R-1-d.padInfo.front,H=_-1-d.padInfo.top,j=A-1-d.padInfo.left;for(let K=0;K<E;++K)for(let e=0;e<F;++e)for(let t=0;t<O;++t){const n=t-G,a=Math.max(0,Math.ceil(n/W)),r=Math.min(P,(R+n)/W);for(let o=0;o<D;++o){const s=o-H,i=Math.max(0,Math.ceil(s/V)),c=Math.min(z,(_+s)/V);for(let l=0;l<M;++l){const u=l-j,d=Math.max(0,Math.ceil(u/U)),h=Math.min(B,(A+u)/U);let E=0;for(let t=a;t<r;++t){const a=t*W-n;for(let n=i;n<c;++n){const r=n*V-s;for(let o=d;o<h;++o){const s=x*K+v*t+w*n+k*o,i=S*(R-1-a)+N*(_-1-r)+C*(A-1-(o*U-u))+T*e;for(let e=0;e<L;++e){E+=y[s+e]*I[i+e]}}}}p[f*K+m*t+g*o+b*l+e]=E}}}return n.makeTensorInfo(h.shape,h.dtype,h.values)}},Y4=n3(QG,(e=>Math.cos(e))),Q4={kernelName:QG,backendName:"cpu",kernelFunc:Y4},J4=n3(JG,(e=>Math.cosh(e))),Z4={kernelName:JG,backendName:"cpu",kernelFunc:J4};const $4={kernelName:eH,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{image:r,boxes:o,boxInd:s}=t,{cropSize:i,method:c,extrapolationValue:l}=a,[u,d,h,p]=r.shape,f=o.shape[0],[m,g]=i,b=cY([f,m,g,p],"float32"),y=n.data.get(o.dataId).values,x=n.data.get(s.dataId).values,v=n.data.get(r.dataId).values,w=JU(r.shape),k=JU(b.shape);for(let I=0;I<f;I++){const e=4*I,t=y[e],n=y[e+1],a=y[e+2],r=y[e+3],o=x[I];if(o>=u)continue;const s=m>1?(a-t)*(d-1)/(m-1):0,i=g>1?(r-n)*(h-1)/(g-1):0;for(let u=0;u<m;u++){const e=m>1?t*(d-1)+u*s:.5*(t+a)*(d-1);if(e<0||e>d-1)for(let t=0;t<g;t++)for(let e=0;e<p;e++){const n=e+t*k[2]+u*k[1]+I*k[0];b.values[n]=l}else if("bilinear"===c){const t=Math.floor(e),a=Math.ceil(e),s=e-t;for(let e=0;e<g;e++){const c=g>1?n*(h-1)+e*i:.5*(n+r)*(h-1);if(c<0||c>h-1){for(let t=0;t<p;t++){const n=t+e*k[2]+u*k[1]+I*k[0];b.values[n]=l}continue}const d=Math.floor(c),f=Math.ceil(c),m=c-d;for(let n=0;n<p;n++){let r=n+d*w[2]+t*w[1]+o*w[0];const i=v[r];r=n+f*w[2]+t*w[1]+o*w[0];const c=v[r];r=n+d*w[2]+a*w[1]+o*w[0];const l=v[r];r=n+f*w[2]+a*w[1]+o*w[0];const h=i+(c-i)*m,p=l+(v[r]-l)*m;r=n+e*k[2]+u*k[1]+I*k[0],b.values[r]=h+(p-h)*s}}}else for(let t=0;t<g;++t){const a=g>1?n*(h-1)+t*i:.5*(n+r)*(h-1);if(a<0||a>h-1){for(let e=0;e<p;e++){const n=e+t*k[2]+u*k[1]+I*k[0];b.values[n]=l}continue}const s=Math.round(a),c=Math.round(e);for(let e=0;e<p;e++){const n=e+s*w[2]+c*w[1]+o*w[0],a=e+t*k[2]+u*k[1]+I*k[0];b.values[a]=v[n]}}}}return n.makeTensorInfo(b.shape,b.dtype,b.values)}};const e5={kernelName:ZG,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{axis:o,exclusive:s,reverse:i}=a;Z2(r,"cumprod");const c=ZJ([o],r.shape.length);let l=r;null!=c&&(l=Y3({inputs:{x:r},backend:n,attrs:{perm:c}}));const u=eZ(1,r.shape.length)[0];if(u!==l.shape.length-1)throw new Error("backend.cumprod in CPU expects an inner-most "+"axis=".concat(l.shape.length-1," but got axis=").concat(u));const d=Cq(l.dtype,"int32"),h=eG(DU(l.shape),d),p=n.data.get(l.dataId).values,f=l.shape[l.shape.length-1],m=i?(e,t)=>e+f-t-1:(e,t)=>e+t;for(let b=0;b<p.length;b+=f)for(let e=0;e<f;e++){const t=m(b,e);if(0===e)h[t]=s?1:p[t];else{const n=m(b,e-1);h[t]=s?p[n]*h[n]:p[t]*h[n]}}const g=n.makeTensorInfo(l.shape,d,h);if(null!=c){const e=Y3({inputs:{x:g},backend:n,attrs:{perm:$J(c)}});return n.disposeIntermediateTensorInfo(g),n.disposeIntermediateTensorInfo(l),e}return g}};const t5={kernelName:$G,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{axis:o,exclusive:s,reverse:i}=a;Z2(r,"cumsum");const c=ZJ([o],r.shape.length);let l=r;null!=c&&(l=Y3({inputs:{x:r},backend:n,attrs:{perm:c}}));const u=eZ(1,r.shape.length)[0];if(u!==l.shape.length-1)throw new Error("backend.cumsum in CPU expects an inner-most "+"axis=".concat(l.shape.length-1," but got axis=").concat(u));const d=Cq(l.dtype,"int32"),h=tG(DU(l.shape),d),p=n.data.get(l.dataId).values,f=l.shape[l.shape.length-1],m=i?(e,t)=>e+f-t-1:(e,t)=>e+t;for(let b=0;b<p.length;b+=f)for(let e=0;e<f;e++){const t=m(b,e);if(0===e)h[t]=s?0:p[t];else{const n=m(b,e-1);h[t]=s?p[n]+h[n]:p[t]+h[n]}}const g=n.makeTensorInfo(l.shape,d,h);if(null!=c){const e=Y3({inputs:{x:g},backend:n,attrs:{perm:$J(c)}});return n.disposeIntermediateTensorInfo(g),n.disposeIntermediateTensorInfo(l),e}return g}};const n5={kernelName:tH,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r,weights:o}=t,{size:s,binaryOutput:i}=a;if(1===r.shape.length){const e=S4(n.data.get(r.dataId).values,n.data.get(o.dataId).values,o.dtype,o.shape,s);return n.makeTensorInfo([s],o.dtype,e)}if(2===r.shape.length){const e=N4(n.bufferSync(r),n.bufferSync(o),s,i);return n.makeTensorInfo(e.shape,o.dtype,e.values)}throw new Error("Error in denseBincount: input must be at most rank 2, but got rank"+"".concat(r.shape.length,"."))}};const a5={kernelName:nH,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{blockSize:o,dataFormat:s}=a;AU("NHWC"===s,(()=>"Only NHWC dataFormat supported on CPU for depthToSpace. Got ".concat(s)));const i=r.shape[0],c=r.shape[1],l=r.shape[2],u=r.shape[3],d=c*o,h=l*o,p=u/(o*o),f=n.data.get(r.dataId).values,m=new Float32Array(i*d*h*p);let g=0;for(let b=0;b<i;++b)for(let e=0;e<d;++e){const t=Math.floor(e/o),n=e%o;for(let e=0;e<h;++e){const a=Math.floor(e/o),r=(n*o+e%o)*p;for(let e=0;e<p;++e){const n=e+r+u*(a+l*(t+c*b));m[g++]=f[n]}}}return n.makeTensorInfo([i,d,h,p],r.dtype,m)}};function r5(e){const{inputs:t,backend:n,attrs:a}=e,{x:r,filter:o}=t,{strides:s,pad:i,dilations:c,dimRoundingMode:l}=a;Z2([r,o],"depthwiseConv2DNative");const u=JU(r.shape),d=JU(o.shape);let h=c;null==h&&(h=[1,1]),AU(YQ(s,h),(()=>"Error in depthwiseConv2d: Either strides or dilations must be "+"1. Got strides ".concat(s," and dilations '").concat(h,"'")));const p=VQ(r.shape,o.shape,s,h,i,l,!0),{filterHeight:f,filterWidth:m,dilationHeight:g,dilationWidth:b,padInfo:y}=p,x=y.left,v=y.top,w=p.outChannels/p.inChannels,k=new pq(p.outShape,r.dtype),I=n.data.get(r.dataId).values,S=n.data.get(o.dataId).values,N=k.values;for(let C=0;C<p.batchSize;++C){const e=C*u[0],t=C*k.strides[0];for(let n=0;n<p.outHeight;++n){const a=t+n*k.strides[1],r=n*p.strideHeight-v;for(let t=0;t<f;++t){const n=r+t*g;if(n<0||n>=p.inHeight)continue;const o=t*d[0],s=e+n*u[1];for(let e=0;e<p.outWidth;++e){const t=a+e*k.strides[2],n=e*p.strideWidth-x;for(let e=0;e<m;++e){const a=n+e*b;if(a<0||a>=p.inWidth)continue;const r=o+e*d[1],i=s+a*p.inChannels;let c=t,l=r;for(let e=0;e<p.inChannels;++e){const t=I[i+e];for(let e=0;e<w;++e)N[c+e]+=t*S[l+e];c+=w,l+=w}}}}}}return n.makeTensorInfo(k.shape,k.dtype,k.values)}const o5={kernelName:aH,backendName:"cpu",kernelFunc:r5};const s5={kernelName:rH,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r,dy:o}=t,{strides:s,dilations:i,pad:c,dimRoundingMode:l,filterShape:u}=a;Z2([r,o],"depthwiseConv2dNativeBackpropFilter");const d=VQ(r.shape,u,s,i,c,l,!0),{strideHeight:h,strideWidth:p,filterHeight:f,filterWidth:m}=d,g=new pq(d.filterShape,"float32"),b=d.padInfo.left,y=d.padInfo.top,x=d.outChannels/d.inChannels,v=n.data.get(r.dataId).values,w=new pq(r.shape,r.dtype,v),k=n.data.get(o.dataId).values,I=new pq(o.shape,o.dtype,k);for(let S=0;S<f;++S){const e=Math.max(0,Math.ceil((y-S)/h)),t=Math.min(d.outHeight,(d.inHeight+y-S)/h);for(let n=0;n<m;++n){const a=Math.max(0,Math.ceil((b-n)/p)),r=Math.min(d.outWidth,(d.inWidth+b-n)/p);for(let o=0;o<d.outChannels;++o){const s=Math.trunc(o/x),i=o%x;let c=0;for(let l=0;l<d.batchSize;++l)for(let i=e;i<t;++i){const e=S+i*h-y;for(let t=a;t<r;++t){const a=n+t*p-b;c+=w.get(l,e,a,s)*I.get(l,i,t,o)}}g.set(c,S,n,s,i)}}}return n.makeTensorInfo(g.shape,g.dtype,g.values)}};const i5={kernelName:oH,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{dy:r,filter:o}=t,{strides:s,dilations:i,pad:c,dimRoundingMode:l,inputShape:u}=a;Z2([r,o],"depthwiseConv2DNativeBackpropInput");const d=JU(r.shape),h=JU(o.shape),p=VQ(u,o.shape,s,i,c,l,!0),f=new pq(p.inShape,"float32"),m=f.values,[g,b,y]=f.strides,x=n.data.get(r.dataId).values,[v,w,k]=d,I=n.data.get(o.dataId).values,[S,N,C]=h,{batchSize:T,filterHeight:E,filterWidth:R,inChannels:_,inHeight:A,inWidth:F,outChannels:O,outHeight:D,outWidth:M,strideHeight:L,strideWidth:P}=p,z=E-1-p.padInfo.top,B=R-1-p.padInfo.left,W=O/_;for(let V=0;V<T;++V)for(let e=0;e<_;++e)for(let t=0;t<A;++t){const n=t-z,a=Math.max(0,Math.ceil(n/L)),r=Math.min(D,(E+n)/L);for(let o=0;o<F;++o){const s=o-B,i=Math.max(0,Math.ceil(s/P)),c=Math.min(M,(R+s)/P);let l=0;for(let t=a;t<r;++t){const a=t*L-n;for(let n=i;n<c;++n){const r=v*V+w*t+k*n,o=S*(E-1-a)+N*(R-1-(n*P-s))+C*e;for(let t=0;t<W;++t){l+=x[r+(e*W+t)]*I[o+t]}}}m[g*V+b*t+y*o+e]=l}}return n.makeTensorInfo(f.shape,f.dtype,f.values)}};const c5={kernelName:sH,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{x:a}=t,r=DU(a.shape),o=n.data.get(a.dataId).values,s=cY([r,r],a.dtype),i=s.values;for(let l=0;l<o.length;l++)i[l*r+l]=o[l];const c=[...a.shape,...a.shape];return n.makeTensorInfo(c,s.dtype,s.values)}},l5={kernelName:iH,backendName:"cpu",kernelFunc:e=>{let{inputs:t,backend:n,attrs:a}=e;const{x:r,filter:o}=t,{strides:s,pad:i,dilations:c}=a,l=n,u=l.data.get(r.dataId).values,d=r.shape.length,h=l.data.get(o.dataId).values,p=o.shape.length,{batchSize:f,inHeight:m,inWidth:g,inChannels:b,outHeight:y,outWidth:x,padInfo:v,strideHeight:w,strideWidth:k,filterHeight:I,filterWidth:S,dilationHeight:N,dilationWidth:C,outShape:T}=zQ(r.shape,o.shape,s,i,"NHWC",c),E=DU(T),R=T.length,_=HU(r.dtype,E);for(let A=0;A<f;++A)for(let e=0;e<y;++e){const t=e*w-v.top;for(let n=0;n<x;++n){const a=n*k-v.left;for(let s=0;s<b;++s){let i=Number.MIN_SAFE_INTEGER;for(let e=0;e<I;++e){const n=t+e*N;if(n>=0&&n<m)for(let t=0;t<S;++t){const c=a+t*C;if(c>=0&&c<g){const a=rG([A,n,c,s],d,JU(r.shape)),l=rG([e,t,s],p,JU(o.shape)),f=u[a]+h[l];f>i&&(i=f)}}}_[rG([A,e,n,s],R,JU(T))]=i}}}return{dataId:l.write(QK(_,r.dtype),T,r.dtype),shape:T,dtype:r.dtype}}},u5={kernelName:lH,backendName:"cpu",kernelFunc:e=>{let{inputs:t,backend:n,attrs:a}=e;const{x:r,filter:o,dy:s}=t,{strides:i,pad:c,dilations:l}=a,u=n,d=$U(r.shape,u.data.get(r.dataId).values),h=$U(o.shape,u.data.get(o.dataId).values),{batchSize:p,inHeight:f,inWidth:m,inChannels:g,outHeight:b,outWidth:y,padInfo:x,strideHeight:v,strideWidth:w,filterHeight:k,filterWidth:I,dilationHeight:S,dilationWidth:N,outShape:C}=zQ(r.shape,o.shape,i,c,"NHWC",l);AU(s.rank===C.length,(()=>"Error in ".concat(lH,", dy ")+"must have the same rank as output ".concat(C.length,", but got ")+"".concat(s.rank)));const T=$U(C,u.data.get(s.dataId).values),E=nG(o.shape,o.dtype);for(let R=0;R<p;++R)for(let e=0;e<b;++e){const t=e*v-x.top;for(let n=0;n<y;++n){const a=n*w-x.left;for(let r=0;r<g;++r){let o=Number.MIN_SAFE_INTEGER,s=0,i=0;for(let e=0;e<k;++e){const n=t+e*S;if(n>=0&&n<f)for(let t=0;t<I;++t){const c=a+t*N;if(c>=0&&c<m){const a=d[R][n][c][r]+h[e][t][r];a>o&&(o=a,s=e,i=t)}}}E[s][i][r]+=T[R][e][n][r]}}}return{dataId:u.write(QK(E,r.dtype),o.shape,o.dtype),shape:o.shape,dtype:o.dtype}}},d5={kernelName:cH,backendName:"cpu",kernelFunc:e=>{let{inputs:t,backend:n,attrs:a}=e;const{x:r,filter:o,dy:s}=t,{strides:i,pad:c,dilations:l}=a,u=n,d=$U(r.shape,u.data.get(r.dataId).values),h=$U(o.shape,u.data.get(o.dataId).values),{batchSize:p,inHeight:f,inWidth:m,inChannels:g,outHeight:b,outWidth:y,padInfo:x,strideHeight:v,strideWidth:w,filterHeight:k,filterWidth:I,dilationHeight:S,dilationWidth:N,outShape:C}=zQ(r.shape,o.shape,i,c,"NHWC",l);AU(s.rank===C.length,(()=>"Error in ".concat(cH,", dy ")+"must have the same rank as output ".concat(C.length,", but got ")+"".concat(s.rank)));const T=$U(C,u.data.get(s.dataId).values),E=nG(r.shape,r.dtype);for(let R=0;R<p;++R)for(let e=0;e<b;++e){const t=e*v-x.top;for(let n=0;n<y;++n){const a=n*w-x.left;for(let r=0;r<g;++r){let o=Number.MIN_SAFE_INTEGER,s=t<0?0:t,i=a<0?0:a;for(let e=0;e<k;++e){const n=t+e*S;if(n>=0&&n<f)for(let t=0;t<I;++t){const c=a+t*N;if(c>=0&&c<m){const a=d[R][n][c][r]+h[e][t][r];a>o&&(o=a,s=n,i=c)}}}E[R][s][i][r]+=T[R][e][n][r]}}}return{dataId:u.write(QK(E,r.dtype),r.shape,r.dtype),shape:r.shape,dtype:r.dtype}}};const h5={kernelName:uH,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{image:r}=t,{canvas:o,options:s}=a,{contextOptions:i,imageOptions:c}=s||{},l=(null===c||void 0===c?void 0:c.alpha)||1,u=(null===i||void 0===i?void 0:i.contextType)||"2d";if("2d"!==u)throw new Error("Context type ".concat(i.contextType," is not supported by the CPU backend."));const d=o.getContext(u,(null===i||void 0===i?void 0:i.contextAttributes)||{});if(null==d)throw new Error("Could not get the context with ".concat(u," type."));const[h,p]=r.shape.slice(0,2),f=2===r.shape.length?1:r.shape[2],m=n.data.get(r.dataId).values,g="float32"===r.dtype?255:1,b=new Uint8ClampedArray(p*h*4);for(let x=0;x<h*p;++x){const e=[0,0,0,255*l];for(let n=0;n<f;n++){const t=m[x*f+n];if("float32"===r.dtype){if(t<0||t>1)throw new Error("Tensor values for a float32 Tensor must be in the "+"range [0 - 1] but encountered ".concat(t,"."))}else if("int32"===r.dtype&&(t<0||t>255))throw new Error("Tensor values for a int32 Tensor must be in the "+"range [0 - 255] but encountered ".concat(t,"."));1===f?(e[0]=t*g,e[1]=t*g,e[2]=t*g):e[n]=t*g}const t=4*x;b[t+0]=Math.round(e[0]),b[t+1]=Math.round(e[1]),b[t+2]=Math.round(e[2]),b[t+3]=Math.round(e[3])}o.width=p,o.height=h;const y=new ImageData(b,p,h);return d.putImageData(y,0,0),r}},p5=u3(((e,t)=>e*t)),f5=A3(((e,t,n,a)=>({real:e*n-t*a,imag:e*a+t*n}))),m5=_3(sj,p5,f5),g5={kernelName:sj,backendName:"cpu",kernelFunc:m5};function b5(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{axis:o,keepDims:s}=a;let i;Z2(r,"sum"),i="bool"===r.dtype?E3({inputs:{x:r},backend:n,attrs:{dtype:"int32"}}):s3({inputs:{x:r},backend:n});const c=i.shape.length,l=VU(o,i.shape),u=ZJ(l,c);let d=l,h=i;null!=u&&(h=Y3({inputs:{x:i},backend:n,attrs:{perm:u}}),d=eZ(d.length,c)),JJ("sum",d,h.shape.length);const[p,f]=YJ(h.shape,d);let m=S3(n,p,Cq(h.dtype,"int32"));const g=DU(f),b=n.data.get(m.dataId).values,y=n.data.get(h.dataId).values;for(let x=0;x<b.length;++x){const e=x*g;let t=0;for(let n=0;n<g;++n)t+=y[e+n];b[x]=t}if(s){const e=m;m=L3({inputs:{x:m},backend:n,attrs:{shape:QJ(m.shape,l)}}),n.disposeIntermediateTensorInfo(e)}return n.disposeIntermediateTensorInfo(i),null!=u&&n.disposeIntermediateTensorInfo(h),m}const y5={kernelName:qj,backendName:"cpu",kernelFunc:b5};const x5={kernelName:hH,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{equation:r}=a,o=t,{allDims:s,summedDims:i,idDims:c}=E2(r,o.length);_2(s.length,c,o);const{path:l,steps:u}=A2(i,c),d=u.length;let h=null,p=s.length;const f=[];for(let m=0;m<d;++m){for(const e of u[m]){const{permutationIndices:t,expandDims:a}=R2(p,c[e]);let r;F2(t)?r=o[e]:(r=Y3({inputs:{x:o[e]},backend:n,attrs:{perm:t}}),f.push(r));const s=r.shape.slice();for(let e=0;e<a.length;++e)s.splice(a[e],0,1);MU(r.shape,s)||(r=L3({inputs:{x:r},backend:n,attrs:{shape:s}}),f.push(r)),null===h?h=r:(h=m5({inputs:{a:r,b:h},backend:n}),f.push(h))}m<d-1&&(l[m]>=0&&(h=b5({inputs:{x:h},backend:n,attrs:{axis:l[m]-(s.length-p),keepDims:!1}}),f.push(h)),p--)}for(const m of f)m!==h&&n.disposeIntermediateTensorInfo(m);return h}};const v5={kernelName:fH,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{dy:a,y:r}=t;Z2([a,r],"eluGrad");const o=new Float32Array(DU(r.shape)),s=n.data.get(r.dataId).values,i=n.data.get(a.dataId).values;for(let c=0;c<s.length;++c){const e=s[c];o[c]=e>=0?i[c]:i[c]*(e+1)}return n.makeTensorInfo(r.shape,"float32",o)}},w5=u3(((e,t)=>e===t?1:0)),k5=_3(gH,w5,null,"bool"),I5={kernelName:gH,backendName:"cpu",kernelFunc:k5},S5=u2,N5=d2,C5=h2,T5=p2,E5=f2,R5=m2,_5=n3(mH,(e=>{const t=Math.sign(e),n=Math.abs(e),a=1/(1+S5*n);return t*(1-((((R5*a+E5)*a+T5)*a+C5)*a+N5)*a*Math.exp(-n*n))})),A5={kernelName:mH,backendName:"cpu",kernelFunc:_5},F5=t3((e=>Math.exp(e))),O5=a3(bH,F5,"float32"),D5={kernelName:bH,backendName:"cpu",kernelFunc:O5};function M5(e){const{inputs:t,backend:n,attrs:a}=e,{input:r}=t,{dim:o}=a,s=r.shape.length,i=r.shape.slice();let c=o;return o<0&&(AU(-(s+1)<=o,(()=>"Axis must be in the interval [".concat(-(s+1),", ").concat(s,"]"))),c=s+o+1),i.splice(c,0,1),L3({inputs:{x:r},backend:n,attrs:{shape:i}})}const L5={kernelName:yH,backendName:"cpu",kernelFunc:M5},P5=t3((e=>Math.expm1(e))),z5=a3(xH,P5),B5={kernelName:xH,backendName:"cpu",kernelFunc:z5},W5=u3(((e,t)=>e/t)),V5=_3(dH,W5),U5={kernelName:dH,backendName:"cpu",kernelFunc:V5},G5=u3(((e,t)=>e-t)),H5=A3(((e,t,n,a)=>({real:e-n,imag:t-a}))),j5=_3(lK,G5,H5),K5={kernelName:lK,backendName:"cpu",kernelFunc:j5};function q5(e,t,n){const a=e.shape,r=a[0],o=a[1],s=n.data.get(e.dataId),i=s.complexTensorInfos.real,c=s.complexTensorInfos.imag,l=[r,o],u=DU(l),d=GU("float32",u),h=GU("float32",u);for(let g=0;g<r;g++){const e=w4({inputs:{x:i},backend:n,attrs:{begin:[g,0],size:[1,o]}}),a=w4({inputs:{x:c},backend:n,attrs:{begin:[g,0],size:[1,o]}}),r=k3({inputs:{real:e,imag:a},backend:n}),{real:s,imag:l}=X5(r,t,n),u=g2(s,l);for(let t=0;t<o;t++){const e=v2(u,t);d[g*o+t]=e.real,h[g*o+t]=e.imag}n.disposeIntermediateTensorInfo(e),n.disposeIntermediateTensorInfo(a),n.disposeIntermediateTensorInfo(r)}const p=n.makeTensorInfo(l,"float32",d),f=n.makeTensorInfo(l,"float32",h),m=k3({inputs:{real:p,imag:f},backend:n});return n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(f),m}function X5(e,t,n){const a=DU(e.shape),r=n.data.get(e.dataId),o=n.data.get(r.complexTensorInfos.real.dataId).values,s=n.data.get(r.complexTensorInfos.imag.dataId).values;if(0===((i=a)&i-1)){const r=Y5(o,s,a,t,n),i=[e.shape[0],e.shape[1]];if(t){const e=n.makeTensorInfo(i,"float32",r.real),t=n.makeTensorInfo(i,"float32",r.imag),o=n.makeTensorInfo([],"float32",YK(a,"float32")),s=s3({inputs:{x:o},backend:n}),c=U5.kernelFunc({inputs:{a:e,b:o},backend:n}),l=U5.kernelFunc({inputs:{a:t,b:s},backend:n}),u=n.data.get(c.dataId).values,d=n.data.get(l.dataId).values;return n.disposeIntermediateTensorInfo(e),n.disposeIntermediateTensorInfo(t),n.disposeIntermediateTensorInfo(o),n.disposeIntermediateTensorInfo(s),n.disposeIntermediateTensorInfo(c),n.disposeIntermediateTensorInfo(l),{real:u,imag:d}}return r}{const e=function(e,t,n){const a=new Float32Array(2*t);for(let r=0;r<t;r++){let o=0,s=0;for(let a=0;a<t;a++){const i=I2(r*a,t,n),c=v2(e,a);o+=c.real*i.real-c.imag*i.imag,s+=c.real*i.imag+c.imag*i.real}n&&(o/=t,s/=t),w2(a,o,s,r)}return a}(g2(o,s),a,t);return b2(e)}var i}function Y5(e,t,n,a,r){if(1===n)return{real:e,imag:t};const o=g2(e,t),s=n/2,i=y2(o),c=i.real,l=i.imag,u=[c.length],d=r.makeTensorInfo(u,"float32",c),h=r.makeTensorInfo(u,"float32",l),p=k3({inputs:{real:d,imag:h},backend:r}),f=x2(o),m=f.real,g=f.imag,b=[m.length],y=r.makeTensorInfo(b,"float32",m),x=r.makeTensorInfo(b,"float32",g),v=k3({inputs:{real:y,imag:x},backend:r}),w=Y5(c,l,s,a,r),k=w.real,I=w.imag,S=[k.length],N=r.makeTensorInfo(S,"float32",k),C=r.makeTensorInfo(S,"float32",I),T=k3({inputs:{real:N,imag:C},backend:r}),E=Y5(m,g,s,a,r),R=E.real,_=E.imag,A=[R.length],F=r.makeTensorInfo(A,"float32",R),O=r.makeTensorInfo(A,"float32",_),D=k3({inputs:{real:F,imag:O},backend:r}),M=k2(n,a),L=[M.real.length],P=r.makeTensorInfo(L,"float32",M.real),z=r.makeTensorInfo(L,"float32",M.imag),B=k3({inputs:{real:P,imag:z},backend:r}),W=m5({inputs:{a:B,b:D},backend:r}),V=D3({inputs:{a:T,b:W},backend:r}),U=j5({inputs:{a:T,b:W},backend:r}),G=N3({inputs:{input:V},backend:r}),H=N3({inputs:{input:U},backend:r}),j=z4({inputs:{input:V},backend:r}),K=z4({inputs:{input:U},backend:r}),q=W4({inputs:[G,H],backend:r,attrs:{axis:0}}),X=W4({inputs:[j,K],backend:r,attrs:{axis:0}}),Y=r.data.get(q.dataId).values,Q=r.data.get(X.dataId).values;return r.disposeIntermediateTensorInfo(d),r.disposeIntermediateTensorInfo(h),r.disposeIntermediateTensorInfo(p),r.disposeIntermediateTensorInfo(y),r.disposeIntermediateTensorInfo(x),r.disposeIntermediateTensorInfo(v),r.disposeIntermediateTensorInfo(N),r.disposeIntermediateTensorInfo(C),r.disposeIntermediateTensorInfo(T),r.disposeIntermediateTensorInfo(F),r.disposeIntermediateTensorInfo(O),r.disposeIntermediateTensorInfo(D),r.disposeIntermediateTensorInfo(P),r.disposeIntermediateTensorInfo(z),r.disposeIntermediateTensorInfo(B),r.disposeIntermediateTensorInfo(W),r.disposeIntermediateTensorInfo(V),r.disposeIntermediateTensorInfo(U),r.disposeIntermediateTensorInfo(G),r.disposeIntermediateTensorInfo(j),r.disposeIntermediateTensorInfo(H),r.disposeIntermediateTensorInfo(K),r.disposeIntermediateTensorInfo(q),r.disposeIntermediateTensorInfo(X),{real:Y,imag:Q}}const Q5={kernelName:vH,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{input:a}=t,r=DU(a.shape),o=a.shape[a.shape.length-1],s=L3({inputs:{x:a},backend:n,attrs:{shape:[r/o,o]}}),i=q5(s,!1,n),c=L3({inputs:{x:i},backend:n,attrs:{shape:a.shape}});return n.disposeIntermediateTensorInfo(s),n.disposeIntermediateTensorInfo(i),c}};function J5(e){const{backend:t,attrs:n}=e,{shape:a,value:r,dtype:o}=n,s=o||XU(r),i=HU(s,DU(a));return function(e,t,n){e.fill(t)}(i,r),t.makeTensorInfo(a,s,i)}const Z5={kernelName:wH,backendName:"cpu",kernelFunc:J5};const $5={kernelName:kH,backendName:"cpu",kernelFunc:e=>{let{inputs:t,attrs:n,backend:a}=e;const{image:r}=t,o=a,s=GU(r.dtype,DU(r.shape)),[i,c,l,u]=r.shape,d=o.data.get(r.dataId).values;for(let h=0;h<i;h++){const e=h*l*c*u;for(let t=0;t<c;t++){const n=t*(l*u);for(let t=0;t<l;t++){const a=t*u;for(let r=0;r<u;r++){const o=Math.round(l-t-1),i=e+n+a+r;let c=d[i];if(o>=0&&o<l){c=d[e+n+o*u+r]}s[i]=c}}}}return{dataId:o.write(s,r.shape,r.dtype),shape:r.shape,dtype:r.dtype}}},e6=t3((e=>Math.floor(e))),t6=a3(IH,e6),n6={kernelName:IH,backendName:"cpu",kernelFunc:t6},a6=u3(((e,t)=>Math.floor(e/t))),r6=_3(SH,a6,null,"int32"),o6={kernelName:SH,backendName:"cpu",kernelFunc:r6};const s6={kernelName:SK,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r,filter:o,bias:s,preluActivationWeights:i}=t,{strides:c,pad:l,dataFormat:u,dilations:d,dimRoundingMode:h,activation:p,leakyreluAlpha:f}=a;let m=U4({inputs:{x:r,filter:o},backend:n,attrs:{strides:c,pad:l,dataFormat:u,dilations:d,dimRoundingMode:h}});if(s){const e=m;if("NCHW"===u&&1===s.shape.length&&1!==s.shape[0]){const e=L3({inputs:{x:s},backend:n,attrs:{shape:[s.shape[0],1,1]}});m=D3({inputs:{a:m,b:e},backend:n}),n.disposeIntermediateTensorInfo(e)}else m=D3({inputs:{a:m,b:s},backend:n});n.disposeIntermediateTensorInfo(e)}if(p){const e=m;if("NCHW"===u&&"prelu"===p&&1===i.shape.length&&1!==i.shape[0]){const e=L3({inputs:{x:i},backend:n,attrs:{shape:[i.shape[0],1,1]}});m=w3(n,m,p,e,f),n.disposeIntermediateTensorInfo(e)}else m=w3(n,m,p,i,f);n.disposeIntermediateTensorInfo(e)}return m}};const i6={kernelName:NK,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r,filter:o,bias:s,preluActivationWeights:i}=t,{strides:c,pad:l,dataFormat:u,dilations:d,dimRoundingMode:h,activation:p,leakyreluAlpha:f}=a;let m=r5({inputs:{x:r,filter:o},backend:n,attrs:{strides:c,pad:l,dataFormat:u,dilations:d,dimRoundingMode:h}});if(s){const e=m;m=D3({inputs:{a:m,b:s},backend:n}),n.disposeIntermediateTensorInfo(e)}if(p){const e=m;m=w3(n,m,p,i,f),n.disposeIntermediateTensorInfo(e)}return m}};function c6(e,t,n,a,r,o,s,i,c){const l=cY([a,o],n);for(let u=0;u<a;u++){const n=[];let a=0;for(let t=0;t<r;t++){const o=e[u*r+t];a+=o*s[t],n.push(o)}if(a<0||a>=c/o)throw new Error("Invalid indices: ".concat(n," does not index into ").concat(i));for(let e=0;e<o;e++)l.values[u*o+e]=t.get(...t.indexToLoc(a*o+e))}return l}const l6={kernelName:TH,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{params:a,indices:r}=t,o=DU(a.shape),s=r.shape,i=s[s.length-1],[c,l,u,d]=i2(a,r);if(0===l)return n.makeTensorInfo(c,a.dtype,[]);const h=c6(n.data.get(r.dataId).values,n.bufferSync(a),a.dtype,l,i,u,d,a.shape,o);return n.makeTensorInfo(c,a.dtype,h.values)}};function u6(e,t,n){const a=cY(n,e.dtype);for(let r=0;r<a.size;++r){const n=a.indexToLoc(r).slice(),o=n[0],s=n[2],i=t.locToIndex([o,s]);n[2]=t.values[i];const c=e.locToIndex(n);0<=c&&c<e.values.length&&(a.values[r]=e.values[c])}return a}const d6={kernelName:CH,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r,indices:o}=t,{axis:s,batchDims:i}=a;Z2([r,o],"gatherV2");const c=VU(s,r.shape)[0],l=n.data.get(o.dataId).values,u=r.shape[c];for(let x=0;x<l.length;++x){const e=l[x];AU(e<=u-1&&e>=0,(()=>"GatherV2: the index value ".concat(e," is not in [0, ").concat(u-1,"]")))}let d=i;null==i&&(d=0);const h=DU(o.shape),p=Y2(r,o,c,d),f=L3({inputs:{x:r},backend:n,attrs:{shape:[p.batchSize,p.outerSize,p.dimSize,p.sliceSize]}}),m=L3({inputs:{x:o},backend:n,attrs:{shape:[p.batchSize,h/p.batchSize]}}),g=[p.batchSize,p.outerSize,h/p.batchSize,p.sliceSize],b=n.bufferSync(m),y=u6(n.bufferSync(f),b,g);return n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),n.makeTensorInfo(p.outputShape,y.dtype,y.values)}},h6=u3(((e,t)=>e>t?1:0)),p6=_3(EH,h6,null,"bool"),f6={kernelName:EH,backendName:"cpu",kernelFunc:p6},m6=u3(((e,t)=>e>=t?1:0)),g6=_3(RH,m6,null,"bool"),b6={kernelName:RH,backendName:"cpu",kernelFunc:g6};const y6={kernelName:AH,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{input:a}=t,r=DU(a.shape),o=a.shape[a.shape.length-1],s=L3({inputs:{x:a},backend:n,attrs:{shape:[r/o,o]}}),i=q5(s,!0,n),c=L3({inputs:{x:i},backend:n,attrs:{shape:a.shape}});return n.disposeIntermediateTensorInfo(s),n.disposeIntermediateTensorInfo(i),c}},x6=n3(OH,(e=>Number.isFinite(e)?1:0),"bool"),v6={kernelName:OH,backendName:"cpu",kernelFunc:x6},w6=n3(DH,(e=>Math.abs(e)===1/0?1:0),"bool"),k6={kernelName:DH,backendName:"cpu",kernelFunc:w6},I6=n3(MH,(e=>Number.isNaN(e)?1:0),"bool"),S6={kernelName:MH,backendName:"cpu",kernelFunc:I6},N6=u3(((e,t)=>e<t?1:0)),C6=_3(PH,N6,null,"bool"),T6={kernelName:PH,backendName:"cpu",kernelFunc:C6},E6=u3(((e,t)=>e<=t?1:0)),R6=_3(zH,E6,null,"bool"),_6={kernelName:zH,backendName:"cpu",kernelFunc:R6};function A6(e,t,n){const a=(t-e)/(n-1),r=tG(n,"float32");r[0]=e;for(let o=1;o<r.length;o++)r[o]=r[o-1]+a;return r}const F6={kernelName:BH,backendName:"cpu",kernelFunc:function(e){const{backend:t,attrs:n}=e,{start:a,stop:r,num:o}=n,s=A6(a,r,o);return t.makeTensorInfo([s.length],"float32",s)}},O6=t3((e=>Math.log(e))),D6=a3(WH,O6),M6={kernelName:WH,backendName:"cpu",kernelFunc:D6},L6=n3(VH,(e=>Math.log1p(e))),P6={kernelName:VH,backendName:"cpu",kernelFunc:L6},z6=u3(((e,t)=>e&&t)),B6=_3(UH,z6,null,"bool"),W6={kernelName:UH,backendName:"cpu",kernelFunc:B6},V6=n3(GH,(e=>e?0:1),"bool"),U6={kernelName:GH,backendName:"cpu",kernelFunc:V6},G6=u3(((e,t)=>e||t)),H6=_3(HH,G6,null,"bool"),j6={kernelName:HH,backendName:"cpu",kernelFunc:H6};const K6={kernelName:jH,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{depthRadius:o,bias:s,alpha:i,beta:c}=a;Z2(r,"LRN");const l=r.shape[3],u=l-1,d=n.data.get(r.dataId).values,h=DU(r.shape),p=new Float32Array(h);function f(e){const t=e%l;let n=e-t+Math.max(0,t-o);const a=e-t+Math.min(t+o,u);let r=0;for(;n<=a;n++){const e=d[n];r+=e*e}return r}for(let m=0;m<h;m++){const e=f(m),t=d[m]*Math.pow(s+i*e,-c);p[m]=t}return n.makeTensorInfo(r.shape,r.dtype,p)}};const q6={kernelName:KH,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r,y:o,dy:s}=t,{depthRadius:i,bias:c,alpha:l,beta:u}=a;Z2(s,"LRNGrad");const d=DU(s.shape),h=s.shape[3],p=n.data.get(s.dataId).values,f=n.data.get(r.dataId).values,m=n.data.get(o.dataId).values,g=new Float32Array(d),b=d;for(let y=0;y<b;y++){const e=y%h,t=y-e+Math.max(0,e-i),n=y-e+Math.min(h,e+i+1);let a=0;for(let r=t;r<n;r++)a+=Math.pow(f[r],2);a=l*a+c;for(let r=t;r<n;r++){let e=-2*l*u*f[r]*m[y]/a;y===r&&(e+=Math.pow(a,-u)),e*=p[y],g[r]+=e}}return n.makeTensorInfo(s.shape,r.dtype,g)}};function X6(e,t,n,a){const r=GU(a,DU(n));for(let o=0;o<r.length;++o){const n=o*t;let a=e[n];for(let r=0;r<t;++r){const t=e[n+r];(Number.isNaN(t)||t>a)&&(a=t)}r[o]=a}return r}function Y6(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{reductionIndices:o,keepDims:s}=a,i=n;let c=r.shape;const l=c.length,u=VU(o,c);let d=u;const h=ZJ(d,l);let p=i.data.get(r.dataId).values;if(null!=h){const e=new Array(l);for(let t=0;t<e.length;t++)e[t]=c[h[t]];p=X3(p,c,r.dtype,h,e),d=eZ(d.length,l),c=e}Z2(r,"max"),JJ("max",d,l);const[f,m]=YJ(c,d),g=X6(p,DU(m),f,r.dtype),b=i.write(g,f,r.dtype);let y=f;if(s){y=QJ(f,u)}return{dataId:b,shape:y,dtype:r.dtype}}const Q6={kernelName:qH,backendName:"cpu",kernelFunc:Y6},J6=u3(((e,t)=>Math.max(e,t))),Z6=_3(XH,J6),$6={kernelName:XH,backendName:"cpu",kernelFunc:Z6};const e8={kernelName:YH,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t;Z2(r,"maxPool");const{filterSize:o,strides:s,pad:i,dimRoundingMode:c}=a;AU(YQ(s,1),(()=>"Error in maxPool: Either strides or dilations must be 1. "+"Got strides ".concat(s," and dilations '").concat(1,"'")));const l=BQ(r.shape,o,s,1,i,c);let u;if(1===l.filterWidth&&1===l.filterHeight&&MU(l.inShape,l.outShape))u=s3({inputs:{x:r},backend:n});else{const e=n.data.get(r.dataId).values,t=JU(r.shape),a=h4(e,r.shape,r.dtype,t,l,"max");u=n.makeTensorInfo(l.outShape,r.dtype,a.values)}return u}};const t8={kernelName:JH,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{filterSize:o,strides:s,pad:i,dimRoundingMode:c,dataFormat:l}=a;Z2(r,"maxPool3d");const u=WQ(r.shape,o,s,1,i,c,l),d=f4(n.data.get(r.dataId).values,r.shape,r.dtype,JU(r.shape),u,"max");return n.makeTensorInfo(d.shape,"float32",d.values)}};const n8={kernelName:ZH,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{dy:r,input:o}=t,{filterSize:s,strides:i,pad:c,dimRoundingMode:l}=a;Z2([r,o],"maxPool3DGrad");const u=WQ(o.shape,s,i,1,c,l),d=function(e,t){const n=cY(t.outShape,"int32"),a=t.strideDepth,r=t.strideHeight,o=t.strideWidth,s=t.dilationDepth,i=t.dilationHeight,c=t.dilationWidth,l=t.effectiveFilterDepth,u=t.effectiveFilterHeight,d=t.effectiveFilterWidth,h=t.padInfo.front,p=t.padInfo.top,f=t.padInfo.left;for(let m=0;m<t.batchSize;++m)for(let g=0;g<t.inChannels;++g)for(let b=0;b<t.outDepth;++b){const y=b*a-h;let x=y;for(;x<0;)x+=s;const v=Math.min(t.inDepth,l+y);for(let a=0;a<t.outHeight;++a){const l=a*r-p;let h=l;for(;h<0;)h+=i;const w=Math.min(t.inHeight,u+l);for(let r=0;r<t.outWidth;++r){const p=r*o-f;let k=p;for(;k<0;)k+=c;const I=Math.min(t.inWidth,d+p);let S=Number.NEGATIVE_INFINITY,N=-1;for(let t=x;t<v;t+=s){const n=t-y;for(let a=h;a<w;a+=i){const r=a-l;for(let o=k;o<I;o+=c){const s=o-p,i=e.get(m,t,a,o,g);i>=S&&(S=i,N=n*u*d+r*u+s)}}}n.set(N,m,b,a,r,g)}}}return n}(n.bufferSync(o),u),h=u.strideDepth,p=u.strideHeight,f=u.strideWidth,m=u.dilationDepth,g=u.dilationHeight,b=u.dilationWidth,y=u.effectiveFilterDepth,x=u.effectiveFilterHeight,v=u.effectiveFilterWidth,w=y-1-u.padInfo.front,k=v-1-u.padInfo.left,I=x-1-u.padInfo.top,S=cY(o.shape,"float32"),N=n.bufferSync(r);for(let C=0;C<u.batchSize;++C)for(let e=0;e<u.inChannels;++e)for(let t=0;t<u.inDepth;++t)for(let n=0;n<u.inHeight;++n)for(let a=0;a<u.inWidth;++a){const r=t-w,o=n-I,s=a-k;let i=0;for(let t=0;t<y;t+=m){const n=(r+t)/h;if(!(n<0||n>=u.outDepth||Math.floor(n)!==n))for(let a=0;a<x;a+=g){const r=(o+a)/p;if(!(r<0||r>=u.outHeight||Math.floor(r)!==r))for(let o=0;o<v;o+=b){const c=(s+o)/f;if(c<0||c>=u.outWidth||Math.floor(c)!==c)continue;const l=y*x*v-1-d.get(C,n,r,c,e)===t*x*v+a*v+o?1:0;if(0===l)continue;i+=N.get(C,n,r,c,e)*l}}}S.set(i,C,t,n,a,e)}return n.makeTensorInfo(S.shape,S.dtype,S.values)}};const a8={kernelName:QH,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{dy:r,input:o,output:s}=t,i=o;Z2([o,s],"maxPoolGrad");const{filterSize:c,strides:l,pad:u,dimRoundingMode:d}=a,h=BQ(i.shape,c,l,1,u,d),p=n.data.get(i.dataId).values,f=cY(h.outShape,i.dtype,p4(p,i.shape,i.dtype,h).values),m=h.strideHeight,g=h.strideWidth,b=h.dilationHeight,y=h.dilationWidth,x=h.effectiveFilterHeight,v=h.effectiveFilterWidth,w=v-1-h.padInfo.left,k=x-1-h.padInfo.top,I=cY(i.shape,"float32"),S=n.data.get(r.dataId).values,N=cY(r.shape,"float32",S);for(let C=0;C<h.batchSize;++C)for(let e=0;e<h.inChannels;++e)for(let t=0;t<h.inHeight;++t)for(let n=0;n<h.inWidth;++n){const a=t-k,r=n-w;let o=0;for(let t=0;t<x;t+=b){const n=(a+t)/m;if(!(n<0||n>=h.outHeight||Math.floor(n)!==n))for(let a=0;a<v;a+=y){const s=(r+a)/g;if(s<0||s>=h.outWidth||Math.floor(s)!==s)continue;const i=x*v-1-f.get(C,n,s,e)===t*v+a?1:0;if(0===i)continue;o+=N.get(C,n,s,e)*i}}I.set(o,C,t,n,e)}return n.makeTensorInfo(I.shape,I.dtype,I.values)}};const r8={kernelName:$H,backendName:"cpu",kernelFunc:e=>{let{inputs:t,attrs:n,backend:a}=e;const{x:r}=t,{filterSize:o,strides:s,pad:i,includeBatchInIndex:c}=n,l=a;Z2(r,"MaxPoolWithArgmax");const u=l.data.get(r.dataId).values,d=BQ(r.shape,o,s,[1,1],i),[h,p]=function(e,t,n,a,r){const o=h4(e,0,n,JU(t),r,"max"),s=p4(e,t,n,r,!0,a);return[o.values,s.values]}(u,r.shape,r.dtype,c,d),f=l.write(h,d.outShape,r.dtype),m=l.write(p,d.outShape,r.dtype);return[{dataId:f,shape:d.outShape,dtype:r.dtype},{dataId:m,shape:d.outShape,dtype:"int32"}]}};const o8={kernelName:ej,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{axis:o,keepDims:s}=a,i=VU(o,r.shape),c=DU(YJ(r.shape,i)[1]),l=[],u=n.makeTensorInfo([],"float32",new Float32Array([c]));l.push(u);const d=E3({inputs:{x:r},backend:n,attrs:{dtype:"float32"}});l.push(d);const h=V5({inputs:{a:d,b:u},backend:n});l.push(h);const p=b5({inputs:{x:h},backend:n,attrs:{axis:o,keepDims:s}});return l.forEach((e=>n.disposeIntermediateTensorInfo(e))),p}};const s8={kernelName:tj,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{axis:o,keepDims:s}=a;Z2(r,"min");const i=VU(o,r.shape);let c=i;const l=ZJ(c,r.shape.length);let u=r;null!=l&&(u=Y3({inputs:{x:r},backend:n,attrs:{perm:l}}),c=eZ(c.length,r.shape.length)),JJ("min",c,u.shape.length);const[d,h]=YJ(u.shape,c),p=DU(h),f=tG(DU(d),u.dtype),m=n.data.get(u.dataId).values;for(let b=0;b<f.length;++b){const e=b*p;let t=m[e];for(let n=0;n<p;++n){const a=m[e+n];(Number.isNaN(a)||a<t)&&(t=a)}f[b]=t}null!=l&&n.disposeIntermediateTensorInfo(u);const g=n.makeTensorInfo(d,u.dtype,f);if(s){const e=L3({inputs:{x:g},backend:n,attrs:{shape:QJ(d,i)}});return n.disposeIntermediateTensorInfo(g),e}return g}},i8=u3(((e,t)=>Math.min(e,t))),c8=_3(nj,i8),l8={kernelName:nj,backendName:"cpu",kernelFunc:c8};const u8={kernelName:aj,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{paddings:o,mode:s}=a;Z2(r,"mirrorPad");const i=o.map(((e,t)=>e[0]+r.shape[t]+e[1])),c=o.map((e=>e[0])),l=o.map(((e,t)=>e[0]+r.shape[t])),u="reflect"===s?0:1,d=n.data.get(r.dataId).values,h=r.shape.length,p=JU(r.shape),f=DU(i),m=i.length,g=JU(i),b=GU(r.dtype,f);for(let y=0;y<f;y++){let e=oG(y,m,g);for(let n=0;n<m;n++)e[n]<c[n]?e[n]=2*c[n]-e[n]-u:e[n]>=l[n]&&(e[n]=2*(l[n]-1)-e[n]+u);e=e.map(((e,t)=>e-c[t]));const t=rG(e,h,p);b[y]=d[t]}return{dataId:n.write(b,i,r.dtype),shape:i,dtype:r.dtype}}},d8=u3(((e,t)=>{const n=e%t;return e<0&&t<0||e>=0&&t>=0?n:(n+t)%t})),h8=_3(rj,d8),p8={kernelName:rj,backendName:"cpu",kernelFunc:h8};function f8(e){const{inputs:t,backend:n,attrs:a}=e,{logits:r}=t,{dim:o}=a,s=r.shape.length;let i=o;if(-1===i&&(i=s-1),i!==s-1)throw Error("Softmax along a non-last dimension is not yet supported. "+"Logits was rank ".concat(s," and dim was ").concat(i));const c=VU([i],r.shape),l=Y6({inputs:{x:r},backend:n,attrs:{reductionIndices:c,keepDims:!1}}),u=QJ(l.shape,c),d=L3({inputs:{x:l},backend:n,attrs:{shape:u}}),h=j5({inputs:{a:r,b:d},backend:n}),p=O5({inputs:{x:h},backend:n}),f=b5({inputs:{x:p},backend:n,attrs:{axis:c,keepDims:!1}}),m=L3({inputs:{x:f},backend:n,attrs:{shape:u}}),g=V5({inputs:{a:p,b:m},backend:n});return n.disposeIntermediateTensorInfo(l),n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),g}const m8={kernelName:Qj,backendName:"cpu",kernelFunc:f8};const g8={kernelName:oj,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{logits:r}=t,{numSamples:o,seed:s,normalized:i}=a;Z2(r,"multinomial");const c=i?r:f8({inputs:{logits:r},backend:n,attrs:{dim:-1}}),l=c.shape[0],u=c.shape[1],d=n.data.get(c.dataId).values,h=[l,o],p=tG(DU(h),"int32");for(let f=0;f<l;++f){const e=f*u,t=new Float32Array(u-1);t[0]=d[e];for(let r=1;r<t.length;++r)t[r]=t[r-1]+d[e+r];const n=sf.alea(s.toString()),a=f*o;for(let r=0;r<o;++r){const e=n();p[a+r]=t.length;for(let n=0;n<t.length;n++)if(e<t[n]){p[a+r]=n;break}}}return i||n.disposeIntermediateTensorInfo(c),n.makeTensorInfo(h,"int32",p)}};function b8(e,t,n){const a=YK(-1,n);return p5([],t,a,e,n)}const y8={kernelName:ij,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{x:a}=t;Z2(a,"neg");const r=n.data.get(a.dataId).values,[o,s]=b8(r,a.shape,a.dtype);return n.makeTensorInfo(s,a.dtype,o)}},x8=e1;const v8={kernelName:lj,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{boxes:r,scores:o}=t,{maxOutputSize:s,iouThreshold:i,scoreThreshold:c}=a;Z2(r,"NonMaxSuppression");const l=n.data.get(r.dataId).values,u=n.data.get(o.dataId).values,{selectedIndices:d}=x8(l,u,s,i,c);return n.makeTensorInfo([d.length],"int32",new Int32Array(d))}},w8=t1;const k8={kernelName:uj,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{boxes:r,scores:o}=t,{maxOutputSize:s,iouThreshold:i,scoreThreshold:c,padToMaxOutputSize:l}=a;Z2(r,"NonMaxSuppressionPadded");const u=n.data.get(r.dataId).values,d=n.data.get(o.dataId).values,{selectedIndices:h,validOutputs:p}=w8(u,d,s,i,c,l);return[n.makeTensorInfo([h.length],"int32",new Int32Array(h)),n.makeTensorInfo([],"int32",new Int32Array([p]))]}},I8=n1;const S8={kernelName:dj,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{boxes:r,scores:o}=t,{maxOutputSize:s,iouThreshold:i,scoreThreshold:c,softNmsSigma:l}=a;Z2(r,"NonMaxSuppressionWithScore");const u=n.data.get(r.dataId).values,d=n.data.get(o.dataId).values,h=s,p=i,f=c,m=l,{selectedIndices:g,selectedScores:b}=I8(u,d,h,p,f,m);return[n.makeTensorInfo([g.length],"int32",new Int32Array(g)),n.makeTensorInfo([b.length],"float32",new Float32Array(b))]}},N8=u3(((e,t)=>e!==t?1:0)),C8=_3(cj,N8,null,"bool"),T8={kernelName:cj,backendName:"cpu",kernelFunc:C8};const E8={kernelName:pj,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{indices:r}=t,{dtype:o,depth:s,onValue:i,offValue:c}=a;Z2(r,"oneHot");const l=DU(r.shape),u=new Float32Array(l*s);u.fill(c);const d=n.data.get(r.dataId).values;for(let h=0;h<l;++h)d[h]>=0&&d[h]<s&&(u[h*s+d[h]]=i);return n.makeTensorInfo([...r.shape,s],o,u)}};function R8(e){const{inputs:t,backend:n}=e,{x:a}=t;if("string"===a.dtype)throw new Error("zerosLike is not supported for string tensors");if("complex64"===a.dtype){const e=N3({inputs:{input:a},backend:n}),t=R8({inputs:{x:e},backend:n}),r=z4({inputs:{input:a},backend:n}),o=R8({inputs:{x:r},backend:n}),s=k3({inputs:{real:t,imag:o},backend:n});return n.disposeIntermediateTensorInfo(e),n.disposeIntermediateTensorInfo(t),n.disposeIntermediateTensorInfo(r),n.disposeIntermediateTensorInfo(o),s}return J5({backend:n,attrs:{shape:a.shape,value:0,dtype:a.dtype}})}const _8={kernelName:xK,backendName:"cpu",kernelFunc:R8};const A8={kernelName:hj,backendName:"cpu",kernelFunc:function e(t){const{inputs:n,backend:a}=t,{x:r}=n;if("string"===r.dtype)throw new Error("onesLike is not supported for string tensors");if("complex64"===r.dtype){const t=N3({inputs:{input:r},backend:a}),n=e({inputs:{x:t},backend:a}),o=z4({inputs:{input:r},backend:a}),s=R8({inputs:{x:o},backend:a}),i=k3({inputs:{real:n,imag:s},backend:a});return a.disposeIntermediateTensorInfo(t),a.disposeIntermediateTensorInfo(n),a.disposeIntermediateTensorInfo(o),a.disposeIntermediateTensorInfo(s),i}return J5({backend:a,attrs:{shape:r.shape,value:1,dtype:r.dtype}})}};function F8(e){const{inputs:t,backend:n,attrs:a}=e,{axis:r}=a;if(1===t.length)return M5({inputs:{input:t[0]},backend:n,attrs:{dim:r}});const o=t[0].shape,s=t[0].dtype;t.forEach((e=>{FU(o,e.shape,"All tensors passed to stack must have matching shapes"),AU(s===e.dtype,(()=>"All tensors passed to stack must have matching dtypes"))}));const i=[],c=t.map((e=>{const t=M5({inputs:{input:e},backend:n,attrs:{dim:r}});return i.push(t),t})),l=W4({inputs:c,backend:n,attrs:{axis:r}});return i.forEach((e=>n.disposeIntermediateTensorInfo(e))),l}const O8={kernelName:fj,backendName:"cpu",kernelFunc:F8};const D8={kernelName:mj,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{paddings:o,constantValue:s}=a;Z2(r,"pad");const i=o.map(((e,t)=>e[0]+r.shape[t]+e[1])),c=o.map((e=>e[0])),l=n.data.get(r.dataId).values,u=DU(r.shape),d=r.shape.length,h=JU(r.shape),p=DU(i),f=i.length,m=JU(i),g=GU(r.dtype,p);0!==s&&g.fill(s);for(let b=0;b<u;b++){const e=oG(b,d,h).map(((e,t)=>e+c[t]));g[rG(e,f,m)]=l[b]}return{dataId:n.write(g,i,r.dtype),shape:i,dtype:r.dtype}}},M8=u3(((e,t)=>Math.pow(e,t))),L8=_3(gj,M8),P8={kernelName:gj,backendName:"cpu",kernelFunc:L8};function z8(e,t,n,a){const[r,o]=YJ(e,a),s=Cq(t,"int32"),i=tG(DU(r),s),c=DU(o);for(let l=0;l<i.length;++l){const e=l*c;let t=1;for(let a=0;a<c;++a)t*=n[e+a];i[l]=t}return{outVals:i,outShape:r,outDtype:s}}const B8={kernelName:yj,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{axis:o,keepDims:s}=a;Z2(r,"prod");const i=r.shape.length,c=VU(o,r.shape),l=ZJ(c,i);let u=c,d=r;const h=[];null!=l&&(d=Y3({inputs:{x:r},backend:n,attrs:{perm:l}}),h.push(d),u=eZ(u.length,i));const p=n.data.get(d.dataId).values,{outVals:f,outShape:m,outDtype:g}=z8(d.shape,d.dtype,p,u);let b=m;return s&&(b=QJ(m,c)),h.forEach((e=>n.disposeIntermediateTensorInfo(e))),n.makeTensorInfo(b,g,f)}};function W8(e,t,n,a){const r=[];let o=0;const s=t.length-1+n.length,i=new Array(s).fill(null).map((()=>[0]));!function(e,t){for(let n=0;n<e.length;++n){const a=e[n],r=n===e.length-1?t:e[n+1].length;if(0===a.length)throw new Error("Ragged splits may not be empty");if(a[0]<0)throw new Error("Ragged splits must be non-negative");if(a[a.length-1]>r)throw new Error("Ragged splits must not point past values");for(let e=1;e<a.length;++e)if(a[e-1]>a[e])throw new Error("Ragged splits must be sorted in ascending order")}}(n,a);let c=1;for(let l=0;l<t.length-1;++l){c*=t[l];const e=t[l+1];for(let t=1;t<c+1;++t)i[l].push(t*e)}for(let l=0;l<e.length;++l){let a=e[l],s=e[l]+1;for(let e=0;e<n.length;++e){const r=n[e],o=e+t.length-1;if(o>=0){const e=i[o],t=e[e.length-1]-r[a];for(let n=a;n<s;++n)i[o].push(r[n+1]+t)}a=r[a],s=r[s]}s!==a&&(r.push([a,s]),o+=s-a)}return{outSplits:i,valueSlices:r,numValues:o}}function V8(e,t){const n=e.slice(0,t);for(;n.length<t;)n.push(1);for(let a=t;a<e.length;a++)n[t-1]*=e[a];return n}function U8(e,t,n,a,r){const o=t.slice();o[0]=r;const s=HU(n,DU(o)),i=e.length;return function(e,t,n,a,r,o){const s=V8(t,2)[1],i=V8(o,2)[1];let c=0;for(const l of n)for(let t=l[0];t<l[1];++t){for(let n=0;n<a;++n)r[c*i+n]=e[t*s+n];++c}}(e,t,a,0===i?0:i/t[0],s,o),[s,o]}function G8(e,t,n,a,r,o,s,i){if(0===e.length)throw new Error("paramsNestedSplits must be non empty");if(0===t[0].length)throw new Error("Split tensors must not be scalars");if(function(e,t,n){e.forEach(((e,a)=>{if(e<0||e>=n){const r=oG(a,t.length,JU(t)).join(",");throw new Error("indices[".concat(r,"] = ").concat(e," is not in [0, ").concat(n,")"))}}))}(o,s,t[0][0]-1),0===a.length)throw new Error("params.rank must be nonzero");const c=a[0],{outSplits:l,valueSlices:u,numValues:d}=W8(o,s,e,c),h=function(e){const t=[];for(let n=0;n<e.length;++n){const a=HU("int32",e[n].length);t.push(a),e[n].forEach(((e,t)=>a[t]=e))}return t}(l),p=U8(n,a,r,u,d);return[h,p[0],p[1]]}const H8={kernelName:xj,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{paramsNestedSplits:r,paramsDenseValues:o,indices:s}=t,{outputRaggedRank:i}=a,c=r.map((e=>n.data.get(e.dataId).values)),l=r.map((e=>e.shape)),u=n.data.get(o.dataId).values,d=n.data.get(s.dataId).values,[h,p,f]=G8(c,l,u,o.shape,o.dtype,d,s.shape),m=h.map((e=>n.makeTensorInfo([e.length],"int32",e))),g=n.makeTensorInfo(f,o.dtype,p);return m.concat([g])}},j8=2147483647;function K8(e,t,n,a,r,o,s){if(t.length>1)throw new Error("starts must be a scalar or vector");if(r.length>1)throw new Error("limits must be a scalar or vector");if(s.length>1)throw new Error("deltas must be a scalar or vector");const i=0===t.length,c=0===r.length,l=0===s.length,u=[];i||u.push(t[0]),c||u.push(r[0]),l||u.push(s[0]);for(let m=1;m<u.length;++m)if(u[m]!==u[m-1])throw new Error("starts, limits, and deltas must have the same shape");const d=0===u.length?1:u[0],h=HU("int32",d+1);h[0]=0;for(let m=0;m<d;++m){const t=i?e[0]:e[m],n=c?a[0]:a[m],r=l?o[0]:o[m];if(0===r)throw new Error("Requires delta != 0");let s;if(r>0&&n<t||r<0&&n>t)s=0;else if(s=Math.ceil(Math.abs((n-t)/r)),s>j8)throw new Error("Requires ((limit - start) / delta) <= ".concat(j8));h[m+1]=h[m]+s}const p=HU(n,h[d]);let f=0;for(let m=0;m<d;++m){const t=h[m+1]-h[m];let n=i?e[0]:e[m];const a=l?o[0]:o[m];for(let e=0;e<t;++e)p[f++]=n,n+=a}return[h,p]}const q8={kernelName:vj,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{starts:a,limits:r,deltas:o}=t,s=n.data.get(a.dataId).values,i=n.data.get(r.dataId).values,c=n.data.get(o.dataId).values,[l,u]=K8(s,a.shape,a.dtype,i,r.shape,c,o.shape);return[n.makeTensorInfo([l.length],"int32",l),n.makeTensorInfo([u.length],a.dtype,u)]}};var X8=X1;class Y8{constructor(e,t,n,a,r,o,s,i,c,l){this.shape=e,this.shapeShape=t,this.values=n,this.valuesShape=a,this.valuesDType=r,this.defaultValue=o,this.defaultValueShape=s,this.rowPartitionValues=i,this.rowPartitionValuesShapes=c,this.rowPartitionTypes=Q1(l),this.raggedRank=J1(this.rowPartitionTypes)}getRowPartitionTypeByDimension(e){return this.rowPartitionTypes[0]===X8.FIRST_DIM_SIZE?this.rowPartitionTypes[e+1]:this.rowPartitionTypes[e]}getRowPartitionTensor(e){return this.rowPartitionTypes[0]===X8.FIRST_DIM_SIZE?this.rowPartitionValues[e+1]:this.rowPartitionValues[e]}getMaxWidth(e){const t=this.getRowPartitionTensor(e-1);switch(this.getRowPartitionTypeByDimension(e-1)){case X8.VALUE_ROWIDS:return Y8.getMaxWidthValueRowID(t);case X8.ROW_SPLITS:return Y8.getMaxWidthRowSplit(t);default:throw new Error("Cannot handle partition type ".concat(X8[this.getRowPartitionTypeByDimension(e-1)]))}}static getMaxWidthRowSplit(e){const t=e.length;if(0===t||1===t)return 0;let n=0;for(let a=0;a<t-1;++a){const t=e[a+1]-e[a];t>n&&(n=t)}return n}static getMaxWidthValueRowID(e){const t=e.length;if(0===t)return 0;let n=0,a=e[0],r=0;for(let o=1;o<t;++o){const t=e[o];t!==a&&(a=t,r=Math.max(o-n,r),n=o)}return Math.max(t-n,r)}tensorShapeFromTensor(e,t){let n=!(arguments.length>2&&void 0!==arguments[2])||arguments[2];if(0===t.length){if(-1===e[0])return[];throw new Error("The only valid scalar shape tensor is the fully unknown shape specified as -1.")}return J8(e,n)}calculateOutputSize(e){const t=this.valuesShape;Z1(this.defaultValueShape,t);const n=this.tensorShapeFromTensor(this.shape,this.shapeShape),a=Y1(this.raggedRank,n,t);a[0]<0&&(a[0]=e);for(let r=1;r<=this.raggedRank;++r)a[r]<0&&(a[r]=this.getMaxWidth(r));return a}calculateFirstParentOutputIndex(e,t,n){const a=Math.min(e,n),r=[];let o=0;for(let s=0;s<a;++s,o+=t)r.push(o);for(let s=a;s<e;++s)r.push(-1);return AU(r.length===e,(()=>"Final length of result must be equal to firstDimension.")),r}calculateOutputIndexRowSplit(e,t,n,a){const r=e.length,o=[];for(let s=0;s<r-1;++s){const r=e[s+1]-e[s];let i=Math.min(a,r),c=t[s];-1===c&&(i=0);for(let e=0;e<i;++e)o.push(c),c+=n;for(let e=0;e<r-i;++e)o.push(-1)}if(r>0&&o.length!==e[r-1])throw new Error("Invalid row split size.");return o}calculateOutputIndexValueRowID(e,t,n,a){const r=e.length,o=[];if(0===r)return[];let s=0,i=e[0];if(i>=t.length)throw new Error("Got currentValueRowId=".concat(i,", which is not less than ").concat(t.length));let c=t[i];o.push(c);for(let l=1;l<r;++l){const r=e[l];if(r===i)c>=0&&(++s,s<a?c+=n:c=-1);else{if(s=0,i=r,r>=t.length)throw new Error("Got nextValueRowId=".concat(r," which is not less than ").concat(t.length));c=t[r]}o.push(c)}if(o.length!==e.length)throw new Error("Invalid row ids.");return o}calculateOutputIndex(e,t,n,a){const r=this.getRowPartitionTensor(e),o=this.getRowPartitionTypeByDimension(e);switch(o){case X8.VALUE_ROWIDS:return this.calculateOutputIndexValueRowID(r,t,n,a);case X8.ROW_SPLITS:if(r.length-1>t.length)throw new Error("Row partition size is greater than output size: ".concat(r.length-1," > ").concat(t.length));return this.calculateOutputIndexRowSplit(r,t,n,a);default:throw new Error("Unsupported partition type: ".concat(X8[o]))}}getFirstDimensionSize(){const e=this.rowPartitionValues[0];if(0===this.rowPartitionTypes.length)throw new Error("No row_partition_types given.");const t=this.rowPartitionTypes[0];switch(t){case X8.FIRST_DIM_SIZE:return e[0];case X8.VALUE_ROWIDS:throw new Error("Cannot handle VALUE_ROWIDS in first dimension.");case X8.ROW_SPLITS:return this.rowPartitionValuesShapes[0][0]-1;default:throw new Error("Cannot handle type ".concat(X8[t]))}}compute(){if(this.rowPartitionValues[0].length<=0)throw new Error("Invalid first partition input. Tensor requires at least one element.");const e=this.getFirstDimensionSize(),t=this.calculateOutputSize(e),n=new Array(this.raggedRank+1);n[n.length-1]=1;for(let o=n.length-2;o>=0;--o)n[o]=n[o+1]*t[o+1];const a=J8(t,!1),r=HU(this.valuesDType,DU(a));if(n[0]*t[0]>0){let o=this.calculateFirstParentOutputIndex(e,n[0],t[0]);for(let e=1;e<=this.raggedRank;++e){o=this.calculateOutputIndex(e-1,o,n[e],t[e])}this.setOutput(this.raggedRank,o,r,a)}return[a,r]}setOutput(e,t,n,a){if(0===n.length)return;const r=this.values,o=n;let s=a.slice();s=s.slice(e+1);const i=DU(s),c=t.length;let l=this.defaultValue;if(l.length!==i&&1!==l.length){const e=this.defaultValueShape;nX((()=>{const t=$Q(l,e),n=gJ(t,s);l=n.dataSync()}))}let u=0,d=0,h=0;for(let p=0;p<=c;++p){let e=p<c?t[p]:-1;if(e!==h){if(d<h){const e=r.subarray(u*i);Q8(o.subarray(d*i),e,(h-d)*i)}if(p>=c){const t=n.length;e=Math.floor(t/i)}if(e>h)if(1===this.defaultValue.length)o.subarray(h*i,e*i).fill(this.defaultValue[0]),h=e;else for(;e>h;){Q8(o.slice(h*i),l,i),++h}e<0?(u=p+1,d=h):(u=p,d=h,h=d+1)}else++h}}}function Q8(e,t,n){for(let a=0;a<n;a++)e[a]=t[a]}function J8(e,t){const n=[];for(let a of e){if(a<0){if(!t)throw new Error("Dimension ".concat(a," must be >= 0"));if(a<-1)throw new Error("Dimension ".concat(a," must be >= -1"));a=-1}n.push(a)}return n}function Z8(e,t,n,a,r,o,s,i,c,l){return new Y8(e,t,n,a,r,o,s,i,c,l).compute()}const $8={kernelName:wj,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{shape:r,values:o,defaultValue:s,rowPartitionTensors:i}=t,{rowPartitionTypes:c}=a,l=n.data.get(r.dataId).values,u=n.data.get(o.dataId).values,d=n.data.get(s.dataId).values,h=i.map((e=>n.data.get(e.dataId).values)),p=i.map((e=>e.shape)),[f,m]=Z8(l,r.shape,u,o.shape,o.dtype,d,s.shape,h,p,c);return n.makeTensorInfo(f,o.dtype,m)}};function e7(e,t,n,a){if(e===t||e<t&&n<0||t<e&&n>1)return tG(0,a);const r=tG(Math.abs(Math.ceil((t-e)/n)),a);t<e&&1===n&&(n=-1),r[0]=e;for(let o=1;o<r.length;o++)r[o]=r[o-1]+n;return r}const t7={kernelName:kj,backendName:"cpu",kernelFunc:function(e){const{backend:t,attrs:n}=e,{start:a,stop:r,dtype:o,step:s}=n,i=e7(a,r,s,o);return t.makeTensorInfo([i.length],o,i)}},n7=n3(Sj,(e=>1/e)),a7={kernelName:Sj,backendName:"cpu",kernelFunc:n7};const r7={kernelName:Rj,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{images:r}=t,{alignCorners:o,halfPixelCenters:s,size:i}=a;Z2(r,"resizeBilinear");const c=JU(r.shape),[l,u]=i,[d,h,p,f]=r.shape,m=n.data.get(r.dataId).values,g=new Float32Array(DU([d,l,u,f])),b=[o&&l>1?h-1:h,o&&u>1?p-1:p],y=[o&&l>1?l-1:l,o&&u>1?u-1:u];let x=0;const v=b[0]/y[0],w=b[1]/y[1];for(let k=0;k<d;k++)for(let e=0;e<l;e++){let t;t=s?v*(e+.5)-.5:v*e;const n=Math.max(0,Math.floor(t)),a=t-n,r=Math.min(h-1,Math.ceil(t)),o=k*c[0]+n*c[1],i=k*c[0]+r*c[1];for(let e=0;e<u;e++){let t;t=s?w*(e+.5)-.5:w*e;const n=Math.max(0,Math.floor(t)),r=t-n,l=Math.min(p-1,Math.ceil(t)),u=o+n*c[2],d=i+n*c[2],h=o+l*c[2],b=i+l*c[2];for(let e=0;e<f;e++){const t=m[u+e],n=m[d+e],o=t+(m[h+e]-t)*r,s=o+(n+(m[b+e]-n)*r-o)*a;g[x++]=s}}}return n.makeTensorInfo([d,l,u,f],"float32",g)}};const o7={kernelName:_j,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{images:r,dy:o}=t,{alignCorners:s}=a;Z2([o,r],"resizeBilinearGrad");const i=JU(r.shape),[c,l,u,d]=r.shape,[,h,p]=o.shape,f=new Float32Array(c*l*u*d),m=[s&&h>1?l-1:l,s&&p>1?u-1:u],g=[s&&h>1?h-1:h,s&&p>1?p-1:p],b=m[0]/g[0],y=m[1]/g[1],x=n.data.get(o.dataId).values;let v=0;for(let w=0;w<c;w++){const e=w*i[0];for(let t=0;t<h;t++){const n=t*b,a=Math.floor(n),r=Math.min(Math.ceil(n),l-1),o=e+a*i[1],s=e+r*i[1],c=n-a,h=1-c;for(let e=0;e<p;e++){const t=e*y,n=Math.floor(t),a=Math.min(Math.ceil(t),u-1),r=t-n,l=1-r,p=o+n*i[2],m=o+a*i[2],g=s+n*i[2],b=s+a*i[2],w=h*l,k=h*r,I=c*l,S=c*r;for(let e=0;e<d;e++){const t=x[v++];f[p+e]+=t*w,f[m+e]+=t*k,f[g+e]+=t*I,f[b+e]+=t*S}}}}return n.makeTensorInfo([c,u,l,d],"float32",f)}};const s7={kernelName:Tj,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{images:r}=t,{alignCorners:o,halfPixelCenters:s,size:i}=a;Z2(r,"resizeNearestNeighbor");const c=JU(r.shape),[l,u]=i,[d,h,p,f]=r.shape,m=n.data.get(r.dataId).values,g=new Float32Array(d*l*u*f),b=[o&&l>1?h-1:h,o&&u>1?p-1:p],y=[o&&l>1?l-1:l,o&&u>1?u-1:u],x=b[0]/y[0],v=b[1]/y[1];let w=0;for(let k=0;k<d;k++){const e=k*c[0];for(let t=0;t<l;t++){const n=s?x*(t+.5):x*t;let a=Math.min(h-1,o?Math.round(n):Math.floor(n));s&&(a=Math.max(0,a));const r=e+a*c[1];for(let e=0;e<u;e++){const t=s?v*(e+.5):v*e;let n=Math.min(p-1,o?Math.round(t):Math.floor(t));s&&(n=Math.max(0,n));const a=r+n*c[2];for(let e=0;e<f;e++){const t=m[a+e];g[w++]=t}}}}return n.makeTensorInfo([d,l,u,f],r.dtype,g)}};const i7={kernelName:Ej,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{images:r,dy:o}=t,{alignCorners:s}=a;Z2([o,r],"resizeNearestNeighborGrad");const i=JU(r.shape),c=JU(o.shape),[l,u,d,h]=r.shape,[,p,f]=o.shape,m=new Float32Array(l*u*d*h),g=n.data.get(o.dataId).values,b=[s&&p>1?u-1:u,s&&f>1?d-1:d],y=[s&&p>1?p-1:p,s&&f>1?f-1:f],x=b[0]/y[0],v=b[1]/y[1],w=1/x,k=1/v,I=2*Math.ceil(w)+2,S=2*Math.ceil(k)+2;for(let N=0;N<l;N++){const e=N*i[0];for(let t=0;t<u;t++){const n=e+t*i[1],a=Math.floor(t*w),r=Math.floor(a-I/2);for(let o=0;o<d;o++){const a=n+o*i[2],l=Math.floor(o*k),b=Math.floor(l-S/2);for(let n=0;n<h;n++){let i=0;for(let a=0;a<I;a++){const l=a+r;if(l<0||l>=p)continue;const h=e+l*c[1],m=l*x;if(t===Math.min(u-1,s?Math.round(m):Math.floor(m)))for(let e=0;e<S;e++){const t=e+b;if(t<0||t>=f)continue;const a=h+t*c[2],r=t*v;o===Math.min(d-1,s?Math.round(r):Math.floor(r))&&(i+=g[a+n])}}m[a+n]=i}}}}return n.makeTensorInfo(r.shape,r.dtype,m)}};const c7={kernelName:Fj,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{dims:o}=a;Z2(r,"reverse");const s=r.shape.length,i=VU(o,r.shape);if(0===s)return s3({inputs:{x:r},backend:n});const c=new pq(r.shape,r.dtype),l=n.bufferSync(r);for(let u=0;u<c.size;u++){const e=c.indexToLoc(u),t=e.slice();i.forEach((e=>t[e]=r.shape[e]-1-t[e])),c.set(l.get(...t),...e)}return n.makeTensorInfo(c.shape,c.dtype,c.values)}},l7={kernelName:kK,backendName:"cpu",kernelFunc:e=>{let{inputs:t,attrs:n,backend:a}=e;const{image:r}=t,{radians:o,fillValue:s,center:i}=n,c=a,l=GU(r.dtype,DU(r.shape)),[u,d,h,p]=r.shape,[f,m]=t2(i,d,h),g=Math.sin(o),b=Math.cos(o),y=c.data.get(r.dataId).values;for(let x=0;x<u;x++){const e=x*h*d*p;for(let t=0;t<d;t++){const n=t*(h*p);for(let a=0;a<h;a++){const r=a*p;for(let o=0;o<p;o++){const i=[u,t,a,o],c=i[2],x=i[1];let v=(c-f)*b-(x-m)*g,w=(c-f)*g+(x-m)*b;v=Math.round(v+f),w=Math.round(w+m);let k=s;if("number"!==typeof s&&(k=3===o?255:s[o]),v>=0&&v<h&&w>=0&&w<d){k=y[e+w*(h*p)+v*p+o]}l[e+n+r+o]=k}}}}return{dataId:c.write(l,r.shape,r.dtype),shape:r.shape,dtype:r.dtype}}},u7=n3(Oj,(e=>{const t=Math.floor(e);return e-t<.5?Math.floor(e):e-t>.5?Math.ceil(e):t%2===0?t:t+1})),d7={kernelName:Oj,backendName:"cpu",kernelFunc:u7},h7=t3((e=>1/Math.sqrt(e))),p7=a3(Dj,h7),f7={kernelName:Dj,backendName:"cpu",kernelFunc:p7};function m7(e,t,n,a,r,o,s,i,c,l){const u=[a/r,r],d=e.values,h=t.values;if(0===a)return cY(n,t.dtype);const p=c instanceof pq?c:cY(u,t.dtype);"string"===typeof c||"number"===typeof c?p.values.fill(c):"boolean"===typeof c&&p.values.fill(+c);for(let f=0;f<o;f++){const e=[];let o=0;for(let t=0;t<s;t++){const n=d[f*s+t];e.push(n),o+=n*i[t]}if(o<0||o>=a/r)throw new Error("Invalid indices: ".concat(e," does not index into ").concat(n));for(let n=0;n<r;n++)l?p.values[o*r+n]+=h[f*r+n]:p.values[o*r+n]=0===t.rank?h[0]:h[f*r+n]}return p}const g7={kernelName:Mj,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{indices:r,updates:o}=t,{shape:s}=a,{sliceRank:i,numUpdates:c,sliceSize:l,strides:u,outputSize:d}=u0(0,r,s),h=m7(n.bufferSync(r),n.bufferSync(o),s,d,l,c,i,u,0,!0);return n.makeTensorInfo(s,h.dtype,h.values)}};function b7(e,t){let n=0,a=e.length,r=0;for(;n<a;)r=Math.floor((n+a)/2),e[r]<t?n=r+1:a=r;return a}function y7(e,t){let n=0,a=e.length,r=0;for(;n<a;)r=Math.floor((n+a)/2),e[r]<=t?n=r+1:a=r;return a}const x7={kernelName:Pj,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{sortedSequence:r,values:o}=t,{side:s}=a,i=function(e,t,n,a,r,o){const s=HU("int32",n*r);for(let i=0;i<n;++i){const n=e.slice(i*a,(i+1)*a),c=i*r;for(let e=0;e<r;++e)s[c+e]="left"===o?b7(n,t[e+c]):y7(n,t[e+c])}return s}(n.data.get(r.dataId).values,n.data.get(o.dataId).values,r.shape[0],r.shape[1],o.shape[1],s);return n.makeTensorInfo(o.shape,"int32",i)}};const v7={kernelName:zj,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{condition:a,t:r,e:o}=t;Z2([a,r,o],"select");const s=a.shape.length,i=n.data.get(a.dataId).values,c=n.data.get(r.dataId).values,l=n.data.get(o.dataId).values,u=Cq(r.dtype,o.dtype),d=tG(DU(r.shape),u);let h=0;const p=0===s||s>1||1===r.shape.length?1:DU(r.shape.slice(1));for(let f=0;f<i.length;f++)for(let e=0;e<p;e++)1===i[f]?d[h++]=c[f]:d[h++]=l[f];return n.makeTensorInfo(r.shape,u,d)}},w7=c2,k7=l2,I7=n3(Bj,(e=>e>=0?k7*e:w7*(Math.exp(e)-1))),S7={kernelName:Bj,backendName:"cpu",kernelFunc:I7},N7=n3(Gj,(e=>e<0?-1:e>0?1:0)),C7={kernelName:Gj,backendName:"cpu",kernelFunc:N7},T7=n3(Vj,(e=>Math.sin(e))),E7={kernelName:Vj,backendName:"cpu",kernelFunc:T7},R7=n3(Uj,(e=>Math.sinh(e))),_7={kernelName:Uj,backendName:"cpu",kernelFunc:R7},A7=Math.log(1.1920928955078125e-7)+2,F7=n3(jj,(e=>{const t=e>-A7,n=e<A7,a=Math.exp(e);let r;return r=n?a:t?e:Math.log(1+a),r})),O7={kernelName:jj,backendName:"cpu",kernelFunc:F7};const D7={kernelName:Xj,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{blockShape:o,paddings:s}=a;Z2([r],"spaceToBatchND");const i=DU(o),c=[[0,0]];c.push(...s);for(let g=1+o.length;g<r.shape.length;++g)c.push([0,0]);const l=D8.kernelFunc({inputs:{x:r},backend:n,attrs:{paddings:c,constantValue:0}}),u=n2(l.shape,o,i,!1),d=a2(u.length,o.length,!1),h=r2(l.shape,o,i,!1),p=L3({inputs:{x:l},backend:n,attrs:{shape:u}}),f=Y3({inputs:{x:p},backend:n,attrs:{perm:d}}),m=L3({inputs:{x:f},backend:n,attrs:{shape:h}});return n.disposeIntermediateTensorInfo(l),n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(f),m}};function M7(e,t,n,a,r,o,s){const i=t[0],c=o[0],l=new Array(c),u=new Array(i),d=t[1];if(0===c){if(0!==i)throw new Error(M2(i));return[HU(n,0),[0,d],HU(r,0),l,u]}let h=!0,p=0;const f=new Array(c).fill(0);for(let g=0;g<i;++g){const t=e[g*d];if(t<0)throw new Error(L2(g,t));if(t>=c)throw new Error(P2(g,t,c));++f[t],h=h&&t>=p,p=t}let m=!0;for(let g=0;g<c;++g){const e=0===f[g];l[g]=e,m=m&&!e,f[g]=Math.max(f[g],1),g>0&&(f[g]+=f[g-1])}if(m&&h){const t=e,n=a;for(let e=0;e<i;++e)u[e]=e;return[t,[i,d],n,l,u]}{const t=f[c-1],o=HU(n,t*d),h=HU(r,t),p=new Array(c).fill(0);for(let n=0;n<i;++n){const t=e[n*d],r=p[t],s=(0===t?0:f[t-1])+r;p[t]++;for(let a=0;a<d;++a)o[s*d+a]=e[n*d+a];h[s]=a[n],u[n]=s}for(let e=0;e<c;++e){if(0===p[e]){const t=0===e?0:f[e-1];o[t*d+0]=e;for(let e=1;e<d;++e)o[t*d+e]=0;h[t]=s}}return[o,[t,d],h,l,u]}}const L7={kernelName:Jj,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{indices:a,values:r,denseShape:o,defaultValue:s}=t;if(1!==o.shape.length)throw new Error("Dense shape must be a vector, saw:\n        ".concat(o.shape));if(2!==a.shape.length)throw new Error("Indices must be a matrix, saw:\n        ".concat(a.shape));if(1!==r.shape.length)throw new Error("Values must be a vector, saw:\n        ".concat(r.shape));if(0!==s.shape.length)throw new Error("Default value must be a scalar, saw:\n        ".concat(s.shape));const i=n.data.get(a.dataId).values,c=n.data.get(r.dataId).values,l=n.data.get(o.dataId).values,u=n.data.get(s.dataId).values[0],[d,h,p,f,m]=M7(i,a.shape,a.dtype,c,r.dtype,l,u);return[n.makeTensorInfo(h,a.dtype,d),n.makeTensorInfo([h[0]],r.dtype,p),n.makeTensorInfo([f.length],"bool",new Uint8Array(f.map((e=>Number(e))))),n.makeTensorInfo([m.length],a.dtype,new Int32Array(m))]}};function P7(e,t,n,a,r){const o=DU(a),s=t[0],i=r.length,c=[];let l=1,u=-1;for(let m=0;m<i;++m){const e=r[m];if(-1===e){if(-1!==u)throw new Error(z2(u,m));u=m,c.push(1)}else{if(e<0)throw new Error(B2(m,e));l*=e,c.push(e)}}if(-1!==u){if(l<=0)throw new Error("reshape cannot infer the missing input size for an empty tensor unless all specified input sizes are non-zero");const e=Math.trunc(o/l);if(l*e!==o)throw new Error(V2(a,c));c[u]=e}if(DU(c)!==o)throw new Error(U2(a,c));const d=a.length,h=[];if(d>0){h[d-1]=1;for(let e=d-2;e>=0;--e)h[e]=h[e+1]*a[e+1]}const p=[];if(i>0){p[i-1]=1;for(let e=i-2;e>=0;--e)p[e]=p[e+1]*c[e+1]}const f=HU(n,s*i);for(let m=0;m<s;++m){let t=0;for(let n=0;n<d;++n)t+=e[m*d+n]*h[n];for(let e=0;e<i;++e)f[m*i+e]=Math.trunc(t/p[e]),t%=p[e]}return[f,[s,i],c]}const z7={kernelName:Zj,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{inputIndices:a,inputShape:r,newShape:o}=t;if(2!==a.shape.length)throw new Error("Input indices should be a matrix but received shape\n        ".concat(a.shape));if(1!==r.shape.length)throw new Error("Input shape should be a vector but received shape\n        ".concat(r.shape));if(1!==o.shape.length)throw new Error("Target shape should be a vector but received shape ".concat(o.shape));const s=Array.from(n.data.get(r.dataId).values),i=n.data.get(a.dataId).values,c=Array.from(n.data.get(o.dataId).values),[l,u,d]=P7(i,a.shape,a.dtype,s,c);return[n.makeTensorInfo(u,a.dtype,l),n.makeTensorInfo([d.length],o.dtype,new Int32Array(d))]}};function B7(e,t,n,a,r){let o=arguments.length>5&&void 0!==arguments[5]&&arguments[5],s=arguments.length>6&&void 0!==arguments[6]?arguments[6]:0;const i=a.length,c=[t[0],e.length/t[0]],l=c[1],u=i>0?r[i-1]+1:0;if(u<0)throw new Error("segment ids must be >= 0");const d=t.slice();d[0]=u;const h=HU(n,d.reduce(((e,t)=>e*t),1));if(0===i)return u>0&&h.fill(s),[h,d];if(u<=0)throw new Error("segment ids must be >= 0");let p=0,f=1,m=0,g=r[p];for(;;){let t=0;if(f<i){if(t=r[f],g===t){++f;continue}if(g>=t)throw new Error("segment ids are not increasing")}if(g<0||g>=u)throw new Error(j2(g,u));g>m&&h.fill(s,m*l,g*l);for(let n=p;n<f;++n){const t=a[n];if(t<0||t>=c[0])throw new Error(K2(n,a[n],c[0]));for(let n=0;n<l;n++)h[g*l+n]+=e[t*l+n]}if(o)for(let e=0;e<l;e++)h[g*l+e]/=f-p;if(p=f,++f,m=g+1,g=t,f>i)break}return m<u&&h.fill(s,m*l,u*l),[h,d]}const W7={kernelName:$j,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{data:a,indices:r,segmentIds:o}=t;if(a.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==r.shape.length)throw new Error("Indices should be a vector but received shape\n          ".concat(r.shape));if(1!==o.shape.length)throw new Error("Segment ids should be a vector but received shape\n          ".concat(o.shape));if(r.shape[0]!==o.shape[0])throw new Error("segmentIds and indices should have same size.");const s=n.data.get(a.dataId).values,i=n.data.get(r.dataId).values,c=n.data.get(o.dataId).values,[l,u]=B7(s,a.shape,a.dtype,i,c,!0);return n.makeTensorInfo(u,a.dtype,l)}};const V7={kernelName:eK,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{data:a,indices:r,segmentIds:o}=t;if(a.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==r.shape.length)throw new Error("Indices should be a vector but received shape\n         ".concat(r.shape));if(1!==o.shape.length)throw new Error("Segment ids should be a vector but received shape\n         ".concat(o.shape));if(r.shape[0]!==o.shape[0])throw new Error("segmentIds and indices should have same size.");const s=n.data.get(a.dataId).values,i=n.data.get(r.dataId).values,c=n.data.get(o.dataId).values,[l,u]=B7(s,a.shape,a.dtype,i,c);return n.makeTensorInfo(u,a.dtype,l)}};const U7={kernelName:tK,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{sparseIndices:r,sparseValues:o,defaultValue:s}=t,{outputShape:i}=a,{sliceRank:c,numUpdates:l,sliceSize:u,strides:d,outputSize:h}=u0(0,r,i),p=!1,f=n.bufferSync(r);let m;switch(o.dtype){case"bool":m=m7(f,n.bufferSync(o),i,h,u,l,c,d,Boolean(n.data.get(s.dataId).values[0]),p);break;case"float32":m=m7(f,n.bufferSync(o),i,h,u,l,c,d,n.data.get(s.dataId).values[0],p);break;case"int32":m=m7(f,n.bufferSync(o),i,h,u,l,c,d,n.data.get(s.dataId).values[0],p);break;case"string":m=m7(f,n.bufferSync(o),i,h,u,l,c,d,$K(n.data.get(s.dataId).values[0]),p);break;default:throw new Error("Unsupported type ".concat(o.dtype))}return n.makeTensorInfo(i,m.dtype,m.values)}};const G7={kernelName:Yj,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{numOrSizeSplits:o,axis:s}=a,i=VU(s,r.shape)[0],c=D2(r,o,i),l=new Array(r.shape.length).fill(0),u=r.shape.slice();return c.map((e=>{const t=[...u];t[i]=e;const a=w4({inputs:{x:r},backend:n,attrs:{begin:l,size:t}});return l[i]+=e,a}))}},H7=t3((e=>Math.sqrt(e))),j7=n3(Kj,(e=>Math.sqrt(e))),K7={kernelName:Kj,backendName:"cpu",kernelFunc:j7},q7={kernelName:aK,backendName:"cpu",kernelFunc:e=>{let{inputs:t,backend:n}=e;const{x:a}=t,r=n;Z2(a,"square");const o=r.data.get(a.dataId).values,s=new Float32Array(o.length);for(let i=0;i<o.length;++i){const e=o[i];s[i]=e*e}return{dataId:r.write(s,a.shape,a.dtype),shape:a.shape,dtype:a.dtype}}},X7=u3(((e,t)=>{const n=e-t;return n*n})),Y7=_3(nK,X7),Q7={kernelName:nK,backendName:"cpu",kernelFunc:Y7},J7=t3(((e,t)=>{const{pattern:n,replaceGlobal:a,rewrite:r}=t;return e.replace(new RegExp(n,a?"g":""),r)})),Z7=a3(rK,J7),$7={kernelName:rK,backendName:"cpu",kernelFunc:Z7},e9=n3(vK,((e,t)=>{const n=t;return isNaN(e)?NaN:e>0?1:n.alpha})),t9={kernelName:vK,backendName:"cpu",kernelFunc:e9};function n9(e,t,n,a){const r=cY(e,t.dtype);for(let o=0;o<r.size;o++){const e=r.indexToLoc(o),s=new Array(e.length);for(let t=0;t<s.length;t++)s[t]=e[t]*n[t]+a[t];r.set(t.get(...s),...e)}return r}const a9={kernelName:oK,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{begin:o,end:s,strides:i,beginMask:c,endMask:l,ellipsisMask:u,newAxisMask:d,shrinkAxisMask:h}=a;Z2(r,"stridedSlice");const{finalShapeSparse:p,finalShape:f,isIdentity:m,sliceDim0:g,isSimpleSlice:b,begin:y,end:x,strides:v}=SQ(r.shape,o,s,i,c,l,u,d,h);let w;if(m)w=L3({inputs:{x:r},backend:n,attrs:{shape:f}});else if(g||b){AU(r.shape.length>=1,(()=>"Input must have rank at least 1, got: ".concat(r.shape.length)));const e=dQ(y,x,v),t=w4({inputs:{x:r},backend:n,attrs:{begin:y,size:e}});w=L3({inputs:{x:t},backend:n,attrs:{shape:f}}),n.disposeIntermediateTensorInfo(t)}else{const e=n9(p,n.bufferSync(r),v,y);w=n.makeTensorInfo(f,e.dtype,e.values)}return w}};class r9{constructor(e,t,n,a,r,o){this.separator=ZK(e),this.nGramWidths=t,this.leftPad=ZK(n),this.rightPad=ZK(a),this.padWidth=r,this.preserveShort=o}getPadWidth(e){return Math.min(this.padWidth<0?e-1:this.padWidth,e-1)}getNumNGrams(e,t){const n=this.getPadWidth(t);return Math.max(0,e+2*n-t+1)}createNGrams(e,t,n,a,r,o){for(let s=0;s<r;++s){const i=this.getPadWidth(o),c=Math.max(0,i-s),l=Math.max(0,i-(r-(s+1))),u=o-(c+l),d=t+(c>0?0:s-i);let h=0;h+=c*this.leftPad.length;for(let t=0;t<u;++t)h+=e[d+t].length;h+=l*this.rightPad.length;h+=(c+l+u-1)*this.separator.length,n[a+s]=new Uint8Array(h);const p=n[a+s];let f=0;const m=e=>e.forEach((e=>p[f++]=e));for(let e=0;e<c;++e)m(this.leftPad),m(this.separator);for(let t=0;t<u-1;++t)m(e[d+t]),m(this.separator);if(u>0){m(e[d+u-1]);for(let e=0;e<l;++e)m(this.separator),m(this.rightPad)}else{for(let e=0;e<l-1;++e)m(this.rightPad),m(this.separator);m(this.rightPad)}}}compute(e,t){const n=e.length,a=t.length;if(a>0){let e=t[0];if(0!==e)throw new Error("First split value must be 0, got ".concat(e));for(let r=1;r<a;++r){let a=t[r]>=e;if(a=a&&t[r]<=n,!a)throw new Error("Invalid split value ".concat(t[r],", must be in [").concat(e,", ").concat(n,"]"));e=t[r]}if(e!==n)throw new Error("Last split value must be data size. Expected ".concat(n,", got ").concat(e))}const r=a-1,o=HU("int32",a);if(0===n||0===a){const e=new Array(n);for(let t=0;t<=r;++t)o[t]=0;return[e,o]}o[0]=0;for(let i=1;i<=r;++i){const e=t[i]-t[i-1];let n=0;this.nGramWidths.forEach((t=>{n+=this.getNumNGrams(e,t)})),this.preserveShort&&e>0&&0===n&&(n=1),o[i]=o[i-1]+n}const s=new Array(o[r]);for(let i=0;i<r;++i){const n=t[i];let a=o[i];if(this.nGramWidths.forEach((r=>{const o=t[i+1]-t[i],c=this.getNumNGrams(o,r);this.createNGrams(e,n,s,a,c,r),a+=c})),this.preserveShort&&a===o[i]){const r=t[i+1]-t[i];if(0===r)continue;const o=r+2*this.padWidth,c=1;this.createNGrams(e,n,s,a,c,o)}}return[s,o]}}function o9(e,t,n,a,r,o,s,i){return new r9(n,a,r,o,s,i).compute(e,t)}const s9={kernelName:sK,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{separator:r,nGramWidths:o,leftPad:s,rightPad:i,padWidth:c,preserveShortSequences:l}=a,{data:u,dataSplits:d}=t,h=n.data.get(u.dataId).values,p=n.data.get(d.dataId).values,[f,m]=o9(h,p,r,o,s,i,c,l);return[n.makeTensorInfo([f.length],"string",f),n.makeTensorInfo(d.shape,"int32",m)]}};function i9(e,t,n,a){if(!e.length)return;if(0===t.length){for(let t=0;t<e.length;++t)a.push(e.subarray(t,t+1));return}if(1===t.length){const r=t[0];let o=e.indexOf(r);for(;-1!==o;){const t=e.subarray(0,o);n&&0===t.length||a.push(t),o=(e=e.subarray(o+1)).indexOf(r)}return void(n&&0===e.length||a.push(e))}let r=0;for(let o=0;o<e.length+1;o++)if(o===e.length||-1!==t.indexOf(e[o])){const t=e.subarray(r,o);n&&0===t.length||a.push(t),r=o+1}}function c9(e,t,n){const a=e.length,r=[];let o=0,s=0;const i=new Array(a);for(let h=0;h<a;++h){const a=r.length;i9(e[h],t,n,r);const c=r.length-a;i[h]=c,o+=c,s=Math.max(s,c)}const c=HU("int32",2*o),l=new Array(o),u=[a,s];let d=0;for(let h=0;h<a;++h)for(let e=0;e<i[h];++e)c[2*d]=h,c[2*d+1]=e,l[d]=r[d],++d;return[c,l,u]}const l9={kernelName:iK,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{skipEmpty:r}=a,{input:o,delimiter:s}=t;if("string"!==o.dtype)throw new Error("Input must be of datatype string");if(1!==o.shape.length)throw new Error("Input must be a vector, got shape: ".concat(o.shape));if(0!==s.shape.length)throw new Error("Delimiter must be a scalar, got shape: ".concat(s.shape));const i=n.data.get(o.dataId).values,c=n.data.get(s.dataId).values[0],[l,u,d]=c9(i,c,r),h=u.length;return[n.makeTensorInfo([h,2],"int32",l),n.makeTensorInfo([h],"string",u),n.makeTensorInfo([2],"int32",new Int32Array(d))]}};function u9(e,t){const n=HU("int32",e.length);for(let a=0;a<e.length;++a)n[a]=XK(e[a]).modulo(t).getLowBitsUnsigned();return n}const d9={kernelName:cK,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{numBuckets:r}=a,{input:o}=t;if("string"!==o.dtype)throw new Error("Input must be of datatype string");if(r<=0)throw new Error("Number of buckets must be at least 1");const s=u9(n.data.get(o.dataId).values,r);return n.makeTensorInfo(o.shape,"int32",s)}},h9=n3(uK,(e=>Math.tan(e))),p9={kernelName:uK,backendName:"cpu",kernelFunc:h9},f9=n3(dK,(e=>Math.tanh(e)));const m9={kernelName:Lj,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{tensor:a,indices:r,updates:o}=t,{sliceRank:s,numUpdates:i,sliceSize:c,strides:l,outputSize:u}=u0(0,r,a.shape),d=n.bufferSync(r),h=n.bufferSync(o),p=n.bufferSync(a),f=m7(d,h,a.shape,u,c,i,s,l,p,!1);return n.makeTensorInfo(a.shape,f.dtype,f.values)}};function g9(e,t){const n=new Array(e.rank);for(let r=0;r<n.length;r++)n[r]=e.shape[r]*t[r];const a=cY(n,e.dtype);for(let r=0;r<a.values.length;++r){const t=a.indexToLoc(r),n=new Array(e.rank);for(let a=0;a<n.length;a++)n[a]=t[a]%e.shape[a];const o=e.locToIndex(n);a.values[r]=e.values[o]}return a}const b9={kernelName:hK,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{reps:o}=a;Z2(r,"tile");const s=g9(n.bufferSync(r),o);return n.makeTensorInfo(s.shape,s.dtype,s.values)}},y9=(e,t)=>{const n=t.value-e.value;return 0===n?e.index-t.index:n};function x9(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:e.length-1;for(;a>n;){if(a-n>600){const r=a-n+1,o=t-n+1,s=Math.log(r),i=.5*Math.exp(2*s/3),c=.5*Math.sqrt(s*i*(r-i)/r)*Math.sign(o-r/2);x9(e,t,Math.max(n,Math.floor(t-o*i/r+c)),Math.min(a,Math.floor(t+(r-o)*i/r+c)))}const r=e[t];let o=n,s=a;for(_U(e,n,t),y9(e[a],r)>0&&_U(e,n,a);o<s;){for(_U(e,o,s),o++,s--;y9(e[o],r)<0;)o+=1;for(;y9(e[s],r)>0;)s-=1}0===y9(e[n],r)?_U(e,n,s):(s+=1,_U(e,s,a)),s<=t&&(n=s+1),t<=s&&(a=s-1)}}function v9(e,t,n,a,r){const o=t[t.length-1],[s,i]=[e.length/o,o],c=GU(n,s*a),l=GU("int32",s*a);for(let d=0;d<s;d++){const t=d*i,n=e.subarray(t,t+i);let o=new Array(n.length);n.forEach(((e,t)=>o[t]={value:e,index:t})),a<o.length&&(x9(o,a),o=o.slice(0,a)),r&&o.sort(y9);const s=d*a,u=c.subarray(s,s+a),h=l.subarray(s,s+a);for(let e=0;e<a;e++)u[e]=o[e].value,h[e]=o[e].index}const u=t.slice();return u[u.length-1]=a,[cY(u,n,c),cY(u,"int32",l)]}const w9={kernelName:pK,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{k:o,sorted:s}=a;Z2(r,"topk");const i=n.data.get(r.dataId).values,[c,l]=v9(i,r.shape,r.dtype,o,s);return[n.makeTensorInfo(c.shape,c.dtype,c.values),n.makeTensorInfo(l.shape,l.dtype,l.values)]}};const k9={kernelName:fK,backendName:"cpu",kernelFunc:function(e){const{inputs:t,attrs:n,backend:a}=e,{image:r,transforms:o}=t,{interpolation:s,fillMode:i,fillValue:c,outputShape:l}=n,[u,d,h,p]=r.shape,[f,m]=null!=l?l:[d,h],g=[u,f,m,p],b=JU(r.shape),y=b[0],x=b[1],v=b[2],w=JU(g),k=w[0],I=w[1],S=w[2],N=GU(r.dtype,DU(g));N.fill(c);const C=a.data.get(r.dataId).values,T=a.data.get(o.dataId).values;for(let E=0;E<u;++E){const e=1===o.shape[0]?T:T.subarray(8*E,8*E+8);for(let t=0;t<f;++t)for(let n=0;n<m;++n)for(let a=0;a<p;++a){let r;const o=e[6]*n+e[7]*t+1;if(0===o)continue;const l=(e[0]*n+e[1]*t+e[2])/o,u=(e[3]*n+e[4]*t+e[5])/o,p=I9(l,h,i),f=I9(u,d,i);switch(s){case"nearest":r=N9(C,d,h,y,x,v,E,f,p,a,c);break;case"bilinear":r=C9(C,d,h,y,x,v,E,f,p,a,c);break;default:throw new Error("Error in Transform: Expect 'nearest' or "+"'bilinear', but got ".concat(s))}N[E*k+t*I+n*S+a]=r}return a.makeTensorInfo(g,r.dtype,N)}return{dataId:a.write(N,g,r.dtype),shape:r.shape,dtype:r.dtype}}};function I9(e,t,n){switch(n){case"reflect":return function(e,t){let n=e;if(n<0)if(t<=1)n=0;else{const e=2*t;n<e&&(n=e*Math.trunc(-n/e)+n),n=n<-t?n+e:-n-1}else if(n>t-1)if(t<=1)n=0;else{const e=2*t;n-=e*Math.trunc(n/e),n>=t&&(n=e-n-1)}return EU(0,n,t-1)}(e,t);case"wrap":return function(e,t){let n=e;if(n<0)if(t<=1)n=0;else{const e=t-1;n+=t*(Math.trunc(-n/e)+1)}else if(n>t-1)if(t<=1)n=0;else{const e=t-1;n-=t*Math.trunc(n/e)}return EU(0,n,t-1)}(e,t);case"nearest":return function(e,t){return EU(0,e,t-1)}(e,t);default:return function(e,t){return e}(e)}}function S9(e,t,n,a,r,o,s,i,c,l,u){return 0<=i&&i<t&&0<=c&&c<n?e[s*a+i*r+c*o+l]:u}function N9(e,t,n,a,r,o,s,i,c,l,u){return S9(e,t,n,a,r,o,s,Math.round(i),Math.round(c),l,u)}function C9(e,t,n,a,r,o,s,i,c,l,u){const d=Math.floor(i),h=Math.floor(c),p=d+1,f=h+1;return(p-i)*((f-c)*S9(e,t,n,a,r,o,s,d,h,l,u)+(c-h)*S9(e,t,n,a,r,o,s,d,f,l,u))+(i-d)*((f-c)*S9(e,t,n,a,r,o,s,p,h,l,u)+(c-h)*S9(e,t,n,a,r,o,s,p,f,l,u))}function T9(e,t,n,a){const r=VU(t,n)[0],o=[1,n[0],1];for(let f=0;f<r;f++)o[0]*=n[f];o[1]=n[r];for(let f=r+1;f<n.length;f++)o[2]*=n[f];const s=new Map,i=new Int32Array(n[r]),c=new pq(o,a,e),l=[],u=1===o[0]&&1===o[2];for(let f=0;f<n[r];f++){let t;if(u)t=e[f].toString();else{const e=[];for(let t=0;t<o[0];t++)for(let n=0;n<o[2];n++)e.push(c.get(t,f,n));t=e.join(",")}const n=s.get(t);if(null!=n)i[f]=n;else{const e=s.size;s.set(t,e),i[f]=e,l.push(f)}}const d=o.slice();d[1]=s.size;const h=new pq(d,a);l.forEach(((e,t)=>{for(let n=0;n<o[0];n++)for(let a=0;a<o[2];a++)h.set(c.get(n,e,a),n,t,a)}));const p=n.slice();return p[r]=d[1],{outputValues:h.values,outputShape:p,indices:i}}const E9={kernelName:gK,backendName:"cpu",kernelFunc:function(e){const{inputs:t,attrs:n,backend:a}=e,{axis:r}=n,{x:o}=t;Z2(o,"unique");const s=a.data.get(o.dataId).values,{outputValues:i,outputShape:c,indices:l}=T9(s,r,o.shape,o.dtype);return[a.makeTensorInfo(c,o.dtype,i),a.makeTensorInfo([l.length],"int32",l)]}};const R9={kernelName:bK,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{value:r}=t;let{axis:o}=a;o<0&&(o+=r.shape.length);const s=r.shape.length,i=r.shape[o],c=new Array(s-1);let l=0;for(let p=0;p<s;p++)p!==o&&(c[l++]=r.shape[p]);const u=new Array(s).fill(0),d=r.shape.slice();d[o]=1;const h=new Array(i);for(let p=0;p<h.length;p++){u[o]=p;const e=w4({inputs:{x:r},backend:n,attrs:{begin:u,size:d}});h[p]=L3({inputs:{x:e},backend:n,attrs:{shape:c}}),n.disposeIntermediateTensorInfo(e)}return h}};const _9={kernelName:yK,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r,segmentIds:o}=t,{numSegments:s}=a;Z2(r,"unsortedSegmentSum");const i=[],c=[],l=r.shape.length-o.shape.length;let u=o;for(let h=0;h<l;++h){const e=M5({inputs:{input:u},backend:n,attrs:{dim:h+1}});u=e,c.push(e)}for(let h=0;h<s;++h){const e=YK(h,"int32"),t=n.makeTensorInfo([],"int32",e),a=k5({inputs:{a:t,b:u},backend:n}),o=E3({inputs:{x:a},backend:n,attrs:{dtype:"float32"}}),s=m5({inputs:{a:o,b:r},backend:n}),l=b5({inputs:{x:s},backend:n,attrs:{axis:0,keepDims:!1}});i.push(l),c.push(t),c.push(a),c.push(o),c.push(s),c.push(l)}const d=F8({inputs:i,backend:n,attrs:{axis:0}});return c.forEach((e=>n.disposeIntermediateTensorInfo(e))),d}},A9=[W3,U3,H3,K3,M3,q3,J3,Z3,$3,e4,n4,r4,s4,l4,d4,m4,g4,b4,y4,B3,x4,I4,C4,R4,_4,R3,O4,M4,I3,L4,V4,G4,H4,j4,K4,q4,X4,Q4,Z4,$4,e5,t5,n5,a5,o5,s5,i5,c5,l5,u5,d5,h5,x5,o3,v5,I5,A5,D5,L5,B5,Q5,Z5,$5,n6,o6,s6,i6,l6,d6,f6,b6,i3,y6,B4,v6,k6,S6,l3,T6,_6,F6,M6,P6,W6,U6,j6,K6,q6,Q6,$6,e8,t8,n8,a8,r8,o8,s8,l8,u8,p8,g8,g5,y8,v8,k8,S8,T8,E8,A8,O8,D8,P8,p3,B8,H8,q8,$8,t7,C3,U5,a7,m3,b3,P3,r7,o7,s7,i7,c7,l7,d7,f7,g7,x7,v7,S7,v3,C7,E7,_7,k4,m8,O7,D7,L7,z7,W7,V7,U7,G7,K7,q7,Q7,$7,t9,a9,s9,l9,d9,K5,y5,p9,{kernelName:dK,backendName:"cpu",kernelFunc:f9},m9,b9,w9,k9,Q3,E9,R9,_9,_8];for(const n of A9)OK(n);const F9={},O9={alpha:!1,antialias:!1,premultipliedAlpha:!1,preserveDrawingBuffer:!1,depth:!1,stencil:!1,failIfMajorPerformanceCaveat:!0};function D9(e,t){if(!(e in F9)||null!=t){const n=function(e,t){if(1!==e&&2!==e)throw new Error("Cannot get WebGL rendering context, WebGL is disabled.");const n=null==t?function(e){if(uG().getBool("IS_SAFARI")||"undefined"===typeof OffscreenCanvas||2!==e){if("undefined"!==typeof document)return document.createElement("canvas");throw new Error("Cannot create a canvas in this context")}return new OffscreenCanvas(300,150)}(e):t;n.addEventListener("webglcontextlost",(t=>{t.preventDefault(),delete F9[e]}),!1),uG().getBool("SOFTWARE_WEBGL_ENABLED")&&(O9.failIfMajorPerformanceCaveat=!1);if(1===e)return n.getContext("webgl",O9)||n.getContext("experimental-webgl",O9);return n.getContext("webgl2",O9)}(e,t);if(null===n)return console.log("Could not get context for WebGL version",e),null;F9[e]=n}const n=F9[e];return null==n||n.isContextLost()?(delete F9[e],D9(e)):(n.disable(n.DEPTH_TEST),n.disable(n.STENCIL_TEST),n.disable(n.BLEND),n.disable(n.DITHER),n.disable(n.POLYGON_OFFSET_FILL),n.disable(n.SAMPLE_COVERAGE),n.enable(n.SCISSOR_TEST),n.enable(n.CULL_FACE),n.cullFace(n.BACK),F9[e])}var M9,L9,P9;function z9(e,t){return[t,e]}function B9(e){const t=DU(e);return PU(Math.ceil(t/4))}function W9(e,t){return[Math.max(1,Math.ceil(t/2)),Math.max(1,Math.ceil(e/2))]}function V9(e,t){const n=e;let a,r,o,s,i,c,l,u,d,h;return 2===uG().getNumber("WEBGL_VERSION")?(a=n.R32F,r=n.R16F,o=n.RGBA16F,s=n.RGBA32F,i=n.RED,l=4,u=1,d=n.HALF_FLOAT,h=n.FLOAT,c=n.RGBA8):(a=e.RGBA,r=e.RGBA,o=e.RGBA,s=n.RGBA,i=e.RGBA,l=4,u=4,d=null!=t?t.HALF_FLOAT_OES:null,h=e.FLOAT,c=e.RGBA),{internalFormatFloat:a,internalFormatHalfFloat:r,internalFormatPackedHalfFloat:o,internalFormatPackedFloat:s,textureFormatFloat:i,downloadTextureFormat:c,downloadUnpackNumChannels:l,defaultNumChannels:u,textureTypeHalfFloat:d,textureTypeFloat:h}}function U9(e,t){const n=t();return uG().getBool("DEBUG")&&function(e){const t=e.getError();if(t!==e.NO_ERROR)throw new Error("WebGL Error: "+function(e,t){switch(t){case e.NO_ERROR:return"NO_ERROR";case e.INVALID_ENUM:return"INVALID_ENUM";case e.INVALID_VALUE:return"INVALID_VALUE";case e.INVALID_OPERATION:return"INVALID_OPERATION";case e.INVALID_FRAMEBUFFER_OPERATION:return"INVALID_FRAMEBUFFER_OPERATION";case e.OUT_OF_MEMORY:return"OUT_OF_MEMORY";case e.CONTEXT_LOST_WEBGL:return"CONTEXT_LOST_WEBGL";default:return"Unknown error code ".concat(t)}}(e,t))}(e),n}!function(e){e[e.DENSE=0]="DENSE",e[e.SHARED_BATCH=1]="SHARED_BATCH"}(M9||(M9={})),function(e){e[e.RENDER=0]="RENDER",e[e.UPLOAD=1]="UPLOAD",e[e.PIXELS=2]="PIXELS",e[e.DOWNLOAD=3]="DOWNLOAD"}(L9||(L9={})),function(e){e[e.UNPACKED_FLOAT16=0]="UNPACKED_FLOAT16",e[e.UNPACKED_FLOAT32=1]="UNPACKED_FLOAT32",e[e.PACKED_4X1_UNSIGNED_BYTE=2]="PACKED_4X1_UNSIGNED_BYTE",e[e.PACKED_2X2_FLOAT32=3]="PACKED_2X2_FLOAT32",e[e.PACKED_2X2_FLOAT16=4]="PACKED_2X2_FLOAT16"}(P9||(P9={}));function G9(e){return!!(uG().getBool("WEBGL_RENDER_FLOAT32_ENABLED")||0===e||5.96e-8<Math.abs(e)&&Math.abs(e)<65504)}function H9(e,t){return $9(e,(()=>e.getExtension(t)),'Extension "'+t+'" not supported on this browser.')}const j9=/ERROR: [0-9]+:([0-9]+):/g;function K9(e,t){const n=j9.exec(t);if(null==n)return console.log("Couldn't parse line number in error: ".concat(t)),void console.log(e);const a=+n[1],r=e.split("\n"),o=r.length.toString().length+2,s=r.map(((e,t)=>zU((t+1).toString(),o)+e));let i=0;for(let d=0;d<s.length;d++)i=Math.max(s[d].length,i);const c=s.slice(0,a-1),l=s.slice(a-1,a),u=s.slice(a);console.log(c.join("\n")),console.log(t.split("\n")[0]),console.log("%c ".concat(zU(l[0],i)),"border:1px solid red; background-color:#e3d2d2; color:#a61717"),console.log(u.join("\n"))}function q9(e,t){if(U9(e,(()=>e.validateProgram(t))),!1===e.getProgramParameter(t,e.VALIDATE_STATUS))throw console.log(e.getProgramInfoLog(t)),new Error("Shader program validation failed.")}function X9(e,t,n,a,r,o,s){const i=e.getAttribLocation(t,n);return-1!==i&&(U9(e,(()=>e.bindBuffer(e.ARRAY_BUFFER,a))),U9(e,(()=>e.vertexAttribPointer(i,r,e.FLOAT,!1,o,s))),U9(e,(()=>e.enableVertexAttribArray(i))),!0)}function Y9(e,t,n,a){U9(e,(()=>function(e,t,n){eee(e,n),U9(e,(()=>e.activeTexture(e.TEXTURE0+n))),U9(e,(()=>e.bindTexture(e.TEXTURE_2D,t)))}(e,t,a))),U9(e,(()=>e.uniform1i(n,a)))}function Q9(e,t,n){U9(e,(()=>e.bindFramebuffer(e.FRAMEBUFFER,n))),U9(e,(()=>e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,t,0)))}function J9(e,t){U9(e,(()=>e.bindFramebuffer(e.FRAMEBUFFER,t))),U9(e,(()=>e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,null,0)))}function Z9(e){const t=e.checkFramebufferStatus(e.FRAMEBUFFER);if(t!==e.FRAMEBUFFER_COMPLETE)throw new Error("Error binding framebuffer: "+function(e,t){switch(t){case e.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_ATTACHMENT";case e.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT";case e.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:return"FRAMEBUFFER_INCOMPLETE_DIMENSIONS";case e.FRAMEBUFFER_UNSUPPORTED:return"FRAMEBUFFER_UNSUPPORTED";default:return"unknown error ".concat(t)}}(e,t))}function $9(e,t,n){const a=U9(e,(()=>t()));if(null==a)throw new Error(n);return a}function eee(e,t){const n=e.MAX_COMBINED_TEXTURE_IMAGE_UNITS-1,a=t+e.TEXTURE0;if(a<e.TEXTURE0||a>n){const e="[gl.TEXTURE0, gl.TEXTURE".concat(n,"]");throw new Error("textureUnit must be in ".concat(e,"."))}}function tee(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:2;return DU(e.slice(0,e.length-t))}function nee(e){if(0===e.length)throw Error("Cannot get rows and columns of an empty shape array.");return[e.length>1?e[e.length-2]:1,e[e.length-1]]}function aee(e){let t=[1,1,1];return 0===e.length||1===e.length&&1===e[0]||(t=[tee(e),...nee(e)]),t}function ree(e){return e%2===0}function oee(e,t){if(MU(e=e.slice(-2),t=t.slice(-2)))return!0;if(!e.length||!t.length)return!0;if(0===e[0]||0===e[1]||0===t[0]||0===t[1])return!0;if(e.length!==t.length){const n=e[e.length-1],a=t[t.length-1];if(n===a)return!0;if(ree(n)&&ree(a)&&(1===e[0]||1===t[0]))return!0}return e[1]===t[1]&&ree(e[0])&&ree(t[0])}let see,iee;function cee(e,t){return null!=e.getExtension(t)}function lee(e){try{if(null!=D9(e))return!0}catch(D){return console.log("Error when getting WebGL context: ",D),!1}return!1}function uee(e){if(0===e)return!1;const t=D9(e);if(1!==e){if(cee(t,"EXT_color_buffer_float"))return dee(t);const e="EXT_color_buffer_half_float";if(cee(t,e)){const n=t.getExtension(e);return function(e,t){const n=V9(e,t),a=e.createTexture();e.bindTexture(e.TEXTURE_2D,a);const r=1,o=1;e.texImage2D(e.TEXTURE_2D,0,n.internalFormatHalfFloat,r,o,0,n.textureFormatFloat,n.textureTypeHalfFloat,null);const s=e.createFramebuffer();e.bindFramebuffer(e.FRAMEBUFFER,s),e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,a,0);const i=e.checkFramebufferStatus(e.FRAMEBUFFER)===e.FRAMEBUFFER_COMPLETE;return e.bindTexture(e.TEXTURE_2D,null),e.bindFramebuffer(e.FRAMEBUFFER,null),e.deleteTexture(a),e.deleteFramebuffer(s),i}(t,n)}return!1}if(!cee(t,"OES_texture_float"))return!1;if(!cee(t,"WEBGL_color_buffer_float"))return!1;return dee(t)}function dee(e){const t=V9(e),n=e.createTexture();e.bindTexture(e.TEXTURE_2D,n);e.texImage2D(e.TEXTURE_2D,0,t.internalFormatFloat,1,1,0,t.textureFormatFloat,t.textureTypeFloat,null);const a=e.createFramebuffer();e.bindFramebuffer(e.FRAMEBUFFER,a),e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,n,0);const r=e.checkFramebufferStatus(e.FRAMEBUFFER)===e.FRAMEBUFFER_COMPLETE;return e.bindTexture(e.TEXTURE_2D,null),e.bindFramebuffer(e.FRAMEBUFFER,null),e.deleteTexture(n),e.deleteFramebuffer(a),r}function hee(e,t){Array.isArray(e)||(e=[e]),e.forEach((e=>{null!=e&&AU("complex64"!==e.dtype,(()=>"".concat(t," does not support complex64 tensors ")+"in the WebGL backend."))}))}const pee=uG();function fee(){let e,t,n,a,r,o,s,i,c,l;return 2===uG().getNumber("WEBGL_VERSION")?(e="#version 300 es",t="in",n="out",a="in",r="texture",o="outputColor",s="out vec4 outputColor;",i=uG().getBool("WEBGL2_ISNAN_CUSTOM")?"\n      bool isnan_custom(float val) {\n        uint floatToUint = floatBitsToUint(val);\n        return (floatToUint & 0x7fffffffu) > 0x7f800000u;\n      }\n\n      bvec4 isnan_custom(vec4 val) {\n        return bvec4(isnan_custom(val.x),\n          isnan_custom(val.y), isnan_custom(val.z), isnan_custom(val.w));\n      }\n\n      #define isnan(value) isnan_custom(value)\n    ":"",c="",l="\n      #define round(value) newRound(value)\n      int newRound(float value) {\n        return int(floor(value + 0.5));\n      }\n\n      ivec4 newRound(vec4 value) {\n        return ivec4(floor(value + vec4(0.5)));\n      }\n    "):(e="",t="attribute",n="varying",a="varying",r="texture2D",o="gl_FragColor",s="",i="\n      #define isnan(value) isnan_custom(value)\n      bool isnan_custom(float val) {\n        return (val > 0. || val < 1. || val == 0.) ? false : true;\n      }\n      bvec4 isnan_custom(vec4 val) {\n        return bvec4(isnan(val.x), isnan(val.y), isnan(val.z), isnan(val.w));\n      }\n    ",c="\n      uniform float INFINITY;\n\n      bool isinf(float val) {\n        return abs(val) == INFINITY;\n      }\n      bvec4 isinf(vec4 val) {\n        return equal(abs(val), vec4(INFINITY));\n      }\n    ",l="\n      int round(float value) {\n        return int(floor(value + 0.5));\n      }\n\n      ivec4 round(vec4 value) {\n        return ivec4(floor(value + vec4(0.5)));\n      }\n    "),{version:e,attribute:t,varyingVs:n,varyingFs:a,texture2D:r,output:o,defineOutput:s,defineSpecialNaN:i,defineSpecialInf:c,defineRound:l}}function mee(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"index";const a=JU(t);return a.map(((t,r)=>{const o="int ".concat(e[r]," = ").concat(n," / ").concat(t),s=r===a.length-1?"int ".concat(e[r+1]," = ").concat(n," - ").concat(e[r]," * ").concat(t):"index -= ".concat(e[r]," * ").concat(t);return"".concat(o,"; ").concat(s,";")})).join("")}function gee(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"index";const a=JU(t);return a.map(((t,r)=>{const o="int ".concat(e[r]," = ").concat(n," / outShapeStrides[").concat(r,"]"),s=r===a.length-1?"int ".concat(e[r+1]," = ").concat(n," - ").concat(e[r]," * outShapeStrides[").concat(r,"]"):"index -= ".concat(e[r]," * outShapeStrides[").concat(r,"]");return"".concat(o,"; ").concat(s,";")})).join("")}function bee(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"index";const a=e.map(((e,t)=>t)),r=function(e,t){const n=e.length,a=e.map((e=>"".concat(t,"[").concat(e,"]"))),r=new Array(n-1);r[n-2]=a[n-1];for(let o=n-3;o>=0;--o)r[o]="(".concat(r[o+1]," * ").concat(a[o+1],")");return r}(a,t);return r.map(((t,a)=>{const o="int ".concat(e[a]," = ").concat(n," / ").concat(r[a]),s=a===r.length-1?"int ".concat(e[a+1]," = ").concat(n," - ").concat(e[a]," * ").concat(r[a]):"index -= ".concat(e[a]," * ").concat(r[a]);return"".concat(o,"; ").concat(s,";")})).join("")}function yee(e){const t=JU(e).map((e=>e.toString()));return"\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * ".concat(t[0]," + coords.y * ").concat(t[1]," + coords.z;\n  }\n")}pee.registerFlag("HAS_WEBGL",(()=>pee.getNumber("WEBGL_VERSION")>0)),pee.registerFlag("WEBGL_VERSION",(()=>lee(2)?2:lee(1)?1:0)),pee.registerFlag("WEBGL_CHECK_NUMERICAL_PROBLEMS",(()=>!1)),pee.registerFlag("WEBGL_BUFFER_SUPPORTED",(()=>2===pee.get("WEBGL_VERSION"))),pee.registerFlag("WEBGL_CPU_FORWARD",(()=>!0)),pee.registerFlag("WEBGL_FORCE_F16_TEXTURES",(()=>!1)),pee.registerFlag("WEBGL_PACK",(()=>pee.getBool("HAS_WEBGL"))),pee.registerFlag("WEBGL_PACK_NORMALIZATION",(()=>pee.getBool("WEBGL_PACK"))),pee.registerFlag("WEBGL_PACK_CLIP",(()=>pee.getBool("WEBGL_PACK"))),pee.registerFlag("WEBGL_PACK_DEPTHWISECONV",(()=>pee.getBool("WEBGL_PACK"))),pee.registerFlag("WEBGL_PACK_BINARY_OPERATIONS",(()=>pee.getBool("WEBGL_PACK"))),pee.registerFlag("WEBGL_PACK_UNARY_OPERATIONS",(()=>pee.getBool("WEBGL_PACK"))),pee.registerFlag("WEBGL_PACK_ARRAY_OPERATIONS",(()=>pee.getBool("WEBGL_PACK"))),pee.registerFlag("WEBGL_PACK_IMAGE_OPERATIONS",(()=>pee.getBool("WEBGL_PACK"))),pee.registerFlag("WEBGL_PACK_REDUCE",(()=>pee.getBool("WEBGL_PACK"))),pee.registerFlag("WEBGL_LAZILY_UNPACK",(()=>pee.getBool("WEBGL_PACK"))),pee.registerFlag("WEBGL_CONV_IM2COL",(()=>pee.getBool("WEBGL_PACK"))),pee.registerFlag("WEBGL_PACK_CONV2DTRANSPOSE",(()=>pee.getBool("WEBGL_PACK"))),pee.registerFlag("WEBGL_MAX_TEXTURE_SIZE",(()=>function(e){if(null==see){const t=D9(e);see=t.getParameter(t.MAX_TEXTURE_SIZE)}return see}(pee.getNumber("WEBGL_VERSION")))),pee.registerFlag("WEBGL_MAX_TEXTURES_IN_SHADER",(()=>function(e){if(null==iee){const t=D9(e);iee=t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS)}return Math.min(16,iee)}(pee.getNumber("WEBGL_VERSION")))),pee.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION",(()=>{const e=pee.getNumber("WEBGL_VERSION");return 0===e?0:function(e){if(0===e)return 0;let t;const n=D9(e);return t=cee(n,"EXT_disjoint_timer_query_webgl2")&&2===e?2:cee(n,"EXT_disjoint_timer_query")?1:0,t}(e)})),pee.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE",(()=>pee.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0&&!Wq())),pee.registerFlag("WEBGL_RENDER_FLOAT32_CAPABLE",(()=>function(e){if(0===e)return!1;const t=D9(e);if(1===e){if(!cee(t,"OES_texture_float"))return!1}else if(!cee(t,"EXT_color_buffer_float"))return!1;return dee(t)}(pee.getNumber("WEBGL_VERSION")))),pee.registerFlag("WEBGL_RENDER_FLOAT32_ENABLED",(()=>!pee.getBool("WEBGL_FORCE_F16_TEXTURES")&&pee.getBool("WEBGL_RENDER_FLOAT32_CAPABLE"))),pee.registerFlag("WEBGL_DOWNLOAD_FLOAT_ENABLED",(()=>uee(pee.getNumber("WEBGL_VERSION")))),pee.registerFlag("WEBGL_FENCE_API_ENABLED",(()=>{return 2===(e=pee.getNumber("WEBGL_VERSION"))&&null!=D9(e).fenceSync;var e})),pee.registerFlag("WEBGL_SIZE_UPLOAD_UNIFORM",(()=>pee.getBool("WEBGL_RENDER_FLOAT32_ENABLED")?4:0)),pee.registerFlag("WEBGL_DELETE_TEXTURE_THRESHOLD",(()=>-1),(e=>{if("number"!==typeof e)throw new Error("WEBGL_DELETE_TEXTURE_THRESHOLD must be a number but "+"got ".concat(e,"."));if(e<0&&-1!==e)throw new Error("WEBGL_DELETE_TEXTURE_THRESHOLD must be -1 (indicating never "+"delete) or at least 0, but got ".concat(e,"."))})),pee.registerFlag("WEBGL_FLUSH_THRESHOLD",(()=>Wq()?1:-1),(e=>{if("number"!==typeof e)throw new Error("WEBGL_FLUSH_THRESHOLD must be a number but got "+"".concat(e,"."));if(e<0&&-1!==e)throw new Error("WEBGL_FLUSH_THRESHOLD must be -1 (indicating never "+"manual flush) or at least 0, but got ".concat(e,"."))})),pee.registerFlag("CPU_HANDOFF_SIZE_THRESHOLD",(()=>128)),pee.registerFlag("WEBGL_USE_SHAPES_UNIFORMS",(()=>!1)),pee.registerFlag("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD",(()=>1e5)),pee.registerFlag("TOPK_K_CPU_HANDOFF_THRESHOLD",(()=>128)),pee.registerFlag("WEBGL_EXP_CONV",(()=>!1)),pee.registerFlag("SOFTWARE_WEBGL_ENABLED",(()=>pee.getBool("IS_TEST"))),pee.registerFlag("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE",(()=>1/0)),pee.registerFlag("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE",(()=>!1)),pee.registerFlag("WEBGL2_ISNAN_CUSTOM",(()=>!1)),pee.registerFlag("ENGINE_COMPILE_ONLY",(()=>!1));const xee="\n  const float FLOAT_MAX = 1.70141184e38;\n  const float FLOAT_MIN = 1.17549435e-38;\n\n  lowp vec4 encode_float(highp float v) {\n    if (isnan(v)) {\n      return vec4(255, 255, 255, 255);\n    }\n\n    highp float av = abs(v);\n\n    if(av < FLOAT_MIN) {\n      return vec4(0.0, 0.0, 0.0, 0.0);\n    } else if(v > FLOAT_MAX) {\n      return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;\n    } else if(v < -FLOAT_MAX) {\n      return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;\n    }\n\n    highp vec4 c = vec4(0,0,0,0);\n\n    highp float e = floor(log2(av));\n    highp float m = exp2(fract(log2(av))) - 1.0;\n\n    c[2] = floor(128.0 * m);\n    m -= c[2] / 128.0;\n    c[1] = floor(32768.0 * m);\n    m -= c[1] / 32768.0;\n    c[0] = floor(8388608.0 * m);\n\n    highp float ebias = e + 127.0;\n    c[3] = floor(ebias / 2.0);\n    ebias -= c[3] * 2.0;\n    c[2] += floor(ebias) * 128.0;\n\n    c[3] += 128.0 * step(0.0, -v);\n\n    return c / 255.0;\n  }\n",{getBroadcastDims:vee}=l;function wee(e,t,n){const a=[];if(e.forEach((e=>{const t=DU(e.shapeInfo.logicalShape);if(e.shapeInfo.isUniform?a.push("uniform float ".concat(e.name).concat(t>1?"[".concat(t,"]"):"",";")):(a.push("uniform sampler2D ".concat(e.name,";")),a.push("uniform int offset".concat(e.name,";"))),n.enableShapeUniforms){const{uniformShape:t}=Aee(n.packedInputs,e.shapeInfo.logicalShape,e.shapeInfo.texShape);switch(t.length){case 1:a.push("uniform int ".concat(e.name,"Shape;"));break;case 2:a.push("uniform ivec2 ".concat(e.name,"Shape;"));break;case 3:a.push("uniform ivec3 ".concat(e.name,"Shape;"));break;case 4:a.push("uniform ivec4 ".concat(e.name,"Shape;"))}a.push("uniform ivec2 ".concat(e.name,"TexShape;"))}})),n.enableShapeUniforms){switch(t.logicalShape.length){case 1:a.push("uniform int outShape;");break;case 2:a.push("uniform ivec2 outShape;"),a.push("uniform int outShapeStrides;");break;case 3:a.push("uniform ivec3 outShape;"),a.push("uniform ivec2 outShapeStrides;");break;case 4:a.push("uniform ivec4 outShape;"),a.push("uniform ivec3 outShapeStrides;")}a.push("uniform ivec2 outTexShape;")}n.customUniforms&&n.customUniforms.forEach((e=>{a.push("uniform ".concat(e.type," ").concat(e.name).concat(e.arrayIndex?"[".concat(e.arrayIndex,"]"):"",";"))}));const r=a.join("\n"),o=e.map((e=>function(e,t){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],a=arguments.length>3?arguments[3]:void 0,r="";r+=n?Iee(e,a):kee(e,a);const o=e.shapeInfo.logicalShape,s=t.logicalShape;o.length<=s.length&&(r+=n?function(e,t){const n=e.name,a=n.charAt(0).toUpperCase()+n.slice(1),r="get"+a+"AtOutCoords",o=e.shapeInfo.logicalShape.length,s=t.logicalShape.length,i=vee(e.shapeInfo.logicalShape,t.logicalShape),c=_ee(s),l=s-o;let u;const d=["x","y","z","w","u","v"];u=0===o?"":s<2&&i.length>=1?"coords = 0;":i.map((e=>"coords.".concat(d[e+l]," = 0;"))).join("\n");let h="";h=s<2&&o>0?"coords":e.shapeInfo.logicalShape.map(((e,t)=>"coords.".concat(d[t+l]))).join(", ");let p="return outputValue;";const f=1===DU(e.shapeInfo.logicalShape),m=DU(t.logicalShape),g=1===m;if(1!==o||f||g){if(f&&!g)p=1===s?"\n        return vec4(outputValue.x, outputValue.x, 0., 0.);\n      ":"\n        return vec4(outputValue.x);\n      ";else if(i.length){const e=o-2,t=o-1;i.indexOf(e)>-1&&i.indexOf(t)>-1?p="return vec4(outputValue.x);":i.indexOf(e)>-1?p="return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);":i.indexOf(t)>-1&&(p="return vec4(outputValue.xx, outputValue.zz);")}}else p="\n      return vec4(outputValue.xy, outputValue.xy);\n    ";return"\n    vec4 ".concat(r,"() {\n      ").concat(c," coords = getOutputCoords();\n      ").concat(u,"\n      vec4 outputValue = get").concat(a,"(").concat(h,");\n      ").concat(p,"\n    }\n  ")}(e,t):function(e,t){const n=e.name,a=n.charAt(0).toUpperCase()+n.slice(1),r="get"+a+"AtOutCoords",o=t.texShape,s=e.shapeInfo.texShape,i=e.shapeInfo.logicalShape.length,c=t.logicalShape.length;if(!e.shapeInfo.isUniform&&i===c&&null==e.shapeInfo.flatOffset&&MU(s,o))return"\n      float ".concat(r,"() {\n        return sampleTexture(").concat(n,", resultUV);\n      }\n    ");const l=_ee(c),u=vee(e.shapeInfo.logicalShape,t.logicalShape),d=c-i;let h;const p=["x","y","z","w","u","v"];h=0===i?"":c<2&&u.length>=1?"coords = 0;":u.map((e=>"coords.".concat(p[e+d]," = 0;"))).join("\n");let f="";f=c<2&&i>0?"coords":e.shapeInfo.logicalShape.map(((e,t)=>"coords.".concat(p[t+d]))).join(", ");return"\n    float ".concat(r,"() {\n      ").concat(l," coords = getOutputCoords();\n      ").concat(h,"\n      return get").concat(a,"(").concat(f,");\n    }\n  ")}(e,t));return r}(e,t,n.packedInputs,n.enableShapeUniforms))).join("\n"),s=t.texShape,i=fee(),c=function(e){return"\n    float sampleTexture(sampler2D textureSampler, vec2 uv) {\n      return ".concat(e.texture2D,"(textureSampler, uv).r;\n    }\n  ")}(i);let l,u,d=function(e){const t="".concat(e.version,"\n    precision highp float;\n    precision highp int;\n    precision highp sampler2D;\n    ").concat(e.varyingFs," vec2 resultUV;\n    ").concat(e.defineOutput,"\n    const vec2 halfCR = vec2(0.5, 0.5);\n\n    struct ivec5\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n    };\n\n    struct ivec6\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n      int v;\n    };\n\n    uniform float NAN;\n    ").concat(e.defineSpecialNaN,"\n    ").concat(e.defineSpecialInf,"\n    ").concat(e.defineRound,"\n\n    int imod(int x, int y) {\n      return x - y * (x / y);\n    }\n\n    int idiv(int a, int b, float sign) {\n      int res = a / b;\n      int mod = imod(a, b);\n      if (sign < 0. && mod != 0) {\n        res -= 1;\n      }\n      return res;\n    }\n\n    //Based on the work of Dave Hoskins\n    //https://www.shadertoy.com/view/4djSRW\n    #define HASHSCALE1 443.8975\n    float random(float seed){\n      vec2 p = resultUV * seed;\n      vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);\n      p3 += dot(p3, p3.yzx + 19.19);\n      return fract((p3.x + p3.y) * p3.z);\n    }\n\n    ").concat(See,"\n    ").concat(Nee,"\n    ").concat(Cee,"\n  ");return t}(i);t.isPacked?(l=function(e,t,n){switch(e.length){case 0:return"\n    int getOutputCoords() {\n      return 0;\n    }\n  ";case 1:return function(e,t,n){const a=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)];if(1===a[0])return n?"\n      int getOutputCoords() {\n        return 2 * int(resultUV.x * ceil(float(outTexShape[1]) / 2.0));\n      }\n    ":"\n      int getOutputCoords() {\n        return 2 * int(resultUV.x * ".concat(a[1],".0);\n      }\n    ");if(1===a[1])return n?"\n      int getOutputCoords() {\n        return 2 * int(resultUV.y * ceil(float(outTexShape[0]) / 2.0));\n      }\n    ":"\n      int getOutputCoords() {\n        return 2 * int(resultUV.y * ".concat(a[0],".0);\n      }\n    ");if(n)return"\n    int getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n      return 2 * (resTexRC.x * packedTexShape[1] + resTexRC.y);\n    }\n  ";return"\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(".concat(a[0],", ").concat(a[1],"));\n      return 2 * (resTexRC.x * ").concat(a[1]," + resTexRC.y);\n    }\n  ")}(0,t,n);case 2:return function(e,t,n){const a=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)];if(MU(e,t))return n?"\n      ivec2 getOutputCoords() {\n        ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n        return 2 * ivec2(resultUV.yx * vec2(packedTexShape[0], packedTexShape[1]));\n      }\n    ":"\n      ivec2 getOutputCoords() {\n        return 2 * ivec2(resultUV.yx * vec2(".concat(a[0],", ").concat(a[1],"));\n      }\n    ");const r=Math.ceil(e[1]/2);if(n)return"\n    ivec2 getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      int texelsInLogicalRow = int(ceil(float(outShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n\n      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;\n      int r = 2 * (index / texelsInLogicalRow);\n      int c = imod(index, texelsInLogicalRow) * 2;\n\n      return ivec2(r, c);\n    }\n  ";return"\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(".concat(a[0],", ").concat(a[1],"));\n\n      int index = resTexRC.x * ").concat(a[1]," + resTexRC.y;\n      int r = 2 * (index / ").concat(r,");\n      int c = imod(index, ").concat(r,") * 2;\n\n      return ivec2(r, c);\n    }\n  ")}(e,t,n);case 3:return function(e,t,n){if(n)return"\n    ivec3 getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      int texelsInLogicalRow = int(ceil(float(outShape[2]) / 2.0));\n      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;\n\n      int b = index / texelsInBatch;\n      index -= b * texelsInBatch;\n\n      int r = 2 * (index / texelsInLogicalRow);\n      int c = imod(index, texelsInLogicalRow) * 2;\n\n      return ivec3(b, r, c);\n    }\n  ";const a=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)],r=Math.ceil(e[2]/2),o=r*Math.ceil(e[1]/2);return"\n    ivec3 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(".concat(a[0],", ").concat(a[1],"));\n      int index = resTexRC.x * ").concat(a[1]," + resTexRC.y;\n\n      int b = index / ").concat(o,";\n      index -= b * ").concat(o,";\n\n      int r = 2 * (index / ").concat(r,");\n      int c = imod(index, ").concat(r,") * 2;\n\n      return ivec3(b, r, c);\n    }\n  ")}(e,t,n);default:return function(e,t,n){if(n)return"\n    ivec4 getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;\n\n      int texelsInLogicalRow = int(ceil(float(outShape[3]) / 2.0));\n      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[2]) / 2.0));\n      int texelsInBatchN = texelsInBatch * outShape[1];\n\n      int b2 = index / texelsInBatchN;\n      index -= b2 * texelsInBatchN;\n\n      int b = index / texelsInBatch;\n      index -= b * texelsInBatch;\n\n      int r = 2 * (index / texelsInLogicalRow);\n      int c = imod(index, texelsInLogicalRow) * 2;\n\n      return ivec4(b2, b, r, c);\n    }\n  ";const a=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)],r=Math.ceil(e[e.length-1]/2),o=r*Math.ceil(e[e.length-2]/2);let s=o,i="",c="b, r, c";for(let l=2;l<e.length-1;l++)s*=e[e.length-l-1],i="\n      int b".concat(l," = index / ").concat(s,";\n      index -= b").concat(l," * ").concat(s,";\n    ")+i,c="b".concat(l,", ")+c;return"\n    ivec".concat(e.length," getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(").concat(a[0],", ").concat(a[1],"));\n      int index = resTexRC.x * ").concat(a[1]," + resTexRC.y;\n\n      ").concat(i,"\n\n      int b = index / ").concat(o,";\n      index -= b * ").concat(o,";\n\n      int r = 2 * (index / ").concat(r,");\n      int c = imod(index, ").concat(r,") * 2;\n\n      return ivec").concat(e.length,"(").concat(c,");\n    }\n  ")}(e,t,n)}}(t.logicalShape,s,n.enableShapeUniforms),u=function(e){return"\n    void setOutput(vec4 val) {\n      ".concat(e.output," = val;\n    }\n  ")}(i)):(l=function(e,t,n){switch(e.length){case 0:return"\n    int getOutputCoords() {\n      return 0;\n    }\n  ";case 1:return function(e,t,n){if(1===t[0])return n?"\n      int getOutputCoords() {\n        return int(resultUV.x * float(outTexShape[1]));\n      }\n    ":"\n      int getOutputCoords() {\n        return int(resultUV.x * ".concat(t[1],".0);\n      }\n    ");if(1===t[1])return n?"\n      int getOutputCoords() {\n        return int(resultUV.y * float(outTexShape[0]));\n      }\n    ":"\n      int getOutputCoords() {\n        return int(resultUV.y * ".concat(t[0],".0);\n      }\n    ");if(n)return"\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(outTexShape[0], outTexShape[1]));\n      return resTexRC.x * outTexShape[1] + resTexRC.y;\n    }\n  ";return"\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(".concat(t[0],", ").concat(t[1],"));\n      return resTexRC.x * ").concat(t[1]," + resTexRC.y;\n    }\n  ")}(0,t,n);case 2:return function(e,t,n){if(MU(e,t))return n?"\n      ivec2 getOutputCoords() {\n        return ivec2(resultUV.yx * vec2(outTexShape[0], outTexShape[1]));\n      }\n    ":"\n      ivec2 getOutputCoords() {\n        return ivec2(resultUV.yx * vec2(".concat(t[0],", ").concat(t[1],"));\n      }\n    ");if(1===e[1])return n?"\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(outTexShape[0], outTexShape[1]));\n        int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n        return ivec2(index, 0);\n      }\n    ":"\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(".concat(t[0],", ").concat(t[1],"));\n        int index = resTexRC.x * ").concat(t[1]," + resTexRC.y;\n        return ivec2(index, 0);\n      }\n    ");if(1===e[0])return n?"\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(outTexShape[0], outTexShape[1]));\n        int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n        return ivec2(0, index);\n      }\n    ":"\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(".concat(t[0],", ").concat(t[1],"));\n        int index = resTexRC.x * ").concat(t[1]," + resTexRC.y;\n        return ivec2(0, index);\n      }\n    ");if(n)return"\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(outTexShape[0], outTexShape[1]));\n      int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n      int r = index / outShape[1];\n      int c = index - r * outShape[1];\n      return ivec2(r, c);\n    }\n  ";return"\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(".concat(t[0],", ").concat(t[1],"));\n      int index = resTexRC.x * ").concat(t[1]," + resTexRC.y;\n      int r = index / ").concat(e[1],";\n      int c = index - r * ").concat(e[1],";\n      return ivec2(r, c);\n    }\n  ")}(e,t,n);case 3:return function(e,t,n){if(n){const t=gee(["r","c","d"],e);return"\n  ivec3 getOutputCoords() {\n    ivec2 resTexRC = ivec2(resultUV.yx *\n                           vec2(outTexShape[0], outTexShape[1]));\n    int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n    ".concat(t,"\n    return ivec3(r, c, d);\n  }\n")}const a=mee(["r","c","d"],e);return"\n    ivec3 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(".concat(t[0],", ").concat(t[1],"));\n      int index = resTexRC.x * ").concat(t[1]," + resTexRC.y;\n      ").concat(a,"\n      return ivec3(r, c, d);\n    }\n  ")}(e,t,n);case 4:return function(e,t,n){if(n){const t=gee(["r","c","d","d2"],e);return"\n    ivec4 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(outTexShape[0], outTexShape[1]));\n      int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n      ".concat(t,"\n      return ivec4(r, c, d, d2);\n    }\n  ")}const a=mee(["r","c","d","d2"],e);return"\n    ivec4 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(".concat(t[0],", ").concat(t[1],"));\n      int index = resTexRC.x * ").concat(t[1]," + resTexRC.y;\n      ").concat(a,"\n      return ivec4(r, c, d, d2);\n    }\n  ")}(e,t,n);case 5:return function(e,t){const n=mee(["r","c","d","d2","d3"],e);return"\n    ivec5 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx * vec2(".concat(t[0],",\n                             ").concat(t[1],"));\n\n      int index = resTexRC.x * ").concat(t[1]," + resTexRC.y;\n\n      ").concat(n,"\n\n      ivec5 outShape = ivec5(r, c, d, d2, d3);\n      return outShape;\n    }\n  ")}(e,t);case 6:return function(e,t){const n=mee(["r","c","d","d2","d3","d4"],e);return"\n    ivec6 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(".concat(t[0],", ").concat(t[1],"));\n      int index = resTexRC.x * ").concat(t[1]," + resTexRC.y;\n\n      ").concat(n,"\n\n      ivec6 result = ivec6(r, c, d, d2, d3, d4);\n      return result;\n    }\n  ")}(e,t);default:throw new Error("".concat(e.length,"-D output sampling is not yet supported"))}}(t.logicalShape,s,n.enableShapeUniforms),u=function(e){return"\n    void setOutput(float val) {\n      ".concat(e.output," = vec4(val, 0, 0, 0);\n    }\n  ")}(i)),n.packedInputs&&(d+=Tee);return[d,c,u,r,l,o,n.userCode].join("\n")}function kee(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];const n=e.shapeInfo.logicalShape;switch(n.length){case 0:return function(e,t){const n=e.name,a="get"+n.charAt(0).toUpperCase()+n.slice(1);if(e.shapeInfo.isUniform)return"float ".concat(a,"() {return ").concat(n,";}");const[r,o]=e.shapeInfo.texShape;if(1===r&&1===o)return"\n      float ".concat(a,"() {\n        return sampleTexture(").concat(n,", halfCR);\n      }\n    ");const s=Eee(n);if(t)return"\n    float ".concat(a,"() {\n      vec2 uv = uvFromFlat(").concat(n,"TexShape[0], ").concat(n,"TexShape[1], ").concat(s,");\n      return sampleTexture(").concat(n,", uv);\n    }\n  ");const[i,c]=e.shapeInfo.texShape;return"\n    float ".concat(a,"() {\n      vec2 uv = uvFromFlat(").concat(i,", ").concat(c,", ").concat(s,");\n      return sampleTexture(").concat(n,", uv);\n    }\n  ")}(e,t);case 1:return function(e,t){const n=e.name,a="get"+n.charAt(0).toUpperCase()+n.slice(1);if(e.shapeInfo.isUniform)return"\n      float ".concat(a,"(int index) {\n        ").concat(Ree(e),"\n      }\n    ");const r=e.shapeInfo.texShape,o=r[0],s=r[1];if(1===s&&1===o)return"\n      float ".concat(a,"(int index) {\n        return sampleTexture(").concat(n,", halfCR);\n      }\n    ");const i=Eee(n);if(1===s)return t?"\n      float ".concat(a,"(int index) {\n        vec2 uv = vec2(0.5, (float(index + ").concat(i,") + 0.5) / float(").concat(n,"TexShape[0]));\n        return sampleTexture(").concat(n,", uv);\n      }\n    "):"\n      float ".concat(a,"(int index) {\n        vec2 uv = vec2(0.5, (float(index + ").concat(i,") + 0.5) / ").concat(o,".0);\n        return sampleTexture(").concat(n,", uv);\n      }\n    ");if(1===o)return t?"\n      float ".concat(a,"(int index) {\n        vec2 uv = vec2((float(index + ").concat(i,") + 0.5) / float(").concat(n,"TexShape[1]), 0.5);\n        return sampleTexture(").concat(n,", uv);\n      }\n    "):"\n      float ".concat(a,"(int index) {\n        vec2 uv = vec2((float(index + ").concat(i,") + 0.5) / ").concat(s,".0, 0.5);\n        return sampleTexture(").concat(n,", uv);\n      }\n    ");if(t)return"\n    float ".concat(a,"(int index) {\n      vec2 uv = uvFromFlat(").concat(n,"TexShape[0], ").concat(n,"TexShape[1], index + ").concat(i,");\n      return sampleTexture(").concat(n,", uv);\n    }\n  ");return"\n    float ".concat(a,"(int index) {\n      vec2 uv = uvFromFlat(").concat(o,", ").concat(s,", index + ").concat(i,");\n      return sampleTexture(").concat(n,", uv);\n    }\n  ")}(e,t);case 2:return function(e,t){const n=e.shapeInfo.logicalShape,a=e.name,r="get"+a.charAt(0).toUpperCase()+a.slice(1),o=e.shapeInfo.texShape;if(null!=o&&MU(n,o)){if(t)return"\n      float ".concat(r,"(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(").concat(a,"TexShape[1], ").concat(a,"TexShape[0]);\n        return sampleTexture(").concat(a,", uv);\n      }\n    ");const e=o[0],n=o[1];return"\n    float ".concat(r,"(int row, int col) {\n      vec2 uv = (vec2(col, row) + halfCR) / vec2(").concat(n,".0, ").concat(e,".0);\n      return sampleTexture(").concat(a,", uv);\n    }\n  ")}const{newShape:s,keptDims:i}=UU(n),c=s;if(c.length<n.length){const n=Fee(e,c),a=["row","col"];return"\n      ".concat(kee(n,t),"\n      float ").concat(r,"(int row, int col) {\n        return ").concat(r,"(").concat(Oee(a,i),");\n      }\n    ")}if(e.shapeInfo.isUniform)return"\n      float ".concat(r,"(int row, int col) {\n        int index = round(dot(vec2(row, col), vec2(").concat(n[1],", 1)));\n        ").concat(Ree(e),"\n      }\n    ");const l=o[0],u=o[1],d=Eee(a);if(1===u)return t?"\n      float ".concat(r,"(int row, int col) {\n        float index = dot(vec3(row, col, ").concat(d,"), vec3(").concat(a,"Shape[1], 1, 1));\n        vec2 uv = vec2(0.5, (index + 0.5) / float(").concat(a,"TexShape[0]));\n        return sampleTexture(").concat(a,", uv);\n      }\n    "):"\n    float ".concat(r,"(int row, int col) {\n      float index = dot(vec3(row, col, ").concat(d,"), vec3(").concat(n[1],", 1, 1));\n      vec2 uv = vec2(0.5, (index + 0.5) / ").concat(l,".0);\n      return sampleTexture(").concat(a,", uv);\n    }\n  ");if(1===l)return t?"\n      float ".concat(r,"(int row, int col) {\n        float index = dot(vec3(row, col, ").concat(d,"), vec3(").concat(a,"Shape[1], 1, 1));\n        vec2 uv = vec2((index + 0.5) / float(").concat(a,"TexShape[1]), 0.5);\n        return sampleTexture(").concat(a,", uv);\n      }\n    "):"\n    float ".concat(r,"(int row, int col) {\n      float index = dot(vec3(row, col, ").concat(d,"), vec3(").concat(n[1],", 1, 1));\n      vec2 uv = vec2((index + 0.5) / ").concat(u,".0, 0.5);\n      return sampleTexture(").concat(a,", uv);\n    }\n  ");if(t)return"\n      float ".concat(r,"(int row, int col) {\n        // Explicitly use integer operations as dot() only works on floats.\n        int index = row * ").concat(a,"Shape[1] + col + ").concat(d,";\n        vec2 uv = uvFromFlat(").concat(a,"TexShape[0], ").concat(a,"TexShape[1], index);\n        return sampleTexture(").concat(a,", uv);\n      }\n    ");return"\n  float ".concat(r,"(int row, int col) {\n    // Explicitly use integer operations as dot() only works on floats.\n    int index = row * ").concat(n[1]," + col + ").concat(d,";\n    vec2 uv = uvFromFlat(").concat(l,", ").concat(u,", index);\n    return sampleTexture(").concat(a,", uv);\n  }\n")}(e,t);case 3:return function(e,t){const n=e.shapeInfo.logicalShape,a=e.name,r="get"+a.charAt(0).toUpperCase()+a.slice(1),o=n[1]*n[2],s=n[2],{newShape:i,keptDims:c}=UU(n),l=i;if(l.length<n.length){const n=Fee(e,l),a=["row","col","depth"];return"\n        ".concat(kee(n,t),"\n        float ").concat(r,"(int row, int col, int depth) {\n          return ").concat(r,"(").concat(Oee(a,c),");\n        }\n      ")}if(e.shapeInfo.isUniform)return"\n      float ".concat(r,"(int row, int col, int depth) {\n        int index = round(dot(vec3(row, col, depth),\n                          vec3(").concat(o,", ").concat(s,", 1)));\n        ").concat(Ree(e),"\n      }\n    ");const u=e.shapeInfo.texShape,d=u[0],h=u[1],p=e.shapeInfo.flatOffset;if(h===o&&null==p)return t?"\n      float ".concat(r,"(int row, int col, int depth) {\n        int stride1 = ").concat(a,"Shape[2];\n        float texR = float(row);\n        float texC = dot(vec2(col, depth), vec2(stride1, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(").concat(a,"TexShape[1], ").concat(a,"TexShape[0]);\n        return sampleTexture(").concat(a,", uv);\n      }\n    "):"\n        float ".concat(r,"(int row, int col, int depth) {\n          float texR = float(row);\n          float texC = dot(vec2(col, depth), vec2(").concat(s,", 1));\n          vec2 uv = (vec2(texC, texR) + halfCR) /\n                     vec2(").concat(h,".0, ").concat(d,".0);\n          return sampleTexture(").concat(a,", uv);\n        }\n      ");if(h===s&&null==p)return t?"\n      float ".concat(r,"(int row, int col, int depth) {\n        float texR = dot(vec2(row, col), vec2(").concat(a,"Shape[1], 1));\n        float texC = float(depth);\n        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(").concat(a,"TexShape[1], ").concat(a,"TexShape[0]);\n        return sampleTexture(").concat(a,", uv);\n      }\n    "):"\n    float ".concat(r,"(int row, int col, int depth) {\n      float texR = dot(vec2(row, col), vec2(").concat(n[1],", 1));\n      float texC = float(depth);\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(").concat(h,".0, ").concat(d,".0);\n      return sampleTexture(").concat(a,", uv);\n    }\n  ");const f=Eee(a);if(t)return"\n    float ".concat(r,"(int row, int col, int depth) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int stride0 = ").concat(a,"Shape[1] * ").concat(a,"Shape[2];\n      int stride1 = ").concat(a,"Shape[2];\n      int index = row * stride0 + col * stride1 + depth + ").concat(f,";\n      vec2 uv = uvFromFlat(").concat(a,"TexShape[0], ").concat(a,"TexShape[1], index);\n      return sampleTexture(").concat(a,", uv);\n    }\n    ");return"\n      float ".concat(r,"(int row, int col, int depth) {\n        // Explicitly use integer operations as dot() only works on floats.\n        int index = row * ").concat(o," + col * ").concat(s," + depth + ").concat(f,";\n        vec2 uv = uvFromFlat(").concat(d,", ").concat(h,", index);\n        return sampleTexture(").concat(a,", uv);\n      }\n  ")}(e,t);case 4:return function(e,t){const n=e.shapeInfo.logicalShape,a=e.name,r="get"+a.charAt(0).toUpperCase()+a.slice(1),o=n[3],s=n[2]*o,i=n[1]*s,{newShape:c,keptDims:l}=UU(n);if(c.length<n.length){const n=Fee(e,c),a=["row","col","depth","depth2"];return"\n      ".concat(kee(n,t),"\n      float ").concat(r,"(int row, int col, int depth, int depth2) {\n        return ").concat(r,"(").concat(Oee(a,l),");\n      }\n    ")}if(e.shapeInfo.isUniform)return"\n      float ".concat(r,"(int row, int col, int depth, int depth2) {\n        int index = round(dot(vec4(row, col, depth, depth2),\n                          vec4(").concat(i,", ").concat(s,", ").concat(o,", 1)));\n        ").concat(Ree(e),"\n      }\n    ");const u=e.shapeInfo.flatOffset,d=e.shapeInfo.texShape,h=d[0],p=d[1],f="int stride2 = ".concat(a,"Shape[3];"),m="int stride1 = ".concat(a,"Shape[2] * stride2;"),g="int stride0 = ".concat(a,"Shape[1] * stride1;");if(p===i&&null==u)return t?"\n      float ".concat(r,"(int row, int col, int depth, int depth2) {\n        ").concat(f,"\n        ").concat(m,"\n        float texR = float(row);\n        float texC =\n            dot(vec3(col, depth, depth2),\n                vec3(stride1, stride2, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(").concat(a,"TexShape[1], ").concat(a,"TexShape[0]);\n        return sampleTexture(").concat(a,", uv);\n      }\n    "):"\n      float ".concat(r,"(int row, int col, int depth, int depth2) {\n        float texR = float(row);\n        float texC =\n            dot(vec3(col, depth, depth2),\n                vec3(").concat(s,", ").concat(o,", 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(").concat(p,".0, ").concat(h,".0);\n        return sampleTexture(").concat(a,", uv);\n      }\n    ");if(p===o&&null==u)return t?"\n      float ".concat(r,"(int row, int col, int depth, int depth2) {\n        float texR = dot(vec3(row, col, depth),\n                         vec3(").concat(a,"Shape[1] * ").concat(a,"Shape[2], ").concat(a,"Shape[2], 1));\n        float texC = float(depth2);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(").concat(a,"TexShape[1], ").concat(a,"TexShape[0]);\n        return sampleTexture(").concat(a,", uv);\n      }\n    "):"\n      float ".concat(r,"(int row, int col, int depth, int depth2) {\n        float texR = dot(vec3(row, col, depth),\n                         vec3(").concat(n[1]*n[2],", ").concat(n[2],", 1));\n        float texC = float(depth2);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(").concat(p,".0, ").concat(h,".0);\n        return sampleTexture(").concat(a,", uv);\n      }\n    ");const b=Eee(a);if(t)return"\n    float ".concat(r,"(int row, int col, int depth, int depth2) {\n      // Explicitly use integer operations as dot() only works on floats.\n      ").concat(f,"\n      ").concat(m,"\n      ").concat(g,"\n      int index = row * stride0 + col * stride1 +\n          depth * stride2 + depth2;\n      vec2 uv = uvFromFlat(").concat(a,"TexShape[0], ").concat(a,"TexShape[1], index + ").concat(b,");\n      return sampleTexture(").concat(a,", uv);\n    }\n  ");return"\n    float ".concat(r,"(int row, int col, int depth, int depth2) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ").concat(i," + col * ").concat(s," +\n          depth * ").concat(o," + depth2;\n      vec2 uv = uvFromFlat(").concat(h,", ").concat(p,", index + ").concat(b,");\n      return sampleTexture(").concat(a,", uv);\n    }\n  ")}(e,t);case 5:return function(e){const t=e.shapeInfo.logicalShape,n=e.name,a="get"+n.charAt(0).toUpperCase()+n.slice(1),r=t[4],o=t[3]*r,s=t[2]*o,i=t[1]*s,{newShape:c,keptDims:l}=UU(t);if(c.length<t.length){const t=Fee(e,c),n=["row","col","depth","depth2","depth3"];return"\n      ".concat(kee(t),"\n      float ").concat(a,"(int row, int col, int depth, int depth2, int depth3) {\n        return ").concat(a,"(").concat(Oee(n,l),");\n      }\n    ")}if(e.shapeInfo.isUniform)return"\n      float ".concat(a,"(int row, int col, int depth, int depth2, int depth3) {\n        float index = dot(\n          vec4(row, col, depth, depth2),\n          vec4(").concat(i,", ").concat(s,", ").concat(o,", ").concat(r,")) +\n          depth3;\n        ").concat(Ree(e),"\n      }\n    ");const u=e.shapeInfo.flatOffset,d=e.shapeInfo.texShape,h=d[0],p=d[1];if(p===i&&null==u)return"\n      float ".concat(a,"(int row, int col, int depth, int depth2, int depth3) {\n        int texR = row;\n        float texC = dot(vec4(col, depth, depth2, depth3),\n                         vec4(").concat(s,", ").concat(o,", ").concat(r,", 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(").concat(p,".0, ").concat(h,".0);\n        return sampleTexture(").concat(n,", uv);\n      }\n    ");if(p===r&&null==u)return"\n      float ".concat(a,"(int row, int col, int depth, int depth2, int depth3) {\n        float texR = dot(\n          vec4(row, col, depth, depth2),\n          vec4(").concat(t[1]*t[2]*t[3],",\n               ").concat(t[2]*t[3],", ").concat(t[3],", 1));\n        int texC = depth3;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(").concat(p,".0, ").concat(h,".0);\n        return sampleTexture(").concat(n,", uv);\n      }\n    ");const f=Eee(n);return"\n    float ".concat(a,"(int row, int col, int depth, int depth2, int depth3) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ").concat(i," + col * ").concat(s," + depth * ").concat(o," +\n          depth2 * ").concat(r," + depth3 + ").concat(f,";\n      vec2 uv = uvFromFlat(").concat(h,", ").concat(p,", index);\n      return sampleTexture(").concat(n,", uv);\n    }\n  ")}(e);case 6:return function(e){const t=e.shapeInfo.logicalShape,n=e.name,a="get"+n.charAt(0).toUpperCase()+n.slice(1),{newShape:r,keptDims:o}=UU(t);if(r.length<t.length){const t=Fee(e,r),n=["row","col","depth","depth2","depth3","depth4"];return"\n      ".concat(kee(t),"\n      float ").concat(a,"(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        return ").concat(a,"(").concat(Oee(n,o),");\n      }\n    ")}const s=t[5],i=t[4]*s,c=t[3]*i,l=t[2]*c,u=t[1]*l;if(e.shapeInfo.isUniform)return"\n      float ".concat(a,"(int row, int col, int depth,\n                  int depth2, int depth3, int depth4) {\n        int index = round(dot(\n          vec4(row, col, depth, depth2),\n          vec4(").concat(u,", ").concat(l,", ").concat(c,", ").concat(i,")) +\n          dot(\n            vec2(depth3, depth4),\n            vec2(").concat(s,", 1)));\n        ").concat(Ree(e),"\n      }\n    ");const d=e.shapeInfo.flatOffset,h=e.shapeInfo.texShape,p=h[0],f=h[1];if(f===u&&null==d)return"\n      float ".concat(a,"(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        int texR = row;\n        float texC = dot(vec4(col, depth, depth2, depth3),\n          vec4(").concat(l,", ").concat(c,", ").concat(i,", ").concat(s,")) +\n               float(depth4);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(").concat(f,".0, ").concat(p,".0);\n        return sampleTexture(").concat(n,", uv);\n      }\n    ");if(f===s&&null==d)return"\n      float ".concat(a,"(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        float texR = dot(vec4(row, col, depth, depth2),\n          vec4(").concat(t[1]*t[2]*t[3]*t[4],",\n               ").concat(t[2]*t[3]*t[4],",\n               ").concat(t[3]*t[4],",\n               ").concat(t[4],")) + float(depth3);\n        int texC = depth4;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(").concat(f,".0, ").concat(p,".0);\n        return sampleTexture(").concat(n,", uv);\n      }\n    ");const m=Eee(n);return"\n    float ".concat(a,"(int row, int col, int depth,\n                  int depth2, int depth3, int depth4) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ").concat(u," + col * ").concat(l," + depth * ").concat(c," +\n          depth2 * ").concat(i," + depth3 * ").concat(s," + depth4 + ").concat(m,";\n      vec2 uv = uvFromFlat(").concat(p,", ").concat(f,", index);\n      return sampleTexture(").concat(n,", uv);\n    }\n  ")}(e);default:throw new Error("".concat(n.length,"-D input sampling")+" is not yet supported")}}function Iee(e,t){switch(e.shapeInfo.logicalShape.length){case 0:return function(e){const t=e.name,n="get"+t.charAt(0).toUpperCase()+t.slice(1),a=fee();return"\n    vec4 ".concat(n,"() {\n      return ").concat(a.texture2D,"(").concat(t,", halfCR);\n    }\n  ")}(e);case 1:return function(e,t){const n=e.name,a="get"+n.charAt(0).toUpperCase()+n.slice(1),r=e.shapeInfo.texShape,o=fee();if(t)return"\n    vec4 ".concat(a,"(int index) {\n      ivec2 packedTexShape = ivec2(ceil(float(").concat(n,"TexShape[0]) / 2.0), ceil(float(").concat(n,"TexShape[1]) / 2.0));\n      vec2 uv = packedUVfrom1D(\n        packedTexShape[0], packedTexShape[1], index);\n      return ").concat(o.texture2D,"(").concat(n,", uv);\n    }\n  ");const s=[Math.ceil(r[0]/2),Math.ceil(r[1]/2)];return"\n    vec4 ".concat(a,"(int index) {\n      vec2 uv = packedUVfrom1D(\n        ").concat(s[0],", ").concat(s[1],", index);\n      return ").concat(o.texture2D,"(").concat(n,", uv);\n    }\n  ")}(e,t);case 2:return function(e,t){const n=e.shapeInfo.logicalShape,a=e.name,r="get"+a.charAt(0).toUpperCase()+a.slice(1),o=e.shapeInfo.texShape,s=o[0],i=o[1],c=fee();if(null!=o&&MU(n,o))return t?"\n      vec4 ".concat(r,"(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(").concat(a,"TexShape[1], ").concat(a,"TexShape[0]);\n\n        return ").concat(c.texture2D,"(").concat(a,", uv);\n      }\n    "):"\n      vec4 ".concat(r,"(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(").concat(i,".0, ").concat(s,".0);\n\n        return ").concat(c.texture2D,"(").concat(a,", uv);\n      }\n    ");if(t)return"\n    vec4 ".concat(r,"(int row, int col) {\n      ivec2 packedTexShape = ivec2(ceil(float(").concat(a,"TexShape[0]) / 2.0), ceil(float(").concat(a,"TexShape[1]) / 2.0));\n      int valuesPerRow = int(ceil(float(").concat(a,"Shape[1]) / 2.0));\n      vec2 uv = packedUVfrom2D(valuesPerRow, packedTexShape[0], packedTexShape[1], row, col);\n      return ").concat(c.texture2D,"(").concat(a,", uv);\n    }\n  ");const l=[Math.ceil(o[0]/2),Math.ceil(o[1]/2)],u=Math.ceil(n[1]/2);return"\n    vec4 ".concat(r,"(int row, int col) {\n      vec2 uv = packedUVfrom2D(").concat(u,", ").concat(l[0],", ").concat(l[1],", row, col);\n      return ").concat(c.texture2D,"(").concat(a,", uv);\n    }\n  ")}(e,t);case 3:return function(e,t){const n=e.shapeInfo.logicalShape,a=e.name,r="get"+a.charAt(0).toUpperCase()+a.slice(1),o=e.shapeInfo.texShape,s=[Math.ceil(o[0]/2),Math.ceil(o[1]/2)];if(1===n[0]){const a=[1,2],o=Fee(e,n.slice(1)),s=["b","row","col"];return"\n        ".concat(Iee(o,t),"\n        vec4 ").concat(r,"(int b, int row, int col) {\n          return ").concat(r,"(").concat(Oee(s,a),");\n        }\n      ")}const i=fee();if(t)return"\n    vec4 ".concat(r,"(int b, int row, int col) {\n      ivec2 packedTexShape = ivec2(ceil(float(").concat(a,"TexShape[0]) / 2.0), ceil(float(").concat(a,"TexShape[1]) / 2.0));\n      int valuesPerRow = int(ceil(float(").concat(a,"Shape[2]) / 2.0));\n      int texelsInBatch = valuesPerRow * int(ceil(float(").concat(a,"Shape[1]) / 2.0));\n      vec2 uv = packedUVfrom3D(\n        packedTexShape[0], packedTexShape[1], texelsInBatch, valuesPerRow, b, row, col);\n      return ").concat(i.texture2D,"(").concat(a,", uv);\n    }\n  ");const c=s[0],l=s[1],u=Math.ceil(n[2]/2),d=u*Math.ceil(n[1]/2);return"\n    vec4 ".concat(r,"(int b, int row, int col) {\n      vec2 uv = packedUVfrom3D(\n        ").concat(c,", ").concat(l,", ").concat(d,", ").concat(u,", b, row, col);\n      return ").concat(i.texture2D,"(").concat(a,", uv);\n    }\n  ")}(e,t);default:return function(e,t){const n=e.name,a="get"+n.charAt(0).toUpperCase()+n.slice(1),r=fee();if(t)return"\n    vec4 ".concat(a,"(int b2, int b, int row, int col) {\n      int valuesPerRow = int(ceil(float(").concat(n,"Shape[3]) / 2.0));\n      int texelsInBatch = valuesPerRow * int(ceil(float(").concat(n,"Shape[2]) / 2.0));\n      int index = b * texelsInBatch + (row / 2) * valuesPerRow + (col / 2);\n      texelsInBatch *= ").concat(n,"Shape[1];\n      index = b2 * texelsInBatch + index;\n      ivec2 packedTexShape = ivec2(ceil(float(").concat(n,"TexShape[0]) / 2.0), ceil(float(").concat(n,"TexShape[1]) / 2.0));\n      int texR = index / packedTexShape[1];\n      int texC = index - texR * packedTexShape[1];\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(packedTexShape[1], packedTexShape[0]); return ").concat(r.texture2D,"(").concat(n,", uv);\n    }\n  ");const o=e.shapeInfo.logicalShape,s=o.length,i=e.shapeInfo.texShape,c=[Math.ceil(i[0]/2),Math.ceil(i[1]/2)],l=c[0],u=c[1],d=Math.ceil(o[s-1]/2);let h=d*Math.ceil(o[s-2]/2),p="int b, int row, int col",f="b * ".concat(h," + (row / 2) * ").concat(d," + (col / 2)");for(let m=2;m<s-1;m++)p="int b".concat(m,", ")+p,h*=o[s-m-1],f="b".concat(m," * ").concat(h," + ")+f;return"\n    vec4 ".concat(a,"(").concat(p,") {\n      int index = ").concat(f,";\n      int texR = index / ").concat(u,";\n      int texC = index - texR * ").concat(u,";\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(").concat(u,", ").concat(l,");\n      return ").concat(r.texture2D,"(").concat(n,", uv);\n    }\n  ")}(e,t)}}const See="\nvec2 uvFromFlat(int texNumR, int texNumC, int index) {\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\nvec2 packedUVfrom1D(int texNumR, int texNumC, int index) {\n  int texelIndex = index / 2;\n  int texR = texelIndex / texNumC;\n  int texC = texelIndex - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",Nee="\nvec2 packedUVfrom2D(int texelsInLogicalRow, int texNumR,\n  int texNumC, int row, int col) {\n  int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);\n  int texR = texelIndex / texNumC;\n  int texC = texelIndex - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",Cee="\nvec2 packedUVfrom3D(int texNumR, int texNumC,\n    int texelsInBatch, int texelsInLogicalRow, int b,\n    int row, int col) {\n  int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",Tee="\n  float getChannel(vec4 frag, vec2 innerDims) {\n    vec2 modCoord = mod(innerDims, 2.);\n    return modCoord.x == 0. ?\n      (modCoord.y == 0. ? frag.r : frag.g) :\n      (modCoord.y == 0. ? frag.b : frag.a);\n  }\n  float getChannel(vec4 frag, int dim) {\n    float modCoord = mod(float(dim), 2.);\n    return modCoord == 0. ? frag.r : frag.g;\n  }\n";function Eee(e){return"offset".concat(e)}function Ree(e){const t=e.name,n=DU(e.shapeInfo.logicalShape);return n<2?"return ".concat(t,";"):"\n    for (int i = 0; i < ".concat(n,"; i++) {\n      if (i == index) {\n        return ").concat(t,"[i];\n      }\n    }\n  ")}function _ee(e){if(e<=1)return"int";if(2===e)return"ivec2";if(3===e)return"ivec3";if(4===e)return"ivec4";if(5===e)return"ivec5";if(6===e)return"ivec6";throw Error("GPU for rank ".concat(e," is not yet supported"))}function Aee(e,t,n){const{newShape:a,keptDims:r}=UU(t),o=t.length,s=e&&3===o&&1===t[0],i=s?t.slice(1):a,c=!e&&o>1&&!MU(t,n)&&a.length<o||s;return{useSqueezeShape:c,uniformShape:c?i:t,keptDims:r}}function Fee(e,t){const n=JSON.parse(JSON.stringify(e));return n.shapeInfo.logicalShape=t,n}function Oee(e,t){return t.map((t=>e[t])).join(", ")}function Dee(e,t,n,a){const r=n.map(((e,n)=>{const a={logicalShape:e.shape,texShape:e.isUniform?null:e.texData.texShape,isUniform:e.isUniform,isPacked:!e.isUniform&&e.texData.isPacked,flatOffset:null};return null!=e.texData&&null!=e.texData.slice&&e.texData.slice.flatOffset>0&&(a.flatOffset=e.texData.slice.flatOffset),{name:t.variableNames[n],shapeInfo:a}})),o=r.map((e=>e.shapeInfo)),s={logicalShape:a.shape,texShape:a.texData.texShape,isUniform:!1,isPacked:a.texData.isPacked,flatOffset:null},i=wee(r,s,t),c=function(e,t){const n=$9(e,(()=>e.createShader(e.FRAGMENT_SHADER)),"Unable to create fragment WebGLShader.");if(U9(e,(()=>e.shaderSource(n,t))),U9(e,(()=>e.compileShader(n))),uG().get("ENGINE_COMPILE_ONLY"))return n;if(!1===e.getShaderParameter(n,e.COMPILE_STATUS))throw K9(t,e.getShaderInfoLog(n)),new Error("Failed to compile fragment shader.");return n}(e.gl,i),l=e.createProgram(c);return uG().get("ENGINE_COMPILE_ONLY")?{program:t,fragmentShader:c,source:i,webGLProgram:l,inShapeInfos:o,outShapeInfo:s,variablesLocations:null,customUniformLocations:null,infLoc:null,nanLoc:null,outShapeLocation:null,outShapeStridesLocation:null,outTexShapeLocation:null}:(e.buildVao(l),Object.assign({program:t,fragmentShader:c,source:i,webGLProgram:l,inShapeInfos:o,outShapeInfo:s},Mee(e,t,l)))}function Mee(e,t,n){const a=[],r=[];let o,s,i,c=null,l=null;l=e.getUniformLocation(n,"NAN",!1),1===uG().getNumber("WEBGL_VERSION")&&(c=e.getUniformLocation(n,"INFINITY",!1));const u=!1;for(const d of t.variableNames){const r={name:d,uniform:e.getUniformLocation(n,d,u),offset:e.getUniformLocation(n,"offset".concat(d),u)};t.enableShapeUniforms&&(r.shape=e.getUniformLocation(n,"".concat(d,"Shape"),u),r.texShape=e.getUniformLocation(n,"".concat(d,"TexShape"),u)),a.push(r)}if(t.enableShapeUniforms&&(o=e.getUniformLocation(n,"outShape",u),i=e.getUniformLocation(n,"outShapeStrides",u),s=e.getUniformLocation(n,"outTexShape",u)),t.customUniforms)for(const d of t.customUniforms)r.push(e.getUniformLocation(n,d.name,u));return{variablesLocations:a,customUniformLocations:r,infLoc:c,nanLoc:l,outShapeLocation:o,outShapeStridesLocation:i,outTexShapeLocation:s}}function Lee(e,t){if(e.length!==t.length)throw Error("Binary was compiled with ".concat(e.length," inputs, but ")+"was executed with ".concat(t.length," inputs"));e.forEach(((e,n)=>{const a=e.logicalShape,r=t[n],o=r.shape;if(!MU(a,o))throw Error("Binary was compiled with different shapes than "+"the current args. Shapes ".concat(a," and ").concat(o," must match"));if(e.isUniform&&r.isUniform)return;const s=e.texShape,i=r.isUniform?null:r.texData.texShape;if(!MU(s,i))throw Error("Binary was compiled with different texture shapes than the"+" current args. Shape ".concat(s," and ").concat(i," must match"))}))}function Pee(e){return uG().getBool("WEBGL_USE_SHAPES_UNIFORMS")&&e<=4}class zee{constructor(e){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outPackingScheme=M9.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];const t=fee();this.outputShape=e,this.enableShapeUniforms=Pee(this.outputShape.length),this.userCode="\n      ivec3 outCoordsFromFlatIndex(int index) {\n        ".concat(this.enableShapeUniforms?gee(["r","c","d"],e):mee(["r","c","d"],e),"\n        return ivec3(r, c, d);\n      }\n\n      void main() {\n        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));\n        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);\n\n        vec4 result = vec4(0.);\n\n        for (int i=0; i<4; i++) {\n          int flatIndex = index + i;\n          ivec3 rc = outCoordsFromFlatIndex(flatIndex);\n          result[i] = getA(rc.x, rc.y, rc.z);\n        }\n\n        ").concat(t.output," = result;\n      }\n    ")}}class Bee{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outPackingScheme=M9.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];const t=fee();this.outputShape=e,this.enableShapeUniforms=Pee(this.outputShape.length),this.userCode="\n      ivec3 outCoordsFromFlatIndex(int index) {\n        ".concat(this.enableShapeUniforms?gee(["r","c","d"],e):mee(["r","c","d"],e),"\n        return ivec3(r, c, d);\n      }\n\n      void main() {\n        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));\n        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);\n\n        vec4 result = vec4(0.);\n\n        for (int i=0; i<4; i++) {\n          int flatIndex = index + i;\n          ivec3 rc = outCoordsFromFlatIndex(flatIndex);\n          result[i] = getChannel(getA(rc.x, rc.y, rc.z), vec2(rc.y, rc.z));\n        }\n\n        ").concat(t.output," = result;\n      }\n    ")}}class Wee{constructor(e){this.variableNames=["A"],this.outTexUsage=L9.DOWNLOAD;const t=fee();this.outputShape=e,this.userCode="\n      ".concat(xee,"\n\n      void main() {\n        float x = getAAtOutCoords();\n        ").concat(t.output," = encode_float(x);\n      }\n    ")}}class Vee{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outTexUsage=L9.DOWNLOAD;const t=fee();this.outputShape=e,this.userCode="\n      ".concat(xee,"\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n        float x = getChannel(getAAtOutCoords(), vec2(coords.y, coords.z));\n        ").concat(t.output," = encode_float(x);\n      }\n    ")}}const Uee={R:0,G:1,B:2,A:3};class Gee{constructor(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1],n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"RGBA";this.variableNames=["A"],this.customUniforms=[{name:"texShape",type:"ivec2"}];const a=fee();this.outputShape=e,this.enableShapeUniforms=Pee(this.outputShape.length);let r="result";t&&(r="floor(result * 255. + 0.5)");let o="";for(let s=0;s<n.length;s++){const e=n[s];o+="\n          if(offset == ".concat(s,") {\n            result = values[").concat(Uee[e],"];\n          }")}this.userCode="\n      ".concat(this.enableShapeUniforms?"\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;\n  }\n":yee(e),"\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int flatIndex = getFlatIndex(coords);\n        float result = 0.;\n        int offset = imod(flatIndex, ").concat(n.length,");\n\n        flatIndex = idiv(flatIndex, ").concat(n.length,", 1.);\n\n        int r = flatIndex / texShape[1];\n        if (r < texShape[0]) {\n          int c = imod(flatIndex, texShape[1]);\n          vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);\n          vec4 values = ").concat(a.texture2D,"(A, uv);\n          ").concat(o,"\n        }\n        ").concat(a.output," = vec4(").concat(r,", 0., 0., 0.);\n      }\n    ")}}class Hee{constructor(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.customUniforms=[{name:"texShape",type:"ivec2"}];const n=fee();this.outputShape=e,this.enableShapeUniforms=Pee(this.outputShape.length);let a="",r="result";t&&(r="floor(result * 255. + 0.5)");for(let o=0;o<=1;o++)for(let t=0;t<=1;t++){const r=2*o+t;a+="\n          localCoords = coords;\n          if(localCoords[2] + ".concat(t," < ").concat(this.enableShapeUniforms?"outShape[2]":"".concat(e[2]),") {\n          localCoords[2] += ").concat(t,";\n          if (localCoords[1] + ").concat(o," < ").concat(this.enableShapeUniforms?"outShape[1]":"".concat(e[1]),") {\n            localCoords[1] += ").concat(o,";\n\n            flatIndex = getFlatIndex(localCoords);\n            offset = imod(flatIndex, 4);\n\n            flatIndex = idiv(flatIndex, 4, 1.);\n\n            int r = flatIndex / texShape[1];\n            int c = imod(flatIndex, texShape[1]);\n            vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);\n            values = ").concat(n.texture2D,"(A, uv);\n\n            if (offset == 0) {\n              result[").concat(r,"] = values[0];\n            } else if (offset == 1) {\n              result[").concat(r,"] = values[1];\n            } else if (offset == 2) {\n              result[").concat(r,"] = values[2];\n            } else {\n              result[").concat(r,"] = values[3];\n            }\n          }\n        }\n        ")}this.userCode="\n        ".concat(this.enableShapeUniforms?"\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;\n  }\n":yee(e),"\n\n        void main() {\n          ivec3 coords = getOutputCoords();\n\n          vec4 result = vec4(0.);\n          int flatIndex, r, c, offset;\n          ivec3 localCoords;\n          vec2 uv;\n          vec4 values;\n\n          ").concat(a,"\n\n          ").concat(n.output," = ").concat(r,";\n        }\n    ")}}function jee(e){const t=fee();return function(e,t){const n=$9(e,(()=>e.createShader(e.VERTEX_SHADER)),"Unable to create vertex WebGLShader.");if(U9(e,(()=>e.shaderSource(n,t))),U9(e,(()=>e.compileShader(n))),!1===e.getShaderParameter(n,e.COMPILE_STATUS))throw console.log(e.getShaderInfoLog(n)),new Error("Failed to compile vertex shader.");return n}(e,"".concat(t.version,"\n    precision highp float;\n    ").concat(t.attribute," vec3 clipSpacePos;\n    ").concat(t.attribute," vec2 uv;\n    ").concat(t.varyingVs," vec2 resultUV;\n\n    void main() {\n      gl_Position = vec4(clipSpacePos, 1);\n      resultUV = uv;\n    }"))}function Kee(e){return function(e,t){const n=$9(e,(()=>e.createBuffer()),"Unable to create WebGLBuffer");return U9(e,(()=>e.bindBuffer(e.ARRAY_BUFFER,n))),U9(e,(()=>e.bufferData(e.ARRAY_BUFFER,t,e.STATIC_DRAW))),n}(e,new Float32Array([-1,1,0,0,1,-1,-1,0,0,0,1,1,0,1,1,1,-1,0,1,0]))}function qee(e){return function(e,t){const n=$9(e,(()=>e.createBuffer()),"Unable to create WebGLBuffer");return U9(e,(()=>e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,n))),U9(e,(()=>e.bufferData(e.ELEMENT_ARRAY_BUFFER,t,e.STATIC_DRAW))),n}(e,new Uint16Array([0,1,2,2,1,3]))}function Xee(e,t,n,a,r,o){!function(e,t){const n=uG().getNumber("WEBGL_MAX_TEXTURE_SIZE");if(e<=0||t<=0){const n="[".concat(e,"x").concat(t,"]");throw new Error("Requested texture size "+n+" is invalid.")}if(e>n||t>n){const a="[".concat(e,"x").concat(t,"]"),r="[".concat(n,"x").concat(n,"]");throw new Error("Requested texture size "+a+" greater than WebGL maximum on this browser / GPU "+r+".")}}(t,n);const s=function(e){return $9(e,(()=>e.createTexture()),"Unable to create WebGLTexture.")}(e),i=e.TEXTURE_2D;return U9(e,(()=>e.bindTexture(i,s))),U9(e,(()=>e.texParameteri(i,e.TEXTURE_WRAP_S,e.CLAMP_TO_EDGE))),U9(e,(()=>e.texParameteri(i,e.TEXTURE_WRAP_T,e.CLAMP_TO_EDGE))),U9(e,(()=>e.texParameteri(i,e.TEXTURE_MIN_FILTER,e.NEAREST))),U9(e,(()=>e.texParameteri(i,e.TEXTURE_MAG_FILTER,e.NEAREST))),1===uG().getNumber("WEBGL_VERSION")?U9(e,(()=>e.texImage2D(i,0,a,t,n,0,r,o,null))):U9(e,(()=>e.texStorage2D(i,1,a,t,n))),U9(e,(()=>e.bindTexture(e.TEXTURE_2D,null))),{texture:s,texShape:[n,t]}}function Yee(e){return e.internalFormatFloat}function Qee(e){return e.internalFormatHalfFloat}function Jee(e){return e.downloadTextureFormat}function Zee(e){return e.internalFormatPackedFloat}function $ee(e){return e.internalFormatPackedHalfFloat}function ete(e,t,n,a,r,o,s,i){const c=e,l=new Float32Array(function(e,t){const[n,a]=W9(e,t);return n*a*4}(o,s));return c.bindBuffer(c.PIXEL_PACK_BUFFER,t),c.getBufferSubData(c.PIXEL_PACK_BUFFER,0,l),c.bindBuffer(c.PIXEL_PACK_BUFFER,null),l}class tte{constructor(e){this.outputTexture=null,this.program=null,this.disposed=!1,this.itemsToPoll=[];const t=uG().getNumber("WEBGL_VERSION");if(null!=e?(this.gl=e,function(e,t){F9[e]=t}(t,e)):this.gl=D9(t),e=this.gl,2===uG().getNumber("WEBGL_VERSION")){const t=e;this.createVertexArray=()=>U9(t,(()=>t.createVertexArray())),this.bindVertexArray=e=>U9(t,(()=>t.bindVertexArray(e))),this.deleteVertexArray=e=>U9(t,(()=>t.deleteVertexArray(e))),this.getVertexArray=()=>U9(t,(()=>t.getParameter(t.VERTEX_ARRAY_BINDING)))}else if(null!=e){const t=e.getExtension("OES_vertex_array_object");if(null==t)throw new Error("All WebGL1 implementations are expected to offer OES_vertex_array_object.");this.createVertexArray=()=>U9(e,(()=>t.createVertexArrayOES())),this.bindVertexArray=n=>U9(e,(()=>t.bindVertexArrayOES(n))),this.deleteVertexArray=n=>U9(e,(()=>t.deleteVertexArrayOES(n))),this.getVertexArray=()=>U9(e,(()=>e.getParameter(t.VERTEX_ARRAY_BINDING_OES)))}let n="WEBGL_color_buffer_float";const a="EXT_color_buffer_half_float";if(this.parallelCompilationExtension=this.gl.getExtension("KHR_parallel_shader_compile"),1===uG().getNumber("WEBGL_VERSION")){const e="OES_texture_float",t="OES_texture_half_float";if(this.textureFloatExtension=H9(this.gl,e),cee(this.gl,t))this.textureHalfFloatExtension=H9(this.gl,t);else if(uG().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support half float textures, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.");if(this.colorBufferFloatExtension=this.gl.getExtension(n),cee(this.gl,a))this.colorBufferHalfFloatExtension=H9(this.gl,a);else if(uG().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support color renderable half floats, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.")}else if(n="EXT_color_buffer_float",cee(this.gl,n))this.colorBufferFloatExtension=this.gl.getExtension(n);else{if(!cee(this.gl,a))throw new Error("GL context does not support color renderable floats");this.colorBufferHalfFloatExtension=this.gl.getExtension(a)}this.vertexBuffer=Kee(this.gl),this.indexBuffer=qee(this.gl),this.framebuffer=function(e){return $9(e,(()=>e.createFramebuffer()),"Unable to create WebGLFramebuffer.")}(this.gl),this.textureConfig=V9(this.gl,this.textureHalfFloatExtension)}get debug(){return uG().getBool("DEBUG")}dispose(){if(this.disposed)return;null!=this.program&&console.warn("Disposing a GPGPUContext that still has a bound WebGLProgram. This is probably a resource leak, delete the program with GPGPUContext.deleteProgram before disposing."),null!=this.outputTexture&&console.warn("Disposing a GPGPUContext that still has a bound output matrix texture.  This is probably a resource leak, delete the output matrix texture with GPGPUContext.deleteMatrixTexture before disposing.");const e=this.gl;U9(e,(()=>e.finish())),U9(e,(()=>e.bindFramebuffer(e.FRAMEBUFFER,null))),U9(e,(()=>e.deleteFramebuffer(this.framebuffer))),U9(e,(()=>e.bindBuffer(e.ARRAY_BUFFER,null))),U9(e,(()=>e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,null))),U9(e,(()=>e.deleteBuffer(this.indexBuffer))),this.disposed=!0}createFloat32MatrixTexture(e,t){return this.throwIfDisposed(),function(e,t,n,a){const[r,o]=z9(t,n);return Xee(e,r,o,Yee(a),a.textureFormatFloat,e.FLOAT)}(this.gl,e,t,this.textureConfig)}createFloat16MatrixTexture(e,t){return this.throwIfDisposed(),function(e,t,n,a){const[r,o]=z9(t,n);return Xee(e,r,o,Qee(a),a.textureFormatFloat,a.textureTypeHalfFloat)}(this.gl,e,t,this.textureConfig)}createUnsignedBytesMatrixTexture(e,t){return this.throwIfDisposed(),function(e,t,n,a){const[r,o]=z9(t,n);return Xee(e,r,o,Jee(a),e.RGBA,e.UNSIGNED_BYTE)}(this.gl,e,t,this.textureConfig)}uploadPixelDataToTexture(e,t){this.throwIfDisposed(),function(e,t,n){U9(e,(()=>e.bindTexture(e.TEXTURE_2D,t))),n.data instanceof Uint8Array?2===uG().getNumber("WEBGL_VERSION")?U9(e,(()=>e.texSubImage2D(e.TEXTURE_2D,0,0,0,n.width,n.height,e.RGBA,e.UNSIGNED_BYTE,n.data))):U9(e,(()=>e.texImage2D(e.TEXTURE_2D,0,e.RGBA,n.width,n.height,0,e.RGBA,e.UNSIGNED_BYTE,n.data))):2===uG().getNumber("WEBGL_VERSION")?U9(e,(()=>e.texSubImage2D(e.TEXTURE_2D,0,0,0,e.RGBA,e.UNSIGNED_BYTE,n))):U9(e,(()=>e.texImage2D(e.TEXTURE_2D,0,e.RGBA,e.RGBA,e.UNSIGNED_BYTE,n))),U9(e,(()=>e.bindTexture(e.TEXTURE_2D,null)))}(this.gl,e,t)}uploadDenseMatrixToTexture(e,t,n,a){this.throwIfDisposed(),function(e,t,n,a,r,o){let s,i,c;U9(e,(()=>e.bindTexture(e.TEXTURE_2D,t))),r instanceof Uint8Array?(s=new Uint8Array(n*a*4),i=e.UNSIGNED_BYTE,c=e.RGBA):(s=new Float32Array(n*a*4),i=e.FLOAT,c=o.internalFormatPackedFloat),s.set(r),2===uG().getNumber("WEBGL_VERSION")?U9(e,(()=>e.texSubImage2D(e.TEXTURE_2D,0,0,0,n,a,e.RGBA,i,s))):U9(e,(()=>e.texImage2D(e.TEXTURE_2D,0,c,n,a,0,e.RGBA,i,s))),U9(e,(()=>e.bindTexture(e.TEXTURE_2D,null)))}(this.gl,e,t,n,a,this.textureConfig)}createFloat16PackedMatrixTexture(e,t){return this.throwIfDisposed(),function(e,t,n,a){const[r,o]=W9(t,n);return Xee(e,r,o,$ee(a),e.RGBA,a.textureTypeHalfFloat)}(this.gl,e,t,this.textureConfig)}createPackedMatrixTexture(e,t){return this.throwIfDisposed(),function(e,t,n,a){const[r,o]=W9(t,n);return Xee(e,r,o,Zee(a),e.RGBA,e.FLOAT)}(this.gl,e,t,this.textureConfig)}deleteMatrixTexture(e){this.throwIfDisposed(),this.outputTexture===e&&(J9(this.gl,this.framebuffer),this.outputTexture=null),U9(this.gl,(()=>this.gl.deleteTexture(e)))}downloadByteEncodedFloatMatrixFromOutputTexture(e,t,n){return this.downloadMatrixDriver(e,(()=>function(e,t,n,a){const[r,o]=z9(t,n),s=new Uint8Array(t*n*4);return U9(e,(()=>e.readPixels(0,0,r,o,a.downloadTextureFormat,e.UNSIGNED_BYTE,s))),new Float32Array(s.buffer)}(this.gl,t,n,this.textureConfig)))}downloadPackedMatrixFromBuffer(e,t,n,a,r,o){return ete(this.gl,e,0,0,0,r,o,this.textureConfig)}downloadFloat32MatrixFromBuffer(e,t){return function(e,t,n){const a=e,r=new Float32Array(n);return a.bindBuffer(a.PIXEL_PACK_BUFFER,t),a.getBufferSubData(a.PIXEL_PACK_BUFFER,0,r),a.bindBuffer(a.PIXEL_PACK_BUFFER,null),r}(this.gl,e,t)}createBufferFromTexture(e,t,n){this.bindTextureToFrameBuffer(e);const a=function(e,t,n,a){const r=e.createBuffer();U9(e,(()=>e.bindBuffer(e.PIXEL_PACK_BUFFER,r)));const o=16*t*n;return U9(e,(()=>e.bufferData(e.PIXEL_PACK_BUFFER,o,e.STREAM_READ))),U9(e,(()=>e.readPixels(0,0,n,t,e.RGBA,e.FLOAT,0))),U9(e,(()=>e.bindBuffer(e.PIXEL_PACK_BUFFER,null))),r}(this.gl,t,n,this.textureConfig);return this.unbindTextureToFrameBuffer(),a}createAndWaitForFence(){const e=this.createFence(this.gl);return this.pollFence(e)}createFence(e){let t,n;if(uG().getBool("WEBGL_FENCE_API_ENABLED")){const a=e,r=a.fenceSync(a.SYNC_GPU_COMMANDS_COMPLETE,0);e.flush(),n=()=>{const e=a.clientWaitSync(r,0,0);return e===a.ALREADY_SIGNALED||e===a.CONDITION_SATISFIED},t=r}else uG().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0?(t=this.beginQuery(),this.endQuery(),n=()=>this.isQueryAvailable(t,uG().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))):n=()=>!0;return{query:t,isFencePassed:n}}downloadMatrixFromPackedTexture(e,t,n){return this.downloadMatrixDriver(e,(()=>function(e,t,n){const a=new Float32Array(t*n*4);return U9(e,(()=>e.readPixels(0,0,n,t,e.RGBA,e.FLOAT,a))),a}(this.gl,t,n)))}createProgram(e){this.throwIfDisposed();const t=this.gl;null==this.vertexShader&&(this.vertexShader=jee(t));const n=function(e){return $9(e,(()=>e.createProgram()),"Unable to create WebGLProgram.")}(t);U9(t,(()=>t.attachShader(n,this.vertexShader))),U9(t,(()=>t.attachShader(n,e))),function(e,t){if(U9(e,(()=>e.linkProgram(t))),!uG().get("ENGINE_COMPILE_ONLY")&&!1===e.getProgramParameter(t,e.LINK_STATUS))throw console.log(e.getProgramInfoLog(t)),new Error("Failed to link vertex and fragment shaders.")}(t,n);const a=Object.assign(n,{vao:this.createVertexArray()});return this.debug&&q9(t,a),a}buildVao(e){this.setProgram(e),this.bindVertexArray(e.vao);const t=this.gl;U9(t,(()=>t.bindBuffer(t.ELEMENT_ARRAY_BUFFER,this.indexBuffer))),function(e,t,n){U9(e,(()=>e.bindBuffer(e.ARRAY_BUFFER,n))),X9(e,t,"clipSpacePos",n,3,20,0)&&X9(e,t,"uv",n,2,20,12)}(t,e,this.vertexBuffer)}deleteProgram(e){this.throwIfDisposed(),e===this.program&&(this.program=null),null!=e&&(U9(this.gl,(()=>this.gl.deleteProgram(e))),this.deleteVertexArray(e.vao))}setProgram(e){this.throwIfDisposed(),this.program=e,null!=this.program&&this.debug&&q9(this.gl,this.program),U9(this.gl,(()=>this.gl.useProgram(e)))}getUniformLocation(e,t){let n=!(arguments.length>2&&void 0!==arguments[2])||arguments[2];return this.throwIfDisposed(),n?function(e,t,n){return $9(e,(()=>e.getUniformLocation(t,n)),'uniform "'+n+'" not present in program.')}(this.gl,e,t):function(e,t,n){return e.getUniformLocation(t,n)}(this.gl,e,t)}getAttributeLocation(e,t){return this.throwIfDisposed(),U9(this.gl,(()=>this.gl.getAttribLocation(e,t)))}getUniformLocationNoThrow(e,t){return this.throwIfDisposed(),this.gl.getUniformLocation(e,t)}setInputMatrixTexture(e,t,n){this.throwIfDisposed(),this.throwIfNoProgram(),Y9(this.gl,e,t,n)}setOutputMatrixTexture(e,t,n){this.setOutputMatrixTextureDriver(e,n,t)}setOutputPackedMatrixTexture(e,t,n){this.throwIfDisposed();const[a,r]=W9(t,n);this.setOutputMatrixTextureDriver(e,a,r)}setOutputMatrixWriteRegion(e,t,n,a){this.setOutputMatrixWriteRegionDriver(n,e,a,t)}setOutputPackedMatrixWriteRegion(e,t,n,a){throw new Error("setOutputPackedMatrixWriteRegion not implemented.")}debugValidate(){null!=this.program&&q9(this.gl,this.program),Z9(this.gl)}executeProgram(){this.throwIfDisposed(),this.throwIfNoProgram();const e=this.gl;if(this.debug){const e=this.getVertexArray();console.assert(e===this.program.vao,"VAO changed between setProgram and executeProgram!"),this.debugValidate()}U9(e,(()=>e.drawElements(e.TRIANGLES,6,e.UNSIGNED_SHORT,0)))}blockUntilAllProgramsCompleted(){this.throwIfDisposed(),U9(this.gl,(()=>this.gl.finish()))}getQueryTimerExtension(){return null==this.disjointQueryTimerExtension&&(this.disjointQueryTimerExtension=H9(this.gl,2===uG().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")?"EXT_disjoint_timer_query_webgl2":"EXT_disjoint_timer_query")),this.disjointQueryTimerExtension}getQueryTimerExtensionWebGL2(){return this.getQueryTimerExtension()}getQueryTimerExtensionWebGL1(){return this.getQueryTimerExtension()}beginQuery(){if(2===uG().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")){const e=this.gl,t=this.getQueryTimerExtensionWebGL2(),n=e.createQuery();return e.beginQuery(t.TIME_ELAPSED_EXT,n),n}const e=this.getQueryTimerExtensionWebGL1(),t=e.createQueryEXT();return e.beginQueryEXT(e.TIME_ELAPSED_EXT,t),t}endQuery(){if(2===uG().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")){const e=this.gl,t=this.getQueryTimerExtensionWebGL2();return void e.endQuery(t.TIME_ELAPSED_EXT)}const e=this.getQueryTimerExtensionWebGL1();e.endQueryEXT(e.TIME_ELAPSED_EXT)}async waitForQueryAndGetTime(e){return await BU((()=>this.disposed||this.isQueryAvailable(e,uG().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")))),this.getQueryTime(e,uG().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))}getQueryTime(e,t){if(0===t)return null;if(2===t){const t=this.gl;return t.getQueryParameter(e,t.QUERY_RESULT)/1e6}{const t=this.getQueryTimerExtensionWebGL1();return t.getQueryObjectEXT(e,t.QUERY_RESULT_EXT)/1e6}}isQueryAvailable(e,t){if(0===t)return!0;if(2===t){const t=this.gl,n=this.getQueryTimerExtensionWebGL2(),a=t.getQueryParameter(e,t.QUERY_RESULT_AVAILABLE);return null==this.disjoint&&(this.disjoint=this.gl.getParameter(n.GPU_DISJOINT_EXT)),a&&!this.disjoint}{const t=this.getQueryTimerExtensionWebGL1(),n=t.getQueryObjectEXT(e,t.QUERY_RESULT_AVAILABLE_EXT);return null==this.disjoint&&(this.disjoint=this.gl.getParameter(t.GPU_DISJOINT_EXT)),n&&!this.disjoint}}pollFence(e){return new Promise((t=>{this.addItemToPoll((()=>e.isFencePassed()),(()=>t()))}))}pollItems(){const e=function(e){let t=0;for(;t<e.length;++t){if(!e[t]())break}return t-1}(this.itemsToPoll.map((e=>e.isDoneFn)));for(let t=0;t<=e;++t){const{resolveFn:e}=this.itemsToPoll[t];e()}this.itemsToPoll=this.itemsToPoll.slice(e+1)}addItemToPoll(e,t){if(this.itemsToPoll.push({isDoneFn:e,resolveFn:t}),this.itemsToPoll.length>1)return;let n;"setTimeoutCustom"in uG().platform&&(n=uG().platform.setTimeoutCustom.bind(uG().platform)),BU((()=>(this.pollItems(),0===this.itemsToPoll.length)),(()=>0),null,n)}bindTextureToFrameBuffer(e){this.throwIfDisposed(),Q9(this.gl,e,this.framebuffer),this.debug&&Z9(this.gl)}unbindTextureToFrameBuffer(){null!=this.outputTexture?(Q9(this.gl,this.outputTexture,this.framebuffer),this.debug&&Z9(this.gl)):J9(this.gl,this.framebuffer)}downloadMatrixDriver(e,t){this.bindTextureToFrameBuffer(e);const n=t();return this.unbindTextureToFrameBuffer(),n}setOutputMatrixTextureDriver(e,t,n){this.throwIfDisposed();const a=this.gl;Q9(a,e,this.framebuffer),this.debug&&Z9(a),this.outputTexture=e,U9(a,(()=>a.viewport(0,0,t,n))),U9(a,(()=>a.scissor(0,0,t,n)))}setOutputMatrixWriteRegionDriver(e,t,n,a){this.throwIfDisposed(),U9(this.gl,(()=>this.gl.scissor(e,t,n,a)))}throwIfDisposed(){if(this.disposed)throw new Error("Attempted to use disposed GPGPUContext.")}throwIfNoProgram(){if(null==this.program)throw new Error("No GPU program is currently set.")}}const{addImpl:nte,bincountImpl:ate,bincountReduceImpl:rte,bitwiseAndImpl:ote,castImpl:ste,ceilImpl:ite,concatImpl:cte,equalImpl:lte,expImpl:ute,expm1Impl:dte,floorImpl:hte,gatherNdImpl:pte,gatherV2Impl:fte,greaterImpl:mte,greaterEqualImpl:gte,lessImpl:bte,lessEqualImpl:yte,linSpaceImpl:xte,logImpl:vte,maxImpl:wte,maximumImpl:kte,minimumImpl:Ite,multiplyImpl:Ste,negImpl:Nte,notEqualImpl:Cte,prodImpl:Tte,raggedGatherImpl:Ete,raggedRangeImpl:Rte,raggedTensorToTensorImpl:_te,rangeImpl:Ate,rsqrtImpl:Fte,scatterImpl:Ote,sigmoidImpl:Dte,simpleAbsImpl:Mte,sliceImpl:Lte,sparseFillEmptyRowsImpl:Pte,sparseReshapeImpl:zte,sparseSegmentReductionImpl:Bte,sqrtImpl:Wte,staticRegexReplaceImpl:Vte,stridedSliceImpl:Ute,stringNGramsImpl:Gte,stringSplitImpl:Hte,stringToHashBucketFastImpl:jte,subImpl:Kte,tileImpl:qte,topKImpl:Xte,transposeImpl:Yte,uniqueImpl:Qte}=u;function Jte(e,t){return["x","y","z","w","u","v"].slice(0,t).map((t=>"".concat(e,".").concat(t)))}function Zte(e,t){return 1===t?[e]:Jte(e,t)}class $te{constructor(e){if(this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outputShape=e,this.rank=e.length,this.enableShapeUniforms=Pee(this.outputShape.length),0===this.rank)this.userCode="\n        void main() {\n          setOutput(vec4(getA(), 0., 0., 0.));\n        }\n      ";else{const e=Zte("rc",this.rank),t=_ee(this.rank),n=this.getOutOfBoundsCondition(e),a=this.getSetup(e),r=this.getOutput(e);this.userCode="\n        void main() {\n          ".concat(t," rc = getOutputCoords();\n\n          if(").concat(n,") {\n            setOutput(vec4(0));\n          } else {\n            ").concat(a,"\n\n            setOutput(vec4(").concat(r,"));\n          }\n        }\n      ")}}getSourceCoordsArr(e){const t=[];for(let n=0;n<=1;n++)for(let a=0;a<=1;a++){let r="".concat(0===n?"r":"rp1",", ").concat(0===a?"c":"cp1");for(let t=2;t<this.rank;t++)r="".concat(e[e.length-1-t],",")+r;t.push(r)}return t}getOutOfBoundsCondition(e){if(1===this.rank)return"rc > ".concat(this.enableShapeUniforms?"outShape":this.outputShape[0]);let t="";for(let n=this.rank-2;n<this.rank;n++)t+="".concat(e[n]," >= ").concat(this.enableShapeUniforms?"outShape[".concat(n,"]"):this.outputShape[n]),n<this.rank-1&&(t+="||");return t}getSetup(e){if(1===this.rank)return"";const t=e.slice(-2),n=this.enableShapeUniforms?"outShape[".concat(this.rank," - 1]"):this.outputShape[this.rank-1],a=this.enableShapeUniforms?"outShape[".concat(this.rank," - 2]"):this.outputShape[this.rank-2];return"\n      int r = ".concat(t[0],";\n      int c = ").concat(t[1],";\n      int rp1 = r + 1;\n      int cp1 = c + 1;\n\n      bool cEdge = cp1 >= ").concat(n,";\n      bool rEdge = rp1 >= ").concat(a,";\n    ")}getOutput(e){const t=this.getSourceCoordsArr(e);if(1===this.rank){const e=this.enableShapeUniforms?"outShape":this.outputShape[0];return"getA(rc), (rc + 1 >= ".concat(e," ? 0. : getA(rc + 1)), 0, 0")}return"getA(".concat(t[0],"),\n            cEdge ? 0. : getA(").concat(t[1],"),\n            rEdge ? 0. : getA(").concat(t[2],"),\n            rEdge || cEdge ? 0. : getA(").concat(t[3],")")}}class ene{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec3"}],this.outputShape=e,this.enableShapeUniforms=Pee(this.outputShape.length);let n="";for(let a=0;a<4;a++){let e="thisRC = rc;";a%2===1&&(e+="thisRC.z += 1;"),a>1&&(e+="thisRC.y += 1;"),n+="\n        ".concat(e,"\n        ").concat(a>0?"if(thisRC.y < rows && thisRC.z < cols){":"","\n          int flatIndex = getFlatIndex(thisRC);\n\n          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flatIndex);\n          vec2 inputRCInnerDims = vec2(float(inputRC.y),float(inputRC.z));\n\n          result[").concat(a,"] =\n            getChannel(getA(inputRC.x, inputRC.y, inputRC.z), inputRCInnerDims);\n        ").concat(a>0?"}":"","\n      ")}this.userCode="\n      ".concat(function(e,t){const n=t?bee(["r","c","d"],"inputShape"):mee(["r","c","d"],e);return"\n    ivec3 inputCoordsFromReshapedOutCoords(int index) {\n      ".concat(n,"\n      return ivec3(r, c, d);\n    }\n  ")}(t,this.enableShapeUniforms),"\n      ").concat(this.enableShapeUniforms?"\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;\n  }\n":yee(e),"\n\n      void main() {\n        ivec3 rc = getOutputCoords();\n\n        vec4 result = vec4(0.);\n\n        ivec3 thisRC;\n        int rows = ").concat(this.enableShapeUniforms?"outShape[1]":e[1],";\n        int cols = ").concat(this.enableShapeUniforms?"outShape[2]":e[2],";\n\n        ").concat(n,"\n\n        setOutput(result);\n      }\n    ")}}class tne{constructor(e){this.gpgpu=e,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0,this.freeTextures={},this.usedTextures={},this.logEnabled=!1}acquireTexture(e,t,n){const a=ane(t,n),r=rne(e,a,n);r in this.freeTextures||(this.freeTextures[r]=[]),r in this.usedTextures||(this.usedTextures[r]=[]);const o=nne(e,a,this.gpgpu.gl,this.gpgpu.textureConfig,n);if(this.freeTextures[r].length>0){this.numFreeTextures--,this.numUsedTextures++,this._numBytesFree-=o,this.log();const e=this.freeTextures[r].pop();return this.usedTextures[r].push(e),e}let s;return a===P9.PACKED_2X2_FLOAT32?s=this.gpgpu.createPackedMatrixTexture(e[0],e[1]):a===P9.PACKED_2X2_FLOAT16?s=this.gpgpu.createFloat16PackedMatrixTexture(e[0],e[1]):a===P9.UNPACKED_FLOAT32?s=this.gpgpu.createFloat32MatrixTexture(e[0],e[1]):a===P9.UNPACKED_FLOAT16?s=this.gpgpu.createFloat16MatrixTexture(e[0],e[1]):a===P9.PACKED_4X1_UNSIGNED_BYTE&&(s=this.gpgpu.createUnsignedBytesMatrixTexture(e[0],e[1])),this.usedTextures[r].push(s),this.numUsedTextures++,this._numBytesAllocated+=o,this.log(),s}releaseTexture(e,t,n,a){if(null==this.freeTextures)return;const r=ane(n,a),o=rne(t,r,a);o in this.freeTextures||(this.freeTextures[o]=[]);const s=nne(t,r,this.gpgpu.gl,this.gpgpu.textureConfig,a),i=uG().getNumber("WEBGL_DELETE_TEXTURE_THRESHOLD");-1!==i&&this._numBytesAllocated>i?(this.gpgpu.deleteMatrixTexture(e.texture),this._numBytesAllocated-=s):(this.freeTextures[o].push(e),this.numFreeTextures++,this._numBytesFree+=s),this.numUsedTextures--;const c=this.usedTextures[o],l=c&&c.indexOf(e);if(null==l||l<0)throw new Error("Cannot release a texture that was never provided by this texture manager");c[l]=c[c.length-1],c.pop(),this.log()}log(){if(!this.logEnabled)return;const e=this.numFreeTextures+this.numUsedTextures;console.log("Free/Used","".concat(this.numFreeTextures," / ").concat(this.numUsedTextures),"(".concat(e,")"));const t=this._numBytesFree/this._numBytesAllocated;console.log("Bytes allocated: ".concat(this._numBytesAllocated)),console.log("Bytes unused: ".concat(this._numBytesFree," (").concat(Math.round(100*t),"%)"))}get numBytesAllocated(){return this._numBytesAllocated}get numBytesFree(){return this._numBytesFree}getNumUsedTextures(){return this.numUsedTextures}getNumFreeTextures(){return this.numFreeTextures}dispose(){if(null!=this.freeTextures){for(const e in this.freeTextures)this.freeTextures[e].forEach((e=>{this.gpgpu.deleteMatrixTexture(e.texture)}));for(const e in this.usedTextures)this.usedTextures[e].forEach((e=>{this.gpgpu.deleteMatrixTexture(e.texture)}));this.freeTextures=null,this.usedTextures=null,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0}}}function nne(e,t,n,a,r){const o=function(e,t){switch(e){case P9.PACKED_2X2_FLOAT32:return Zee(t);case P9.PACKED_2X2_FLOAT16:return $ee(t);case P9.UNPACKED_FLOAT32:return Yee(t);case P9.UNPACKED_FLOAT16:return Qee(t);case P9.PACKED_4X1_UNSIGNED_BYTE:return Jee(t);default:throw new Error("Unknown physical texture type ".concat(e))}}(t,a);let s;if(r){const[t,n]=W9(e[0],e[1]);s=t*n}else{const[t,n]=z9(e[0],e[1]);s=t*n}const i=function(e,t){const n=e;if(t===n.R32F)return 4;if(t===n.R16F)return 2;if(t===n.RGBA32F)return 16;if(t===e.RGBA)return 16;if(t===n.RGBA16F)return 8;if(t===n.RGBA8)return 4;throw new Error("Unknown internal format ".concat(t))}(n,o);return s*i}function ane(e,t){if(e===L9.UPLOAD)return P9.PACKED_2X2_FLOAT32;if(e===L9.RENDER||null==e)return function(e){return uG().getBool("WEBGL_RENDER_FLOAT32_ENABLED")?e?P9.PACKED_2X2_FLOAT32:P9.UNPACKED_FLOAT32:e?P9.PACKED_2X2_FLOAT16:P9.UNPACKED_FLOAT16}(t);if(e===L9.DOWNLOAD||e===L9.PIXELS)return P9.PACKED_4X1_UNSIGNED_BYTE;throw new Error("Unknown logical texture type ".concat(e))}function rne(e,t,n){return"".concat(e[0],"_").concat(e[1],"_").concat(t,"_").concat(n)}class one{constructor(e,t){this.variableNames=["A"],this.outputShape=e,this.enableShapeUniforms=Pee(this.outputShape.length),this.userCode="\n      float unaryOperation(float x) {\n        ".concat(t,"\n      }\n\n      void main() {\n        float x = getAAtOutCoords();\n        float y = unaryOperation(x);\n\n        setOutput(y);\n      }\n    ")}}const sne="if (isnan(x)) return x;",ine="return x;",cne="return abs(x);";const lne="return (x >= 0.0) ? x : (exp(x) - 1.0);",une=sne+"\n  return (x < 0.0) ? 0.0 : x;\n",dne=sne+"\n  return (x < 0.0) ? 0.0 : min(6.0, x);\n",hne="return x;",pne="return 1.0 / (1.0 + exp(-1.0 * x));",fne="return x;",mne="\n  vec4 result;\n\n  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);\n  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);\n  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);\n  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);\n\n  return result;\n",gne="\n  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n",bne="\n  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n",yne="return 1.0 / (1.0 + exp(-1.0 * x));";class xne{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.enableShapeUniforms=Pee(this.outputShape.length),this.userCode="\n      vec4 unaryOperation(vec4 x) {\n        ".concat(t,"\n      }\n\n      void main() {\n        vec4 x = getAAtOutCoords();\n        vec4 y = unaryOperation(x);\n\n        setOutput(y);\n      }\n    ")}}class vne{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outputShape=e,this.enableShapeUniforms=Pee(this.outputShape.length);const t=e.length,n=Zte("rc",t),a=_ee(t),r=function(e,t){if(1===e)return"rc";let n="";for(let a=0;a<e;a++)n+=t[a],a<e-1&&(n+=",");return n}(t,n),o=n.slice(-2),s=t<=1?"rc":"vec2(".concat(o.join(","),")");this.userCode="\n      void main() {\n        ".concat(a," rc = getOutputCoords();\n        vec4 packedInput = getA(").concat(r,");\n\n        setOutput(getChannel(packedInput, ").concat(s,"));\n      }\n    ")}}const wne=x0,kne={};const Ine=uG().getNumber("CPU_HANDOFF_SIZE_THRESHOLD");class Sne extends CU{nextDataId(){return Sne.nextDataId++}constructor(e){if(super(),this.pendingRead=new WeakMap,this.pendingDisposal=new WeakSet,this.dataRefCount=new WeakMap,this.numBytesInGPU=0,this.uploadWaitMs=0,this.downloadWaitMs=0,this.lastGlFlushTime=0,this.warnedAboutMemory=!1,this.pendingDeletes=0,this.disposed=!1,!uG().getBool("HAS_WEBGL"))throw new Error("WebGL is not supported on this device");let t;if(null!=e){if(e instanceof tte)t=e;else{const n=D9(uG().getNumber("WEBGL_VERSION"),e);t=new tte(n)}this.binaryCache={},this.gpgpuCreatedLocally=!1}else{const e=D9(uG().getNumber("WEBGL_VERSION"));t=new tte(e),this.binaryCache=((n=uG().getNumber("WEBGL_VERSION"))in kne||(kne[n]={}),kne[n]),this.gpgpuCreatedLocally=!0}var n;this.gpgpu=t,this.canvas=this.gpgpu.gl.canvas,this.textureManager=new tne(this.gpgpu),this.numMBBeforeWarning=null==uG().global.screen?1024:uG().global.screen.height*uG().global.screen.width*window.devicePixelRatio*600/1024/1024,this.texData=new NU(this,tX())}numDataIds(){return this.texData.numDataIds()-this.pendingDeletes}writeTexture(e,t,n,a,r,o){const s=this.makeTensorInfo(t,n),i=this.texData.get(s.dataId);i.isPacked=!1,i.texture={texture:e,texShape:[a,r]},i.texShape=[a,r];const c=aee(t),l=new Gee(c,!1,o),u=this.runWebGLProgram(l,[s],n,[[a,r]]);return u.shape=t,i.texture=null,this.disposeIntermediateTensorInfo(s),u.dataId}write(e,t,n){if((uG().getBool("WEBGL_CHECK_NUMERICAL_PROBLEMS")||uG().getBool("DEBUG"))&&this.checkNumericalProblems(e),"complex64"===n&&null!=e)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");const a={id:this.nextDataId()};return this.texData.set(a,{shape:t,dtype:n,values:e,usage:L9.UPLOAD,refCount:1}),a}refCount(e){if(this.texData.has(e)){return this.texData.get(e).refCount}return 0}incRef(e){this.texData.get(e).refCount++}decRef(e){if(this.texData.has(e)){this.texData.get(e).refCount--}}move(e,t,n,a,r){if(uG().getBool("DEBUG")&&this.checkNumericalProblems(t),"complex64"===a)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");this.texData.set(e,{shape:n,dtype:a,values:t,usage:L9.UPLOAD,refCount:r})}disposeIntermediateTensorInfo(e){this.disposeData(e.dataId)}readSync(e){const t=this.texData.get(e),{values:n,dtype:a,complexTensorInfos:r,slice:o,shape:s,isPacked:i}=t;if(null!=o){let t;t=i?new xne(s,hne):new one(s,hne);const n=this.runWebGLProgram(t,[{dataId:e,shape:s,dtype:a}],a),r=this.readSync(n.dataId);return this.disposeIntermediateTensorInfo(n),r}if(null!=n)return this.convertAndCacheOnCPU(e);if("string"===a)return n;const c=null!=this.activeTimers;let l,u;if(c&&(l=JK()),"complex64"===a){u=g2(this.readSync(r.real.dataId),this.readSync(r.imag.dataId))}else u=this.getValuesFromTexture(e);return c&&(this.downloadWaitMs+=JK()-l),this.convertAndCacheOnCPU(e,u)}async read(e){if(this.pendingRead.has(e)){const t=this.pendingRead.get(e);return new Promise((e=>t.push(e)))}const t=this.texData.get(e),{values:n,shape:a,slice:r,dtype:o,complexTensorInfos:s,isPacked:i}=t;if(null!=r){let t;t=i?new xne(a,hne):new one(a,hne);const n=this.runWebGLProgram(t,[{dataId:e,shape:a,dtype:o}],o),r=this.read(n.dataId);return this.disposeIntermediateTensorInfo(n),r}if(null!=n)return this.convertAndCacheOnCPU(e);if(uG().getBool("DEBUG")&&!uG().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")&&2===uG().getNumber("WEBGL_VERSION"))throw new Error("tensor.data() with WEBGL_DOWNLOAD_FLOAT_ENABLED=false and WEBGL_VERSION=2 not yet supported.");let c,l,u=null;if("complex64"!==o&&uG().get("WEBGL_BUFFER_SUPPORTED")){c=this.decode(e);const t=this.texData.get(c.dataId);u=this.gpgpu.createBufferFromTexture(t.texture.texture,...B9(a))}if(this.pendingRead.set(e,[]),"complex64"!==o&&await this.gpgpu.createAndWaitForFence(),"complex64"===o){const e=await Promise.all([this.read(s.real.dataId),this.read(s.imag.dataId)]);l=g2(e[0],e[1])}else if(null==u)l=this.getValuesFromTexture(e);else{const e=DU(a);l=this.gpgpu.downloadFloat32MatrixFromBuffer(u,e)}if(null!=c&&this.disposeIntermediateTensorInfo(c),null!=u){const e=this.gpgpu.gl;U9(e,(()=>e.deleteBuffer(u)))}const d=this.convertAndCacheOnCPU(e,l),h=this.pendingRead.get(e);return this.pendingRead.delete(e),h.forEach((e=>e(d))),this.pendingDisposal.has(e)&&(this.pendingDisposal.delete(e),this.disposeData(e)&&tX().removeDataId(e,this),this.pendingDeletes--),d}readToGPU(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const n=this.texData.get(e),{values:a,shape:r,slice:o,dtype:s,isPacked:i,texture:c}=n;if("complex64"===s)throw new Error("Does not support reading texture for complex64 dtype.");if(null!=o){let n;n=i?new xne(r,hne):new one(r,hne);const a=this.runWebGLProgram(n,[{dataId:e,shape:r,dtype:s}],s),o=this.readToGPU(a,t);return this.disposeIntermediateTensorInfo(a),o}if(null==c)throw null!=a?new Error("Data is not on GPU but on CPU."):new Error("There is no data on GPU or CPU.");const l=this.decode(e,t.customTexShape),u=tX().makeTensorFromTensorInfo(l),d=this.texData.get(l.dataId);return Object.assign({tensorRef:u},d.texture)}bufferSync(e){const t=this.readSync(e.dataId);if("string"===e.dtype)try{const n=t.map((e=>$K(e)));return cY(e.shape,e.dtype,n)}catch(n){throw new Error("Failed to decode encoded string bytes into utf-8")}return cY(e.shape,e.dtype,t)}checkNumericalProblems(e){if(null!=e)for(let t=0;t<e.length;t++){const n=e[t];if(!G9(n)){if(uG().getBool("WEBGL_RENDER_FLOAT32_CAPABLE"))throw Error("The value ".concat(n," cannot be represented with your ")+"current settings. Consider enabling float32 rendering: 'tf.env().set('WEBGL_RENDER_FLOAT32_ENABLED', true);'");throw Error("The value ".concat(n," cannot be represented on this device."))}}}getValuesFromTexture(e){const{shape:t,dtype:n,isPacked:a}=this.texData.get(e),r=DU(t);if(uG().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")){const n=this.decode(e),a=this.texData.get(n.dataId),o=this.gpgpu.downloadMatrixFromPackedTexture(a.texture.texture,...B9(t)).subarray(0,r);return this.disposeIntermediateTensorInfo(n),o}const o=uG().getBool("WEBGL_PACK")&&!0===a,s=o?aee(t):t,i=o?new Vee(s):new Wee(s),c=this.runWebGLProgram(i,[{shape:s,dtype:n,dataId:e}],"float32"),l=this.texData.get(c.dataId),u=this.gpgpu.downloadByteEncodedFloatMatrixFromOutputTexture(l.texture.texture,l.texShape[0],l.texShape[1]).subarray(0,r);return this.disposeIntermediateTensorInfo(c),u}timerAvailable(){return uG().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0}time(e){const t=this.activeTimers,n=[];let a=!1;null==this.programTimersStack?(this.programTimersStack=n,a=!0):this.activeTimers.push(n),this.activeTimers=n,e();const r=tq(this.activeTimers.map((e=>e.query))).filter((e=>null!=e)),o=tq(this.activeTimers.map((e=>e.name))).filter((e=>null!=e));this.activeTimers=t,a&&(this.programTimersStack=null);const s={uploadWaitMs:this.uploadWaitMs,downloadWaitMs:this.downloadWaitMs,kernelMs:null,wallMs:null};return(async()=>{if(uG().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0){const e=await Promise.all(r);s.kernelMs=function(e){let t=0;for(let n=0;n<e.length;n++)t+=e[n];return t}(e),s.getExtraProfileInfo=()=>e.map(((e,t)=>({name:o[t],ms:e}))).map((e=>"".concat(e.name,": ").concat(e.ms))).join(", ")}else s.kernelMs={error:"WebGL query timers are not supported in this environment."};return this.uploadWaitMs=0,this.downloadWaitMs=0,s})()}memory(){return{unreliable:!1,numBytesInGPU:this.numBytesInGPU,numBytesInGPUAllocated:this.textureManager.numBytesAllocated,numBytesInGPUFree:this.textureManager.numBytesFree}}startTimer(){return uG().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?this.gpgpu.beginQuery():{startMs:JK(),endMs:null}}endTimer(e){return uG().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?(this.gpgpu.endQuery(),e):(e.endMs=JK(),e)}async getQueryTime(e){if(uG().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0)return this.gpgpu.waitForQueryAndGetTime(e);const t=e;return t.endMs-t.startMs}disposeData(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];if(this.pendingDisposal.has(e))return!1;if(!this.texData.has(e))return!0;if(t?this.texData.get(e).refCount=0:this.texData.get(e).refCount--,!t&&this.texData.get(e).refCount>0)return!1;if(this.pendingRead.has(e))return this.pendingDisposal.add(e),this.pendingDeletes++,!1;this.releaseGPUData(e);const{complexTensorInfos:n}=this.texData.get(e);return null!=n&&(this.disposeData(n.real.dataId,t),this.disposeData(n.imag.dataId,t)),this.texData.delete(e),!0}releaseGPUData(e){const{texture:t,dtype:n,texShape:a,usage:r,isPacked:o,slice:s}=this.texData.get(e),i=s&&s.origDataId||e,c=this.dataRefCount.get(i);c>1?this.dataRefCount.set(i,c-1):(this.dataRefCount.delete(i),null!=t&&(this.numBytesInGPU-=this.computeBytes(a,n),this.textureManager.releaseTexture(t,a,r,o)));const l=this.texData.get(e);l.texture=null,l.texShape=null,l.isPacked=!1,l.slice=null}getTexture(e){return this.uploadToGPU(e),this.texData.get(e).texture.texture}getDataInfo(e){return this.texData.get(e)}shouldExecuteOnCPU(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:Ine;return uG().getBool("WEBGL_CPU_FORWARD")&&e.every((e=>null==this.texData.get(e.dataId).texture&&DU(e.shape)<t))}getGPGPUContext(){return this.gpgpu}where(e){CK("tf.where() in webgl locks the UI thread. Call tf.whereAsync() instead");const t=e.dataSync();return wne(e.shape,t)}packedUnaryOp(e,t,n){const a=new xne(e.shape,t),r=this.compileAndRun(a,[e],n);return tX().makeTensorFromTensorInfo(r)}abs(e){if(this.shouldExecuteOnCPU([e])&&"complex64"!==e.dtype){const t=Mte(this.texData.get(e.dataId).values);return this.makeOutput(e.shape,e.dtype,t)}if(uG().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(e,cne,e.dtype);const t=new one(e.shape,cne),n=this.compileAndRun(t,[e]);return tX().makeTensorFromTensorInfo(n)}makeTensorInfo(e,t,n){let a;if("string"===t&&null!=n&&n.length>0&&qU(n[0])){const r=n.map((e=>ZK(e)));a=this.write(r,e,t)}else a=this.write(n,e,t);return this.texData.get(a).usage=null,{dataId:a,shape:e,dtype:t}}makeOutput(e,t,n){return tX().makeTensorFromTensorInfo(this.makeTensorInfo(e,t,n),this)}unpackTensor(e){const t=new vne(e.shape);return this.runWebGLProgram(t,[e],e.dtype)}packTensor(e){const t=new $te(e.shape);return this.runWebGLProgram(t,[e],e.dtype,null,!0)}packedReshape(e,t){const n=[tee(e.shape),...nee(e.shape)],a={dtype:e.dtype,shape:n,dataId:e.dataId},r=[tee(t),...nee(t)],o=new ene(r,n),s=[n],i=this.runWebGLProgram(o,[a],e.dtype,s,!0);return{dataId:i.dataId,shape:t,dtype:i.dtype}}decode(e,t){const n=this.texData.get(e),{isPacked:a,shape:r,dtype:o}=n;if(null!=t){AU(DU(r)<=t[0]*t[1]*4,(()=>"customTexShape is too small. Row * Column * 4 should be equal or larger than the size of the tensor data."))}const s=aee(r);let i;i=a?new Bee(s):new zee(s);const c=[null!=t?t:B9(s)];return{dtype:o,shape:r,dataId:this.runWebGLProgram(i,[{shape:s,dtype:o,dataId:e}],o,c,!0,t).dataId}}runWebGLProgram(e,t,n,a){let r=arguments.length>4&&void 0!==arguments[4]&&arguments[4],o=arguments.length>5?arguments[5]:void 0;const s=this.makeTensorInfo(e.outputShape,n),i=this.texData.get(s.dataId);if(e.packedOutput&&(i.isPacked=!0),e.outPackingScheme===M9.DENSE){const t=null!=o?o:B9(e.outputShape);i.texShape=t.map((e=>2*e))}if(null!=e.outTexUsage&&(i.usage=e.outTexUsage),0===DU(s.shape))return i.values=GU(s.dtype,0),s;const c=[],l=t.map((t=>{if("complex64"===t.dtype)throw new Error("GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.");let n=this.texData.get(t.dataId);if(null==n.texture){if(!e.packedInputs&&DU(t.shape)<=uG().getNumber("WEBGL_SIZE_UPLOAD_UNIFORM"))return{shape:t.shape,texData:null,isUniform:!0,uniformValues:n.values};e.packedInputs&&(n.isPacked=!0,n.shape=t.shape)}if(this.uploadToGPU(t.dataId),!!n.isPacked!==!!e.packedInputs)t=n.isPacked?this.unpackTensor(t):this.packTensor(t),c.push(t),n=this.texData.get(t.dataId);else if(n.isPacked&&!oee(n.shape,t.shape)){const e=t,a=t.shape;t.shape=n.shape,t=this.packedReshape(t,a),c.push(t),n=this.texData.get(t.dataId),e.shape=a}return{shape:t.shape,texData:n,isUniform:!1}}));this.uploadToGPU(s.dataId);const u={shape:s.shape,texData:i,isUniform:!1},d=function(e,t,n){let a="";t.concat(n).forEach((t=>{const r=null!=t.texData&&null!=t.texData.slice&&t.texData.slice.flatOffset>0;if(e.enableShapeUniforms&&!t.isUniform){const o=t.texData.texShape,{useSqueezeShape:s,uniformShape:i,keptDims:c}=Aee(e.packedInputs,t.shape,o);let l="",u="",d="";if(1===i.length&&e.packedInputs){const e=[Math.ceil(o[0]/2),Math.ceil(o[1]/2)];l="".concat(e[0]>1,"_").concat(e[1]>1)}else if(2!==i.length||e.packedInputs){if(i.length>2&&!e.packedInputs){const e=JU(i);d="".concat(e[0]===o[1],"_").concat(e[e.length-1]===o[1])}}else u="".concat(i[0]>1,"_").concat(i[1]>1);const h=t.shape.length,p=2===i.length&&MU(t.shape,o),f=1===DU(t.shape),m=AY(t.shape,n.shape),g=!e.packedInputs&&h===n.shape.length&&MU(o,n.texData.texShape),b=e.packedInputs||i.length>2?"":"".concat(o[0]>1,"_").concat(o[1]>1);a+="".concat(h,"_").concat(g,"_").concat(s?c:"","_").concat(i.length,"_").concat(f,"_").concat(m,"_").concat(p,"_").concat(l,"_").concat(u,"_").concat(d,"_").concat(b,"_").concat(r)}else{const e=t.isUniform?"uniform":t.texData.texShape;a+="".concat(t.shape,"_").concat(e,"_").concat(r)}}));const r=e.userCode;let o=e.constructor.name;return o+="_"+a+"_"+r+"".concat(uG().getNumber("WEBGL_VERSION")),o}(e,l,u),h=this.getAndSaveBinary(d,(()=>Dee(this.gpgpu,e,l,u))),p=null!=this.activeTimers;let f;p&&(f=this.startTimer()),uG().get("ENGINE_COMPILE_ONLY")||function(e,t,n,a,r){t.program.enableShapeUniforms||(Lee(t.inShapeInfos,n),Lee([t.outShapeInfo],[a]));const o=a.texData.texture,s=a.texData.texShape;a.texData.isPacked?e.setOutputPackedMatrixTexture(o.texture,s[0],s[1]):e.setOutputMatrixTexture(o.texture,s[0],s[1]),e.setProgram(t.webGLProgram),e.bindVertexArray(t.webGLProgram.vao),1===uG().getNumber("WEBGL_VERSION")&&null!==t.infLoc&&e.gl.uniform1f(t.infLoc,1/0),null!==t.nanLoc&&e.gl.uniform1f(t.nanLoc,NaN);for(let c=0;c<n.length;++c){const a=n[c],{uniform:r,offset:o,shape:s,texShape:i}=t.variablesLocations[c];if(s){const{uniformShape:n}=Aee(t.program.packedInputs,a.shape,a.texData.texShape);switch(n.length){case 1:e.gl.uniform1iv(s,new Int32Array(n));break;case 2:e.gl.uniform2iv(s,new Int32Array(n));break;case 3:e.gl.uniform3iv(s,new Int32Array(n));break;case 4:e.gl.uniform4iv(s,new Int32Array(n))}}if(i&&e.gl.uniform2i(i,a.texData.texShape[0],a.texData.texShape[1]),null!=r)if(a.isUniform)if(DU(a.shape)<2)e.gl.uniform1f(r,a.uniformValues[0]);else{let t=a.uniformValues;t instanceof Float32Array||(t=new Float32Array(t)),e.gl.uniform1fv(r,t)}else null!=a.texData.slice&&null!=o&&e.gl.uniform1i(o,a.texData.slice.flatOffset),e.setInputMatrixTexture(a.texData.texture.texture,r,c)}const i=t.outShapeLocation;if(i)switch(a.shape.length){case 1:e.gl.uniform1iv(i,new Int32Array(a.shape));break;case 2:e.gl.uniform2iv(i,new Int32Array(a.shape));break;case 3:e.gl.uniform3iv(i,new Int32Array(a.shape));break;case 4:e.gl.uniform4iv(i,new Int32Array(a.shape))}if(t.outShapeStridesLocation){const n=JU(a.shape);switch(a.shape.length){case 2:e.gl.uniform1iv(t.outShapeStridesLocation,new Int32Array(n));break;case 3:e.gl.uniform2iv(t.outShapeStridesLocation,new Int32Array(n));break;case 4:e.gl.uniform3iv(t.outShapeStridesLocation,new Int32Array(n))}}if(t.outTexShapeLocation&&e.gl.uniform2i(t.outTexShapeLocation,a.texData.texShape[0],a.texData.texShape[1]),t.program.customUniforms&&r)for(let c=0;c<t.program.customUniforms.length;++c){const n=t.program.customUniforms[c],a=t.customUniformLocations[c],o=r[c];if("float"===n.type)e.gl.uniform1fv(a,o);else if("vec2"===n.type)e.gl.uniform2fv(a,o);else if("vec3"===n.type)e.gl.uniform3fv(a,o);else if("vec4"===n.type)e.gl.uniform4fv(a,o);else if("int"===n.type)e.gl.uniform1iv(a,o);else if("ivec2"===n.type)e.gl.uniform2iv(a,o);else if("ivec3"===n.type)e.gl.uniform3iv(a,o);else{if("ivec4"!==n.type)throw Error("uniform type ".concat(n.type," is not supported yet."));e.gl.uniform4iv(a,o)}}e.executeProgram()}(this.gpgpu,h,l,u,a),c.forEach((e=>this.disposeIntermediateTensorInfo(e))),p&&(f=this.endTimer(f),this.activeTimers.push({name:e.constructor.name,query:this.getQueryTime(f)}));const m=uG().getNumber("WEBGL_FLUSH_THRESHOLD");if(m>0){const e=JK();e-this.lastGlFlushTime>m&&(this.gpgpu.gl.flush(),this.lastGlFlushTime=e)}if(!uG().getBool("WEBGL_LAZILY_UNPACK")&&i.isPacked&&!1===r){const e=this.unpackTensor(s);return this.disposeIntermediateTensorInfo(s),e}return s}compileAndRun(e,t,n,a){let r=arguments.length>4&&void 0!==arguments[4]&&arguments[4];n=n||t[0].dtype;return this.runWebGLProgram(e,t,n,a,r)}getAndSaveBinary(e,t){return e in this.binaryCache||(this.binaryCache[e]=t()),this.binaryCache[e]}getTextureManager(){return this.textureManager}dispose(){if(!this.disposed){if(!uG().getBool("IS_TEST")){Object.keys(this.binaryCache).forEach((e=>{this.gpgpu.deleteProgram(this.binaryCache[e].webGLProgram),delete this.binaryCache[e]}))}this.textureManager.dispose(),null!=this.canvas&&"undefined"!==typeof HTMLCanvasElement&&this.canvas instanceof HTMLCanvasElement?this.canvas.remove():this.canvas=null,this.gpgpuCreatedLocally&&(this.gpgpu.program=null,this.gpgpu.dispose()),this.disposed=!0}}floatPrecision(){return null==this.floatPrecisionValue&&(this.floatPrecisionValue=nX((()=>{if(!uG().get("WEBGL_RENDER_FLOAT32_ENABLED")){const e=uG().getBool("DEBUG");uG().set("DEBUG",!1);const t=this.abs(vY(1e-8)).dataSync()[0];if(uG().set("DEBUG",e),t>0)return 32}return 16}))),this.floatPrecisionValue}epsilon(){return 32===this.floatPrecision()?1e-7:1e-4}uploadToGPU(e){const t=this.texData.get(e),{shape:n,dtype:a,values:r,texture:o,usage:s,isPacked:i}=t;if(null!=o)return;const c=null!=this.activeTimers;let l;c&&(l=JK());let u=t.texShape;if(null==u&&(u=function(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1],n=uG().getNumber("WEBGL_MAX_TEXTURE_SIZE"),a=uG().getNumber("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE");if(a===1/0&&uG().getBool("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE")&&(a=n/2),t&&(n*=2,a*=2,e=e.map(((t,n)=>n>=e.length-2?RU(e[n]):e[n])),1===e.length&&(e=[2,e[0]])),2!==e.length){const t=UU(e);e=t.newShape}let r=DU(e),o=null;e.length<=1&&r<=n?o=[1,r]:2===e.length&&e[0]<=n&&e[1]<=n?o=e:3===e.length&&e[0]*e[1]<=n&&e[2]<=n?o=[e[0]*e[1],e[2]]:3===e.length&&e[0]<=n&&e[1]*e[2]<=n?o=[e[0],e[1]*e[2]]:4===e.length&&e[0]*e[1]*e[2]<=n&&e[3]<=n?o=[e[0]*e[1]*e[2],e[3]]:4===e.length&&e[0]<=n&&e[1]*e[2]*e[3]<=n&&(o=[e[0],e[1]*e[2]*e[3]]);const s=null!=o&&Math.max(...o)>a&&Math.min(...o)<=(t?2:1)&&Math.min(...o)>0;if(null==o||s)if(t){const t=tee(e);let n=2,a=2;e.length&&([n,a]=nee(e)),r=t*(n/2)*(a/2),o=PU(r).map((e=>2*e))}else o=PU(r);return o}(n,i),t.texShape=u),null!=r){const e=aee(n);let o,s=u[1],d=u[0];const h=r instanceof Uint8Array||r instanceof Uint8ClampedArray;!i&&h||([s,d]=W9(u[0],u[1])),o=i?new Hee(e,h):new Gee(e,h);const p=h?[d,s]:u,f=this.makeTensorInfo(p,a),m=this.texData.get(f.dataId);m.usage=h?L9.PIXELS:L9.UPLOAD,m.texShape=p,this.gpgpu.uploadDenseMatrixToTexture(this.getTexture(f.dataId),s,d,r);const g=[[d,s]],b=!0,y=this.runWebGLProgram(o,[f],a,g,b),x=this.texData.get(y.dataId);t.texShape=x.texShape,t.isPacked=x.isPacked,t.usage=x.usage,uG().get("ENGINE_COMPILE_ONLY")?this.disposeData(y.dataId):(t.texture=x.texture,t.values=null,this.texData.delete(y.dataId)),this.disposeIntermediateTensorInfo(f),c&&(this.uploadWaitMs+=JK()-l)}else{const e=this.acquireTexture(u,s,a,i);t.texture=e}}convertAndCacheOnCPU(e,t){const n=this.texData.get(e),{dtype:a}=n;return null!=t&&(n.values=function(e,t){if("float32"===t||"complex64"===t)return e;if("int32"===t||"bool"===t){const n="int32"===t?new Int32Array(e.length):new Uint8Array(e.length);for(let t=0;t<n.length;++t)n[t]=Math.round(e[t]);return n}throw new Error("Unknown dtype ".concat(t))}(t,a)),n.values}acquireTexture(e,t,n,a){if(this.numBytesInGPU+=this.computeBytes(e,n),!this.warnedAboutMemory&&this.numBytesInGPU>1024*this.numMBBeforeWarning*1024){const e=(this.numBytesInGPU/1024/1024).toFixed(2);this.warnedAboutMemory=!0,console.warn("High memory usage in GPU: ".concat(e," MB, ")+"most likely due to a memory leak")}return this.textureManager.acquireTexture(e,t,a)}computeBytes(e,t){return e[0]*e[1]*KU(t)}checkCompileCompletion(){for(const[,e]of Object.entries(this.binaryCache))this.checkCompletion_(e)}async checkCompileCompletionAsync(){const e=[];if(this.gpgpu.parallelCompilationExtension){for(const[,t]of Object.entries(this.binaryCache))e.push(this.checkCompletionAsync_(t));return Promise.all(e)}for(const[,t]of Object.entries(this.binaryCache)){const n=new Promise((e=>{try{this.checkCompletion_(t),e(!0)}catch(n){throw n}}));e.push(n)}return Promise.all(e)}async checkCompletionAsync_(e){return this.gpgpu.gl.getProgramParameter(e.webGLProgram,this.gpgpu.parallelCompilationExtension.COMPLETION_STATUS_KHR)?this.checkCompletion_(e):(await new Promise((e=>j1((()=>e())))),this.checkCompletionAsync_(e))}checkCompletion_(e){if(!1===this.gpgpu.gl.getProgramParameter(e.webGLProgram,this.gpgpu.gl.LINK_STATUS)){if(console.log(this.gpgpu.gl.getProgramInfoLog(e.webGLProgram)),!1===this.gpgpu.gl.getShaderParameter(e.fragmentShader,this.gpgpu.gl.COMPILE_STATUS))throw K9(e.source,this.gpgpu.gl.getShaderInfoLog(e.fragmentShader)),new Error("Failed to compile fragment shader.");throw new Error("Failed to link vertex and fragment shaders.")}return!0}getUniformLocations(){for(const e of Object.values(this.binaryCache)){this.gpgpu.buildVao(e.webGLProgram);const{variablesLocations:t,customUniformLocations:n,infLoc:a,nanLoc:r,outShapeLocation:o,outShapeStridesLocation:s,outTexShapeLocation:i}=Mee(this.gpgpu,e.program,e.webGLProgram);e.variablesLocations=t,e.customUniformLocations=n,e.infLoc=a,e.nanLoc=r,e.outShapeLocation=o,e.outShapeStridesLocation=s,e.outTexShapeLocation=i}}createTensorFromGPUData(e,t,n){e.channels=e.channels||"RGBA";const{texture:a,height:r,width:o,channels:s}=e,i=tX().backend;if(!i.gpgpu.gl.isTexture(a))throw new Error("The texture is invalid. Also, please make sure the texture and the TFJS WebGL backend are using the same canvas. If you want to use your own custom canvas, you have to create and use the custom TFJS WebGL backend created from the canvas through 'new tf.MathBackendWebGL(customCanvas)'.");const c=i.writeTexture(a,t,n,r,o,s);return tX().makeTensorFromDataId(c,t,n,i)}}Sne.nextDataId=0,Vq()&&oX("webgl",(()=>new Sne),2);const Nne="\n  if (isnan(a)) return a;\n  if (isnan(b)) return b;\n";class Cne{constructor(e,t,n){this.variableNames=["A","B"],this.outputShape=OY(t,n),this.enableShapeUniforms=Pee(this.outputShape.length),this.userCode="\n      float binaryOperation(float a, float b) {\n        ".concat(e,"\n      }\n\n      void main() {\n        float a = getAAtOutCoords();\n        float b = getBAtOutCoords();\n        setOutput(binaryOperation(a, b));\n      }\n    ")}}const Tne="\n  result.r = isNaN.r ? NAN : result.r;\n  result.g = isNaN.g ? NAN : result.g;\n  result.b = isNaN.b ? NAN : result.b;\n  result.a = isNaN.a ? NAN : result.a;\n";class Ene{constructor(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]&&arguments[3];this.variableNames=["A","B"],this.supportsBroadcasting=!0,this.packedInputs=!0,this.packedOutput=!0,this.outputShape=OY(t,n);const r=this.outputShape.length;this.enableShapeUniforms=Pee(r);let o="";if(a)if(0===r||1===DU(this.outputShape))o="\n          result.y = 0.;\n          result.z = 0.;\n          result.w = 0.;\n        ";else{const e=_ee(r);if(o="\n          ".concat(e," coords = getOutputCoords();\n        "),1===r)this.enableShapeUniforms?o+="\n            result.y = (coords + 1) >= outShape ? 0. : result.y;\n            result.z = 0.;\n            result.w = 0.;\n          ":o+="\n            result.y = (coords + 1) >= ".concat(this.outputShape[0]," ? 0. : result.y;\n            result.z = 0.;\n            result.w = 0.;\n          ");else{const e=Zte("coords",r);this.enableShapeUniforms?o+="\n            bool nextRowOutOfBounds =\n              (".concat(e[r-2]," + 1) >= outShape[").concat(r," - 2];\n            bool nextColOutOfBounds =\n              (").concat(e[r-1]," + 1) >= outShape[").concat(r," - 1];\n            result.y = nextColOutOfBounds ? 0. : result.y;\n            result.z = nextRowOutOfBounds ? 0. : result.z;\n            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;\n          "):o+="\n            bool nextRowOutOfBounds =\n              (".concat(e[r-2]," + 1) >= ").concat(this.outputShape[r-2],";\n            bool nextColOutOfBounds =\n              (").concat(e[r-1]," + 1) >= ").concat(this.outputShape[r-1],";\n            result.y = nextColOutOfBounds ? 0. : result.y;\n            result.z = nextRowOutOfBounds ? 0. : result.z;\n            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;\n          ")}}this.userCode="\n      vec4 binaryOperation(vec4 a, vec4 b) {\n        ".concat(e,"\n      }\n\n      void main() {\n        vec4 a = getAAtOutCoords();\n        vec4 b = getBAtOutCoords();\n\n        vec4 result = binaryOperation(a, b);\n        ").concat(o,"\n\n        setOutput(result);\n      }\n    ")}}function Rne(e){const{inputs:t,backend:n}=e,{x:a}=t;return n.incRef(a.dataId),{dataId:a.dataId,shape:a.shape,dtype:a.dtype}}const _ne={kernelName:_H,backendName:"webgl",kernelFunc:Rne};function Ane(e){const{inputs:t,backend:n}=e,{real:a,imag:r}=t,o=n.makeTensorInfo(a.shape,"complex64"),s=n.texData.get(o.dataId),i=Rne({inputs:{x:a},backend:n}),c=Rne({inputs:{x:r},backend:n});return s.complexTensorInfos={real:i,imag:c},o}const Fne={kernelName:VG,backendName:"webgl",kernelFunc:Ane},One="return (a < 0.) ? b * a : a;",Dne="\n  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));\n  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);\n";const Mne={kernelName:LH,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{alpha:o}=a,s=n.makeTensorInfo([],"float32",YK(o,"float32")),i=uG().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new Ene(Dne,r.shape,s.shape):new Cne(One,r.shape,s.shape),c=n.runWebGLProgram(i,[r,s],"float32");return n.disposeIntermediateTensorInfo(s),c}},Lne="return (a < 0.) ? b * a : a;",Pne="\n  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));\n  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);\n";const zne={kernelName:bj,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{x:a,alpha:r}=t,o=uG().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new Ene(Pne,a.shape,r.shape):new Cne(Lne,a.shape,r.shape);return n.runWebGLProgram(o,[a,r],"float32")}},Bne="if (isnan(x)) return x;";function Wne(e){let{opSnippet:t,packedOpSnippet:n,cpuKernelImpl:a,dtype:r}=e;return e=>{let{inputs:o,backend:s}=e;const{x:i}=o,c=s,l=r||i.dtype;if(c.shouldExecuteOnCPU([i])&&null!=a){const e=c.texData.get(i.dataId),t=a(e.values,l);return c.makeTensorInfo(i.shape,l,t)}let u;return u=uG().getBool("WEBGL_PACK_UNARY_OPERATIONS")&&null!=n?new xne(i.shape,n):new one(i.shape,t),c.runWebGLProgram(u,[i],l)}}function Vne(e){let{opSnippet:t,packedOpSnippet:n,checkOutOfBounds:a=!1,supportsComplex:r=!1,cpuKernelImpl:o,dtype:s}=e;return e=>{let{inputs:i,backend:c}=e;const{a:l,b:u}=i,d=c;if(r&&"complex64"===l.dtype){const e=d.texData.get(l.dataId),n=d.texData.get(u.dataId),[a,r]=[[e.complexTensorInfos.real,n.complexTensorInfos.real],[e.complexTensorInfos.imag,n.complexTensorInfos.imag]].map((e=>{const[n,a]=e,r={dataId:n.dataId,dtype:n.dtype,shape:l.shape},o={dataId:a.dataId,dtype:a.dtype,shape:u.shape},s=new Cne(t,l.shape,u.shape);return d.runWebGLProgram(s,[r,o],Cq(n.dtype,a.dtype))})),o=Ane({inputs:{real:a,imag:r},backend:d});return d.disposeIntermediateTensorInfo(a),d.disposeIntermediateTensorInfo(r),o}const h=s||Cq(l.dtype,u.dtype);if(("string"===l.dtype||"string"===u.dtype||d.shouldExecuteOnCPU([l,u]))&&null!=o){const e=d.texData.get(l.dataId).values,t=d.texData.get(u.dataId).values,n="string"===l.dtype?Q2(e):e,a="string"===l.dtype?Q2(t):t,[r,s]=o(l.shape,u.shape,n,a,h),i=d.makeTensorInfo(s,h);return d.texData.get(i.dataId).values=r,i}let p;return p=uG().getBool("WEBGL_PACK_BINARY_OPERATIONS")&&null!=n?new Ene(n,l.shape,u.shape,a):new Cne(t,l.shape,u.shape),d.runWebGLProgram(p,[l,u],h)}}function Une(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];if("linear"===e)return t?fne:ine;if("relu"===e)return t?gne:une;if("elu"===e)return t?mne:lne;if("relu6"===e)return t?bne:dne;if("prelu"===e)return t?Pne:Lne;if("leakyrelu"===e)return t?Dne:One;if("sigmoid"===e)return t?yne:pne;throw new Error("Activation ".concat(e," has not been implemented for the WebGL backend."))}class Gne{constructor(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]&&arguments[3],r=arguments.length>4&&void 0!==arguments[4]&&arguments[4],o=arguments.length>5&&void 0!==arguments[5]&&arguments[5],s=arguments.length>6&&void 0!==arguments[6]?arguments[6]:null,i=arguments.length>7&&void 0!==arguments[7]&&arguments[7],c=arguments.length>8&&void 0!==arguments[8]&&arguments[8];this.variableNames=["matrixA","matrixB"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=n,this.enableShapeUniforms=Pee(this.outputShape.length);const l=a?e[1]:e[2],u=Math.ceil(l/2),d=a?"i * 2, rc.y":"rc.y, i * 2",h=r?"rc.z, i * 2":"i * 2, rc.z",p=a?["a.xxyy","a.zzww"]:["a.xxzz","a.yyww"],f=r?["b.xzxz","b.ywyw"]:["b.xyxy","b.zwzw"];let m="",g="";s&&(m=i?"vec4 activation(vec4 a) {\n          vec4 b = getPreluActivationWeightsAtOutCoords();\n          ".concat(s,"\n        }"):c?"vec4 activation(vec4 a) {\n          vec4 b = getLeakyreluAlphaAtOutCoords();\n          ".concat(s,"\n        }"):"vec4 activation(vec4 x) {\n          ".concat(s,"\n        }"),g="result = activation(result);");const b=o?"result += getBiasAtOutCoords();":"";o&&this.variableNames.push("bias"),i&&this.variableNames.push("preluActivationWeights"),c&&this.variableNames.push("leakyreluAlpha");let y="rc.x",x="rc.x";e[0]<t[0]?y="imod(rc.x, ".concat(e[0],")"):t[0]<e[0]&&(x="imod(rc.x, ".concat(t[0],")")),this.userCode="\n      ".concat(m,"\n      // Don't use uniform for sharedDimensionPacked for performance.\n      const float sharedDimension = ").concat(u,".0;\n\n      vec4 dot2x2ARowBCol(ivec3 rc) {\n        vec4 result = vec4(0);\n        int batchA = ").concat(y,";\n        int batchB = ").concat(x,";\n        for (int i = 0; i < ").concat(u,"; i++) {\n          vec4 a = getMatrixA(batchA, ").concat(d,");\n          vec4 b = getMatrixB(batchB, ").concat(h,");\n\n          // These swizzled products need to be separately added.\n          // See: https://github.com/tensorflow/tfjs/issues/1735\n          result += (").concat(p[0]," * ").concat(f[0],");\n          result += (").concat(p[1]," * ").concat(f[1],");\n        }\n        return result;\n      }\n\n      void main() {\n        ivec3 rc = getOutputCoords();\n        vec4 result = dot2x2ARowBCol(rc);\n\n        ").concat(b,"\n\n        ").concat(g,"\n\n        setOutput(result);\n      }\n    ")}}const Hne={REAL:"return areal * breal - aimag * bimag;",IMAG:"return areal * bimag + aimag * breal;"};class jne{constructor(e,t,n){this.variableNames=["AReal","AImag","BReal","BImag"],this.outputShape=OY(t,n),this.userCode="\n      float binaryOpComplex(\n          float areal, float aimag, float breal, float bimag) {\n        ".concat(e,"\n      }\n\n      void main() {\n        float areal = getARealAtOutCoords();\n        float aimag = getAImagAtOutCoords();\n        float breal = getBRealAtOutCoords();\n        float bimag = getBImagAtOutCoords();\n        setOutput(binaryOpComplex(areal, aimag, breal, bimag));\n      }\n    ")}}const Kne="return a * b;";function qne(e){const{inputs:t,backend:n}=e,{a:a,b:r}=t,o=Cq(a.dtype,r.dtype);if("complex64"===a.dtype){const e=n.texData.get(a.dataId),t=n.texData.get(r.dataId),o=new jne(Hne.REAL,a.shape,r.shape),s=new jne(Hne.IMAG,a.shape,r.shape),i=[{dataId:e.complexTensorInfos.real.dataId,dtype:e.complexTensorInfos.real.dtype,shape:a.shape},{dataId:e.complexTensorInfos.imag.dataId,dtype:e.complexTensorInfos.imag.dtype,shape:a.shape},{dataId:t.complexTensorInfos.real.dataId,dtype:t.complexTensorInfos.real.dtype,shape:r.shape},{dataId:t.complexTensorInfos.imag.dataId,dtype:t.complexTensorInfos.imag.dtype,shape:r.shape}],c=n.runWebGLProgram(o,i,"float32"),l=n.runWebGLProgram(s,i,"float32"),u=Ane({inputs:{real:c,imag:l},backend:n});return n.disposeIntermediateTensorInfo(c),n.disposeIntermediateTensorInfo(l),u}if(n.shouldExecuteOnCPU([a,r])){const e=n.texData.get(a.dataId),t=n.texData.get(r.dataId),[s,i]=Ste(a.shape,r.shape,e.values,t.values,o),c=n.makeTensorInfo(i,o);return n.texData.get(c.dataId).values=s,c}let s;return s=uG().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new Ene(Kne,a.shape,r.shape):new Cne(Kne,a.shape,r.shape),n.runWebGLProgram(s,[a,r],o)}const Xne={kernelName:sj,backendName:"webgl",kernelFunc:qne};function Yne(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{shape:o}=a,s=n,i=DU(r.shape),c=WU(o,i),l=DU(c);AU(i===l,(()=>"The new shape (".concat(c,") has ").concat(l," elements and the old ")+"shape (".concat(r.shape,") has ").concat(i," elements. The new shape and old ")+"shape must have the same number of elements."));const u=s.texData.get(r.dataId);return!u.isPacked||oee(r.shape,c)||null!==u.texture&&oee(u.shape,c)?(s.incRef(r.dataId),{dataId:r.dataId,shape:c,dtype:r.dtype}):function(e,t,n){const a=[tee(e.shape),...nee(e.shape)],r={dtype:e.dtype,shape:a,dataId:e.dataId},o=[tee(t),...nee(t)],s=new ene(o,a),i=[a],c=n.runWebGLProgram(s,[r],e.dtype,i,!0);return{dataId:c.dataId,shape:t,dtype:c.dtype}}(r,c,s)}const Qne={kernelName:Cj,backendName:"webgl",kernelFunc:Yne};class Jne{constructor(e,t){this.variableNames=["x"];const{windowSize:n,batchSize:a,inSize:r,outSize:o}=e;this.outputShape=[a,o];const s=4*Math.floor(n/4),i=n%4;let c="sumValue += dot(values, ones);";if(null!=t){const e=1/t;c="sumValue += dot(values * ".concat(LU(e)?e.toPrecision(2):e,", ones);")}let l="";r%n>0&&(l="\n        if (inIdx < 0 || inIdx >= ".concat(r,") {\n          return 0.0;\n        }\n      ")),this.userCode="\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float getValue(int batch, int inIdx) {\n        ".concat(l,"\n        return getX(batch, inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ").concat(n,";\n\n        float sumValue = 0.0;\n\n        for (int i = 0; i < ").concat(s,"; i += 4) {\n          int inIdx = inOffset + i;\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          ").concat(c,"\n        }\n\n        int inIdx = inOffset + ").concat(s,";\n        if (").concat(1===i,") {\n          vec4 values = vec4(getValue(batch, inIdx), 0.0, 0.0, 0.0);\n\n          ").concat(c,"\n        } else if (").concat(2===i,") {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1), 0.0, 0.0);\n\n          ").concat(c,"\n        } else if (").concat(3===i,") {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2), 0.0);\n\n          ").concat(c,"\n        }\n        setOutput(sumValue);\n      }\n    ")}}class Zne{constructor(e,t){this.variableNames=["x"];const{windowSize:n,batchSize:a,inSize:r,outSize:o}=e;this.outputShape=[a,o];let s="0.0",i="";"prod"===t?s="1.0":"min"===t?(s="1.0 / 1e-20",i="min"):"max"===t&&(s="-1.0 / 1e-20",i="max");let c="".concat(t,"(").concat(t,"(").concat(t,"(")+"minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])";"sum"===t?c="sumValue":"prod"===t?c="prodValue":"all"===t?c="allValue":"any"===t&&(c="anyValue");const l=4*Math.floor(n/4),u=n%4;let d="\n      if (".concat("sum"===t,") {\n        sumValue += dot(values, ones);\n      } else if (").concat("prod"===t,") {\n        vec2 tmp = vec2(values[0], values[1]) * vec2(values[2], values[3]);\n        prodValue *= tmp[0] * tmp[1];\n      } else {\n        minMaxValue = ").concat(i,"(values, minMaxValue);\n        if (").concat("min"===t," || ").concat("max"===t,") {\n          minMaxValue = ").concat(i,"(values, minMaxValue);\n          bvec4 isNaN = isnan(values);\n          if (isNaN.r || isNaN.g || isNaN.b || isNaN.a) {\n            minMaxValue = vec4(NAN);\n          }\n        }\n      }\n    "),h="vec4";"all"===t?(s="1.0",d="\n        bool reducedAllValue = all(values);\n        float floatedReducedAllValue = float(reducedAllValue);\n        allValue = float(allValue >= 1.0 && floatedReducedAllValue >= 1.0);\n      ",h="bvec4"):"any"===t&&(s="0.0",d="\n        bool reducedAnyValue = any(values);\n        float floatedReducedAnyValue = float(reducedAnyValue);\n        anyValue = float(anyValue >= 1.0 || floatedReducedAnyValue >= 1.0);\n      ",h="bvec4");let p="";r%n>0&&(p="\n        if (inIdx < 0 || inIdx >= ".concat(r,") {\n          return initializationValue;\n        }\n      ")),this.userCode="\n      const float initializationValue = ".concat(s,";\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float getValue(int batch, int inIdx) {\n        ").concat(p,"\n        return getX(batch, inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ").concat(n,";\n\n        vec4 minMaxValue = vec4(").concat(s,");\n        float prodValue = 1.0;\n        float sumValue = 0.0;\n        float allValue = 1.0;\n        float anyValue = 0.0;\n\n        for (int i = 0; i < ").concat(l,"; i += 4) {\n          int inIdx = inOffset + i;\n          ").concat(h," values = ").concat(h,"(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          ").concat(d,"\n        }\n\n        int inIdx = inOffset + ").concat(l,";\n        if (").concat(1===u,") {\n          ").concat(h," values = ").concat(h,"(\n            getValue(batch, inIdx),\n            initializationValue,\n            initializationValue,\n            initializationValue\n          );\n\n          ").concat(d,"\n        } else if (").concat(2===u,") {\n          ").concat(h," values = ").concat(h,"(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            initializationValue,\n            initializationValue\n          );\n\n          ").concat(d,"\n        } else if (").concat(3===u,") {\n          ").concat(h," values = ").concat(h,"(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            initializationValue\n          );\n\n          ").concat(d,"\n        }\n        setOutput(").concat(c,");\n      }\n    ")}}function $ne(e,t,n,a){const r=function(e){const t=[];for(;0===t.length||1!==t[t.length-1].outSize;){const n=t.length?t[t.length-1].outSize:e[1],a=e2(n);t.push({inSize:n,windowSize:a,outSize:Math.ceil(n/a)})}return t}(e.shape);let o=e;for(let s=0;s<r.length;s++){const{inSize:i,windowSize:c,outSize:l}=r[s];let u,d;u="mean"===n?0===s?new Jne({windowSize:c,inSize:i,batchSize:e.shape[0],outSize:l},i):new Jne({windowSize:c,inSize:i,batchSize:e.shape[0],outSize:l}):new Zne({windowSize:c,inSize:i,batchSize:e.shape[0],outSize:l},n),d=o,o=a.runWebGLProgram(u,[o],t),d.dataId!==e.dataId&&a.disposeIntermediateTensorInfo(d)}return o}class eae{constructor(e,t){this.variableNames=["A"];const n=new Array(e.length);for(let o=0;o<n.length;o++)n[o]=e[t[o]];this.outputShape=n,this.rank=n.length;const a=_ee(this.rank),r=function(e){const t=e.length;if(t>6)throw Error("Transpose for rank ".concat(t," is not yet supported"));const n=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u","resRC.v"],a=new Array(t);for(let r=0;r<e.length;r++)a[e[r]]=n[r];return a.join()}(t);this.userCode="\n    void main() {\n      ".concat(a," resRC = getOutputCoords();\n      setOutput(getA(").concat(r,"));\n    }\n    ")}}class tae{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0;const n=new Array(e.length);for(let l=0;l<n.length;l++)n[l]=e[t[l]];if(this.outputShape=n,this.rank=n.length,this.rank>6)throw Error("Packed transpose for rank ".concat(this.rank," is not yet supported."));const a=_ee(this.rank),r=Jte("rc",this.rank),o=new Array(this.rank);for(let l=0;l<t.length;l++)o[t[l]]=r[l];const s="vec2(".concat(o.slice(-2).join(),")"),i="++".concat(r[this.rank-1]," < ").concat(n[this.rank-1]),c="getChannel(getA(".concat(o.join(),"), ").concat(s,")");this.userCode="\n    void main() {\n      ".concat(a," rc = getOutputCoords();\n      vec4 result = vec4(0.);\n      result[0] = ").concat(c,";\n      if(").concat(i,") {\n        result[1] = ").concat(c,";\n      }\n      --").concat(r[this.rank-1],";\n      if(++").concat(r[this.rank-2]," < ").concat(n[this.rank-2],") {\n        result[2] = ").concat(c,";\n        if(").concat(i,") {\n          result[3] = ").concat(c,";\n        }\n      }\n      setOutput(result);\n    }\n    ")}}function nae(e,t,n){const a=uG().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new tae(e.shape,t):new eae(e.shape,t);return n.runWebGLProgram(a,[e],e.dtype)}function aae(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{axis:o,keepDims:s}=a;return function(e,t,n,a){const r=t,o=e.shape.length,s=VU(r,e.shape);let i=s;const c=ZJ(i,o),l=null!=c;let u=e;l&&(u=nae(e,c,a),i=eZ(i.length,o)),JJ("sum",i,o);const[d,h]=YJ(u.shape,i);let p=d;n&&(p=QJ(d,s));const f=DU(h),m=Yne({inputs:{x:u},attrs:{shape:[DU(e.shape)/f,f]},backend:a}),g=$ne(m,Tq(e.dtype),"sum",a),b=Yne({inputs:{x:g},attrs:{shape:p},backend:a});return a.disposeIntermediateTensorInfo(m),a.disposeIntermediateTensorInfo(g),l&&a.disposeIntermediateTensorInfo(u),b}(r,o,s,n)}const rae={kernelName:qj,backendName:"webgl",kernelFunc:aae};function oae(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{perm:o}=a,s=n,i=r.shape.length,c=new Array(i);for(let u=0;u<c.length;u++)c[u]=r.shape[o[u]];let l;if(s.shouldExecuteOnCPU([r])){const e=s.texData.get(r.dataId).values,t=Yte(e,r.shape,r.dtype,o,c);l=s.makeTensorInfo(c,r.dtype);s.texData.get(l.dataId).values=t}else l=nae(r,o,s);return l}const sae={kernelName:mK,backendName:"webgl",kernelFunc:oae},iae=1e3;function cae(e){let{a:t,b:n,transposeA:a,transposeB:r,backend:o,bias:s=null,preluActivationWeights:i=null,leakyreluAlpha:c=0,activation:l=null}=e;const u=t.shape.length,d=n.shape.length,h=a?t.shape[u-2]:t.shape[u-1],p=r?n.shape[d-1]:n.shape[d-2],f=a?t.shape[u-1]:t.shape[u-2],m=r?n.shape[d-2]:n.shape[d-1],g=t.shape.slice(0,-2),b=n.shape.slice(0,-2),y=DU(g),x=DU(b),v=OY(t.shape.slice(0,-2),n.shape.slice(0,-2)).concat([f,m]);AU(h===p,(()=>"Error in matMul: inner shapes (".concat(h,") and (")+"".concat(p,") of Tensors with shapes ").concat(t.shape," and ")+"".concat(n.shape," and transposeA=").concat(a)+" and transposeB=".concat(r," must match.")));const w=a?[y,h,f]:[y,f,h],k=r?[x,m,p]:[x,p,m],I=Yne({inputs:{x:t},backend:o,attrs:{shape:w}}),S=Yne({inputs:{x:n},backend:o,attrs:{shape:k}}),N=[I,S],C=Math.max(y,x),T=a?I.shape[1]:I.shape[2],E=null!=s,R=null!=i,_="leakyrelu"===l,A=null!=l?Une(l,!0):null;let F;if((1===f||1===m)&&T>iae&&!1===(E||R||_||null!=A)){let e=I,t=S;a&&(e=oae({inputs:{x:I},backend:o,attrs:{perm:[0,2,1]}}),N.push(e)),r&&(t=oae({inputs:{x:S},backend:o,attrs:{perm:[0,2,1]}}),N.push(t));const n=1===m;let s=e;1!==m&&(s=Yne({inputs:{x:e},backend:o,attrs:{shape:[C,T,1]}}),N.push(s));const i=1===m?2:1;let c=t;n&&(c=Yne({inputs:{x:t},backend:o,attrs:{shape:[C,1,T]}}),N.push(c));const l=qne({inputs:{a:s,b:c},backend:o});F=aae({inputs:{x:l},backend:o,attrs:{axis:i,keepDims:!0}}),N.push(l)}else{const e=Cq(t.dtype,n.dtype),l=new Gne(w,k,[C,f,m],a,r,E,A,R,_),u=[I,S];if(null!=s&&u.push(s),R&&u.push(i),_){const e=o.makeTensorInfo([],"float32",YK(c,"float32"));u.push(e),N.push(e)}F=o.runWebGLProgram(l,u,e)}const O=Yne({inputs:{x:F},backend:o,attrs:{shape:v}});N.push(F);for(const D of N)o.disposeIntermediateTensorInfo(D);return O}const lae={kernelName:IK,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{a:r,b:o,bias:s,preluActivationWeights:i}=t,{transposeA:c,transposeB:l,activation:u,leakyreluAlpha:d}=a;return cae({a:r,b:o,transposeA:c,transposeB:l,backend:n,bias:s,preluActivationWeights:i,leakyreluAlpha:d,activation:u})}},uae="return abs(x);";const dae={kernelName:mG,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{x:a}=t;if(n.shouldExecuteOnCPU([a])&&"complex64"!==a.dtype){const e=n.texData.get(a.dataId),t=Mte(e.values);return n.makeTensorInfo(a.shape,a.dtype,t)}let r;return r=uG().getBool("WEBGL_PACK_UNARY_OPERATIONS")?new xne(a.shape,uae):new one(a.shape,uae),n.runWebGLProgram(r,[a],a.dtype)}},hae=Wne({opSnippet:sne+"\n  if (abs(x) > 1.) {\n    return NAN;\n  }\n  return acos(x);\n"}),pae={kernelName:gG,backendName:"webgl",kernelFunc:hae},fae=Wne({opSnippet:sne+"\n  if (x < 1.0) return NAN;\nreturn log(x + sqrt(x * x - 1.0));"}),mae={kernelName:bG,backendName:"webgl",kernelFunc:fae},gae="return a + b;",bae=Vne({opSnippet:gae,packedOpSnippet:gae,supportsComplex:!0,cpuKernelImpl:nte}),yae={kernelName:yG,backendName:"webgl",kernelFunc:bae};class xae{constructor(e,t){this.outputShape=[],this.outputShape=e,this.variableNames=t.map(((e,t)=>"T".concat(t)));const n=[];this.variableNames.forEach((e=>{n.push("float v".concat(e," = get").concat(e,"AtOutCoords();"))}));const a=this.variableNames.map((e=>"v".concat(e))).join(" + ");this.userCode="\n      void main() {\n        ".concat(n.join("\n        "),"\n\n        float result = ").concat(a,";\n        setOutput(result);\n      }\n    ")}}class vae{constructor(e,t){this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.variableNames=t.map(((e,t)=>"T".concat(t)));const n=[];this.variableNames.forEach((e=>{n.push("vec4 v".concat(e," = get").concat(e,"AtOutCoords();"))}));const a=this.variableNames.map((e=>"v".concat(e))).join(" + ");this.userCode="\n      void main() {\n        ".concat(n.join("\n        "),"\n\n        vec4 result = ").concat(a,";\n        setOutput(result);\n      }\n    ")}}const wae={kernelName:xG,backendName:"webgl",kernelFunc:function e(t){const{inputs:n,backend:a}=t,r=n;if(1===r.length)return Rne({inputs:{x:r[0]},backend:a});if(r.length>uG().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER")){const t=Math.floor(r.length/2),n=e({inputs:r.slice(0,t),backend:a}),o=e({inputs:r.slice(t),backend:a});return e({inputs:[n,o],backend:a})}const o=r.map((e=>e.dtype)).reduce(((e,t)=>Cq(e,t))),s=r.map((e=>e.shape)),i=uG().getBool("WEBGL_PACK")?new vae(r[0].shape,s):new xae(r[0].shape,s);return a.runWebGLProgram(i,r,o)}};const kae={kernelName:vG,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{axis:o,keepDims:s}=a,i=r.shape.length,c=VU(o,r.shape);let l=c;const u=ZJ(l,i);let d=r;null!=u&&(d=oae({inputs:{x:r},backend:n,attrs:{perm:u}}),l=eZ(l.length,i)),JJ("all",l,i);const[h,p]=YJ(d.shape,l),f=Yne({inputs:{x:d},backend:n,attrs:{shape:[-1,DU(p)]}}),m=$ne(f,f.dtype,"all",n);let g;if(s){g=Yne({inputs:{x:m},backend:n,attrs:{shape:QJ(h,c)}})}else g=Yne({inputs:{x:m},backend:n,attrs:{shape:h}});return n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),null!=u&&n.disposeIntermediateTensorInfo(d),g}};const Iae={kernelName:wG,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{axis:o,keepDims:s}=a,i=r.shape.length,c=VU(o,r.shape);let l=c;const u=ZJ(l,i);let d=r;null!=u&&(d=oae({inputs:{x:r},backend:n,attrs:{perm:u}}),l=eZ(l.length,i)),JJ("any",l,i);const[h,p]=YJ(d.shape,l),f=Yne({inputs:{x:d},backend:n,attrs:{shape:[-1,DU(p)]}}),m=$ne(f,f.dtype,"any",n);let g;if(s){g=Yne({inputs:{x:m},backend:n,attrs:{shape:QJ(h,c)}})}else g=Yne({inputs:{x:m},backend:n,attrs:{shape:h}});return n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),null!=u&&n.disposeIntermediateTensorInfo(d),g}};class Sae{constructor(e,t,n){this.variableNames=["A"];const{windowSize:a,batchSize:r,outSize:o}=e;n||this.variableNames.push("bestIndicesA"),this.outputShape=[r,o];const s="max"===t?">":"<",i=n?"inOffset + i;":"round(getBestIndicesA(batch, inOffset + i));";this.userCode="\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ".concat(a,";\n\n        int bestIndex = inOffset;\n        float bestValue = getA(batch, bestIndex);\n\n        for (int i = 0; i < ").concat(a,"; i++) {\n          int inIdx = ").concat(i,";\n          float candidate = getA(batch, inIdx);\n          if (candidate ").concat(s," bestValue) {\n            bestValue = candidate;\n            bestIndex = inIdx;\n          }\n        }\n        setOutput(float(bestIndex));\n      }\n    ")}}class Nae{constructor(e,t,n,a){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,AU(e.length>2,(()=>"Packed arg".concat(n.charAt(0).toUpperCase()+n.slice(1)," supports only inputs with rank above 2.")));const r=e[e.length-1],o=Math.ceil(r/t);this.outputShape=e.slice(0,-1),o>1&&this.outputShape.push(o),a||this.variableNames.push("bestIndicesA");const s=this.outputShape,i=s.length,c=_ee(i),l=Zte("coords",i);let u,d;if(1===o){d=i+1;const e=_ee(d);u="\n        ".concat(e," sourceLocR = ").concat(e,"(").concat(l.join(),", 0);\n        ++").concat(l[i-1],";\n        ").concat(e," sourceLocG = ").concat(e,"(").concat(l.join(),", 0);\n        ++").concat(l[i-2],";\n        ").concat(e," sourceLocA = ").concat(e,"(").concat(l.join(),", 0);\n        --").concat(l[i-1],";\n        ").concat(e," sourceLocB = ").concat(e,"(").concat(l.join(),", 0);\n        --").concat(l[i-2],";")}else d=i,u="\n        ".concat(c," sourceLocR = coords;\n        ++").concat(l[i-1],";\n        ").concat(c," sourceLocG = coords;\n        ++").concat(l[i-2],";\n        ").concat(c," sourceLocA = coords;\n        --").concat(l[i-1],";\n        ").concat(c," sourceLocB = coords;\n        --").concat(l[i-2],";");const h=["x","y","z","w","u","v"].slice(0,d),p="."+h[d-1],f=h.map((e=>"int "+e)),m=Zte("sourceLocR",d-1).concat("inIdx.r"),g=Zte("sourceLocG",d-1).concat("inIdx.g"),b=Zte("sourceLocB",d-1).concat("inIdx.b"),y=Zte("sourceLocA",d-1).concat("inIdx.a"),x="max"===n?"greaterThan":"lessThan",v=a?"":"\n          inIdx = round(vec4(getBestIndicesAChannel(".concat(m.join(),"),\n                             getBestIndicesAChannel(").concat(g.join(),"),\n                             getBestIndicesAChannel(").concat(b.join(),"),\n                             getBestIndicesAChannel(").concat(y.join(),")));"),w="vec4(\n            getAChannel(".concat(m.join(),"),\n            hasNextCol ? getAChannel(").concat(g.join(),") : 0.,\n            hasNextRow ? getAChannel(").concat(b.join(),") : 0.,\n            hasNextRow && hasNextCol ? getAChannel(").concat(y.join(),") : 0.)"),k=a?"":"\n      float getBestIndicesAChannel(".concat(f.join(),") {\n        return getChannel(getBestIndicesA(").concat(h.join(),"),\n                                          vec2(").concat(h.slice(-2).join(),"));\n      }");this.userCode="\n      float getAChannel(".concat(f.join(),") {\n        return getChannel(getA(").concat(h.join(),"),\n                               vec2(").concat(h.slice(-2).join(),"));\n      }\n      ").concat(k,"\n      void main() {\n        ").concat(c," coords = getOutputCoords();\n        bool hasNextCol = ").concat(l[i-1]," < ").concat(s[i-1]-1,";\n        bool hasNextRow = ").concat(l[i-2]," < ").concat(s[i-2]-1,";\n        ").concat(u,"\n        ivec4 srcIdx = ivec4(sourceLocR").concat(p,", sourceLocG").concat(p,",\n          sourceLocB").concat(p,", sourceLocA").concat(p,") * ").concat(t,";\n        ivec4 inIdx = srcIdx;\n        vec4 bestIndex = vec4(inIdx);\n        vec4 bestValue = ").concat(w,";\n\n        for (int i = 0; i < ").concat(t,"; i++) {\n          inIdx = srcIdx;\n          ").concat(v,"\n          vec4 candidate = ").concat(w,";\n          bvec4 nan = isnan(candidate);\n          bvec4 replace = bvec4(\n            vec4(").concat(x,"(candidate, bestValue)) * (vec4(1.0) - vec4(nan)));\n\n          bestValue = vec4(replace.x  ? candidate.x : bestValue.x,\n                           replace.y  ? candidate.y : bestValue.y,\n                           replace.z  ? candidate.z : bestValue.z,\n                           replace.w  ? candidate.w : bestValue.w);\n          bestIndex = mix(bestIndex, vec4(inIdx), vec4(replace));\n          srcIdx++;\n        }\n        setOutput(bestIndex);\n      }\n    ")}}function Cae(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:null,r=t.shape[0],o=t.shape[1];null!=a&&(r=a.shape[0],o=a.shape[1]);const s=e2(o),i={windowSize:s,inSize:o,batchSize:r,outSize:Math.ceil(o/s)},c=new Sae(i,n,null==a),l=[t];null!=a&&l.push(a);const u=e.runWebGLProgram(c,l,"int32");if(1===u.shape[1])return u;const d=Cae(e,t,n,u);return e.disposeIntermediateTensorInfo(u),d}function Tae(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:null;const r=null!=a?a.shape:t.shape,o=e2(r[r.length-1]),s=new Nae(r,o,n,null==a),i=null==a?[t]:[t,a],c=e.runWebGLProgram(s,i,"int32");if(c.shape.length===t.shape.length){const a=Tae(e,t,n,c);return e.disposeIntermediateTensorInfo(c),a}return c}function Eae(e,t,n,a){const r=[n];if(JJ("arg"+a.charAt(0).toUpperCase()+a.slice(1),r,t.shape.length),!uG().getBool("WEBGL_PACK_REDUCE")||t.shape.length<=2){const n=[],o=e.texData.get(t.dataId);let s=t;null!==o&&o.isPacked&&(s=e.unpackTensor(t),n.push(s));const[i,c]=YJ(s.shape,r),l=DU(c),u=Yne({inputs:{x:s},backend:e,attrs:{shape:[-1,l]}});n.push(u);const d=Cae(e,u,a);n.push(d);const h=Yne({inputs:{x:d},backend:e,attrs:{shape:i}});return n.forEach((t=>e.disposeIntermediateTensorInfo(t))),h}return Tae(e,t,a)}const Rae={kernelName:kG,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{axis:o}=a;let s=VU(o,r.shape);const i=ZJ(s,r.shape.length);let c=r;const l=[];null!=i&&(c=oae({inputs:{x:r},backend:n,attrs:{perm:i}}),l.push(c),s=eZ(s.length,c.shape.length)),JJ("argMax",[s[0]],c.shape.length);const u=Eae(n,c,s[0],"max");return l.forEach((e=>n.disposeIntermediateTensorInfo(e))),u}};const _ae={kernelName:IG,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{axis:o}=a;let s=VU(o,r.shape);const i=ZJ(s,r.shape.length);let c=r;const l=[];null!=i&&(c=oae({inputs:{x:r},backend:n,attrs:{perm:i}}),l.push(c),s=eZ(s.length,c.shape.length)),JJ("argMin",[s[0]],c.shape.length);const u=Eae(n,c,s[0],"min");return l.forEach((e=>n.disposeIntermediateTensorInfo(e))),u}},Aae=Wne({opSnippet:sne+"\n  if (abs(x) > 1.) {\n    return NAN;\n  }\n  return asin(x);\n"}),Fae={kernelName:SG,backendName:"webgl",kernelFunc:Aae},Oae=Wne({opSnippet:sne+"return log(x + sqrt(x * x + 1.0));"}),Dae={kernelName:NG,backendName:"webgl",kernelFunc:Oae},Mae=Wne({opSnippet:sne+"\n  return atan(x);\n"}),Lae={kernelName:CG,backendName:"webgl",kernelFunc:Mae},Pae=Vne({opSnippet:Nne+"\n  return atan(a, b);\n",packedOpSnippet:"\n  vec4 result = atan(a, b);\n  bvec4 isNaNA = isnan(a);\n  bvec4 isNaNB = isnan(b);\n  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);\n  "+Tne+"\n  return result;\n"}),zae={kernelName:EG,backendName:"webgl",kernelFunc:Pae},Bae=Wne({opSnippet:sne+"\n  if ((x < -1.0) || (x > 1.0)) return NAN;\nreturn (log(1.0 + x) - log(1.0 - x)) / 2.0;"}),Wae={kernelName:TG,backendName:"webgl",kernelFunc:Bae};class Vae{constructor(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]&&arguments[3],r=arguments.length>4&&void 0!==arguments[4]&&arguments[4];if(this.variableNames=["x"],"avg"===t&&n)throw new Error("Cannot compute positions for average pool.");const o=e.filterWidth,s=e.strideHeight,i=e.strideWidth,c=e.dilationHeight,l=e.dilationWidth,u=e.effectiveFilterHeight,d=e.effectiveFilterWidth,h=e.padInfo.top,p=e.padInfo.left;this.outputShape=e.outShape;const f="avg"===t,m="((batch  * ".concat(e.inHeight," + xR) * ").concat(e.inWidth," + xC) * ").concat(e.inChannels," + d"),g="(xR * ".concat(e.inWidth," + xC) * ").concat(e.inChannels," + d");let b="0.0";if(f||(b="-1.0 / 1e-20"),n){const t=">=";return void(this.userCode="\n        const ivec2 strides = ivec2(".concat(s,", ").concat(i,");\n        const ivec2 pads = ivec2(").concat(h,", ").concat(p,");\n\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int batch = coords[0];\n          int d = coords[3];\n\n          ivec2 xRCCorner = coords.yz * strides - pads;\n          int xRCorner = xRCCorner.x;\n          int xCCorner = xRCCorner.y;\n\n          // max/min x(?, ?, d) to get y(yR, yC, d).\n          // ? = to be determined\n          float minMaxValue = 0.0;\n          float minMaxValueFound = 0.0;\n          int minMaxPosition = 0;\n          float avgValue = 0.0;\n\n          for (int wR = 0; wR < ").concat(u,";\n              wR += ").concat(c,") {\n            int xR = xRCorner + wR;\n\n            if (xR < 0 || xR >= ").concat(e.inHeight,") {\n              continue;\n            }\n\n            for (int wC = 0; wC < ").concat(d,";\n                wC += ").concat(l,") {\n              int xC = xCCorner + wC;\n\n              if (xC < 0 || xC >= ").concat(e.inWidth,") {\n                continue;\n              }\n\n              float value = getX(batch, xR, xC, d);\n\n              // If a min / max value has already been found, use it. If not,\n              // use the current value.\n              float currMinMaxValue = mix(\n                  value, minMaxValue, minMaxValueFound);\n              if (value ").concat(t," currMinMaxValue) {\n                minMaxValue = value;\n                minMaxValueFound = 1.0;\n                minMaxPosition = ").concat(a?r?m:g:"wR * ".concat(d," + wC"),";\n              }\n            }\n          }\n          setOutput(float(minMaxPosition));\n        }\n      "))}let y="".concat(t,"(").concat(t,"(").concat(t,"(")+"minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])";"avg"===t&&(y="avgValue / max(count, 1.0)");const x=4*Math.floor(o/4),v=o%4,w="\n      if (".concat(f,") {\n        avgValue += dot(values, ones);\n      } else {\n        minMaxValue = ").concat("max","(values, minMaxValue);\n      }\n    ");this.userCode="\n      const ivec2 strides = ivec2(".concat(s,", ").concat(i,");\n      const ivec2 pads = ivec2(").concat(h,", ").concat(p,");\n      const float initializationValue = ").concat(b,";\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float count = 0.0;\n\n      float getValue(int batch, int xR, int xC, int d) {\n        if (xC < 0 || xC >= ").concat(e.inWidth,") {\n          return initializationValue;\n        }\n        count += 1.0;\n        return getX(batch, xR, xC, d);\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d = coords[3];\n\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // max/min x(?, ?, d) to get y(yR, yC, d).\n        // ? = to be determined\n        vec4 minMaxValue = vec4(").concat(b,");\n        float avgValue = 0.0;\n        count = 0.0;\n\n        for (int wR = 0; wR < ").concat(u,";\n            wR += ").concat(c,") {\n          int xR = xRCorner + wR;\n\n          if (xR < 0 || xR >= ").concat(e.inHeight,") {\n            continue;\n          }\n\n          for (int wC = 0; wC < ").concat(x,"; wC += 4) {\n            int xC = xCCorner + wC * ").concat(l,";\n\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ").concat(l,", d),\n              getValue(batch, xR, xC + 2 * ").concat(l,", d),\n              getValue(batch, xR, xC + 3 * ").concat(l,", d)\n            );\n\n            ").concat(w,"\n          }\n\n          int xC = xCCorner + ").concat(x,";\n          if (").concat(1===v,") {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              initializationValue,\n              initializationValue,\n              initializationValue\n            );\n\n            ").concat(w,"\n          } else if (").concat(2===v,") {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ").concat(l,", d),\n              initializationValue,\n              initializationValue\n            );\n\n            ").concat(w,"\n          } else if (").concat(3===v,") {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ").concat(l,", d),\n              getValue(batch, xR, xC + 2 * ").concat(l,", d),\n              initializationValue\n            );\n\n            ").concat(w,"\n          }\n        }\n        setOutput(").concat(y,");\n      }\n    ")}}class Uae{constructor(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]&&arguments[3],r=arguments.length>4&&void 0!==arguments[4]&&arguments[4];if(this.variableNames=["x"],"avg"===t&&n)throw new Error("Cannot compute positions for average pool.");const o=e.filterWidth,s=e.strideDepth,i=e.strideHeight,c=e.strideWidth,l=e.dilationDepth,u=e.dilationHeight,d=e.dilationWidth,h=e.effectiveFilterDepth,p=e.effectiveFilterHeight,f=e.effectiveFilterWidth,m=e.padInfo.front,g=e.padInfo.top,b=e.padInfo.left;this.outputShape=e.outShape;const y="avg"===t;let x="0.0";if(y||(x="-1.0 / 1e-20"),n){const t=">=";return void(this.userCode="\n        const ivec3 strides =\n            ivec3(".concat(s,", ").concat(i,", ").concat(c,");\n        const ivec3 pads = ivec3(").concat(m,", ").concat(g,", ").concat(b,");\n\n        void main() {\n          ivec5 coords = getOutputCoords();\n          int batch = coords.x;\n          int ch = coords.u;\n\n          ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n          int xDCorner = xCorner.x;\n          int xRCorner = xCorner.y;\n          int xCCorner = xCorner.z;\n\n          // max/min x(?, ?, ?, ch) to get y(yD, yR, yC, ch).\n          // ? = to be determined\n          float minMaxValue = 0.0;\n          float minMaxValueFound = 0.0;\n          int minMaxPosition = 0;\n\n          for (int wD = 0; wD < ").concat(h,";\n              wD += ").concat(l,") {\n            int xD = xDCorner + wD;\n\n            if (xD < 0 || xD >= ").concat(e.inDepth,") {\n              continue;\n            }\n\n            for (int wR = 0; wR < ").concat(p,";\n                wR += ").concat(u,") {\n              int xR = xRCorner + wR;\n\n              if (xR < 0 || xR >= ").concat(e.inHeight,") {\n                continue;\n              }\n\n              for (int wC = 0; wC < ").concat(f,";\n                  wC += ").concat(d,") {\n                int xC = xCCorner + wC;\n\n                if (xC < 0 || xC >= ").concat(e.inWidth,") {\n                  continue;\n                }\n\n                float value = getX(batch, xD, xR, xC, ch);\n\n                // If a min / max value has already been found, use it. If not,\n                // use the current value.\n                float currMinMaxValue = mix(\n                    value, minMaxValue, minMaxValueFound);\n                if (value ").concat(t," currMinMaxValue) {\n                  minMaxValue = value;\n                  minMaxValueFound = 1.0;\n                  minMaxPosition = ").concat(a?r?"(((batch * ".concat(e.inDepth," + xD) * ").concat(e.inHeight," + xR) * ").concat(e.inWidth," + xC) * ").concat(e.inChannels," + ch"):"((xD * ".concat(e.inHeight," + xR) * ").concat(e.inWidth," + xC) * ").concat(e.inChannels," + ch"):"wD * ".concat(p," * ").concat(f," +\n                      wR * ").concat(f," + wC"),";\n                }\n              }\n            }\n          }\n          setOutput(float(minMaxPosition));\n        }\n      "))}let v="".concat(t,"(").concat(t,"(").concat(t,"(")+"minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])";"avg"===t&&(v="avgValue / max(count, 1.0)");const w=4*Math.floor(o/4),k=o%4,I="\n      if (".concat(y,") {\n        avgValue += dot(values, ones);\n      } else {\n        minMaxValue = ").concat("max","(values, minMaxValue);\n      }\n    ");this.userCode="\n      const ivec3 strides =\n        ivec3(".concat(s,", ").concat(i,", ").concat(c,");\n      const ivec3 pads = ivec3(").concat(m,", ").concat(g,", ").concat(b,");\n      const float initializationValue = ").concat(x,";\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float count = 0.0;\n\n      float getValue(int batch, int xD, int xR, int xC, int ch) {\n        if (xC < 0 || xC >= ").concat(e.inWidth,") {\n          return initializationValue;\n        }\n        count += 1.0;\n        return getX(batch, xD, xR, xC, ch);\n      }\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n        int xDCorner = xCorner.x;\n        int xRCorner = xCorner.y;\n        int xCCorner = xCorner.z;\n\n        // max/min x(?, ?, ?, d) to get y(yD, yR, yC, ch).\n        // ? = to be determined\n        vec4 minMaxValue = vec4(").concat(x,");\n        float avgValue = 0.0;\n        count = 0.0;\n\n        for (int wD = 0; wD < ").concat(h,";\n            wD += ").concat(l,") {\n          int xD = xDCorner + wD;\n\n          if (xD < 0 || xD >= ").concat(e.inDepth,") {\n            continue;\n          }\n\n          for (int wR = 0; wR < ").concat(p,";\n            wR += ").concat(u,") {\n            int xR = xRCorner + wR;\n\n            if (xR < 0 || xR >= ").concat(e.inHeight,") {\n              continue;\n            }\n\n            for (int wC = 0; wC < ").concat(w,"; wC += 4) {\n              int xC = xCCorner + wC * ").concat(d,";\n\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ").concat(d,", ch),\n                getValue(batch, xD, xR, xC + 2 * ").concat(d,", ch),\n                getValue(batch, xD, xR, xC + 3 * ").concat(d,", ch)\n              );\n\n              ").concat(I,"\n            }\n\n            int xC = xCCorner + ").concat(w,";\n            if (").concat(1===k,") {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                initializationValue,\n                initializationValue,\n                initializationValue\n              );\n\n              ").concat(I,"\n            } else if (").concat(2===k,") {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ").concat(d,", ch),\n                initializationValue,\n                initializationValue\n              );\n\n              ").concat(I,"\n            } else if (").concat(3===k,") {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ").concat(d,", ch),\n                getValue(batch, xD, xR, xC + 2 * ").concat(d,", ch),\n                initializationValue\n              );\n\n              ").concat(I,"\n            }\n          }\n        }\n        setOutput(").concat(v,");\n      }\n    ")}}const Gae={kernelName:RG,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t;hee(r,"avgPool");const{filterSize:o,strides:s,pad:i,dimRoundingMode:c}=a;AU(YQ(s,1),(()=>"Error in avgPool: Either strides or dilations must be 1. "+"Got strides ".concat(s," and dilations '").concat(1,"'")));const l=BQ(r.shape,o,s,1,i,c);if(1===l.filterWidth&&1===l.filterHeight&&MU(l.inShape,l.outShape))return Rne({inputs:{x:r},backend:n});const u=new Vae(l,"avg",!1);return n.runWebGLProgram(u,[r],"float32")}};const Hae={kernelName:AG,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{filterSize:o,strides:s,pad:i,dimRoundingMode:c,dataFormat:l}=a,u=WQ(r.shape,o,s,[1,1,1],i,c,l),d=new Uae(u,"avg",!1);return n.runWebGLProgram(d,[r],"float32")}};class jae{constructor(e){this.variableNames=["dy"],this.outputShape=e.inShape;const t=e.filterHeight,n=e.filterWidth,a=e.strideHeight,r=e.strideWidth,o=e.dilationHeight,s=e.dilationWidth,i=e.effectiveFilterHeight,c=e.effectiveFilterWidth,l=i-1-e.padInfo.top,u=c-1-e.padInfo.left,d=1/(t*n);this.userCode="\n      const ivec2 pads = ivec2(".concat(l,", ").concat(u,");\n      const float avgMultiplier = float(").concat(d,");\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n\n        ivec2 dyRCCorner = coords.yz - pads;\n        int dyRCorner = dyRCCorner.x;\n        int dyCCorner = dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ").concat(i,";\n            wR += ").concat(o,") {\n          float dyR = float(dyRCorner + wR) / ").concat(a,".0;\n\n          if (dyR < 0.0 || dyR >= ").concat(e.outHeight,".0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          for (int wC = 0; wC < ").concat(c,";\n            wC+= ").concat(s,") {\n            float dyC = float(dyCCorner + wC) / ").concat(r,".0;\n\n            if (dyC < 0.0 || dyC >= ").concat(e.outWidth,".0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            float dyValue = getDy(b, idyR, idyC, d);\n\n            dotProd += dyValue * avgMultiplier;\n          }\n        }\n        setOutput(dotProd);\n      }\n    ")}}class Kae{constructor(e){this.variableNames=["dy"],this.outputShape=e.inShape;const t=e.filterDepth,n=e.filterHeight,a=e.filterWidth,r=e.strideDepth,o=e.strideHeight,s=e.strideWidth,i=e.dilationDepth,c=e.dilationHeight,l=e.dilationWidth,u=e.effectiveFilterDepth,d=e.effectiveFilterHeight,h=e.effectiveFilterWidth,p=u-1-e.padInfo.front,f=d-1-e.padInfo.top,m=h-1-e.padInfo.left,g=1/(t*n*a);this.userCode="\n      const ivec3 pads = ivec3(".concat(p,", ").concat(f,", ").concat(m,");\n      const float avgMultiplier = float(").concat(g,");\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyDCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        // Convolve dy(?, ?, ?, d) with pos mask(:, :, :, ch) to get\n        // dx(xD, xR, xC, ch).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int wD = 0; wD < ").concat(u,";\n            wD += ").concat(i,") {\n          float dyD = float(dyDCorner + wD) / ").concat(r,".0;\n\n          if (dyD < 0.0 || dyD >= ").concat(e.outDepth,".0 || fract(dyD) > 0.0) {\n            continue;\n          }\n          int idyD = int(dyD);\n\n          for (int wR = 0; wR < ").concat(d,";\n              wR += ").concat(c,") {\n            float dyR = float(dyRCorner + wR) / ").concat(o,".0;\n\n            if (dyR < 0.0 || dyR >= ").concat(e.outHeight,".0 ||\n                fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            for (int wC = 0; wC < ").concat(h,";\n                wC += ").concat(l,") {\n              float dyC = float(dyCCorner + wC) / ").concat(s,".0;\n\n              if (dyC < 0.0 || dyC >= ").concat(e.outWidth,".0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              float dyValue = getDy(batch, idyD, idyR, idyC, ch);\n\n              dotProd += dyValue * avgMultiplier;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    ")}}const qae={kernelName:FG,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{dy:r,input:o}=t,s=o,{filterSize:i,strides:c,pad:l,dimRoundingMode:u}=a,d=WQ(s.shape,i,c,[1,1,1],l,u),h=new Kae(d);return n.runWebGLProgram(h,[r],s.dtype)}};const Xae={kernelName:_G,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{dy:r,input:o}=t,s=o;hee([r,o],"avgPoolGrad");const{filterSize:i,strides:c,pad:l}=a,u=BQ(s.shape,i,c,1,l),d=new jae(u);return n.runWebGLProgram(d,[r],s.dtype)}};const Yae={kernelName:OG,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{a:r,b:o}=t,{transposeA:s,transposeB:i}=a;return cae({a:r,b:o,transposeA:s,transposeB:i,backend:n})}};class Qae{constructor(e,t,n,a,r,o){this.outputShape=[],this.variableNames=["x","mean","variance"],OY(e,t),OY(e,n);let s="0.0";null!=a&&(OY(e,a),this.variableNames.push("offset"),s="getOffsetAtOutCoords()");let i="1.0";null!=r&&(OY(e,r),this.variableNames.push("scale"),i="getScaleAtOutCoords()"),this.outputShape=e,this.userCode="\n      void main() {\n        float x = getXAtOutCoords();\n        float mean = getMeanAtOutCoords();\n        float variance = getVarianceAtOutCoords();\n        float offset = ".concat(s,";\n        float scale = ").concat(i,";\n        float inv = scale * inversesqrt(variance + float(").concat(o,"));\n        setOutput(dot(vec3(x, -mean, offset), vec3(inv, inv, 1)));\n      }\n    ")}}class Jae{constructor(e,t,n,a,r,o){this.packedInputs=!0,this.packedOutput=!0,this.variableNames=["x","mean","variance"],OY(e,t),OY(e,n);let s="vec4(0.0)";null!=a&&(OY(e,a),this.variableNames.push("offset"),s="getOffsetAtOutCoords()");let i="vec4(1.0)";null!=r&&(OY(e,r),this.variableNames.push("scale"),i="getScaleAtOutCoords()"),this.outputShape=e,this.userCode="\n      void main() {\n        vec4 offset = ".concat(s,";\n        vec4 scale = ").concat(i,";\n\n        vec4 x = getXAtOutCoords();\n        vec4 mean = getMeanAtOutCoords();\n        vec4 variance = getVarianceAtOutCoords();\n\n        vec4 inv = scale * inversesqrt(variance + vec4(").concat(o,"));\n\n        setOutput((x - mean) * inv + offset);\n      }\n    ")}}const Zae={kernelName:NH,backendName:"webgl",kernelFunc:e=>{let{inputs:t,backend:n,attrs:a}=e;const{x:r,mean:o,variance:s,offset:i,scale:c}=t;AU(o.shape.length===s.shape.length,(()=>"Batch normalization gradient requires mean and variance to have equal ranks.")),AU(null==i||o.shape.length===i.shape.length,(()=>"Batch normalization gradient requires mean and offset to have equal ranks.")),AU(null==c||o.shape.length===c.shape.length,(()=>"Batch normalization gradient requires mean and scale to have equal ranks."));let{varianceEpsilon:l}=a;null==l&&(l=.001);const u=[r,o,s];let d=null;null!=i&&(d=i.shape,u.push(i));let h=null;null!=c&&(h=c.shape,u.push(c));const p=uG().getBool("WEBGL_PACK_NORMALIZATION")?new Jae(r.shape,o.shape,s.shape,d,h,l):new Qae(r.shape,o.shape,s.shape,d,h,l);return n.runWebGLProgram(p,u,u[0].dtype)}};class $ae{constructor(e){this.variableNames=["source"],this.outputShape=e,this.rank=e.length;const t=_ee(this.rank);this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];const n=function(e){if(1===e)return"sourceLoc";if(e<=6)return ere.slice(0,e).map((e=>"sourceLoc."+e)).join(",");throw Error("Slicing for rank ".concat(e," is not yet supported"))}(this.rank);let a;const r=e.map(((e,t)=>"sourceLoc.".concat(ere[t]," = start[").concat(t,"] + coords.").concat(ere[t],";")));a="\n        ".concat(t," sourceLoc;\n        ").concat(t," coords = getOutputCoords();\n        ").concat(r.join("\n"),"\n      "),this.userCode="\n      void main() {\n        ".concat(a,"\n        setOutput(getSource(").concat(n,"));\n      }\n    ")}}const ere=["x","y","z","w","u","v"];class tre{constructor(e){this.variableNames=["source"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.rank=e.length,this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];const t=_ee(this.rank),n=Zte("coords",this.rank),a=Zte("sourceLoc",this.rank),r=1===this.rank?"sourceLoc":"vec2(".concat(a.slice(-2).join(),")"),o="getChannel(getSource(".concat(a.join(),"), ").concat(r,")"),s="\n      result.x = ".concat(o,";\n      if (++").concat(n[this.rank-1]," < ").concat(e[this.rank-1],") {\n        ++").concat(a[this.rank-1],";\n        result.y = ").concat(o,";\n        --").concat(a[this.rank-1],";\n      }\n    "),i=1===this.rank?"":"\n      --".concat(n[this.rank-1],";\n      if (++").concat(n[this.rank-2]," < ").concat(e[this.rank-2],") {\n        ++").concat(a[this.rank-2],";\n        result.z = ").concat(o,";\n        if (++").concat(n[this.rank-1]," < ").concat(e[this.rank-1],") {\n          ++").concat(a[this.rank-1],";\n          result.w = ").concat(o,";\n        }\n      }\n    "),c=this.rank<=4?"sourceLoc = coords +\n            ".concat(t,"(").concat(e.map(((e,t)=>"start[".concat(t,"]"))).join(),");"):e.map(((e,t)=>"".concat(a[t]," = ").concat(n[t]," + start[").concat(t,"];"))).join("\n");this.userCode="\n      void main() {\n        ".concat(t," coords = getOutputCoords();\n        ").concat(t," sourceLoc;\n        ").concat(c,"\n        vec4 result = vec4(0.);\n        ").concat(s,"\n        ").concat(i,"\n        setOutput(result);\n      }\n    ")}}function nre(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{begin:o,size:s}=a,[i,c]=IQ(r,o,s);if(lQ(r,i,c),0===DU(c))return n.makeTensorInfo(c,r.dtype,[]);if(n.shouldExecuteOnCPU([r])||"string"===r.dtype){const e=n.texData.get(r.dataId),t=Lte(e.values,i,c,r.shape,r.dtype);return n.makeTensorInfo(c,r.dtype,t)}const{isPacked:l}=n.texData.get(r.dataId),u=wQ(r.shape,i,c);if(l||!u){const e=uG().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new tre(c):new $ae(c),t=[i];return n.runWebGLProgram(e,[r],r.dtype,t)}return n.uploadToGPU(r.dataId),function(e,t,n,a){const r=a.texData.get(e.dataId),o=a.makeTensorInfo(n,e.dtype),s=a.texData.get(o.dataId);Object.assign(s,r),s.refCount=1,s.shape=n,s.dtype=e.dtype;let i=kQ(t,JU(e.shape));r.slice&&(i+=r.slice.flatOffset),s.slice={flatOffset:i,origDataId:r.slice&&r.slice.origDataId||e.dataId};const c=a.dataRefCount.get(s.slice.origDataId)||1;return a.dataRefCount.set(s.slice.origDataId,c+1),o}(r,i,c,n)}const are={kernelName:Wj,backendName:"webgl",kernelFunc:nre},rre={kernelName:DG,backendName:"webgl",kernelFunc:e=>{const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{blockShape:o,crops:s}=a;AU(r.shape.length<=4,(()=>"batchToSpaceND for rank > 4 with a WebGL backend not implemented yet"));const i=o.reduce(((e,t)=>e*t)),c=n2(r.shape,o,i),l=a2(c.length,o.length),u=r2(r.shape,o,i),d=o2(s,o.length),h=s2(u,s,o.length),p=[],f=Yne({inputs:{x:r},backend:n,attrs:{shape:c}}),m=oae({inputs:{x:f},backend:n,attrs:{perm:l}}),g=Yne({inputs:{x:m},backend:n,attrs:{shape:u}}),b=nre({inputs:{x:g},backend:n,attrs:{begin:d,size:h}});return p.push(f),p.push(m),p.push(g),p.forEach((e=>n.disposeIntermediateTensorInfo(e))),b}};const ore={kernelName:MG,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r,weights:o}=t,{size:s}=a,i=n.readSync(r.dataId),c=n.readSync(o.dataId),l=ate(i,c,o.dtype,o.shape,s);return n.makeTensorInfo([s],o.dtype,l)}};const sre={kernelName:LG,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{a:a,b:r}=t,o=uG().getBool("WEBGL_PACK_BINARY_OPERATIONS"),s=uG().getNumber("WEBGL_VERSION");if(n.shouldExecuteOnCPU([a,r])||1===s){const e=n.texData.get(a.dataId).values,t=n.texData.get(r.dataId).values,[o,s]=ote(a.shape,r.shape,e,t,a.dtype),i=n.makeTensorInfo(s,a.dtype);return n.texData.get(i.dataId).values=o,i}let i;return i=o?new Ene("\n  int r = int(a.r) & int(b.r);\n  int g = int(a.g) & int(b.g);\n  int rb = int(a.b) & int(b.b);\n  int ra = int(a.a) & int(b.a);\n  return vec4(r, g, rb, ra);\n",a.shape,r.shape,!1):new Cne("\n  return float(int(a.r) & int(b.r));\n",a.shape,r.shape),n.runWebGLProgram(i,[a,r],a.dtype)}};const ire={kernelName:PG,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{s0:a,s1:r}=t,o=n.readSync(a.dataId),s=n.readSync(r.dataId),i=OY(Array.from(o),Array.from(s));return n.makeTensorInfo([i.length],"int32",Int32Array.from(i))}},cre=Vne({opSnippet:"return float(a != b);",cpuKernelImpl:Cte,dtype:"bool"}),lre={kernelName:cj,backendName:"webgl",kernelFunc:cre};function ure(e){const{inputs:t,backend:n}=e,{input:a}=t;return Rne({inputs:{x:n.texData.get(a.dataId).complexTensorInfos.real},backend:n})}const dre={kernelName:Ij,backendName:"webgl",kernelFunc:ure},hre="return float(int(x));";const pre={kernelName:zG,backendName:"webgl",kernelFunc:function e(t){const{inputs:n,backend:a,attrs:r}=t,{x:o}=n,{dtype:s}=r;if("complex64"===s){if("complex64"===o.dtype)return Rne({inputs:{x:o},backend:a});const t=GZ(o.shape),n=e({inputs:{x:o},backend:a,attrs:{dtype:"float32"}}),r=Ane({inputs:{real:n,imag:t},backend:a});return t.dispose(),a.disposeIntermediateTensorInfo(n),r}if("complex64"===o.dtype){const t=ure({inputs:{input:o},backend:a}),n=e({inputs:{x:t},backend:a,attrs:{dtype:s}});return a.disposeIntermediateTensorInfo(t),n}if(!jU(o.dtype,s)){const e=Rne({inputs:{x:o},backend:a});return{dataId:e.dataId,shape:e.shape,dtype:s}}if(a.shouldExecuteOnCPU([o])){const e=a.texData.get(o.dataId).values,[t,n,r]=ste(e,o.shape,o.dtype,s);return a.makeTensorInfo(t,n,r)}if("int32"===s)return function(e,t){const n=new one(e.shape,hre),a=t.runWebGLProgram(n,[e],"int32");return{dataId:a.dataId,shape:a.shape,dtype:a.dtype}}(o,a);if("bool"===s){const e=a.makeTensorInfo([],"bool",GU("bool",1)),t=cre({inputs:{a:o,b:e},backend:a});return a.disposeIntermediateTensorInfo(e),t}throw new Error("Error in Cast: failed to cast ".concat(o.dtype," to ").concat(s))}},fre="return ceil(x);",mre=Wne({opSnippet:fre,packedOpSnippet:fre,cpuKernelImpl:ite}),gre={kernelName:BG,backendName:"webgl",kernelFunc:mre};class bre{constructor(e){this.variableNames=["A"],this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=e,this.userCode="\n\n      void main() {\n        float value = getAAtOutCoords();\n        if (isnan(value)) {\n          setOutput(value);\n          return;\n        }\n\n        setOutput(clamp(value, minVal, maxVal));\n      }\n    "}}class yre{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=e,this.userCode="\n      void main() {\n        vec4 value = getAAtOutCoords();\n\n        if (any(isnan(value))) {\n          setOutput(value);\n          return;\n        }\n\n        setOutput(clamp(value, vec4(minVal), vec4(maxVal)));\n      }\n    "}}const xre={kernelName:WG,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{clipValueMin:o,clipValueMax:s}=a;let i;i=uG().getBool("WEBGL_PACK_CLIP")?new yre(r.shape):new bre(r.shape);const c=[[o],[s]];return n.runWebGLProgram(i,[r],r.dtype,c)}};class vre{constructor(e){this.variableNames=["real","imag"],this.outputShape=e,this.userCode="\n      void main() {\n        float re = abs(getRealAtOutCoords());\n        float im = abs(getImagAtOutCoords());\n        float mx = max(re, im);\n\n        // sadly the length function in glsl is not underflow-safe\n        // (at least not on Intel GPUs). So the safe solution is\n        // to ensure underflow-safety in all cases.\n        setOutput(\n          mx == 0.0 ? 0.0 : mx * length(vec2(1, min(re, im)/mx))\n        );\n      }\n    "}}function wre(e,t){return{dataId:t.dataId,dtype:t.dtype,shape:e.shape}}const kre={kernelName:UG,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{x:a}=t,r=n.texData.get(a.dataId),o=new vre(a.shape),s=[wre(a,r.complexTensorInfos.real),wre(a,r.complexTensorInfos.imag)];return n.runWebGLProgram(o,s,s[0].dtype)}};class Ire{constructor(e){this.outputShape=[],this.outputShape=q1(e,1),this.variableNames=e.map(((e,t)=>"T".concat(t)));const t=new Array(e.length-1);t[0]=e[0][1];for(let o=1;o<t.length;o++)t[o]=t[o-1]+e[o][1];const n=["if (yC < ".concat(t[0],") setOutput(getT0(yR, yC));")];for(let o=1;o<t.length;o++){const e=t[o-1];n.push("else if (yC < ".concat(t[o],") ")+"setOutput(getT".concat(o,"(yR, yC-").concat(e,"));"))}const a=t.length,r=t[t.length-1];n.push("else setOutput(getT".concat(a,"(yR, yC-").concat(r,"));")),this.userCode="\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int yR = coords.x;\n        int yC = coords.y;\n\n        ".concat(n.join("\n        "),"\n      }\n    ")}}class Sre{constructor(e,t){this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[],this.outputShape=q1(e,t);const n=this.outputShape,a=n.length,r=_ee(a),o=Zte("coords",a),s=["x","y","z","w","u","v"].slice(0,a);this.variableNames=e.map(((e,t)=>"T".concat(t)));const i=new Array(e.length-1);i[0]=e[0][t];for(let f=1;f<i.length;f++)i[f]=i[f-1]+e[f][t];const c=s[t],l=s.slice(-2),u=s.join();let d="if (".concat(c," < ").concat(i[0],") {\n        return getChannel(\n            getT0(").concat(u,"), vec2(").concat(l.join(),"));\n        }");for(let f=1;f<i.length;f++){const e=i[f-1];d+="\n        if (".concat(c," < ").concat(i[f],"  && ").concat(c," >= ").concat(i[f-1],") {\n          return getChannel(\n            getT").concat(f,"(").concat(Nre(s,c,e),"),\n            vec2(").concat(Nre(l,c,e),"));\n        }")}const h=i.length,p=i[i.length-1];d+="\n        return getChannel(\n          getT".concat(h,"(").concat(Nre(s,c,p),"),\n          vec2(").concat(Nre(l,c,p),"));"),this.userCode="\n      float getValue(".concat(s.map((e=>"int "+e)),") {\n        ").concat(d,"\n      }\n\n      void main() {\n        ").concat(r," coords = getOutputCoords();\n        vec4 result = vec4(getValue(").concat(o,"), 0., 0., 0.);\n\n        ").concat(o[a-1]," = ").concat(o[a-1]," + 1;\n        if (").concat(o[a-1]," < ").concat(n[a-1],") {\n          result.g = getValue(").concat(o,");\n        }\n\n        ").concat(o[a-2]," = ").concat(o[a-2]," + 1;\n        if (").concat(o[a-2]," < ").concat(n[a-2],") {\n          result.a = getValue(").concat(o,");\n        }\n\n        ").concat(o[a-1]," = ").concat(o[a-1]," - 1;\n        if (").concat(o[a-2]," < ").concat(n[a-2]," &&\n            ").concat(o[a-1]," < ").concat(n[a-1],") {\n          result.b = getValue(").concat(o,");\n        }\n        setOutput(result);\n      }\n    ")}}function Nre(e,t,n){const a=e.indexOf(t),r=e.map(((e,t)=>t===a?"".concat(e," - ").concat(n):e));return r.join()}function Cre(e){const{inputs:t,backend:n}=e,{input:a}=t;return Rne({inputs:{x:n.texData.get(a.dataId).complexTensorInfos.imag},backend:n})}const Tre={kernelName:FH,backendName:"webgl",kernelFunc:Cre};function Ere(e,t,n){const a=e[0].dtype;if("complex64"===a){const a=e.map((e=>ure({inputs:{input:e},backend:n}))),r=e.map((e=>Cre({inputs:{input:e},backend:n}))),o=Ere(a,t,n),s=Ere(r,t,n),i=Ane({inputs:{real:o,imag:s},backend:n});return a.forEach((e=>n.disposeIntermediateTensorInfo(e))),r.forEach((e=>n.disposeIntermediateTensorInfo(e))),n.disposeIntermediateTensorInfo(o),n.disposeIntermediateTensorInfo(s),i}let r=n.shouldExecuteOnCPU(e);if("string"===a&&(r=!0),r){const r=e.map((e=>{const a=DU(e.shape.slice(t));return Yne({inputs:{x:e},backend:n,attrs:{shape:[-1,a]}})})),o=r.map((e=>({vals:n.readSync(e.dataId),shape:e.shape}))),s=q1(r.map((e=>e.shape)),1),i=1===r[0].shape[0],c=cte(o,s,a,i),l=q1(e.map((e=>e.shape)),t),u=n.makeTensorInfo(l,a,c);return r.forEach((e=>n.disposeIntermediateTensorInfo(e))),u}const o=e.filter((e=>DU(e.shape)>0)),s=uG().getBool("WEBGL_PACK_ARRAY_OPERATIONS")&&o[0].shape.length>1;if(1===o.length){const t=s?new one(e[0].shape,hne):new xne(e[0].shape,hne);return n.runWebGLProgram(t,e,a)}const i=uG().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER");if(o.length>i){const e=[];for(let r=0;r<o.length;r+=i){const a=o.slice(r,r+i);e.push(Ere(a,t,n))}const a=Ere(e,t,n);for(const t of e)n.disposeIntermediateTensorInfo(t);return a}if(s){const e=new Sre(o.map((e=>e.shape)),t);return n.runWebGLProgram(e,o,a)}const{tensors2D:c,outShape:l}=function(e,t,n){const a=q1(e.map((e=>e.shape)),t),r=e.map((e=>Yne({inputs:{x:e},attrs:{shape:[-1,DU(e.shape.slice(t))]},backend:n})));return{tensors2D:r,outShape:a}}(o,t,n),u=new Ire(c.map((e=>e.shape))),d=n.runWebGLProgram(u,c,a);c.forEach((e=>n.disposeIntermediateTensorInfo(e)));const h=Yne({inputs:{x:d},attrs:{shape:l},backend:n});return n.disposeIntermediateTensorInfo(d),h}function Rre(e){const{inputs:t,backend:n,attrs:a}=e,{axis:r}=a,o=VU(r,t[0].shape)[0],s=t.map((e=>e.shape));K1(s,o);const i=q1(t.map((e=>e.shape)),o);if(0===DU(i))return n.makeTensorInfo(i,t[0].dtype,[]);const c=t.filter((e=>DU(e.shape)>0));return 1===c.length?Rne({inputs:{x:c[0]},backend:n}):Ere(c,o,n)}const _re={kernelName:GG,backendName:"webgl",kernelFunc:Rre};class Are{constructor(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1],n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null,a=arguments.length>3&&void 0!==arguments[3]&&arguments[3],r=arguments.length>4&&void 0!==arguments[4]&&arguments[4];this.variableNames=["x","W"],this.outputShape=e.outShape;const o=e.padInfo.top,s=e.padInfo.left,i=e.strideHeight,c=e.strideWidth,l=e.dilationHeight,u=e.dilationWidth,d=e.filterHeight,h=e.filterWidth,p=4*Math.floor(e.inChannels/4),f=e.inChannels%4,m="channelsLast"===e.dataFormat,g=m?1:2,b=m?2:3,y=m?3:1;let x="",v="";n&&(x=a?"float activation(float a) {\n          float b = getPreluActivationWeightsAtOutCoords();\n          ".concat(n,"\n        }"):r?"float activation(float a) {\n          float b = getLeakyreluAlphaAtOutCoords();\n          ".concat(n,"\n        }"):"\n          float activation(float x) {\n            ".concat(n,"\n          }\n        "),v="result = activation(result);");const w=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),a&&this.variableNames.push("preluActivationWeights"),r&&this.variableNames.push("leakyreluAlpha"),this.userCode="\n      ".concat(x,"\n\n      const ivec2 strides = ivec2(").concat(i,", ").concat(c,");\n      const ivec2 pads = ivec2(").concat(o,", ").concat(s,");\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d2 = coords[").concat(y,"];\n\n        ivec2 xRCCorner =\n            ivec2(coords[").concat(g,"], coords[").concat(b,"]) * strides - pads;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // Convolve x(?, ?, d1) with w(:, :, d1, d2) to get y(yR, yC, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ").concat(d,"; wR++) {\n          int xR = xRCorner + wR * ").concat(l,";\n\n          if (xR < 0 || xR >= ").concat(e.inHeight,") {\n            continue;\n          }\n\n          for (int wC = 0; wC < ").concat(h,"; wC++) {\n            int xC = xCCorner + wC * ").concat(u,";\n\n            if (xC < 0 || xC >= ").concat(e.inWidth,") {\n              continue;\n            }\n\n            for (int d1 = 0; d1 < ").concat(p,"; d1 += 4) {\n              vec4 wValues = vec4(\n                getW(wR, wC, d1, d2),\n                getW(wR, wC, d1 + 1, d2),\n                getW(wR, wC, d1 + 2, d2),\n                getW(wR, wC, d1 + 3, d2)\n              );\n\n              if (").concat(m,") {\n                vec4 xValues = vec4(\n                  getX(batch, xR, xC, d1),\n                  getX(batch, xR, xC, d1 + 1),\n                  getX(batch, xR, xC, d1 + 2),\n                  getX(batch, xR, xC, d1 + 3)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec4 xValues = vec4(\n                  getX(batch, d1, xR, xC),\n                  getX(batch, d1 + 1, xR, xC),\n                  getX(batch, d1 + 2, xR, xC),\n                  getX(batch, d1 + 3, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n            }\n\n            if (").concat(1===f,") {\n\n              if (").concat(m,") {\n                dotProd +=\n                    getX(batch, xR, xC, ").concat(p,") *\n                    getW(wR, wC, ").concat(p,", d2);\n              } else {\n                dotProd +=\n                    getX(batch, ").concat(p,", xR, xC) *\n                    getW(wR, wC, ").concat(p,", d2);\n              }\n\n            } else if (").concat(2===f,") {\n              vec2 wValues = vec2(\n                getW(wR, wC, ").concat(p,", d2),\n                getW(wR, wC, ").concat(p," + 1, d2)\n              );\n\n              if (").concat(m,") {\n                vec2 xValues = vec2(\n                  getX(batch, xR, xC, ").concat(p,"),\n                  getX(batch, xR, xC, ").concat(p," + 1)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec2 xValues = vec2(\n                  getX(batch, ").concat(p,", xR, xC),\n                  getX(batch, ").concat(p," + 1, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n\n            } else if (").concat(3===f,") {\n              vec3 wValues = vec3(\n                getW(wR, wC, ").concat(p,", d2),\n                getW(wR, wC, ").concat(p," + 1, d2),\n                getW(wR, wC, ").concat(p," + 2, d2)\n              );\n\n              if (").concat(m,") {\n                vec3 xValues = vec3(\n                  getX(batch, xR, xC, ").concat(p,"),\n                  getX(batch, xR, xC, ").concat(p," + 1),\n                  getX(batch, xR, xC, ").concat(p," + 2)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec3 xValues = vec3(\n                  getX(batch, ").concat(p,", xR, xC),\n                  getX(batch, ").concat(p," + 1, xR, xC),\n                  getX(batch, ").concat(p," + 2, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n\n            }\n          }\n        }\n\n        float result = dotProd;\n        ").concat(w,"\n        ").concat(v,"\n        setOutput(result);\n      }\n    ")}}class Fre{constructor(e){this.variableNames=["x","W"],this.outputShape=e.outShape;const t=e.padInfo.front,n=e.padInfo.top,a=e.padInfo.left,r=e.strideDepth,o=e.strideHeight,s=e.strideWidth,i=e.dilationDepth,c=e.dilationHeight,l=e.dilationWidth,u=e.filterDepth,d=e.filterHeight,h=e.filterWidth,p=4*Math.floor(e.inChannels/4),f=e.inChannels%4;this.userCode="\n      const ivec3 strides = ivec3(".concat(r,", ").concat(o,", ").concat(s,");\n      const ivec3 pads = ivec3(").concat(t,", ").concat(n,", ").concat(a,");\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int d2 = coords.u;\n\n        ivec3 xFRCCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n        int xFCorner = xFRCCorner.x;\n        int xRCorner = xFRCCorner.y;\n        int xCCorner = xFRCCorner.z;\n\n        // Convolve x(?, ?, ?, d1) with w(:, :, :, d1, d2) to get\n        // y(yF, yR, yC, d2). ? = to be determined. : = across all\n        // values in that axis.\n        float dotProd = 0.0;\n        for (int wF = 0; wF < ").concat(u,"; wF++) {\n          int xF = xFCorner + wF * ").concat(i,";\n\n          if (xF < 0 || xF >= ").concat(e.inDepth,") {\n            continue;\n          }\n\n          for (int wR = 0; wR < ").concat(d,"; wR++) {\n            int xR = xRCorner + wR * ").concat(c,";\n\n            if (xR < 0 || xR >= ").concat(e.inHeight,") {\n              continue;\n            }\n\n            for (int wC = 0; wC < ").concat(h,"; wC++) {\n              int xC = xCCorner + wC * ").concat(l,";\n\n              if (xC < 0 || xC >= ").concat(e.inWidth,") {\n                continue;\n              }\n\n              for (int d1 = 0; d1 < ").concat(p,"; d1 += 4) {\n                vec4 xValues = vec4(\n                  getX(batch, xF, xR, xC, d1),\n                  getX(batch, xF, xR, xC, d1 + 1),\n                  getX(batch, xF, xR, xC, d1 + 2),\n                  getX(batch, xF, xR, xC, d1 + 3)\n                );\n                vec4 wValues = vec4(\n                  getW(wF, wR, wC, d1, d2),\n                  getW(wF, wR, wC, d1 + 1, d2),\n                  getW(wF, wR, wC, d1 + 2, d2),\n                  getW(wF, wR, wC, d1 + 3, d2)\n                );\n\n                dotProd += dot(xValues, wValues);\n              }\n\n              if (").concat(1===f,") {\n                dotProd +=\n                  getX(batch, xF, xR, xC, ").concat(p,") *\n                  getW(wF, wR, wC, ").concat(p,", d2);\n              } else if (").concat(2===f,") {\n                vec2 xValues = vec2(\n                  getX(batch, xF, xR, xC, ").concat(p,"),\n                  getX(batch, xF, xR, xC, ").concat(p," + 1)\n                );\n                vec2 wValues = vec2(\n                  getW(wF, wR, wC, ").concat(p,", d2),\n                  getW(wF, wR, wC, ").concat(p," + 1, d2)\n                );\n                dotProd += dot(xValues, wValues);\n              } else if (").concat(3===f,") {\n                vec3 xValues = vec3(\n                  getX(batch, xF, xR, xC, ").concat(p,"),\n                  getX(batch, xF, xR, xC, ").concat(p," + 1),\n                  getX(batch, xF, xR, xC, ").concat(p," + 2)\n                );\n                vec3 wValues = vec3(\n                  getW(wF, wR, wC, ").concat(p,", d2),\n                  getW(wF, wR, wC, ").concat(p," + 1, d2),\n                  getW(wF, wR, wC, ").concat(p," + 2, d2)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    ")}}class Ore{constructor(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1],n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null,a=arguments.length>3&&void 0!==arguments[3]&&arguments[3],r=arguments.length>4&&void 0!==arguments[4]&&arguments[4];this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=Pee(this.outputShape.length);const o=e.padInfo.left,s=e.strideWidth,i=e.dilationWidth,c=e.filterHeight,l=e.filterWidth,u=l;let d="\n       int xR; int xC; int xCOffset;\n       vec4 wTexel; vec4 previous; vec4 final;";for(let m=0;m<l;m++)d+="\n           vec4 xTexelC".concat(2*m,";\n           int xTexelC").concat(2*m,"Ready;\n           vec4 xTexelC").concat(2*m+1,";\n           int xTexelC").concat(2*m+1,"Ready;\n           vec4 xC").concat(m,";");d+="\n     for (int r = 0; r < ".concat(c,"; r++) {\n      for (int d1 = 0; d1 < ").concat(e.inChannels,"; d1 += 2) {\n       ");for(let m=0;m<l;m++)d+="\n           xTexelC".concat(2*m," = vec4(0.0);\n           xTexelC").concat(2*m,"Ready = 0;\n           xTexelC").concat(2*m+1," = vec4(0.0);\n           xTexelC").concat(2*m+1,"Ready = 0;\n           xC").concat(m," = vec4(0.0);");d+="\n         xR = xRCorner + r * dilations[0];\n         if (xR >=0 && xR < inDims[0]) {\n       ";for(let m=0;m<(u+1)/2;m++){const t=2*m;if(d+="\n           xC = xCCorner + ".concat(t*i,";\n           "),1===s){if(t<l&&(o%2===1?(d+="\n                 xCOffset = xC + 1;\n                 if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC".concat(t,"Ready == 0) {\n                   xTexelC").concat(t," = getX(batch, xR, xCOffset, d1);\n\n                   // Need to manually clear unused channels in case\n                   // we're reading from recycled texture.\n                   if (xCOffset + 1 >= inDims[1]) {\n                     xTexelC").concat(t,".zw = vec2(0.0);\n                   }\n                   xTexelC").concat(t,"Ready = 1;\n                 }\n               "),d+=1===i&&t>0?"\n                 xC".concat(t," = vec4(xTexelC").concat(t-2,".zw, xTexelC").concat(t,".xy);\n                 "):"\n                   xCOffset = xC + 1 - 2;\n\n                   if (xCOffset >= 0 && xCOffset < inDims[1]) {\n                     previous = getX(batch, xR, xCOffset, d1);\n\n                     // Need to manually clear unused channels in case\n                     // we're reading from recycled texture.\n                     if (xCOffset + 1 >= inDims[1]) {\n                       previous.zw = vec2(0.0);\n                     }\n\n                     xC".concat(t," = vec4(previous.zw, xTexelC").concat(t,".xy);\n                   } else {\n                     xC").concat(t," = vec4(0.0, 0.0, xTexelC").concat(t,".xy);\n                   }\n                   ")):d+="\n                 if (xC >= 0 && xC < inDims[1] && xTexelC".concat(t,"Ready == 0) {\n                   xTexelC").concat(t," = getX(batch, xR, xC, d1);\n                   if (xC + 1 >= inDims[1]) {\n                     xTexelC").concat(t,".zw = vec2(0.0);\n                   }\n                   xTexelC").concat(t,"Ready = 1;\n                 }\n\n                 xC").concat(t," = xTexelC").concat(t,";\n                 "),t+1<l)){const e=o%2===0?RU(i):i;i%2===0&&o%2===1||i%2!==0&&o%2!==1?(d+="\n                   xCOffset = xC + imod(pads[1], 2) + ".concat(e,";\n\n                   if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC").concat(t+1,"Ready == 0) {\n                     xTexelC").concat(t+1," = getX(batch, xR, xCOffset, d1);\n\n                     // Need to manually clear unused channels in case\n                     // we're reading from recycled texture.\n                     if (xCOffset + 1 >= inDims[1]) {\n                       xTexelC").concat(t+1,".zw = vec2(0.0);\n                     }\n                     xTexelC").concat(t+1,"Ready = 1;\n                   }\n                   "),d+=i>1?"\n                     xCOffset -= 2;\n                     if (xCOffset >= 0 && xCOffset < inDims[1]) {\n                      previous = getX(batch, xR, xCOffset, d1);\n                      xC".concat(t+1," = vec4(previous.zw, xTexelC").concat(t+1,".xy);\n                     } else {\n                      xC").concat(t+1," = vec4(0.0, 0.0, xTexelC").concat(t+1,".xy);\n                     }\n                     "):"\n                     xC".concat(t+1," = vec4(xTexelC").concat(t,".zw, xTexelC").concat(t+1,".xy);\n                     ")):d+=1===e?"\n                     xC".concat(t+1," = xTexelC").concat(t,";\n                     "):"\n                     xCOffset = xC + ".concat(e,";\n\n                     if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC").concat(t+1,"Ready == 0) {\n                       xTexelC").concat(t+1," = getX(batch, xR, xCOffset, d1);\n                       if (xCOffset + 1 >= inDims[1]) {\n                         xTexelC").concat(t+1,".zw = vec2(0.0);\n                       }\n                       xTexelC").concat(t+1,"Ready = 1;\n                     }\n\n                     xC").concat(t+1," = xTexelC").concat(t+1,";\n                     ")}}else t<l&&(o%2===1?(d+="\n                 xCOffset = xC + 1 - strides[1];\n                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC".concat(t,"Ready == 0) {\n                   xTexelC").concat(t," = getX(batch, xR, xCOffset, d1);\n                   // Need to manually clear unused channels in case\n                   // we're reading from recycled texture.\n                   if (xCOffset + 1 >= inDims[1]) {\n                     xTexelC").concat(t,".zw = vec2(0.0);\n                   }\n                   xTexelC").concat(t,"Ready = 1;\n                 }\n\n                 if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC").concat(t+1,"Ready == 0) {\n                   xTexelC").concat(t+1," = getX(batch, xR, xC + 1, d1);\n                   // Need to manually clear unused channels in case\n                   // we're reading from recycled texture.\n                   if (xC + 2 >= inDims[1]) {\n                     xTexelC").concat(t+1,".zw = vec2(0.0);\n                   }\n                   xTexelC").concat(t+1,"Ready = 1;\n                 }\n\n                 xC").concat(t," = vec4(xTexelC").concat(t,".zw, xTexelC").concat(t+1,".zw);\n               "),t+1<l&&(d+="\n                   final = vec4(0.0);\n                   xCOffset = xC + 1 + strides[1];\n                   if(xCOffset >= 0 && xCOffset < inDims[1]) {\n                     final = getX(batch, xR, xCOffset, d1);\n                   }\n                   xC".concat(t+1," = vec4(xTexelC").concat(t+1,".xy, final.xy);\n                 "))):(d+="\n                 if(xC >= 0 && xC < inDims[1] && xTexelC".concat(t,"Ready == 0) {\n                   xTexelC").concat(t," = getX(batch, xR, xC, d1);\n                   if (xC + 1 >= inDims[1]) {\n                     xTexelC").concat(t,".zw = vec2(0.0);\n                   }\n                   xTexelC").concat(t,"Ready = 1;\n                 }\n\n                 xCOffset = xC + strides[1];\n                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC").concat(t+1,"Ready == 0) {\n                   xTexelC").concat(t+1," = getX(batch, xR, xCOffset, d1);\n                   if (xCOffset + 1 >= inDims[1]) {\n                     xTexelC").concat(t+1,".zw = vec2(0.);\n                   }\n                   xTexelC").concat(t+1,"Ready = 1;\n                 }\n\n                 xC").concat(t," = vec4(\n                   xTexelC").concat(t,".xy, xTexelC").concat(t+1,".xy);\n               "),t+1<l&&(d+="\n                   xC".concat(t+1," = vec4(xTexelC").concat(t,".zw, xTexelC").concat(t+1,".zw);\n                 "))));t<l&&(d+="\n             wTexel = getW(r, ".concat(t,", d1, d2);\n             dotProd += xC").concat(t,".xxzz * vec4(wTexel.xy, wTexel.xy);\n             if(d1 + 1 < ").concat(e.inChannels,") {\n               dotProd += xC").concat(t,".yyww * vec4(wTexel.zw, wTexel.zw);\n             }\n           "),t+1<l&&(d+="\n               wTexel = getW(r, ".concat(t+1,", d1, d2);\n               dotProd += xC").concat(t+1,".xxzz * vec4(wTexel.xy, wTexel.xy);\n               if(d1 + 1 < ").concat(e.inChannels,") {\n                 dotProd += xC").concat(t+1,".yyww * vec4(wTexel.zw, wTexel.zw);\n               }\n             ")))}d+="\n     }\n   ",d+="\n     }\n   ",d+="\n     }\n   ";let h="",p="";n&&(h=a?"vec4 activation(vec4 a) {\n           vec4 b = getPreluActivationWeightsAtOutCoords();\n           ".concat(n,"\n         }"):r?"vec4 activation(vec4 a) {\n           vec4 b = getLeakyreluAlphaAtOutCoords();\n           ".concat(n,"\n         }"):"vec4 activation(vec4 x) {\n           ".concat(n,"\n         }"),p="result = activation(result);");const f=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),a&&this.variableNames.push("preluActivationWeights"),r&&this.variableNames.push("leakyreluAlpha"),this.userCode="\n       ".concat(h,"\n\n       void main() {\n         ivec4 coords = getOutputCoords();\n         int batch = coords.x;\n         ivec2 xRCCorner = coords.yz * strides - pads;\n         int d2 = coords.w;\n         int xRCorner = xRCCorner.x;\n         int xCCorner = xRCCorner.y;\n\n         //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.\n         vec4 dotProd = vec4(0.000000000000001);\n\n         ").concat(d,"\n\n         vec4 result = dotProd - vec4(0.000000000000001);\n         ").concat(f,"\n         ").concat(p,"\n         setOutput(result);\n       }\n     ")}}class Dre{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec4"},{name:"pad",type:"ivec2"},{name:"stride",type:"ivec2"},{name:"dilation",type:"ivec2"},{name:"inChannels",type:"int"},{name:"itemsPerBlockRow",type:"int"},{name:"outWidth",type:"int"}],this.outputShape=e,this.enableShapeUniforms=Pee(this.outputShape.length);const{dataFormat:n}=t,a=fee(),r="channelsLast"===n,o=r?1:2,s=r?2:3,i=this.enableShapeUniforms?"if(blockIndex < outShape[2] && pos < outShape[1]) {":"if(blockIndex < ".concat(e[2]," && pos < ").concat(e[1],") {");let c="";for(let l=0;l<=1;l++)for(let e=0;e<=1;e++)c+="\n          blockIndex = rc.z + ".concat(e,";\n          pos = rc.y + ").concat(l,";\n\n          ").concat(i,"\n            offsetY = int(blockIndex / outWidth) * stride[0] - pad[0];\n            d0 = offsetY + dilation[0] * (pos / itemsPerBlockRow);\n\n            if(d0 < inputShape[").concat(o,"] && d0 >= 0) {\n              // Use custom imod instead mod. On Intel GPU, mod may generate\n              // unexpected value.\n              // https://github.com/tensorflow/tfjs/issues/5447\n              offsetX = imod(blockIndex, outWidth) * stride[1] - pad[1];\n              d1 = offsetX + dilation[1] * (imod(pos, itemsPerBlockRow) /\n                  inChannels);\n\n              if(d1 < inputShape[").concat(s,"] && d1 >= 0) {\n\n                ch = imod(pos, inChannels);\n\n                if (").concat(r,") {\n                  innerDims = vec2(d1, ch);\n                  result[").concat(2*l+e,"] = getChannel(\n                    getA(rc.x, d0, int(innerDims.x),\n                    int(innerDims.y)), innerDims);\n                } else {\n                  innerDims = vec2(d0, d1);\n                  result[").concat(2*l+e,"] = getChannel(\n                    getA(rc.x, ch, int(innerDims.x),\n                    int(innerDims.y)), innerDims);\n                }\n              }\n            }\n          }\n        ");this.userCode="\n      void main() {\n        ivec3 rc = getOutputCoords();\n\n        vec4 result = vec4(0);\n\n        int blockIndex, pos, offsetY, d0, offsetX, d1, ch;\n        vec2 innerDims;\n\n        ".concat(c,"\n\n        ").concat(a.output," = result;\n      }\n    ")}}function Mre(e,t){const n=e.length;return n>=3?t?[...e.slice(0,-3),e[n-3]*e[n-2],e[n-1]]:[...e.slice(0,-3),e[n-3],e[n-2]*e[n-1]]:!t&&1===n&&e[0]>1?[e[0],1]:null}function Lre(e){let{x:t,filter:n,convInfo:a,backend:r,bias:o=null,preluActivationWeights:s=null,leakyreluAlpha:i=0,activation:c=null}=e;const l=t.shape,u=r.texData.get(t.dataId),d=a.inChannels,h=l[0]*l[1]*l[2],p=a.outChannels,f="channelsLast"===a.dataFormat,m=!1;let g;const b=[];if(null!=s){const e=Mre(s.shape,f);null!=e&&(s=Yne({inputs:{x:s},backend:r,attrs:{shape:e}}),b.push(s))}if(null!=o){const e=Mre(o.shape,f);null!=e&&(o=Yne({inputs:{x:o},backend:r,attrs:{shape:e}}),b.push(o))}if(!((1===h||1===p)&&d>iae)&&u.isPacked&&f&&null!=u.texture&&l[2]%2!==0&&MU(u.shape.slice(-3),l.slice(-3))){const e=l[0]*l[1]*(l[2]+1),d={dataId:t.dataId,shape:[1,e,a.inChannels],dtype:t.dtype},h=u.shape;u.shape=u.shape.slice(),u.shape[u.shape.length-2]++,AU(oee(u.shape,d.shape),(()=>"packed reshape ".concat(u.shape," to ").concat(d.shape," isn't free")));const p=Yne({inputs:{x:n},backend:r,attrs:{shape:[1,a.inChannels,a.outChannels]}});b.push(p);const f=cae({a:d,b:p,backend:r,transposeA:false,transposeB:m,bias:o,activation:c,preluActivationWeights:s,leakyreluAlpha:i}),y=r.texData.get(f.dataId);AU(y.isPacked,(()=>"batchMatMul result is expected to be packed")),u.shape=h,y.shape=a.outShape,g=Rne({inputs:{x:f},backend:r}),g.shape=a.outShape,b.push(f)}else{const e=a.outHeight*a.outWidth,l=Yne({inputs:{x:t},backend:r,attrs:{shape:f?[a.batchSize,e,a.inChannels]:[a.batchSize,a.inChannels,e]}}),u=Yne({inputs:{x:n},backend:r,attrs:{shape:[1,a.inChannels,a.outChannels]}}),d=cae({a:f?l:u,b:f?u:l,transposeA:!f,transposeB:m,backend:r,bias:o,activation:c,preluActivationWeights:s,leakyreluAlpha:i});g=Yne({inputs:{x:d},backend:r,attrs:{shape:a.outShape}}),b.push(l),b.push(u),b.push(d)}for(const y of b)r.disposeIntermediateTensorInfo(y);return g}function Pre(e){let{x:t,filter:n,convInfo:a,backend:r,bias:o=null,preluActivationWeights:s=null,leakyreluAlpha:i=0,activation:c=null}=e;const{filterWidth:l,filterHeight:u,inChannels:d,outWidth:h,outHeight:p,dataFormat:f}=a,m="channelsLast"===f,g=l*u*d,b=p*h,y=[a.batchSize,g,b],x=[];if(null!=s){const e=Mre(s.shape,m);null!=e&&(s=Yne({inputs:{x:s},backend:r,attrs:{shape:e}}),x.push(s))}if(null!=o){const e=Mre(o.shape,m);null!=e&&(o=Yne({inputs:{x:o},backend:r,attrs:{shape:e}}),x.push(o))}const v=Yne({inputs:{x:n},backend:r,attrs:{shape:[1,g,DU(n.shape)/g]}});x.push(v);const w=new Dre(y,a),k=[t.shape,[a.padInfo.top,a.padInfo.left],[a.strideHeight,a.strideWidth],[a.dilationHeight,a.dilationWidth],[a.inChannels],[a.filterWidth*a.inChannels],[a.outWidth]],I=r.runWebGLProgram(w,[t],"float32",k),S=Yne({inputs:{x:I},backend:r,attrs:{shape:y}});x.push(I),x.push(S);const N=null!=o,C=null!=s,T="leakyrelu"===c,E=c?Une(c,!0):null,R=new Gne(m?S.shape:v.shape,m?v.shape:S.shape,m?[a.batchSize,b,a.outChannels]:[a.batchSize,a.outChannels,b],!0,!1,N,E,C,T),_=m?[S,v]:[v,S];if(o&&_.push(o),C&&_.push(s),T){const e=r.makeTensorInfo([],"float32",YK(i,"float32"));_.push(e),x.push(e)}const A=r.runWebGLProgram(R,_,"float32"),F=Yne({inputs:{x:A},backend:r,attrs:{shape:a.outShape}});x.push(A);for(const O of x)r.disposeIntermediateTensorInfo(O);return F}const zre={kernelName:HG,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r,filter:o}=t,{strides:s,pad:i,dataFormat:c,dilations:l,dimRoundingMode:u}=a,d=JQ(c),h=VQ(r.shape,o.shape,s,l,i,u,!1,d);let p;if(1!==h.filterHeight||1!==h.filterWidth||1!==h.dilationHeight||1!==h.dilationWidth||1!==h.strideHeight||1!==h.strideWidth||"SAME"!==h.padInfo.type&&"VALID"!==h.padInfo.type)if(h.strideWidth<=2&&"channelsLast"===d&&uG().getBool("WEBGL_EXP_CONV")){const e=new Ore(h),t=[[h.padInfo.top,h.padInfo.left],[h.strideHeight,h.strideWidth],[h.dilationHeight,h.dilationWidth],[h.inHeight,h.inWidth]];p=n.runWebGLProgram(e,[r,o],"float32",t)}else if(uG().getBool("WEBGL_CONV_IM2COL"))p=Pre({x:r,filter:o,convInfo:h,backend:n});else{const e=new Are(h);p=n.runWebGLProgram(e,[r,o],"float32")}else p=Lre({x:r,filter:o,convInfo:h,backend:n});const f=Yne({inputs:{x:p},backend:n,attrs:{shape:h.outShape}});return n.disposeIntermediateTensorInfo(p),f}};class Bre{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;const t=e.strideHeight,n=e.strideWidth,a=e.padInfo.top,r=e.padInfo.left,o="channelsLast"===e.dataFormat;this.userCode="\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int wR = coords.x;\n        int wC = coords.y;\n        int d1 = coords.z;\n        int d2 = coords.w;\n\n        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int b = 0; b < ".concat(e.batchSize,"; b++) {\n          for (int yR = 0; yR < ").concat(e.outHeight,"; yR++) {\n            int xR = wR + yR * ").concat(t," - ").concat(a,";\n\n            if (xR < 0 || xR >= ").concat(e.inHeight,") {\n              continue;\n            }\n\n            for (int yC = 0; yC < ").concat(e.outWidth,"; yC++) {\n              int xC = wC + yC * ").concat(n," - ").concat(r,";\n\n              if (xC < 0 || xC >= ").concat(e.inWidth,") {\n                continue;\n              }\n\n              ").concat(o?"float dyValue = getDy(b, yR, yC, d2);\n              float xValue = getX(b, xR, xC, d1);\n              dotProd += (xValue * dyValue);":"float dyValue = getDy(b, d2, yR, yC);\n              float xValue = getX(b, d1, xR, xC);\n              dotProd += (xValue * dyValue);","\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    ")}}class Wre{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;const t=e.filterHeight,n=e.filterWidth,a=e.strideHeight,r=e.strideWidth,o="channelsLast"===e.dataFormat,s=t-1-e.padInfo.top,i=n-1-e.padInfo.left,c=o?1:2,l=o?2:3,u=o?3:1;this.userCode="\n      const ivec2 pads = ivec2(".concat(s,", ").concat(i,");\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[").concat(u,"];\n\n        ivec2 dyCorner = ivec2(coords[").concat(c,"], coords[").concat(l,"]) - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ").concat(t,"; wR++) {\n          float dyR = float(dyRCorner + wR) / ").concat(a,".0;\n\n          if (dyR < 0.0 || dyR >= ").concat(e.outHeight,".0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          int wRPerm = ").concat(t," - 1 - wR;\n\n          for (int wC = 0; wC < ").concat(n,"; wC++) {\n            float dyC = float(dyCCorner + wC) / ").concat(r,".0;\n\n            if (dyC < 0.0 || dyC >= ").concat(e.outWidth,".0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            int wCPerm = ").concat(n," - 1 - wC;\n\n            for (int d2 = 0; d2 < ").concat(e.outChannels,"; d2++) {\n\n              if (").concat(o,") {\n                float xValue = getDy(batch, idyR, idyC, d2);\n                float wValue = getW(wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              } else {\n                float xValue = getDy(batch, d2, idyR, idyC);\n                float wValue = getW(wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              }\n\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    ")}}class Vre{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;const t=e.strideDepth,n=e.strideHeight,a=e.strideWidth,r=e.padInfo.front,o=e.padInfo.top,s=e.padInfo.left;this.userCode="\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int wF = coords.x;\n        int wR = coords.y;\n        int wC = coords.z;\n        int d1 = coords.w;\n        int d2 = coords.u;\n\n        float dotProd = 0.0;\n\n        for (int b = 0; b < ".concat(e.batchSize,"; b++) {\n          for (int yF = 0; yF < ").concat(e.outDepth,"; yF++) {\n            int xF = wF + yF * ").concat(t," - ").concat(r,";\n\n            if (xF < 0 || xF >= ").concat(e.inDepth,") {\n              continue;\n            }\n\n            for (int yR = 0; yR < ").concat(e.outHeight,"; yR++) {\n              int xR = wR + yR * ").concat(n," - ").concat(o,";\n\n              if (xR < 0 || xR >= ").concat(e.inHeight,") {\n                continue;\n              }\n\n              for (int yC = 0; yC < ").concat(e.outWidth,"; yC++) {\n                int xC = wC + yC * ").concat(a," - ").concat(s,";\n\n                if (xC < 0 || xC >= ").concat(e.inWidth,") {\n                  continue;\n                }\n\n                float dyValue = getDy(b, yF, yR, yC, d2);\n                float xValue = getX(b, xF, xR, xC, d1);\n                dotProd += (xValue * dyValue);\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    ")}}class Ure{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;const t=e.filterDepth,n=e.filterHeight,a=e.filterWidth,r=e.strideDepth,o=e.strideHeight,s=e.strideWidth,i=t-1-e.padInfo.front,c=n-1-e.padInfo.top,l=a-1-e.padInfo.left;this.userCode="\n      const ivec3 pads = ivec3(".concat(i,", ").concat(c,", ").concat(l,");\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int d1 = coords.u;\n\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyFCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        float dotProd = 0.0;\n        for (int wF = 0; wF < ").concat(t,"; wF++) {\n          float dyF = float(dyFCorner + wF) / ").concat(r,".0;\n\n          if (dyF < 0.0 || dyF >= ").concat(e.outDepth,".0 || fract(dyF) > 0.0) {\n            continue;\n          }\n          int idyF = int(dyF);\n\n          int wFPerm = ").concat(t," - 1 - wF;\n\n          for (int wR = 0; wR < ").concat(n,"; wR++) {\n            float dyR = float(dyRCorner + wR) / ").concat(o,".0;\n\n            if (dyR < 0.0 || dyR >= ").concat(e.outHeight,".0 ||\n              fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            int wRPerm = ").concat(n," - 1 - wR;\n\n            for (int wC = 0; wC < ").concat(a,"; wC++) {\n              float dyC = float(dyCCorner + wC) / ").concat(s,".0;\n\n              if (dyC < 0.0 || dyC >= ").concat(e.outWidth,".0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              int wCPerm = ").concat(a," - 1 - wC;\n\n              for (int d2 = 0; d2 < ").concat(e.outChannels,"; d2++) {\n                float xValue = getDy(batch, idyF, idyR, idyC, d2);\n                float wValue = getW(wFPerm, wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    ")}}const Gre={kernelName:jG,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r,dy:o}=t,{strides:s,pad:i,dataFormat:c,dimRoundingMode:l,filterShape:u}=a,d=JQ(c),h=VQ(r.shape,u,s,1,i,l,!1,d),p=new Bre(h);return n.runWebGLProgram(p,[r,o],"float32")}};class Hre{constructor(e){this.variableNames=["dy","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"strides",type:"vec2"}],this.outputShape=e.inShape,this.enableShapeUniforms=Pee(this.outputShape.length);const t=e.filterHeight,n=e.filterWidth,a=t-1-e.padInfo.top,r=n-1-e.padInfo.left;this.userCode="\n      const ivec2 pads = ivec2(".concat(a,", ").concat(r,");\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[3];\n\n        ivec2 dyCorner = ivec2(coords[1], coords[2]) - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        vec4 result = vec4(0.);\n        for (int wR = 0; wR < ").concat(t,"; wR++) {\n          float dyR = float(dyRCorner + wR) / strides[0];\n          if (dyR < 0.0 || dyR >= ").concat(e.outHeight,".0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n          int wRPerm = ").concat(t," - 1 - wR;\n\n          for (int wC = 0; wC < ").concat(n,"; wC++) {\n            int wCPerm = ").concat(n," - 1 - wC;\n\n            float dyC = float(dyCCorner + wC) / strides[1];\n            bool idyCVal = (dyC >= 0.0) && (dyC < ").concat(e.outWidth,".0)\n              && (fract(dyC) == 0.0);\n            int idyC = int(dyC);\n\n            float dyC2 = float(dyCCorner + wC + 1) / strides[1];\n            bool idyCVal2 = (dyC2 >= 0.0) && (dyC2 < ").concat(e.outWidth,".0)\n              && (fract(dyC2) == 0.0);\n            int idyC2 = int(dyC2);\n\n            if (idyCVal && idyCVal2) {\n              for (int d2 = 0; d2 < ").concat(e.outChannels,"; d2 += 2) {\n                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);\n                vec4 dySample = getDy(batch, idyR, idyC, d2);\n                vec4 dySample2 = (idyC / 2 == idyC2 / 2) ?\n                  dySample : getDy(batch, idyR, idyC2, d2);\n\n                vec2 dyValue = mod(float(idyC), 2.) == 0. ?\n                  dySample.xy : dySample.zw;\n                result.xy += vec2(dot(dyValue, wValue.xy),\n                  dot(dyValue, wValue.zw));\n\n                dyValue = mod(float(idyC2), 2.) == 0. ?\n                  dySample2.xy : dySample2.zw;\n                result.zw += vec2(dot(dyValue, wValue.xy),\n                  dot(dyValue, wValue.zw));\n              }\n            } else if (idyCVal) {\n              for (int d2 = 0; d2 < ").concat(e.outChannels,"; d2 += 2) {\n                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);\n                vec4 dySample = getDy(batch, idyR, idyC, d2);\n                vec2 dyValue = mod(float(idyC), 2.) == 0. ?\n                  dySample.xy : dySample.zw;\n                result.xy += vec2(dot(dyValue, wValue.xy),\n                  dot(dyValue, wValue.zw));\n              }\n            } else if (idyCVal2) {\n              for (int d2 = 0; d2 < ").concat(e.outChannels,"; d2 += 2) {\n                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);\n                vec4 dySample = getDy(batch, idyR, idyC2, d2);\n                vec2 dyValue = mod(float(idyC2), 2.) == 0. ?\n                  dySample.xy : dySample.zw;\n                result.zw += vec2(dot(dyValue, wValue.xy),\n                  dot(dyValue, wValue.zw));\n              }\n            }\n          }\n        }\n        setOutput(result);\n      }\n    ")}}const jre={kernelName:KG,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{dy:r,filter:o}=t,{inputShape:s,strides:i,pad:c,dataFormat:l,dimRoundingMode:u}=a,d=JQ(l),h=VQ(s,o.shape,i,1,c,u,!1,d);if(uG().getBool("WEBGL_PACK_CONV2DTRANSPOSE")&&"channelsLast"===d){const e=[[h.strideHeight,h.strideWidth]],t=new Hre(h);return n.runWebGLProgram(t,[r,o],"float32",e)}{const e=new Wre(h);return n.runWebGLProgram(e,[r,o],"float32")}}};const Kre={kernelName:qG,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r,filter:o}=t,{strides:s,pad:i,dilations:c}=a,l=UQ(r.shape,o.shape,s,c,i),u=new Fre(l);return n.runWebGLProgram(u,[r,o],"float32")}};const qre={kernelName:XG,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r,dy:o}=t,{strides:s,pad:i,filterShape:c}=a,l=UQ(r.shape,c,s,1,i),u=new Vre(l);return n.runWebGLProgram(u,[r,o],"float32")}};const Xre={kernelName:YG,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{dy:r,filter:o}=t,{pad:s,strides:i,inputShape:c}=a,l=UQ(c,o.shape,i,1,s),u=new Ure(l);return n.runWebGLProgram(u,[r,o],"float32")}},Yre=Wne({opSnippet:Bne+"\n  return cos(x);\n",packedOpSnippet:"\n  vec4 result = cos(x);\n  bvec4 isNaN = isnan(x);\n  ".concat(Tne,"\n  return result;\n")}),Qre={kernelName:QG,backendName:"webgl",kernelFunc:Yre},Jre=Wne({opSnippet:"\n  float e2x = exp(-x);\n  return (e2x + 1.0 / e2x) / 2.0;\n"}),Zre={kernelName:JG,backendName:"webgl",kernelFunc:Jre};class $re{constructor(e,t,n,a,r){this.variableNames=["Image","Boxes","BoxInd"],this.outputShape=[];const[o,s,i,c]=e,[l]=t,[u,d]=n;this.outputShape=[l,u,d,c];const h="bilinear"===a?1:0,[p,f]=["".concat(s-1,".0"),"".concat(i-1,".0")],[m,g,b]=u>1?["".concat((s-1)/(u-1)),"(y2-y1) * height_ratio","y1*".concat(p," + float(y)*(height_scale)")]:["0.0","0.0","0.5 * (y1+y2) * ".concat(p)],[y,x,v]=d>1?["".concat((i-1)/(d-1)),"(x2-x1) * width_ratio","x1*".concat(f," + float(x)*(width_scale)")]:["0.0","0.0","0.5 * (x1+x2) * ".concat(f)];this.userCode="\n      const float height_ratio = float(".concat(m,");\n      const float width_ratio = float(").concat(y,");\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int y = coords[1];\n        int x = coords[2];\n        int d = coords[3];\n\n        // get box vals\n        float y1 = getBoxes(b,0);\n        float x1 = getBoxes(b,1);\n        float y2 = getBoxes(b,2);\n        float x2 = getBoxes(b,3);\n\n        // get image in batch index\n        int bInd = round(getBoxInd(b));\n        if(bInd < 0 || bInd >= ").concat(o,") {\n          return;\n        }\n\n        float height_scale = ").concat(g,";\n        float width_scale = ").concat(x,";\n\n        float in_y = ").concat(b,";\n        if( in_y < 0.0 || in_y > ").concat(p," ) {\n          setOutput(float(").concat(r,"));\n          return;\n        }\n        float in_x = ").concat(v,";\n        if( in_x < 0.0 || in_x > ").concat(f," ) {\n          setOutput(float(").concat(r,"));\n          return;\n        }\n\n        vec2 sourceFracIndexCR = vec2(in_x,in_y);\n        if(").concat(h," == 1) {\n          // Compute the four integer indices.\n          ivec2 sourceFloorCR = ivec2(sourceFracIndexCR);\n          ivec2 sourceCeilCR = ivec2(ceil(sourceFracIndexCR));\n\n          float topLeft = getImage(b, sourceFloorCR.y, sourceFloorCR.x, d);\n          float bottomLeft = getImage(b, sourceCeilCR.y, sourceFloorCR.x, d);\n          float topRight = getImage(b, sourceFloorCR.y, sourceCeilCR.x, d);\n          float bottomRight = getImage(b, sourceCeilCR.y, sourceCeilCR.x, d);\n\n          vec2 fracCR = sourceFracIndexCR - vec2(sourceFloorCR);\n\n          float top = topLeft + (topRight - topLeft) * fracCR.x;\n          float bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;\n          float newValue = top + (bottom - top) * fracCR.y;\n          setOutput(newValue);\n        } else {\n          // Compute the coordinators of nearest neighbor point.\n          ivec2 sourceNearestCR = ivec2(floor(\n            sourceFracIndexCR + vec2(0.5,0.5)));\n          float newValue = getImage(b, sourceNearestCR.y, sourceNearestCR.x, d);\n          setOutput(newValue);\n        }\n      }\n    ")}}const eoe={kernelName:eH,backendName:"webgl",kernelFunc:e=>{const{inputs:t,backend:n,attrs:a}=e,{image:r,boxes:o,boxInd:s}=t,{cropSize:i,method:c,extrapolationValue:l}=a,u=new $re(r.shape,o.shape,i,c,l);return n.runWebGLProgram(u,[r,o,s],"float32")}};var toe;!function(e){e.Prod="*",e.Sum="+"}(toe||(toe={}));class noe{constructor(e,t,n,a){this.op=e,this.outputShape=t,this.variableNames=["x"],this.customUniforms=[{name:"index",type:"float"}];const r=this.outputShape.length,o=this.op===toe.Prod?"1.0":"0.0",s=n?o:"getX(".concat(aoe(r,"coords",this.op),")"),i=this.outputShape[this.outputShape.length-1];let c="",l="";n?(c=a?"end != ".concat(i-1):"end != 0",l=a?"end + 1":"end - 1"):(c=a?"end + pow2 < ".concat(i):"end >= pow2",l=a?"end + pow2":"end - pow2"),this.userCode="\n      void main() {\n        ".concat(_ee(r)," coords = getOutputCoords();\n        int end = ").concat(roe(r,"coords",this.op),";\n        float val = ").concat(s,";\n        int pow2 = int(pow(2.0, index));\n        if (").concat(c,") {\n          int idx = ").concat(l,";\n          ").concat(roe(r,"coords",this.op)," = idx;\n          val ").concat(this.op,"= getX(").concat(aoe(r,"coords",this.op),");\n        }\n        setOutput(val);\n      }\n    ")}}function aoe(e,t,n){if(1===e)return"".concat(t);if(2===e)return"".concat(t,".x, ").concat(t,".y");if(3===e)return"".concat(t,".x, ").concat(t,".y, ").concat(t,".z");if(4===e)return"".concat(t,".x, ").concat(t,".y, ").concat(t,".z, ").concat(t,".w");throw new Error("Cumulative ".concat(n," for rank ").concat(e," is not yet supported"))}function roe(e,t,n){if(1===e)return"".concat(t);if(2===e)return"".concat(t,".y");if(3===e)return"".concat(t,".z");if(4===e)return"".concat(t,".w");throw new Error("Cumulative ".concat(n," for rank ").concat(e," is not yet supported"))}function ooe(e,t,n,a,r,o){const s=t.shape.length,i=ZJ([a],s);let c=t;null!=i&&(c=oae({inputs:{x:t},backend:n,attrs:{perm:i}}));const l=eZ(1,s)[0];if(l!==s-1)throw new Error("WebGL cumprod shader expects an inner-most axis=".concat(t.shape.length-1," ")+"but got axis=".concat(a));const u=c.shape[l];let d=Rne({inputs:{x:c},backend:n});for(let h=0;h<=Math.ceil(Math.log2(u))-1;h++){const t=new noe(e,c.shape,!1,o),a=[[h]],r=d;d=n.runWebGLProgram(t,[d],d.dtype,a),n.disposeIntermediateTensorInfo(r)}if(r){const t=new noe(e,c.shape,r,o),a=d;d=n.runWebGLProgram(t,[d],d.dtype),n.disposeIntermediateTensorInfo(a)}if(null!=i){const e=oae({inputs:{x:d},backend:n,attrs:{perm:$J(i)}});return n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(c),e}return d}const soe={kernelName:ZG,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{axis:o,exclusive:s,reverse:i}=a;return ooe(toe.Prod,r,n,o,s,i)}};const ioe={kernelName:$G,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{axis:o,exclusive:s,reverse:i}=a;return ooe(toe.Sum,r,n,o,s,i)}};const coe={kernelName:tH,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r,weights:o}=t,{size:s,binaryOutput:i}=a;if(1===r.shape.length){const e=n.readSync(r.dataId),t=n.readSync(o.dataId),a=ate(e,t,o.dtype,o.shape,s);return n.makeTensorInfo([s],o.dtype,a)}if(2===r.shape.length){const e=n.bufferSync(r),t=n.bufferSync(o),a=rte(e,t,s,i);return n.makeTensorInfo(a.shape,o.dtype,a.values)}throw new Error("Error in denseBincount: input must be at most rank 2, but got rank"+"".concat(r.shape.length,"."))}};class loe{constructor(e,t,n){this.variableNames=["x"],this.outputShape=[],this.outputShape=e,this.blockSize=t,this.dataFormat=n,this.userCode="\n    void main() {\n      ivec4 coords = getOutputCoords();\n      int b = coords[0];\n      int h = ".concat(this.getHeightCoordString(),";\n      int w = ").concat(this.getWidthCoordString(),";\n      int d = ").concat(this.getDepthCoordString(),";\n\n      int in_h = h / ").concat(t,";\n      int offset_h = imod(h, ").concat(t,");\n      int in_w = w / ").concat(t,";\n      int offset_w = imod(w, ").concat(t,");\n      int offset_d = (offset_h * ").concat(t," + offset_w) *\n        ").concat(this.getOutputDepthSize(),";\n      int in_d = d + offset_d;\n\n      float result = ").concat(this.getInputSamplingString(),";\n      setOutput(result);\n    }\n  ")}getHeightCoordString(){return"NHWC"===this.dataFormat?"coords[1]":"coords[2]"}getWidthCoordString(){return"NHWC"===this.dataFormat?"coords[2]":"coords[3]"}getDepthCoordString(){return"NHWC"===this.dataFormat?"coords[3]":"coords[1]"}getOutputDepthSize(){return"NHWC"===this.dataFormat?this.outputShape[3]:this.outputShape[1]}getInputSamplingString(){return"NHWC"===this.dataFormat?"getX(b, in_h, in_w, in_d)":"getX(b, in_d, in_h, in_w)"}}const uoe={kernelName:nH,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{blockSize:o,dataFormat:s}=a,i=r.shape[0],c=("NHWC"===s?r.shape[1]:r.shape[2])*o,l=("NHWC"===s?r.shape[2]:r.shape[3])*o,u=("NHWC"===s?r.shape[3]:r.shape[1])/(o*o),d=new loe("NHWC"===s?[i,c,l,u]:[i,u,c,l],o,s);return n.runWebGLProgram(d,[r],r.dtype)}};class doe{constructor(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1],n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null,a=arguments.length>3&&void 0!==arguments[3]&&arguments[3],r=arguments.length>4&&void 0!==arguments[4]&&arguments[4];this.variableNames=["x","W"],this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=Pee(this.outputShape.length);const o=e.filterHeight,s=e.filterWidth,i=e.outChannels/e.inChannels;let c="",l="";n&&(c=a?"float activation(float a) {\n          float b = getPreluActivationWeightsAtOutCoords();\n          ".concat(n,"\n        }"):r?"float activation(float a) {\n          float b = getLeakyreluAlphaAtOutCoords();\n          ".concat(n,"\n        }"):"\n          float activation(float x) {\n            ".concat(n,"\n          }\n        "),l="result = activation(result);");const u=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),a&&this.variableNames.push("preluActivationWeights"),r&&this.variableNames.push("leakyreluAlpha"),this.userCode="\n      ".concat(c,"\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int d2 = coords.w;\n        int d1 = d2 / ").concat(i,";\n        int q = d2 - d1 * ").concat(i,";\n\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // Convolve x(?, ?, d1) with w(:, :, d1, q) to get y(yR, yC, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        // TO DO(dsmilkov): Flatten the two for loops and vec4 the operations.\n        for (int wR = 0; wR < ").concat(o,"; wR++) {\n          int xR = xRCorner + wR * dilations[0];\n\n          if (xR < 0 || xR >= inDims[0]) {\n            continue;\n          }\n\n          for (int wC = 0; wC < ").concat(s,"; wC++) {\n            int xC = xCCorner + wC * dilations[1];\n\n            if (xC < 0 || xC >= inDims[1]) {\n              continue;\n            }\n\n            float xVal = getX(batch, xR, xC, d1);\n            float wVal = getW(wR, wC, d1, q);\n            dotProd += xVal * wVal;\n          }\n        }\n\n        float result = dotProd;\n        ").concat(u,"\n        ").concat(l,"\n        setOutput(result);\n      }\n    ")}}class hoe{constructor(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1],n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null,a=arguments.length>3&&void 0!==arguments[3]&&arguments[3],r=arguments.length>4&&void 0!==arguments[4]&&arguments[4];this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=Pee(this.outputShape.length);const o=e.outChannels/e.inChannels,s=e.padInfo.left,i=e.strideWidth,c=e.dilationWidth,l=e.filterHeight,u=e.filterWidth,d=u;let h="\n      int xR; int xC; int xCOffset;\n      vec4 wTexel; vec4 previous; vec4 final;";for(let g=0;g<u;g++)h+="\n          vec4 xTexelC".concat(2*g,";\n          int xTexelC").concat(2*g,"Ready;\n          vec4 xTexelC").concat(2*g+1,";\n          int xTexelC").concat(2*g+1,"Ready;\n          vec4 xC").concat(g,";");h+="\n    for (int r = 0; r < ".concat(l,"; r++) {\n      ");for(let g=0;g<u;g++)h+="\n          xTexelC".concat(2*g," = vec4(0.0);\n          xTexelC").concat(2*g,"Ready = 0;\n          xTexelC").concat(2*g+1," = vec4(0.0);\n          xTexelC").concat(2*g+1,"Ready = 0;\n          xC").concat(g," = vec4(0.0);");h+="\n        xR = xRCorner + r * dilations[0];\n        if (xR >=0 && xR < inDims[0]) {\n      ";for(let g=0;g<(d+1)/2;g++){const e=2*g;if(h+="\n          xC = xCCorner + ".concat(e*c,";\n          "),1===i){if(e<u&&(s%2===1?(h+="\n                xCOffset = xC + 1;\n                if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC".concat(e,"Ready == 0) {\n                  xTexelC").concat(e," = getX(batch, xR, xCOffset, d1);\n\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if (xCOffset + 1 >= inDims[1]) {\n                    xTexelC").concat(e,".zw = vec2(0.0);\n                  }\n                  xTexelC").concat(e,"Ready = 1;\n                }\n              "),h+=1===c&&e>0?"\n                xC".concat(e," = vec4(xTexelC").concat(e-2,".zw, xTexelC").concat(e,".xy);\n                "):"\n                  xCOffset = xC + 1 - 2;\n\n                  if (xCOffset >= 0 && xCOffset < inDims[1]) {\n                    previous = getX(batch, xR, xCOffset, d1);\n\n                    // Need to manually clear unused channels in case\n                    // we're reading from recycled texture.\n                    if (xCOffset + 1 >= inDims[1]) {\n                      previous.zw = vec2(0.0);\n                    }\n\n                    xC".concat(e," = vec4(previous.zw, xTexelC").concat(e,".xy);\n                  } else {\n                    xC").concat(e," = vec4(0.0, 0.0, xTexelC").concat(e,".xy);\n                  }\n                  ")):h+="\n                if (xC >= 0 && xC < inDims[1] && xTexelC".concat(e,"Ready == 0) {\n                  xTexelC").concat(e," = getX(batch, xR, xC, d1);\n                  if (xC + 1 >= inDims[1]) {\n                    xTexelC").concat(e,".zw = vec2(0.0);\n                  }\n                  xTexelC").concat(e,"Ready = 1;\n                }\n\n                xC").concat(e," = xTexelC").concat(e,";\n                "),e+1<u)){const t=s%2===0?RU(c):c;c%2===0&&s%2===1||c%2!==0&&s%2!==1?(h+="\n                  xCOffset = xC + imod(pads[1], 2) + ".concat(t,";\n\n                  if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC").concat(e+1,"Ready == 0) {\n                    xTexelC").concat(e+1," = getX(batch, xR, xCOffset, d1);\n\n                    // Need to manually clear unused channels in case\n                    // we're reading from recycled texture.\n                    if (xCOffset + 1 >= inDims[1]) {\n                      xTexelC").concat(e+1,".zw = vec2(0.0);\n                    }\n                    xTexelC").concat(e+1,"Ready = 1;\n                  }\n                  "),h+=c>1?"\n                    xCOffset -= 2;\n                    if (xCOffset >= 0 && xCOffset < inDims[1]) {\n                     previous = getX(batch, xR, xCOffset, d1);\n                     xC".concat(e+1," = vec4(previous.zw, xTexelC").concat(e+1,".xy);\n                    } else {\n                     xC").concat(e+1," = vec4(0.0, 0.0, xTexelC").concat(e+1,".xy);\n                    }\n                    "):"\n                    xC".concat(e+1," = vec4(xTexelC").concat(e,".zw, xTexelC").concat(e+1,".xy);\n                    ")):h+=1===t?"\n                    xC".concat(e+1," = xTexelC").concat(e,";\n                    "):"\n                    xCOffset = xC + ".concat(t,";\n\n                    if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC").concat(e+1,"Ready == 0) {\n                      xTexelC").concat(e+1," = getX(batch, xR, xCOffset, d1);\n                      if (xCOffset + 1 >= inDims[1]) {\n                        xTexelC").concat(e+1,".zw = vec2(0.0);\n                      }\n                      xTexelC").concat(e+1,"Ready = 1;\n                    }\n\n                    xC").concat(e+1," = xTexelC").concat(e+1,";\n                    ")}}else e<u&&(s%2===1?(h+="\n                xCOffset = xC + 1 - strides[1];\n                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC".concat(e,"Ready == 0) {\n                  xTexelC").concat(e," = getX(batch, xR, xCOffset, d1);\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if (xCOffset + 1 >= inDims[1]) {\n                    xTexelC").concat(e,".zw = vec2(0.0);\n                  }\n                  xTexelC").concat(e,"Ready = 1;\n                }\n\n                if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC").concat(e+1,"Ready == 0) {\n                  xTexelC").concat(e+1," = getX(batch, xR, xC + 1, d1);\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if (xC + 2 >= inDims[1]) {\n                    xTexelC").concat(e+1,".zw = vec2(0.0);\n                  }\n                  xTexelC").concat(e+1,"Ready = 1;\n                }\n\n                xC").concat(e," = vec4(xTexelC").concat(e,".zw, xTexelC").concat(e+1,".zw);\n              "),e+1<u&&(h+="\n                  final = vec4(0.0);\n                  xCOffset = xC + 1 + strides[1];\n                  if(xCOffset >= 0 && xCOffset < inDims[1]) {\n                    final = getX(batch, xR, xCOffset, d1);\n                  }\n                  xC".concat(e+1," = vec4(xTexelC").concat(e+1,".xy, final.xy);\n                "))):(h+="\n                if(xC >= 0 && xC < inDims[1] && xTexelC".concat(e,"Ready == 0) {\n                  xTexelC").concat(e," = getX(batch, xR, xC, d1);\n                  if (xC + 1 >= inDims[1]) {\n                    xTexelC").concat(e,".zw = vec2(0.0);\n                  }\n                  xTexelC").concat(e,"Ready = 1;\n                }\n\n                xCOffset = xC + strides[1];\n                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC").concat(e+1,"Ready == 0) {\n                  xTexelC").concat(e+1," = getX(batch, xR, xCOffset, d1);\n                  if (xCOffset + 1 >= inDims[1]) {\n                    xTexelC").concat(e+1,".zw = vec2(0.);\n                  }\n                  xTexelC").concat(e+1,"Ready = 1;\n                }\n\n                xC").concat(e," = vec4(\n                  xTexelC").concat(e,".xy, xTexelC").concat(e+1,".xy);\n              "),e+1<u&&(h+="\n                  xC".concat(e+1," = vec4(xTexelC").concat(e,".zw, xTexelC").concat(e+1,".zw);\n                "))));e<u&&(h+="\n            wTexel = getW(r, ".concat(e,", d1, q);\n            dotProd += xC").concat(e," * vec4(wTexel.xz, wTexel.xz);\n          "),e+1<u&&(h+="\n              wTexel = getW(r, ".concat(e+1,", d1, q);\n              dotProd += xC").concat(e+1," * vec4(wTexel.xz, wTexel.xz);\n            ")))}h+="\n    }\n  ",h+="\n      }\n    ";let p="",f="";n&&(p=a?"vec4 activation(vec4 a) {\n          vec4 b = getPreluActivationWeightsAtOutCoords();\n          ".concat(n,"\n        }"):r?"vec4 activation(vec4 a) {\n          vec4 b = getLeakyreluAlphaAtOutCoords();\n          ".concat(n,"\n        }"):"vec4 activation(vec4 x) {\n          ".concat(n,"\n        }"),f="result = activation(result);");const m=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),a&&this.variableNames.push("preluActivationWeights"),r&&this.variableNames.push("leakyreluAlpha"),this.userCode="\n      ".concat(p,"\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int d2 = coords.w;\n        int d1 = d2 / ").concat(o,";\n        int q = d2 - d1 * ").concat(o,";\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.\n        vec4 dotProd = vec4(0.000000000000001);\n\n        ").concat(h,"\n\n        vec4 result = dotProd - vec4(0.000000000000001);\n        ").concat(m,"\n        ").concat(f,"\n        setOutput(result);\n      }\n    ")}}const poe={kernelName:aH,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r,filter:o}=t,{strides:s,pad:i,dilations:c,dimRoundingMode:l}=a;let u=c;null==u&&(u=[1,1]),AU(YQ(s,u),(()=>"Error in depthwiseConv2d: Either strides or dilations must be "+"1. Got strides ".concat(s," and dilations '").concat(u,"'")));const d=VQ(r.shape,o.shape,s,u,i,l,!0);let h;h=uG().getBool("WEBGL_PACK_DEPTHWISECONV")&&d.strideWidth<=2&&d.outChannels/d.inChannels===1?new hoe(d):new doe(d);const p=[[d.padInfo.top,d.padInfo.left],[d.strideHeight,d.strideWidth],[d.dilationHeight,d.dilationWidth],[d.inHeight,d.inWidth]];return n.runWebGLProgram(h,[r,o],"float32",p)}};class foe{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;const t=e.strideHeight,n=e.strideWidth,a=e.padInfo.top,r=e.padInfo.left,o=e.outChannels/e.inChannels;this.userCode="\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int wR = coords.x;\n        int wC = coords.y;\n        int d1 = coords.z;\n        int dm = coords.w;\n        int d2 = d1 * ".concat(o," + dm;\n\n        float dotProd = 0.0;\n\n        // TO DO: Vec4 over the batch size\n        for (int b = 0; b < ").concat(e.batchSize,"; b++) {\n          for (int yR = 0; yR < ").concat(e.outHeight,"; yR++) {\n            int xR = wR + yR * ").concat(t," - ").concat(a,";\n\n            if (xR < 0 || xR >= ").concat(e.inHeight,") {\n              continue;\n            }\n\n            for (int yC = 0; yC < ").concat(e.outWidth,"; yC++) {\n              int xC = wC + yC * ").concat(n," - ").concat(r,";\n\n              if (xC < 0 || xC >= ").concat(e.inWidth,") {\n                continue;\n              }\n\n              float dyValue = getDy(b, yR, yC, d2);\n              float xValue = getX(b, xR, xC, d1);\n              dotProd += (xValue * dyValue);\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    ")}}class moe{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;const t=e.filterHeight,n=e.filterWidth,a=e.strideHeight,r=e.strideWidth,o=t-1-e.padInfo.top,s=n-1-e.padInfo.left,i=e.outChannels/e.inChannels;this.userCode="\n      const ivec2 pads = ivec2(".concat(o,", ").concat(s,");\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[3];\n        ivec2 dyCorner = coords.yz - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        float dotProd = 0.0;\n\n        for (int wR = 0; wR < ").concat(t,"; wR++) {\n          float dyR = float(dyRCorner + wR) / ").concat(a,".0;\n\n          if (dyR < 0.0 || dyR >= ").concat(e.outHeight,".0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          int wRPerm = ").concat(t," - 1 - wR;\n\n          for (int wC = 0; wC < ").concat(n,"; wC++) {\n            float dyC = float(dyCCorner + wC) / ").concat(r,".0;\n\n            if (dyC < 0.0 || dyC >= ").concat(e.outWidth,".0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            int wCPerm = ").concat(n," - 1 - wC;\n\n            // TO DO: Vec4 over the channelMul\n            for (int dm = 0; dm < ").concat(i,"; dm++) {\n              int d2 = d1 * ").concat(i," + dm;\n              float xValue = getDy(batch, idyR, idyC, d2);\n              float wValue = getW(wRPerm, wCPerm, d1, dm);\n              dotProd += xValue * wValue;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    ")}}const goe={kernelName:rH,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r,dy:o}=t,{strides:s,dilations:i,pad:c,dimRoundingMode:l,filterShape:u}=a,d=VQ(r.shape,u,s,i,c,l,!0),h=new foe(d);return n.runWebGLProgram(h,[r,o],"float32")}};const boe={kernelName:oH,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{dy:r,filter:o}=t,{strides:s,dilations:i,pad:c,dimRoundingMode:l,inputShape:u}=a,d=VQ(u,o.shape,s,i,c,l,!0),h=new moe(d);return n.runWebGLProgram(h,[r,o],"float32")}};class yoe{constructor(e){this.variableNames=["X"],this.outputShape=[e,e],this.userCode="\n      void main() {\n          ivec2 coords = getOutputCoords();\n          float val = coords[0] == coords[1] ? getX(coords[0]) : 0.0;\n          setOutput(val);\n      }\n    "}}const xoe={kernelName:sH,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{x:a}=t,r=[...a.shape,...a.shape],o=DU(a.shape),s=Yne({inputs:{x:a},backend:n,attrs:{shape:[o]}}),i=new yoe(o),c=n.runWebGLProgram(i,[s],s.dtype),l=Yne({inputs:{x:c},backend:n,attrs:{shape:r}});return n.disposeIntermediateTensorInfo(s),n.disposeIntermediateTensorInfo(c),l}};class voe{constructor(e){this.variableNames=["x","W"],this.outputShape=e.outShape;const{inHeight:t,inWidth:n,padInfo:a,strideHeight:r,strideWidth:o,filterHeight:s,filterWidth:i,dilationHeight:c,dilationWidth:l}=e,{top:u,left:d}=a;this.userCode="\n      const ivec2 strides = ivec2(".concat(r,", ").concat(o,");\n      const ivec2 pads = ivec2(").concat(u,", ").concat(d,");\n      const float neg_infinity = -3.4e38;\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        int d1 = coords.w;\n        ivec2 outTopLeftCorner =\n            coords.yz * strides - pads;\n        int hBeg = outTopLeftCorner.x;\n        int wBeg = outTopLeftCorner.y;\n\n        float curVal = neg_infinity;\n        for (int h = 0; h < ").concat(s,"; h++) {\n          int hIn = hBeg + h * ").concat(c,";\n\n          if (hIn >= 0 && hIn < ").concat(t,") {\n            for (int w = 0; w < ").concat(i,"; w++) {\n              int wIn = wBeg + w * ").concat(l,";\n\n              if (wIn >= 0 && wIn < ").concat(n,") {\n                float xVal = getX(batch, hIn, wIn, d1);\n                float wVal = getW(h, w, d1);\n\n                float val = xVal + wVal;\n                if (val > curVal) {\n                  curVal = val;\n                }\n              }\n            }\n          }\n        }\n\n        float result = curVal;\n        setOutput(result);\n      }\n    ")}}const woe={kernelName:iH,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r,filter:o}=t,{strides:s,pad:i,dilations:c}=a,l=zQ(r.shape,o.shape,s,i,"NHWC",c);let u;const d=new voe(l);u=n.runWebGLProgram(d,[r,o],"float32");const h=Yne({inputs:{x:u},backend:n,attrs:{shape:l.outShape}});return n.disposeIntermediateTensorInfo(u),h}};const koe={kernelName:hH,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{equation:r}=a,o=t,{allDims:s,summedDims:i,idDims:c}=E2(r,o.length);_2(s.length,c,o);const{path:l,steps:u}=A2(i,c),d=u.length;let h=null,p=s.length;const f=[];for(let m=0;m<d;++m){for(const e of u[m]){const{permutationIndices:t,expandDims:a}=R2(p,c[e]);let r;F2(t)?r=o[e]:(r=oae({inputs:{x:o[e]},backend:n,attrs:{perm:t}}),f.push(r));const s=r.shape.slice();for(let e=0;e<a.length;++e)s.splice(a[e],0,1);MU(r.shape,s)||(r=Yne({inputs:{x:r},backend:n,attrs:{shape:s}}),f.push(r)),null===h?h=r:(h=qne({inputs:{a:r,b:h},backend:n}),f.push(h))}m<d-1&&(l[m]>=0&&(h=aae({inputs:{x:h},backend:n,attrs:{axis:l[m]-(s.length-p),keepDims:!1}}),f.push(h)),p--)}for(const m of f)m!==h&&n.disposeIntermediateTensorInfo(m);return h}},Ioe=Wne({opSnippet:"return (x >= 0.0) ? x : (exp(x) - 1.0);",packedOpSnippet:"\n  vec4 result;\n\n  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);\n  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);\n  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);\n  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);\n\n  return result;\n"}),Soe={kernelName:pH,backendName:"webgl",kernelFunc:Ioe},Noe={kernelName:fH,backendName:"webgl",kernelFunc:e=>{const{inputs:t,backend:n}=e,{dy:a,y:r}=t,o=uG().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new Ene("\n  vec4 bGTEZero = vec4(greaterThanEqual(b, vec4(0.)));\n  return (bGTEZero * a) + ((vec4(1.0) - bGTEZero) * (a * (b + vec4(1.0))));\n",a.shape,r.shape):new Cne("return (b >= 0.0) ? a : a * (b + 1.0);",a.shape,r.shape);return n.runWebGLProgram(o,[a,r],a.dtype)}},Coe=Vne({opSnippet:"return float(a == b);",packedOpSnippet:"\n  return vec4(equal(a, b));\n",dtype:"bool",cpuKernelImpl:lte}),Toe={kernelName:gH,backendName:"webgl",kernelFunc:Coe},Eoe=Wne({opSnippet:'\n  // Error function is calculated approximately with elementary function.\n  // See "Handbook of Mathematical Functions with Formulas,\n  // Graphs, and Mathematical Tables", Abramowitz and Stegun.\n  float p = '.concat(u2,";\n  float a1 = ").concat(d2,";\n  float a2 = ").concat(h2,";\n  float a3 = ").concat(p2,";\n  float a4 = ").concat(f2,";\n  float a5 = ").concat(m2,";\n\n  float sign = sign(x);\n  x = abs(x);\n  float t = 1.0 / (1.0 + p * x);\n  return sign * (1.0 - (((((a5*t + a4)*t) + a3)*t + a2)*t + a1)*t*exp(-x*x));\n")}),Roe={kernelName:mH,backendName:"webgl",kernelFunc:Eoe},_oe=Wne({opSnippet:Bne+"\n  return exp(x);\n",packedOpSnippet:"\n  vec4 result = exp(x);\n  bvec4 isNaN = isnan(x);\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n",cpuKernelImpl:ute,dtype:"float32"}),Aoe={kernelName:bH,backendName:"webgl",kernelFunc:_oe};function Foe(e){const{inputs:t,attrs:n,backend:a}=e,{dim:r}=n,{input:o}=t,s=o.shape.length,i=o.shape.slice();let c=r;return r<0&&(AU(-(s+1)<=r,(()=>"Axis must be in the interval [".concat(-(s+1),", ").concat(s,"]"))),c=s+r+1),i.splice(c,0,1),Yne({inputs:{x:o},backend:a,attrs:{shape:i}})}const Ooe={kernelName:yH,backendName:"webgl",kernelFunc:Foe},Doe="return exp(x) - 1.0;",Moe=Wne({opSnippet:Doe,packedOpSnippet:Doe,cpuKernelImpl:dte}),Loe={kernelName:xH,backendName:"webgl",kernelFunc:Moe};class Poe{constructor(e,t,n){this.variableNames=["real","imag"];const a=t[1];this.outputShape=t;const r=n?"2.0 * ".concat(Math.PI):"-2.0 * ".concat(Math.PI),o=n?"".concat(a,".0"):"1.0";let s;if("real"===e)s="return real * expR - imag * expI;";else{if("imag"!==e)throw new Error('FFT component must be either "real" or "imag", got '.concat(e,"."));s="return real * expI + imag * expR;"}this.userCode="\n      const float exponentMultiplier = ".concat(r,";\n\n      float unaryOpComplex(float real, float expR, float imag, float expI) {\n        ").concat(s,"\n      }\n\n      float mulMatDFT(int batch, int index) {\n        float indexRatio = float(index) / float(").concat(a,");\n        float exponentMultiplierTimesIndexRatio =\n            exponentMultiplier * indexRatio;\n\n        float result = 0.0;\n\n        for (int i = 0; i < ").concat(a,"; i++) {\n          // x = (-2|2 * PI / N) * index * i;\n          float x = exponentMultiplierTimesIndexRatio * float(i);\n          float expR = cos(x);\n          float expI = sin(x);\n          float real = getReal(batch, i);\n          float imag = getImag(batch, i);\n\n          result +=\n              unaryOpComplex(real, expR, imag, expI) / ").concat(o,";\n        }\n\n        return result;\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        setOutput(mulMatDFT(coords[0], coords[1]));\n      }\n    ")}}function zoe(e,t,n){const a=n.texData.get(e.dataId),r=DU(e.shape),o=e.shape[e.shape.length-1],s=Yne({inputs:{x:e},backend:n,attrs:{shape:[r/o,o]}}),i=s.shape,c=new Poe("real",i,t),l=new Poe("imag",i,t),u=[{dataId:a.complexTensorInfos.real.dataId,dtype:a.complexTensorInfos.real.dtype,shape:i},{dataId:a.complexTensorInfos.imag.dataId,dtype:a.complexTensorInfos.imag.dtype,shape:i}],d=n.runWebGLProgram(c,u,"float32"),h=n.runWebGLProgram(l,u,"float32"),p=Ane({inputs:{real:d,imag:h},backend:n});n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(h);const f=Yne({inputs:{x:p},backend:n,attrs:{shape:e.shape}});return n.disposeIntermediateTensorInfo(s),n.disposeIntermediateTensorInfo(p),f}const Boe={kernelName:vH,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{input:a}=t;return zoe(a,!1,n)}};class Woe{constructor(e,t){this.outputShape=[],this.customUniforms=[{name:"value",type:"float"}],this.variableNames=["x"],this.outputShape=e,this.userCode="\n      void main() {\n        // Input can be obtained from uniform value.\n        setOutput(value);\n      }\n    "}}function Voe(e){const{backend:t,attrs:n}=e,{shape:a,value:r}=n;let{dtype:o}=n;if(o=o||XU(r),"string"===o){const e=HU(o,DU(a));return e.fill(r),t.makeTensorInfo(a,o,e)}{const e=new Woe(a,r),n=[[r]];return t.runWebGLProgram(e,[],o,n)}}const Uoe={kernelName:wH,backendName:"webgl",kernelFunc:Voe};class Goe{constructor(e){this.variableNames=["Image"],this.outputShape=[];const t=e[2];this.outputShape=e,this.userCode="\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int x = coords[2];\n\n          int coordX = ".concat(t," - x - 1;\n          float outputValue;\n          if(coordX >= 0 && coordX < ").concat(t,") {\n            outputValue = getImage(coords[0], coords[1], coordX, coords[3]);\n          } else {\n            outputValue = getImage(coords[0], coords[1], coords[2], coords[3]);\n          }\n          setOutput(outputValue);\n        }\n    ")}}const Hoe={kernelName:kH,backendName:"webgl",kernelFunc:e=>{let{inputs:t,backend:n}=e;const{image:a}=t,r=n,o=new Goe(a.shape);return r.runWebGLProgram(o,[a],a.dtype)}},joe="return floor(x);",Koe=Wne({opSnippet:joe,packedOpSnippet:joe,cpuKernelImpl:hte}),qoe={kernelName:IH,backendName:"webgl",kernelFunc:Koe},Xoe=Vne({opSnippet:"\n  float s = sign(a) * sign(b);\n  int ia = round(a);\n  int ib = round(b);\n  if (ib != 0) {\n    // Windows (D3D) wants guaranteed non-zero int division at compile-time.\n    return float(idiv(ia, ib, s));\n  } else {\n    return NAN;\n  }\n",packedOpSnippet:"\n  ivec4 ia = round(a);\n  ivec4 ib = round(b);\n  bvec4 cond = notEqual(ib, ivec4(0));\n  ivec4 result = ivec4(0);\n  vec4 s = sign(a) * sign(b);\n\n  // Windows (D3D) wants guaranteed non-zero int division at compile-time.\n  if (cond[0]) {\n    result[0] = idiv(ia[0], ib[0], s[0]);\n  }\n  if (cond[1]) {\n    result[1] = idiv(ia[1], ib[1], s[1]);\n  }\n  if (cond[2]) {\n    result[2] = idiv(ia[2], ib[2], s[2]);\n  }\n  if (cond[3]) {\n    result[3] = idiv(ia[3], ib[3], s[3]);\n  }\n  return vec4(result);\n",dtype:"int32"}),Yoe={kernelName:SH,backendName:"webgl",kernelFunc:Xoe};class Qoe{constructor(e){this.variableNames=["A"];const t=fee(),[n,a]=e;this.outputShape=e,this.userCode="\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int texR = coords[0];\n        int texC = coords[1];\n        int depth = coords[2];\n        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(".concat(a,".0, ").concat(n,".0);\n\n        vec4 values = ").concat(t.texture2D,"(A, uv);\n        float value;\n        if (depth == 0) {\n          value = values.r;\n        } else if (depth == 1) {\n          value = values.g;\n        } else if (depth == 2) {\n          value = values.b;\n        } else if (depth == 3) {\n          value = values.a;\n        }\n\n        setOutput(floor(value * 255.0 + 0.5));\n      }\n    ")}}class Joe{constructor(e){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0;const t=fee(),[n,a]=e;this.outputShape=e,this.userCode="\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int texR = coords[0];\n        int texC = coords[1];\n        int depth = coords[2];\n\n        vec4 result = vec4(0.);\n\n        for(int row=0; row<=1; row++) {\n          for(int col=0; col<=1; col++) {\n            texC = coords[1] + row;\n            depth = coords[2] + col;\n\n            vec2 uv = (vec2(texC, texR) + halfCR) /\n                       vec2(".concat(a,".0, ").concat(n,".0);\n            vec4 values = ").concat(t.texture2D,"(A, uv);\n            float value;\n            if (depth == 0) {\n              value = values.r;\n            } else if (depth == 1) {\n              value = values.g;\n            } else if (depth == 2) {\n              value = values.b;\n            } else if (depth == 3) {\n              value = values.a;\n            }\n\n            result[row * 2 + col] = floor(value * 255.0 + 0.5);\n          }\n        }\n\n        ").concat(t.output," = result;\n      }\n    ")}}const Zoe={kernelName:wK,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e;let{pixels:r}=t;const{numChannels:o}=a,s="undefined"!==typeof HTMLVideoElement&&r instanceof HTMLVideoElement,i="undefined"!==typeof HTMLImageElement&&r instanceof HTMLImageElement,[c,l]=s?[r.videoWidth,r.videoHeight]:[r.width,r.height],u=[l,c],d=[l,c,o];if(i||s){const e=uG().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");null!=$oe&&e===ese||(ese=e,$oe=document.createElement("canvas").getContext("2d",{willReadFrequently:ese})),$oe.canvas.width=c,$oe.canvas.height=l,$oe.drawImage(r,0,0,c,l),r=$oe.canvas}const h=n.makeTensorInfo(u,"int32");n.texData.get(h.dataId).usage=L9.PIXELS,n.gpgpu.uploadPixelDataToTexture(n.getTexture(h.dataId),r);const p=uG().getBool("WEBGL_PACK")?new Joe(d):new Qoe(d),f=n.runWebGLProgram(p,[h],"int32");return n.disposeData(h.dataId),f}};let $oe,ese=uG().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");const tse={kernelName:SK,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r,filter:o,bias:s,preluActivationWeights:i}=t,{strides:c,pad:l,dataFormat:u,dilations:d,dimRoundingMode:h,activation:p,leakyreluAlpha:f}=a,m=JQ(u),g=VQ(r.shape,o.shape,c,d,l,h,!1,m);let b;const y=[],x=null!=s,v=null!=i,w="leakyrelu"===p,k=()=>{const e=[r,o],t=(e,t)=>{if("NCHW"===t&&1===e.shape.length&&1!==e.shape[0]){const t=Yne({inputs:{x:e},backend:n,attrs:{shape:[e.shape[0],1,1]}});return y.push(t),t}return e};if(x&&e.push(t(s,u)),v&&e.push(t(i,u)),w){const t=n.makeTensorInfo([],"float32",YK(f,"float32"));e.push(t),y.push(t)}return e};if(1!==g.filterHeight||1!==g.filterWidth||1!==g.dilationHeight||1!==g.dilationWidth||1!==g.strideHeight||1!==g.strideWidth||"SAME"!==g.padInfo.type&&"VALID"!==g.padInfo.type)if(g.strideWidth<=2&&"channelsLast"===m&&uG().getBool("WEBGL_EXP_CONV")){const e=p?Une(p,!0):null,t=new Ore(g,x,e,v,w),a=[[g.padInfo.top,g.padInfo.left],[g.strideHeight,g.strideWidth],[g.dilationHeight,g.dilationWidth],[g.inHeight,g.inWidth]],r=k();b=n.runWebGLProgram(t,r,"float32",a)}else if(uG().getBool("WEBGL_CONV_IM2COL"))b=Pre({x:r,filter:o,convInfo:g,backend:n,bias:s,activation:p,preluActivationWeights:i,leakyreluAlpha:f});else{const e=p?Une(p,!1):null,t=new Are(g,x,e,v,w),a=k();b=n.runWebGLProgram(t,a,"float32")}else b=Lre({x:r,filter:o,convInfo:g,backend:n,bias:s,activation:p,preluActivationWeights:i,leakyreluAlpha:f});const I=Yne({inputs:{x:b},backend:n,attrs:{shape:g.outShape}});return y.push(b),y.forEach((e=>n.disposeIntermediateTensorInfo(e))),I}};const nse={kernelName:NK,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r,filter:o,bias:s,preluActivationWeights:i}=t,{strides:c,pad:l,dilations:u,dimRoundingMode:d,activation:h,leakyreluAlpha:p}=a,f=[];let m=u;null==m&&(m=[1,1]),AU(YQ(c,m),(()=>"Error in depthwiseConv2d: Either strides or dilations must be "+"1. Got strides ".concat(c," and dilations '").concat(m,"'")));const g=VQ(r.shape,o.shape,c,m,l,d,!0),b=uG().getBool("WEBGL_PACK_DEPTHWISECONV")&&g.strideWidth<=2&&g.outChannels/g.inChannels===1,y=h?Une(h,b):null,x=[r,o],v=null!=s,w=null!=i,k="leakyrelu"===h;if(v&&x.push(s),w&&x.push(i),k){const e=n.makeTensorInfo([],"float32",YK(p,"float32"));x.push(e),f.push(e)}let I;I=b?new hoe(g,v,y,w,k):new doe(g,v,y,w,k);const S=[[g.padInfo.top,g.padInfo.left],[g.strideHeight,g.strideWidth],[g.dilationHeight,g.dilationWidth],[g.inHeight,g.inWidth]],N=n.runWebGLProgram(I,x,"float32",S);return f.forEach((e=>n.disposeIntermediateTensorInfo(e))),N}};class ase{constructor(e,t,n,a){this.sliceDim=e,this.strides=t,this.paramsShape=a,this.variableNames=["x","indices"],this.outputShape=n;const r=_ee(n.length);let o="\n    int index;";for(let s=0;s<this.sliceDim;s++)o+="\n          index = round(getIndices(coords[0], ".concat(s,"));\n          out_of_bounds = out_of_bounds || index < 0;\n          out_of_bounds = out_of_bounds || index >= ").concat(this.paramsShape[s],";\n          flattenIndex += index * ").concat(this.strides[s],";");this.userCode="\n         void main() {\n          ".concat(r," coords = getOutputCoords();\n          int flattenIndex = 0;\n          bool out_of_bounds = false;\n\n          ").concat(o,"\n\n          setOutput(out_of_bounds ? 0.0 : getX(flattenIndex, coords[1]));\n        }\n      ")}}const rse={kernelName:TH,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{params:a,indices:r}=t,o=r.shape,s=o[o.length-1],i=DU(a.shape),[c,l,u,d]=i2(a,r),h=Yne({inputs:{x:r},backend:n,attrs:{shape:[l,s]}}),p=Yne({inputs:{x:a},backend:n,attrs:{shape:[DU(a.shape)/u,u]}});if(n.shouldExecuteOnCPU([a,r])||"string"===a.dtype){const e=n.readSync(r.dataId),t=n.bufferSync(a),o=pte(e,t,a.dtype,l,s,u,d,a.shape,i);return n.makeTensorInfo(c,a.dtype,o.values)}const f=new ase(s,d,[l,u],a.shape),m=n.runWebGLProgram(f,[p,h],p.dtype),g=Yne({inputs:{x:m},backend:n,attrs:{shape:c}});return n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(m),g}};class ose{constructor(e,t){this.variableNames=["A","indices"],this.outputShape=t,this.rank=t.length;const n=_ee(this.rank),a=function(e,t){const n=["resRC.x","resRC.y","resRC.z","resRC.w"],a=[];for(let r=0;r<e.length;r++)2===r?a.push("index"):a.push("".concat(n[r]));return a.join()}(e);this.userCode="\n      void main() {\n        ".concat(n," resRC = getOutputCoords();\n        int index = int(getIndices(resRC.x, resRC.z));\n        float inBounds = (index >= 0) && (index < ").concat(e[2],") ? 1.0 : 0.0;\n        setOutput(inBounds * getA(").concat(a,"));\n      }\n    ")}}function sse(e){const{inputs:t,backend:n,attrs:a}=e,{x:r,indices:o}=t,{axis:s,batchDims:i}=a,c=VU(s,r.shape)[0];if(uG().get("DEBUG")){const e=n.readSync(o.dataId),t=r.shape[c];for(let n=0;n<e.length;++n){const a=e[n];AU(a<=t-1&&a>=0,(()=>"GatherV2: the index value ".concat(a," is not in [0, ").concat(t-1,"]")))}}const l=Y2(r,o,c,i),u=DU(o.shape),d=[],h=Yne({inputs:{x:r},backend:n,attrs:{shape:[l.batchSize,l.outerSize,l.dimSize,l.sliceSize]}}),p=Yne({inputs:{x:o},backend:n,attrs:{shape:[l.batchSize,u/l.batchSize]}});d.push(h),d.push(p);const f=[l.batchSize,l.outerSize,u/l.batchSize,l.sliceSize];if(n.shouldExecuteOnCPU([r,o])||"string"===r.dtype){const e=n.bufferSync(p),t=n.bufferSync(h),a=fte(t,e,f);return d.forEach((e=>n.disposeIntermediateTensorInfo(e))),n.makeTensorInfo(l.outputShape,a.dtype,a.values)}const m=new ose(h.shape,f),g=n.runWebGLProgram(m,[h,p],h.dtype);d.push(g);const b=Yne({inputs:{x:g},backend:n,attrs:{shape:l.outputShape}});return d.forEach((e=>n.disposeIntermediateTensorInfo(e))),b}const ise={kernelName:CH,backendName:"webgl",kernelFunc:sse},cse=Vne({opSnippet:"return float(a > b);",packedOpSnippet:"\n  return vec4(greaterThan(a, b));\n",cpuKernelImpl:mte,dtype:"bool"}),lse={kernelName:EH,backendName:"webgl",kernelFunc:cse},use=Vne({opSnippet:"return float(a >= b);",packedOpSnippet:"\n  return vec4(greaterThanEqual(a, b));\n",dtype:"bool",cpuKernelImpl:gte}),dse={kernelName:RH,backendName:"webgl",kernelFunc:use};const hse={kernelName:AH,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{input:a}=t;return zoe(a,!0,n)}},pse=Wne({opSnippet:"return float(!isnan(x) && !isinf(x));",dtype:"bool"}),fse={kernelName:OH,backendName:"webgl",kernelFunc:pse},mse=Wne({opSnippet:"return float(isinf(x));",dtype:"bool"}),gse={kernelName:DH,backendName:"webgl",kernelFunc:mse},bse=Wne({opSnippet:"return float(isnan(x));",dtype:"bool"}),yse={kernelName:MH,backendName:"webgl",kernelFunc:bse},xse=Vne({opSnippet:"return float(a < b);",packedOpSnippet:"\n  return vec4(lessThan(a, b));\n",cpuKernelImpl:bte,dtype:"bool"}),vse={kernelName:PH,backendName:"webgl",kernelFunc:xse},wse=Vne({opSnippet:"return float(a <= b);",packedOpSnippet:"\n  return vec4(lessThanEqual(a, b));\n",cpuKernelImpl:yte,dtype:"bool"}),kse={kernelName:zH,backendName:"webgl",kernelFunc:wse};const Ise={kernelName:BH,backendName:"webgl",kernelFunc:function(e){const{backend:t,attrs:n}=e,{start:a,stop:r,num:o}=n,s=xte(a,r,o);return t.makeTensorInfo([s.length],"float32",s)}},Sse=Wne({opSnippet:Bne+"\n  return x < 0.0 ? 0./0. : log(x);\n",packedOpSnippet:"\n  vec4 result = log(x);\n  bvec4 isNaN = isnan(x);\n  result.r = isNaN.r ? x.r : (x.r < 0.0 ? 0./0. : result.r);\n  result.g = isNaN.g ? x.g : (x.g < 0.0 ? 0./0. : result.g);\n  result.b = isNaN.b ? x.b : (x.b < 0.0 ? 0./0. : result.b);\n  result.a = isNaN.a ? x.a : (x.a < 0.0 ? 0./0. : result.a);\n  return result;\n",cpuKernelImpl:vte}),Nse={kernelName:WH,backendName:"webgl",kernelFunc:Sse},Cse=Wne({opSnippet:Bne+"\n  return log(1.0 + x);\n"}),Tse={kernelName:VH,backendName:"webgl",kernelFunc:Cse},Ese=Vne({opSnippet:"return float(a >= 1.0 && b >= 1.0);",packedOpSnippet:"\n  return vec4(\n    vec4(greaterThanEqual(a, vec4(1.0))) *\n    vec4(greaterThanEqual(b, vec4(1.0))));\n",dtype:"bool"}),Rse={kernelName:UH,backendName:"webgl",kernelFunc:Ese},_se=Wne({opSnippet:"return float(!(x >= 1.0));"}),Ase={kernelName:GH,backendName:"webgl",kernelFunc:_se},Fse=Vne({opSnippet:"return float(a >= 1.0 || b >= 1.0);",packedOpSnippet:"\n  return min(\n    vec4(greaterThanEqual(a, vec4(1.0))) +\n    vec4(greaterThanEqual(b, vec4(1.0))),\n    vec4(1.0));\n",dtype:"bool"}),Ose={kernelName:HH,backendName:"webgl",kernelFunc:Fse};class Dse{constructor(e,t,n,a,r){this.variableNames=["x"],this.outputShape=[];const o=t,s=e[3]-1;let i;this.outputShape=e;const c="float(".concat(n,") + float(").concat(a,") * sum");i=.5===r?"inversesqrt(".concat(c,")"):1===r?"1.0/(".concat(c,")"):"exp(log(".concat(c,") * float(-").concat(r,"));"),this.userCode="\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int r = coords[1];\n        int c = coords[2];\n        int d = coords[3];\n        float x = getX(b, r, c, d);\n        float sum = 0.0;\n        for (int j = -".concat(o,"; j <= ").concat(o,"; j++) {\n          int idx = d + j;\n          if (idx >= 0 && idx <=  ").concat(s,") {\n            float z = getX(b, r, c, idx);\n            sum += z * z;\n          }\n        }\n        float val = x * ").concat(i,";\n        setOutput(val);\n      }\n    ")}}class Mse{constructor(e,t,n,a,r){this.variableNames=["x"],this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0;const o=t,s=e[3]-1;let i;this.outputShape=e;const c="float(".concat(n,") + float(").concat(a,") * sum");i=.5===r?"inversesqrt(".concat(c,")"):1===r?"1.0/(".concat(c,")"):"exp(log(".concat(c,") * float(-").concat(r,"));"),this.userCode="\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords.x;\n        int r = coords.y;\n        int c = coords.z;\n        int d = coords.w;\n\n        bool hasNextCol = d < ".concat(this.outputShape[3],";\n        bool hasNextRow = c < ").concat(this.outputShape[2],";\n\n        vec4 sum = vec4(0.);\n        vec4 xFragAtOutputCoords = getX(b, r, c, d);\n\n        vec4 xAtOutputCoords = vec4(\n          getChannel(xFragAtOutputCoords, vec2(c, d)),\n          hasNextCol ?\n            getChannel(xFragAtOutputCoords, vec2(c, d + 1)) : 0.0,\n          hasNextRow ?\n            getChannel(xFragAtOutputCoords , vec2(c + 1, d)) : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getChannel(xFragAtOutputCoords, vec2(c + 1, d + 1)) : 0.0\n        );\n\n        int firstChannel = d - ").concat(o,";\n        vec2 cache = vec2(0.);\n        if(firstChannel >= 0){\n          vec4 firstChannelFrag = getX(b, r, c, firstChannel);\n          cache.x = getChannel(firstChannelFrag, vec2(c, firstChannel));\n            if(hasNextRow){\n              cache.y = getChannel(firstChannelFrag, vec2(c + 1, firstChannel));\n            }\n        }\n\n        ivec2 depth = ivec2(d, d + 1);\n        for (int j = - ").concat(o,"; j <= ").concat(o,"; j++) {\n          ivec2 idx = depth + j;\n          bvec2 aboveLowerBound = greaterThanEqual(idx, ivec2(0));\n          bvec2 belowUpperBound = lessThanEqual(idx, ivec2(").concat(s,"));\n\n          bool depthInRange = aboveLowerBound.x && belowUpperBound.x;\n          bool depthPlusOneInRange = aboveLowerBound.y && belowUpperBound.y;\n\n          if(depthInRange || depthPlusOneInRange){\n            vec4 z = vec4(0.);\n            vec4 xFragAtCurrentDepth;\n            z.xz = cache.xy;\n            if(depthPlusOneInRange && hasNextCol){\n              xFragAtCurrentDepth = idx.y != d ?\n                getX(b, r, c, idx.y) : xFragAtOutputCoords;\n              z.y = getChannel(xFragAtCurrentDepth, vec2(c, idx.y));\n              if(hasNextRow){\n                z.w = getChannel(xFragAtCurrentDepth, vec2(c + 1, idx.y));\n              }\n            }\n            cache.xy = z.yw;\n            sum += z * z;\n          }\n        }\n        vec4 result = xAtOutputCoords * ").concat(i,";\n        setOutput(result);\n      }\n    ")}}const Lse={kernelName:jH,backendName:"webgl",kernelFunc:e=>{const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{depthRadius:o,bias:s,alpha:i,beta:c}=a,l=uG().getBool("WEBGL_PACK_NORMALIZATION")?new Mse(r.shape,o,s,i,c):new Dse(r.shape,o,s,i,c);return n.runWebGLProgram(l,[r],r.dtype)}};class Pse{constructor(e,t,n,a,r){this.variableNames=["inputImage","outputImage","dy"],this.outputShape=[],this.outputShape=e,this.depth=e[3],this.depthRadius=t,this.bias=n,this.alpha=a,this.beta=r,this.userCode="\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int r = coords[1];\n        int c = coords[2];\n\n        float result = 0.0;\n        for (int d = 0; d < ".concat(this.depth,"; ++d) {\n          int depthBegin = int(max(0.0, float(d - ").concat(t,")));\n          int depthEnd = int(min(float(").concat(this.depth,"),\n              float(d + ").concat(t," + 1)));\n\n          const int MIN_DEPTH_BEGIN = 0;\n          const int MAX_DEPTH_END = ").concat(this.depth,";\n\n          float norm = 0.0;\n          for (int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k) {\n            if (k < depthBegin){\n              continue;\n            }\n            else if (k >= depthBegin && k < depthEnd) {\n              norm += getInputImage(b, r, c, k) * getInputImage(b, r, c, k);\n            }\n            else {\n              break;\n            }\n          }\n\n          norm = float(").concat(a,") * norm + float(").concat(n,");\n\n          for(int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k){\n            if (k < depthBegin){\n              continue;\n            }\n            else if (k >= depthBegin && k < depthEnd){\n              float dyi = -2.0 * float(").concat(a,")\n                * float(").concat(r,")\n                * getInputImage(b, r, c, k) * getOutputImage(b, r, c, d)\n                / norm;\n              if (k == d) {\n                dyi += pow(norm, -1.0 * ").concat(r,");\n              }\n              if (k == coords[3]) {\n                dyi *= getDy(b, r, c, d);\n                result += dyi;\n              }\n            }\n            else {\n              break;\n            }\n          }\n      }\n      setOutput(result);\n      }\n    ")}}const zse={kernelName:KH,backendName:"webgl",kernelFunc:e=>{const{inputs:t,backend:n,attrs:a}=e,{x:r,y:o,dy:s}=t,{depthRadius:i,bias:c,alpha:l,beta:u}=a,d=new Pse(r.shape,i,c,l,u);return n.runWebGLProgram(d,[r,o,s],r.dtype)}};function Bse(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{reductionIndices:o,keepDims:s}=a,i=r.shape.length,c=VU(o,r.shape);let l=c;const u=ZJ(l,i),d=null!=u,h=n.shouldExecuteOnCPU([r]);let p=r;if(d){if(h){const e=n.texData.get(p.dataId).values,t=new Array(i);for(let n=0;n<t.length;n++)t[n]=r.shape[u[n]];const a=Yte(e,r.shape,r.dtype,u,t);p=n.makeTensorInfo(t,r.dtype);n.texData.get(p.dataId).values=a}else p=nae(r,u,n);l=eZ(l.length,i)}JJ("max",l,i);const[f,m]=YJ(p.shape,l);let g,b=f;if(s&&(b=QJ(f,c)),h){const e=n.texData.get(p.dataId).values,t=wte(e,DU(m),b,r.dtype);g=n.makeTensorInfo(b,r.dtype);n.texData.get(g.dataId).values=t}else g=function(e,t,n,a){const r=DU(t),o=Yne({inputs:{x:e},attrs:{shape:[DU(e.shape)/r,r]},backend:a}),s=$ne(o,e.dtype,"max",a),i=Yne({inputs:{x:s},attrs:{shape:n},backend:a});return a.disposeIntermediateTensorInfo(o),a.disposeIntermediateTensorInfo(s),i}(p,m,b,n);return d&&n.disposeIntermediateTensorInfo(p),g}const Wse={kernelName:qH,backendName:"webgl",kernelFunc:Bse},Vse=Vne({opSnippet:Nne+"\n  return max(a, b);\n",packedOpSnippet:"\n  vec4 result = vec4(max(a, b));\n  bvec4 isNaNA = isnan(a);\n  bvec4 isNaNB = isnan(b);\n  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);\n  "+Tne+"\n  return result;\n",cpuKernelImpl:kte}),Use={kernelName:XH,backendName:"webgl",kernelFunc:Vse};const Gse={kernelName:YH,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t;hee(r,"maxPool");const{filterSize:o,strides:s,pad:i,dimRoundingMode:c}=a;AU(YQ(s,1),(()=>"Error in maxPool: Either strides or dilations must be 1. "+"Got strides ".concat(s," and dilations '").concat(1,"'")));const l=BQ(r.shape,o,s,1,i,c);if(1===l.filterWidth&&1===l.filterHeight&&MU(l.inShape,l.outShape))return Rne({inputs:{x:r},backend:n});const u=new Vae(l,"max",!1);return n.runWebGLProgram(u,[r],r.dtype)}};const Hse={kernelName:JH,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{filterSize:o,strides:s,pad:i,dataFormat:c,dimRoundingMode:l}=a,u=WQ(r.shape,o,s,[1,1,1],i,l,c),d=new Uae(u,"max",!1);return n.runWebGLProgram(d,[r],r.dtype)}};class jse{constructor(e){this.variableNames=["dy","maxPos"],this.outputShape=e.inShape;const t=e.strideHeight,n=e.strideWidth,a=e.dilationHeight,r=e.effectiveFilterHeight,o=e.effectiveFilterWidth,s=r-1-e.padInfo.top,i=o-1-e.padInfo.left,c=r*o-1;this.userCode="\n      const ivec2 pads = ivec2(".concat(s,", ").concat(i,");\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n\n        ivec2 dyRCCorner = coords.yz - pads;\n        int dyRCorner = dyRCCorner.x;\n        int dyCCorner = dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ").concat(r,";\n          wR += ").concat(a,") {\n          float dyR = float(dyRCorner + wR) / ").concat(t,".0;\n\n          if (dyR < 0.0 || dyR >= ").concat(e.outHeight,".0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          for (int wC = 0; wC < ").concat(o,"; wC++) {\n            float dyC = float(dyCCorner + wC) / ").concat(n,".0;\n\n            if (dyC < 0.0 || dyC >= ").concat(e.outWidth,".0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            float dyValue = getDy(b, idyR, idyC, d);\n            int maxPosValue = ").concat(c," - int(getMaxPos(b, idyR, idyC, d));\n\n            // Get the current value, check it against the value from the\n            // position matrix.\n            int curPosValue = wR * ").concat(o," + wC;\n            float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);\n\n            dotProd += dyValue * mask;\n          }\n        }\n        setOutput(dotProd);\n      }\n    ")}}class Kse{constructor(e){this.variableNames=["dy","maxPos"],this.outputShape=e.inShape;const t=e.strideDepth,n=e.strideHeight,a=e.strideWidth,r=e.dilationDepth,o=e.dilationHeight,s=e.dilationWidth,i=e.effectiveFilterDepth,c=e.effectiveFilterHeight,l=e.effectiveFilterWidth,u=i-1-e.padInfo.front,d=c-1-e.padInfo.top,h=l-1-e.padInfo.left,p=i*c*l-1;this.userCode="\n      const ivec3 pads = ivec3(".concat(u,", ").concat(d,", ").concat(h,");\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyDCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        // Convolve dy(?, ?, ?, ch) with pos mask(:, :, :, d) to get\n        // dx(xD, xR, xC, ch).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int wD = 0; wD < ").concat(i,";\n           wD += ").concat(r,") {\n          float dyD = float(dyDCorner + wD) / ").concat(t,".0;\n\n          if (dyD < 0.0 || dyD >= ").concat(e.outDepth,".0 || fract(dyD) > 0.0) {\n            continue;\n          }\n          int idyD = int(dyD);\n\n          for (int wR = 0; wR < ").concat(c,";\n              wR += ").concat(o,") {\n            float dyR = float(dyRCorner + wR) / ").concat(n,".0;\n\n            if (dyR < 0.0 || dyR >= ").concat(e.outHeight,".0 ||\n                fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            for (int wC = 0; wC < ").concat(l,";\n                wC += ").concat(s,") {\n              float dyC = float(dyCCorner + wC) / ").concat(a,".0;\n\n              if (dyC < 0.0 || dyC >= ").concat(e.outWidth,".0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              float dyValue = getDy(batch, idyD, idyR, idyC, ch);\n              int maxPosValue = ").concat(p," -\n                  int(getMaxPos(batch, idyD, idyR, idyC, ch));\n\n              // Get the current value, check it against the value from the\n              // position matrix.\n              int curPosValue =\n                  wD * ").concat(c," * ").concat(l," +\n                  wR * ").concat(l," + wC;\n              float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);\n\n              dotProd += dyValue * mask;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    ")}}const qse={kernelName:ZH,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{dy:r,input:o}=t,s=o,{filterSize:i,strides:c,pad:l,dimRoundingMode:u}=a,d=WQ(s.shape,i,c,[1,1,1],l,u),h=new Uae(d,"max",!0),p=n.runWebGLProgram(h,[s],s.dtype),f=new Kse(d),m=n.runWebGLProgram(f,[r,p],s.dtype);return n.disposeIntermediateTensorInfo(p),m}};const Xse={kernelName:QH,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{dy:r,input:o,output:s}=t,i=o;hee([o,s],"maxPoolGrad");const{filterSize:c,strides:l,pad:u,dimRoundingMode:d}=a,h=BQ(i.shape,c,l,1,u,d),p=new Vae(h,"max",!0),f=n.runWebGLProgram(p,[i],i.dtype),m=new jse(h),g=n.runWebGLProgram(m,[r,f],i.dtype);return n.disposeIntermediateTensorInfo(f),g}};const Yse={kernelName:$H,backendName:"webgl",kernelFunc:e=>{let{inputs:t,attrs:n,backend:a}=e;const{x:r}=t,{filterSize:o,strides:s,pad:i,includeBatchInIndex:c}=n,l=a;AU(4===r.shape.length,(()=>"Error in maxPool: input must be rank 4 but got rank ".concat(r.shape.length,".")));const u=[1,1];AU(YQ(s,u),(()=>"Error in maxPool: Either strides or dilations must be 1. "+"Got strides ".concat(s," and dilations '").concat(u,"'")));const d=BQ(r.shape,o,s,u,i),[h,p]=function(e,t,n,a){let r=new Vae(n,"max",!1);const o=a.runWebGLProgram(r,[e],"float32");return r=new Vae(n,"max",!0,!0,t),[o,a.runWebGLProgram(r,[e],"float32")]}(r,c,d,l);return[h,p]}};const Qse={kernelName:ej,backendName:"webgl",kernelFunc:e=>{let{inputs:t,attrs:n,backend:a}=e;const{x:r}=t,{keepDims:o,axis:s}=n,i=a,c=r.shape.length,l=VU(s,r.shape);let u=l;const d=ZJ(u,c),h=null!=d,p=i.shouldExecuteOnCPU([r]),f=[];let m=r;if(h){if(p){const e=i.texData.get(m.dataId).values,t=new Array(c);for(let a=0;a<t.length;a++)t[a]=r.shape[d[a]];const n=Yte(e,r.shape,r.dtype,d,t);m=i.makeTensorInfo(t,r.dtype);i.texData.get(m.dataId).values=n}else m=nae(r,d,i);f.push(m),u=eZ(u.length,c)}JJ("sum",u,c);const[g,b]=YJ(m.shape,u);let y=g;o&&(y=QJ(g,l));const x=function(e,t,n,a){const r=DU(t),o=Yne({inputs:{x:e},attrs:{shape:[DU(e.shape)/r,r]},backend:a}),s=$ne(o,"float32","mean",a),i=Yne({inputs:{x:s},attrs:{shape:n},backend:a});return a.disposeIntermediateTensorInfo(o),a.disposeIntermediateTensorInfo(s),i}(m,b,y,i);for(const v of f)i.disposeIntermediateTensorInfo(v);return x}};const Jse={kernelName:tj,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{axis:o,keepDims:s}=a,i=r.shape.length,c=VU(o,r.shape);let l=c;const u=ZJ(l,i);let d=r;null!=u&&(d=oae({inputs:{x:r},backend:n,attrs:{perm:u}}),l=eZ(l.length,r.shape.length)),JJ("min",l,i);const[h,p]=YJ(d.shape,l),f=Yne({inputs:{x:d},backend:n,attrs:{shape:[-1,DU(p)]}}),m=$ne(f,f.dtype,"min",n);let g;if(s){g=Yne({inputs:{x:m},backend:n,attrs:{shape:QJ(h,c)}})}else g=Yne({inputs:{x:m},backend:n,attrs:{shape:h}});return n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),null!=u&&n.disposeIntermediateTensorInfo(d),g}},Zse=Vne({opSnippet:Nne+"\n  return min(a, b);\n",packedOpSnippet:"\n  vec4 result = vec4(min(a, b));\n  bvec4 isNaNA = isnan(a);\n  bvec4 isNaNB = isnan(b);\n  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);\n  "+Tne+"\n  return result;\n",cpuKernelImpl:Ite}),$se={kernelName:nj,backendName:"webgl",kernelFunc:Zse};class eie{constructor(e,t,n){this.variableNames=["x"],this.outputShape=t.map(((t,n)=>t[0]+e[n]+t[1]));const a=e.length,r=_ee(a),o=t.map((e=>e[0])).join(","),s=t.map(((t,n)=>t[0]+e[n])).join(","),i=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,a),c="reflect"===n?0:1;this.userCode=1!==a?"\n      ".concat(r," start = ").concat(r,"(").concat(o,");\n      ").concat(r," end = ").concat(r,"(").concat(s,");\n\n      void main() {\n        ").concat(r," outC = getOutputCoords();\n        for (int i = 0; i < ").concat(a,"; i++) {\n          if (outC[i] < start[i]) {\n            outC[i] = start[i] * 2 - outC[i] - ").concat(c,";\n          } else if(outC[i] >= end[i]) {\n            outC[i] = (end[i] - 1) * 2 - outC[i] + ").concat(c,";\n          }\n        }\n        ").concat(r," coords = outC - start;\n        setOutput(getX(").concat(i,"));\n      }\n    "):"\n        int start = ".concat(o,";\n        int end = ").concat(s,";\n\n        void main() {\n          int outC = getOutputCoords();\n          if (outC < start) {\n            outC = start * 2 - outC - ").concat(c,";\n          } else if(outC >= end) {\n            outC = (end - 1) * 2 - outC + ").concat(c,";\n          }\n          setOutput(getX(outC - start));\n        }\n      ")}}class tie{constructor(e,t,n){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t.map(((t,n)=>t[0]+e[n]+t[1]));const a=e.length,r=_ee(a),o=t.map((e=>e[0])).join(","),s=t.map(((t,n)=>t[0]+e[n])).join(","),i=Zte("rc",a),c=Zte("source",a),l="".concat(i[a-1]," < ").concat(this.outputShape[a-1]),u=1===a?"source":"vec2(".concat(c.slice(-2).join(),")"),d="reflect"===n?0:1;let h="";if(1===a){const e="\n        ".concat(r," source = rc;\n        if (source < start) {\n          source = start * 2 - source - ").concat(d,";\n        } else if (source >= end) {\n          source = (end - 1) * 2 - source + ").concat(d,";\n        }\n        source -= start;\n      ");h="\n        ".concat(r," rc = outputLoc;\n        ").concat(e,"\n        result[0] = getChannel(getX(").concat(c.join(),"), ").concat(u,");\n        ").concat(i[a-1]," += 1;\n        if(").concat(l,") {\n          ").concat(e,"\n          result[1] = getChannel(getX(").concat(c.join(),"), ").concat(u,");\n        }\n      ")}else{const e="\n        ".concat(r," source = rc;\n        ").concat(r," lt = ").concat(r,"(lessThan(source, start));\n        ").concat(r," gte = ").concat(r,"(greaterThanEqual(source, end));\n        ").concat(r," orig = 1 - (lt + gte);\n        source = orig * source +\n                lt * (start * 2 - source - ").concat(d,") +\n                gte * ((end - 1) * 2 - source + ").concat(d,");\n        source -= start;\n      ");h="\n        ".concat(r," rc = outputLoc;\n        ").concat(e,"\n        result[0] = getChannel(getX(").concat(c.join(),"), ").concat(u,");\n        ").concat(i[a-1]," += 1;\n        if(").concat(l,") {\n          ").concat(e,"\n          result[1] = getChannel(getX(").concat(c.join(),"), ").concat(u,");\n        }\n        rc = outputLoc;\n        ").concat(i[a-2]," += 1;\n        if(").concat(i[a-2]," < ").concat(this.outputShape[a-2],") {\n          ").concat(e,"\n          result[2] = getChannel(getX(").concat(c.join(),"), ").concat(u,");\n          ").concat(i[a-1]," += 1;\n          if(").concat(l,") {\n            ").concat(e,"\n            result[3] = getChannel(getX(").concat(c.join(),"), ").concat(u,");\n          }\n        }\n      ")}this.userCode="\n      const ".concat(r," start = ").concat(r,"(").concat(o,");\n      const ").concat(r," end = ").concat(r,"(").concat(s,");\n\n      void main() {\n        ").concat(r," outputLoc = getOutputCoords();\n        vec4 result = vec4(0.);\n        ").concat(h,"\n        setOutput(result);\n      }\n    ")}}const nie={kernelName:aj,backendName:"webgl",kernelFunc:e=>{let{inputs:t,backend:n,attrs:a}=e;const{x:r}=t,{paddings:o,mode:s}=a,i=uG().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new tie(r.shape,o,s):new eie(r.shape,o,s);return n.runWebGLProgram(i,[r],r.dtype)}},aie=Vne({opSnippet:"if (b == 0.0) return NAN;\n  return mod(a, b);",packedOpSnippet:"\n  vec4 result = mod(a, b);\n  bvec4 isNaN = equal(b, vec4(0.0));\n  "+Tne+"\n  return result;\n"}),rie={kernelName:rj,backendName:"webgl",kernelFunc:aie};class oie{constructor(e,t,n){this.variableNames=["probs"],this.customUniforms=[{name:"seed",type:"float"}],this.outputShape=[e,n],this.userCode="\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n\n        float r = random(seed);\n        float cdf = 0.0;\n\n        for (int i = 0; i < ".concat(t-1,"; i++) {\n          cdf += getProbs(batch, i);\n\n          if (r < cdf) {\n            setOutput(float(i));\n            return;\n          }\n        }\n\n        // If no other event happened, last event happened.\n        setOutput(float(").concat(t-1,"));\n      }\n    ")}}const sie=Vne({opSnippet:"\nif (a == b) {\n  return 1.0;\n};\nreturn a / b;",packedOpSnippet:"\n  // vec4 one = vec4(equal(a, b));\n  // return one + (vec4(1.0) - one) * a / b;\n  vec4 result = a / b;\n  if(a.x == b.x) {\n    result.x = 1.;\n  }\n  if(a.y == b.y) {\n    result.y = 1.;\n  }\n  if(a.z == b.z) {\n    result.z = 1.;\n  }\n  if(a.w == b.w) {\n    result.w = 1.;\n  }\n\n  return result;\n",checkOutOfBounds:!0}),iie={kernelName:dH,backendName:"webgl",kernelFunc:sie},cie="return a - b;",lie=Vne({opSnippet:cie,packedOpSnippet:cie,supportsComplex:!0,cpuKernelImpl:Kte}),uie={kernelName:lK,backendName:"webgl",kernelFunc:lie};function die(e){const{inputs:t,backend:n,attrs:a}=e,{logits:r}=t,{dim:o}=a,s=VU([o],r.shape),i=Bse({inputs:{x:r},backend:n,attrs:{reductionIndices:s,keepDims:!1}}),c=QJ(i.shape,s),l=Yne({inputs:{x:i},backend:n,attrs:{shape:c}}),u=lie({inputs:{a:r,b:l},backend:n}),d=_oe({inputs:{x:u},backend:n}),h=aae({inputs:{x:d},backend:n,attrs:{axis:s,keepDims:!1}}),p=Yne({inputs:{x:h},backend:n,attrs:{shape:c}}),f=sie({inputs:{a:d,b:p},backend:n});return n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(l),n.disposeIntermediateTensorInfo(u),n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(p),f}const hie={kernelName:Qj,backendName:"webgl",kernelFunc:die};const pie={kernelName:oj,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{logits:r}=t,{numSamples:o,seed:s,normalized:i}=a,c=i?r:die({inputs:{logits:r},backend:n,attrs:{dim:r.shape.length-1}}),l=c.shape[0],u=c.shape[1],d=new oie(l,u,o),h=[[s]],p=n.runWebGLProgram(d,[c],"int32",h);return i||n.disposeIntermediateTensorInfo(c),p}},fie=sne+"\n  return -x;\n";const mie={kernelName:ij,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{x:a}=t;if(n.shouldExecuteOnCPU([a])){const e=n.texData.get(a.dataId),[t,r]=Nte(e.values,a.shape,a.dtype);return n.makeTensorInfo(r,a.dtype,t)}let r;return r=uG().getBool("WEBGL_PACK_UNARY_OPERATIONS")?new xne(a.shape,"\n  vec4 result = -x;\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n"):new one(a.shape,fie),n.runWebGLProgram(r,[a],a.dtype)}},gie=e1;const bie={kernelName:lj,backendName:"webgl",kernelFunc:function(e){CK("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:t,backend:n,attrs:a}=e,{boxes:r,scores:o}=t,{maxOutputSize:s,iouThreshold:i,scoreThreshold:c}=a,l=n.readSync(r.dataId),u=n.readSync(o.dataId),{selectedIndices:d}=gie(l,u,s,i,c);return n.makeTensorInfo([d.length],"int32",new Int32Array(d))}},yie=t1;const xie={kernelName:uj,backendName:"webgl",kernelFunc:function(e){CK("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:t,backend:n,attrs:a}=e,{boxes:r,scores:o}=t,{maxOutputSize:s,iouThreshold:i,scoreThreshold:c,padToMaxOutputSize:l}=a,u=n.readSync(r.dataId),d=n.readSync(o.dataId),{selectedIndices:h,validOutputs:p}=yie(u,d,s,i,c,l);return[n.makeTensorInfo([h.length],"int32",new Int32Array(h)),n.makeTensorInfo([],"int32",new Int32Array([p]))]}},vie=n1;const wie={kernelName:dj,backendName:"webgl",kernelFunc:function(e){CK("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:t,backend:n,attrs:a}=e,{boxes:r,scores:o}=t,{maxOutputSize:s,iouThreshold:i,scoreThreshold:c,softNmsSigma:l}=a,u=n.readSync(r.dataId),d=n.readSync(o.dataId),h=s,p=i,f=c,m=l,{selectedIndices:g,selectedScores:b}=vie(u,d,h,p,f,m);return[n.makeTensorInfo([g.length],"int32",new Int32Array(g)),n.makeTensorInfo([b.length],"float32",new Float32Array(b))]}};class kie{constructor(e,t,n,a){this.variableNames=["indices"],this.outputShape=[e,t],this.userCode="\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int index = round(getIndices(coords.x));\n        setOutput(mix(float(".concat(a,"), float(").concat(n,"),\n                      float(index == coords.y)));\n      }\n    ")}}const Iie={kernelName:pj,backendName:"webgl",kernelFunc:e=>{const{inputs:t,backend:n,attrs:a}=e,{indices:r}=t,{dtype:o,depth:s,onValue:i,offValue:c}=a,l=DU(r.shape),u=new kie(l,s,i,c),d=Yne({inputs:{x:r},backend:n,attrs:{shape:[l]}}),h=n.runWebGLProgram(u,[d],o);n.disposeIntermediateTensorInfo(d);const p=Yne({inputs:{x:h},backend:n,attrs:{shape:[...r.shape,s]}});return n.disposeIntermediateTensorInfo(h),p}};function Sie(e){const{inputs:t,backend:n}=e,{x:a}=t;if("complex64"===a.dtype){const e=ure({inputs:{input:a},backend:n}),t=Sie({inputs:{x:e},backend:n}),r=Cre({inputs:{input:a},backend:n}),o=Sie({inputs:{x:r},backend:n}),s=Ane({inputs:{real:t,imag:o},backend:n});return n.disposeIntermediateTensorInfo(e),n.disposeIntermediateTensorInfo(t),n.disposeIntermediateTensorInfo(r),n.disposeIntermediateTensorInfo(o),s}return Voe({attrs:{shape:a.shape,dtype:a.dtype,value:"string"===a.dtype?"":0},backend:n})}const Nie={kernelName:xK,backendName:"webgl",kernelFunc:Sie};const Cie={kernelName:hj,backendName:"webgl",kernelFunc:function e(t){const{inputs:n,backend:a}=t,{x:r}=n;if("string"===r.dtype)throw new Error("onesLike is not supported under string dtype");if("complex64"===r.dtype){const t=ure({inputs:{input:r},backend:a}),n=e({inputs:{x:t},backend:a}),o=Cre({inputs:{input:r},backend:a}),s=Sie({inputs:{x:o},backend:a}),i=Ane({inputs:{real:n,imag:s},backend:a});return a.disposeIntermediateTensorInfo(t),a.disposeIntermediateTensorInfo(n),a.disposeIntermediateTensorInfo(o),a.disposeIntermediateTensorInfo(s),i}return Voe({attrs:{shape:r.shape,dtype:r.dtype,value:1},backend:a})}};const Tie={kernelName:fj,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{axis:r}=a;if(1===t.length)return Foe({inputs:{input:t[0]},backend:n,attrs:{dim:r}});const o=t[0].shape,s=t[0].dtype;t.forEach((e=>{FU(o,e.shape,"All tensors passed to stack must have matching shapes"),AU(s===e.dtype,(()=>"All tensors passed to stack must have matching dtypes"))}));const i=[],c=t.map((e=>{const t=Foe({inputs:{input:e},backend:n,attrs:{dim:r}});return i.push(t),t})),l=Rre({inputs:c,backend:n,attrs:{axis:r}});return i.forEach((e=>n.disposeIntermediateTensorInfo(e))),l}};class Eie{constructor(e,t,n){this.variableNames=["x"],this.customUniforms=[{name:"value",type:"float"}],this.outputShape=t.map(((t,n)=>t[0]+e[n]+t[1]));const a=e.length,r=_ee(a),o=t.map((e=>e[0])).join(","),s=t.map(((t,n)=>t[0]+e[n])).join(","),i=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,a);this.userCode=1!==a?"\n      ".concat(r," start = ").concat(r,"(").concat(o,");\n      ").concat(r," end = ").concat(r,"(").concat(s,");\n\n      void main() {\n        ").concat(r," outC = getOutputCoords();\n        if (any(lessThan(outC, start)) || any(greaterThanEqual(outC, end))) {\n          setOutput(value);\n        } else {\n          ").concat(r," coords = outC - start;\n          setOutput(getX(").concat(i,"));\n        }\n      }\n    "):"\n        int start = ".concat(o,";\n        int end = ").concat(s,";\n\n        void main() {\n          int outC = getOutputCoords();\n          if (outC < start || outC >= end) {\n            setOutput(value);\n          } else {\n            setOutput(getX(outC - start));\n          }\n        }\n      ")}}class Rie{constructor(e,t,n){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"value",type:"float"}],this.outputShape=t.map(((t,n)=>t[0]+e[n]+t[1]));const a=e.length,r=_ee(a),o=t.map((e=>e[0])).join(","),s=t.map(((t,n)=>t[0]+e[n])).join(","),i=Zte("rc",a),c=Zte("source",a),l="".concat(i[a-1]," < ").concat(this.outputShape[a-1]),u=1===a?"source":"vec2(".concat(c.slice(-2).join(),")"),d=["".concat(r," rc = outputLoc;"),"".concat(i[a-1]," += 1;\n       if(").concat(l,") {\n      "),1===a?"":"}\n       rc = outputLoc;\n       ".concat(i[a-2]," += 1;\n       if(").concat(i[a-2]," < ").concat(this.outputShape[a-2],") {"),1===a?"":"  ".concat(i[a-1]," += 1;\n         if(").concat(l,") {")],h=1===a?"rc < start || rc >= end":"any(lessThan(rc, start)) || any(greaterThanEqual(rc, end))";let p="";for(let f=0,m=1===a?2:4;f<m;f++)p+="\n        ".concat(d[f],"\n        if (").concat(h,") {\n          result[").concat(f,"] = float(value);\n        } else {\n          ").concat(r," source = rc - start;\n          result[").concat(f,"] = getChannel(getX(").concat(c.join(),"), ").concat(u,");\n        }\n      ");p+=1===a?"} ":"}}",this.userCode="\n      const ".concat(r," start = ").concat(r,"(").concat(o,");\n      const ").concat(r," end = ").concat(r,"(").concat(s,");\n\n      void main() {\n        ").concat(r," outputLoc = getOutputCoords();\n        vec4 result = vec4(0.);\n        ").concat(p,"\n        setOutput(result);\n      }\n    ")}}const _ie=e=>{const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{paddings:o,constantValue:s}=a;if(0===DU(r.shape)){const e=o.map(((e,t)=>e[0]+r.shape[t]+e[1]));return Voe({backend:n,attrs:{shape:e,value:s,dtype:r.dtype}})}const i=uG().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new Rie(r.shape,o,s):new Eie(r.shape,o,s),c=[[s]];return n.runWebGLProgram(i,[r],r.dtype,c)},Aie={kernelName:mj,backendName:"webgl",kernelFunc:_ie},Fie=Vne({opSnippet:"\n  if(a < 0.0 && floor(b) < b){\n    return NAN;\n  }\n  if (b == 0.0) {\n    return 1.0;\n  }\n  return (round(mod(b, 2.0)) != 1) ?\n      pow(abs(a), b) : sign(a) * pow(abs(a), b);\n",packedOpSnippet:"\n  // isModRound1 has 1 for components with round(mod(b, 2.0)) == 1, 0 otherwise.\n  vec4 isModRound1 = vec4(equal(round(mod(b, 2.0)), ivec4(1)));\n  vec4 multiplier = sign(a) * isModRound1 + (vec4(1.0) - isModRound1);\n  vec4 result = multiplier * pow(abs(a), b);\n\n  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS\n  bvec4 isExpZero = equal(b, vec4(0.0));\n  result.r = isExpZero.r ? 1.0 : result.r;\n  result.g = isExpZero.g ? 1.0 : result.g;\n  result.b = isExpZero.b ? 1.0 : result.b;\n  result.a = isExpZero.a ? 1.0 : result.a;\n\n  bvec4 isNaN1 = lessThan(a, vec4(0.0));\n  bvec4 isNaN2 = lessThan(floor(b), b);\n  bvec4 isNaN = bvec4(isNaN1.x && isNaN2.x, isNaN1.y && isNaN2.y, isNaN1.z && isNaN2.z, isNaN1.w && isNaN2.w);\n  "+Tne+"\n  return result;\n"}),Oie={kernelName:gj,backendName:"webgl",kernelFunc:Fie};const Die={kernelName:yj,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{axis:o,keepDims:s}=a,i=r.shape.length,c=[],l=VU(o,r.shape);let u=l;const d=ZJ(u,i);let h,p=r;if(null!=d&&(p=oae({inputs:{x:r},backend:n,attrs:{perm:d}}),u=eZ(u.length,i),c.push(p)),JJ("prod",u,i),n.shouldExecuteOnCPU([p])){const e=n.texData.get(p.dataId).values,{outVals:t,outShape:a,outDtype:r}=Tte(p.shape,p.dtype,e,u);h=n.makeTensorInfo(a,r,t)}else{const[e,t]=YJ(p.shape,u),a=DU(t),o=Yne({inputs:{x:p},backend:n,attrs:{shape:[-1,a]}}),s=$ne(o,Tq(r.dtype),"prod",n);h=Yne({inputs:{x:s},backend:n,attrs:{shape:e}}),c.push(o),c.push(s)}if(s){c.push(h);const e=QJ(h.shape,l);h=Yne({inputs:{x:h},backend:n,attrs:{shape:e}})}return c.forEach((e=>n.disposeIntermediateTensorInfo(e))),h}};const Mie={kernelName:xj,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{paramsNestedSplits:r,paramsDenseValues:o,indices:s}=t,{outputRaggedRank:i}=a,c=r.map((e=>n.readSync(e.dataId))),l=r.map((e=>e.shape)),u=n.readSync(o.dataId),d=n.readSync(s.dataId),[h,p,f]=Ete(c,l,u,o.shape,o.dtype,d,s.shape,i),m=h.map((e=>n.makeTensorInfo([e.length],"int32",e))),g=n.makeTensorInfo(f,o.dtype,p);return m.concat([g])}};const Lie={kernelName:vj,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{starts:a,limits:r,deltas:o}=t,s=n.readSync(a.dataId),i=n.readSync(r.dataId),c=n.readSync(o.dataId),[l,u]=Rte(s,a.shape,a.dtype,i,r.shape,c,o.shape);return[n.makeTensorInfo([l.length],"int32",l),n.makeTensorInfo([u.length],a.dtype,u)]}};const Pie={kernelName:wj,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{shape:r,values:o,defaultValue:s,rowPartitionTensors:i}=t,{rowPartitionTypes:c}=a,l=n.readSync(r.dataId),u=n.readSync(o.dataId),d=n.readSync(s.dataId),h=i.map((e=>n.readSync(e.dataId))),p=i.map((e=>e.shape)),[f,m]=_te(l,r.shape,u,o.shape,o.dtype,d,s.shape,h,p,c);return n.makeTensorInfo(f,o.dtype,m)}},zie=e=>{const{backend:t,attrs:n}=e,{start:a,stop:r,step:o,dtype:s}=n,i=Ate(a,r,o,s);return t.makeTensorInfo([i.length],s,i)},Bie={kernelName:kj,backendName:"webgl",kernelFunc:zie},Wie=Wne({opSnippet:"return 1.0 / x;"}),Vie={kernelName:Sj,backendName:"webgl",kernelFunc:Wie},Uie=Wne({opSnippet:sne+"\n  return (x < 0.0) ? 0.0 : x;\n",packedOpSnippet:"\n  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n"}),Gie={kernelName:Nj,backendName:"webgl",kernelFunc:Uie},Hie=Wne({opSnippet:sne+"\n  return (x < 0.0) ? 0.0 : min(6.0, x);\n",packedOpSnippet:"\n  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n"}),jie={kernelName:Aj,backendName:"webgl",kernelFunc:Hie};class Kie{constructor(e,t,n,a,r){this.variableNames=["A"],this.outputShape=[];const[o,s,i,c]=e;this.outputShape=[o,t,n,c];const l=[a&&t>1?s-1:s,a&&n>1?i-1:i],u=[a&&t>1?t-1:t,a&&n>1?n-1:n];let d;d=r?"(vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC - vec2(0.5)":"vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode="\n      const vec2 effectiveInputOverOutputRatioRC = vec2(\n          ".concat(l[0]/u[0],",\n          ").concat(l[1]/u[1],");\n      const vec2 inputShapeRC = vec2(").concat(s,".0, ").concat(i,".0);\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        ivec2 yRC = coords.yz;\n\n        // Fractional source index.\n        vec2 sourceFracIndexRC = ").concat(d,";\n\n        // Compute the four integer indices.\n        ivec2 sourceFloorRC = ivec2(max(sourceFracIndexRC, vec2(0.0)));\n        ivec2 sourceCeilRC = ivec2(\n          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));\n\n        float topLeft = getA(b, sourceFloorRC.x, sourceFloorRC.y, d);\n        float bottomLeft = getA(b, sourceCeilRC.x, sourceFloorRC.y, d);\n        float topRight = getA(b, sourceFloorRC.x, sourceCeilRC.y, d);\n        float bottomRight = getA(b, sourceCeilRC.x, sourceCeilRC.y, d);\n\n        vec2 fracRC = sourceFracIndexRC - vec2(sourceFloorRC);\n\n        float top = topLeft + (topRight - topLeft) * fracRC.y;\n        float bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;\n        float newValue = top + (bottom - top) * fracRC.x;\n\n        setOutput(newValue);\n      }\n    ")}}class qie{constructor(e,t,n,a,r){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];const[o,s,i,c]=e;this.outputShape=[o,t,n,c];const l=[a&&t>1?s-1:s,a&&n>1?i-1:i],u=[a&&t>1?t-1:t,a&&n>1?n-1:n];let d;d=r?"(vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC - vec3(0.5)":"vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode="\n      const vec3 effectiveInputOverOutputRatioRC = vec3(\n          ".concat(l[0]/u[0],",\n          ").concat(l[1]/u[1],",\n          ").concat(l[1]/u[1],");\n      const vec3 inputShapeRC = vec3(").concat(s,".0, ").concat(i,".0,\n                                     ").concat(i,".0);\n\n      float getAValue(int b, int r, int c, int d) {\n        return getChannel(getA(b, r, c, d), vec2(c, d));\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        // Calculate values for next column in yRC.z.\n        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);\n\n        // Fractional source index.\n        vec3 sourceFracIndexRC = ").concat(d,";\n\n        // Compute the four integer indices.\n        ivec3 sourceFloorRC = ivec3(max(sourceFracIndexRC, vec3(0.0)));\n        ivec3 sourceCeilRC = ivec3(\n          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));\n\n        // Should we calculate next column and row elements in 2x2 packed cell.\n        bool hasNextCol = d < ").concat(c-1,";\n        bool hasNextRow = coords.z < ").concat(n-1,";\n\n        // In parallel, construct four corners for all four components in\n        // packed 2x2 cell.\n        vec4 topLeft = vec4(\n          getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d),\n          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d + 1) : 0.0);\n\n        vec4 bottomLeft = vec4(\n          getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d),\n          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d + 1) : 0.0);\n\n        vec4 topRight = vec4(\n          getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d),\n          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d + 1) : 0.0);\n\n        vec4 bottomRight = vec4(\n          getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d),\n          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d + 1) : 0.0);\n\n        vec3 fracRC = sourceFracIndexRC - vec3(sourceFloorRC);\n\n        vec4 top = mix(topLeft, topRight, fracRC.yyzz);\n        vec4 bottom = mix(bottomLeft, bottomRight, fracRC.yyzz);\n        vec4 newValue = mix(top, bottom, fracRC.x);\n\n        setOutput(newValue);\n      }\n    ")}}const Xie={kernelName:Rj,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{images:r}=t,{alignCorners:o,halfPixelCenters:s,size:i}=a,[c,l]=i,u=uG().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new qie(r.shape,c,l,o,s):new Kie(r.shape,c,l,o,s);return n.runWebGLProgram(u,[r],"float32")}};class Yie{constructor(e,t,n){this.variableNames=["dy"],this.outputShape=[],this.outputShape=t;const[,a,r]=t,[,o,s]=e,i=[n&&o>1?a-1:a,n&&s>1?r-1:r],c=[n&&o>1?o-1:o,n&&s>1?s-1:s],l=i[0]/c[0],u=i[1]/c[1],d=1/l,h=1/u,p=2*Math.ceil(d)+2,f=2*Math.ceil(h)+2;this.userCode="\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        int r = coords[1];\n        int c = coords[2];\n\n        float accumulator = 0.0;\n\n        const float heightScale = float(".concat(l,");\n        const float widthScale = float(").concat(u,");\n\n        const float invHeightScale = float(").concat(d,");\n        const float invWidthScale = float(").concat(h,");\n\n        const int winHeight = int(").concat(p,");\n        const int winWidth = int(").concat(f,");\n\n        // Compute bounds for where in dy we will look\n        float startRLerp = floor(float(r) * invHeightScale);\n        int startDyR = int(startRLerp - float(winHeight / 2));\n\n        float startCLerp = floor(float(c) * invWidthScale);\n        int startDyC = int(startCLerp - float(winWidth / 2));\n\n        // Loop over dy\n        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {\n          int dyR = dyROffset + startDyR;\n\n          // Guard against the window exceeding the bounds of dy\n          if (dyR < 0 || dyR >= ").concat(o,") {\n            continue;\n          }\n\n          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {\n            int dyC = dyCOffset + startDyC;\n\n            // Guard against the window exceeding the bounds of dy\n            if (dyC < 0 || dyC >= ").concat(s,") {\n              continue;\n            }\n\n            float dxR = float(dyR) * heightScale;\n            int topDxRIndex = int(floor(dxR));\n            int bottomDxRIndex = int(min(ceil(dxR), ").concat(a-1,".0));\n            float dxRLerp = dxR - float(topDxRIndex);\n            float inverseDxRLerp = 1.0 - dxRLerp;\n\n            float dxC = float(dyC) * widthScale;\n            int leftDxCIndex = int(floor(dxC));\n            int rightDxCIndex = int(min(ceil(dxC), ").concat(r-1,".0));\n            float dxCLerp = dxC - float(leftDxCIndex);\n            float inverseDxCLerp = 1.0 - dxCLerp;\n\n            if (r == topDxRIndex && c == leftDxCIndex) {\n              // topLeft\n              accumulator +=\n                getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;\n            }\n\n            if (r == topDxRIndex && c == rightDxCIndex) {\n              // topRight\n              accumulator += getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;\n            }\n\n            if (r == bottomDxRIndex && c == leftDxCIndex) {\n              // bottomLeft\n              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;\n            }\n\n            if (r == bottomDxRIndex && c == rightDxCIndex) {\n              // bottomRight\n              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;\n            }\n          }\n        }\n        // End loop over dy\n\n        setOutput(accumulator);\n      }\n    ")}}const Qie={kernelName:_j,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{images:r,dy:o}=t,{alignCorners:s}=a,i=new Yie(o.shape,r.shape,s);return n.runWebGLProgram(i,[o],o.dtype)}};class Jie{constructor(e,t,n,a,r){this.variableNames=["A"],this.outputShape=[];const[o,s,i,c]=e;this.outputShape=[o,t,n,c];const l=[a&&t>1?s-1:s,a&&n>1?i-1:i],u=[a&&t>1?t-1:t,a&&n>1?n-1:n],d=a?"0.5":"0.0";let h;h=r?"max((vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC, vec2(0.0))":"vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode="\n      const vec2 effectiveInputOverOutputRatioRC = vec2(\n          ".concat(l[0]/u[0],",\n          ").concat(l[1]/u[1],");\n      const vec2 inputShapeRC = vec2(").concat(s,".0, ").concat(i,".0);\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        ivec2 yRC = coords.yz;\n\n        // Fractional source index.\n        vec2 sourceFracIndexRC = ").concat(h,";\n\n        // Compute the coordinators of nearest neighbor point.\n        ivec2 sourceNearestRC = ivec2(\n          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ").concat(d,")));\n        float newValue = getA(b, sourceNearestRC.x, sourceNearestRC.y, d);\n\n        setOutput(newValue);\n      }\n    ")}}class Zie{constructor(e,t,n,a,r){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];const[o,s,i,c]=e;this.outputShape=[o,t,n,c];const l=[a&&t>1?s-1:s,a&&n>1?i-1:i],u=[a&&t>1?t-1:t,a&&n>1?n-1:n],d=a?"0.5":"0.0";let h;h=r?"max((vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC, vec3(0.0))":"vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode="\n      const vec3 effectiveInputOverOutputRatioRC = vec3(\n          ".concat(l[0]/u[0],",\n          ").concat(l[1]/u[1],",\n          ").concat(l[1]/u[1],");\n      const vec3 inputShapeRC = vec3(").concat(s,".0, ").concat(i,".0,\n                                     ").concat(i,".0);\n\n      float getAValue(int b, int r, int c, int d) {\n        return getChannel(getA(b, r, c, d), vec2(c, d));\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        // Calculate values for next column in yRC.z.\n        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);\n\n        // Fractional source index.\n        vec3 sourceFracIndexRC = ").concat(h,";\n\n        // Compute the coordinators of nearest neighbor point.\n        ivec3 sourceNearestRC = ivec3(\n          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ").concat(d,")));\n\n        // Should we calculate next column and row elements in 2x2 packed cell.\n        bool hasNextCol = d < ").concat(c-1,";\n        bool hasNextRow = coords.z < ").concat(n-1,";\n\n        vec4 newValue = vec4(\n          getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d),\n          hasNextCol ? getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d + 1) : 0.0);\n\n        setOutput(newValue);\n      }\n    ")}}const $ie={kernelName:Tj,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{images:r}=t,{alignCorners:o,halfPixelCenters:s,size:i}=a,[c,l]=i,u=uG().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new Zie(r.shape,c,l,o,s):new Jie(r.shape,c,l,o,s);return n.runWebGLProgram(u,[r],r.dtype)}};class ece{constructor(e,t,n){this.variableNames=["dy"],this.outputShape=[],this.outputShape=t;const[,a,r]=t,[,o,s]=e,i=[n&&o>1?a-1:a,n&&s>1?r-1:r],c=[n&&o>1?o-1:o,n&&s>1?s-1:s],l=i[0]/c[0],u=i[1]/c[1],d=1/l,h=1/u,p=2*Math.ceil(d)+2,f=2*Math.ceil(h)+2;this.userCode="\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        int r = coords[1];\n        int c = coords[2];\n\n        float accumulator = 0.0;\n\n        const float heightScale = float(".concat(l,");\n        const float widthScale = float(").concat(u,");\n\n        const float invHeightScale = float(").concat(d,");\n        const float invWidthScale = float(").concat(h,");\n\n        const int winHeight = int(").concat(p,");\n        const int winWidth = int(").concat(f,");\n\n        // Compute bounds for where in dy we will look\n        float startRLerp = floor(float(r) * invHeightScale);\n        int startDyR = int(floor(startRLerp - float(winHeight / 2)));\n\n        float startCLerp = floor(float(c) * invWidthScale);\n        int startDyC = int(floor(startCLerp - float(winWidth / 2)));\n\n        // Loop over dy\n        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {\n          int dyR = dyROffset + startDyR;\n\n          // Guard against the window exceeding the bounds of dy\n          if (dyR < 0 || dyR >= ").concat(o,") {\n            continue;\n          }\n\n          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {\n            int dyC = dyCOffset + startDyC;\n\n            // Guard against the window exceeding the bounds of dy\n            if (dyC < 0 || dyC >= ").concat(s,") {\n              continue;\n            }\n\n            float sourceFracRow =\n              float(").concat(i[0],") *\n                (float(dyR) / float(").concat(c[0],"));\n\n            float sourceFracCol =\n                float(").concat(i[1],") *\n                  (float(dyC) / float(").concat(c[1],"));\n\n            int sourceNearestRow = int(min(\n                float(int(").concat(a,") - 1),\n                ").concat(n," ? float(round(sourceFracRow)) :\n                                  float(floor(sourceFracRow))));\n\n            int sourceNearestCol = int(min(\n                float(int(").concat(r,") - 1),\n                ").concat(n," ? float(round(sourceFracCol)) :\n                                  float(floor(sourceFracCol))));\n\n            if (r == sourceNearestRow && c == sourceNearestCol) {\n              accumulator += getDy(b, dyR, dyC, d);\n            }\n          }\n        }\n        // End loop over dy\n\n        setOutput(accumulator);\n      }\n    ")}}const tce={kernelName:Ej,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{images:r,dy:o}=t,{alignCorners:s}=a,i=new ece(o.shape,r.shape,s);return n.runWebGLProgram(i,[o],o.dtype)}};class nce{constructor(e,t){this.variableNames=["x"];const n=e.length;if(n>4)throw new Error("WebGL backend: Reverse of rank-".concat(n," tensor is not yet supported"));if(this.outputShape=e,1===n)return void(this.userCode="\n        void main() {\n          int coord = getOutputCoords();\n          setOutput(getX(".concat(e[0]," - coord - 1));\n        }\n      "));const a=e.map(((n,a)=>(n=>-1!==t.indexOf(n)&&1!==e[n]?"".concat(e[n]," - coords[").concat(n,"] - 1"):"coords[".concat(n,"]"))(a))).join(","),r=_ee(n);this.userCode="\n      void main() {\n        ".concat(r," coords = getOutputCoords();\n        setOutput(getX(").concat(a,"));\n      }\n    ")}}class ace{constructor(e,t){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0;const n=e.length;if(n>4)throw new Error("WebGL backend: Reverse of rank-".concat(n," tensor is not yet supported"));this.outputShape=e;const a=Zte("rc",n),r="".concat(a[n-1]," + 1 < ").concat(this.outputShape[n-1]),o="".concat(a[n-2]," + 1 < ").concat(this.outputShape[n-2]),s=_ee(n);function i(n){const a=e.map(((a,r)=>function(n,a){return-1!==t.indexOf(n)&&1!==e[n]?"".concat(e[n]," - ").concat(a[n]," - 1"):"".concat(a[n])}(r,n))),r=a.join(","),o=a.slice(-2).join(",");return"getChannel(getX(".concat(r,"), vec2(").concat(o,"))")}this.userCode=1===n?"\n        void main(){\n          int rc = getOutputCoords();\n          vec4 result = vec4(0.);\n          result.r = getChannel(getX(".concat(e[0]," - rc - 1),\n            ").concat(e[0]," - rc - 1);\n          if(").concat(r,"){\n              result.g = getChannel(getX(").concat(e[0]," - (rc  + 1) - 1),\n                ").concat(e[0]," - (rc  + 1) - 1);\n          }\n          setOutput(result);\n        }\n      "):"\n        void main() {\n          ".concat(s," rc = getOutputCoords();\n          vec4 result = vec4(0.);\n          result.r = ").concat(function(e){return i(e)}(a.slice()),";\n          if(").concat(r,"){\n            result.g = ").concat(function(e){return e[n-1]="("+e[n-1]+" + 1)",i(e)}(a.slice()),";\n          }\n          if(").concat(o,") {\n            result.b = ").concat(function(e){return e[n-2]="("+e[n-2]+" + 1)",i(e)}(a.slice()),";\n            if(").concat(r,") {\n              result.a = ").concat(function(e){return e[n-1]="("+e[n-1]+" + 1)",e[n-2]="("+e[n-2]+" + 1)",i(e)}(a.slice()),";\n            }\n          }\n          setOutput(result);\n        }\n    ")}}const rce={kernelName:Fj,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{dims:o}=a,s=r.shape.length,i=VU(o,r.shape);if(0===s)return Rne({inputs:{x:r},backend:n});const c=uG().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new ace(r.shape,i):new nce(r.shape,i);return n.runWebGLProgram(c,[r],r.dtype)}};class oce{constructor(e,t){this.variableNames=["Image"],this.outputShape=[],this.customUniforms=[{name:"params",type:"vec4"}];const n=e[1],a=e[2];this.outputShape=e;let r="";r="number"===typeof t?"float outputValue = ".concat(t.toFixed(2),";"):"\n        vec3 fill = vec3(".concat(t.join(","),");\n        float outputValue = fill[coords[3]];"),this.userCode="\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int x = coords[2];\n          int y = coords[1];\n          float coordXFloat = (float(x) - params[0]) * params[3] -\n            (float(y) - params[1]) * params[2];\n          float coordYFloat = (float(x) - params[0]) * params[2] +\n            (float(y) - params[1]) * params[3];\n          int coordX = int(round(coordXFloat + params[0]));\n          int coordY = int(round(coordYFloat + params[1]));\n          ".concat(r,"\n          if(coordX >= 0 && coordX < ").concat(a," && coordY >= 0 && coordY < ").concat(n,") {\n            outputValue = getImage(coords[0], coordY, coordX, coords[3]);\n          }\n          setOutput(outputValue);\n        }\n    ")}}const sce={kernelName:kK,backendName:"webgl",kernelFunc:e=>{let{inputs:t,attrs:n,backend:a}=e;const{image:r}=t,{radians:o,fillValue:s,center:i}=n,c=a,l=new oce(r.shape,s),[u,d]=t2(i,r.shape[1],r.shape[2]),h=[[u,d,Math.sin(o),Math.cos(o)]];return c.runWebGLProgram(l,[r],r.dtype,h)}},ice=Wne({opSnippet:"\n  // OpenGL ES does not support round function.\n  // The algorithm is based on banker's rounding.\n  float base = floor(x);\n  if ((x - base) < 0.5) {\n    return floor(x);\n  } else if ((x - base) > 0.5) {\n    return ceil(x);\n  } else {\n    if (mod(base, 2.0) == 0.0) {\n      return base;\n    } else {\n      return base + 1.0;\n    }\n  }\n"}),cce={kernelName:Oj,backendName:"webgl",kernelFunc:ice},lce=Wne({opSnippet:"return inversesqrt(x);",cpuKernelImpl:Fte}),uce={kernelName:Dj,backendName:"webgl",kernelFunc:lce};class dce{constructor(e,t,n,a,r,o){let s=arguments.length>7&&void 0!==arguments[7]&&arguments[7];this.variableNames=["updates","indices","defaultValue"],this.outputShape=o;const i=_ee(r.length),c=_ee(o.length);let l="";1===n?l="i":2===n&&(l="i, j");const u="getIndices(".concat(l,")");let d="";1===a?d="i":2===a&&(d="i, coords[1]");const h="getUpdates(".concat(d,")");let p="";s&&(p="coords[0], coords[1]");const f="getDefaultValue(".concat(p,")"),m=t>1?"strides[j]":"strides";this.userCode="\n        ".concat(i," strides = ").concat(i,"(").concat(r,");\n\n        void main() {\n          ").concat(c," coords = getOutputCoords();\n          float sum = 0.0;\n          bool found = false;\n          for (int i = 0; i < ").concat(e,"; i++) {\n            int flattenedIndex = 0;\n            for (int j = 0; j < ").concat(t,"; j++) {\n              int index = round(").concat(u,");\n              flattenedIndex += index * ").concat(m,";\n            }\n            if (flattenedIndex == coords[0]) {\n              sum += ").concat(h,";\n              found = true;\n            }\n          }\n          setOutput(mix(").concat(f,", sum, float(found)));\n        }\n      ")}}class hce{constructor(e,t,n,a,r,o){let s=arguments.length>7&&void 0!==arguments[7]&&arguments[7];this.variableNames=["updates","indices","defaultValue"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=o;const i=_ee(r.length),c=_ee(o.length);let l="";1===n?l="i":2===n&&(l="i, j");const u="getIndices(".concat(l,")");let d="";1===a?d="i":2===a&&(d="i, coords[1]");const h="getUpdates(".concat(d,")");let p="";s&&(p="coords[0], coords[1]");const f="getDefaultValue(".concat(p,")"),m=t>1?"strides[j]":"strides",g=t>1?"strides[j + 1]":"strides";this.userCode="\n        ".concat(i," strides = ").concat(i,"(").concat(r,");\n\n        void main() {\n          ").concat(c," coords = getOutputCoords();\n          vec4 sum = vec4(0.);\n          vec4 found = vec4(0.);\n          for (int i = 0; i < ").concat(e,"; i+=2) {\n            ivec2 flattenedIndex = ivec2(0);\n            for (int j = 0; j < ").concat(t,"; j+=2) {\n              ivec4 index = round(").concat(u,");\n              flattenedIndex += index.xz * ").concat(m,";\n              if (j + 1 < ").concat(t,") {\n                flattenedIndex += index.yw * ").concat(g,";\n              }\n            }\n            if (flattenedIndex[0] == coords[0] || flattenedIndex[1] == coords[0] ||\n                flattenedIndex[0] == coords[0] + 1 || flattenedIndex[1] == coords[0] + 1) {\n              vec4 updVals = ").concat(h,";\n              if (flattenedIndex[0] == coords[0]) {\n                sum.xy += updVals.xy;\n                found.xy = vec2(1.);\n              } else if (flattenedIndex[0] == coords[0] + 1) {\n                sum.zw += updVals.xy;\n                found.zw = vec2(1.);\n              }\n              if (flattenedIndex[1] == coords[0]) {\n                sum.xy += updVals.zw;\n                found.xy = vec2(1.);\n              } else if (flattenedIndex[1] == coords[0] + 1) {\n                sum.zw += updVals.zw;\n                found.zw = vec2(1.);\n              }\n            }\n          }\n          setOutput(mix(").concat(f,", sum, found));\n        }\n      ")}}const pce={kernelName:Mj,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{indices:r,updates:o}=t,{shape:s}=a,{sliceRank:i,numUpdates:c,sliceSize:l,strides:u,outputSize:d}=u0(0,r,s),h=[d/l,l];if(0===d)return n.makeTensorInfo(s,r.dtype);const p=Yne({inputs:{x:r},backend:n,attrs:{shape:[c,i]}}),f=Yne({inputs:{x:o},backend:n,attrs:{shape:[c,l]}}),m=n.makeTensorInfo([],"float32",new Float32Array([0]));let g;g=uG().getBool("WEBGL_PACK")?new hce(c,i,p.shape.length,f.shape.length,u,h):new dce(c,i,p.shape.length,f.shape.length,u,h);const b=n.runWebGLProgram(g,[f,p,m],f.dtype),y=Yne({inputs:{x:b},backend:n,attrs:{shape:s}});return n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(b),n.disposeIntermediateTensorInfo(m),y}};class fce{constructor(e,t,n,a){this.variableNames=["sortedSequence","values"],this.customUniforms=[{name:"numInputs",type:"int"}],this.outputShape=[e,n];const r="for (int i = 0; i < ".concat(Math.ceil(Math.log2(t+1)),"; ++i) { if (left >= right) break;"),o=2===uG().getNumber("WEBGL_VERSION")?"while (left < right) {":r,s="left"===a?"<":"<=";this.userCode="\n       int findBound(int batch, float value) {\n         int left = 0;\n         int right = numInputs;\n         int mid;\n         ".concat(o,"\n           mid = (left + right) / 2;\n           if (getSortedSequence(batch, mid) ").concat(s," value) {\n             left = mid + 1;\n           } else {\n             right = mid;\n           }\n         }\n         return right;\n       }\n\n       void main() {\n         ivec2 coords = getOutputCoords();\n         int batch = coords[0];\n         int valueIndex = coords[1];\n\n         float value = getValues(batch, valueIndex);\n\n         setOutput(float(findBound(batch, value)));\n       }\n     ")}}const mce={kernelName:Pj,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{sortedSequence:r,values:o}=t,{side:s}=a,i=new fce(r.shape[0],r.shape[1],o.shape[1],s),c=[[r.shape[1]]];return n.runWebGLProgram(i,[r,o],"int32",c)}};class gce{constructor(e,t,n){let a,r;if(this.variableNames=["c","a","b"],this.outputShape=t,n>4)throw Error("Where for rank ".concat(n," is not yet supported"));if(1===n)r="resRC",a="resRC";else{const n=["resRC.x","resRC.y","resRC.z","resRC.w"],o=[],s=[];for(let a=0;a<t.length;a++)s.push("".concat(n[a])),a<e&&o.push("".concat(n[a]));a=o.join(),r=s.join()}const o=_ee(n);this.userCode="\n      void main() {\n        ".concat(o," resRC = getOutputCoords();\n        float cVal = getC(").concat(a,");\n        if (cVal >= 1.0) {\n          setOutput(getA(").concat(r,"));\n        } else {\n          setOutput(getB(").concat(r,"));\n        }\n      }\n    ")}}const bce={kernelName:zj,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{condition:a,t:r,e:o}=t,s=new gce(a.shape.length,r.shape,r.shape.length);return n.runWebGLProgram(s,[a,r,o],Cq(r.dtype,o.dtype))}},yce=Wne({opSnippet:"\n  // Stable and Attracting Fixed Point (0, 1) for Normalized Weights.\n  // see: https://arxiv.org/abs/1706.02515\n  float scaleAlpha = ".concat(c2,";\n  float scale = ").concat(l2,";\n  return (x >= 0.0) ? scale * x : scaleAlpha * (exp(x) - 1.0);\n")}),xce={kernelName:Bj,backendName:"webgl",kernelFunc:yce},vce=Wne({opSnippet:Bne+"\n  return 1.0 / (1.0 + exp(-1.0 * x));\n",packedOpSnippet:"\n  vec4 result = 1.0 / (1.0 + exp(-1.0 * x));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n",cpuKernelImpl:Dte}),wce={kernelName:Hj,backendName:"webgl",kernelFunc:vce},kce=Wne({opSnippet:"\n  if (isnan(x)) { return 0.0; }\n  return sign(x);\n"}),Ice={kernelName:Gj,backendName:"webgl",kernelFunc:kce},Sce=Wne({opSnippet:Bne+"\n  return sin(x);\n",packedOpSnippet:"\n  vec4 result = sin(x);\n  bvec4 isNaN = isnan(x);\n  ".concat(Tne,"\n  return result;\n")}),Nce={kernelName:Vj,backendName:"webgl",kernelFunc:Sce},Cce=Wne({opSnippet:"\n  float e2x = exp(x);\n  return (e2x - 1.0 / e2x) / 2.0;\n"}),Tce={kernelName:Uj,backendName:"webgl",kernelFunc:Cce},Ece=Wne({opSnippet:"\n  float epsilon = 1.1920928955078125e-7;\n  float threshold = log(epsilon) + 2.0;\n\n  bool too_large = x > -threshold;\n  bool too_small = x < threshold;\n\n  float result;\n  float exp_x = exp(x);\n\n  if (too_large){\n    result = x;\n  }\n  else if (too_small){\n    result = exp_x;\n  }\n  else{\n    result = log(exp_x + 1.0);\n  }\n  return result;\n"}),Rce={kernelName:jj,backendName:"webgl",kernelFunc:Ece},_ce={kernelName:Xj,backendName:"webgl",kernelFunc:e=>{const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{blockShape:o,paddings:s}=a;AU(r.shape.length<=4,(()=>"spaceToBatchND for rank > 4 with a WebGL backend not implemented yet"));const i=o.reduce(((e,t)=>e*t)),c=[[0,0]];c.push(...s);for(let b=1+o.length;b<r.shape.length;++b)c.push([0,0]);const l=[],u=_ie({inputs:{x:r},backend:n,attrs:{paddings:c,constantValue:0}}),d=n2(u.shape,o,i,!1),h=a2(d.length,o.length,!1),p=r2(u.shape,o,i,!1),f=Yne({inputs:{x:u},backend:n,attrs:{shape:d}}),m=oae({inputs:{x:f},backend:n,attrs:{perm:h}}),g=Yne({inputs:{x:m},backend:n,attrs:{shape:p}});return l.push(u),l.push(f),l.push(m),l.forEach((e=>n.disposeIntermediateTensorInfo(e))),g}};const Ace={kernelName:Jj,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{indices:a,values:r,denseShape:o,defaultValue:s}=t;if(1!==o.shape.length)throw new Error("Dense shape must be a vector, saw:\n         ".concat(o.shape));if(2!==a.shape.length)throw new Error("Indices must be a matrix, saw:\n         ".concat(a.shape));if(1!==r.shape.length)throw new Error("Values must be a vector, saw:\n         ".concat(r.shape));if(0!==s.shape.length)throw new Error("Default value must be a scalar, saw:\n        ".concat(s.shape));const i=n.readSync(a.dataId),c=n.readSync(r.dataId),l=n.readSync(o.dataId),u=n.readSync(s.dataId)[0],[d,h,p,f,m]=Pte(i,a.shape,a.dtype,c,r.dtype,l,u);return[n.makeTensorInfo(h,a.dtype,d),n.makeTensorInfo([h[0]],r.dtype,p),n.makeTensorInfo([f.length],"bool",new Uint8Array(f.map((e=>Number(e))))),n.makeTensorInfo([m.length],a.dtype,new Int32Array(m))]}};const Fce={kernelName:Zj,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{inputIndices:a,inputShape:r,newShape:o}=t;if(2!==a.shape.length)throw new Error("Input indices should be a matrix but received shape ".concat(a.shape));if(1!==r.shape.length)throw new Error("Input shape should be a vector but received shape ".concat(r.shape));if(1!==o.shape.length)throw new Error("Target shape should be a vector but received shape ".concat(o.shape));const s=Array.from(n.readSync(r.dataId)),i=n.readSync(a.dataId),c=Array.from(n.readSync(o.dataId)),[l,u,d]=zte(i,a.shape,a.dtype,s,c);return[n.makeTensorInfo(u,a.dtype,l),n.makeTensorInfo([d.length],o.dtype,new Int32Array(d))]}};const Oce={kernelName:$j,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{data:a,indices:r,segmentIds:o}=t;if(a.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==r.shape.length)throw new Error("Indices should be a vector but received shape\n              ".concat(r.shape));if(1!==o.shape.length)throw new Error("Segment ids should be a vector but received shape\n              ".concat(o.shape));const s=n.readSync(a.dataId),i=n.readSync(r.dataId),c=n.readSync(o.dataId),[l,u]=Bte(s,a.shape,a.dtype,i,c,!0);return n.makeTensorInfo(u,a.dtype,l)}};const Dce={kernelName:eK,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{data:a,indices:r,segmentIds:o}=t;if(a.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==r.shape.length)throw new Error("Indices should be a vector but received shape\n             ".concat(r.shape));if(1!==o.shape.length)throw new Error("Segment ids should be a vector but received shape\n             ".concat(o.shape));const s=n.readSync(a.dataId),i=n.readSync(r.dataId),c=n.readSync(o.dataId),[l,u]=Bte(s,a.shape,a.dtype,i,c);return n.makeTensorInfo(u,a.dtype,l)}};const Mce={kernelName:tK,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{sparseIndices:r,sparseValues:o,defaultValue:s}=t,{outputShape:i}=a,{sliceRank:c,numUpdates:l,sliceSize:u,strides:d,outputSize:h}=u0(0,r,i),p=!1;if("string"===o.dtype){const e=n.bufferSync(r),t=n.bufferSync(o),a=$K(n.readSync(s.dataId)[0]),f=Ote(e,t,i,h,u,l,c,d,a,p);return n.makeTensorInfo(i,f.dtype,f.values)}const f=new dce(l,c,r.shape.length,o.shape.length,d,[h,1],p),m=n.runWebGLProgram(f,[o,r,s],o.dtype),g=Yne({inputs:{x:m},backend:n,attrs:{shape:i}});return n.disposeIntermediateTensorInfo(m),g}};const Lce={kernelName:Yj,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{numOrSizeSplits:o,axis:s}=a,i=VU(s,r.shape)[0],c=D2(r,o,i),l=r.shape.length,u=new Array(l).fill(0),d=r.shape.slice();return c.map((e=>{const t=[...d];t[i]=e;const a=nre({inputs:{x:r},backend:n,attrs:{begin:u,size:t}});return u[i]+=e,a}))}},Pce="return sqrt(x);",zce=Wne({opSnippet:Pce,packedOpSnippet:Pce,cpuKernelImpl:Wte}),Bce={kernelName:Kj,backendName:"webgl",kernelFunc:zce},Wce={kernelName:aK,backendName:"webgl",kernelFunc:Wne({opSnippet:"return x * x;"})},Vce="return (a - b) * (a - b);",Uce=Vne({opSnippet:Vce,packedOpSnippet:Vce}),Gce={kernelName:nK,backendName:"webgl",kernelFunc:Uce};const Hce={kernelName:rK,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t;if("string"!==r.dtype)throw new Error("Input must be of datatype string");const o=Q2(n.readSync(r.dataId)),s=Vte(o,"string",a);return n.makeTensorInfo(r.shape,"string",s)}};const jce={kernelName:vK,backendName:"webgl",kernelFunc:function(e){let{inputs:t,attrs:n,backend:a}=e;const{x:r}=t,o=sne+"\n    return x > 0.0 ? 1.0 : float(".concat(n.alpha,");\n  "),s=new one(r.shape,o);return a.runWebGLProgram(s,[r],r.dtype)}};class Kce{constructor(e,t,n){this.variableNames=["x"],this.outputShape=n;const a=n.length,r=_ee(n.length),o=_ee(n.length);let s="";if(1===a)s="coords * strides + begin";else{let e=0;s=n.map(((t,a)=>(e++,1===n.length?"coords * strides[".concat(a,"] + begin[").concat(a,"]"):"coords[".concat(e-1,"] * strides[").concat(a,"] + begin[").concat(a,"]")))).join(",")}this.userCode="\n      ".concat(r," begin = ").concat(r,"(").concat(e,");\n      ").concat(r," strides = ").concat(r,"(").concat(t,");\n\n      void main() {\n        ").concat(o," coords = getOutputCoords();\n        setOutput(getX(").concat(s,"));\n      }\n    ")}}const qce={kernelName:oK,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{begin:o,end:s,strides:i,beginMask:c,endMask:l,ellipsisMask:u,newAxisMask:d,shrinkAxisMask:h}=a,{finalShapeSparse:p,finalShape:f,isIdentity:m,sliceDim0:g,isSimpleSlice:b,begin:y,end:x,strides:v}=SQ(r.shape,o,s,i,c,l,u,d,h);let w;if(m)w=Yne({inputs:{x:r},backend:n,attrs:{shape:f}});else if(g||b){AU(r.shape.length>=1,(()=>"Input must have rank at least 1, got: ".concat(r.shape.length)));const e=dQ(y,x,v),t=nre({inputs:{x:r},backend:n,attrs:{begin:y,size:e}});w=Yne({inputs:{x:t},backend:n,attrs:{shape:f}}),n.disposeIntermediateTensorInfo(t)}else{if(n.shouldExecuteOnCPU([r])){const e=n.readSync(r.dataId),t=cY(r.shape,r.dtype,e),a=Ute(p,t,v,y);w=n.makeTensorInfo(f,r.dtype,a.values)}else{const e=new Kce(y,v,p);w=n.runWebGLProgram(e,[r],r.dtype)}}const k=Yne({inputs:{x:w},backend:n,attrs:{shape:f}});return n.disposeIntermediateTensorInfo(w),k}};const Xce={kernelName:sK,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{separator:r,nGramWidths:o,leftPad:s,rightPad:i,padWidth:c,preserveShortSequences:l}=a,{data:u,dataSplits:d}=t,h=n.readSync(u.dataId),p=n.readSync(d.dataId),[f,m]=Gte(h,p,r,o,s,i,c,l);return[n.makeTensorInfo([f.length],"string",f),n.makeTensorInfo(d.shape,"int32",m)]}};const Yce={kernelName:iK,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{skipEmpty:r}=a,{input:o,delimiter:s}=t;if("string"!==o.dtype)throw new Error("Input must be of datatype string");if(1!==o.shape.length)throw new Error("Input must be a vector, got shape: ".concat(o.shape));if(0!==s.shape.length)throw new Error("Delimiter must be a scalar, got shape: ".concat(s.shape));const i=n.readSync(o.dataId),c=n.readSync(s.dataId)[0],[l,u,d]=Hte(i,c,r),h=u.length;return[n.makeTensorInfo([h,2],"int32",l),n.makeTensorInfo([h],"string",u),n.makeTensorInfo([2],"int32",new Int32Array(d))]}};const Qce={kernelName:cK,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{numBuckets:r}=a,{input:o}=t;if("string"!==o.dtype)throw new Error("Input must be of datatype string");if(r<=0)throw new Error("Number of buckets must be at least 1");const s=n.readSync(o.dataId),i=jte(s,r);return n.makeTensorInfo(o.shape,"int32",i)}},Jce=Wne({opSnippet:"return tan(x);"}),Zce={kernelName:uK,backendName:"webgl",kernelFunc:Jce},$ce=Wne({opSnippet:"\n  float e2x = exp(-2.0 * abs(x));\n  return sign(x) * (1.0 - e2x) / (1.0 + e2x);\n"}),ele={kernelName:dK,backendName:"webgl",kernelFunc:$ce};const tle={kernelName:Lj,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{tensor:r,indices:o,updates:s}=t,{}=a,{sliceRank:i,numUpdates:c,sliceSize:l,strides:u,outputSize:d}=u0(0,o,r.shape),h=[d/l,l];if(0===d)return n.makeTensorInfo(r.shape,o.dtype);const p=Yne({inputs:{x:o},backend:n,attrs:{shape:[c,i]}}),f=Yne({inputs:{x:s},backend:n,attrs:{shape:[c,l]}}),m=Yne({inputs:{x:r},backend:n,attrs:{shape:h}}),g=new dce(c,i,p.shape.length,f.shape.length,u,h,!1,!0),b=n.runWebGLProgram(g,[f,p,m],m.dtype),y=Yne({inputs:{x:b},backend:n,attrs:{shape:r.shape}});return n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),n.disposeIntermediateTensorInfo(b),y}};class nle{constructor(e,t){this.variableNames=["A"];const n=new Array(e.length);for(let o=0;o<n.length;o++)n[o]=e[o]*t[o];this.outputShape=n,this.rank=n.length;const a=_ee(this.rank),r=function(e){const t=e.length;if(t>5)throw Error("Tile for rank ".concat(t," is not yet supported"));if(1===t)return"imod(resRC, ".concat(e[0],")");const n=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u"],a=[];for(let r=0;r<e.length;r++)a.push("imod(".concat(n[r],", ").concat(e[r],")"));return a.join()}(e);this.userCode="\n      void main() {\n        ".concat(a," resRC = getOutputCoords();\n        setOutput(getA(").concat(r,"));\n      }\n    ")}}function ale(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{reps:o}=a;if("string"===r.dtype||r.shape.length>5){const e=n.readSync(r.dataId),t="string"===r.dtype?e.map((e=>$K(e))):e,a=cY(r.shape,r.dtype,t),s=qte(a,o);return n.makeTensorInfo(s.shape,s.dtype,s.values)}const s=new nle(r.shape,o);return n.runWebGLProgram(s,[r],r.dtype)}const rle={kernelName:hK,backendName:"webgl",kernelFunc:ale};class ole{constructor(e){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"negativeInf",type:"float"},{name:"dir",type:"int"},{name:"inc",type:"int"}],this.outputShape=e,this.userCode="\n       void main() {\n         ivec2 coords = getOutputCoords();\n         int batch = coords[0];\n         int elemIdx = coords[1];\n\n         // We compare elements pair-wise within a group of size 2 * inc.\n         // The comparing rule for each group alternates between ascending\n         // and descending. Within each group, we compare each pair at\n         // positions i and i+inc. To decide whether an element at position i\n         // is x0 or x1, we mod it by 2 * inc, if the result is smaller than\n         // inc, it is in the first half of the group, we denote it as x0,\n         // otherwise we denote it as x1.\n         // For example, as shown in the Bitonic top K paper referenced above,\n         // Figure5(a) shows that element[1] is in the\n         // second half of the group when group size is 2, but it is in the\n         // first half of the group when group size is 4.\n\n         bool isFirstInPair = imod(elemIdx, 2 * inc) < inc;\n         int i = isFirstInPair ? elemIdx : elemIdx - inc;\n\n         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));\n         int i1 = firstPass == 1 ? i + inc : int(getIndices(batch, i + inc));\n         float x0 = i0 < n ? getX(batch, i0) : negativeInf;\n         float x1 = i1 < n ? getX(batch, i1) : negativeInf;\n\n         // Denotes which direction indices are in (ascending or descending).\n         bool reverse = imod(elemIdx, 2 * dir) >= dir;\n         bool isGreater = x0 > x1 || (x0 == x1 && i1 > i0);\n         if (reverse == isGreater) { // Elements in opposite order of direction\n           int iTemp = i0;\n           i0 = i1;\n           i1 = iTemp;\n         }\n         if (isFirstInPair) {\n            setOutput(float(i0));\n         } else {\n            setOutput(float(i1));\n         }\n       }\n     "}}class sle{constructor(e){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"k",type:"int"}],this.outputShape=e,this.userCode="\n    void main() {\n         // Takes max of indices (0, k), (1, k + 1), (2, k + 2) ...\n         ivec2 coords = getOutputCoords();\n         int batch = coords[0];\n         int elemIdx = coords[1];\n\n         // The output size is half of the previous size.\n         // If the previous sequence is | | | | _ _ _ _  | | | |  _ _ _ _ (k=4),\n         // we only need to output the indices at positions |, the indices at\n         // positions _ can be thrown away, see Figure5(b) After Phase 2\n         // (Merge phase) in the Bitonic Top K paper referenced above.\n         // For example, the paper shows we only need to output the orange bars.\n         // The output sequence should look like this | | | | | | | |.\n         // Because the sequence is halved, to map the output index back\n         // to the previous sequence to find the corresponding value,\n         // we need to double the index. When we double the index,\n         // we basically interpolate a position, so 2i looks like\n         // | _ | _ | _ | _ | _ | _ | _. We move the | to the first k position\n         // of each 2k positions by - elemIdx % k. E.g. for output at\n         // index 4,5,6,7, we want to get the corresponding element at\n         // original index 8,9,10,11, for output at index 8,9,10,11,\n         // we want to get the corresponding element at original index\n         // 16,17,18,19, so on and so forth.\n\n         int i = elemIdx < k ? elemIdx : (elemIdx * 2 - imod(elemIdx, k));\n         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));\n         int i1 = firstPass == 1 ? i + k : int(getIndices(batch, i + k));\n\n         float x0 = getX(batch, i0);\n         float x1 = i1 < n ? getX(batch, i1) : x0;\n\n         setOutput(x0 >= x1 ? float(i0) : float(i1));\n       }\n     "}}function ile(e,t){null!==t&&e.disposeIntermediateTensorInfo(t)}function cle(e){let t=1;for(;t<e;)t*=2;return t}const lle={kernelName:pK,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{k:o,sorted:s}=a,i=uG().getNumber("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD"),c=uG().getNumber("TOPK_K_CPU_HANDOFF_THRESHOLD"),l=r.shape,u=l[l.length-1];if(n.shouldExecuteOnCPU([r])||u<i||o>c){const e=n.readSync(r.dataId),[t,a]=Xte(e,l,r.dtype,o,s);return[n.makeTensorInfo(t.shape,t.dtype,t.values),n.makeTensorInfo(a.shape,a.dtype,a.values)]}if(0===o)return l[l.length-1]=0,[n.makeTensorInfo(l,r.dtype,[]),n.makeTensorInfo(l,"int32",[])];if(1===u)return[r,Voe({attrs:{shape:l,dtype:"int32",value:0},backend:n})];const d=n.texData.get(r.dataId),h=null!==d&&d.isPacked,p=h?n.unpackTensor(r):r,f=DU(l)/u,m=Yne({inputs:{x:p},attrs:{shape:[f,u]},backend:n});h&&ile(n,p);const g=cle(o),b=cle(u);let y=null;const x=()=>null===y?[m,m]:[m,y],v=(e,t,a)=>{const r=x(),o=new ole(a),s=[[u],[null===y?1:0],[Number.NEGATIVE_INFINITY],[e],[t]],i=y;y=n.runWebGLProgram(o,r,"int32",s),ile(n,i)};for(let N=1;N<g;N*=2){const e=2*N;for(let t=N;t>=1;t/=2)v(e,t,[f,b])}for(let N=b;N>g;N/=2){const e=x(),t=new sle([f,N/2]),a=[[u],[null===y?1:0],[g]],r=y;y=n.runWebGLProgram(t,e,"int32",a),ile(n,r);const o=g/2,s=2*o;for(let n=o;n>=1;n/=2)v(s,n,y.shape)}let w=y;y=nre({inputs:{x:y},backend:n,attrs:{begin:0,size:[f,o]}}),ile(n,w);let k=sse({inputs:{x:m,indices:y},backend:n,attrs:{axis:1,batchDims:1}});ile(n,m);const I=l.slice(0,-1);I.push(o),w=y,y=Yne({inputs:{x:y},attrs:{shape:I},backend:n}),ile(n,w);const S=k;return k=Yne({inputs:{x:k},attrs:{shape:I},backend:n}),ile(n,S),[k,y]}};class ule{constructor(e,t,n,a,r,o){this.variableNames=["Image","Transforms"],this.outputShape=o;const s="nearest"===n?1:2;let i;switch(a){case"constant":default:i=1;break;case"reflect":i=2;break;case"wrap":i=3;break;case"nearest":i=4}this.userCode="\n            float mapCoord(float outCoord, float len) {\n              float inCoord = outCoord;\n              if(".concat(i," == 2) {\n                if (inCoord < 0.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz2 = 2.0 * len;\n                    if (inCoord < sz2) {\n                      inCoord = sz2 * float(int(float(-inCoord / sz2))) +\n                      inCoord;\n                    }\n                    inCoord = inCoord < -len ? inCoord + sz2 : -inCoord - 1.0;\n                  }\n                } else if (inCoord > len - 1.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz2 = 2.0 * len;\n                    inCoord -= sz2 * float(int(float(inCoord / sz2)));\n                    if (inCoord >= len) {\n                      inCoord = sz2 - inCoord - 1.0;\n                    }\n                  }\n                }\n                return clamp(inCoord, 0.0, len - 1.0);\n              } else if (").concat(i," == 3) {\n                if (inCoord < 0.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz = len - 1.0;\n                    inCoord += len * (float(int(float(-inCoord / sz))) + 1.0);\n                  }\n                } else if (inCoord > len - 1.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz = len - 1.0;\n                    inCoord -= len * float(int(float(inCoord / sz)));\n                  }\n                }\n                return clamp(inCoord, 0.0, len - 1.0);\n              } else if (").concat(i," == 4) {\n                return clamp(outCoord, 0.0, len - 1.0);\n              } else {\n                return outCoord;\n              }\n            }\n\n            float readWithFillValue(int batch, int coordY, int coordX,\n              int channel) {\n              float outputValue;\n              if (0 <= coordY && coordY < ").concat(e," && 0 <= coordX && coordX < ").concat(t,") {\n                  outputValue = getImage(batch, coordY, coordX, channel);\n              } else {\n                outputValue = float(").concat(r,");\n              }\n              return outputValue;\n            }\n\n            void main() {\n              ivec4 coords = getOutputCoords();\n              float outputValue;\n              int batch = coords[0];\n              int x = coords[2];\n              int y = coords[1];\n              int channel = coords[3];\n              float xf = float(x);\n              float yf = float(y);\n              float a1 = getTransforms(batch, 0);\n              float a2 = getTransforms(batch, 1);\n              float a3 = getTransforms(batch, 2);\n              float b1 = getTransforms(batch, 3);\n              float b2 = getTransforms(batch, 4);\n              float b3 = getTransforms(batch, 5);\n              float c1 = getTransforms(batch, 6);\n              float c2 = getTransforms(batch, 7);\n              float projection = c1 * xf + c2 * yf + 1.0;\n              if (projection == 0.0) {\n                outputValue = float(").concat(r,");\n              } else {\n                float inX = (a1 * xf + a2 * yf + a3) / projection;\n                float inY = (b1 * xf + b2 * yf + b3) / projection;\n                float mapX = mapCoord(inX, float(").concat(t,"));\n                float mapY = mapCoord(inY, float(").concat(e,"));\n\n                if (").concat(s," == 1) {\n                  int coordY = int(round(mapY));\n                  int coordX = int(round(mapX));\n                  outputValue = readWithFillValue(batch, coordY, coordX,\n                    channel);\n                } else {\n                  float yFloor = floor(mapY);\n                  float xFloor = floor(mapX);\n                  float yCeil = yFloor + 1.0;\n                  float xCeil = xFloor + 1.0;\n                  float valueYFloor = (xCeil - mapX) *\n                  readWithFillValue(batch, int(yFloor), int(xFloor), channel) +\n                  (mapX - xFloor) *\n                  readWithFillValue(batch, int(yFloor), int(xCeil), channel);\n                  float valueYCeil = (xCeil - mapX) *\n                  readWithFillValue(batch, int(yCeil), int(xFloor), channel) +\n                  (mapX - xFloor) *\n                  readWithFillValue(batch, int(yCeil), int(xCeil), channel);\n                  outputValue = (yCeil - mapY) * valueYFloor +\n                  (mapY - yFloor) * valueYCeil;\n                }\n              }\n              setOutput(outputValue);\n            }\n        ")}}const dle={kernelName:fK,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{image:r,transforms:o}=t,{interpolation:s,fillMode:i,fillValue:c,outputShape:l}=a,[u,d,h,p]=r.shape,[f,m]=null!=l?l:[d,h],g=new ule(d,h,s,i,c,[u,f,m,p]);return n.runWebGLProgram(g,[r,o],"float32")}};const hle={kernelName:gK,backendName:"webgl",kernelFunc:function(e){const{inputs:t,attrs:n,backend:a}=e,{axis:r}=n,{x:o}=t;hee(o,"unique"),console.warn("WARNING: ","UI might be locked temporarily as data is being downloaded");const s=a.readSync(o.dataId),{outputValues:i,outputShape:c,indices:l}=Qte(s,r,o.shape,o.dtype);return[a.makeTensorInfo(c,o.dtype,i),a.makeTensorInfo([l.length],"int32",l)]}};const ple={kernelName:bK,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{value:r}=t;let{axis:o}=a;o<0&&(o+=r.shape.length);const s=r,i=s.shape.length,c=r.shape[o],l=new Array(i-1);let u=0;for(let m=0;m<i;m++)m!==o&&(l[u++]=s.shape[m]);const d=[],h=new Array(i).fill(0),p=s.shape.slice();p[o]=1;const f=new Array(c);for(let m=0;m<f.length;m++){h[o]=m;const e=nre({inputs:{x:s},backend:n,attrs:{begin:h,size:p}}),t=Yne({inputs:{x:e},backend:n,attrs:{shape:l}});f[m]=t,d.push(e)}return d.forEach((e=>n.disposeIntermediateTensorInfo(e))),f}};class fle{constructor(e,t){this.variableNames=["x","segmentIds"];const n=e.windowSize,a=e.batchSize,r=e.inSize,o=e.numSegments,s=o*Math.ceil(r/n);this.outputShape=[a,s];const i=4*Math.floor(n/4),c=n%4,l="\n        sumValue += dot(values, segFilter);\n    ";let u="";r%n>0&&(u="\n        if (inIdx < 0 || inIdx >= ".concat(r,") {\n          return initializationValue;\n        }\n      "));let d="";r%n>0&&(d="\n        if (inIdx < 0 || inIdx >= ".concat(r,") {\n          return -1.0;\n        }\n      ")),this.userCode="\n      const float initializationValue = ".concat("0.0",";\n\n      float getValue(int batch, int inIdx) {\n        ").concat(u,"\n        return getX(batch, inIdx);\n      }\n\n      float getSegmentIdAtIndex(int inIdx) {\n        ").concat(d,"\n        return getSegmentIds(inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = int(floor(float(outIdx) / float(\n          ").concat(o,")) * float(").concat(n,"));\n        int currentSeg = int(mod(float(outIdx), float(").concat(o,")));\n\n        float sumValue = 0.0;\n\n        for (int i = 0; i < ").concat(i,"; i += 4) {\n          int inIdx = inOffset + i;\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 3)) == currentSeg ? 1 : 0\n          );\n\n          ").concat(l,"\n        }\n\n        int inIdx = inOffset + ").concat(i,";\n        if (").concat(1===c,") {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            initializationValue,\n            initializationValue,\n            initializationValue\n          );\n\n          int inIdxSeg = int(getSegmentIdAtIndex(inIdx));\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            0,\n            0,\n            0\n          );\n\n          ").concat(l,"\n        } else if (").concat(2===c,") {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            initializationValue,\n            initializationValue\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n              0,\n              0\n          );\n\n          ").concat(l,"\n        } else if (").concat(3===c,") {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            initializationValue\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,\n            0\n          );\n\n          ").concat(l,"\n        }\n        setOutput(").concat("sumValue",");\n      }\n    ")}}const mle={kernelName:yK,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r,segmentIds:o}=t,{numSegments:s}=a,i=r.shape.length,c=[];let l=0;const u=ZJ([l],i);let d=r;null!=u&&(d=oae({inputs:{x:r},backend:n,attrs:{perm:u}}),c.push(d),l=eZ(1,i)[0]);const h=X2(d.shape,l,s),p=DU([d.shape[l]]),f=Yne({inputs:{x:d},backend:n,attrs:{shape:[-1,p]}});c.push(f);const m=Tq(r.dtype),g=(e,t,a,r,o)=>{const s=e.shape[0],i=e.shape[1],l=q2(i,o),u=new fle({windowSize:l,inSize:i,batchSize:s,numSegments:o},t),d=n.compileAndRun(u,[e,a],r);if(c.push(d),d.shape[1]===o)return d;const h=zie({backend:n,attrs:{start:0,stop:o,step:1,dtype:"float32"}}),p=ale({inputs:{x:h},backend:n,attrs:{reps:[i/l]}});c.push(h),c.push(p);return g(d,t,p,r,o)},b=Yne({inputs:{x:g(f,"unsortedSegmentSum",o,m,s)},backend:n,attrs:{shape:h}});let y=b;if(null!=u){c.push(b);const e=$J(u);y=oae({inputs:{x:y},backend:n,attrs:{perm:e}})}return c.forEach((e=>n.disposeIntermediateTensorInfo(e))),y}},gle=[lae,dae,pae,mae,yae,wae,kae,Iae,Rae,_ae,Fae,Dae,Lae,zae,Wae,Gae,Hae,qae,Xae,Yae,Zae,rre,ore,sre,ire,pre,gre,xre,Fne,kre,_re,zre,Gre,jre,Kre,qre,Xre,Qre,Zre,eoe,soe,ioe,coe,uoe,poe,goe,boe,xoe,woe,koe,Soe,Noe,Toe,Roe,Aoe,Ooe,Loe,Boe,Uoe,Hoe,qoe,Yoe,Zoe,tse,nse,rse,ise,lse,dse,_ne,hse,Tre,fse,gse,yse,Mne,vse,kse,Ise,Nse,Tse,Rse,Ase,Ose,Lse,zse,Wse,Use,Gse,Hse,qse,Xse,Yse,Qse,Jse,$se,nie,rie,pie,Xne,mie,bie,xie,wie,lre,Iie,Cie,Tie,Aie,Oie,zne,Die,Mie,Lie,Pie,Bie,dre,iie,Vie,Gie,jie,Qne,Xie,Qie,$ie,tce,rce,sce,cce,uce,pce,mce,bce,xce,wce,Ice,Nce,Tce,are,hie,Rce,_ce,Ace,Fce,Oce,Dce,Mce,Lce,Bce,Wce,Gce,Hce,jce,qce,Xce,Yce,Qce,uie,rae,Zce,ele,tle,rle,lle,dle,sae,hle,ple,mle,Nie];for(const n of gle)OK(n);var ble,yle;uG().registerFlag("KEEP_INTERMEDIATE_TENSORS",(()=>!1),(e=>{e&&console.warn("Keep intermediate tensors is ON. This will print the values of all intermediate tensors during model inference. Not all models support this mode. For details, check e2e/benchmarks/ model_config.js. This significantly impacts performance.")})),function(e){e[e.DT_INVALID=0]="DT_INVALID",e[e.DT_FLOAT=1]="DT_FLOAT",e[e.DT_DOUBLE=2]="DT_DOUBLE",e[e.DT_INT32=3]="DT_INT32",e[e.DT_UINT8=4]="DT_UINT8",e[e.DT_INT16=5]="DT_INT16",e[e.DT_INT8=6]="DT_INT8",e[e.DT_STRING=7]="DT_STRING",e[e.DT_COMPLEX64=8]="DT_COMPLEX64",e[e.DT_INT64=9]="DT_INT64",e[e.DT_BOOL=10]="DT_BOOL",e[e.DT_QINT8=11]="DT_QINT8",e[e.DT_QUINT8=12]="DT_QUINT8",e[e.DT_QINT32=13]="DT_QINT32",e[e.DT_BFLOAT16=14]="DT_BFLOAT16",e[e.DT_QINT16=15]="DT_QINT16",e[e.DT_QUINT16=16]="DT_QUINT16",e[e.DT_UINT16=17]="DT_UINT16",e[e.DT_COMPLEX128=18]="DT_COMPLEX128",e[e.DT_HALF=19]="DT_HALF",e[e.DT_RESOURCE=20]="DT_RESOURCE",e[e.DT_VARIANT=21]="DT_VARIANT",e[e.DT_UINT32=22]="DT_UINT32",e[e.DT_UINT64=23]="DT_UINT64",e[e.DT_FLOAT_REF=101]="DT_FLOAT_REF",e[e.DT_DOUBLE_REF=102]="DT_DOUBLE_REF",e[e.DT_INT32_REF=103]="DT_INT32_REF",e[e.DT_UINT8_REF=104]="DT_UINT8_REF",e[e.DT_INT16_REF=105]="DT_INT16_REF",e[e.DT_INT8_REF=106]="DT_INT8_REF",e[e.DT_STRING_REF=107]="DT_STRING_REF",e[e.DT_COMPLEX64_REF=108]="DT_COMPLEX64_REF",e[e.DT_INT64_REF=109]="DT_INT64_REF",e[e.DT_BOOL_REF=110]="DT_BOOL_REF",e[e.DT_QINT8_REF=111]="DT_QINT8_REF",e[e.DT_QUINT8_REF=112]="DT_QUINT8_REF",e[e.DT_QINT32_REF=113]="DT_QINT32_REF",e[e.DT_BFLOAT16_REF=114]="DT_BFLOAT16_REF",e[e.DT_QINT16_REF=115]="DT_QINT16_REF",e[e.DT_QUINT16_REF=116]="DT_QUINT16_REF",e[e.DT_UINT16_REF=117]="DT_UINT16_REF",e[e.DT_COMPLEX128_REF=118]="DT_COMPLEX128_REF",e[e.DT_HALF_REF=119]="DT_HALF_REF",e[e.DT_RESOURCE_REF=120]="DT_RESOURCE_REF",e[e.DT_VARIANT_REF=121]="DT_VARIANT_REF",e[e.DT_UINT32_REF=122]="DT_UINT32_REF",e[e.DT_UINT64_REF=123]="DT_UINT64_REF"}(ble||(ble={})),function(e){let t;!function(e){e[e.LEGACY=0]="LEGACY",e[e.V1=1]="V1",e[e.V2=2]="V2"}(t=e.CheckpointFormatVersion||(e.CheckpointFormatVersion={}))}(yle||(yle={}));const xle={};function vle(e){return xle[e]}function wle(e,t,n,a,r){const o=t.inputParams[e];if(o&&void 0!==o.inputIndexStart){const e=o.inputIndexStart,s=0===o.inputIndexEnd?void 0:void 0===o.inputIndexEnd?e+1:o.inputIndexEnd,i=e<0?t.inputNames.length+e:e;if("tensor"===o.type)return kle(t.inputNames[i],n,a,r);if("tensors"===o.type){const o=t.inputs.slice(e,s);return t.inputNames.slice(e,s).filter(((e,t)=>{var n;return"NoOp"!==(null===(n=o[t])||void 0===n?void 0:n.op)})).map((e=>kle(e,n,a,r)))}const c=kle(t.inputNames[i],n,a,r),l=c.dataSync();return"number"===o.type?l[0]:$U(c.shape,l)}const s=t.attrParams[e];return s&&s.value}function kle(e,t,n,a){const[r,o]=Cle(e,n);if(null!=a){const e=a.getHashTableHandleByName(r);if(null!=e)return e}const s=n.currentContextIds.find((e=>!!t[Nle(r,e)]));return void 0!==s?t[Nle(r,s)][o]:void 0}function Ile(e,t,n){return t[Nle(e,n.currentContextId)]}function Sle(e,t){const[n,a,r]=Cle(e,t);return[Nle(n,t&&t.currentContextId),a,r]}function Nle(e,t){return t?"".concat(e,"-").concat(t):e}function Cle(e,t){if(""===e)return["",0,void 0];const n=null!=t&&null!=t.parseNodeNameCache;if(n){const n=t.parseNodeNameCache.get(e);if(null!=n)return n}const a=e.split(":");let r;if(1===a.length)r=[e,0,void 0];else{const e=a[0],t=3===a.length?a[1]:void 0;r=[e,Number(a[a.length-1]),t]}return n&&t.parseNodeNameCache.set(e,r),r}function Tle(e,t,n){let a=wle("pad",e,t,n);if("explicit"===a){a=wle("explicitPaddings",e,t,n);const r=[[0,0],[0,0],[0,0],[0,0]];for(let e=0;e<4;e++)r[e][0]=a[2*e],r[e][1]=a[2*e+1];return r}return a}function Ele(e){return e.kept?e:uY(e)}const Rle=[{tfOpName:"Add",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddV2",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddN",category:"arithmetic",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"BiasAdd",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"Sub",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"RealDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Div",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"DivNoNan",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mul",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Maximum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Minimum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Pow",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SquaredDifference",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorMod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],_le=[{tfOpName:"Abs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan2",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Ceil",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ClipByValue",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"clipValueMin",type:"number"},{start:2,name:"clipValueMax",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Complex",category:"basic_math",inputs:[{start:0,name:"real",type:"tensor"},{start:1,name:"imag",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ComplexAbs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Elu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Exp",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Floor",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Imag",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Neg",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Real",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Prelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"alpha",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu6",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Selu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sigmoid",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Rsqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Square",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sign",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Round",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Expm1",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log1p",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Reciprocal",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Softplus",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Erf",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LeakyRelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"alpha",name:"alpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsNan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsFinite",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsInf",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],Ale=[{tfOpName:"EmptyTensorList",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"maxNumElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"LoopCond",category:"control",inputs:[{start:0,name:"pred",type:"tensor"}]},{tfOpName:"Switch",category:"control",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"pred",type:"tensor"}]},{tfOpName:"Merge",category:"control",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"Enter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"frame_name",name:"frameName",type:"string"},{tfName:"is_constant",name:"isConstant",type:"bool"}]},{tfOpName:"Exit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NextIteration",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayV3",category:"control",inputs:[{start:0,name:"size",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"dynamic_size",name:"dynamicSize",type:"bool"},{tfName:"clear_after_read",name:"clearAfterRead",type:"bool"},{tfName:"identical_element_shapes",name:"identicalElementShapes",type:"bool"},{tfName:"tensor_array_name",name:"name",type:"string"}]},{tfOpName:"TensorArrayWriteV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayReadV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayGatherV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"}]},{tfOpName:"TensorArrayScatterV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArrayConcatV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape_except0",name:"elementShapeExcept0",type:"shape",notSupported:!0}]},{tfOpName:"TensorArraySplitV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"tensor",type:"tensor"},{start:2,name:"lengths",type:"number[]"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArraySizeV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}]},{tfOpName:"TensorArrayCloseV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"}]},{tfOpName:"StatelessIf",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"If",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"StatelessWhile",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"While",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"TensorListScatter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListScatterV2",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"},{start:3,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGather",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListSetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListReserve",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListFromTensor",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListStack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"},{tfName:"num_elements",name:"numElements",type:"dtype"}]},{tfOpName:"TensorListSplit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"},{start:2,name:"lengths",type:"number[]"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcat",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcatV2",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPopBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPushBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListLength",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}]},{tfOpName:"TensorListResize",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"size",type:"number"}]}],Fle=[{tfOpName:"AvgPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[],notSupported:!0},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPoolWithArgmax",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"include_batch_in_index",name:"includeBatchInIndex",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AvgPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Conv1D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"stride",name:"stride",type:"number"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NWC"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"dilation",name:"dilation",type:"number",defaultValue:1}]},{tfOpName:"Conv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"useCudnnOnGpu",name:"useCudnnOnGpu",type:"bool"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"_FusedConv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"use_cudnn_on_gpu",name:"useCudnnOnGpu",type:"bool",defaultValue:!0},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"leakyrelu_alpha",name:"leakyreluAlpha",type:"number",defaultValue:.2}]},{tfOpName:"Conv2DBackpropInput",category:"convolution",inputs:[{start:2,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:0,name:"outputShape",type:"number[]"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]",notSupported:!0}]},{tfOpName:"DepthwiseConv2d",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"DepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"FusedDepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]}]},{tfOpName:"Conv3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"Dilation2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"rates",name:"dilations",type:"number[]"},{tfName:"padding",name:"pad",type:"string"}]}],Ole=[{tfOpName:"Fill",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"},{start:1,name:"value",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"LinSpace",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"num",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"OneHot",category:"creation",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"depth",type:"number"},{start:2,name:"onValue",type:"number",defaultValue:1},{start:3,name:"offValue",type:"number",defaultValue:0}],attrs:[{tfName:"axis",name:"axis",type:"number",notSupported:!0},{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Ones",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"OnesLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"RandomStandardNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"RandomUniform",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"minval",name:"minval",type:"number",defaultValue:0},{tfName:"maxval",name:"maxval",type:"number",defaultValue:1},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"RandomUniformInt",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"minval",name:"minval",type:"number"},{tfName:"maxval",name:"maxval",type:"number"},{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0}]},{tfOpName:"Range",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"step",type:"number",defaultValue:0}],attrs:[{tfName:"Tidx",name:"dtype",type:"dtype"}]},{tfOpName:"TruncatedNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"means",name:"mean",type:"number",defaultValue:0},{tfName:"stddev",name:"stdDev",type:"number",defaultValue:1},{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"Zeros",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"ZerosLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Multinomial",category:"creation",inputs:[{start:0,name:"logits",type:"tensor"},{start:1,name:"numSamples",type:"number"}],attrs:[{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number"},{tfName:"T",name:"dtype",type:"dtype"},{tfName:"output_dtype",name:"output_dtype",type:"dtype"}]}],Dle=[{tfOpName:"NonMaxSuppressionV2",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV3",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV4",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"T_threshold",name:"threshold",type:"dtype",notSupported:!0},{tfName:"pad_to_max_output_size",name:"padToMaxOutputSize",type:"bool"}]},{tfOpName:"NonMaxSuppressionV5",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"},{start:5,name:"softNmsSigma",type:"number"}]},{tfOpName:"Where",category:"dynamic",inputs:[{start:0,name:"condition",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ListDiff",category:"dynamic",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],Mle=[{tfOpName:"LowerBound",category:"evaluation",inputs:[{start:0,name:"sortedSequence",type:"tensor"},{start:1,name:"values",type:"tensor"}]},{tfOpName:"TopKV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"k",type:"number"}],attrs:[{tfName:"sorted",name:"sorted",type:"bool"}]},{tfOpName:"UpperBound",category:"evaluation",inputs:[{start:0,name:"sortedSequence",type:"tensor"},{start:1,name:"values",type:"tensor"}]},{tfOpName:"Unique",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"UniqueV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]}],Lle=[{tfOpName:"PlaceholderWithDefault",category:"graph",inputs:[{start:0,name:"default",type:"tensor"}],attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Placeholder",category:"graph",attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Const",category:"graph"},{tfOpName:"Identity",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IdentityN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Snapshot",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Rank",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Size",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Shape",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"ShapeN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Print",category:"graph",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"data",type:"tensors"}],attrs:[{tfName:"message",name:"message",type:"string"},{tfName:"first_n",name:"firstN",type:"number",notSupported:!0},{tfName:"summarize",name:"summarize",type:"number",defaultValue:3}]},{tfOpName:"NoOp",category:"graph",inputs:[]},{tfOpName:"StopGradient",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"FakeQuantWithMinMaxVars",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"min",name:"min",type:"number"},{tfName:"max",name:"max",type:"number"}]}],Ple=[{tfOpName:"HashTable",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"HashTableV2",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"LookupTableImport",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableImportV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFind",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFindV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableSize",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]},{tfOpName:"LookupTableSizeV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]},{tfOpName:"InitializeTable",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}]},{tfOpName:"InitializeTableV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}]}],zle=[{tfOpName:"ResizeBilinear",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ResizeNearestNeighbor",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"CropAndResize",category:"image",inputs:[{start:0,name:"image",type:"tensor"},{start:1,name:"boxes",type:"tensor"},{start:2,name:"boxInd",type:"tensor"},{start:3,name:"cropSize",type:"number[]"}],attrs:[{tfName:"method",name:"method",type:"string"},{tfName:"extrapolation_value",name:"extrapolationValue",type:"number"}]},{tfOpName:"ImageProjectiveTransformV3",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"transforms",type:"tensor"},{start:2,name:"outputShape",type:"number[]"},{start:3,name:"fillValue",type:"number"}],attrs:[{tfName:"interpolation",name:"interpolation",type:"string"},{tfName:"fill_mode",name:"fillMode",type:"string"}]}],Ble=[{tfOpName:"Equal",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NotEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Greater",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"GreaterEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Less",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LessEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalAnd",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalNot",category:"logical",inputs:[{start:0,name:"a",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalOr",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Select",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SelectV2",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BitwiseAnd",category:"logical",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}]}],Wle=[{tfOpName:"_FusedMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"leakyrelu_alpha",name:"leakyreluAlpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMulV2",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Transpose",category:"matrices",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"perm",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Einsum",category:"matrices",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"equation",name:"equation",type:"string"},{tfName:"N",name:"n",type:"number",defaultValue:2},{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"MatrixBandPart",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"numLower",type:"tensor"},{start:1,name:"numUpper",type:"tensor"}]}],Vle=[{tfOpName:"EuclideanNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool",defaultValue:!1}]},{tfOpName:"FusedBatchNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV2",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV3",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"LRN",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"depth_radius",name:"radius",type:"number",defaultValue:5},{tfName:"bias",name:"bias",type:"number",defaultValue:1},{tfName:"alpha",name:"alpha",type:"number",defaultValue:1},{tfName:"beta",name:"beta",type:"number",defaultValue:.5}]},{tfOpName:"Softmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"LogSoftmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]}],Ule=[{tfOpName:"Bincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}]},{tfOpName:"DenseBincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}],attrs:[{tfName:"binary_output",name:"binaryOutput",type:"bool"}]},{tfOpName:"Max",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Mean",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Min",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Sum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"All",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Any",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"ArgMax",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"ArgMin",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"Prod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cumprod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]},{tfOpName:"Cumsum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]}],Gle=[{tfOpName:"ConcatV2",category:"slice_join",inputs:[{start:0,end:-1,name:"tensors",type:"tensors"},{start:-1,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"Concat",category:"slice_join",inputs:[{start:1,end:0,name:"tensors",type:"tensors"},{start:0,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"GatherV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"axis",type:"number",defaultValue:0}],attrs:[{tfName:"batch_dims",name:"batchDims",type:"number",defaultValue:0}]},{tfOpName:"Gather",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",notSupported:!0}]},{tfOpName:"Reverse",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"dims",type:"bool[]"}]},{tfOpName:"ReverseV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}]},{tfOpName:"Slice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"size",type:"number[]"}]},{tfOpName:"StridedSlice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"end",type:"number[]"},{start:3,name:"strides",type:"number[]"}],attrs:[{tfName:"begin_mask",name:"beginMask",type:"number",defaultValue:0},{tfName:"end_mask",name:"endMask",type:"number",defaultValue:0},{tfName:"new_axis_mask",name:"newAxisMask",type:"number",defaultValue:0},{tfName:"ellipsis_mask",name:"ellipsisMask",type:"number",defaultValue:0},{tfName:"shrink_axis_mask",name:"shrinkAxisMask",type:"number",defaultValue:0}]},{tfOpName:"Pack",category:"slice_join",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0}]},{tfOpName:"Unpack",category:"slice_join",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0},{tfName:"num",name:"num",type:"number",defaultValue:0,notSupported:!0}]},{tfOpName:"Tile",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"reps",type:"number[]"}]},{tfOpName:"Split",category:"slice_join",inputs:[{start:0,name:"axis",type:"number",defaultValue:0},{start:1,name:"x",type:"tensor"}],attrs:[{tfName:"num_split",name:"numOrSizeSplits",type:"number",defaultValue:1}]},{tfOpName:"SplitV",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"numOrSizeSplits",type:"number[]"},{start:2,name:"axis",type:"number",defaultValue:0}]},{tfOpName:"ScatterNd",category:"slice_join",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"shape",type:"number[]"}]},{tfOpName:"GatherNd",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}]},{tfOpName:"SparseToDense",category:"slice_join",inputs:[{start:0,name:"sparseIndices",type:"tensor"},{start:1,name:"outputShape",type:"number[]"},{start:2,name:"sparseValues",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",defaultValue:!1,notSupported:!0}]},{tfOpName:"TensorScatterUpdate",category:"slice_join",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"values",type:"tensor"}]}],Hle=[{tfOpName:"SparseFillEmptyRows",category:"sparse",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"denseShape",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}]},{tfOpName:"SparseReshape",category:"sparse",inputs:[{start:0,name:"inputIndices",type:"tensor"},{start:1,name:"inputShape",type:"tensor"},{start:2,name:"newShape",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SparseSegmentMean",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]},{tfOpName:"SparseSegmentSum",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]}],jle=[{tfOpName:"FFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"RFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]},{tfOpName:"IRFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]}],Kle=[{tfOpName:"StaticRegexReplace",category:"string",inputs:[{start:0,name:"input",type:"tensor"}],attrs:[{tfName:"pattern",name:"pattern",type:"string"},{tfName:"rewrite",name:"rewrite",type:"string"},{tfName:"replace_global",name:"replaceGlobal",type:"bool"}]},{tfOpName:"StringNGrams",category:"string",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"dataSplits",type:"tensor"}],attrs:[{tfName:"separator",name:"separator",type:"string"},{tfName:"ngram_widths",name:"nGramWidths",type:"number[]"},{tfName:"left_pad",name:"leftPad",type:"string"},{tfName:"right_pad",name:"rightPad",type:"string"},{tfName:"pad_width",name:"padWidth",type:"number"},{tfName:"preserve_short_sequences",name:"preserveShortSequences",type:"bool"}],outputs:["ngrams","ngrams_splits"]},{tfOpName:"StringSplit",category:"string",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"delimiter",type:"tensor"}],attrs:[{tfName:"skip_empty",name:"skipEmpty",type:"bool"}],outputs:["indices","values","shape"]},{tfOpName:"StringToHashBucketFast",category:"string",inputs:[{start:0,name:"input",type:"tensor"}],attrs:[{tfName:"num_buckets",name:"numBuckets",type:"number"}]}],qle=[{tfOpName:"Cast",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"SrcT",name:"sdtype",type:"dtype",notSupported:!0},{tfName:"DstT",name:"dtype",type:"dtype"}]},{tfOpName:"ExpandDims",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"MirrorPad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"mode",name:"mode",type:"string"}]},{tfOpName:"Pad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"constant_value",name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"PadV2",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"},{start:2,name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"Reshape",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}]},{tfOpName:"EnsureShape",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}]},{tfOpName:"Squeeze",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"axis",tfDeprecatedName:"squeeze_dims",name:"axis",type:"number[]"}]},{tfOpName:"SpaceToBatchND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"paddings",type:"number[]"}]},{tfOpName:"BatchToSpaceND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"crops",type:"number[]"}]},{tfOpName:"DepthToSpace",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"block_size",name:"blockSize",type:"number"},{tfName:"data_format",name:"dataFormat",type:"string"}]},{tfOpName:"BroadcastTo",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}],attrs:[]},{tfOpName:"BroadcastArgs",category:"transformation",inputs:[{start:0,name:"s0",type:"tensor"},{start:1,name:"s1",type:"tensor"}],attrs:[]}];class Xle{static get Instance(){return this._instance||(this._instance=new this)}constructor(){const e=[].concat(...[d,h,p,f,m,g,b,y,x,v,w,k,I,S,N,C,T,E,R].map((e=>e.json)));this.opMappers=e.reduce(((e,t)=>(e[t.tfOpName]=t,e)),{})}transformGraph(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const n=e.node,a=[],r=[],o=[],s=n.reduce(((e,t)=>(e[t.name]=this.mapNode(t),t.op.startsWith("Placeholder")?a.push(e[t.name]):"Const"===t.op?r.push(e[t.name]):null!=t.input&&0!==t.input.length||o.push(e[t.name]),e)),{});let i=[];const c=[];let l={},u={};null!=t&&(l=this.mapSignatureEntries(t.inputs),u=this.mapSignatureEntries(t.outputs));const d=Object.keys(s);d.forEach((e=>{const t=s[e];t.inputNames.forEach(((e,n)=>{const[a,,r]=Sle(e),o=s[a];if(null!=o.outputs){const e=o.outputs.indexOf(r);if(-1!==e){const r="".concat(a,":").concat(e);t.inputNames[n]=r}}t.inputs.push(o),o.children.push(t)}))})),0===Object.keys(u).length?d.forEach((e=>{const t=s[e];0===t.children.length&&c.push(t)})):Object.keys(u).forEach((e=>{const[t]=Sle(e),n=s[t];null!=n&&(n.signatureKey=u[e],c.push(n))})),Object.keys(l).length>0?Object.keys(l).forEach((e=>{const[t]=Sle(e),n=s[t];n&&(n.signatureKey=l[e],i.push(n))})):i=a;let h={};null!=e.library&&null!=e.library.function&&(h=e.library.function.reduce(((e,t)=>(e[t.signature.name]=this.mapFunction(t),e)),{}));const p={nodes:s,inputs:i,outputs:c,weights:r,placeholders:a,signature:t,functions:h};return o.length>0&&(p.initNodes=o),p}mapSignatureEntries(e){return Object.keys(e||{}).reduce(((t,n)=>(t[e[n].name]=n,t)),{})}mapNode(e){const t=vle(e.op)||this.opMappers[e.op]||{};null==e.attr&&(e.attr={});const n={name:e.name,op:e.op,category:t.category,inputNames:(e.input||[]).map((e=>e.startsWith("^")?e.slice(1):e)),inputs:[],children:[],inputParams:{},attrParams:{},rawAttrs:e.attr,outputs:t.outputs};return null!=t.inputs&&(n.inputParams=t.inputs.reduce(((e,t)=>(e[t.name]={type:t.type,inputIndexStart:t.start,inputIndexEnd:t.end},e)),{})),null!=t.attrs&&(n.attrParams=t.attrs.reduce(((t,n)=>{const a=n.type;let r;switch(n.type){case"string":r=Qle(e.attr,n.tfName,n.defaultValue),void 0===r&&n.tfDeprecatedName&&(r=Qle(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"string[]":r=sue(e.attr,n.tfName,n.defaultValue),void 0===r&&n.tfDeprecatedName&&(r=sue(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"number":r=Zle(e.attr,n.tfName,n.defaultValue||0),void 0===r&&n.tfDeprecatedName&&(r=Zle(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"number[]":r=oue(e.attr,n.tfName,n.defaultValue),void 0===r&&n.tfDeprecatedName&&(r=oue(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"bool":r=Jle(e.attr,n.tfName,n.defaultValue),void 0===r&&n.tfDeprecatedName&&(r=Jle(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"bool[]":r=cue(e.attr,n.tfName,n.defaultValue),void 0===r&&n.tfDeprecatedName&&(r=cue(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"shape":r=rue(e.attr,n.tfName,n.defaultValue),void 0===r&&n.tfDeprecatedName&&(r=rue(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"shape[]":r=iue(e.attr,n.tfName,n.defaultValue),void 0===r&&n.tfDeprecatedName&&(r=iue(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"dtype":r=tue(e.attr,n.tfName,n.defaultValue),void 0===r&&n.tfDeprecatedName&&(r=tue(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"dtype[]":r=nue(e.attr,n.tfName,n.defaultValue),void 0===r&&n.tfDeprecatedName&&(r=nue(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"func":r=eue(e.attr,n.tfName,n.defaultValue),void 0===r&&n.tfDeprecatedName&&(r=eue(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"tensor":case"tensors":break;default:throw new Error("Unsupported param type: ".concat(n.type," for op: ").concat(e.op))}return t[n.name]={value:r,type:a},t}),{})),n}mapFunction(e){const t=e.nodeDef,n=[];let a={};null!=t&&(a=t.reduce(((e,t)=>(e[t.name]=this.mapNode(t),"Const"===t.op&&n.push(e[t.name]),e)),{}));const r=[],o=[];e.signature.inputArg.forEach((e=>{const[t]=Sle(e.name),n={name:t,op:"Placeholder",inputs:[],inputNames:[],category:"graph",inputParams:{},attrParams:{dtype:{value:$le(e.type),type:"dtype"}},children:[]};n.signatureKey=e.name,r.push(n),a[t]=n}));Object.keys(a).forEach((e=>{const t=a[e];t.inputNames.forEach(((e,n)=>{const[r,,o]=Sle(e),s=a[r];if(null!=s.outputs){const e=s.outputs.indexOf(o);if(-1!==e){const a="".concat(r,":").concat(e);t.inputNames[n]=a}}t.inputs.push(s),s.children.push(t)}))}));const s=e.ret;e.signature.outputArg.forEach((e=>{const[t,n]=Sle(s[e.name]),r=a[t];null!=r&&(r.defaultOutput=n,o.push(r))}));const i=this.mapArgsToSignature(e);return{nodes:a,inputs:r,outputs:o,weights:n,placeholders:[],signature:i}}mapArgsToSignature(e){return{methodName:e.signature.name,inputs:e.signature.inputArg.reduce(((e,t)=>(e[t.name]=this.mapArgToTensorInfo(t),e)),{}),outputs:e.signature.outputArg.reduce(((t,n)=>(t[n.name]=this.mapArgToTensorInfo(n,e.ret),t)),{})}}mapArgToTensorInfo(e,t){let n=e.name;return null!=t&&(n=t[n]),{name:n,dtype:e.type}}}function Yle(e,t){const n=Array.isArray(e)?String.fromCharCode.apply(null,e):function(e){const t=uG().global;if("undefined"!==typeof t.atob)return t.atob(e);if("undefined"!==typeof Buffer)return new Buffer(e,"base64").toString();throw new Error("Unable to decode base64 in this environment. Missing built-in atob() or Buffer()")}(e);return t?n:n.toLowerCase()}function Qle(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const r=e[t];return null!=r?Yle(r.s,a):n}function Jle(e,t,n){const a=e[t];return a?a.b:n}function Zle(e,t,n){const a=e[t]||{},r=null!=a.i?a.i:null!=a.f?a.f:n;return"number"===typeof r?r:parseInt(r,10)}function $le(e){switch("string"===typeof e&&(e=ble[e]),e){case ble.DT_FLOAT:case ble.DT_HALF:return"float32";case ble.DT_INT32:case ble.DT_INT64:case ble.DT_INT8:case ble.DT_UINT8:return"int32";case ble.DT_BOOL:return"bool";case ble.DT_DOUBLE:return"float32";case ble.DT_STRING:return"string";case ble.DT_COMPLEX64:case ble.DT_COMPLEX128:return"complex64";default:return null}}function eue(e,t,n){const a=e[t];return a&&a.func?a.func.name:n}function tue(e,t,n){const a=e[t];return a&&a.type?$le(a.type):n}function nue(e,t,n){const a=e[t];return a&&a.list&&a.list.type?a.list.type.map((e=>$le(e))):n}function aue(e){if(!e.unknownRank)return null!=e.dim?e.dim.map((e=>"number"===typeof e.size?e.size:parseInt(e.size,10))):[]}function rue(e,t,n){const a=e[t];return a&&a.shape?aue(a.shape):n}function oue(e,t,n){const a=e[t];return a?((a.list.f&&a.list.f.length?a.list.f:a.list.i)||[]).map((e=>"number"===typeof e?e:parseInt(e,10))):n}function sue(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const r=e[t];return r&&r.list&&r.list.s?r.list.s.map((e=>Yle(e,a))):n}function iue(e,t,n){const a=e[t];return a&&a.list&&a.list.shape?a.list.shape.map((e=>aue(e))):n}function cue(e,t,n){const a=e[t];return a&&a.list&&a.list.b?a.list.b:n}class lue{constructor(e,t,n){this.node=e,this.tensorMap=t,this.context=n,this.inputs=[],this.attrs={},this.inputs=e.inputNames.map((e=>this.getInput(e))),null!=e.rawAttrs&&(this.attrs=Object.keys(e.rawAttrs).reduce(((e,t)=>(e[t]=this.getAttr(t),e)),{}))}getInput(e){return kle(e,this.tensorMap,this.context)}getAttr(e,t){const n=this.node.rawAttrs[e];if(null!=n.tensor)return kle(e,this.tensorMap,this.context);if(null!=n.i||null!=n.f)return Zle(this.node.rawAttrs,e,t);if(null!=n.s)return Qle(this.node.rawAttrs,e,t);if(null!=n.b)return Jle(this.node.rawAttrs,e,t);if(null!=n.shape)return rue(this.node.rawAttrs,e,t);if(null!=n.type)return tue(this.node.rawAttrs,e,t);if(null!=n.list){if(null!=n.list.i||null!=n.list.f)return oue(this.node.rawAttrs,e,t);if(null!=n.list.s)return sue(this.node.rawAttrs,e,t);if(null!=n.list.shape)return iue(this.node.rawAttrs,e,t);if(null!=n.list.b)return cue(this.node.rawAttrs,e,t);if(null!=n.list.type)return nue(this.node.rawAttrs,e,t)}return t}}function uue(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"";if("number"!==typeof e&&"number"!==typeof t){AU(e.length===t.length,(()=>n+" Shapes ".concat(e," and ").concat(t," must match")));for(let a=0;a<e.length;a++){const r=e[a],o=t[a];AU(r<0||o<0||r===o,(()=>n+" Shapes ".concat(e," and ").concat(t," must match")))}}}function due(e){return"number"!==typeof e&&!e.some((e=>e<0))}function hue(e,t,n){let a=pue(e,n);const r=!due(a);if(r&&0===t.length)throw new Error("Tried to calculate elements of an empty list"+" with non-fully-defined elementShape: ".concat(a));if(r&&t.forEach((e=>{a=pue(e.shape,a)})),!due(a))throw new Error("Non-fully-defined elementShape: ".concat(a));return a}function pue(e,t){if("number"===typeof e)return t;if("number"===typeof t)return e;if(e.length!==t.length)throw new Error("Incompatible ranks during merge: ".concat(e," vs. ").concat(t));const n=[];for(let a=0;a<e.length;++a){const r=e[a],o=t[a];if(r>=0&&o>=0&&r!==o)throw new Error("Incompatible shape during merge: ".concat(e," vs. ").concat(t));n[a]=r>=0?r:o}return n}class fue{constructor(e,t,n,a,r,o,s){this.name=e,this.dtype=t,this.maxSize=n,this.elementShape=a,this.identicalElementShapes=r,this.dynamicSize=o,this.clearAfterRead=s,this.tensors=[],this.closed_=!1,this.idTensor=vY(0),rX(this.idTensor)}get id(){return this.idTensor.id}get closed(){return this.closed_}clearAndClose(e){this.tensors.forEach((t=>{null!=e&&e.has(t.tensor.id)||t.tensor.dispose()})),this.tensors=[],this.closed_=!0,this.idTensor.dispose()}size(){return this.tensors.length}read(e){if(this.closed_)throw new Error("TensorArray ".concat(this.name," has already been closed."));if(e<0||e>=this.size())throw new Error("Tried to read from index ".concat(e,", but array size is: ").concat(this.size()));const t=this.tensors[e];if(t.cleared)throw new Error("TensorArray ".concat(this.name,": Could not read index ").concat(e," twice because it was cleared after a previous read ")+"(perhaps try setting clear_after_read = false?).");return this.clearAfterRead&&(t.cleared=!0),t.read=!0,t.tensor}readMany(e){return e.map((e=>this.read(e)))}write(e,t){if(this.closed_)throw new Error("TensorArray ".concat(this.name," has already been closed."));if(e<0||!this.dynamicSize&&e>=this.maxSize)throw new Error("Tried to write to index ".concat(e,", but array is not resizeable and size is: ").concat(this.maxSize));const n=this.tensors[e]||{};if(t.dtype!==this.dtype)throw new Error("TensorArray ".concat(this.name,": Could not write to TensorArray index ").concat(e,",\n          because the value dtype is ").concat(t.dtype,", but TensorArray dtype is ").concat(this.dtype,"."));if(0!==this.size()||null!=this.elementShape&&0!==this.elementShape.length||(this.elementShape=t.shape),uue(this.elementShape,t.shape,"TensorArray ".concat(this.name,": Could not write to TensorArray index ").concat(e,".")),n.read)throw new Error("TensorArray ".concat(this.name,": Could not write to TensorArray index ").concat(e,", because it has already been read."));if(n.written)throw new Error("TensorArray ".concat(this.name,": Could not write to TensorArray index ").concat(e,", because it has already been written."));n.tensor=t,rX(t),n.written=!0,this.tensors[e]=n}writeMany(e,t){if(e.length!==t.length)throw new Error("TensorArray ".concat(this.name,": could not write multiple tensors,")+"because the index size: ".concat(e.length," is not the same as tensors size: ").concat(t.length,"."));e.forEach(((e,n)=>this.write(e,t[n])))}gather(e,t){if(t&&t!==this.dtype)throw new Error("TensorArray dtype is ".concat(this.dtype," but gather requested dtype ").concat(t));if(e)e=e.slice(0,this.size());else{e=[];for(let t=0;t<this.size();t++)e.push(t)}if(0===e.length)return Zq([],[0].concat(this.elementShape));const n=this.readMany(e);return uue(this.elementShape,n[0].shape,"TensorArray shape mismatch: "),$$(n,0)}concat(e){if(e&&e!==this.dtype)throw new Error("TensorArray dtype is ".concat(this.dtype," but concat requested dtype ").concat(e));if(0===this.size())return Zq([],[0].concat(this.elementShape));const t=[];for(let a=0;a<this.size();a++)t.push(a);const n=this.readMany(t);return uue(this.elementShape,n[0].shape,"TensorArray shape mismatch: tensor array shape (".concat(this.elementShape,") vs first tensor shape (").concat(n[0].shape,")")),nJ(n,0)}scatter(e,t){if(t.dtype!==this.dtype)throw new Error("TensorArray dtype is ".concat(this.dtype," but tensor has dtype ").concat(t.dtype));if(e.length!==t.shape[0])throw new Error("Expected len(indices) == tensor.shape[0], but saw: ".concat(e.length," vs. ").concat(t.shape[0]));const n=Math.max(...e);if(!this.dynamicSize&&n>=this.maxSize)throw new Error("Max index must be < array size (".concat(n,"  vs. ").concat(this.maxSize,")"));this.writeMany(e,g0(t,0))}split(e,t){if(t.dtype!==this.dtype)throw new Error("TensorArray dtype is ".concat(this.dtype," but tensor has dtype ").concat(t.dtype));let n=0;const a=e.map((e=>(n+=e,n)));if(n!==t.shape[0])throw new Error("Expected sum of lengths to be equal to\n          tensor.shape[0], but sum of lengths is\n        ".concat(n,", and tensor's shape is: ").concat(t.shape));if(!this.dynamicSize&&e.length!==this.maxSize)throw new Error("TensorArray's size is not equal to the size of lengths (".concat(this.maxSize," vs. ").concat(e.length,"), ")+"and the TensorArray is not marked as dynamically resizeable");const r=0===n?0:t.size/n,o=[];nX((()=>{t=$Q(t,[1,n,r]);for(let n=0;n<e.length;++n){const s=[0,0===n?0:a[n-1],0],i=[1,e[n],r];o[n]=$Q(oJ(t,s,i),this.elementShape)}return o}));const s=[];for(let i=0;i<e.length;i++)s[i]=i;this.writeMany(s,o)}}class mue{get id(){return this.idTensor.id}constructor(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:-1;this.tensors=e,this.elementShape=t,this.elementDtype=n,null!=e&&e.forEach((e=>{if(n!==e.dtype)throw new Error("Invalid data types; op elements ".concat(n,", but list elements ").concat(e.dtype));uue(t,e.shape,"TensorList shape mismatch: "),rX(e)})),this.idTensor=vY(0),this.maxNumElements=a,rX(this.idTensor)}copy(){return new mue([...this.tensors],this.elementShape,this.elementDtype)}clearAndClose(e){this.tensors.forEach((t=>{null!=e&&e.has(t.id)||t.dispose()})),this.tensors.length=0,this.idTensor.dispose()}size(){return this.tensors.length}stack(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:-1;if(t!==this.elementDtype)throw new Error("Invalid data types; op elements ".concat(t,", but list elements ").concat(this.elementDtype));if(-1!==n&&this.tensors.length!==n)throw new Error("Operation expected a list with ".concat(n," elements but got a list with ").concat(this.tensors.length," elements."));uue(e,this.elementShape,"TensorList shape mismatch: ");const a=hue(this.elementShape,this.tensors,e);return nX((()=>{const e=this.tensors.map((e=>$Q(e,a)));return $$(e,0)}))}popBack(e,t){if(t!==this.elementDtype)throw new Error("Invalid data types; op elements ".concat(t,", but list elements ").concat(this.elementDtype));if(0===this.size())throw new Error("Trying to pop from an empty list.");const n=hue(this.elementShape,this.tensors,e),a=this.tensors.pop();return a.kept=!1,uue(a.shape,e,"TensorList shape mismatch: "),$Q(a,n)}pushBack(e){if(e.dtype!==this.elementDtype)throw new Error("Invalid data types; op elements ".concat(e.dtype,", but list elements ").concat(this.elementDtype));if(uue(e.shape,this.elementShape,"TensorList shape mismatch: "),this.maxNumElements===this.size())throw new Error("Trying to push element into a full list.");rX(e),this.tensors.push(e)}resize(e){if(e<0)throw new Error("TensorListResize expects size to be non-negative. Got: ".concat(e));if(-1!==this.maxNumElements&&e>this.maxNumElements)throw new Error("TensorListResize input size ".concat(e," is greater maxNumElement ").concat(this.maxNumElements,"."));const t=new mue([],this.elementShape,this.elementDtype,this.maxNumElements);t.tensors.length=e;for(let n=0;n<Math.min(this.tensors.length,e);++n)t.tensors[n]=this.tensors[n];return t}getItem(e,t,n){if(n!==this.elementDtype)throw new Error("Invalid data types; op elements ".concat(n,", but list elements ").concat(this.elementDtype));if(e<0||e>this.tensors.length)throw new Error("Trying to access element ".concat(e," in a list with ").concat(this.tensors.length," elements."));if(null==this.tensors[e])throw new Error("element at index ".concat(e," is null."));uue(this.tensors[e].shape,t,"TensorList shape mismatch: ");const a=hue(this.elementShape,this.tensors,t);return $Q(this.tensors[e],a)}setItem(e,t){if(t.dtype!==this.elementDtype)throw new Error("Invalid data types; op elements ".concat(t.dtype,", but list elements ").concat(this.elementDtype));if(e<0||-1!==this.maxNumElements&&e>=this.maxNumElements)throw new Error("Trying to set element ".concat(e," in a list with max ").concat(this.maxNumElements," elements."));uue(this.elementShape,t.shape,"TensorList shape mismatch: "),rX(t),null!=this.tensors[e]&&(this.tensors[e].kept=!1),this.tensors[e]=t}gather(e,t,n){if(t!==this.elementDtype)throw new Error("Invalid data types; op elements ".concat(t,", but list elements ").concat(this.elementDtype));uue(this.elementShape,n,"TensorList shape mismatch: "),e=e.slice(0,this.size());const a=hue(this.elementShape,this.tensors,n);return 0===e.length?Zq([],[0].concat(a)):nX((()=>{const t=e.map((e=>$Q(this.tensors[e],a)));return $$(t,0)}))}concat(e,t){if(e&&e!==this.elementDtype)throw new Error("TensorList dtype is ".concat(this.elementDtype," but concat requested dtype ").concat(e));uue(this.elementShape,t,"TensorList shape mismatch: ");const n=hue(this.elementShape,this.tensors,t);return 0===this.size()?Zq([],[0].concat(n)):nX((()=>{const e=this.tensors.map((e=>$Q(e,n)));return nJ(e,0)}))}}const gue=async(e,t,n)=>{switch(e.op){case"If":case"StatelessIf":{const a=wle("thenBranch",e,t,n),r=wle("elseBranch",e,t,n),o=wle("cond",e,t,n),s=wle("args",e,t,n);return(await o.data())[0]?n.functionMap[a].executeFunctionAsync(s,n.tensorArrayMap,n.tensorListMap):n.functionMap[r].executeFunctionAsync(s,n.tensorArrayMap,n.tensorListMap)}case"While":case"StatelessWhile":{const a=wle("body",e,t,n),r=wle("cond",e,t,n),o=wle("args",e,t,n),s=await n.functionMap[r].executeFunctionAsync(o,n.tensorArrayMap,n.tensorListMap),i=o.map((e=>e.id));let c=await s[0].data();s.forEach((e=>{e.kept||-1!==i.indexOf(e.id)||e.dispose()}));let l=o;for(;c[0];){const e=l;l=await n.functionMap[a].executeFunctionAsync(l,n.tensorArrayMap,n.tensorListMap);const t=l.map((e=>e.id));e.forEach((e=>{e.kept||-1!==i.indexOf(e.id)||-1!==t.indexOf(e.id)||e.dispose()}));const o=await n.functionMap[r].executeFunctionAsync(l,n.tensorArrayMap,n.tensorListMap);c=await o[0].data(),o.forEach((e=>{e.kept||-1!==i.indexOf(e.id)||-1!==t.indexOf(e.id)||e.dispose()}))}return l}case"LoopCond":return[Ele(wle("pred",e,t,n))];case"Switch":{const a=wle("pred",e,t,n);let r=wle("data",e,t,n);return r.kept||(r=Ele(r)),(await a.data())[0]?[void 0,r]:[r,void 0]}case"Merge":{const a=e.inputNames.find((e=>void 0!==kle(e,t,n)));if(a){return[Ele(kle(a,t,n))]}return}case"Enter":{const a=wle("frameName",e,t,n),r=wle("tensor",e,t,n);return n.enterFrame(a),[Ele(r)]}case"Exit":{const a=wle("tensor",e,t,n);return n.exitFrame(),[Ele(a)]}case"NextIteration":{const a=wle("tensor",e,t,n);return n.nextIteration(),[Ele(a)]}case"TensorArrayV3":{const a=wle("size",e,t,n),r=wle("dtype",e,t,n),o=wle("elementShape",e,t,n),s=wle("dynamicSize",e,t,n),i=wle("clearAfterRead",e,t,n),c=wle("identicalElementShapes",e,t,n),l=wle("name",e,t,n),u=new fue(l,r,a,o,c,s,i);return n.addTensorArray(u),[u.idTensor,vY(1)]}case"TensorArrayWriteV3":{const a=wle("tensorArrayId",e,t,n),r=wle("index",e,t,n),o=wle("tensor",e,t,n),s=n.getTensorArray(a.id);return s.write(r,o),[s.idTensor]}case"TensorArrayReadV3":{const a=wle("tensorArrayId",e,t,n),r=wle("index",e,t,n);return[n.getTensorArray(a.id).read(r)]}case"TensorArrayGatherV3":{const a=wle("tensorArrayId",e,t,n),r=wle("indices",e,t,n),o=wle("dtype",e,t,n);return[n.getTensorArray(a.id).gather(r,o)]}case"TensorArrayScatterV3":{const a=wle("tensorArrayId",e,t,n),r=wle("indices",e,t,n),o=wle("tensor",e,t,n),s=n.getTensorArray(a.id);return s.scatter(r,o),[s.idTensor]}case"TensorArrayConcatV3":{const a=wle("tensorArrayId",e,t,n),r=n.getTensorArray(a.id),o=wle("dtype",e,t,n);return[r.concat(o)]}case"TensorArraySplitV3":{const a=wle("tensorArrayId",e,t,n),r=wle("tensor",e,t,n),o=wle("lengths",e,t,n),s=n.getTensorArray(a.id);return s.split(o,r),[s.idTensor]}case"TensorArraySizeV3":{const a=wle("tensorArrayId",e,t,n);return[vY(n.getTensorArray(a.id).size(),"int32")]}case"TensorArrayCloseV3":{const a=wle("tensorArrayId",e,t,n),r=n.getTensorArray(a.id);return r.clearAndClose(),[r.idTensor]}case"TensorListSetItem":{const a=wle("tensorListId",e,t,n),r=wle("index",e,t,n),o=wle("tensor",e,t,n),s=n.getTensorList(a.id);return s.setItem(r,o),[s.idTensor]}case"TensorListGetItem":{const a=wle("tensorListId",e,t,n),r=wle("index",e,t,n),o=wle("elementShape",e,t,n),s=wle("elementDType",e,t,n);return[n.getTensorList(a.id).getItem(r,o,s)]}case"TensorListScatterV2":case"TensorListScatter":{const a=wle("indices",e,t,n),r=function(e,t,n,a){if(t.length!==e.shape[0])throw new Error("Expected len(indices) == tensor.shape[0], but saw: ".concat(t.length," vs. ").concat(e.shape[0]));const r=Math.max(...t);if(null!=a&&-1!==a&&r>=a)throw new Error("Max index must be < array size (".concat(r,"  vs. ").concat(a,")"));const o=new mue([],n,e.dtype,a),s=g0(e,0);return t.forEach(((e,t)=>{o.setItem(e,s[t])})),o}(wle("tensor",e,t,n),a,wle("elementShape",e,t,n),wle("numElements",e,t,n));return n.addTensorList(r),[r.idTensor]}case"TensorListReserve":case"EmptyTensorList":{const a=wle("elementShape",e,t,n),r=wle("elementDType",e,t,n);let o;o="TensorListReserve"===e.op?"numElements":"maxNumElements";const s=wle(o,e,t,n),i=function(e,t,n,a){return new mue([],e,t,a)}(a,r,0,"TensorListReserve"===e.op?-1:s);return n.addTensorList(i),[i.idTensor]}case"TensorListGather":{const a=wle("tensorListId",e,t,n),r=wle("indices",e,t,n),o=wle("elementShape",e,t,n),s=wle("elementDType",e,t,n);return[n.getTensorList(a.id).gather(r,s,o)]}case"TensorListStack":{const a=wle("tensorListId",e,t,n),r=wle("elementShape",e,t,n),o=wle("elementDType",e,t,n),s=wle("numElements",e,t,n);return[n.getTensorList(a.id).stack(r,o,s)]}case"TensorListFromTensor":{const a=function(e,t,n){const a=e.dtype;if(e.shape.length<1)throw new Error("Tensor must be at least a vector, but saw shape: ".concat(e.shape));if(e.dtype!==n)throw new Error("Invalid data types; op elements ".concat(e.dtype,", but list elements ").concat(n));uue(e.shape.slice(1),t,"TensorList shape mismatch: ");const r=g0(e);return new mue(r,t,a)}(wle("tensor",e,t,n),wle("elementShape",e,t,n),wle("elementDType",e,t,n));return n.addTensorList(a),[a.idTensor]}case"TensorListConcat":case"TensorListConcatV2":{const a=wle("tensorListId",e,t,n),r=n.getTensorList(a.id),o=wle("dtype",e,t,n),s=wle("elementShape",e,t,n);return[r.concat(o,s)]}case"TensorListPushBack":{const a=wle("tensorListId",e,t,n),r=wle("tensor",e,t,n),o=n.getTensorList(a.id);return o.pushBack(r),[o.idTensor]}case"TensorListPopBack":{const a=wle("tensorListId",e,t,n),r=wle("elementShape",e,t,n),o=wle("elementDType",e,t,n);return[n.getTensorList(a.id).popBack(r,o)]}case"TensorListSplit":{const a=wle("tensor",e,t,n),r=wle("elementShape",e,t,n),o=function(e,t,n){let a=0;const r=t.map((e=>(a+=e,a)));if(a!==e.shape[0])throw new Error("Expected sum of lengths to be equal to\n          tensor.shape[0], but sum of lengths is\n        ".concat(a,", and tensor's shape is: ").concat(e.shape));const o=pue(e.shape.slice(1),n),s=0===a?0:e.size/a,i=nX((()=>{const n=[];e=$Q(e,[1,a,s]);for(let a=0;a<t.length;++a){const i=[0,0===a?0:r[a-1],0],c=[1,t[a],s];n[a]=$Q(oJ(e,i,c),o)}return e.dispose(),n})),c=new mue([],n,e.dtype,t.length);for(let l=0;l<i.length;l++)c.setItem(l,i[l]);return c}(a,wle("lengths",e,t,n),r);return n.addTensorList(o),[o.idTensor]}case"TensorListLength":{const a=wle("tensorListId",e,t,n);return[vY(n.getTensorList(a.id).size(),"int32")]}case"TensorListResize":{const a=wle("tensorListId",e,t,n),r=wle("size",e,t,n),o=n.getTensorList(a.id).resize(r);return n.addTensorList(o),[o.idTensor]}default:throw TypeError("Node type ".concat(e.op," is not implemented"))}};function bue(e,t,n){const[a,r]=wle("fusedOps",e,t,n),o="biasadd"===a,s=!o,i="prelu"===r,c="fusedbatchnorm"===a,l=wle("numArgs",e,t,n);if(o){if(i&&2!==l)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!i&&o&&1!==l)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd must have one extra argument: bias.")}if(c)throw new Error("FusedConv2d and DepthwiseConv2d with FusedBatchNorm is not supported");const u=wle("strides",e,t,n),d=Tle(e,t,n),h=wle("dataFormat",e,t,n).toUpperCase(),p=wle("dilations",e,t,n);let[f,m]=wle("args",e,t,n);s&&(m=f,f=void 0);return{stride:u,pad:d,dataFormat:h,dilations:p,biasArg:f,preluArg:m,activationFunc:r,leakyreluAlpha:wle("leakyreluAlpha",e,t,n)}}function yue(e,t,n){return{boxes:wle("boxes",e,t,n),scores:wle("scores",e,t,n),maxOutputSize:wle("maxOutputSize",e,t,n),iouThreshold:wle("iouThreshold",e,t,n),scoreThreshold:wle("scoreThreshold",e,t,n),softNmsSigma:wle("softNmsSigma",e,t,n)}}class xue{get id(){return this.handle.id}constructor(e,t){this.keyDType=e,this.valueDType=t,this.handle=vY(0),this.tensorMap=new Map,rX(this.handle)}clearAndClose(){this.tensorMap.forEach((e=>e.dispose())),this.tensorMap.clear(),this.handle.dispose()}size(){return this.tensorMap.size}tensorSize(){return vY(this.size(),"int32")}async import(e,t){this.checkKeyAndValueTensor(e,t);const n=await e.data();return this.tensorMap.forEach((e=>e.dispose())),this.tensorMap.clear(),nX((()=>{const e=g0(t),a=n.length,r=e.length;AU(a===r,(()=>"The number of elements doesn't match, keys has "+"".concat(a," elements, the values has ").concat(r," ")+"elements."));for(let t=0;t<a;t++){const a=n[t],r=e[t];rX(r),this.tensorMap.set(a,r)}return this.handle}))}async find(e,t){this.checkKeyAndValueTensor(e,t);const n=await e.data();return nX((()=>{const e=[];for(let a=0;a<n.length;a++){const r=n[a],o=this.findWithDefault(r,t);e.push(o)}return $$(e)}))}findWithDefault(e,t){const n=this.tensorMap.get(e);return null!=n?n:t}checkKeyAndValueTensor(e,t){if(e.dtype!==this.keyDType)throw new Error("Expect key dtype ".concat(this.keyDType,", but got ")+"".concat(e.dtype));if(t.dtype!==this.valueDType)throw new Error("Expect value dtype ".concat(this.valueDType,", but got ")+"".concat(t.dtype))}}function vue(e,t,n,a){let r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:nX;const o=((e,t,n)=>{switch(e.category){case"arithmetic":return r((()=>function(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:_;switch(e.op){case"BiasAdd":case"AddV2":case"Add":return[a.add(wle("a",e,t,n),wle("b",e,t,n))];case"AddN":return[a.addN(wle("tensors",e,t,n))];case"FloorMod":case"Mod":return[a.mod(wle("a",e,t,n),wle("b",e,t,n))];case"Mul":return[a.mul(wle("a",e,t,n),wle("b",e,t,n))];case"RealDiv":case"Div":return[a.div(wle("a",e,t,n),wle("b",e,t,n))];case"DivNoNan":return[a.divNoNan(wle("a",e,t,n),wle("b",e,t,n))];case"FloorDiv":return[a.floorDiv(wle("a",e,t,n),wle("b",e,t,n))];case"Sub":return[a.sub(wle("a",e,t,n),wle("b",e,t,n))];case"Minimum":return[a.minimum(wle("a",e,t,n),wle("b",e,t,n))];case"Maximum":return[a.maximum(wle("a",e,t,n),wle("b",e,t,n))];case"Pow":return[a.pow(wle("a",e,t,n),wle("b",e,t,n))];case"SquaredDifference":return[a.squaredDifference(wle("a",e,t,n),wle("b",e,t,n))];default:throw TypeError("Node type ".concat(e.op," is not implemented"))}}(e,t,n)));case"basic_math":return r((()=>function(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:_;switch(e.op){case"Abs":case"ComplexAbs":return[a.abs(wle("x",e,t,n))];case"Acos":return[a.acos(wle("x",e,t,n))];case"Acosh":return[a.acosh(wle("x",e,t,n))];case"Asin":return[a.asin(wle("x",e,t,n))];case"Asinh":return[a.asinh(wle("x",e,t,n))];case"Atan":return[a.atan(wle("x",e,t,n))];case"Atan2":return[a.atan2(wle("x",e,t,n),wle("y",e,t,n))];case"Atanh":return[a.atanh(wle("x",e,t,n))];case"Ceil":return[a.ceil(wle("x",e,t,n))];case"Complex":return[a.complex(wle("real",e,t,n),wle("imag",e,t,n))];case"Cos":return[a.cos(wle("x",e,t,n))];case"Cosh":return[a.cosh(wle("x",e,t,n))];case"Elu":return[a.elu(wle("x",e,t,n))];case"Erf":return[a.erf(wle("x",e,t,n))];case"Exp":return[a.exp(wle("x",e,t,n))];case"Expm1":return[a.expm1(wle("x",e,t,n))];case"Floor":return[a.floor(wle("x",e,t,n))];case"Log":return[a.log(wle("x",e,t,n))];case"Log1p":return[a.log1p(wle("x",e,t,n))];case"Imag":return[a.imag(wle("x",e,t,n))];case"Neg":return[a.neg(wle("x",e,t,n))];case"Reciprocal":return[a.reciprocal(wle("x",e,t,n))];case"Real":return[a.real(wle("x",e,t,n))];case"Relu":return[a.relu(wle("x",e,t,n))];case"Round":return[a.round(wle("x",e,t,n))];case"Selu":return[a.selu(wle("x",e,t,n))];case"Sigmoid":return[a.sigmoid(wle("x",e,t,n))];case"Sin":return[a.sin(wle("x",e,t,n))];case"Sign":return[a.sign(wle("x",e,t,n))];case"Sinh":return[a.sinh(wle("x",e,t,n))];case"Softplus":return[a.softplus(wle("x",e,t,n))];case"Sqrt":return[a.sqrt(wle("x",e,t,n))];case"Square":return[a.square(wle("x",e,t,n))];case"Tanh":return[a.tanh(wle("x",e,t,n))];case"Tan":return[a.tan(wle("x",e,t,n))];case"ClipByValue":return[a.clipByValue(wle("x",e,t,n),wle("clipValueMin",e,t,n),wle("clipValueMax",e,t,n))];case"Relu6":return[a.relu6(wle("x",e,t,n))];case"Rsqrt":return[a.rsqrt(kle(e.inputNames[0],t,n))];case"LeakyRelu":return[a.leakyRelu(wle("x",e,t,n),wle("alpha",e,t,n))];case"Prelu":return[a.prelu(wle("x",e,t,n),wle("alpha",e,t,n))];case"IsNan":return[a.isNaN(kle(e.inputNames[0],t,n))];case"IsInf":return[a.isInf(kle(e.inputNames[0],t,n))];case"IsFinite":return[a.isFinite(kle(e.inputNames[0],t,n))];default:throw TypeError("Node type ".concat(e.op," is not implemented"))}}(e,t,n)));case"control":return gue(e,t,n);case"convolution":return r((()=>function(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:_;switch(e.op){case"Conv1D":{const r=wle("stride",e,t,n),o=wle("pad",e,t,n),s=wle("dataFormat",e,t,n).toUpperCase(),i=wle("dilation",e,t,n);return[a.conv1d(wle("x",e,t,n),wle("filter",e,t,n),r,o,s,i)]}case"Conv2D":{const r=wle("strides",e,t,n),o=Tle(e,t,n),s=wle("dataFormat",e,t,n).toUpperCase(),i=wle("dilations",e,t,n);return[a.conv2d(wle("x",e,t,n),wle("filter",e,t,n),[r[1],r[2]],o,s,[i[1],i[2]])]}case"_FusedConv2D":{const{stride:r,pad:o,dataFormat:s,dilations:i,biasArg:c,preluArg:l,activationFunc:u,leakyreluAlpha:d}=bue(e,t,n);return[a.fused.conv2d({x:wle("x",e,t,n),filter:wle("filter",e,t,n),strides:[r[1],r[2]],pad:o,dataFormat:s,dilations:[i[1],i[2]],bias:c,activation:u,preluActivationWeights:l,leakyreluAlpha:d})]}case"FusedDepthwiseConv2dNative":{const{stride:r,pad:o,dataFormat:s,dilations:i,biasArg:c,preluArg:l,activationFunc:u,leakyreluAlpha:d}=bue(e,t,n);return[a.fused.depthwiseConv2d({x:wle("x",e,t,n),filter:wle("filter",e,t,n),strides:[r[1],r[2]],pad:o,dataFormat:s,dilations:[i[1],i[2]],bias:c,activation:u,preluActivationWeights:l,leakyreluAlpha:d})]}case"Conv2DBackpropInput":case"Conv2dTranspose":{const r=wle("outputShape",e,t,n),o=wle("strides",e,t,n),s=Tle(e,t,n);return[a.conv2dTranspose(wle("x",e,t,n),wle("filter",e,t,n),r,[o[1],o[2]],s)]}case"DepthwiseConv2dNative":case"DepthwiseConv2d":{const r=wle("strides",e,t,n),o=Tle(e,t,n),s=wle("dilations",e,t,n),i=wle("dataFormat",e,t,n).toUpperCase();return[a.depthwiseConv2d(wle("input",e,t,n),wle("filter",e,t,n),[r[1],r[2]],o,i,[s[1],s[2]])]}case"Conv3D":{const r=wle("strides",e,t,n),o=wle("pad",e,t,n),s=wle("dataFormat",e,t,n).toUpperCase(),i=wle("dilations",e,t,n);return[a.conv3d(wle("x",e,t,n),wle("filter",e,t,n),[r[1],r[2],r[3]],o,s,[i[1],i[2],i[3]])]}case"AvgPool":{const r=wle("strides",e,t,n),o=wle("pad",e,t,n),s=wle("kernelSize",e,t,n);return[a.avgPool(wle("x",e,t,n),[s[1],s[2]],[r[1],r[2]],o)]}case"MaxPool":{const r=wle("strides",e,t,n),o=wle("pad",e,t,n),s=wle("kernelSize",e,t,n);return[a.maxPool(wle("x",e,t,n),[s[1],s[2]],[r[1],r[2]],o)]}case"MaxPoolWithArgmax":{const r=wle("strides",e,t,n),o=wle("pad",e,t,n),s=wle("kernelSize",e,t,n),i=wle("includeBatchInIndex",e,t,n),{result:c,indexes:l}=a.maxPoolWithArgmax(wle("x",e,t,n),[s[1],s[2]],[r[1],r[2]],o,i);return[c,l]}case"AvgPool3D":{const r=wle("strides",e,t,n),o=wle("pad",e,t,n),s=wle("kernelSize",e,t,n);return[a.avgPool3d(wle("x",e,t,n),[s[1],s[2],s[3]],[r[1],r[2],r[3]],o)]}case"MaxPool3D":{const r=wle("strides",e,t,n),o=wle("pad",e,t,n),s=wle("kernelSize",e,t,n);return[a.maxPool3d(wle("x",e,t,n),[s[1],s[2],s[3]],[r[1],r[2],r[3]],o)]}case"Dilation2D":{const r=wle("strides",e,t,n),o=wle("pad",e,t,n),s=wle("dilations",e,t,n),i=r[1],c=r[2],l=s[1],u=s[2];return[a.dilation2d(wle("x",e,t,n),wle("filter",e,t,n),[i,c],o,[l,u],"NHWC")]}default:throw TypeError("Node type ".concat(e.op," is not implemented"))}}(e,t,n)));case"creation":return r((()=>function(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:_;switch(e.op){case"Fill":{const r=wle("shape",e,t,n),o=wle("dtype",e,t,n),s=wle("value",e,t,n);return[a.fill(r,s,o)]}case"LinSpace":{const r=wle("start",e,t,n),o=wle("stop",e,t,n),s=wle("num",e,t,n);return[a.linspace(r,o,s)]}case"Multinomial":{const r=wle("logits",e,t,n),o=wle("numSamples",e,t,n),s=wle("seed",e,t,n);return[a.multinomial(r,o,s)]}case"OneHot":{const r=wle("indices",e,t,n),o=wle("depth",e,t,n),s=wle("onValue",e,t,n),i=wle("offValue",e,t,n),c=wle("dtype",e,t,n);return[a.oneHot(r,o,s,i,c)]}case"Ones":return[a.ones(wle("shape",e,t,n),wle("dtype",e,t,n))];case"OnesLike":return[a.onesLike(wle("x",e,t,n))];case"RandomStandardNormal":return[a.randomStandardNormal(wle("shape",e,t,n),wle("dtype",e,t,n),wle("seed",e,t,n))];case"RandomUniform":return[a.randomUniform(wle("shape",e,t,n),wle("minval",e,t,n),wle("maxval",e,t,n),wle("dtype",e,t,n))];case"RandomUniformInt":return[a.randomUniformInt(wle("shape",e,t,n),wle("minval",e,t,n),wle("maxval",e,t,n),wle("seed",e,t,n))];case"Range":{const r=wle("start",e,t,n),o=wle("stop",e,t,n),s=wle("step",e,t,n);return[a.range(r,o,s,wle("dtype",e,t,n))]}case"TruncatedNormal":{const r=wle("shape",e,t,n),o=wle("mean",e,t,n),s=wle("stdDev",e,t,n),i=wle("seed",e,t,n);return[a.truncatedNormal(r,o,s,wle("dtype",e,t,n),i)]}case"Zeros":return[a.zeros(wle("shape",e,t,n),wle("dtype",e,t,n))];case"ZerosLike":return[a.zerosLike(wle("x",e,t,n))];default:throw TypeError("Node type ".concat(e.op," is not implemented"))}}(e,t,n)));case"dynamic":return async function(e,t,n,a){let r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:_;switch(e.op){case"NonMaxSuppressionV5":{const{boxes:a,scores:o,maxOutputSize:s,iouThreshold:i,scoreThreshold:c,softNmsSigma:l}=yue(e,t,n),u=await r.image.nonMaxSuppressionWithScoreAsync(a,o,s,i,c,l);return[u.selectedIndices,u.selectedScores]}case"NonMaxSuppressionV4":{const{boxes:a,scores:o,maxOutputSize:s,iouThreshold:i,scoreThreshold:c}=yue(e,t,n),l=wle("padToMaxOutputSize",e,t,n),u=await r.image.nonMaxSuppressionPaddedAsync(a,o,s,i,c,l);return[u.selectedIndices,u.validOutputs]}case"NonMaxSuppressionV3":case"NonMaxSuppressionV2":{const{boxes:a,scores:o,maxOutputSize:s,iouThreshold:i,scoreThreshold:c}=yue(e,t,n);return[await r.image.nonMaxSuppressionAsync(a,o,s,i,c)]}case"Where":{const a=r.cast(wle("condition",e,t,n),"bool"),o=[await r.whereAsync(a)];return a.dispose(),o}case"ListDiff":return r.setdiff1dAsync(wle("x",e,t,n),wle("y",e,t,n));default:throw TypeError("Node type ".concat(e.op," is not implemented"))}}(e,t,n);case"evaluation":return r((()=>function(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:_;switch(e.op){case"LowerBound":{const r=wle("sortedSequence",e,t,n),o=wle("values",e,t,n);return[a.lowerBound(r,o)]}case"TopKV2":{const r=wle("x",e,t,n),o=wle("k",e,t,n),s=wle("sorted",e,t,n),i=a.topk(r,o,s);return[i.values,i.indices]}case"UpperBound":{const r=wle("sortedSequence",e,t,n),o=wle("values",e,t,n);return[a.upperBound(r,o)]}case"Unique":{const r=wle("x",e,t,n),o=a.unique(r);return[o.values,o.indices]}case"UniqueV2":{const r=wle("x",e,t,n),o=wle("axis",e,t,n),s=a.unique(r,o);return[s.values,s.indices]}default:throw TypeError("Node type ".concat(e.op," is not implemented"))}}(e,t,n)));case"image":return r((()=>function(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:_;switch(e.op){case"ResizeBilinear":{const r=wle("images",e,t,n),o=wle("size",e,t,n),s=wle("alignCorners",e,t,n),i=wle("halfPixelCenters",e,t,n);return[a.image.resizeBilinear(r,[o[0],o[1]],s,i)]}case"ResizeNearestNeighbor":{const r=wle("images",e,t,n),o=wle("size",e,t,n),s=wle("alignCorners",e,t,n),i=wle("halfPixelCenters",e,t,n);return[a.image.resizeNearestNeighbor(r,[o[0],o[1]],s,i)]}case"CropAndResize":{const r=wle("image",e,t,n),o=wle("boxes",e,t,n),s=wle("boxInd",e,t,n),i=wle("cropSize",e,t,n),c=wle("method",e,t,n),l=wle("extrapolationValue",e,t,n);return[a.image.cropAndResize(r,o,s,i,c,l)]}case"ImageProjectiveTransformV3":{const r=wle("images",e,t,n),o=wle("transforms",e,t,n),s=wle("outputShape",e,t,n),i=wle("fillValue",e,t,n),c=wle("interpolation",e,t,n),l=wle("fillMode",e,t,n);return[a.image.transform(r,o,c.toLowerCase(),l.toLowerCase(),i,s)]}default:throw TypeError("Node type ".concat(e.op," is not implemented"))}}(e,t,n)));case"graph":return r((()=>function(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:_;switch(e.op){case"Const":return t[e.name];case"PlaceholderWithDefault":const r=wle("default",e,t,n);return[kle(e.name,t,n)||r];case"Placeholder":return[kle(e.name,t,n)];case"Identity":case"StopGradient":case"FakeQuantWithMinMaxVars":case"Snapshot":return[Ele(wle("x",e,t,n))];case"IdentityN":return wle("x",e,t,n).map((e=>Ele(e)));case"Shape":return[a.tensor1d(wle("x",e,t,n).shape,"int32")];case"ShapeN":return wle("x",e,t,n).map((e=>a.tensor1d(e.shape)));case"Size":return[a.scalar(wle("x",e,t,n).size,"int32")];case"Rank":return[a.scalar(wle("x",e,t,n).rank,"int32")];case"NoOp":return[a.scalar(1)];case"Print":const o=wle("x",e,t,n),s=wle("data",e,t,n),i=wle("message",e,t,n),c=wle("summarize",e,t,n);console.warn("The graph has a tf.print() operation,usually used for debugging, which slows down performance."),console.log(i);for(let e=0;e<s.length;e++)console.log(Array.prototype.slice.call(s[e].dataSync()).slice(0,c));return[o];default:throw TypeError("Node type ".concat(e.op," is not implemented"))}}(e,t,n)));case"logical":return r((()=>function(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:_;switch(e.op){case"Equal":return[a.equal(wle("a",e,t,n),wle("b",e,t,n))];case"NotEqual":return[a.notEqual(wle("a",e,t,n),wle("b",e,t,n))];case"Greater":return[a.greater(wle("a",e,t,n),wle("b",e,t,n))];case"GreaterEqual":return[a.greaterEqual(wle("a",e,t,n),wle("b",e,t,n))];case"Less":return[a.less(wle("a",e,t,n),wle("b",e,t,n))];case"LessEqual":return[a.lessEqual(wle("a",e,t,n),wle("b",e,t,n))];case"LogicalAnd":return[a.logicalAnd(wle("a",e,t,n),wle("b",e,t,n))];case"LogicalNot":return[a.logicalNot(wle("a",e,t,n))];case"LogicalOr":return[a.logicalOr(wle("a",e,t,n),wle("b",e,t,n))];case"Select":case"SelectV2":return[a.where(wle("condition",e,t,n),wle("a",e,t,n),wle("b",e,t,n))];case"BitwiseAnd":return[a.bitwiseAnd(wle("a",e,t,n),wle("b",e,t,n))];default:throw TypeError("Node type ".concat(e.op," is not implemented"))}}(e,t,n)));case"matrices":return r((()=>function(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:_;switch(e.op){case"BatchMatMul":case"BatchMatMulV2":case"MatMul":return[a.matMul(wle("a",e,t,n),wle("b",e,t,n),wle("transposeA",e,t,n),wle("transposeB",e,t,n))];case"Einsum":return[a.einsum(wle("equation",e,t,n),...wle("tensors",e,t,n))];case"Transpose":return[a.transpose(wle("x",e,t,n),wle("perm",e,t,n))];case"_FusedMatMul":const[r,o]=wle("fusedOps",e,t,n),s="biasadd"===r,i="prelu"===o,c=wle("numArgs",e,t,n),l=wle("leakyreluAlpha",e,t,n);if(s){if(i&&2!==c)throw new Error("Fused MatMul with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!i&&1!==c)throw new Error("Fused MatMul with BiasAdd must have one extra argument: bias.")}const[u,d]=wle("args",e,t,n);return[a.fused.matMul({a:wle("a",e,t,n),b:wle("b",e,t,n),transposeA:wle("transposeA",e,t,n),transposeB:wle("transposeB",e,t,n),bias:u,activation:o,preluActivationWeights:d,leakyreluAlpha:l})];case"MatrixBandPart":return[a.linalg.bandPart(wle("a",e,t,n),wle("numLower",e,t,n),wle("numUpper",e,t,n))];default:throw TypeError("Node type ".concat(e.op," is not implemented"))}}(e,t,n)));case"normalization":return r((()=>function(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:_;switch(e.op){case"EuclideanNorm":return[a.euclideanNorm(wle("x",e,t,n),wle("axis",e,t,n),wle("keepDims",e,t,n))];case"FusedBatchNorm":case"FusedBatchNormV2":case"FusedBatchNormV3":return[a.batchNorm(wle("x",e,t,n),wle("mean",e,t,n),wle("variance",e,t,n),wle("offset",e,t,n),wle("scale",e,t,n),wle("epsilon",e,t,n))];case"LRN":return[a.localResponseNormalization(wle("x",e,t,n),wle("radius",e,t,n),wle("bias",e,t,n),wle("alpha",e,t,n),wle("beta",e,t,n))];case"Softmax":return[a.softmax(wle("x",e,t,n))];case"LogSoftmax":return[a.logSoftmax(wle("x",e,t,n))];default:throw TypeError("Node type ".concat(e.op," is not implemented"))}}(e,t,n)));case"ragged":return r((()=>function(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:_;switch(e.op){case"RaggedGather":{const{outputNestedSplits:r,outputDenseValues:o}=a.raggedGather(wle("paramsNestedSplits",e,t,n),wle("paramsDenseValues",e,t,n),wle("indices",e,t,n),wle("outputRaggedRank",e,t,n));return r.concat(o)}case"RaggedRange":{const{rtNestedSplits:r,rtDenseValues:o}=a.raggedRange(wle("starts",e,t,n),wle("limits",e,t,n),wle("splits",e,t,n));return[r,o]}case"RaggedTensorToTensor":return[a.raggedTensorToTensor(wle("shape",e,t,n),wle("values",e,t,n),wle("defaultValue",e,t,n),wle("rowPartitionTensors",e,t,n),wle("rowPartitionTypes",e,t,n))];default:throw TypeError("Node type ".concat(e.op," is not implemented"))}}(e,t,n)));case"reduction":return r((()=>function(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:_;switch(e.op){case"Max":{const r=wle("axis",e,t,n),o=wle("keepDims",e,t,n);return[a.max(wle("x",e,t,n),r,o)]}case"Mean":{const r=wle("axis",e,t,n),o=wle("keepDims",e,t,n);return[a.mean(wle("x",e,t,n),r,o)]}case"Min":{const r=wle("axis",e,t,n),o=wle("keepDims",e,t,n);return[a.min(wle("x",e,t,n),r,o)]}case"Sum":{const r=wle("axis",e,t,n),o=wle("keepDims",e,t,n);return[a.sum(wle("x",e,t,n),r,o)]}case"All":{const r=wle("axis",e,t,n),o=wle("keepDims",e,t,n);return[a.all(wle("x",e,t,n),r,o)]}case"Any":{const r=wle("axis",e,t,n),o=wle("keepDims",e,t,n);return[a.any(wle("x",e,t,n),r,o)]}case"ArgMax":{const r=wle("axis",e,t,n);return[a.argMax(wle("x",e,t,n),r)]}case"ArgMin":{const r=wle("axis",e,t,n);return[a.argMin(wle("x",e,t,n),r)]}case"Prod":{const r=wle("axis",e,t,n),o=wle("keepDims",e,t,n);return[a.prod(wle("x",e,t,n),r,o)]}case"Cumprod":{const r=wle("axis",e,t,n),o=wle("exclusive",e,t,n),s=wle("reverse",e,t,n);return[a.cumprod(wle("x",e,t,n),r,o,s)]}case"Cumsum":{const r=wle("axis",e,t,n),o=wle("exclusive",e,t,n),s=wle("reverse",e,t,n);return[a.cumsum(wle("x",e,t,n),r,o,s)]}case"Bincount":const r=wle("x",e,t,n),o=wle("weights",e,t,n),s=wle("size",e,t,n);return[a.bincount(r,o,s)];case"DenseBincount":{const r=wle("x",e,t,n),o=wle("weights",e,t,n),s=wle("size",e,t,n),i=wle("binaryOutput",e,t,n);return[a.denseBincount(r,o,s,i)]}default:throw TypeError("Node type ".concat(e.op," is not implemented"))}}(e,t,n)));case"slice_join":return r((()=>function(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:_;switch(e.op){case"ConcatV2":case"Concat":{const r=wle("n",e,t,n),o=wle("axis",e,t,n);let s=wle("tensors",e,t,n);return s=s.slice(0,r),[a.concat(s,o)]}case"Gather":{const r=wle("x",e,t,n),o=wle("indices",e,t,n);return[a.gather(r,a.cast(o,"int32"),0)]}case"GatherV2":{const r=wle("axis",e,t,n),o=wle("batchDims",e,t,n),s=wle("x",e,t,n),i=wle("indices",e,t,n);return[a.gather(s,a.cast(i,"int32"),r,o)]}case"Reverse":{const r=wle("dims",e,t,n),o=[];for(let e=0;e<r.length;e++)r[e]&&o.push(e);const s=wle("x",e,t,n);return[a.reverse(s,o)]}case"ReverseV2":{const r=wle("axis",e,t,n),o=wle("x",e,t,n);return[a.reverse(o,r)]}case"Slice":{const r=wle("begin",e,t,n),o=wle("size",e,t,n);return[a.slice(wle("x",e,t,n),r,o)]}case"StridedSlice":{const r=wle("begin",e,t,n),o=wle("end",e,t,n),s=wle("strides",e,t,n),i=wle("beginMask",e,t,n),c=wle("endMask",e,t,n),l=wle("ellipsisMask",e,t,n),u=wle("newAxisMask",e,t,n),d=wle("shrinkAxisMask",e,t,n),h=wle("x",e,t,n);return[a.stridedSlice(h,r,o,s,i,c,l,u,d)]}case"Pack":return nX((()=>{const r=wle("axis",e,t,n),o=wle("tensors",e,t,n),s=o[0].shape,i=a.squeeze(o[0]).shape,c=o.map((e=>{const t=MU(e.shape,s);if(!t&&!MU(a.squeeze(e).shape,i))throw new Error("the input tensors shape does not match");return t?e:a.reshape(e,s)}));return[a.stack(c,r)]}));case"Unpack":{const r=wle("axis",e,t,n),o=wle("tensor",e,t,n);return a.unstack(o,r)}case"Tile":{const r=wle("reps",e,t,n);return[a.tile(wle("x",e,t,n),r)]}case"Split":case"SplitV":{const r=wle("axis",e,t,n),o=wle("numOrSizeSplits",e,t,n),s=wle("x",e,t,n);return a.split(s,o,r)}case"ScatterNd":{const r=wle("indices",e,t,n),o=wle("values",e,t,n),s=wle("shape",e,t,n);return[a.scatterND(r,o,s)]}case"GatherNd":{const r=wle("x",e,t,n),o=wle("indices",e,t,n);return[a.gatherND(r,o)]}case"SparseToDense":{const r=wle("sparseIndices",e,t,n),o=wle("outputShape",e,t,n),s=wle("sparseValues",e,t,n),i=wle("defaultValue",e,t,n);return[a.sparseToDense(r,s,o,s.dtype===i.dtype?i:a.cast(i,s.dtype))]}case"TensorScatterUpdate":{const r=wle("indices",e,t,n),o=wle("values",e,t,n),s=wle("tensor",e,t,n);return[a.tensorScatterUpdate(s,r,o)]}default:throw TypeError("Node type ".concat(e.op," is not implemented"))}}(e,t,n)));case"sparse":return r((()=>function(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:_;switch(e.op){case"SparseFillEmptyRows":{const{outputIndices:r,outputValues:o,emptyRowIndicator:s,reverseIndexMap:i}=a.sparse.sparseFillEmptyRows(wle("indices",e,t,n),wle("values",e,t,n),wle("denseShape",e,t,n),wle("defaultValue",e,t,n));return[r,o,s,i]}case"SparseReshape":{const{outputIndices:r,outputShape:o}=a.sparse.sparseReshape(wle("inputIndices",e,t,n),wle("inputShape",e,t,n),wle("newShape",e,t,n));return[r,o]}case"SparseSegmentMean":return[a.sparse.sparseSegmentMean(wle("data",e,t,n),wle("indices",e,t,n),wle("segmentIds",e,t,n))];case"SparseSegmentSum":return[a.sparse.sparseSegmentSum(wle("data",e,t,n),wle("indices",e,t,n),wle("segmentIds",e,t,n))];default:throw TypeError("Node type ".concat(e.op," is not implemented"))}}(e,t,n)));case"spectral":return r((()=>function(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:_;switch(e.op){case"FFT":return[a.fft(wle("x",e,t,n))];case"IFFT":return[a.ifft(wle("x",e,t,n))];case"RFFT":return[a.rfft(wle("x",e,t,n))];case"IRFFT":return[a.irfft(wle("x",e,t,n))];default:throw TypeError("Node type ".concat(e.op," is not implemented"))}}(e,t,n)));case"string":return r((()=>function(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:_;switch(e.op){case"StaticRegexReplace":return[a.string.staticRegexReplace(wle("input",e,t,n),wle("pattern",e,t,n),wle("rewrite",e,t,n),wle("replaceGlobal",e,t,n))];case"StringNGrams":{const{nGrams:r,nGramsSplits:o}=a.string.stringNGrams(wle("data",e,t,n),wle("dataSplits",e,t,n),wle("separator",e,t,n),wle("nGramWidths",e,t,n),wle("leftPad",e,t,n),wle("rightPad",e,t,n),wle("padWidth",e,t,n),wle("preserveShortSequences",e,t,n));return[r,o]}case"StringSplit":{const{indices:r,values:o,shape:s}=a.string.stringSplit(wle("input",e,t,n),wle("delimiter",e,t,n),wle("skipEmpty",e,t,n));return[r,o,s]}case"StringToHashBucketFast":return[a.string.stringToHashBucketFast(wle("input",e,t,n),wle("numBuckets",e,t,n))];default:throw TypeError("Node type ".concat(e.op," is not implemented"))}}(e,t,n)));case"transformation":return r((()=>function(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:_;switch(e.op){case"Cast":return[a.cast(wle("x",e,t,n),wle("dtype",e,t,n))];case"ExpandDims":{const r=wle("axis",e,t,n);return[a.expandDims(wle("x",e,t,n),r)]}case"Squeeze":{const r=wle("axis",e,t,n);return[a.squeeze(wle("x",e,t,n),r)]}case"Reshape":return[a.reshape(wle("x",e,t,n),wle("shape",e,t,n))];case"EnsureShape":return[a.ensureShape(wle("x",e,t,n),wle("shape",e,t,n))];case"MirrorPad":return[a.mirrorPad(wle("x",e,t,n),wle("padding",e,t,n),wle("mode",e,t,n))];case"PadV2":case"Pad":return[a.pad(wle("x",e,t,n),wle("padding",e,t,n),wle("constantValue",e,t,n))];case"SpaceToBatchND":{const r=wle("blockShape",e,t,n),o=wle("paddings",e,t,n);return[a.spaceToBatchND(wle("x",e,t,n),r,o)]}case"BatchToSpaceND":{const r=wle("blockShape",e,t,n),o=wle("crops",e,t,n);return[a.batchToSpaceND(wle("x",e,t,n),r,o)]}case"DepthToSpace":{const r=wle("blockSize",e,t,n),o=wle("dataFormat",e,t,n).toUpperCase();return[a.depthToSpace(wle("x",e,t,n),r,o)]}case"BroadcastTo":return[a.broadcastTo(wle("x",e,t,n),wle("shape",e,t,n))];case"BroadcastArgs":return[a.broadcastArgs(wle("s0",e,t,n),wle("s1",e,t,n))];default:throw TypeError("Node type ".concat(e.op," is not implemented"))}}(e,t,n)));case"hash_table":return(async(e,t,n,a)=>{switch(e.op){case"HashTable":case"HashTableV2":{const r=a.getHashTableHandleByName(e.name);if(null!=r)return[r];{const r=wle("keyDType",e,t,n),o=wle("valueDType",e,t,n),s=new xue(r,o);return a.addHashTable(e.name,s),[s.handle]}}case"InitializeTable":case"InitializeTableV2":case"LookupTableImport":case"LookupTableImportV2":{const r=wle("tableHandle",e,t,n,a),o=wle("keys",e,t,n),s=wle("values",e,t,n),i=a.getHashTableById(r.id);return[await i.import(o,s)]}case"LookupTableFind":case"LookupTableFindV2":{const r=wle("tableHandle",e,t,n,a),o=wle("keys",e,t,n),s=wle("defaultValue",e,t,n),i=a.getHashTableById(r.id);return[await i.find(o,s)]}case"LookupTableSize":case"LookupTableSizeV2":{const r=wle("tableHandle",e,t,n,a);return[a.getHashTableById(r.id).tensorSize()]}default:throw TypeError("Node type ".concat(e.op," is not implemented"))}})(e,t,n,a);case"custom":const o=vle(e.op);if(o&&o.customExecutor)return o.customExecutor(new lue(e,t,n));throw TypeError("Custom op ".concat(e.op," is not registered."));default:throw TypeError("Unknown op '".concat(e.op,"'. File an issue at ")+"https://github.com/tensorflow/tfjs/issues so we can add it, or register a custom execution with tf.registerOp()")}})(e,t,n);return sG(o)?o.then((e=>[].concat(e))):[].concat(o)}class wue{constructor(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{},a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{},r=arguments.length>4?arguments[4]:void 0;this.weightMap=e,this.tensorArrayMap=t,this.tensorListMap=n,this.functionMap=a,this.parseNodeNameCache=r,this.rootContext={id:0,frameName:"",iterationId:0},this.contexts=[this.rootContext],this.lastId=0,this.generateCurrentContextIds()}newFrame(e,t){return{id:e,frameName:t,iterationId:0}}set currentContext(e){this.contexts!==e&&(this.contexts=e,this.generateCurrentContextIds())}get currentContext(){return this.contexts}get currentContextId(){return this._currentContextIds[0]}get currentContextIds(){return this._currentContextIds}generateCurrentContextIds(){const e=[];for(let t=0;t<this.contexts.length-1;t++){const n=this.contexts.slice(0,this.contexts.length-t);e.push(this.contextIdforContexts(n))}e.push(""),this._currentContextIds=e}contextIdforContexts(e){return e?e.map((e=>0===e.id&&0===e.iterationId?"":"".concat(e.frameName,"-").concat(e.iterationId))).join("/"):""}enterFrame(e){this.contexts&&(this.lastId++,this.contexts=this.contexts.slice(),this.contexts.push(this.newFrame(this.lastId,e)),this._currentContextIds.unshift(this.contextIdforContexts(this.contexts)))}exitFrame(){if(!(this.contexts&&this.contexts.length>1))throw new Error("Cannot exit frame, the context is empty");this.contexts=this.contexts.slice(),this.contexts.splice(-1),this.currentContextIds.shift()}nextIteration(){if(!(this.contexts&&this.contexts.length>0))throw new Error("Cannot increase frame iteration, the context is empty");{this.contexts=this.contexts.slice(),this.lastId++;const e=Object.assign({},this.contexts[this.contexts.length-1]);e.iterationId+=1,e.id=this.lastId,this.contexts.splice(-1,1,e),this._currentContextIds.splice(0,1,this.contextIdforContexts(this.contexts))}}getWeight(e){return this.weightMap[e]}addTensorArray(e){this.tensorArrayMap[e.id]=e}getTensorArray(e){return this.tensorArrayMap[e]}addTensorList(e){this.tensorListMap[e.id]=e}getTensorList(e){return this.tensorListMap[e]}dispose(e){for(const t in this.tensorArrayMap)this.tensorArrayMap[t].clearAndClose(e);for(const t in this.tensorListMap)this.tensorListMap[t].clearAndClose(e)}}function kue(e,t,n,a){const r=new Set,o=[];let s=null,i=null;const c=new Set,l=new Set(Object.keys(e).map((e=>Cle(e)[0])));a=a||[];const u=new Set(a.map((e=>Cle(e.name)[0]))),d=[...t];for(;d.length>0;){const e=d.pop();(Eue(e)||Rue(e)||_ue(e))&&null==s&&(s=e,i=s.children.map((e=>e.name)).filter((e=>r.has(e)))),r.add(e.name),null==n[e.name]&&(l.has(e.name)||u.has(e.name)||(0!==e.inputs.length?e.inputs.forEach((e=>{c.has(e.name)||(c.add(e.name),d.push(e))})):o.push(e.name)))}return{inputs:e,outputs:t,usedNodes:r,missingInputs:o,dynamicNode:s,syncInputs:i}}function Iue(e,t){const{usedNodes:n,inputs:a}=t,r=Object.keys(a).map((e=>Cle(e)[0])).map((t=>e.nodes[t])),o=e.initNodes||[],s=e=>n.has("string"===typeof e?e:e.name);function i(e){return[...new Map(e.map((e=>[e.name,e]))).values()]}const c=i([...r,...e.weights,...o]).filter(s),l=i([...c,...Object.values(e.nodes)]).filter(s),u=new Map(l.map((e=>[e.name,e]))),d={};for(const m of l){d[m.name]=d[m.name]||0;for(const e of m.children)s(e)||(d[e.name]=Number.POSITIVE_INFINITY),d[e.name]=(d[e.name]||0)+1}const h=Object.entries(d).filter((e=>{let[,t]=e;return 0===t})).map((e=>{let[t]=e;return t})),p=[...h];for(;h.length>0;){const e=h.pop(),t=u.get(e);for(const n of t.children.filter(s))0===--d[n.name]&&(p.push(n.name),h.push(n.name))}const f=function(e,t){const n=new Map(e.map((e=>[e.name,e]))),a=t.map((e=>e.name)),r=new Set(a);for(;a.length>0;){const e=a.pop(),t=n.get(e);for(const o of t.children)n.has(o.name)&&!r.has(o.name)&&(r.add(o.name),a.push(o.name))}const o=e.filter((e=>r.has(e.name)));return o}(p.map((e=>u.get(e))),c);return function(e,t){const n=new Map(e.map(((e,t)=>[e.name,t]))),a=new Set(t.map((e=>e.name))),r=e=>a.has("string"===typeof e?e:e.name),o=new Set(e.map((e=>e.name))),s=e=>o.has("string"===typeof e?e:e.name);for(const i of e){for(const e of i.children.filter(s)){if(!n.has(e.name))throw new Sue("Child ".concat(e.name," of node ").concat(i.name," is unreachable."));if(n.get(i.name)>n.get(e.name))throw new Sue("Node ".concat(i.name," is scheduled to run after its child ").concat(e.name,"."))}if(!r(i))for(const e of i.inputs){if(!n.has(e.name))throw new Sue("Input ".concat(e.name," of node ").concat(i.name," is unreachable."));if(n.get(e.name)>n.get(i.name))throw new Sue("Node ".concat(i.name," is scheduled to run before its input ").concat(e.name,"."))}}}(f,c),f}class Sue extends Error{constructor(e){super("NodesExecutionOrderError: ".concat(e))}}const Nue=new Set(["Switch","Merge","Enter","Exit","NextIteration","StatelessIf","StatelessWhile","if","While"]),Cue=new Set(["NonMaxSuppressionV2","NonMaxSuppressionV3","NonMaxSuppressionV5","Where"]),Tue=new Set(["HashTable","HashTableV2","LookupTableImport","LookupTableImportV2","LookupTableFind","LookupTableFindV2","LookupTableSize","LookupTableSizeV2"]);function Eue(e){return Nue.has(e.op)}function Rue(e){return Cue.has(e.op)}function _ue(e){return Tue.has(e.op)}class Aue{get weightIds(){return this.parent?this.parent.weightIds:this._weightIds}get functionExecutorMap(){return this.parent?this.parent.functionExecutorMap:this._functionExecutorMap}get weightMap(){return this.parent?this.parent.weightMap:this._weightMap}set weightMap(e){const t=Object.keys(e).map((t=>e[t].map((e=>e.id))));this._weightIds=[].concat(...t),this._weightMap=e}set resourceManager(e){this._resourceManager=e}get inputs(){return this._inputs.map((e=>({name:e.name,shape:e.attrParams.shape?e.attrParams.shape.value:void 0,dtype:e.attrParams.dtype?e.attrParams.dtype.value:void 0})))}get outputs(){return this._outputs.map((e=>({name:e.name,shape:e.attrParams.shape?e.attrParams.shape.value:void 0,dtype:e.attrParams.dtype?e.attrParams.dtype.value:void 0})))}get inputNodes(){return this._inputs.map((e=>e.signatureKey||e.name))}get outputNodes(){return this._outputs.map((e=>{const t=e.signatureKey||e.name;return e.defaultOutput?"".concat(t,":").concat(e.defaultOutput):t}))}get functions(){return Object.keys(this._functions).reduce(((e,t)=>(e[t]=this._functions[t].signature,e)),{})}constructor(e,t){this.graph=e,this.parent=t,this.compiledMap=new Map,this.parseNodeNameCache=new Map,this._weightMap={},this.SEPARATOR=",",this._functions={},this._functionExecutorMap={},this.keepIntermediateTensors=!1,this._outputs=e.outputs,this._inputs=e.inputs,this._initNodes=e.initNodes,this._signature=e.signature,this._functions=e.functions,null!=e.functions&&Object.keys(e.functions).forEach((t=>{this._functionExecutorMap[t]=new Aue(e.functions[t],this)}))}getCompilationKey(e,t){const n=e.map((e=>e.name)).sort(),a=t.map((e=>e.name)).sort();return n.join(this.SEPARATOR)+"--"+a.join(this.SEPARATOR)}compile(e,t){const n=kue(e,t,this.weightMap,this._initNodes),{missingInputs:a,dynamicNode:r,syncInputs:o}=n;if(null!=r)throw new Error("This execution contains the node '".concat(r.name,"', which has ")+"the dynamic op '".concat(r.op,"'. Please use ")+"model.executeAsync() instead. Alternatively, to avoid the "+"dynamic ops, specify the inputs [".concat(o,"]"));if(a.length>0){const n=t.map((e=>e.name)),r=Object.keys(e);throw new Error("Cannot compute the outputs [".concat(n,"] from the provided inputs ")+"[".concat(r,"]. Missing the following inputs: [").concat(a,"]"))}const s=Iue(this.graph,n),i=function(e){const t=new Map(e.map(((e,t)=>[e.name,t]))),n=Number.MAX_SAFE_INTEGER,a=e.map(((e,t)=>Eue(e)?n:t)),r=e=>{const n=a[t.get(e.name)];return null==n?-1:n},o=e.map(((e,t)=>e.children.map(r).reduce(((e,t)=>Math.max(e,t)),a[t]))),s=new Map;for(let i=0;i<e.length;++i){const t=o[i];if(t===n)continue;const a=e[i],r=e[t];s.has(r.name)||s.set(r.name,[]),s.get(r.name).push(a)}return s}(s);return{orderedNodes:s,nodeLiveUntilMap:i}}cloneAndKeepTensor(e){if(null==e)return null;const t=e.clone();return rX(t),t}cloneTensorList(e){if(!e)return null;return e.map((e=>this.cloneAndKeepTensor(e)))}cloneTensorMap(e){return Object.fromEntries(Object.entries(e).map((e=>{let[t,n]=e;return[t,this.cloneTensorList(n)]})))}execute(e,t){this.disposeIntermediateTensors(),e=this.mapInputs(e);const n=Object.keys(e).sort();this.checkInputs(e),this.checkInputShapeAndType(e),t=this.mapOutputs(t),this.checkOutputs(t);const a=n.map((e=>this.graph.nodes[Cle(e)[0]])),r=t.map((e=>Cle(e)[0])),o=new Set(r);let s=r.map((e=>this.graph.nodes[e]));0===s.length&&(s=this._outputs);const i=this.getCompilationKey(a,s);let c=this.compiledMap.get(i);null==c&&(c=this.compile(e,s),this.compiledMap.set(i,c));try{this.keepIntermediateTensors=uG().getBool("KEEP_INTERMEDIATE_TENSORS")}catch(D){this.keepIntermediateTensors=!1,console.warn(D.message)}const l={},u={};return nX((()=>{const n=new wue(this.weightMap,l,u,this.functionExecutorMap,this.parseNodeNameCache),a=Object.assign({},this.weightMap);this.keepIntermediateTensors&&(this.clonedTensorsMap=this.cloneTensorMap(this.weightMap)),Object.keys(e).forEach((t=>{const[r,o]=Cle(t,n),s=[];s[o]=e[t],a[r]=s,this.keepIntermediateTensors&&(this.clonedTensorsMap[r]=this.cloneTensorList(s))}));const r=this.getFrozenTensorIds(a),{orderedNodes:s,nodeLiveUntilMap:i}=c;for(const e of s){if(a[e.name])continue;const t=vue(e,a,n,this._resourceManager);if(sG(t))throw new Error("The execution of the op '".concat(e.op,"' returned a promise. ")+"Please use model.executeAsync() instead.");a[e.name]=t,this.keepIntermediateTensors&&(this.clonedTensorsMap[e.name]=this.cloneTensorList(t)),this.checkTensorForDisposalWithNodeLiveUntilInfo(e,a,n,r,o,i.get(e.name))}return null==this.parent&&n.dispose(r),t.map((e=>kle(e,a,n)))}))}getFrozenTensorIds(e){const t=[].concat.apply([],Object.keys(e).map((t=>e[t])).map((e=>e.map((e=>e.id)))));return new Set(t)}checkTensorForDisposal(e,t,n,a,r,o,s){if(!Eue(t)&&!o.has(e)){for(const a of n[e])null!=a&&(s[a.id]=(s[a.id]||0)+t.children.length);for(const e of t.inputs){if(Eue(e))continue;const t=Ile(e.name,n,a);if(null!=t)for(const e of t){if(!e||e.kept||r.has(e.id))continue;const t=s[e.id];1===t?(e.dispose(),delete s[e.id]):null!=t&&s[e.id]--}}}}checkTensorForDisposalWithNodeLiveUntilInfo(e,t,n,a,r,o){function s(e){return Eue(e)||r.has(e.name)}if(!Eue(e)&&null!=o)for(const i of o){if(s(i))continue;const e=Ile(i.name,t,n);for(const t of e)!t||t.kept||a.has(t.id)||t.dispose()}}async executeAsync(e,t){return this._executeAsync(e,t)}disposeIntermediateTensors(){this.clonedTensorsMap&&(Object.values(this.clonedTensorsMap).forEach((e=>{for(const t of e)t&&!t.isDisposed&&t.dispose()})),this.clonedTensorsMap=null)}getIntermediateTensors(){return this.clonedTensorsMap}async _executeAsync(e,t){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{},r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:{};this.disposeIntermediateTensors(),n||(e=this.mapInputs(e),this.checkInputs(e),this.checkInputShapeAndType(e),t=this.mapOutputs(t),this.checkOutputs(t));try{this.keepIntermediateTensors=uG().getBool("KEEP_INTERMEDIATE_TENSORS")}catch(D){this.keepIntermediateTensors=!1,console.warn(D.message)}const o=new wue(this.weightMap,a,r,this.functionExecutorMap,this.parseNodeNameCache);this.keepIntermediateTensors&&(this.clonedTensorsMap=this.cloneTensorMap(this.weightMap));const s=await this.executeWithControlFlow(e,o,t,n),i=t.map((e=>kle(e,s,o))),c=i.map((e=>e.id)),l=Object.keys(e).map((t=>e[t].id)),u=new Set([...c,...l,...this.weightIds]);return Object.values(s).forEach((e=>{e.forEach((e=>{!e||e.isDisposed||u.has(e.id)||e.dispose()}))})),null==this.parent&&o.dispose(u),i}async executeFunctionAsync(e,t,n){const a=e.reduce(((e,t,n)=>(e[this.inputs[n].name]=t,e)),{});return this._executeAsync(a,this.outputNodes,!0,t,n)}async executeWithControlFlow(e,t,n,a){const r=Object.keys(e),o=r.map((e=>this.graph.nodes[Cle(e)[0]])),s=n.map((e=>Cle(e)[0])),i=new Set(s);let c=s.map((e=>this.graph.nodes[e]));0===c.length&&(c=this._outputs);const{usedNodes:l,missingInputs:u,dynamicNode:d,syncInputs:h}=kue(e,c,this.weightMap,this._initNodes),p=[...o,...this.graph.weights,...this._initNodes||[]].map((e=>({node:e,contexts:t.currentContext}))),f=Object.assign({},this.weightMap);Object.keys(e).forEach((t=>{const[n,a]=Cle(t),r=[];r[a]=e[t],f[n]=r}));const m={},g=this.getFrozenTensorIds(f),b={};for(;p.length>0;){const e=this.processStack(o,p,t,f,b,g,i,m,l);await Promise.all(e)}null!=d||a||console.warn("This model execution did not contain any nodes with control flow or dynamic output shapes. You can use model.execute() instead.");const y=c.filter((e=>!Eue(e)&&!kle(e.name,f,t))).map((e=>e.name));if(y.length>0){let e="";throw null!=d&&(e="Alternatively, to avoid the dynamic ops, use model.execute() "+"and specify the inputs [".concat(h,"]")),new Error("Cannot compute the outputs [".concat(y,"] from the provided ")+"inputs [".concat(r,"]. Consider providing the following inputs: ")+"[".concat(u,"]. ").concat(e))}return f}processStack(e,t,n,a,r,o,s,i,c){const l=[];for(;t.length>0;){const e=t.pop();n.currentContext=e.contexts;let u="";if("Enter"===e.node.op&&wle("isConstant",e.node,a,n)&&([u]=Sle(e.node.name,n)),null==a[e.node.name]){const d=vue(e.node,a,n,this._resourceManager);u||([u]=Sle(e.node.name,n));const h=n.currentContext;sG(d)?l.push(d.then((l=>(a[u]=l,this.keepIntermediateTensors&&(this.clonedTensorsMap[u]=this.cloneTensorList(l)),n.currentContext=h,this.checkTensorForDisposal(u,e.node,a,n,o,s,i),this.processChildNodes(e.node,t,n,a,r,c),l)))):(a[u]=d,this.keepIntermediateTensors&&(this.clonedTensorsMap[u]=this.cloneTensorList(d)),this.checkTensorForDisposal(u,e.node,a,n,o,s,i),this.processChildNodes(e.node,t,n,a,r,c))}else this.processChildNodes(e.node,t,n,a,r,c)}return l}processChildNodes(e,t,n,a,r,o){e.children.forEach((e=>{const[s]=Sle(e.name,n);!r[s]&&o.has(e.name)&&("Merge"===e.op?e.inputNames.some((e=>!!kle(e,a,n)))&&(r[s]=!0,t.push({contexts:n.currentContext,node:e})):e.inputNames.every((e=>!!kle(e,a,n)))&&(r[s]=!0,t.push({contexts:n.currentContext,node:e})))}))}dispose(){Object.keys(this.weightMap).forEach((e=>this.weightMap[e].forEach((e=>e.dispose()))))}checkInputShapeAndType(e){Object.keys(e).forEach((t=>{const n=e[t],[a]=Cle(t),r=this.graph.nodes[a];if(r.attrParams.shape&&r.attrParams.shape.value){const e=r.attrParams.shape.value;AU(e.length===n.shape.length&&n.shape.every(((t,n)=>-1===e[n]||e[n]===t)),(()=>"The shape of dict['".concat(r.name,"'] provided in ")+"model.execute(dict) must be [".concat(e,"], but was ")+"[".concat(n.shape,"]")))}r.attrParams.dtype&&r.attrParams.dtype.value&&AU(n.dtype===r.attrParams.dtype.value,(()=>"The dtype of dict['".concat(r.name,"'] provided in ")+"model.execute(dict) must be "+"".concat(r.attrParams.dtype.value,", but was ").concat(n.dtype)))}))}mapInputs(e){var t,n;const a={};for(const r in e){const o=null===(n=null===(t=this._signature)||void 0===t?void 0:t.inputs)||void 0===n?void 0:n[r];null!=o?a[o.name]=e[r]:a[r]=e[r]}return a}checkInputs(e){const t=Object.keys(e).filter((e=>{const[t]=Cle(e);return null==this.graph.nodes[t]}));if(t.length>0)throw new Error("The dict provided in model.execute(dict) has "+"keys: [".concat(t,"] that are not part of graph"))}mapOutputs(e){return e.map((e=>{var t,n;const a=null===(n=null===(t=this._signature)||void 0===t?void 0:t.outputs)||void 0===n?void 0:n[e];return null!=a?a.name:e}),{})}checkOutputs(e){e.forEach((e=>{const[t]=Cle(e);if(!this.graph.nodes[t])throw new Error("The output '".concat(e,"' is not found in the graph"))}))}}class Fue{constructor(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};this.hashTableNameToHandle=e,this.hashTableMap=t}addHashTable(e,t){this.hashTableNameToHandle[e]=t.handle,this.hashTableMap[t.id]=t}getHashTableHandleByName(e){return this.hashTableNameToHandle[e]}getHashTableById(e){return this.hashTableMap[e]}dispose(){for(const e in this.hashTableMap)this.hashTableMap[e].clearAndClose(),delete this.hashTableMap[e];for(const e in this.hashTableNameToHandle)this.hashTableNameToHandle[e].dispose(),delete this.hashTableNameToHandle[e]}}const Oue="?tfjs-format=file",Due="model.json";class Mue{get modelVersion(){return this.version}get inputNodes(){return this.executor.inputNodes}get outputNodes(){return this.executor.outputNodes}get inputs(){return this.executor.inputs}get outputs(){return this.executor.outputs}get weights(){return this.executor.weightMap}get metadata(){return this.artifacts.userDefinedMetadata}get modelSignature(){return this.signature}get modelStructuredOutputKeys(){return this.structuredOutputKeys}constructor(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:o;this.modelUrl=e,this.loadOptions=t,this.version="n/a",this.io=n,null==t&&(this.loadOptions={}),this.resourceManager=new Fue}findIOHandler(){const e=this.modelUrl;if(null!=e.load)this.handler=e;else if(null!=this.loadOptions.requestInit)this.handler=this.io.browserHTTPRequest(e,this.loadOptions);else{const t=this.io.getLoadHandlers(e,this.loadOptions);if(0===t.length)t.push(this.io.browserHTTPRequest(e,this.loadOptions));else if(t.length>1)throw new Error("Found more than one (".concat(t.length,") load handlers for ")+"URL '".concat([e],"'"));this.handler=t[0]}}load(){if(this.findIOHandler(),null==this.handler.load)throw new Error("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");const e=this.handler.load();return sG(e)?e.then((e=>null==e.getWeightStream?this.loadSync(e):this.loadStreaming(e))):this.loadSync(e)}loadSync(e){const t=this.io.decodeWeights(e.weightData,e.weightSpecs);return this.loadWithWeightMap(e,t)}async loadStreaming(e){if(null==e.getWeightStream)throw new Error("Model artifacts missing streamWeights function");const t=await pX(e.getWeightStream(),e.weightSpecs);return this.loadWithWeightMap(e,t)}loadWithWeightMap(e,t){this.artifacts=e;const n=this.artifacts.modelTopology;let a=this.artifacts.signature;if(null!=this.artifacts.userDefinedMetadata){const e=this.artifacts.userDefinedMetadata;null!=e.signature&&(a=e.signature),null!=e.structuredOutputKeys&&(this.structuredOutputKeys=e.structuredOutputKeys)}if(this.signature=a,this.version="".concat(n.versions.producer,".").concat(n.versions.minConsumer),this.executor=new Aue(Xle.Instance.transformGraph(n,this.signature)),this.executor.weightMap=this.convertTensorMapToTensorsMap(t),this.executor.resourceManager=this.resourceManager,null!=e.modelInitializer&&null!=e.modelInitializer.node){const t=Xle.Instance.transformGraph(e.modelInitializer);this.initializer=new Aue(t),this.initializer.weightMap=this.executor.weightMap,this.initializer.resourceManager=this.resourceManager,this.initializerSignature=e.initializerSignature}return!0}async save(e,t){if("string"===typeof e){const t=this.io.getSaveHandlers(e);if(0===t.length)throw new Error("Cannot find any save handlers for URL '".concat(e,"'"));if(t.length>1)throw new Error("Found more than one (".concat(t.length,") save handlers for ")+"URL '".concat(e,"'"));e=t[0]}if(null==e.save)throw new Error("GraphModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");return e.save(this.artifacts)}addStructuredOutputNames(e){if(this.structuredOutputKeys){const t={};return(e instanceof bq?[e]:e).forEach(((e,n)=>t[this.structuredOutputKeys[n]]=e)),t}return e}predict(e,t){const n=this.execute(e,this.outputNodes);return this.addStructuredOutputNames(n)}async predictAsync(e,t){const n=await this.executeAsync(e,this.outputNodes);return this.addStructuredOutputNames(n)}normalizeInputs(e){var t;if(!(e instanceof bq)&&!Array.isArray(e)){const n=null===(t=this.signature)||void 0===t?void 0:t.inputs;if(null!=n)for(const t in n){const a=n[t];null!=a.resourceId&&(e[t]=this.resourceIdToCapturedInput[a.resourceId])}return e}e=Array.isArray(e)?e:[e];const n=Object.keys(this.resourceIdToCapturedInput).length;if(e.length+n!==this.inputNodes.length)throw new Error("Input tensor count mismatch, the graph model has ".concat(this.inputNodes.length-n," non-resource placeholders, while there are ").concat(e.length," input tensors provided."));let a=0;return this.inputNodes.reduce(((t,n)=>{var r,o,s;const i=null===(s=null===(o=null===(r=this.signature)||void 0===r?void 0:r.inputs)||void 0===o?void 0:o[n])||void 0===s?void 0:s.resourceId;return t[n]=null!=i?this.resourceIdToCapturedInput[i]:e[a++],t}),{})}normalizeOutputs(e){return e=e||this.outputNodes,Array.isArray(e)?e:[e]}executeInitializerGraph(){return null==this.initializer?[]:null==this.initializerSignature?this.initializer.execute({},[]):this.initializer.execute({},Object.keys(this.initializerSignature.outputs))}async executeInitializerGraphAsync(){return null==this.initializer?[]:null==this.initializerSignature?this.initializer.executeAsync({},[]):this.initializer.executeAsync({},Object.keys(this.initializerSignature.outputs))}setResourceIdToCapturedInput(e){if(this.resourceIdToCapturedInput={},this.initializerSignature){const t=this.initializerSignature.outputs,n=Object.keys(t);for(let a=0;a<n.length;a++){const r=t[n[a]];this.resourceIdToCapturedInput[r.resourceId]=e[a]}}}execute(e,t){null==this.resourceIdToCapturedInput&&this.setResourceIdToCapturedInput(this.executeInitializerGraph()),e=this.normalizeInputs(e),t=this.normalizeOutputs(t);const n=this.executor.execute(e,t);return n.length>1?n:n[0]}async executeAsync(e,t){null==this.resourceIdToCapturedInput&&this.setResourceIdToCapturedInput(await this.executeInitializerGraphAsync()),e=this.normalizeInputs(e),t=this.normalizeOutputs(t);const n=await this.executor.executeAsync(e,t);return n.length>1?n:n[0]}getIntermediateTensors(){return this.executor.getIntermediateTensors()}disposeIntermediateTensors(){this.executor.disposeIntermediateTensors()}convertTensorMapToTensorsMap(e){return Object.keys(e).reduce(((t,n)=>(t[n]=[e[n]],t)),{})}dispose(){this.executor.dispose(),this.initializer&&(this.initializer.dispose(),this.resourceIdToCapturedInput&&aX(this.resourceIdToCapturedInput)),this.resourceManager.dispose()}}async function Lue(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:o;if(null==e)throw new Error("modelUrl in loadGraphModel() cannot be null. Please provide a url or an IOHandler that loads the model");null==t&&(t={}),t.fromTFHub&&"string"===typeof e&&(e=function(e){e.endsWith("/")||(e+="/");return"".concat(e).concat(Due).concat(Oue)}(e));const a=new Mue(e,t,n);return await a.load(),a}function Pue(e,t,n,a){return new(n||(n=Promise))((function(r,o){function s(e){try{c(a.next(e))}catch(D){o(D)}}function i(e){try{c(a.throw(e))}catch(D){o(D)}}function c(e){var t;e.done?r(e.value):(t=e.value,t instanceof n?t:new n((function(e){e(t)}))).then(s,i)}c((a=a.apply(e,t||[])).next())}))}function zue(e,t){var n,a,r,o,s={label:0,sent:function(){if(1&r[0])throw r[1];return r[1]},trys:[],ops:[]};return o={next:i(0),throw:i(1),return:i(2)},"function"===typeof Symbol&&(o[Symbol.iterator]=function(){return this}),o;function i(o){return function(i){return function(o){if(n)throw new TypeError("Generator is already executing.");for(;s;)try{if(n=1,a&&(r=2&o[0]?a.return:o[0]?a.throw||((r=a.return)&&r.call(a),0):a.next)&&!(r=r.call(a,o[1])).done)return r;switch(a=0,r&&(o=[2&o[0],r.value]),o[0]){case 0:case 1:r=o;break;case 4:return s.label++,{value:o[1],done:!1};case 5:s.label++,a=o[1],o=[0];continue;case 7:o=s.ops.pop(),s.trys.pop();continue;default:if(!(r=(r=s.trys).length>0&&r[r.length-1])&&(6===o[0]||2===o[0])){s=0;continue}if(3===o[0]&&(!r||o[1]>r[0]&&o[1]<r[3])){s.label=o[1];break}if(6===o[0]&&s.label<r[1]){s.label=r[1],r=o;break}if(r&&s.label<r[2]){s.label=r[2],s.ops.push(o);break}r[2]&&s.ops.pop(),s.trys.pop();continue}o=t.call(e,s)}catch(D){o=[6,D],a=0}finally{n=r=0}if(5&o[0])throw o[1];return{value:o[0]?o[1]:void 0,done:!0}}([o,i])}}}var Bue=function(e){return{startEndTensor:e,startPoint:oJ(e,[0,0],[-1,2]),endPoint:oJ(e,[0,2],[-1,2])}},Wue={strides:[8,16],anchors:[2,6]};function Vue(e,t){var n,a,r;if(e.topLeft instanceof bq&&e.bottomRight instanceof bq){var o=nX((function(){return[nJ([oJ(RY(t-1,e.topLeft),0,1),oJ(e.topLeft,1,1)]),nJ([RY(t-1,oJ(e.bottomRight,0,1)),oJ(e.bottomRight,1,1)])]}));n=o[0],a=o[1],null!=e.landmarks&&(r=nX((function(){var n=RY(a0([t-1,0]),e.landmarks),a=a0([1,-1]);return mY(n,a)})))}else{var s=e.topLeft,i=s[0],c=s[1],l=e.bottomRight,u=l[0],d=l[1];n=[t-1-i,c],a=[t-1-u,d],null!=e.landmarks&&(r=e.landmarks.map((function(e){return[t-1-e[0],e[1]]})))}var h={topLeft:n,bottomRight:a};return null!=r&&(h.landmarks=r),null!=e.probability&&(h.probability=e.probability instanceof bq?e.probability.clone():e.probability),h}function Uue(e,t){return nX((function(){var n;return n=e.hasOwnProperty("box")?e.box:e,Z$(function(e,t){var n=mY(e.startPoint,t),a=mY(e.endPoint,t),r=vJ([n,a],1);return Bue(r)}(n,t).startEndTensor)}))}var Gue=function(){function e(e,t,n,a,r,o){this.blazeFaceModel=e,this.width=t,this.height=n,this.maxFaces=a,this.anchorsData=function(e,t,n){for(var a=[],r=0;r<n.strides.length;r++)for(var o=n.strides[r],s=Math.floor((t+o-1)/o),i=Math.floor((e+o-1)/o),c=n.anchors[r],l=0;l<s;l++)for(var u=o*(l+.5),d=0;d<i;d++)for(var h=o*(d+.5),p=0;p<c;p++)a.push([h,u]);return a}(t,n,Wue),this.anchors=r0(this.anchorsData),this.inputSizeData=[t,n],this.inputSize=a0([t,n]),this.iouThreshold=r,this.scoreThreshold=o}return e.prototype.getBoundingBoxes=function(e,t,n){return void 0===n&&(n=!0),Pue(this,void 0,void 0,(function(){var a,r,o,s,i,c,l,u,d,h,p,f,m,g,b=this;return zue(this,(function(y){switch(y.label){case 0:return a=nX((function(){var t=W1.resizeBilinear(e,[b.width,b.height]),n=mY(RY(fY(t,255),.5),2),a=b.blazeFaceModel.predict(n),r=Z$(a),o=function(e,t,n){var a=oJ(e,[0,1],[-1,2]),r=hY(a,t),o=oJ(e,[0,3],[-1,2]),s=fY(o,n),i=fY(r,n),c=fY(s,2),l=RY(i,c),u=hY(i,c),d=mY(l,n),h=mY(u,n);return vJ([d,h],1)}(r,b.anchors,b.inputSize),s=oJ(r,[0,0],[-1,1]);return[r,o,Z$(rJ(s))]})),r=a[0],o=a[1],s=a[2],i=console.warn,console.warn=function(){},c=W1.nonMaxSuppression(o,s,this.maxFaces,this.iouThreshold,this.scoreThreshold),console.warn=i,[4,c.array()];case 1:return l=y.sent(),c.dispose(),u=l.map((function(e){return oJ(o,[e,0],[1,-1])})),t?[3,3]:[4,Promise.all(u.map((function(e){return Pue(b,void 0,void 0,(function(){var t;return zue(this,(function(n){switch(n.label){case 0:return[4,e.array()];case 1:return t=n.sent(),e.dispose(),[2,t]}}))}))})))];case 2:u=y.sent(),y.label=3;case 3:for(d=e.shape[1],h=e.shape[2],p=t?fY([h,d],this.inputSize):[h/this.inputSizeData[0],d/this.inputSizeData[1]],f=[],m=function(e){var a=u[e],o=nX((function(){var o=Bue(a instanceof bq?a:r0(a));if(!n)return o;var i,c=l[e];return i=t?oJ(b.anchors,[c,0],[1,2]):b.anchorsData[c],{box:o,landmarks:$Q(Z$(oJ(r,[c,5],[1,-1])),[6,-1]),probability:oJ(s,[c],[1]),anchor:i}}));f.push(o)},g=0;g<u.length;g++)m(g);return o.dispose(),s.dispose(),r.dispose(),[2,{boxes:f,scaleFactor:p}]}}))}))},e.prototype.estimateFaces=function(e,t,n,a){return void 0===t&&(t=!1),void 0===n&&(n=!1),void 0===a&&(a=!0),Pue(this,void 0,void 0,(function(){var r,o,s,i,c,l,u=this;return zue(this,(function(d){switch(d.label){case 0:return r=function(e){return e instanceof bq?[e.shape[0],e.shape[1]]:[e.height,e.width]}(e),o=r[1],s=nX((function(){return e instanceof bq||(e=sQ(e)),cZ(lY(e,"float32"),0)})),[4,this.getBoundingBoxes(s,t,a)];case 1:return i=d.sent(),c=i.boxes,l=i.scaleFactor,s.dispose(),t?[2,c.map((function(e){var t=Uue(e,l),r={topLeft:oJ(t,[0],[2]),bottomRight:oJ(t,[2],[2])};if(a){var s=e,i=s.landmarks,c=s.probability,u=s.anchor,d=mY(hY(i,u),l);r.landmarks=d,r.probability=c}return n&&(r=Vue(r,o)),r}))]:[2,Promise.all(c.map((function(e){return Pue(u,void 0,void 0,(function(){var t,r,s,i,c,u,d,h,p,f,m,g=this;return zue(this,(function(b){switch(b.label){case 0:return t=Uue(e,l),a?[3,2]:[4,t.array()];case 1:return c=b.sent(),r={topLeft:c.slice(0,2),bottomRight:c.slice(2)},[3,4];case 2:return[4,Promise.all([e.landmarks,t,e.probability].map((function(e){return Pue(g,void 0,void 0,(function(){return zue(this,(function(t){return[2,e.array()]}))}))})))];case 3:s=b.sent(),i=s[0],c=s[1],u=s[2],d=e.anchor,p=(h=l)[0],f=h[1],m=i.map((function(e){return[(e[0]+d[0])*p,(e[1]+d[1])*f]})),r={topLeft:c.slice(0,2),bottomRight:c.slice(2),landmarks:m,probability:u},(y=e.box).startEndTensor.dispose(),y.startPoint.dispose(),y.endPoint.dispose(),e.landmarks.dispose(),e.probability.dispose(),b.label=4;case 4:return t.dispose(),n&&(r=Vue(r,o)),[2,r]}var y}))}))})))]}}))}))},e.prototype.dispose=function(){this.blazeFaceModel.dispose(),this.anchors.dispose(),this.inputSize.dispose()},e}();const Hue=(0,A.forwardRef)(((e,t)=>{let{videoId:n,canvasId:a,onFacesDetected:r,frameColor:o,receivePedictions:s,setInfo:i}=e;const c=(0,A.useRef)(null),l=(0,A.useRef)(null),u=(0,A.useRef)(),[d,h]=(0,A.useState)(null);(0,A.useImperativeHandle)(t,(()=>({stopFaceRecognition:b,startFaceRecognition:y})));const p=async()=>{await f();const e=await function(e){var t=void 0===e?{}:e,n=t.maxFaces,a=void 0===n?10:n,r=t.inputWidth,o=void 0===r?128:r,s=t.inputHeight,i=void 0===s?128:s,c=t.iouThreshold,l=void 0===c?.3:c,u=t.scoreThreshold,d=void 0===u?.75:u,h=t.modelUrl;return Pue(this,void 0,void 0,(function(){var e;return zue(this,(function(t){switch(t.label){case 0:return null==h?[3,2]:[4,Lue(h)];case 1:return e=t.sent(),[3,4];case 2:return[4,Lue("https://tfhub.dev/tensorflow/tfjs-model/blazeface/1/default/1",{fromTFHub:!0})];case 3:e=t.sent(),t.label=4;case 4:return[2,new Gue(e,o,i,a,l,d)]}}))}))}();m(e)},f=async()=>{try{await Bu("webgl")}catch(e){await Bu("cpu")}await yu.ready()},m=async e=>{if(c.current&&c.current.readyState>=2){const t=c.current,n=await e.estimateFaces(t);h(n),r&&r(n),g(n)}u.current=requestAnimationFrame((()=>m(e)))},g=e=>{const t=l.current.getContext("2d");t.clearRect(0,0,l.current.width,l.current.height),t.drawImage(c.current,0,0,l.current.width,l.current.height),e.forEach((e=>{const[n,a,r,s]=e.topLeft.concat(e.bottomRight);t.strokeStyle=o,t.lineWidth=2,t.strokeRect(n,a,r-n,s-a)}))},b=()=>{if(c.current.srcObject){c.current.srcObject.getTracks().forEach((e=>e.stop()))}return u.current&&cancelAnimationFrame(u.current),d},y=async()=>{await(async()=>{const e=await navigator.mediaDevices.getUserMedia({video:{facingMode:"user"}});c.current.srcObject=e,c.current.onloadedmetadata=()=>{c.current.play(),l.current.width=c.current.videoWidth,l.current.height=c.current.videoHeight}})(),await p()};return(0,A.useEffect)((()=>()=>{u.current&&cancelAnimationFrame(u.current),b()}),[]),(0,Rn.jsxs)(Rn.Fragment,{children:[(0,Rn.jsx)("video",{ref:c,id:n,autoPlay:!0,muted:!0,className:"absolute inset-0 h-full w-full object-contain"}),(0,Rn.jsx)("canvas",{ref:l,id:a,className:"absolute inset-0 h-full w-full object-contain"})]})})),jue=Hue;const Kue=function(){const e=Zr(),{theme:t}=Wr((e=>e.main)),n=(0,A.useRef)(),a=(0,A.useRef)(),[r,o]=(0,A.useState)(!0),[s,i]=(0,A.useState)(!0),[c,l]=(0,A.useState)(null),[u,d]=(0,A.useState)(null),h=(e,t,n,a)=>{if(e.current)if(t)e.current.startFaceRecognition(),n(!1);else{const t=e.current.stopFaceRecognition();console.log(t),console.log(JSON.stringify(t)),a(t),n(!0)}},p=(e,t)=>{e.length},f=(e,t)=>{if(null===e||void 0===e||!e.length||null===t||void 0===t||!t.length)return 0;const n=e=>{const t=e.bottomRight[0]-e.topLeft[0],n=e.bottomRight[1]-e.topLeft[1];return{width:t,height:n,centerX:e.topLeft[0]+t/2,centerY:e.topLeft[1]+n/2}},a=n(e[0]),r=n(t[0]),o=Math.min(a.width/r.width,r.width/a.width)*Math.min(a.height/r.height,r.height/a.height),s=Math.abs(a.centerX-r.centerX),i=Math.abs(a.centerY-r.centerY),c=Math.sqrt(Math.pow(Math.max(a.width,r.width),2)+Math.pow(Math.max(a.height,r.height),2)),l=o*(1-Math.sqrt(Math.pow(s,2)+Math.pow(i,2))/c)*100;return l<80?0:l};(0,A.useEffect)((()=>{const e=async(e,t,n)=>{if(e.current)try{await e.current.startFaceRecognition(),t(!1)}catch(a){console.error("Failed to start ".concat(n," recognition"),a),Ne.error("Unable to access the camera. Please allow permissions.")}};e(n,o,"first"),e(a,i,"second")}),[]),(0,A.useEffect)((()=>{"undefined"!==typeof window&&"undefined"!==typeof document&&(document.documentElement.classList.toggle("dark","dark"===t),window.localStorage.setItem("theme",t))}),[t]);const m="inline-flex items-center justify-center gap-2 rounded-full bg-indigo-600 px-5 py-2.5 text-sm font-semibold text-white shadow-sm shadow-indigo-500/30 transition hover:-translate-y-0.5 hover:bg-indigo-500 hover:shadow-indigo-500/40 focus-visible:outline focus-visible:outline-2 focus-visible:outline-offset-2 focus-visible:outline-indigo-500 active:translate-y-0 disabled:cursor-not-allowed disabled:opacity-60 dark:bg-indigo-500 dark:hover:bg-indigo-400",g="relative aspect-video w-full max-w-md overflow-hidden rounded-2xl border border-slate-200/70 bg-white/80 shadow-sm shadow-slate-200/70 backdrop-blur-sm dark:border-slate-700 dark:bg-slate-800/60 dark:shadow-none";return(0,Rn.jsx)(Rn.Fragment,{children:(0,Rn.jsxs)("div",{className:"flex min-h-screen flex-col bg-slate-50 text-slate-900 dark:bg-slate-900 dark:text-slate-100",children:[(0,Rn.jsx)(Xe,{position:"top-right"}),(0,Rn.jsx)(An,{title:"Face Recognitions Demos",handleThemeChange:()=>{e(vr("light"===t?"dark":"light"))},theme:t}),(0,Rn.jsxs)("div",{className:"flex flex-col items-center gap-3 px-4 py-6 text-center",children:[(0,Rn.jsxs)("div",{className:"max-w-3xl space-y-3 text-sm leading-relaxed text-slate-600 dark:text-slate-300",children:[(0,Rn.jsx)("p",{children:"This app is a playground for experimenting with TensorFlow-based face recognition, showing how live video streams are analyzed and translated into detection data in real time."}),(0,Rn.jsx)("p",{children:"It is intentionally set up for rapid iteration, with the idea of expanding beyond faces into voice recognition and other biometric signals as the next step."})]}),(0,Rn.jsx)("button",{className:m,onClick:async()=>{if(!c||!u)return void Ne.error("Finish both detections first, then press Stop Recognition on each video to capture results.");const e=await Ne.promise(Promise.resolve(f(c,u)),{loading:"Comparing face frames...",success:"Comparison complete.",error:"Comparison failed. Please try again."}),t=Number(e).toFixed(1),n=e>=80?"Strong match: ".concat(t,"% similarity."):"Low match: ".concat(t,"% similarity.");Ne(n,{icon:e>=80?"\u2705":"\u2139\ufe0f"})},children:"Compare Faces"})]}),(0,Rn.jsxs)("div",{className:"flex flex-1 flex-col gap-6 px-4 pb-8 lg:flex-row",children:[(0,Rn.jsxs)("div",{className:"flex w-full flex-col items-center gap-4 lg:w-1/2",children:[(0,Rn.jsx)("div",{className:"flex w-full flex-col gap-2 sm:flex-row sm:justify-center",children:(0,Rn.jsxs)("button",{className:"".concat(m," w-full sm:w-auto"),onClick:()=>h(n,r,o,l),children:[r?"Start":"Stop"," Recognition 1"]})}),(0,Rn.jsx)("div",{className:"".concat(g," mx-auto"),children:(0,Rn.jsx)(jue,{ref:n,videoId:"video1",canvasId:"canvas1",frameColor:"aqua",receivePedictions:p,setInfo:l})})]}),(0,Rn.jsxs)("div",{className:"flex w-full flex-col items-center gap-4 lg:w-1/2",children:[(0,Rn.jsx)("div",{className:"flex w-full flex-col gap-2 sm:flex-row sm:justify-center",children:(0,Rn.jsxs)("button",{className:"".concat(m," w-full sm:w-auto"),onClick:()=>h(a,s,i,d),children:[s?"Start":"Stop"," Recognition 2"]})}),(0,Rn.jsx)("div",{className:"".concat(g," mx-auto"),children:(0,Rn.jsx)(jue,{ref:a,videoId:"video2",canvasId:"canvas2",frameColor:"red",receivePedictions:p,setInfo:d})})]})]})]})})},que=e=>{e&&e instanceof Function&&n.e(453).then(n.bind(n,453)).then((t=>{let{getCLS:n,getFID:a,getFCP:r,getLCP:o,getTTFB:s}=t;n(e),a(e),r(e),o(e),s(e)}))},Xue=function(e){const t=function(e){const{thunk:t=!0,immutableCheck:n=!0,serializableCheck:a=!0,actionCreatorCheck:r=!0}=null!==e&&void 0!==e?e:{};let o=new Ka;return t&&("boolean"===typeof t?o.push(Ua):o.push(Ga(t.extraArgument))),o},{reducer:n,middleware:a,devTools:r=!0,preloadedState:o,enhancers:s}=e||{};let i,c;if("function"===typeof n)i=n;else{if(!Pa(n))throw new Error(br(1));i=Ba(n)}c="function"===typeof a?a(t):t();let l=Wa;r&&(l=Ha({trace:!1,..."object"===typeof r&&r}));const u=function(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];return e=>(n,a)=>{const r=e(n,a);let o=()=>{throw new Error(Oa(15))};const s={getState:r.getState,dispatch:function(e){for(var t=arguments.length,n=new Array(t>1?t-1:0),a=1;a<t;a++)n[a-1]=arguments[a];return o(e,...n)}},i=t.map((e=>e(s)));return o=Wa(...i)(r.dispatch),{...r,dispatch:o}}}(...c),d=Za(u);let h="function"===typeof s?s(d):d();return za(i,o,l(...h))}({reducer:{main:Tr},devTools:!1});F.createRoot(document.getElementById("root")).render((0,Rn.jsx)(A.StrictMode,{children:(0,Rn.jsx)(qr,{store:Xue,children:(0,Rn.jsx)(Kue,{})})})),que()})()})();
//# sourceMappingURL=main.73d223a9.js.map